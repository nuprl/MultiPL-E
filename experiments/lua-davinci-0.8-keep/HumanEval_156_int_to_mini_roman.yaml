name: HumanEval_156_int_to_mini_roman
language: lua
prompt: "-- Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  -- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n-- Examples:\n\
  -- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152) == 'clii'\n\
  -- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
  \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
  \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
  \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
  \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
  \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
  \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
  \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
  \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    assert(number >= 1 and number <= 1000, \"number out of range\"\
    )\n    local table = {\n        \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"\
    L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\n    }\n    local values = {1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    local result = \"\"\n \
    \   local i = 1\n    while number > 0 do\n        local count = math.floor(number\
    \ / values[i])\n        number = number - count * values[i]\n        while count\
    \ > 0 do\n            result = result .. table[i]\n            count = count -\
    \ 1\n        end\n        i = i + 1\n    end\n    return result\nend", "    local\
    \ numerals = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv',\
    \ 'i'}\n    local decimal = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4,\
    \ 1}\n    local result = ''\n    for i, v in ipairs(decimal) do\n        while\
    \ number >= v do\n            result = result .. numerals[i]\n            number\
    \ = number - v\n        end\n    end\n    return result\nend", "  assert(1 <=\
    \ number and number <= 1000, \"roman number out of range\")\n  local numeral =\
    \ \"\"\n  local digits = {1, 2, 3, 4, 5, 6, 7, 8, 9}\n  local symbols = {\n  \
    \  {1, \"i\"},\n    {5, \"v\"},\n    {10, \"x\"},\n    {50, \"l\"},\n    {100,\
    \ \"c\"},\n    {500, \"d\"},\n    {1000, \"m\"}\n  }\n  local digit_symbols =\
    \ {}\n  for _, v in ipairs(symbols) do\n    digit_symbols[v[1]] = v[2]\n  end\n\
    \  local function base_ten_to_roman(number, base)\n    local roman = \"\"\n  \
    \  local digit = math.floor(number / base)\n    if digit == 4 then\n      roman\
    \ = roman .. digit_symbols[base] .. digit_symbols[base * 5]\n    elseif digit\
    \ == 9 then\n      roman = roman .. digit_symbols[base] .. digit_symbols[base\
    \ * 10]\n    else\n      if digit >= 5 then\n        roman = roman .. digit_symbols[base\
    \ * 5]\n        digit = digit - 5\n      end\n      for _ = 1, digit do\n    \
    \    roman = roman .. digit_symbols[base]\n      end\n    end\n    return roman\n\
    \  end\n  for _, v in ipairs(digits) do\n    numeral = numeral .. base_ten_to_roman(number,\
    \ 10 ^ (v - 1))\n    number = number % (10 ^ (v - 1))\n  end\n  return numeral\n\
    end", "    if number <= 0 or number > 1000 then\n        return ''\n    end\n\
    \    local roman = ''\n    local values = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400,\
    \ 500, 900, 1000}\n    local numerals = {'i', 'iv', 'v', 'ix', 'x', 'xl', 'l',\
    \ 'xc', 'c', 'cd', 'd', 'cm', 'm'}\n    while number > 0 do\n        local index\
    \ = 13\n        while values[index] > number do\n            index = index - 1\n\
    \        end\n        number = number - values[index]\n        roman = roman ..\
    \ numerals[index]\n    end\n    return roman\nend", "  local function int_to_mini_roman_rec(number,\
    \ result)\n    if number == 0 then\n      return result\n    elseif number ==\
    \ 4 then\n      return int_to_mini_roman_rec(0, 'iv' .. result)\n    elseif number\
    \ == 9 then\n      return int_to_mini_roman_rec(0, 'ix' .. result)\n    elseif\
    \ number >= 5 then\n      return int_to_mini_roman_rec(number - 5, 'v' .. result)\n\
    \    else\n      return int_to_mini_roman_rec(number - 1, 'i' .. result)\n   \
    \ end\n  end\n  assert(number >= 1 and number <= 1000)\n  return int_to_mini_roman_rec(number,\
    \ '')\nend", "  local romans = { 'm', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x',\
    \ 'ix', 'v', 'iv', 'i' }\n  local numbers = { 1000, 900, 500, 400, 100, 90, 50,\
    \ 40, 10, 9, 5, 4, 1 }\n  local str = ''\n  local n = number\n  while n > 0 do\n\
    \    for k, v in ipairs(numbers) do\n      while n >= v do\n        str = str\
    \ .. romans[k]\n        n = n - v\n      end\n    end\n  end\n  return str\nend",
  "    local units = {\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\"}\n    local tens = {\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"}\n    local hundreds = {\"\", \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"}\n    local thousands\
    \ = {\"\", \"m\", \"mm\", \"mmm\"}\n    return thousands[floor(number / 1000)\
    \ + 1] .. hundreds[floor(number / 100) % 10 + 1] .. tens[floor(number / 10) %\
    \ 10 + 1] .. units[number % 10 + 1]\nend", "    local mini_roman_numerals = {\n\
    \        \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"\
    ix\",\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\",\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\",\n        \"m\", \"mm\", \"mmm\", \"mmv\", \"mv\", \"mvi\", \"\
    mvii\", \"mviii\", \"mix\"\n    }\n    return mini_roman_numerals[number]\nend",
  "  assert(number > 0 and number <= 1000, \"Number is out of bounds\")\n  if number\
    \ == 1000 then return \"m\" end\n  local result = \"\"\n  local values = {1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n  local numerals = {\"m\",\
    \ \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"\
    iv\", \"i\"}\n  for i = 1, #values do\n    while number >= values[i] do\n    \
    \  number = number - values[i]\n      result = result .. numerals[i]\n    end\n\
    \  end\n  return result\nend", "    local roman = {'m', 'cm', 'd', 'cd', 'c',\
    \ 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i'}\n    local values = {1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    local result = \"\"\n    local\
    \ i = 1\n    while number > 0 do\n        local div = math.floor(number / values[i])\n\
    \        number = number % values[i]\n        while div > 0 do\n            result\
    \ = result .. roman[i]\n            div = div - 1\n        end\n        i = i\
    \ + 1\n    end\n    return result\nend", "\tlocal integers = { 1000, 900, 500,\
    \ 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }\n\tlocal numerals = { 'm', 'cm', 'd',\
    \ 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i' }\n\tlocal numeral = \"\
    \"\n\tlocal count = 1\n\twhile number > 0 do\n\t\twhile number >= integers[count]\
    \ do\n\t\t\tnumeral = numeral .. numerals[count]\n\t\t\tnumber = number - integers[count]\n\
    \t\tend\n\t\tcount = count + 1\n\tend\n\treturn numeral\nend", "  local roman_number\
    \ = \"\"\n  local remaining = number\n  for value, numeral in pairs(roman_numerals)\
    \ do\n    local times = math.floor(remaining / value)\n    remaining = remaining\
    \ - (times * value)\n    for i = 1, times do\n      roman_number = roman_number\
    \ .. numeral\n    end\n  end\n  return roman_number\nend", "\tlocal m = {\n\t\t\
    {1000, 'm'},\n\t\t{900, 'cm'},\n\t\t{500, 'd'},\n\t\t{400, 'cd'},\n\t\t{100, 'c'},\n\
    \t\t{90, 'xc'},\n\t\t{50, 'l'},\n\t\t{40, 'xl'},\n\t\t{10, 'x'},\n\t\t{9, 'ix'},\n\
    \t\t{5, 'v'},\n\t\t{4, 'iv'},\n\t\t{1, 'i'}\n\t}\n\tlocal res = ''\n\tfor i =\
    \ 1, #m do\n\t\twhile number >= m[i][1] do\n\t\t\tres = res .. m[i][2]\n\t\t\t\
    number = number - m[i][1]\n\t\tend\n\tend\n\treturn res\nend", "  local romans\
    \ = {\n    {'i', 'v'}, {'x', 'l'}, {'c', 'd'}, {'m'}\n  }\n  local rom = {}\n\
    \  local thousands = math.floor(number / 1000)\n  number = number % 1000\n  if\
    \ thousands > 0 then\n    rom[#rom + 1] = string.rep('m', thousands)\n  end\n\
    \  local hundreds = math.floor(number / 100)\n  number = number % 100\n  if hundreds\
    \ > 0 then\n    if hundreds == 9 then\n      rom[#rom + 1] = romans[3][1] .. romans[4][1]\n\
    \    elseif hundreds == 4 then\n      rom[#rom + 1] = romans[3][1] .. romans[3][2]\n\
    \    else\n      local fives = math.floor(hundreds / 5)\n      hundreds = hundreds\
    \ % 5\n      if fives > 0 then\n        rom[#rom + 1] = romans[3][2]\n      end\n\
    \      if hundreds > 0 then\n        rom[#rom + 1] = string.rep(romans[3][1],\
    \ hundreds)\n      end\n    end\n  end\n  local tens = math.floor(number / 10)\n\
    \  number = number % 10\n  if tens > 0 then\n    if tens == 9 then\n      rom[#rom\
    \ + 1] = romans[2][1] .. romans[3][1]\n    elseif tens == 4 then\n      rom[#rom\
    \ + 1] = romans[2][1] .. romans[2][2]\n    else\n      local fives = math.floor(tens\
    \ / 5)\n      tens = tens % 5\n      if fives > 0 then\n        rom[#rom + 1]\
    \ = romans[2][2]\n      end\n      if tens > 0 then\n        rom[#rom + 1] = string.rep(romans[2][1],\
    \ tens)\n      end\n    end\n  end\n  if number > 0 then\n    if number == 9 then\n\
    \      rom[#rom + 1] = romans[1][1] .. romans[2][1]\n    elseif number == 4 then\n\
    \     ", "    assert(number >= 1 and number <= 1000,\n           'int_to_mini_roman\
    \ called with number out of range!')\n    -- Do something with number\n    --\
    \ Hint: You may want to use the table of mini roman digits in the\n    -- variable\
    \ mini_roman_digits\n    -- ...", "    local numerals = {}\n    local symbols\
    \ = {{'m', 1000}, {'d', 500}, {'c', 100}, {'l', 50}, {'x', 10}, {'v', 5}, {'i',\
    \ 1}}\n    local min_numeral, min_number = '', 0\n    for index, symbol in ipairs(symbols)\
    \ do\n        local numeral, number = symbol[1], symbol[2]\n        if number\
    \ > number - min_number then\n            local value = (number - min_number)\
    \ - min_number\n            min_numeral, min_number = numeral, number\n      \
    \      if value > 0 then\n                numeral = numeral .. min_numeral\n \
    \               number = value\n            end\n        end\n        while number\
    \ > 0 do\n            table.insert(numerals, numeral)\n            number = number\
    \ - number\n        end\n    end\n    return string.lower(table.concat(numerals))\n\
    end", "  if number > 1000 then\n    error(\"Number is greater than 1000\")\n \
    \ end\n  local romans = {\n    ['M'] = 1000,\n    ['CM'] = 900,\n    ['D'] = 500,\n\
    \    ['CD'] = 400,\n    ['C'] = 100,\n    ['XC'] = 90,\n    ['L'] = 50,\n    ['XL']\
    \ = 40,\n    ['X'] = 10,\n    ['IX'] = 9,\n    ['V'] = 5,\n    ['IV'] = 4,\n \
    \   ['I'] = 1\n  }\n  local res = ''\n  for k, v in pairs(romans) do\n    while\
    \ number >= v do\n      res = res .. k\n      number = number - v\n    end\n \
    \ end\n  return res\nend", "  assert(type(number) == 'number' and number >= 1\
    \ and number <= 1000,\n         'Invalid input')\n  local romans = {'m', 'cm',\
    \ 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v',\n                  'iv', 'i'}\n\
    \  local nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n  local\
    \ result = ''\n  for i = 1, #nums do\n    while number >= nums[i] do\n      result\
    \ = result .. romans[i]\n      number = number - nums[i]\n    end\n  end\n  return\
    \ result\nend", "    local int_to_mini_roman_mapping = {\n        [1]  = 'i',\n\
    \        [5]  = 'v',\n        [10] = 'x',\n        [50] = 'l',\n        [100]\
    \ = 'c',\n        [500] = 'd',\n        [1000] = 'm',\n    }\n    local mini_roman_number\
    \ = ''\n    for numeral, roman in pairs(int_to_mini_roman_mapping) do\n      \
    \  local n = number % (numeral * 10)\n        number = (number - n) / 10\n   \
    \     mini_roman_number = mini_roman_number .. string.rep(roman, n / numeral)\n\
    \    end\n    return mini_roman_number\nend", "    -- If nothing, then return\
    \ nothing.\n    if number == 0 then\n        return \"\"\n    end", "    local\
    \ s = \"\"\n    local roman = {\n        {'m', 1000},\n        {'cm', 900},\n\
    \        {'d', 500},\n        {'cd', 400},\n        {'c', 100},\n        {'xc',\
    \ 90},\n        {'l', 50},\n        {'xl', 40},\n        {'x', 10},\n        {'ix',\
    \ 9},\n        {'v', 5},\n        {'iv', 4},\n        {'i', 1}\n    }\n    for\
    \ i, v in ipairs(roman) do\n        local n = math.floor(number / v[2])\n    \
    \    s = s .. string.rep(v[1], n)\n        number = number - (n * v[2])\n    end\n\
    \    return s\nend", "    local number_map = {\n        {1000, 'm'},\n       \
    \ {900, 'cm'},\n        {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n\
    \        {90, 'xc'},\n        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n\
    \        {9, 'ix'},\n        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n\
    \    }\n    local roman = ''\n    for _,number_pair in ipairs(number_map) do\n\
    \        while number >= number_pair[1] do\n            roman = roman .. number_pair[2]\n\
    \            number = number - number_pair[1]\n        end\n    end\n    return\
    \ roman\nend", "    local roman_table = {{\"m\", 1000}, {\"cm\", 900}, {\"d\"\
    , 500}, {\"cd\", 400},\n        {\"c\", 100}, {\"xc\", 90}, {\"l\", 50}, {\"xl\"\
    , 40}, {\"x\", 10}, {\"ix\", 9},\n        {\"v\", 5}, {\"iv\", 4}, {\"i\", 1}}\n\
    \    local result = \"\"\n    for i = 1, #roman_table do\n        local key, value\
    \ = roman_table[i][1], roman_table[i][2]\n        while number >= value do\n \
    \           result = result .. key\n            number = number - value\n    \
    \    end\n    end\n    return result\nend", "    local result = \"\"\n    local\
    \ digits = { 'm', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv',\
    \ 'i' }\n    local values = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5,\
    \ 4, 1 }\n    for index, value in ipairs(values) do\n        local count = number\
    \ / value\n        if count >= 1 then\n            result = result .. string.rep(digits[index],\
    \ count)\n            number = number - value * count\n        end\n    end\n\
    \    return result\nend", "    local numerals = {\n        {1000, 'm'},\n    \
    \    {500, 'd'},\n        {100, 'c'},\n        {50, 'l'},\n        {10, 'x'},\n\
    \        {5, 'v'},\n        {1, 'i'}\n    }\n    local mini_roman = ''\n    for\
    \ i, t in ipairs(numerals) do\n        local numeral = t[2]\n        local count\
    \ = math.floor(number / t[1])\n        mini_roman = mini_roman .. string.rep(numeral,\
    \ count)\n        number = number % t[1]\n    end\n    return mini_roman\nend",
  "  local roman_numerals = {\n    ['M'] = 1000,\n    ['CM'] = 900,\n    ['D'] = 500,\n\
    \    ['CD'] = 400,\n    ['C'] = 100,\n    ['XC'] = 90,\n    ['L'] = 50,\n    ['XL']\
    \ = 40,\n    ['X'] = 10,\n    ['IX'] = 9,\n    ['V'] = 5,\n    ['IV'] = 4,\n \
    \   ['I'] = 1\n  }\n  local letters = ''\n  local roman_numerals_keys = {'M',\
    \ 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'}\n  for k,\
    \ v in ipairs(roman_numerals_keys) do\n    while (number >= roman_numerals[v])\
    \ do\n      number = number - roman_numerals[v]\n      letters = letters .. v\n\
    \    end\n  end\n  return letters\nend", "    if number <= 1000 then\n       \
    \ local result = ''\n        for i = 1, #_MINI_ROMAN_DIGITS do\n            local\
    \ digit, digit_str = math.floor(number / _MINI_ROMAN_DIGITS[i]), _MINI_ROMAN_DIGITS[i]\n\
    \            if digit > 0 then\n                result = result .. digit_str:rep(digit)\n\
    \                number = number - digit * _MINI_ROMAN_DIGITS[i]\n           \
    \ end\n        end\n        return result\n    end\nend", "    -- TODO: Implement\
    \ this function\n    return ''\nend", "  assert(number >= 1 and number <= 1000,\
    \ 'Invalid number: ' .. number)\n  local result = {}\n  for _, v in ipairs(mini_roman_numeral_conversions)\
    \ do\n    while number >= v[1] do\n      table.insert(result, v[2])\n      number\
    \ = number - v[1]\n    end\n  end\n  return table.concat(result)\nend", "\tassert(number\
    \ >= 1 and number <= 1000, 'Invalid mini-roman number')\n\tlocal result = ''\n\
    \tfor _, d in ipairs(int_to_digits(number)) do\n\t\tlocal roman_digits = {'',\
    \ 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix'}\n\t\tresult = result\
    \ .. roman_digits[d + 1]\n\tend\n\treturn result\nend", "    local result = ''\n\
    \    local constants = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix',\
    \ 'v', 'iv', 'i'}\n    local values = {1000, 900, 500, 400, 100, 90, 50, 40, 10,\
    \ 9, 5, 4, 1}\n    for index, constant in ipairs(constants) do\n        while\
    \ number >= values[index] do\n            result = result .. constant\n      \
    \      number = number - values[index]\n        end\n    end\n    return result\n\
    end", "\tassert(number >= 1 and number <= 1000, \"Number must be in the range\
    \ [1, 1000]\")\n\tlocal result = \"\"\n\twhile number > 0 do\n\t\tlocal digit\
    \ = number % 10\n\t\tif digit == 4 then\n\t\t\tresult = mini_roman_subs[(number\
    \ - 4) / 10 + 1] .. result\n\t\telseif digit == 9 then\n\t\t\tresult = mini_roman_subs[(number\
    \ - 9) / 10 + 1] .. mini_roman_subs[(number - 9) / 10 + 2] .. result\n\t\telse\n\
    \t\t\tif digit >= 5 then\n\t\t\t\tresult = mini_roman_subs[(number - 5) / 10 +\
    \ 2] .. result\n\t\t\t\tdigit = digit - 5\n\t\t\tend\n\t\t\tresult = result ..\
    \ mini_roman_subs[(number - digit) / 10 + 1]:rep(digit)\n\t\tend\n\t\tnumber =\
    \ (number - digit) / 10\n\tend\n\treturn result\nend", "  local ones = {'i', 'ii',\
    \ 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix'}\n  local tens = {'x', 'xx', 'xxx',\
    \ 'xl', 'l', 'lx', 'lxx', 'lxxx', 'xc'}\n  local hundreds = {'c', 'cc', 'ccc',\
    \ 'cd', 'd', 'dc', 'dcc', 'dccc', 'cm'}\n  local thousands = {'m', 'mm', 'mmm'}\n\
    \  local result = \"\"\n  if number >= 1000 then\n    result = result .. thousands[math.floor(number\
    \ / 1000)]\n    number = number % 1000\n  end\n  if number >= 100 then\n    result\
    \ = result .. hundreds[math.floor(number / 100)]\n    number = number % 100\n\
    \  end\n  if number >= 10 then\n    result = result .. tens[math.floor(number\
    \ / 10)]\n    number = number % 10\n  end\n  if number >= 1 then\n    result =\
    \ result .. ones[number]\n  end\n  return result\nend", "    local nums = {\n\
    \        {'i', 'v'},\n        {'x', 'l'},\n        {'c', 'd'},\n        {'m'}\n\
    \    }\n    local result = ''\n    local digit = 0\n    while number > 0 do\n\
    \        local ones = number % 10\n        local tens = (number % 100) / 10\n\
    \        local hundreds = (number % 1000) / 100\n        local thousands = number\
    \ / 1000\n        number = number - 1000 * thousands\n        if thousands > 0\
    \ then\n            for i = 1, thousands do\n                result = result ..\
    \ 'm'\n            end\n        end\n        local a = 1\n        local b = 2\n\
    \        local c = 3\n        if digit == 1 then\n            a = 2\n        \
    \    b = 3\n            c = 4\n        end\n        if ones == 4 then\n      \
    \      result = result .. nums[a][1] .. nums[b][2]\n        elseif ones == 9 then\n\
    \            result = result .. nums[a][1] .. nums[c][1]\n        elseif ones\
    \ > 4 then\n            result = result .. nums[b][2]\n            for i = 1,\
    \ ones - 5 do\n                result = result .. nums[a][1]\n            end\n\
    \        else\n            for i = 1, ones do\n                result = result\
    \ .. nums[a][1]\n            end\n        end\n        digit = digit + 1\n   \
    \     number = number - 10 * tens\n    end\n    return result\nend", "    local\
    \ m = {\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    }\n\
    \    local r = {\n        'm', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix',\
    \ 'v', 'iv', 'i'\n    }\n    local output = ''\n    for i = 1, #m do\n       \
    \ local q = math.floor(number / m[i])\n        number = number - q * m[i]\n  \
    \      output = output .. r[i]:rep(q)\n    end\n    return output\nend", "  if\
    \ number > 1000 then\n    return nil\n  end\n  local mini_roman_numerals = {\n\
    \    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n    {400, 'cd'},\n    {100,\
    \ 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n  \
    \  {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1, 'i'}\n  }\n  local output\
    \ = \"\"\n  for i = 1, #mini_roman_numerals do\n    while number >= mini_roman_numerals[i][1]\
    \ do\n      output = output .. mini_roman_numerals[i][2]\n      number = number\
    \ - mini_roman_numerals[i][1]\n    end\n  end\n  return output\nend", "  local\
    \ arabic_to_roman = {\n    [1] = 'i',\n    [2] = 'ii',\n    [3] = 'iii',\n   \
    \ [4] = 'iv',\n    [5] = 'v',\n    [6] = 'vi',\n    [7] = 'vii',\n    [8] = 'viii',\n\
    \    [9] = 'ix',\n    [10] = 'x',\n    [20] = 'xx',\n    [30] = 'xxx',\n    [40]\
    \ = 'xl',\n    [50] = 'l',\n    [60] = 'lx',\n    [70] = 'lxx',\n    [80] = 'lxxx',\n\
    \    [90] = 'xc',\n    [100] = 'c',\n    [200] = 'cc',\n    [300] = 'ccc',\n \
    \   [400] = 'cd',\n    [500] = 'd',\n    [600] = 'dc',\n    [700] = 'dcc',\n \
    \   [800] = 'dccc',\n    [900] = 'cm',\n    [1000] = 'm',\n  }\n  local roman\
    \ = ''\n  local remainder = number\n  if remainder >= 1000 then\n    local n =\
    \ math.floor(remainder / 1000)\n    remainder = remainder - n * 1000\n    roman\
    \ = roman .. string.rep(arabic_to_roman[1000], n)\n  end\n  if remainder >= 900\
    \ then\n    remainder = remainder - 900\n    roman = roman .. arabic_to_roman[900]\n\
    \  end\n  if remainder >= 500 then\n    remainder = remainder - 500\n    roman\
    \ = roman .. arabic_to_roman[500]\n  end\n  if remainder >= 400 then\n    remainder\
    \ = remainder - 400\n    roman = roman .. arabic_to_roman[400]\n  end\n  if remainder\
    \ >= 100 then\n    local n = math.floor(remainder / 100)\n    remainder = remainder\
    \ - n * 100\n    roman = roman .. string.rep(arabic_to_roman[100], n)\n  end\n",
  "    if number <= 0 or number > 1000 then\n        error(\"number out of range\"\
    )\n    end\n    local result = ''\n    while number > 0 do\n        local value\
    \ = _miniroman_values[number % 10]\n        if value == nil then\n           \
    \ value = _miniroman_values[math.floor(number / 10) % 10]\n            if value\
    \ == nil then\n                value = _miniroman_values[math.floor(number / 100)\
    \ % 10]\n            end\n        end\n        result = value .. result\n    \
    \    number = number - (_miniroman_revvalues[value] or 0)\n    end\n    return\
    \ result\nend", "  local ints = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900,\
    \ 1000}\n  local nums = {'i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd',\
    \ 'd', 'cm', 'm'}\n  local roman = ''\n  local idx = 13\n  while number > 0 do\n\
    \    local div = math.floor(number / ints[idx])\n    number = number % ints[idx]\n\
    \    while div > 0 do\n      roman = roman .. nums[idx]\n      div = div - 1\n\
    \    end\n    idx = idx - 1\n  end\n  return roman\nend", "\tlocal rom = ''\n\t\
    for i = 1, #ROMAN_NUMERALS do\n\t\tlocal numeral = ROMAN_NUMERALS[i]\n\t\twhile\
    \ number >= numeral.int do\n\t\t\trom = rom .. numeral.rom\n\t\t\tnumber = number\
    \ - numeral.int\n\t\tend\n\tend\n\treturn rom\nend", "    local roman = ''\n \
    \   for _, arabic in ipairs(arabic_numerals) do\n        while number >= arabic[1]\
    \ do\n            roman = roman .. arabic[2]\n            number = number - arabic[1]\n\
    \        end\n    end\n    return roman\nend", "  assert(type(number) == 'number'\
    \ and number >= 1 and number <= 1000,\n    'Input must be a positive integer from\
    \ 1 to 1000 inclusive')\n  local roman_str = ''\n  local num_left = number\n \
    \ for _, n in ipairs(mini_roman_nums) do\n    local pow_val = n[1]\n    local\
    \ rom_val = n[2]\n    local pow_num = math.floor(num_left / pow_val)\n    for\
    \ _ = 1, pow_num do\n      roman_str = roman_str .. rom_val\n    end\n    num_left\
    \ = num_left % pow_val\n  end\n  return roman_str\nend", "    return number\n\
    end", "  -- body\n  local conversion = {\n    {1000, 'm'},\n    {900, 'cm'},\n\
    \    {500, 'd'},\n    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50,\
    \ 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4,\
    \ 'iv'},\n    {1, 'i'}\n  }\n  local result = ''\n  for _, v in ipairs(conversion)\
    \ do\n    while number >= v[1] do\n      result = result .. v[2]\n      number\
    \ = number - v[1]\n    end\n  end\n  return result\nend", "\tlocal res = ''\n\t\
    local c = 0\n\tfor i = #roman_digits, 1, -1 do\n\t\tlocal digit = roman_digits[i]\n\
    \t\tc = math.floor(number / digit)\n\t\tnumber = number % digit\n\t\tres = res\
    \ .. string.rep(roman_chars[i], c)\n\tend\n\treturn res\nend", "    number = tonumber(number)\n\
    \    if number < 1 or number > 1000 then\n        error('number out of range:\
    \ ' .. number)\n    end\n    if number == 0 then\n        return ''\n    end\n\
    \    local temp = number\n    local result = ''\n    local digit = 1\n    while\
    \ temp > 0 do\n        local d = temp % 10\n        if d ~= 0 then\n         \
    \   result = num_to_roman[digit][d] .. result\n        end\n        temp = (temp\
    \ - d) / 10\n        digit = digit + 1\n    end\n    return result\nend", "  \
    \  local mini_roman_numerals = {'i', 'v', 'x', 'l', 'c', 'd', 'm'}\n    local\
    \ four = mini_roman_numerals[#mini_roman_numerals - 1] .. mini_roman_numerals[#mini_roman_numerals]\n\
    \    local nine = mini_roman_numerals[#mini_roman_numerals - 2] .. mini_roman_numerals[#mini_roman_numerals]\n\
    \    local current_power = 0\n    local result = ''\n    while number > 0 do\n\
    \        local current_digit = number % 10\n        if current_digit == 4 then\n\
    \            result = four .. result\n        elseif current_digit == 9 then\n\
    \            result = nine .. result\n        else\n            if current_digit\
    \ >= 5 then\n                result = mini_roman_numerals[#mini_roman_numerals\
    \ - current_power] .. result\n                current_digit = current_digit -\
    \ 5\n            end\n            result = string.rep(mini_roman_numerals[#mini_roman_numerals\
    \ - current_power - 1], current_digit) .. result\n        end\n        number\
    \ = math.floor(number / 10)\n        current_power = current_power + 2\n    end\n\
    \    return result\nend", "    assert(1 <= number and number <= 1000, \"Value\
    \ out of range\")\n    local roman = ''\n    local nums = {1, 5, 10, 50, 100,\
    \ 500, 1000}\n    local romans = {'i', 'v', 'x', 'l', 'c', 'd', 'm'}\n    for\
    \ i = 7, 1, -1 do\n        local num = nums[i]\n        local d, m = math.modf(number\
    \ / num)\n        if d > 0 then\n            roman = roman .. romans[i]:rep(d)\n\
    \            number = number - d * num\n        end\n    end\n    return roman\n\
    end", "  local roman = \"\"\n  local v = {1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1}\n  local s = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"\
    l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n  for i = 1, #v do\n    local\
    \ value = v[i]\n    local symbol = s[i]\n    while number >= value do\n      roman\
    \ = roman .. symbol\n      number = number - value\n    end\n  end\n  return roman\n\
    end", "\tlocal roman = ''\n\tlocal int_to_mini_roman_symbols = {\n\t\t{'m', 1000},\n\
    \t\t{'d', 500},\n\t\t{'c', 100},\n\t\t{'l', 50},\n\t\t{'x', 10},\n\t\t{'v', 5},\n\
    \t\t{'i', 1}\n\t}\n\tlocal previous_int_to_mini_roman_symbol = { '', 0 }\n\tfor\
    \ _, int_to_mini_roman_symbol in ipairs(int_to_mini_roman_symbols) do\n\t\tlocal\
    \ count = math.floor(number / int_to_mini_roman_symbol[2])\n\t\tlocal repeating_int_to_mini_roman_symbol_count\
    \ = previous_int_to_mini_roman_symbol[2] * 2\n\t\tif count == 1\n\t\t\t\tand int_to_mini_roman_symbol[2]\
    \ < previous_int_to_mini_roman_symbol[2]\n\t\t\t\tand repeating_int_to_mini_roman_symbol_count\
    \ ~= int_to_mini_roman_symbol[2] then\n\t\t\troman = roman .. int_to_mini_roman_symbol[1]\
    \ .. previous_int_to_mini_roman_symbol[1]\n\t\telse\n\t\t\troman = roman .. previous_int_to_mini_roman_symbol[1]:rep(count)\n\
    \t\tend\n\t\tnumber = number % int_to_mini_roman_symbol[2]\n\t\tprevious_int_to_mini_roman_symbol\
    \ = int_to_mini_roman_symbol\n\tend\n\treturn roman\nend", "    if type(number)\
    \ ~= 'number' then\n        return nil\n    end\n    if number < 1 or number >\
    \ 1000 then\n        return nil\n    end\n    local result = ''\n    local values\
    \ = {\n        { 'm', 1000 },\n        { 'd', 500 },\n        { 'c', 100 },\n\
    \        { 'l', 50 },\n        { 'x', 10 },\n        { 'v', 5 },\n        { 'i',\
    \ 1 }\n    }\n    for i, v in ipairs(values) do\n        local roman, value =\
    \ v[1], v[2]\n        if number >= value then\n            local times = math.floor(number\
    \ / value)\n            for i = 1, times do\n                result = result ..\
    \ roman\n            end\n            number = number % value\n        end\n \
    \   end\n    -- We are done when we reach zero.\n    return result\nend", "  error('unimplemented')\n\
    end", "    local out = \"\"\n    for _, v in ipairs(roman_order) do\n        local\
    \ _, q = math.modf(number / v[1])\n        local c = math.floor(q)\n        if\
    \ c > 0 then\n            out = out .. v[2]:rep(c)\n            number = number\
    \ - v[1] * c\n        end\n    end\n    return out\nend", "    -- pull out the\
    \ code from above and use it to create mini_roman_numeral_map\n    local mini_roman_numeral_map\
    \ = {\n        {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'},\n        {'k',\
    \ 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't'},\n        {'u', 'v', 'w', 'x',\
    \ 'y', 'z', 'A', 'B', 'C', 'D'},\n        {'E', 'F', 'G', 'H', 'I', 'J', 'K',\
    \ 'L', 'M', 'N'},\n        {'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X'},\n\
    \        {'Y', 'Z', '!', '@', '#', '$', '%', '^', '&', '*'},\n        {'0', '1',\
    \ '2', '3', '4', '5', '6', '7', '8', '9'},\n    }\n    return int_to_roman(number,\
    \ mini_roman_numeral_map)\nend", "  if number <= 0 or number > 1000 then\n   \
    \ error(\"Value out of range\")\n  end\n  local numeral = \"\"\n  local digit,\
    \ repeat_char\n  repeat\n    repeat_char = \"\"\n    if number >= 900 then\n \
    \     digit = 9\n      repeat_char = \"c\"\n    elseif number >= 500 then\n  \
    \    digit = 5\n      repeat_char = \"c\"\n    elseif number >= 400 then\n   \
    \   digit = 4\n      repeat_char = \"c\"\n    elseif number >= 100 then\n    \
    \  digit = 1\n      repeat_char = \"c\"\n    elseif number >= 90 then\n      digit\
    \ = 9\n      repeat_char = \"x\"\n    elseif number >= 50 then\n      digit =\
    \ 5\n      repeat_char = \"x\"\n    elseif number >= 40 then\n      digit = 4\n\
    \      repeat_char = \"x\"\n    elseif number >= 10 then\n      digit = 1\n  \
    \    repeat_char = \"x\"\n    elseif number >= 9 then\n      digit = 9\n     \
    \ repeat_char = \"i\"\n    elseif number >= 5 then\n      digit = 5\n      repeat_char\
    \ = \"i\"\n    elseif number >= 4 then\n      digit = 4\n      repeat_char = \"\
    i\"\n    else\n      digit = 1\n      repeat_char = \"i\"\n    end\n    numeral\
    \ = numeral .. string.rep(repeat_char, digit)\n    number = number - digit * (string.byte(repeat_char)\
    \ - string.byte(\"i\") + 1)\n  until number == 0\n  return numeral\nend", "  \
    \  if type(number) ~= 'number' then\n        return nil\n    end\n    local minirom\
    \ = {'i', 'v', 'x', 'l', 'c', 'd', 'm'}\n    local i = 1\n    local j = 1\n  \
    \  local c = ''\n    local number = tonumber(number)\n    local result = ''\n\
    \    while number > 0 do\n        c = ''\n        i = number % 10\n        if\
    \ i < 4 then\n            for j = 1, i do\n                c = c .. minirom[2\
    \ * j - 1]\n            end\n        elseif i == 4 then\n            c = minirom[2\
    \ * j - 1] .. minirom[2 * j]\n        elseif i < 9 then\n            c = minirom[2\
    \ * j]\n            for j = 1, i - 5 do\n                c = c .. minirom[2 *\
    \ j - 1]\n            end\n        elseif i == 9 then\n            c = minirom[2\
    \ * j - 1] .. minirom[2 * j + 1]\n        end\n        result = c .. result\n\
    \        number = math.floor(number / 10)\n        j = j + 1\n    end\n    return\
    \ result\nend", "  local n = number\n  local out = ''\n  while n > 0 do\n    local\
    \ d = n % 10\n    local d_roman = ''\n    if d == 1 then\n      d_roman = 'i'\n\
    \    elseif d == 2 then\n      d_roman = 'ii'\n    elseif d == 3 then\n      d_roman\
    \ = 'iii'\n    elseif d == 4 then\n      d_roman = 'iv'\n    elseif d == 5 then\n\
    \      d_roman = 'v'\n    elseif d == 6 then\n      d_roman = 'vi'\n    elseif\
    \ d == 7 then\n      d_roman = 'vii'\n    elseif d == 8 then\n      d_roman =\
    \ 'viii'\n    elseif d == 9 then\n      d_roman = 'ix'\n    end\n    out = d_roman\
    \ .. out\n    n = (n - d) / 10\n  end\n  return out\nend", "    if (number <=\
    \ 0) or (number > 1000) then\n        err_out(\"Invalid input: \" .. number)\n\
    \    end\n    local ret = \"\"\n    local cnt = 0\n    -- Decompose into numeral\
    \ symbols\n    while number > 0 do\n        local digit = number % 10\n      \
    \  if digit == 9 then\n            ret = \"ix\" .. ret\n        elseif digit ==\
    \ 4 then\n            ret = \"iv\" .. ret\n        else\n            if digit\
    \ >= 5 then\n                ret = \"v\" .. ret\n                digit = digit\
    \ - 5\n            end\n            if digit > 0 then\n                ret = \"\
    i\" .. ret\n            end\n        end\n        -- Next digit\n        number\
    \ = math.floor(number / 10)\n        cnt = cnt + 1\n    end\n    -- Add numeral\
    \ symbols for higher powers of ten\n    if cnt == 4 then\n        ret = \"m\"\
    \ .. ret\n    elseif cnt == 3 then\n        ret = \"c\" .. ret\n    elseif cnt\
    \ == 2 then\n        ret = \"x\" .. ret\n    end\n    return ret\nend", "    return\
    \ mini_roman_string(roman_numeral(number))\nend", "    if number < 1 or number\
    \ > 1000 then\n        return nil\n    end\n    local symbols = {'i', 'v', 'x',\
    \ 'l', 'c', 'd', 'm'}\n    local roman = {}\n    local i = 7\n    while number\
    \ > 0 do\n        local int = number % 10\n        local ones, fives, tens = int,\
    \ i - 1, i - 2\n        if int == 9 then\n            roman[#roman + 1] = symbols[tens]\n\
    \            roman[#roman + 1] = symbols[i]\n        elseif int >= 5 then\n  \
    \          roman[#roman + 1] = symbols[fives]\n            for i = 1, int - 5\
    \ do\n                roman[#roman + 1] = symbols[ones]\n            end\n   \
    \     elseif int == 4 then\n            roman[#roman + 1] = symbols[ones]\n  \
    \          roman[#roman + 1] = symbols[fives]\n        else\n            for i\
    \ = 1, int do\n                roman[#roman + 1] = symbols[ones]\n           \
    \ end\n        end\n        number = math.floor(number / 10)\n        i = i +\
    \ 2\n    end\n    return table.concat(roman):reverse()\nend", "    return int_to_roman(number):lower()\n\
    end", "  local string = ''\n  local mini_map = {\n    {1000, 'm'},\n    {900,\
    \ 'cm'},\n    {500, 'd'},\n    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n\
    \    {50, 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n\
    \    {4, 'iv'},\n    {1, 'i'}\n  }\n  for key, val in ipairs(mini_map) do\n  \
    \  local divisor = val[1]\n    local char = val[2]\n    local quotient = math.floor(number\
    \ / divisor)\n    number = number % divisor\n    string = string .. char:rep(quotient)\n\
    \  end\n  return string\nend", "\tlocal roman_digits = { 'm', 'cm', 'd', 'cd',\
    \ 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i' }\n\tlocal decimal_digits =\
    \ { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }\n\tlocal roman = ''\n\
    \tlocal i = 1\n\twhile (number > 0) do\n\t\twhile (number >= decimal_digits[i])\
    \ do\n\t\t\tnumber = number - decimal_digits[i]\n\t\t\troman = roman .. roman_digits[i]\n\
    \t\tend\n\t\ti = i + 1\n\tend\n\treturn roman\nend", "\tassert(number > 0, \"\
    int_to_mini_roman requires a positive integer\")\n\tassert(number <= 1000, \"\
    int_to_mini_roman requires an integer below 1000\")\n\tlocal result = {}\n\tlocal\
    \ remaining = number\n\tlocal places = {\n\t\t{s = \"M\", v = 1000},\n\t\t{s =\
    \ \"C\", v = 100},\n\t\t{s = \"X\", v = 10},\n\t\t{s = \"I\", v = 1}\n\t}\n\t\
    for _, place in ipairs(places) do\n\t\tlocal place_value = place.v\n\t\tlocal\
    \ s = place.s\n\t\tlocal n, remaining = math.modf(remaining / place_value)\n\t\
    \tif n > 0 then\n\t\t\tif n == 4 then\n\t\t\t\tif result[#result] == s then\n\t\
    \t\t\t\tresult[#result] = nil\n\t\t\t\t\ttable.insert(result, s .. \"V\")\n\t\t\
    \t\telse\n\t\t\t\t\ttable.insert(result, s .. \"IV\")\n\t\t\t\tend\n\t\t\telseif\
    \ n == 9 then\n\t\t\t\tif result[#result] == s then\n\t\t\t\t\tresult[#result]\
    \ = nil\n\t\t\t\t\ttable.insert(result, s .. \"X\")\n\t\t\t\telse\n\t\t\t\t\t\
    table.insert(result, s .. \"IX\")\n\t\t\t\tend\n\t\t\telse\n\t\t\t\ttable.insert(result,\
    \ s:rep(n))\n\t\t\tend\n\t\tend\n\t\tremaining = remaining * place_value\n\tend\n\
    \treturn table.concat(result)\nend", "\tlocal roman = ''\n\tlocal mapping = {\n\
    \t\t[1] = 'i',\n\t\t[5] = 'v',\n\t\t[10] = 'x',\n\t\t[50] = 'l',\n\t\t[100] =\
    \ 'c',\n\t\t[500] = 'd',\n\t\t[1000] = 'm'\n\t}\n\tlocal numbers = { 1000, 500,\
    \ 100, 50, 10, 5, 1 }\n\tlocal previous = number\n\tfor k, v in ipairs(numbers)\
    \ do\n\t\tlocal multiple = math.floor(previous / v)\n\t\tprevious = previous %\
    \ v\n\t\tif multiple == 4 then\n\t\t\troman = roman .. mapping[v] .. mapping[v\
    \ * 5]\n\t\telseif multiple == 9 then\n\t\t\troman = roman .. mapping[v] .. mapping[v\
    \ * 10]\n\t\telse\n\t\t\tif multiple >= 5 then\n\t\t\t\troman = roman .. mapping[v\
    \ * 5]\n\t\t\t\tmultiple = multiple - 5\n\t\t\tend\n\t\t\tfor i = 1, multiple\
    \ do\n\t\t\t\troman = roman .. mapping[v]\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ roman\nend", "  local roman = {}\n  local roman_char = {'i', 'v', 'x', 'l',\
    \ 'c', 'd', 'm'}\n  local roman_value = {1, 5, 10, 50, 100, 500, 1000}\n  local\
    \ roman_index = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7}\n  local number_index = {0,\
    \ 1, 2, 3, 4, 1, 2, 3, 4, 2, 3, 4}\n  local four_index = {2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10, 11, 12}\n  local nine_index = {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}\n\
    \  local i, j\n  local r\n  -- Empty table\n  for i = 1, 7 do\n    roman[i] =\
    \ 0\n  end\n  -- Processes hundreds\n  i = 1\n  while number >= roman_value[roman_index[i]]\
    \ do\n    number = number - roman_value[roman_index[i]]\n    roman[roman_index[i]]\
    \ = roman[roman_index[i]] + 1\n  end\n  -- Processes tens\n  i = 1\n  while number\
    \ >= roman_value[roman_index[i + 4]] do\n    number = number - roman_value[roman_index[i\
    \ + 4]]\n    roman[roman_index[i + 4]] = roman[roman_index[i + 4]] + 1\n  end\n\
    \  -- Processes units\n  i = 1\n  while number >= roman_value[roman_index[i +\
    \ 8]] do\n    number = number - roman_value[roman_index[i + 8]]\n    roman[roman_index[i\
    \ + 8]] = roman[roman_index[i + 8]] + 1\n  end\n  -- Builds result\n  r = ''\n\
    \  for i = 1, 7 do\n    for j = 1, roman[i] do\n      r = r .. roman_char[i]\n\
    \    end\n  end\n  -- Normalizes result\n  for", "  local roman = ''\n  local\
    \ num = number\n  local s = int_to_small[num % 10]\n  num = math.floor(num / 10)\n\
    \  local t = int_to_ten[num % 10]\n  num = math.floor(num / 10)\n  local h = int_to_hundred[num\
    \ % 10]\n  return h .. t .. s\nend", "  local roman = \"\"\n  local units = {\n\
    \    {1, \"i\"},\n    {4, \"iv\"},\n    {5, \"v\"},\n    {9, \"ix\"},\n    {10,\
    \ \"x\"},\n    {40, \"xl\"},\n    {50, \"l\"},\n    {90, \"xc\"},\n    {100, \"\
    c\"},\n    {400, \"cd\"},\n    {500, \"d\"},\n    {900, \"cm\"},\n    {1000, \"\
    m\"}\n  }\n  local subtractive = true\n  for _, t in ipairs(units) do\n    local\
    \ value, symbol = t[1], t[2]\n    if subtractive then\n      if number % value\
    \ == number then\n        subtractive = false\n      else\n        roman = roman\
    \ .. symbol\n        number = number - value\n      end\n    else\n      local\
    \ digit = number // value\n      if digit > 0 then\n        roman = roman .. symbol:rep(digit)\n\
    \        number = number % value\n      end\n    end\n  end\n  return roman\n\
    end", "  local result = \"\"\n  local numeral = number\n  for _, i in ipairs({1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}) do\n    while numeral >= i\
    \ do\n      result = result .. roman_numerals[i]\n      numeral = numeral - i\n\
    \    end\n  end\n  return result\nend", "    if number > 1000 then\n        error(\"\
    int_to_mini_roman only defined for numbers 1 <= num <= 1000\")\n    end\n    local\
    \ roman = \"\"\n    local symbols = { \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\" }\n    local values =\
    \ { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }\n    for i = 1, #values\
    \ do\n        while number >= values[i] do\n            roman = roman .. symbols[i]\n\
    \            number = number - values[i]\n        end\n    end\n    return roman\n\
    end", "\tif number > 1000 then\n\t\terror('Value too high to convert to Mini-Roman.')\n\
    \tend\n\tlocal answer = ''\n\tfor i, pair in ipairs(mini_roman_numeral_list) do\n\
    \t\tlocal number_of_symbols = math.floor(number / pair[1])\n\t\tanswer = answer\
    \ .. pair[2]:rep(number_of_symbols)\n\t\tnumber = number - number_of_symbols *\
    \ pair[1]\n\tend\n\treturn answer\nend", "    local numeral = {\n        [1] =\
    \ 'i',\n        [5] = 'v',\n        [10] = 'x',\n        [50] = 'l',\n       \
    \ [100] = 'c',\n        [500] = 'd',\n        [1000] = 'm',\n    }\n    local\
    \ roman_numeral = {}\n    local num = number\n    local digits = math.floor(math.log10(num))\
    \ + 1\n    for digit = 1, digits do\n        local power = 10 ^ (digit - 1)\n\
    \        local value = num // power\n        if value < 4 then\n            for\
    \ i = 1, value do\n                table.insert(roman_numeral, numeral[power])\n\
    \            end\n        elseif value == 4 then\n            table.insert(roman_numeral,\
    \ numeral[power])\n            table.insert(roman_numeral, numeral[5 * power])\n\
    \        elseif value == 5 then\n            table.insert(roman_numeral, numeral[5\
    \ * power])\n        elseif value < 9 then\n            table.insert(roman_numeral,\
    \ numeral[5 * power])\n            for i = 6, value do\n                table.insert(roman_numeral,\
    \ numeral[power])\n            end\n        elseif value == 9 then\n         \
    \   table.insert(roman_numeral, numeral[power])\n            table.insert(roman_numeral,\
    \ numeral[10 * power])\n        end\n        num = num % power\n    end\n    return\
    \ table.concat(roman_numeral)\nend", "    local result = ''\n    while number\
    \ > 0 do\n        local symbol, value = next(symbols)\n        while value <=\
    \ number do\n            result = result .. symbol\n            number = number\
    \ - value\n        end\n    end\n    return result\nend", "    local mapping =\
    \ {\n        {'i', 'v'},\n        {'x', 'l'},\n        {'c', 'd'},\n        {'m'}\n\
    \    }\n    local place_value = 1\n    local result = ''\n    while number > 0\
    \ do\n        local digit = number % 10\n        if digit > 0 then\n         \
    \   local numerals = mapping[place_value]\n            if digit < 4 then\n   \
    \             result = string.rep(numerals[1], digit) .. result\n            elseif\
    \ digit == 4 then\n                result = numerals[1] .. numerals[2] .. result\n\
    \            elseif digit == 5 then\n                result = numerals[2] .. result\n\
    \            elseif digit < 9 then\n                result = numerals[2] .. string.rep(numerals[1],\
    \ digit - 5) .. result\n            elseif digit == 9 then\n                result\
    \ = numerals[1] .. mapping[place_value + 1][1] .. result\n            end\n  \
    \      end\n        place_value = place_value + 1\n        number = number //\
    \ 10\n    end\n    return result\nend", "    local numeral_table = {\n       \
    \ [0] = '',\n        [1] = 'i',\n        [2] = 'ii',\n        [3] = 'iii',\n \
    \       [4] = 'iv',\n        [5] = 'v',\n        [6] = 'vi',\n        [7] = 'vii',\n\
    \        [8] = 'viii',\n        [9] = 'ix',\n        [10] = 'x',\n        [20]\
    \ = 'xx',\n        [30] = 'xxx',\n        [40] = 'xl',\n        [50] = 'l',\n\
    \        [60] = 'lx',\n        [70] = 'lxx',\n        [80] = 'lxxx',\n       \
    \ [90] = 'xc',\n        [100] = 'c',\n        [200] = 'cc',\n        [300] = 'ccc',\n\
    \        [400] = 'cd',\n        [500] = 'd',\n        [600] = 'dc',\n        [700]\
    \ = 'dcc',\n        [800] = 'dccc',\n        [900] = 'cm',\n        [1000] = 'm',\n\
    \    }\n    local result = ''\n    local ones, tens, hundreds, thousands\n   \
    \ local thousands = math.floor(number / 1000)\n    local hundreds = math.floor((number\
    \ % 1000) / 100)\n    local tens = math.floor((number % 100) / 10)\n    local\
    \ ones = math.floor(number % 10)\n    if thousands > 0 then\n        result =\
    \ result .. numeral_table[1000]\n    end\n    if hundreds > 0 then\n        result\
    \ = result .. numeral_table[hundreds * 100]\n    end\n    if tens > 0 then\n \
    \       result = result .. numeral_table[tens * 10]\n    end\n    if ones > 0\
    \ then\n        result = result .. numeral_table[ones]\n    end\n    return result\n\
    end", "    local roman, exp = \"\", 0\n    local base_symbols = {\"i\", \"v\"\
    , \"x\", \"l\", \"c\", \"d\", \"m\"}\n    while number > 0 do\n        local digit\
    \ = number % 10\n        local symbol = base_symbols[exp]\n        if digit <\
    \ 4 then\n            roman = symbol:rep(digit) .. roman\n        elseif digit\
    \ == 4 then\n            roman = symbol .. base_symbols[exp + 1] .. roman\n  \
    \      elseif digit == 5 then\n            roman = base_symbols[exp + 1] .. roman\n\
    \        elseif digit < 9 then\n            roman = base_symbols[exp + 1] .. symbol:rep(digit\
    \ - 5) .. roman\n        elseif digit == 9 then\n            roman = symbol ..\
    \ base_symbols[exp + 2] .. roman\n        end\n        number = math.floor(number\
    \ / 10)\n        exp = exp + 2\n    end\n    return roman\nend", "\tlocal int_to_mini_roman_map\
    \ = {\n\t\t[1] = 'i',\n\t\t[2] = 'ii',\n\t\t[3] = 'iii',\n\t\t[4] = 'iv',\n\t\t\
    [5] = 'v',\n\t\t[6] = 'vi',\n\t\t[7] = 'vii',\n\t\t[8] = 'viii',\n\t\t[9] = 'ix',\n\
    \t\t[10] = 'x',\n\t\t[20] = 'xx',\n\t\t[30] = 'xxx',\n\t\t[40] = 'xl',\n\t\t[50]\
    \ = 'l',\n\t\t[60] = 'lx',\n\t\t[70] = 'lxx',\n\t\t[80] = 'lxxx',\n\t\t[90] =\
    \ 'xc',\n\t\t[100] = 'c',\n\t\t[200] = 'cc',\n\t\t[300] = 'ccc',\n\t\t[400] =\
    \ 'cd',\n\t\t[500] = 'd',\n\t\t[600] = 'dc',\n\t\t[700] = 'dcc',\n\t\t[800] =\
    \ 'dccc',\n\t\t[900] = 'cm',\n\t\t[1000] = 'm',\n\t}\n\tlocal mini_roman = ''\n\
    \tlocal thousands = math.floor(number / 1000)\n\tlocal hundreds = math.floor((number\
    \ - (thousands * 1000)) / 100)\n\tlocal tens = math.floor((number - (thousands\
    \ * 1000) - (hundreds * 100)) / 10)\n\tlocal ones = number - (thousands * 1000)\
    \ - (hundreds * 100) - (tens * 10)\n\tif thousands > 0 then\n\t\tmini_roman =\
    \ mini_roman .. string.rep('m', thousands)\n\tend\n\tif hundreds > 0 then\n\t\t\
    mini_roman = mini_roman .. int_to_mini_roman_map[hundreds * 100]\n\tend\n\tif\
    \ tens > 0 then\n\t\tmini_roman = mini_roman .. int_to_mini_roman_map[tens * 10]\n\
    \tend\n\tif ones > 0 then\n\t", "    local numerals = {\n        'm', 'cm', 'd',\
    \ 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i'\n    }\n    local values\
    \ = {\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    }\n \
    \   local result = ''\n    for i = 1, #values do\n        local value = values[i]\n\
    \        local numeral = numerals[i]\n        while number >= value do\n     \
    \       result = result .. numeral\n            number = number - value\n    \
    \    end\n    end\n    return result\nend", "  local roman = ''\n  for _, v in\
    \ ipairs(MINI_ROMAN_TABLE) do\n    if number >= v[1] then\n      number = number\
    \ - v[1]\n      roman = roman .. v[2]\n    end\n  end\n  return roman\nend", " \
    \ local numerals = {'i', 'v', 'x', 'l', 'c', 'd', 'm'}\n  local numeral_values\
    \ = {1, 5, 10, 50, 100, 500, 1000}\n  local n = number\n  local n_digits = math.floor(math.log10(n)\
    \ + 1)\n  local result = ''\n  for i = n_digits, 1, -1 do\n    local ten_power\
    \ = 10^(i - 1)\n    local d = math.floor(n / ten_power)\n    local j = (d - 1)\
    \ * 2\n    local i0 = numeral_values[j + 1]\n    local i1 = numeral_values[j +\
    \ 2]\n    local i2 = numeral_values[j + 3]\n    if d == 9 then\n      result =\
    \ result .. numerals[j + 1] .. numerals[j + 3]\n    elseif d >= 5 then\n     \
    \ result = result .. numerals[j + 2] .. string.rep(numerals[j + 1], d - 5)\n \
    \   elseif d == 4 then\n      result = result .. numerals[j + 1] .. numerals[j\
    \ + 2]\n    else\n      result = result .. string.rep(numerals[j + 1], d)\n  \
    \  end\n    n = n % ten_power\n  end\n  return result\nend", "  local roman_digits\
    \ = {'i', 'v', 'x', 'l', 'c', 'd', 'm'}\n  local digits = {}\n  local result =\
    \ ''\n  for digit in string.gmatch(tostring(number), '.') do\n    table.insert(digits,\
    \ tonumber(digit))\n  end\n  for power = #digits, 1, -1 do\n    local decimal\
    \ = digits[power]\n    if decimal ~= 0 then\n      local digit = decimal % 5\n\
    \      local ten = math.floor(decimal / 5)\n      if decimal < 4 then\n      \
    \  for i = 1, decimal do\n          result = result .. roman_digits[power]\n \
    \       end\n      elseif decimal == 4 then\n        result = result .. roman_digits[power]\
    \ .. roman_digits[power + 1]\n      elseif digit == 4 then\n        result = result\
    \ .. roman_digits[power + 1] .. roman_digits[power]\n      else\n        result\
    \ = result .. roman_digits[power + 1]\n        for i = 1, digit do\n         \
    \ result = result .. roman_digits[power]\n        end\n      end\n    end\n  end\n\
    \  return result\nend", "\t-- define table of roman numerals from 1 to 9\n\tlocal\
    \ ones = {\n\t\t[1] = 'i',\n\t\t[2] = 'ii',\n\t\t[3] = 'iii',\n\t\t[4] = 'iv',\n\
    \t\t[5] = 'v',\n\t\t[6] = 'vi',\n\t\t[7] = 'vii',\n\t\t[8] = 'viii',\n\t\t[9]\
    \ = 'ix'\n\t}\n\t-- define table of roman numerals from 10 to 90\n\tlocal tens\
    \ = {\n\t\t[1] = 'x',\n\t\t[2] = 'xx',\n\t\t[3] = 'xxx',\n\t\t[4] = 'xl',\n\t\t\
    [5] = 'l',\n\t\t[6] = 'lx',\n\t\t[7] = 'lxx',\n\t\t[8] = 'lxxx',\n\t\t[9] = 'xc'\n\
    \t}\n\t-- define table of roman numerals from 100 to 900\n\tlocal hundreds = {\n\
    \t\t[1] = 'c',\n\t\t[2] = 'cc',\n\t\t[3] = 'ccc',\n\t\t[4] = 'cd',\n\t\t[5] =\
    \ 'd',\n\t\t[6] = 'dc',\n\t\t[7] = 'dcc',\n\t\t[8] = 'dccc',\n\t\t[9] = 'cm'\n\
    \t}\n\t-- define table of roman numerals from 1000 to 1000\n\tlocal thousands\
    \ = {\n\t\t[1] = 'm'\n\t}\n\t-- convert number to string\n\tlocal number = tostring(number)\n\
    \t-- return empty string if number is not a string\n\tif type(number) ~= 'string'\
    \ then\n\t\treturn ''\n\tend\n\t-- return empty string if number is longer than\
    \ 4 digits\n\tif string.len(number) > 4 then\n\t\treturn ''\n\tend\n\t-- set local\
    \ variables for length of number and digit zero\n\tlocal length = string.len(number)\n\
    \tlocal digit_zero = string.sub(number, 1, 1)\n\t-- set local variables", "  error(\"\
    Not implemented\")\nend", "    local roman_digits = {\n        {1000, 'm'},\n\
    \        {900, 'cm'},\n        {500, 'd'},\n        {400, 'cd'},\n        {100,\
    \ 'c'},\n        {90, 'xc'},\n        {50, 'l'},\n        {40, 'xl'},\n      \
    \  {10, 'x'},\n        {9, 'ix'},\n        {5, 'v'},\n        {4, 'iv'},\n   \
    \     {1, 'i'},\n    }\n    local result = {}\n    local i = 1\n    while number\
    \ > 0 do\n        local n = number\n        local u = roman_digits[i][1]\n   \
    \     while n >= u do\n            n = n - u\n            result[#result + 1]\
    \ = roman_digits[i][2]\n        end\n        i = i + 1\n        number = n\n \
    \   end\n    return table.concat(result)\nend", "  local roman = ''\n  while number\
    \ > 0 do\n    local rest = number % 10\n    local prefix = number - rest\n   \
    \ number = (number - prefix) / 10\n    if rest == 0 then\n      prefix = prefix\
    \ / 10\n    end\n    if rest == 4 then\n      if prefix == 0 then\n        roman\
    \ = 'iv' .. roman\n      else\n        roman = 'ix' .. roman\n      end\n    elseif\
    \ rest == 9 then\n      if prefix == 0 then\n        roman = 'ix' .. roman\n \
    \     else\n        roman = 'xc' .. roman\n      end\n    else\n      if rest\
    \ >= 5 then\n        rest = rest - 5\n        roman = 'v' .. roman\n      end\n\
    \      for i = 1, rest do\n        roman = 'i' .. roman\n      end\n      if prefix\
    \ == 40 then\n        roman = 'xl' .. roman\n      elseif prefix == 90 then\n\
    \        roman = 'xc' .. roman\n      else\n        for i = 1, prefix / 10 do\n\
    \          roman = 'x' .. roman\n        end\n      end\n    end\n  end\n  return\
    \ roman\nend", "  if number < 1 or number > 1000 then\n    return nil\n  end\n\
    \  local I = 'i'\n  local V = 'v'\n  local X = 'x'\n  local L = 'l'\n  local C\
    \ = 'c'\n  local D = 'd'\n  local M = 'm'\n  if number == 1 then\n    return I\n\
    \  elseif number == 2 then\n    return I .. I\n  elseif number == 3 then\n   \
    \ return I .. I .. I\n  elseif number == 4 then\n    return I .. V\n  elseif number\
    \ == 5 then\n    return V\n  elseif number == 6 then\n    return V .. I\n  elseif\
    \ number == 7 then\n    return V .. I .. I\n  elseif number == 8 then\n    return\
    \ V .. I .. I .. I\n  elseif number == 9 then\n    return I .. X\n  elseif number\
    \ == 10 then\n    return X\n  elseif number == 20 then\n    return X .. X\n  elseif\
    \ number == 30 then\n    return X .. X .. X\n  elseif number == 40 then\n    return\
    \ X .. L\n  elseif number == 50 then\n    return L\n  elseif number == 60 then\n\
    \    return L .. X\n  elseif number == 70 then\n    return L .. X .. X\n  elseif\
    \ number == 80 then\n    return L .. X .. X .. X\n  elseif number == 90 then\n\
    \    return X .. C\n  elseif number == 100 then\n    return C\n  elseif number\
    \ == 200 then\n    return C .. C\n  elseif number == 300 then\n    return C ..\
    \ C .. C\n  elseif number == 400 then\n    return C .. D\n  elseif number == 500\
    \ then\n    return D\n  elseif number == 600 then\n    return D .. C\n  elseif\
    \ number == 700 then\n    return D .. C .. C\n  elseif number == 800 then\n  \
    \  return D .. C .. C .. C\n  elseif number == 900 then\n    return C .. M\n \
    \ elseif number == 1000 then\n    return M\n  end\nend", "    local roman_equivalent\
    \ = ''\n    local symbol_dict = {M = 1000, D = 500, C = 100, L = 50, X = 10, V\
    \ = 5, I = 1}\n    for symbol, value in pairs(symbol_dict) do\n        while number\
    \ >= value do\n            roman_equivalent = roman_equivalent .. symbol\n   \
    \         number = number - value\n        end\n    end\n    return roman_equivalent\n\
    end", "  assert(number >= 1 and number <= 1000, \"Input number should be in [1,\
    \ 1000]\")\n  local table = { M = 1000, CM = 900, D = 500, CD = 400, C = 100,\
    \ XC = 90,\n    L = 50, XL = 40, X = 10, IX = 9, V = 5, IV = 4, I = 1}\n  local\
    \ string = \"\"\n  for numeral, int in pairs(table) do\n    while number >= int\
    \ do\n      string = string .. numeral\n      number = number - int\n    end\n\
    \  end\n  return string\nend", "  if type(number) ~= 'number' then\n    return\
    \ nil\n  end\n  if number < 1 or number > 1000 then\n    return nil\n  end\n \
    \ return int_to_roman(number):lower()\nend", "    local mini_roman_map = {\n \
    \       [1] = 'i',\n        [5] = 'v',\n        [10] = 'x',\n        [50] = 'l',\n\
    \        [100] = 'c',\n        [500] = 'd',\n        [1000] = 'm',\n    }\n  \
    \  local powers_of_ten = {1, 10, 100, 1000}\n    local numeral = ''\n    local\
    \ remainder = number\n    for i = #powers_of_ten, 1, -1 do\n        local power\
    \ = powers_of_ten[i]\n        local quotient = remainder / power\n        remainder\
    \ = remainder % power\n        if quotient == 9 then\n            numeral = numeral\
    \ .. mini_roman_map[power] .. mini_roman_map[power * 10]\n        elseif quotient\
    \ == 4 then\n            numeral = numeral .. mini_roman_map[power] .. mini_roman_map[power\
    \ * 5]\n        else\n            if quotient >= 5 then\n                numeral\
    \ = numeral .. mini_roman_map[power * 5]\n                quotient = quotient\
    \ - 5\n            end\n            if quotient > 0 then\n                numeral\
    \ = numeral .. mini_roman_map[power]:rep(quotient)\n            end\n        end\n\
    \    end\n    return numeral\nend", "    local roman = {M=1000, D=500, C=100,\
    \ L=50, X=10, V=5, I=1}\n    local mini_roman = {'m', 'd', 'c', 'l', 'x', 'v',\
    \ 'i'}\n    local roman_numeral = ''\n    for i = 1, #mini_roman do\n        local\
    \ int = roman[mini_roman[i]:upper()]\n        while number >= int do\n       \
    \     number = number - int\n            roman_numeral = roman_numeral .. mini_roman[i]\n\
    \        end\n    end\n    return roman_numeral\nend", "    local numeral = ''\n\
    \    for i,v in ipairs(digits) do\n        if v > number then break end\n    \
    \    while v <= number do\n            numeral = numeral .. characters[i]\n  \
    \          number = number - v\n        end\n    end\n    return numeral\nend",
  "    if 1 <= number and number <= 1000 then\n        local numerals = {\n      \
    \      {1000, 'm'},\n            {900, 'cm'},\n            {500, 'd'},\n     \
    \       {400, 'cd'},\n            {100, 'c'},\n            {90, 'xc'},\n     \
    \       {50, 'l'},\n            {40, 'xl'},\n            {10, 'x'},\n        \
    \    {9, 'ix'},\n            {5, 'v'},\n            {4, 'iv'},\n            {1,\
    \ 'i'}\n        }\n        local result = ''\n        for _, v in ipairs(numerals)\
    \ do\n            while number >= v[1] do\n                result = result ..\
    \ v[2]\n                number = number - v[1]\n            end\n        end\n\
    \        return result\n    else\n        return error('number must be between\
    \ 1 and 1000 inclusive')\n    end\nend", "\tlocal function convert(number, one,\
    \ five, ten)\n\t\tlocal function roman_numeral(num, one, five, ten)\n\t\t\tif\
    \ num < 4 then\n\t\t\t\treturn one:rep(num)\n\t\t\telseif num == 4 then\n\t\t\t\
    \treturn one .. five\n\t\t\telseif num < 9 then\n\t\t\t\treturn five .. one:rep(num\
    \ - 5)\n\t\t\telseif num == 9 then\n\t\t\t\treturn one .. ten\n\t\t\tend\n\t\t\
    end\n\t\treturn roman_numeral(number % 10, one, five, ten)\n\tend\n\treturn\n\t\
    \tconvert(number / 1000, 'm', 'm', 'm') ..\n\t\tconvert(number / 100, 'c', 'd',\
    \ 'm') ..\n\t\tconvert(number / 10, 'x', 'l', 'c') ..\n\t\tconvert(number, 'i',\
    \ 'v', 'x')\nend", "  local rom_num = {}\n  while number > 0 do\n    if number\
    \ >= 1000 then\n      number = number - 1000\n      table.insert(rom_num, 'm')\n\
    \    elseif number >= 900 then\n      number = number - 900\n      table.insert(rom_num,\
    \ 'cm')\n    elseif number >= 500 then\n      number = number - 500\n      table.insert(rom_num,\
    \ 'd')\n    elseif number >= 400 then\n      number = number - 400\n      table.insert(rom_num,\
    \ 'cd')\n    elseif number >= 100 then\n      number = number - 100\n      table.insert(rom_num,\
    \ 'c')\n    elseif number >= 90 then\n      number = number - 90\n      table.insert(rom_num,\
    \ 'xc')\n    elseif number >= 50 then\n      number = number - 50\n      table.insert(rom_num,\
    \ 'l')\n    elseif number >= 40 then\n      number = number - 40\n      table.insert(rom_num,\
    \ 'xl')\n    elseif number >= 10 then\n      number = number - 10\n      table.insert(rom_num,\
    \ 'x')\n    elseif number >= 9 then\n      number = number - 9\n      table.insert(rom_num,\
    \ 'ix')\n    elseif number >= 5 then\n      number = number - 5\n      table.insert(rom_num,\
    \ 'v')\n    elseif number >= 4 then\n      number = number - 4\n      table.insert(rom_num,\
    \ 'iv')\n    elseif number >= 1 then\n      number = number - 1\n      table.insert(rom_num,\
    \ 'i')\n    end\n  end\n  return table.concat(rom_num)\nend", "    local ret =\
    \ ''\n    for _, r in ipairs(mini_roman_table) do\n        while number >= r[1]\
    \ do\n            ret = ret .. r[2]\n            number = number - r[1]\n    \
    \    end\n    end\n    return ret\nend", "\tassert(number >= 1 and number <= 1000,\
    \ 'mini_roman: arg 1 must be in the range 1 to 1000')\n\tlocal digits = { { 'i',\
    \ 'v' }, { 'x', 'l' }, { 'c', 'd' }, { 'm' } }\n\tlocal result = ''\n\tfor _,\
    \ d in ipairs(digits) do\n\t\tlocal digit = number % 10\n\t\tnumber = (number\
    \ - digit) / 10\n\t\tif digit == 0 then\n\t\t\tgoto continue\n\t\tend\n\t\tif\
    \ digit <= 3 then\n\t\t\tresult = d[1]:rep(digit) .. result\n\t\telseif digit\
    \ == 4 then\n\t\t\tresult = d[1] .. d[2] .. result\n\t\telseif digit <= 8 then\n\
    \t\t\tresult = d[2] .. d[1]:rep(digit - 5) .. result\n\t\telse\n\t\t\tresult =\
    \ d[1] .. digits[(#d) + 1][1] .. result\n\t\tend\n\t\t::continue::\n\tend\n\t\
    return result\nend", "    if number <= 0 or number > 1000 then\n        return\
    \ ''\n    end\n    local roman = ''\n    local numerals = {\n        ['I'] = 1,\n\
    \        ['V'] = 5,\n        ['X'] = 10,\n        ['L'] = 50,\n        ['C'] =\
    \ 100,\n        ['D'] = 500,\n        ['M'] = 1000\n    }\n    local roman = ''\n\
    \    local values = {\n        [1000] = {'M'},\n        [900] = {'C', 'M'},\n\
    \        [500] = {'D'},\n        [400] = {'C', 'D'},\n        [100] = {'C'},\n\
    \        [90] = {'X', 'C'},\n        [50] = {'L'},\n        [40] = {'X', 'L'},\n\
    \        [10] = {'X'},\n        [9] = {'I', 'X'},\n        [5] = {'V'},\n    \
    \    [4] = {'I', 'V'},\n        [1] = {'I'}\n    }\n    for value, chars in pairs(values)\
    \ do\n        while number >= value do\n            for _, char in ipairs(chars)\
    \ do\n                roman = roman .. char\n            end\n            number\
    \ = number - value\n        end\n    end\n    return roman\nend", "  local temp\
    \ = number\n  local result = ''\n  local map = {\n    {\n      symbol = 'm',\n\
    \      value = 1000\n    },\n    {\n      symbol = 'd',\n      value = 500\n \
    \   },\n    {\n      symbol = 'c',\n      value = 100\n    },\n    {\n      symbol\
    \ = 'l',\n      value = 50\n    },\n    {\n      symbol = 'x',\n      value =\
    \ 10\n    },\n    {\n      symbol = 'v',\n      value = 5\n    },\n    {\n   \
    \   symbol = 'i',\n      value = 1\n    }\n  }\n  for k, v in ipairs(map) do\n\
    \    while temp >= v.value do\n      result = result .. v.symbol\n      temp =\
    \ temp - v.value\n    end\n  end\n  return result\nend", "  local t = {\n    {1000,\
    \ 'm'},\n    { 900, 'cm'},\n    { 500, 'd'},\n    { 400, 'cd'},\n    { 100, 'c'},\n\
    \    {  90, 'xc'},\n    {  50, 'l'},\n    {  40, 'xl'},\n    {  10, 'x'},\n  \
    \  {   9, 'ix'},\n    {   5, 'v'},\n    {   4, 'iv'},\n    {   1, 'i'},\n  }\n\
    \  local result = \"\"\n  for k, v in ipairs(t) do\n    local n = v[1]\n    local\
    \ s = v[2]\n    while number >= n do\n      result = result .. s\n      number\
    \ = number - n\n    end\n  end\n  return result\nend", "  assert(type(number)\
    \ == 'number' and number > 0 and number <= 1000,\n         'Number must be positive\
    \ and <= 1000')\n  local romans = {\n    [1000] = 'm',\n    [900] = 'cm',\n  \
    \  [500] = 'd',\n    [400] = 'cd',\n    [100] = 'c',\n    [90] = 'xc',\n    [50]\
    \ = 'l',\n    [40] = 'xl',\n    [10] = 'x',\n    [9] = 'ix',\n    [5] = 'v',\n\
    \    [4] = 'iv',\n    [1] = 'i'\n  }\n  local result = ''\n  for i, roman in pairs(romans)\
    \ do\n    while number >= i do\n      result = result .. roman\n      number =\
    \ number - i\n    end\n  end\n  return result\nend", "  assert(type(number) ==\
    \ 'number' and number >= 1 and number <= 1000,\n         'number must be an integer\
    \ in [1, 1000]')\n  local numerals = {}\n  for i = 1, #roman_numeral_map do\n\
    \    local numeral, arabic = unpack(roman_numeral_map[i])\n    local quotient\
    \ = math.floor(number / arabic)\n    if quotient > 0 then\n      number = number\
    \ - quotient * arabic\n      while quotient > 0 do\n        table.insert(numerals,\
    \ numeral)\n        quotient = quotient - 1\n      end\n    end\n  end\n  return\
    \ table.concat(numerals):lower()\nend", "    assert(type(number) == 'number',\
    \ 'Number expected')\n    assert(number > 0, 'Positive number expected')\n   \
    \ assert(number <= 1000, 'Number should be <= 1000')", "  -- convert it to a string\n\
    \  number = tostring(number)\n  local result = \"\"\n  local digit = #number\n\
    \  for i = 1, digit do\n    local n = tonumber(number:sub(i, i))\n    -- a tricky\
    \ way to make sure the last digit will not be padded\n    local k = i == digit\
    \ and 1 or 0\n    if n <= 3 then\n      result = result .. string.rep(\"I\", n)\n\
    \    elseif n == 4 then\n      result = result .. \"IV\"\n    elseif n == 5 then\n\
    \      result = result .. \"V\"\n    elseif n <= 8 then\n      result = result\
    \ .. \"V\" .. string.rep(\"I\", n - 5)\n    elseif n == 9 then\n      result =\
    \ result .. \"IX\"\n    end\n    if digit - i > 0 then\n      -- when it has more\
    \ than 1 digit, it should be padded by \"X\"\n      result = result .. string.rep(\"\
    X\", digit - i - k)\n    end\n  end\n  return result\nend", "  if number < 1 or\
    \ number > 1000 then\n    return nil\n  end\n  local romans = {\n    'm', 'cm',\
    \ 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i'\n  }\n  local ints\
    \ = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n  local numeral =\
    \ \"\"\n  for index, value in ipairs(ints) do\n    while number >= value do\n\
    \      number = number - value\n      numeral = numeral .. romans[index]\n   \
    \ end\n  end\n  return numeral\nend", "  local roman_map = {\n    M  = 1000,\n\
    \    CM = 900,\n    D  = 500,\n    CD = 400,\n    C  = 100,\n    XC = 90,\n  \
    \  L  = 50,\n    XL = 40,\n    X  = 10,\n    IX = 9,\n    V  = 5,\n    IV = 4,\n\
    \    I  = 1\n  }\n  local roman_string = \"\"\n  for roman, value in pairs(roman_map)\
    \ do\n    local n = math.floor(number / value)\n    number = number - n * value\n\
    \    roman_string = roman_string .. roman:rep(n)\n  end\n  return roman_string\n\
    end", "    local roman = ''\n    for _, int_roman in ipairs(MiniRomanNumerals)\
    \ do\n        local numeral = int_roman[1]\n        local int_value = int_roman[2]\n\
    \        while number >= int_value do\n            roman = roman .. numeral\n\
    \            number = number - int_value\n        end\n    end\n    return roman\n\
    end", "    if number <= 0 or number > 1000 then\n        error(number .. \" is\
    \ out of bounds\")\n    end\n    local result = ''\n    while number >= 1000 do\n\
    \        result = result .. 'm'\n        number = number - 1000\n    end\n   \
    \ if number >= 900 then\n        result = result .. 'cm'\n        number = number\
    \ - 900\n    end\n    if number >= 500 then\n        result = result .. 'd'\n\
    \        number = number - 500\n    end\n    if number >= 400 then\n        result\
    \ = result .. 'cd'\n        number = number - 400\n    end\n    while number >=\
    \ 100 do\n        result = result .. 'c'\n        number = number - 100\n    end\n\
    \    if number >= 90 then\n        result = result .. 'xc'\n        number = number\
    \ - 90\n    end\n    if number >= 50 then\n        result = result .. 'l'\n  \
    \      number = number - 50\n    end\n    if number >= 40 then\n        result\
    \ = result .. 'xl'\n        number = number - 40\n    end\n    while number >=\
    \ 10 do\n        result = result .. 'x'\n        number = number - 10\n    end\n\
    \    if number >= 9 then\n        result = result .. 'ix'\n        number = number\
    \ - 9\n    end\n    if number >= 5 then\n        result = result .. 'v'\n    \
    \    number = number - 5\n    end\n    if number >= 4 then\n        result = result\
    \ .. 'iv'\n        number = number - 4\n    end\n    while number >= 1 do\n  \
    \      result = result .. 'i'\n        number = number - 1\n    end\n    return\
    \ result\nend", "\tif number > 1000 then\n\t\terror('Roman numerals: cannot encode\
    \ number ' .. number)\n\tend\n\tif number <= 0 then\n\t\terror('Roman numerals:\
    \ cannot encode number ' .. number)\n\tend\n\tlocal mini_roman_numerals = {\n\t\
    \t[\"0\"] = \"\",\n\t\t[\"1\"] = \"i\",\n\t\t[\"2\"] = \"ii\",\n\t\t[\"3\"] =\
    \ \"iii\",\n\t\t[\"4\"] = \"iv\",\n\t\t[\"5\"] = \"v\",\n\t\t[\"6\"] = \"vi\"\
    ,\n\t\t[\"7\"] = \"vii\",\n\t\t[\"8\"] = \"viii\",\n\t\t[\"9\"] = \"ix\",\n\t\t\
    [\"10\"] = \"x\",\n\t\t[\"20\"] = \"xx\",\n\t\t[\"30\"] = \"xxx\",\n\t\t[\"40\"\
    ] = \"xl\",\n\t\t[\"50\"] = \"l\",\n\t\t[\"60\"] = \"lx\",\n\t\t[\"70\"] = \"\
    lxx\",\n\t\t[\"80\"] = \"lxxx\",\n\t\t[\"90\"] = \"xc\",\n\t\t[\"100\"] = \"c\"\
    ,\n\t\t[\"200\"] = \"cc\",\n\t\t[\"300\"] = \"ccc\",\n\t\t[\"400\"] = \"cd\",\n\
    \t\t[\"500\"] = \"d\",\n\t\t[\"600\"] = \"dc\",\n\t\t[\"700\"] = \"dcc\",\n\t\t\
    [\"800\"] = \"dccc\",\n\t\t[\"900\"] = \"cm\",\n\t\t[\"1000\"] = \"m\",\n\t}\n\
    \tlocal s = tostring(number)\n\tlocal result = \"\"\n\tfor i = 1, #s do\n\t\t\
    local digit = s:sub(i, i)\n\t\tlocal place = #s - i + 1\n\t\tlocal value = digit\
    \ .. (\"0\"):rep(place - 1)\n\t\tif mini_roman_numerals[value] then\n\t\t\tresult\
    \ = result .. mini_roman_numerals[value]\n\t\telse\n\t\t\terror('Roman numerals:\
    \ cannot encode number ' .. number)\n\t\tend\n\tend\n\treturn result\nend", " \
    \   -- TODO: Implement this function.\n    return \"something\"\nend", "  local\
    \ digits = {}\n  while number > 0 do\n    table.insert(digits, 1, number % 10)\n\
    \    number = math.floor(number / 10)\n  end\n  return table.concat(digits_to_mini_roman(digits))\n\
    end", "    local mini_roman_numerals = {\n        [1] = 'i', [2] = 'ii', [3] =\
    \ 'iii', [4] = 'iv', [5] = 'v',\n        [6] = 'vi', [7] = 'vii', [8] = 'viii',\
    \ [9] = 'ix', [10] = 'x',\n        [20] = 'xx', [30] = 'xxx', [40] = 'xl', [50]\
    \ = 'l',\n        [60] = 'lx', [70] = 'lxx', [80] = 'lxxx', [90] = 'xc', [100]\
    \ = 'c',\n        [200] = 'cc', [300] = 'ccc', [400] = 'cd', [500] = 'd',\n  \
    \      [600] = 'dc', [700] = 'dcc', [800] = 'dccc', [900] = 'cm', [1000] = 'm'\n\
    \    }\n    local result = ''\n    local divisor = 1\n    while number > 0 do\n\
    \        local digit = number % 10\n        local roman_numeral = mini_roman_numerals[digit\
    \ * divisor]\n        if roman_numeral then\n            result = roman_numeral\
    \ .. result\n        end\n        number = math.floor(number / 10)\n        divisor\
    \ = divisor * 10\n    end\n    return result\nend", "    -- The \"ones\" position\
    \ is always easy:\n    local roman = mini_roman_ones[number % 10]\n    number\
    \ = math.floor(number / 10)\n    -- The \"tens\" position also is usually easy,\
    \ but we have to\n    -- take care of multiples of 50:\n    local tens = number\
    \ % 10\n    if tens == 5 then\n        roman = mini_roman_fives[tens] .. roman\n\
    \    else\n        roman = mini_roman_ones[tens] .. mini_roman_tens .. roman\n\
    \    end\n    number = math.floor(number / 10)\n    -- The \"hundreds\" position\
    \ is always easy:\n    roman = mini_roman_ones[number] .. mini_roman_hundreds\
    \ .. roman\n    return roman\nend", "  local symbols = {\n    {1000, 'm'},\n \
    \   {500, 'd'},\n    {100, 'c'},\n    {50, 'l'},\n    {10, 'x'},\n    {5, 'v'},\n\
    \    {1, 'i'}\n  }\n  local result = ''\n  for _, item in ipairs(symbols) do\n\
    \    local value, symbol = item[1], item[2]\n    local times = math.floor(number\
    \ / value)\n    result = result .. symbol:rep(times)\n    number = number - times\
    \ * value\n  end\n  return result\nend", "  local output = {}\n  while number\
    \ > 0 do\n    local index = util.find_le(table.unpack(roman_numerals))\n    local\
    \ base = roman_numerals[index]\n    if number >= base then\n      table.insert(output,\
    \ symbols[index])\n      number = number - base\n    else\n      index = index\
    \ - 1\n    end\n  end\n  return table.concat(output)\nend", "    local function\
    \ convert(number, n_10, n_5, n_1)\n        local ret = ''\n        if number >=\
    \ n_10 then\n            ret = ret .. convert(number - n_10, n_10, n_5, n_1)\n\
    \        elseif number >= n_5 then\n            if number >= n_5 + n_1 then\n\
    \                ret = ret .. convert(number - n_5 - n_1, n_10, n_5, n_1)\n  \
    \          end\n            ret = ret .. convert(n_5, n_10, n_5, n_1)\n      \
    \  elseif number >= n_1 then\n            if number >= n_1 + n_1 then\n      \
    \          ret = ret .. convert(number - n_1 - n_1, n_10, n_5, n_1)\n        \
    \    end\n            ret = ret .. convert(n_1, n_10, n_5, n_1)\n        else\n\
    \            ret = ret .. roman_table[number]\n        end\n        return ret\n\
    \    end\n    return convert(number, roman_table.M, roman_table.C, roman_table.X)\n\
    end", "    if number > 1000 then\n        return nil\n    end\n    local romans\
    \ = {'i', 'v', 'x', 'l', 'c', 'd', 'm'}\n    local str = ''\n    local rep = 1\n\
    \    while number > 0 do\n        local digi = number % 10\n        if digi ==\
    \ 4 then\n            str = romans[rep] .. romans[rep + 1] .. str\n        elseif\
    \ digi == 9 then\n            str = romans[rep] .. romans[rep + 2] .. str\n  \
    \      else\n            local five = false\n            if digi >= 5 then\n \
    \               digi = digi - 5\n                five = true\n            end\n\
    \            if five then\n                str = romans[rep + 1] .. str\n    \
    \        end\n            for _ = 1, digi do\n                str = romans[rep]\
    \ .. str\n            end\n        end\n        number = math.floor(number / 10)\n\
    \        rep = rep + 2\n    end\n    return str\nend", "    local result = ''\n\
    \    local symbols = {\n        {1000, 'm'},\n        {900, 'cm'},\n        {500,\
    \ 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n    \
    \    {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    for _, pair\
    \ in ipairs(symbols) do\n        local limit, symbol = table.unpack(pair)\n  \
    \      while number >= limit do\n            result = result .. symbol\n     \
    \       number = number - limit\n        end\n    end\n    return result\nend",
  "    assert(number >= 1 and number <= 1000, \"Invalid number\")\n    local romans\
    \ = {}\n    for i = 1, number do\n        table.insert(romans, 'i')\n    end\n\
    \    local m = {}\n    table.insert(m, {[1000] = 'm'})\n    table.insert(m, {[500]\
    \ = 'd'})\n    table.insert(m, {[100] = 'c'})\n    table.insert(m, {[50] = 'l'})\n\
    \    table.insert(m, {[10] = 'x'})\n    table.insert(m, {[5] = 'v'})\n    table.insert(m,\
    \ {[1] = 'i'})\n    local nums = {1000, 500, 100, 50, 10, 5, 1}\n    for i = 1,\
    \ #m do\n        while #romans >= nums[i] and romans[#romans] == 'i' do\n    \
    \        if romans[#romans - 1] == m[i][nums[i]] then\n                table.remove(romans,\
    \ #romans)\n                table.remove(romans, #romans)\n                table.insert(romans,\
    \ m[i][nums[i]] .. m[i + 1][nums[i]])\n            else\n                table.remove(romans,\
    \ #romans)\n                table.insert(romans, m[i][nums[i]])\n            end\n\
    \        end\n    end\n    return table.concat(romans)\nend", "    local numerals\
    \ = {\n        {1000, 'm'},\n        {900, 'cm'},\n        {500, 'd'},\n     \
    \   {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n        {50, 'l'},\n\
    \        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n        {5, 'v'},\n\
    \        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result = ''\n    for i\
    \ = 1, #numerals do\n        local arabic, roman = table.unpack(numerals[i])\n\
    \        while number >= arabic do\n            result = result .. roman\n   \
    \         number = number - arabic\n        end\n    end\n    return result\n\
    end", "    -- Answer goes here\n    local function get_digits(n)\n        return\
    \ n%10, math.floor(n/10)\n    end\n    local function normalize(roman_numeral)\n\
    \        local rn = roman_numeral\n        if string.len(rn) > 1 then\n      \
    \      for i = 1, string.len(rn) - 1 do\n                if romans[string.sub(rn,\
    \ i, i)] < romans[string.sub(rn, i + 1, i + 1)] then\n                    rn =\
    \ string.sub(rn, 1, i - 1) .. string.sub(rn, i + 1)\n                end\n   \
    \         end\n        end\n        return rn\n    end\n    local function iter(n,\
    \ rn)\n        if n <= 0 then\n            return rn\n        else\n         \
    \   local digit, remaining = get_digits(n)\n            return iter(remaining,\
    \ (norm_romans[digit] or '') .. rn)\n        end\n    end\n    return iter(number,\
    \ '')\nend", "    local digits = {}\n    for digit in tostring(number):gmatch('%d')\
    \ do\n        table.insert(digits, tonumber(digit))\n    end\n    -- The digit\
    \ counts need to be reversed,\n    -- so that the following code can be index-wise\n\
    \    -- consistent with the symbols array.\n    local reversed_digits = { table.unpack(digits)\
    \ }\n    local num_digits = #reversed_digits\n    for i = 1, num_digits / 2 do\n\
    \        reversed_digits[i], reversed_digits[num_digits - i + 1] =\n         \
    \   reversed_digits[num_digits - i + 1], reversed_digits[i]\n    end\n    local\
    \ mini_roman = ''\n    local symbols = { 'i', 'x', 'c', 'm' }\n    for exp, digit\
    \ in ipairs(reversed_digits) do\n        if digit < 4 then\n            mini_roman\
    \ = string.rep(symbols[exp], digit) .. mini_roman\n        elseif digit == 4 then\n\
    \            mini_roman = symbols[exp] .. symbols[exp + 1] .. mini_roman\n   \
    \     elseif digit == 5 then\n            mini_roman = symbols[exp + 1] .. mini_roman\n\
    \        elseif digit < 9 then\n            mini_roman = symbols[exp + 1] .. string.rep(symbols[exp],\
    \ digit - 5) .. mini_roman\n        elseif digit == 9 then\n            mini_roman\
    \ = symbols[exp] .. symbols[exp + 2] .. mini_roman\n        end\n    end\n   \
    \ return mini_roman\nend", "    local roman_numerals = {\n        {1, \"i\"},\n\
    \        {4, \"iv\"},\n        {5, \"v\"},\n        {9, \"ix\"},\n        {10,\
    \ \"x\"},\n        {40, \"xl\"},\n        {50, \"l\"},\n        {90, \"xc\"},\n\
    \        {100, \"c\"},\n        {400, \"cd\"},\n        {500, \"d\"},\n      \
    \  {900, \"cm\"},\n        {1000, \"m\"}\n    }\n    local mini_roman = \"\"\n\
    \    for i = #roman_numerals, 1, -1 do\n        local int, roman = unpack(roman_numerals[i])\n\
    \        while number >= int do\n            mini_roman = mini_roman .. roman\n\
    \            number = number - int\n        end\n    end\n    return mini_roman\n\
    end", "    local str = \"\"\n    local l = {\n        {1000, \"m\"},\n       \
    \ {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100,\
    \ \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n\
    \        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4,\
    \ \"iv\"},\n        {1, \"i\"}\n    }\n    for k, v in ipairs(l) do\n        if\
    \ number >= v[1] then\n            for i = 1, math.floor(number / v[1]) do\n \
    \               str = str .. v[2]\n            end\n            number = number\
    \ % v[1]\n        end\n    end\n    return str\nend", "  local numeral = '?'\n\
    \  local thousands = math.floor(number / 1000)\n  local hundreds = math.floor((number\
    \ - thousands * 1000) / 100)\n  local tens = math.floor((number - thousands *\
    \ 1000 - hundreds * 100) / 10)\n  local units = number - thousands * 1000 - hundreds\
    \ * 100 - tens * 10\n  numeral = string.rep('m', thousands)\n  numeral = numeral\
    \ .. string.rep('c', hundreds)\n  numeral = numeral .. string.rep('x', tens)\n\
    \  numeral = numeral .. string.rep('i', units)\n  numeral = string.gsub(numeral,\
    \ 'dc{1,3}', 'cm')\n  numeral = string.gsub(numeral, 'lc{1,3}', 'cd')\n  numeral\
    \ = string.gsub(numeral, 'xc{1,3}', 'xc')\n  numeral = string.gsub(numeral, 'vx{1,3}',\
    \ 'xc')\n  numeral = string.gsub(numeral, 'iv{1,3}', 'ix')\n  numeral = string.gsub(numeral,\
    \ 'v{1,3}', 'x')\n  numeral = string.gsub(numeral, 'i{1,3}', 'v')\n  numeral =\
    \ string.gsub(numeral, 'mm{1,3}', 'm')\n  numeral = string.gsub(numeral, 'cm{1,3}',\
    \ 'm')\n  numeral = string.gsub(numeral, 'cd{1,3}', 'd')\n  numeral = string.gsub(numeral,\
    \ 'xc{1,3}', 'c')\n  numeral = string.gsub(numeral, 'ix{1,3}', 'x')\n  numeral\
    \ = string.gsub(numeral, 'iv{1,3}', 'v')\n  numeral = string.gsub(numeral, 'mm{1,3}',\
    \ 'm')\n  numeral = string.gsub(numeral, 'cm{1,3}', 'm')\n  numeral = string.gsub(num",
  "    local romans = {M = 1000, CM = 900, D = 500, CD = 400, C = 100, XC = 90, L\
    \ = 50, XL = 40, X = 10, IX = 9, V = 5, IV = 4, I = 1}\n    local roman_numeral\
    \ = \"\"\n    for numeral, integer in pairs(romans) do\n        while number >=\
    \ integer do\n            roman_numeral = roman_numeral .. numeral\n         \
    \   number = number - integer\n        end\n    end\n    return roman_numeral\n\
    end", "  -- your implementation here\n  local out = ''\n  local rem = number\n\
    \  while rem > 0 do\n    local nextnum = get_mini_roman_num(rem)\n    out = out\
    \ .. mini_roman_nums[nextnum]\n    rem = rem - nextnum\n  end\n  return out\n\
    end", "  -- Convert string to number\n  number = tonumber(number)\n  local numerals\
    \ = {'i', 'v', 'x', 'l', 'c', 'd', 'm'}\n  local miniroman = ''\n  local unit\
    \ = number % 10\n  local tens = (number % 100 - unit) / 10\n  local hundreds =\
    \ (number % 1000 - tens * 10 - unit) / 100\n  local thousands = (number - hundreds\
    \ * 100 - tens * 10 - unit) / 1000\n  local strnum = tostring(number)\n  local\
    \ strlen = strnum:len()\n  local prefix = strlen - 1\n  -- convert unit\n  if\
    \ unit == 9 then\n    miniroman = miniroman .. numerals[prefix * 2 + 1] .. numerals[prefix\
    \ * 2 + 3]\n  elseif unit >= 5 then\n    miniroman = miniroman .. numerals[prefix\
    \ * 2 + 2]\n    for i = 1, unit - 5 do\n      miniroman = miniroman .. numerals[prefix\
    \ * 2 + 1]\n    end\n  elseif unit == 4 then\n    miniroman = miniroman .. numerals[prefix\
    \ * 2 + 1] .. numerals[prefix * 2 + 2]\n  else\n    for i = 1, unit do\n     \
    \ miniroman = miniroman .. numerals[prefix * 2 + 1]\n    end\n  end\n  -- convert\
    \ tens\n  prefix = prefix - 1\n  if tens == 9 then\n    miniroman = numerals[prefix\
    \ * 2 + 1] .. numerals[prefix * 2 + 3] .. miniroman\n  elseif tens >= 5 then\n\
    \    miniroman = numerals[prefix * 2 + 2] .. miniroman\n    for i = 1, tens -\
    \ 5 do\n      miniroman = numerals[prefix * 2 + 1] .. miniroman\n    end\n  elseif\
    \ tens == 4 then\n    miniroman = numerals[prefix * 2 + 1] .. numerals[prefix\
    \ * 2 + 2] .. miniroman\n  else\n    for i = 1, tens do\n      miniroman = numerals[prefix\
    \ * 2 + 1] .. miniroman\n    end\n  end\n  -- convert hundreds\n  prefix = prefix\
    \ -", "    local hash = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n\
    \    local roman = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v',\
    \ 'iv', 'i'}\n    local result = \"\"\n    for i = 1, #hash do\n        while\
    \ (number >= hash[i]) do\n            number = number - hash[i]\n            result\
    \ = result .. roman[i]\n        end\n    end\n    return result\nend", "    local\
    \ m_table = {1000, 500, 100, 50, 10, 5, 1}\n    local r_table = {'m', 'd', 'c',\
    \ 'l', 'x', 'v', 'i'}\n    local result = ''\n    local i = 1\n    while number\
    \ > 0 do\n        while number >= m_table[i] do\n            number = number -\
    \ m_table[i]\n            result = result .. r_table[i]\n        end\n       \
    \ if i < #m_table and number >= m_table[i] - m_table[i + 2] then\n           \
    \ number = number - (m_table[i] - m_table[i + 2])\n            result = result\
    \ .. r_table[i + 2] .. r_table[i]\n        end\n        i = i + 1\n    end\n \
    \   return result\nend", "    -- TODO\nend", "    -- Convert the integer to a\
    \ string, then for each character in the string,\n    -- replace the digit with\
    \ its roman numeral equivalent.\n    local number_str = tostring(number)\n   \
    \ local result = ''\n    for i = 1, #number_str do\n        local place = number_str:sub(i,\
    \ i)\n        local int_to_roman_map = {\n            ['1'] = 'i',\n         \
    \   ['2'] = 'ii',\n            ['3'] = 'iii',\n            ['4'] = 'iv',\n   \
    \         ['5'] = 'v',\n            ['6'] = 'vi',\n            ['7'] = 'vii',\n\
    \            ['8'] = 'viii',\n            ['9'] = 'ix',\n        }\n        result\
    \ = result .. int_to_roman_map[place]\n    end\n    return result\nend", "   \
    \ local as_string = \"\"\n    local current_number = number\n    while current_number\
    \ > 0 do\n        for arabic, roman in pairs(arabic_to_roman) do\n           \
    \ if current_number >= arabic then\n                as_string = as_string .. roman\n\
    \                current_number = current_number - arabic\n                break\n\
    \            end\n        end\n    end\n    return as_string\nend", "  local result\
    \ = ''\n  local nums = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix',\
    \ 'v', 'iv', 'i'}\n  local decs = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,\
    \ 5, 4, 1}\n  for i = 1, #decs do\n    local count = 0\n    while number >= decs[i]\
    \ do\n      count = count + 1\n      number = number - decs[i]\n    end\n    if\
    \ count > 0 then\n      result = result .. nums[i]:rep(count)\n    end\n  end\n\
    \  return result\nend", "  local m = {\n    ['0'] = \"\",\n    ['1'] = \"i\",\n\
    \    ['2'] = \"ii\",\n    ['3'] = \"iii\",\n    ['4'] = \"iv\",\n    ['5'] = \"\
    v\",\n    ['6'] = \"vi\",\n    ['7'] = \"vii\",\n    ['8'] = \"viii\",\n    ['9']\
    \ = \"ix\"\n  }\n  local n = {\n    ['0'] = \"\",\n    ['1'] = \"x\",\n    ['2']\
    \ = \"xx\",\n    ['3'] = \"xxx\",\n    ['4'] = \"xl\",\n    ['5'] = \"l\",\n \
    \   ['6'] = \"lx\",\n    ['7'] = \"lxx\",\n    ['8'] = \"lxxx\",\n    ['9'] =\
    \ \"xc\"\n  }\n  local o = {\n    ['0'] = \"\",\n    ['1'] = \"c\",\n    ['2']\
    \ = \"cc\",\n    ['3'] = \"ccc\",\n    ['4'] = \"cd\",\n    ['5'] = \"d\",\n \
    \   ['6'] = \"dc\",\n    ['7'] = \"dcc\",\n    ['8'] = \"dccc\",\n    ['9'] =\
    \ \"cm\"\n  }\n  local p = {\n    ['0'] = \"\",\n    ['1'] = \"m\",\n    ['2']\
    \ = \"mm\",\n    ['3'] = \"mmm\"\n  }\n  if number > 1000 then\n    return \"\"\
    \n  end\n  local new_number = \"\" .. number\n  local len = string.len(new_number)\n\
    \  local a = string.sub(new_number, len - 3, len - 3)\n  local b = string.sub(new_number,\
    \ len - 2, len - 2)\n  local c = string.sub(new_number, len - 1, len - 1)\n  local\
    \ d = string.sub(new_number, len, len)\n  local value = p[a] .. o[b] .. n[c] ..\
    \ m[d]\n  return value\nend", "  local res = ''\n  local nums = {'i', 'v', 'x',\
    \ 'l', 'c', 'd', 'm'}\n  local div = {0, 1, 2, 2, 2, 2, 3}\n  for i = 7, 1, -1\
    \ do\n    local power = 10 ^ div[i]\n    local temp = math.floor(number / power)\n\
    \    if temp == 0 then\n      goto continue\n    end\n    if temp == 9 then\n\
    \      res = res .. nums[i] .. nums[i + 2]\n    elseif temp >= 5 then\n      res\
    \ = res .. nums[i + 1]\n      for j = 1, temp - 5 do\n        res = res .. nums[i]\n\
    \      end\n    elseif temp == 4 then\n      res = res .. nums[i] .. nums[i +\
    \ 1]\n    else\n      for j = 1, temp do\n        res = res .. nums[i]\n     \
    \ end\n    end\n    number = number % power\n    ::continue::\n  end\n  return\
    \ res\nend", "    number = tonumber(number)\n    assert(number >= 1 and number\
    \ <= 1000, \"Number out of range\")\n    local result = \"\"\n    local digit_array\
    \ = to_digit_array(number)\n    result = result .. string.rep(\"m\", digit_array[4])\n\
    \    result = result .. string.rep(\"c\", digit_array[3])\n    result = result\
    \ .. string.rep(\"x\", digit_array[2])\n    result = result .. string.rep(\"i\"\
    , digit_array[1])\n    result = result .. string.rep(\"m\", digit_array[5])\n\
    \    result = result .. string.rep(\"c\", digit_array[6])\n    result = result\
    \ .. string.rep(\"x\", digit_array[7])\n    result = result .. string.rep(\"i\"\
    , digit_array[8])\n    result = result .. string.rep(\"m\", digit_array[9])\n\
    \    result = result .. string.rep(\"c\", digit_array[10])\n    result = result\
    \ .. string.rep(\"x\", digit_array[11])\n    result = result .. string.rep(\"\
    i\", digit_array[12])\n    result = result .. string.rep(\"m\", digit_array[13])\n\
    \    result = result .. string.rep(\"c\", digit_array[14])\n    result = result\
    \ .. string.rep(\"x\", digit_array[15])\n    result = result .. string.rep(\"\
    i\", digit_array[16])\n    result = result .. string.rep(\"m\", digit_array[17])\n\
    \    result = result .. string.rep(\"c\", digit_array[18])\n    result = result\
    \ .. string.rep(\"x\", digit_array[19])\n    result = result .. string.rep(\"\
    i\", digit_array[20])\n    result = result .. string.rep(\"m\", digit_array[21])\n\
    \    result = result .. string.rep(\"c\", digit_array[22])\n    result = result\
    \ .. string.rep(\"x\", digit_array[23])\n    result = result .. string.rep(\"\
    i\", digit_array[24])\n    result = result .. string.rep(\"m\", digit_array[25])\n\
    \    result = result .. string.rep(\"c\", digit_", "  local romans = {\n    {\
    \ 'm', 1000 },\n    { 'cm', 900 },\n    { 'd', 500 },\n    { 'cd', 400 },\n  \
    \  { 'c', 100 },\n    { 'xc', 90 },\n    { 'l', 50 },\n    { 'xl', 40 },\n   \
    \ { 'x', 10 },\n    { 'ix', 9 },\n    { 'v', 5 },\n    { 'iv', 4 },\n    { 'i',\
    \ 1 }\n  }\n  local result = ''\n  for i = 1, #romans do\n    local roman = romans[i]\n\
    \    local reps = math.floor(number / roman[2])\n    for j = 1, reps do\n    \
    \  result = result .. roman[1]\n    end\n    number = number % roman[2]\n  end\n\
    \  return result\nend", "  if type(number) ~= 'number' then\n    return nil\n\
    \  end\n  if number < 1 or number > 1000 then\n    return nil\n  end\n  local\
    \ mini_roman_table = {\n    M=1000,\n    D=500,\n    C=100,\n    L=50,\n    X=10,\n\
    \    V=5,\n    I=1\n  }\n  local mini_roman_numeral = ''\n  local remainder =\
    \ number\n  while remainder > 0 do\n    for value, letter in pairs(mini_roman_table)\
    \ do\n      if remainder >= letter then\n        mini_roman_numeral = mini_roman_numeral\
    \ .. value\n        remainder = remainder - letter\n        break\n      end\n\
    \    end\n  end\n  return mini_roman_numeral\nend", "    local m = {\n       \
    \ {'', 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix'},\n        {'',\
    \ 'x', 'xx', 'xxx', 'xl', 'l', 'lx', 'lxx', 'lxxx', 'xc'},\n        {'', 'c',\
    \ 'cc', 'ccc', 'cd', 'd', 'dc', 'dcc', 'dccc', 'cm'},\n        {'', 'm', 'mm',\
    \ 'mmm'}\n    }\n    local function convert(n, a)\n        if n == 0 then\n  \
    \          return ''\n        else\n            return m[a][math.floor(n % 10)\
    \ + 1] .. convert(math.floor(n / 10), a + 1)\n        end\n    end\n    return\
    \ convert(number, 1)\nend", "  local M = {1000, 500, 100, 50, 10, 5, 1}\n  local\
    \ D = {'m', 'd', 'c', 'l', 'x', 'v', 'i'}\n  local Z = {'', '', 'cd', 'cm', '',\
    \ '', 'ix', 'iv'}\n  local A = {0, 0, 0, 0, 0, 0, 0, 0}\n  local N = number\n\
    \  for J = 1, 7 do\n    local K = math.floor(N / M[J])\n    N = N - K * M[J]\n\
    \    if K < 4 then\n      for L = 1, K do\n        A[J] = A[J] .. D[J]\n     \
    \ end\n    else\n      A[J + 1] = D[J + 1]\n      A[J] = D[J]\n    end\n  end\n\
    \  local S = A[1] .. A[2] .. A[3] .. A[4] .. A[5] .. A[6] .. A[7]\n  S = string.gsub(S,\
    \ Z[1], Z[2])\n  S = string.gsub(S, Z[3], Z[4])\n  S = string.gsub(S, Z[5], Z[6])\n\
    \  S = string.gsub(S, Z[7], Z[8])\n  return S\nend", "  -- First we create a map\
    \ of roman numberals\n  local roman_numberals = {\n    [1] = 'i',\n    [5] = 'v',\n\
    \    [10] = 'x',\n    [50] = 'l',\n    [100] = 'c',\n    [500] = 'd',\n    [1000]\
    \ = 'm'\n  }", "    if number == 0 then\n        return ''\n    elseif number\
    \ >= 1000 then\n        return 'm' .. int_to_mini_roman(number - 1000)\n    elseif\
    \ number >= 900 then\n        return 'cm' .. int_to_mini_roman(number - 900)\n\
    \    elseif number >= 500 then\n        return 'd' .. int_to_mini_roman(number\
    \ - 500)\n    elseif number >= 400 then\n        return 'cd' .. int_to_mini_roman(number\
    \ - 400)\n    elseif number >= 100 then\n        return 'c' .. int_to_mini_roman(number\
    \ - 100)\n    elseif number >= 90 then\n        return 'xc' .. int_to_mini_roman(number\
    \ - 90)\n    elseif number >= 50 then\n        return 'l' .. int_to_mini_roman(number\
    \ - 50)\n    elseif number >= 40 then\n        return 'xl' .. int_to_mini_roman(number\
    \ - 40)\n    elseif number >= 10 then\n        return 'x' .. int_to_mini_roman(number\
    \ - 10)\n    elseif number >= 9 then\n        return 'ix' .. int_to_mini_roman(number\
    \ - 9)\n    elseif number >= 5 then\n        return 'v' .. int_to_mini_roman(number\
    \ - 5)\n    elseif number >= 4 then\n        return 'iv' .. int_to_mini_roman(number\
    \ - 4)\n    elseif number >= 1 then\n        return 'i' .. int_to_mini_roman(number\
    \ - 1)\n    end\nend", "    local roman_numerals = {\n        ['1'] = 'i',\n \
    \       ['2'] = 'ii',\n        ['3'] = 'iii',\n        ['4'] = 'iv',\n       \
    \ ['5'] = 'v',\n        ['6'] = 'vi',\n        ['7'] = 'vii',\n        ['8'] =\
    \ 'viii',\n        ['9'] = 'ix',\n        ['10'] = 'x',\n        ['20'] = 'xx',\n\
    \        ['30'] = 'xxx',\n        ['40'] = 'xl',\n        ['50'] = 'l',\n    \
    \    ['60'] = 'lx',\n        ['70'] = 'lxx',\n        ['80'] = 'lxxx',\n     \
    \   ['90'] = 'xc',\n        ['100'] = 'c',\n        ['200'] = 'cc',\n        ['300']\
    \ = 'ccc',\n        ['400'] = 'cd',\n        ['500'] = 'd',\n        ['600'] =\
    \ 'dc',\n        ['700'] = 'dcc',\n        ['800'] = 'dccc',\n        ['900']\
    \ = 'cm',\n        ['1000'] = 'm',\n    }\n    local number_string = tostring(number)\n\
    \    local number_table = {}\n    for i = 1, #number_string do\n        local\
    \ digit = number_string:sub(i, i)\n        local table_index = (#number_string\
    \ - i + 1) * 10^(i - 1)\n        number_table[table_index] = digit\n    end\n\
    \    local roman_string = ''\n    for i = 1000, 1, -1 do\n        if number_table[i]\
    \ then\n            roman_string = roman_string .. roman_numerals[number_table[i]\
    \ .. string.rep('0', #tostring(i))]\n        end\n    end\n    return roman_string\n\
    end", "    local ret = \"\"\n    local numerals = {\n        {1000, \"m\"},\n\
    \        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n     \
    \   {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"\
    xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n    \
    \    {4, \"iv\"},\n        {1, \"i\"}\n    }\n    for k,v in ipairs(numerals)\
    \ do\n        while number >= v[1] do\n            ret = ret .. v[2]\n       \
    \     number = number - v[1]\n        end\n    end\n    return ret\nend", "  \
    \  local keys = {1000, 500, 100, 50, 10, 5, 1}\n    local values = {'m', 'd',\
    \ 'c', 'l', 'x', 'v', 'i'}\n    local mini_roman = ''\n    for i = 1, #keys do\n\
    \        local key = keys[i]\n        local value = values[i]\n        if key\
    \ <= number then\n            local div = math.floor(number / key)\n         \
    \   mini_roman = mini_roman .. string.rep(value, div)\n            number = number\
    \ - (key * div)\n        end\n    end\n    return mini_roman\nend", "  local hund,\
    \ ten, one\n  local res = ''\n  for hund,ten,one in string.gmatch(string.format('%03d',\
    \ number), '%d') do\n    if hund > 0 then\n      res = res .. string.rep('c',\
    \ hund)\n    end\n    if ten == 9 then\n      res = res .. 'xc'\n    elseif ten\
    \ > 4 then\n      res = res .. 'l' .. string.rep('x', ten - 5)\n    elseif ten\
    \ == 4 then\n      res = res .. 'xl'\n    else\n      res = res .. string.rep('x',\
    \ ten)\n    end\n    if one == 9 then\n      res = res .. 'ix'\n    elseif one\
    \ > 4 then\n      res = res .. 'v' .. string.rep('i', one - 5)\n    elseif one\
    \ == 4 then\n      res = res .. 'iv'\n    else\n      res = res .. string.rep('i',\
    \ one)\n    end\n  end\n  return res\nend", "    if number < 1 or number > 1000\
    \ then\n        error(\"invalid number\")\n    end\n    local result = \"\"\n\
    \    local i = 1\n    local digit\n    repeat\n        digit = number % 10\n \
    \       if digit ~= 0 then\n            if i == 1 then\n                result\
    \ = string.rep(mini_roman_digits[i][digit], 1) .. result\n            else\n \
    \               result = mini_roman_digits[i][digit] .. result\n            end\n\
    \        end\n        number = math.floor(number / 10)\n        i = i + 1\n  \
    \  until number == 0\n    return result\nend", "    local roman_mapping = {\n\
    \        [1000] = 'm',\n        [500] = 'd',\n        [100] = 'c',\n        [50]\
    \ = 'l',\n        [10] = 'x',\n        [5] = 'v',\n        [1] = 'i'\n    }\n\
    \    local keys = {1000, 500, 100, 50, 10, 5, 1}\n    local values = {}\n    for\
    \ i = 1, 7 do\n        local item = number // keys[i]\n        if item > 0 then\n\
    \            values[#values + 1] = item * roman_mapping[keys[i]]\n           \
    \ number = number % keys[i]\n        end\n    end\n    local roman = table.concat(values)\n\
    \    roman = roman:gsub('xl', 'xc')\n    roman = roman:gsub('xc', 'l')\n    roman\
    \ = roman:gsub('xv', 'xc')\n    roman = roman:gsub('xc', 'v')\n    roman = roman:gsub('xm',\
    \ 'xc')\n    roman = roman:gsub('xc', 'm')\n    roman = roman:gsub('xix', 'xcix')\n\
    \    roman = roman:gsub('xcix', 'ix')\n    roman = roman:gsub('xii', 'xcii')\n\
    \    roman = roman:gsub('xcii', 'ii')\n    roman = roman:gsub('xiv', 'xciv')\n\
    \    roman = roman:gsub('xciv', 'iv')\n    roman = roman:gsub('xvi', 'xcvi')\n\
    \    roman = roman:gsub('xcvi', 'vi')\n    roman = roman:gsub('xviii', 'xcviii')\n\
    \    roman = roman:gsub('xcviii', 'viii')\n    roman = roman:gsub('xvii', 'xcvii')\n\
    \    roman = roman:gsub('xcvii', 'vii')\n    roman = roman:gsub('xix", "\tassert(number\
    \ >= 1 and number <= 1000, \"int_to_mini_roman: number out of range\")\n\t-- The\
    \ following three functions convert a number from 100-999 or 10-99 or 1-9\n\t\
    -- to a string in the roman notation, using only the letters i, v, x and l.\n\t\
    local function hundreds(n)\n\t\tlocal res = ''\n\t\tlocal ones = n % 10\n\t\t\
    n = (n - ones) / 10\n\t\tlocal tens = n % 10\n\t\tn = (n - tens) / 10\n\t\tlocal\
    \ hundreds = n % 10\n\t\tfor i = 1, hundreds do\n\t\t\tres = res .. 'c'\n\t\t\
    end\n\t\tif tens == 9 then\n\t\t\tres = res .. 'xc'\n\t\telseif tens >= 5 then\n\
    \t\t\tres = res .. 'l'\n\t\t\tfor i = 6, tens do\n\t\t\t\tres = res .. 'x'\n\t\
    \t\tend\n\t\telseif tens == 4 then\n\t\t\tres = res .. 'xl'\n\t\telse\n\t\t\t\
    for i = 1, tens do\n\t\t\t\tres = res .. 'x'\n\t\t\tend\n\t\tend\n\t\tif ones\
    \ == 9 then\n\t\t\tres = res .. 'xi'\n\t\telseif ones >= 5 then\n\t\t\tres = res\
    \ .. 'v'\n\t\t\tfor i = 6, ones do\n\t\t\t\tres = res .. 'i'\n\t\t\tend\n\t\t\
    elseif ones == 4 then\n\t\t\tres = res .. 'iv'\n\t\telse\n\t\t\tfor i = 1, ones\
    \ do\n\t\t\t\tres = res .. 'i'\n\t\t\tend\n\t\tend\n\t\treturn res\n\tend\n\t\
    local function tens(n)\n\t\tlocal res = ''\n\t\tlocal ones = n % 10\n\t\tn = (n\
    \ - ones) / 10\n\t\tlocal tens = n % 10\n\t\tif tens == 9 then\n\t\t\tres = res\
    \ .. 'xc'\n\t\telseif tens >= 5 then\n\t\t\tres = res .. 'l'\n\t\t\tfor i = 6,\
    \ tens", "    assert(number > 0 and number <= 1000, \"Invalid input\")\n    local\
    \ roman = ''\n    for i = 1, #ROMAN_DIGITS do\n        local num_reps = math.floor(number\
    \ / ROMAN_DIGITS[i])\n        if num_reps == 4 then\n            roman = roman\
    \ .. ROMAN_DIGITS[i] .. ROMAN_DIGITS[i+1]\n        else\n            roman = roman\
    \ .. string.rep(ROMAN_DIGITS[i], num_reps)\n        end\n        number = number\
    \ % ROMAN_DIGITS[i]\n    end\n    return roman\nend", "    assert(number >= 1,\
    \ \"Number must be positive\")\n    assert(number <= 1000, \"Number must be less\
    \ than 1000\")\n    local roman_numerals = {\n        {1000, 'm'},\n        {900,\
    \ 'cm'},\n        {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n   \
    \     {90, 'xc'},\n        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n\
    \        {9, 'ix'},\n        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n\
    \    }\n    local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n\
    \        local value, letter = unpack(pair)\n        while number >= value do\n\
    \            result = result .. letter\n            number = number - value\n\
    \        end\n    end\n    return result\nend", "  local numeral = \"\"\n  local\
    \ num = number\n  while num >= 100 do\n    numeral = numeral .. \"c\"\n    num\
    \ = num - 100\n  end\n  while num >= 90 do\n    numeral = numeral .. \"xc\"\n\
    \    num = num - 90\n  end\n  while num >= 50 do\n    numeral = numeral .. \"\
    l\"\n    num = num - 50\n  end\n  while num >= 40 do\n    numeral = numeral ..\
    \ \"xl\"\n    num = num - 40\n  end\n  while num >= 10 do\n    numeral = numeral\
    \ .. \"x\"\n    num = num - 10\n  end\n  while num >= 9 do\n    numeral = numeral\
    \ .. \"ix\"\n    num = num - 9\n  end\n  while num >= 5 do\n    numeral = numeral\
    \ .. \"v\"\n    num = num - 5\n  end\n  while num >= 4 do\n    numeral = numeral\
    \ .. \"iv\"\n    num = num - 4\n  end\n  while num >= 1 do\n    numeral = numeral\
    \ .. \"i\"\n    num = num - 1\n  end\n  return numeral\nend", "  local mini_roman_numerals\
    \ = {\n    'm', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i'\n\
    \  }\n  local mini_roman_numbers = {\n    1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1\n  }\n  local mini_roman_string = ''\n  while number > 0 do\n\
    \    for index, value in ipairs(mini_roman_numbers) do\n      if number >= value\
    \ then\n        mini_roman_string = mini_roman_string .. mini_roman_numerals[index]\n\
    \        number = number - value\n        break\n      end\n    end\n  end\n \
    \ return mini_roman_string\nend", "    -- Get the number of 1000s, 100s, 10s,\
    \ and 1s.\n    local thousands = math.floor(number / 1000)\n    local hundreds\
    \ = math.floor((number - thousands * 1000) / 100)\n    local tens = math.floor((number\
    \ - thousands * 1000 - hundreds * 100) / 10)\n    local ones = number - thousands\
    \ * 1000 - hundreds * 100 - tens * 10", "  local result = ''\n  local number_string\
    \ = tostring(number)\n  local length = #number_string\n  for i = 1, length do\n\
    \    local digit = number_string:sub(i, i)\n    local int_digit = tonumber(digit)\n\
    \    if int_digit == 0 then\n      result = result .. ''\n    elseif int_digit\
    \ <= 3 then\n      for j = 1, int_digit do\n        result = result .. numeral_to_number[length\
    \ - i + 1]\n      end\n    elseif int_digit == 4 then\n      result = result ..\
    \ numeral_to_number[length - i + 1] ..\n        numeral_to_number[length - i +\
    \ 2]\n    elseif int_digit == 5 then\n      result = result .. numeral_to_number[length\
    \ - i + 2]\n    elseif int_digit <= 8 then\n      result = result .. numeral_to_number[length\
    \ - i + 2]\n      for j = 1, int_digit - 5 do\n        result = result .. numeral_to_number[length\
    \ - i + 1]\n      end\n    elseif int_digit == 9 then\n      result = result ..\
    \ numeral_to_number[length - i + 1] ..\n        numeral_to_number[length - i +\
    \ 3]\n    end\n  end\n  return result\nend", "  local romans = {'i', 'ii', 'iii',\
    \ 'iv', 'v', 'vi', 'vii', 'viii', 'ix'}\n  local hundreds = {'c', 'cc', 'ccc',\
    \ 'cd', 'd', 'dc', 'dcc', 'dccc', 'cm'}\n  local thousands = {'m', 'mm', 'mmm'}\n\
    \  local result = ''\n  local hundreds_digits = math.floor(number / 100)\n  local\
    \ tens_digits = math.floor((number - hundreds_digits * 100) / 10)\n  local ones_digits\
    \ = number - hundreds_digits * 100 - tens_digits * 10\n  if hundreds_digits >\
    \ 0 then\n    result = result .. hundreds[hundreds_digits]\n  end\n  if tens_digits\
    \ > 0 then\n    result = result .. romans[tens_digits]\n  end\n  if ones_digits\
    \ > 0 then\n    result = result .. romans[ones_digits]\n  end\n  return result\n\
    end", "    local roman = {}\n    for i = 1, #mini_roman_digits do\n        local\
    \ d, r = unpack(mini_roman_digits[i])\n        while number >= d do\n        \
    \    number = number - d\n            roman[#roman + 1] = r\n        end\n   \
    \ end\n    return table.concat(roman)\nend", "  local s = ''\n  local r = {\n\
    \    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n    {400, 'cd'},\n    {100,\
    \ 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n  \
    \  {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1, 'i'}\n  }\n  for i = 1,\
    \ #r do\n    while number >= r[i][1] do\n      s = s .. r[i][2]\n      number\
    \ = number - r[i][1]\n    end\n  end\n  return s\nend", "\tif (type(number) ~=\
    \ 'number') then\n\t\terror(string.format('Incorrect type for parameter number.\
    \ Expected: number. Got: %s.', type(number)), 2)\n\tend\n\tif ((number < 1) or\
    \ (number > 1000)) then\n\t\terror(string.format('Incorrect value for parameter\
    \ number. Expected: 1 <= number <= 1000. Got: %d.', number), 2)\n\tend\n\tlocal\
    \ roman_numerals = { 'i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd',\
    \ 'cm', 'm' }\n\tlocal roman_values = { 1, 4, 5, 9, 10, 40, 50, 90, 100, 400,\
    \ 500, 900, 1000 }\n\tlocal mini_roman = ''\n\tlocal pos = #roman_values\n\twhile\
    \ (number > 0) do\n\t\tif (number >= roman_values[pos]) then\n\t\t\tnumber = number\
    \ - roman_values[pos]\n\t\t\tmini_roman = mini_roman .. roman_numerals[pos]\n\t\
    \telse\n\t\t\tpos = pos - 1\n\t\tend\n\tend\n\treturn mini_roman\nend", "    local\
    \ roman_numerals = {\n        { 1000, 'm' },\n        { 900, 'cm' },\n       \
    \ { 500, 'd' },\n        { 400, 'cd' },\n        { 100, 'c' },\n        { 90,\
    \ 'xc' },\n        { 50, 'l' },\n        { 40, 'xl' },\n        { 10, 'x' },\n\
    \        { 9, 'ix' },\n        { 5, 'v' },\n        { 4, 'iv' },\n        { 1,\
    \ 'i' },\n    }\n    local string = ''\n    for _, v in ipairs(roman_numerals)\
    \ do\n        while number >= v[1] do\n            string = string .. v[2]\n \
    \           number = number - v[1]\n        end\n    end\n    return string\n\
    end", "    local digit_subtract_map = {\n        [1] = 'i',\n        [2] = 'x',\n\
    \        [3] = 'c',\n        [4] = 'm',\n    }\n    local roman_number = ''\n\
    \    local temp_number = number\n    local current_digit = 1\n    while temp_number\
    \ > 0 do\n        local digit_amount = temp_number % 10\n        temp_number =\
    \ math.floor(temp_number / 10)\n        if digit_amount == 0 then\n          \
    \  current_digit = current_digit + 1\n            goto continue\n        end\n\
    \        if digit_amount <= 3 then\n            roman_number = string.rep(digit_subtract_map[current_digit],\
    \ digit_amount) .. roman_number\n        elseif digit_amount == 4 then\n     \
    \       roman_number = digit_subtract_map[current_digit] .. digit_subtract_map[current_digit\
    \ + 1] .. roman_number\n        elseif digit_amount <= 8 then\n            roman_number\
    \ = digit_subtract_map[current_digit + 1] .. string.rep(digit_subtract_map[current_digit],\
    \ digit_amount - 5) .. roman_number\n        elseif digit_amount == 9 then\n \
    \           roman_number = digit_subtract_map[current_digit] .. digit_subtract_map[current_digit\
    \ + 2] .. roman_number\n        end\n        ::continue::\n    end\n    return\
    \ roman_number\nend", "    local mini_roman_numerals = {\n        { 1, 'i' },\n\
    \        { 5, 'v' },\n        { 10, 'x' },\n        { 50, 'l' },\n        { 100,\
    \ 'c' },\n        { 500, 'd' },\n        { 1000, 'm' }\n    }\n    local romans\
    \ = {}\n    for _, roman in ipairs(mini_roman_numerals) do\n        local value,\
    \ symbol = unpack(roman)\n        if number >= value then\n            local count\
    \ = math.floor(number / value)\n            for i = 1, count do\n            \
    \    table.insert(romans, symbol)\n            end\n            number = number\
    \ % value\n        end\n    end\n    local result = table.concat(romans)\n   \
    \ result = result:gsub('iiii', 'iv')\n    result = result:gsub('viii', 'ix')\n\
    \    result = result:gsub('xxxx', 'xl')\n    result = result:gsub('lxxx', 'xc')\n\
    \    result = result:gsub('cccc', 'cd')\n    result = result:gsub('dccc', 'cm')\n\
    \    return result\nend", "    local result = ''\n    for _, arabic_roman in ipairs(arabic_roman_map)\
    \ do\n        if number == 0 then\n            break\n        end\n        local\
    \ times = math.floor(number / arabic_roman[1])\n        if times > 0 then\n  \
    \          result = result .. arabic_roman[2]:rep(times)\n            number =\
    \ number - arabic_roman[1] * times\n        end\n    end\n    return result\n\
    end", "  local m = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n  local\
    \ r = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i'}\n\
    \  local s = \"\"\n  for k, v in ipairs(m) do\n    local div = math.floor(number\
    \ / v)\n    for j = 1, div do\n      s = s .. r[k]\n    end\n    number = number\
    \ % v\n  end\n  return s\nend", "    assert(number >= 1 and number <= 1000, 'Number\
    \ out of range')\n    local numeral = ''\n    for i = 1, #mini_romans do\n   \
    \     while number >= mini_romans[i].number do\n            numeral = numeral\
    \ .. mini_romans[i].char\n            number = number - mini_romans[i].number\n\
    \        end\n    end\n    return numeral\nend", "    assert(1 <= number and number\
    \ <= 1000, \"number must be between 1 and 1000\")\n    return table.concat(int_to_mini_roman_digits(number))\n\
    end", "  local res, dec = '', 1000\n  for _, r in ipairs({'m', 'd', 'c', 'l',\
    \ 'x', 'v', 'i'}) do\n    local q, r = math.floor(number / dec), number % dec\n\
    \    if (q ~= 0) then res = res .. string.rep(r, q) end\n    number, dec = r,\
    \ dec / 10\n  end\n  return res\nend", "    return roman.int_to_mini_roman(number)\n\
    end", "  local symbols = { {'i', 'v'}, {'x', 'l'}, {'c', 'd'}, {'m'} }\n  local\
    \ chars = {}\n  local base = 1\n  while number > 0 do\n    local digit = number\
    \ % 10\n    local symbol = symbols[base]\n    if digit == 4 then\n      chars[#chars\
    \ + 1] = symbol[2]\n      chars[#chars + 1] = symbol[1]\n    elseif digit == 9\
    \ then\n      if #symbol == 2 then\n        chars[#chars + 1] = symbols[base +\
    \ 1][1]\n        chars[#chars + 1] = symbol[1]\n      else\n        chars[#chars\
    \ + 1] = symbols[base + 1][1]\n        chars[#chars + 1] = symbols[base][1]\n\
    \      end\n    else\n      if digit >= 5 then\n        chars[#chars + 1] = symbol[2]\n\
    \        digit = digit - 5\n      end\n      for _ = 1, digit do\n        chars[#chars\
    \ + 1] = symbol[1]\n      end\n    end\n    number = (number - (number % 10))\
    \ / 10\n    base = base + 1\n  end\n  return table.concat(chars)\nend", "  local\
    \ numbers = {}\n  local roman_numerals = ''\n  local roman_equivalent", "    local\
    \ numerals = {\n        {0, \"\", \"\"},\n        {1, \"c\", \"m\"},\n       \
    \ {2, \"cc\", \"mm\"},\n        {3, \"ccc\", \"mmm\"},\n        {4, \"cd\", \"\
    md\"},\n        {5, \"d\", \"d\"},\n        {6, \"dc\", \"mc\"},\n        {7,\
    \ \"dcc\", \"mmc\"},\n        {8, \"dccc\", \"mmmc\"},\n        {9, \"cm\", \"\
    mmd\"},\n    }\n    local thousands = floor(number / 1000)\n    local hundreds\
    \ = floor((number - thousands * 1000) / 100)\n    local tens = floor((number -\
    \ thousands * 1000 - hundreds * 100) / 10)\n    local ones = number - thousands\
    \ * 1000 - hundreds * 100 - tens * 10\n    local thousands_numeral = string.rep(numerals[1][2],\
    \ thousands)\n    local hundreds_numeral = numerals[hundreds + 1][2]\n    local\
    \ tens_numeral = numerals[tens + 1][2]\n    local ones_numeral = numerals[ones\
    \ + 1][2]\n    return thousands_numeral .. hundreds_numeral .. tens_numeral ..\
    \ ones_numeral\nend", "  local result = ''\n  local number_of_letters = 0\n  for\
    \ arabic, roman in pairs(mini_roman_numerals) do\n    if number >= arabic then\n\
    \      number_of_letters = number // arabic\n      number = number % arabic\n\
    \      result = result .. string.rep(roman, number_of_letters)\n    end\n  end\n\
    \  return result\nend", "    -- TODO\nend", "    assert(1 <= number and number\
    \ <= 1000, 'Bad input: ' .. number)\n    local digits = { [1] = 'i', [5] = 'v',\
    \ [10] = 'x', [50] = 'l', [100] = 'c', [500] = 'd', [1000] = 'm' }\n    local\
    \ out = ''\n    local place = 1\n    while number > 0 do\n        local digit\
    \ = number % 10\n        local digit_letter = digits[place]\n        if digit\
    \ == 1 then\n            out = digit_letter .. out\n        elseif digit == 2\
    \ then\n            out = digit_letter .. digit_letter .. out\n        elseif\
    \ digit == 3 then\n            out = digit_letter .. digit_letter .. digit_letter\
    \ .. out\n        elseif digit == 4 then\n            out = digit_letter .. digits[5\
    \ * place] .. out\n        elseif digit == 5 then\n            out = digits[5\
    \ * place] .. out\n        elseif digit == 6 then\n            out = digits[5\
    \ * place] .. digit_letter .. out\n        elseif digit == 7 then\n          \
    \  out = digits[5 * place] .. digit_letter .. digit_letter .. out\n        elseif\
    \ digit == 8 then\n            out = digits[5 * place] .. digit_letter .. digit_letter\
    \ .. digit_letter .. out\n        elseif digit == 9 then\n            out = digits[place]\
    \ .. digits[10 * place] .. out\n        end\n        number = math.floor(number\
    \ / 10)\n        place = place * 10\n    end\n    return out\nend", "\tlocal result\
    \ = \"\"\n\tlocal value, letter\n\tfor i, l in ipairs({\"m\", \"d\", \"c\", \"\
    l\", \"x\", \"v\", \"i\"}) do\n\t\tvalue, letter = divmod(number, 10^(2*i - 1))\n\
    \t\tresult = result .. (letter:rep(value) .. l):gsub(\"xv\", \"ix\")\n\t\tnumber\
    \ = number - value * 10^(2*i - 1)\n\tend\n\treturn result\nend", "    assert(number\
    \ >= 1, \"number must be positive\")\n    assert(number <= 1000, \"number must\
    \ be less than or equal to 1000\")\n    local roman = \"\"\n    for i = #digits,\
    \ 1, -1 do\n        local digit = digits[i]\n        while number >= digit do\n\
    \            roman = roman .. romans[i]\n            number = number - digit\n\
    \        end\n    end\n    return roman\nend", "    local roman_numeral_string\
    \ = \"\"\n    local number_of_thousands, remain_number\n    local number_of_hundreds,\
    \ remain_number\n    local number_of_tens, remain_number\n    local number_of_units",
  "    if (number < 1) or (number > 1000) then\n        error('Number should be between\
    \ 1 and 1000 inclusive')\n    end\n    local function build_mini_roman(rest, result)\n\
    \        if rest <= 0 then\n            return result\n        elseif rest >=\
    \ 900 then\n            return build_mini_roman(rest - 900, result .. 'cm')\n\
    \        elseif rest >= 500 then\n            return build_mini_roman(rest - 500,\
    \ result .. 'd')\n        elseif rest >= 400 then\n            return build_mini_roman(rest\
    \ - 400, result .. 'cd')\n        elseif rest >= 100 then\n            return\
    \ build_mini_roman(rest - 100, result .. 'c')\n        elseif rest >= 90 then\n\
    \            return build_mini_roman(rest - 90, result .. 'xc')\n        elseif\
    \ rest >= 50 then\n            return build_mini_roman(rest - 50, result .. 'l')\n\
    \        elseif rest >= 40 then\n            return build_mini_roman(rest - 40,\
    \ result .. 'xl')\n        elseif rest >= 10 then\n            return build_mini_roman(rest\
    \ - 10, result .. 'x')\n        elseif rest >= 9 then\n            return build_mini_roman(rest\
    \ - 9, result .. 'ix')\n        elseif rest >= 5 then\n            return build_mini_roman(rest\
    \ - 5, result .. 'v')\n        elseif rest >= 4 then\n            return build_mini_roman(rest\
    \ - 4, result .. 'iv')\n        elseif rest >= 1 then\n            return build_mini_roman(rest\
    \ - 1, result .. 'i')\n        end\n    end\n    return build_mini_roman(number,\
    \ '')\nend", "  local result = \"\"\n  local numbers = {1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1}\n  local roman = {'m', 'cm', 'd', 'cd', 'c', 'xc',\
    \ 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i'}\n  for i = 1, #numbers do\n    while number\
    \ >= numbers[i] do\n      result = result .. roman[i]\n      number = number -\
    \ numbers[i]\n    end\n  end\n  return result\nend", "    if number < 1 or number\
    \ > 1000 then\n        error(('int_to_mini_roman() called with number outside\
    \ the valid ' ..\n               'range (1 <= num <= 1000)'))\n    end\n    local\
    \ result = ''\n    for _, tuple in ipairs(ROMAN_NUMERAL_DIGITS) do\n        while\
    \ number >= tuple[1] do\n            result = result .. tuple[2]\n           \
    \ number = number - tuple[1]\n        end\n    end\n    return result\nend", " \
    \ local order, roman_equiv = { 'm', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x',\
    \ 'ix', 'v', 'iv', 'i' }, ''\n  local num_left = number\n  while num_left > 0\
    \ do\n    for i = 1, #order do\n      if num_left >= mini_romans[order[i]] then\n\
    \        roman_equiv = roman_equiv .. order[i]\n        num_left = num_left -\
    \ mini_romans[order[i]]\n        break\n      end\n    end\n  end\n  return roman_equiv\n\
    end", "    local numerals = {\n        [1000] = 'm',\n        [900] = 'cm',\n\
    \        [500] = 'd',\n        [400] = 'cd',\n        [100] = 'c',\n        [90]\
    \ = 'xc',\n        [50] = 'l',\n        [40] = 'xl',\n        [10] = 'x',\n  \
    \      [9] = 'ix',\n        [5] = 'v',\n        [4] = 'iv',\n        [1] = 'i'\n\
    \    }\n    local result = \"\"\n    while number > 0 do\n        for k, v in\
    \ pairs(numerals) do\n            if number >= k then\n                result\
    \ = result .. v\n                number = number - k\n                break\n\
    \            end\n        end\n    end\n    return result\nend", "  local t\n\
    \  local result = \"\"\n  local roman_numerals = {\n    {1000, \"m\"},\n    {900,\
    \ \"cm\"},\n    {500, \"d\"},\n    {400, \"cd\"},\n    {100, \"c\"},\n    {90,\
    \ \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"},\n    {10, \"x\"},\n    {9, \"\
    ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n    {1, \"i\"}\n  }\n  for i, v in\
    \ ipairs(roman_numerals) do\n    t = {}\n    for j = 1, number / v[1] do\n   \
    \   table.insert(t, v[2])\n    end\n    result = result .. table.concat(t)\n \
    \   number = number % v[1]\n  end\n  return result\nend", "    local roman = \"\
    \"\n    local number = tonumber(number)\n    local arabic = {\"m\", \"cm\", \"\
    d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\
    }\n    local roman_numerals = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5,\
    \ 4, 1}\n    if number < 0 or number > 1000 then\n        return nil\n    end\n\
    \    for i, a in ipairs(roman_numerals) do\n        local n = math.floor(number\
    \ / a)\n        if n > 0 then\n            for j = 1, n do\n                roman\
    \ = roman .. arabic[i]\n            end\n            number = number - (a * n)\n\
    \        end\n    end\n    return roman\nend", "  local values = {1000, 900, 500,\
    \ 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n  local numerals = {'m', 'cm', 'd', 'cd',\
    \ 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i'}\n  local mini_roman = \"\"\n\
    \  local i = 1\n  while number > 0 do\n    if number >= values[i] then\n     \
    \ mini_roman = mini_roman .. numerals[i]\n      number = number - values[i]\n\
    \    else\n      i = i + 1\n    end\n  end\n  return mini_roman\nend", "    local\
    \ ones = {'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix'}\n    local tens\
    \ = {'x', 'xx', 'xxx', 'xl', 'l', 'lx', 'lxx', 'lxxx', 'xc'}\n    local hundreds\
    \ = {'c', 'cc', 'ccc', 'cd', 'd', 'dc', 'dcc', 'dccc', 'cm'}\n    local thousands\
    \ = {'m', 'mm', 'mmm'}\n    local num_length = #tostring(number)\n    local mini_roman\
    \ = ''\n    local digit\n    for i = 1, num_length do\n        digit = number\
    \ % 10^i\n        digit = digit - digit % 10^(i - 1)\n        digit = digit /\
    \ 10^(i - 1)\n        if i == 1 then\n            mini_roman = ones[digit]\n \
    \       elseif i == 2 then\n            mini_roman = tens[digit] .. mini_roman\n\
    \        elseif i == 3 then\n            mini_roman = hundreds[digit] .. mini_roman\n\
    \        elseif i == 4 then\n            mini_roman = thousands[digit] .. mini_roman\n\
    \        end\n    end\n    return mini_roman\nend", "    local table_of_numbers\
    \ = {\n      {1000, 'm'},\n      {900, 'cm'},\n      {500, 'd'},\n      {400,\
    \ 'cd'},\n      {100, 'c'},\n      {90, 'xc'},\n      {50, 'l'},\n      {40, 'xl'},\n\
    \      {10, 'x'},\n      {9, 'ix'},\n      {5, 'v'},\n      {4, 'iv'},\n     \
    \ {1, 'i'}\n    }\n    local roman_number = ''\n    local i = 1\n    while number\
    \ > 0 do\n      local div = math.floor(number / table_of_numbers[i][1])\n    \
    \  number = number % table_of_numbers[i][1]\n      if div > 0 then\n        roman_number\
    \ = roman_number .. table_of_numbers[i][2]:rep(div)\n      end\n      i = i +\
    \ 1\n    end\n    return roman_number\nend", "  -- TODO: implement\nend", "\t\
    local _table = {\n\t\t{'i', 'v'},\n\t\t{'x', 'l'},\n\t\t{'c', 'd'},\n\t\t{'m'}\n\
    \t}\n\tlocal roman = {}\n\tfor i, v in ipairs(_table) do\n\t\tlocal mod = number\
    \ % 10^i\n\t\tlocal div = math.floor(number / 10^i)\n\t\tif div == 0 then break\
    \ end\n\t\tif div <= 3 then\n\t\t\tfor j = 1, div do\n\t\t\t\ttable.insert(roman,\
    \ v[1])\n\t\t\tend\n\t\telseif div == 4 then\n\t\t\ttable.insert(roman, v[1])\n\
    \t\t\ttable.insert(roman, v[2])\n\t\telseif div <= 8 then\n\t\t\ttable.insert(roman,\
    \ v[2])\n\t\t\tfor j = 1, div - 5 do\n\t\t\t\ttable.insert(roman, v[1])\n\t\t\t\
    end\n\t\telseif div == 9 then\n\t\t\ttable.insert(roman, v[1])\n\t\t\ttable.insert(roman,\
    \ _table[i + 1][1])\n\t\tend\n\t\tnumber = mod\n\tend\n\treturn table.concat(roman):lower()\n\
    end", "  local result = \"\"\n  local letters = { \"i\", \"v\", \"x\", \"l\",\
    \ \"c\", \"d\", \"m\" }\n  local nums = { 1, 5, 10, 50, 100, 500, 1000 }\n  local\
    \ keys = { \"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\" }\n  local tab = {}\n\
    \  for index, num in ipairs(nums) do\n    tab[keys[index]] = num\n  end\n  if\
    \ number > 3999 then\n    return \"ERROR\"\n  end\n  while number ~= 0 do\n  \
    \  local r = \"\"\n    local n = number % 10\n    local t = math.floor(number\
    \ / 10)\n    local b = math.floor(t % 10)\n    local o = math.floor(t / 10)\n\
    \    local p = (o > 0) and math.floor(o % 10) or 0\n    local c = (o > 1) and\
    \ math.floor(o / 10) or 0\n    if n == 1 then\n      r = letters[1]\n    elseif\
    \ n == 2 then\n      r = letters[1] .. letters[1]\n    elseif n == 3 then\n  \
    \    r = letters[1] .. letters[1] .. letters[1]\n    elseif n == 4 then\n    \
    \  r = letters[1] .. letters[2]\n    elseif n == 5 then\n      r = letters[2]\n\
    \    elseif n == 6 then\n      r = letters[2] .. letters[1]\n    elseif n == 7\
    \ then\n      r = letters[2] .. letters[1] .. letters[1]\n    elseif n == 8 then\n\
    \      r = letters[2] .. letters[1] .. letters[1] .. letters[1]\n    elseif n\
    \ == 9 then\n      r = letters[1] .. letters[3]\n    end\n    number = t\n   \
    \ if b == 1 then\n      r = letters[3] .. r\n    elseif b == 2 then\n      r =\
    \ letters[3] .. letters[3] .. r\n    elseif b == 3 then\n      r = letters[3]\
    \ .. letters[3] .. letters[3] .. r\n   ", "  -- your code here\n  local n = number\n\
    \  local val = \n  {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"\
    },\n    {400, \"cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n\
    \    {40, \"xl\"},\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4,\
    \ \"iv\"},\n    {1, \"i\"}\n  }\n  local roman = \"\"\n  for i, v in ipairs(val)\
    \ do\n    local a = n / v[1]\n    roman = roman .. v[2]:rep(a)\n    n = n % v[1]\n\
    \  end\n  return roman\nend", "    number = tonumber(number)\n    if number >\
    \ 1000 or number < 1 then\n        return nil\n    end\n    local roman = {\n\
    \        { 1000, 'm' },\n        { 900, 'cm' },\n        { 500, 'd' },\n     \
    \   { 400, 'cd' },\n        { 100, 'c' },\n        { 90, 'xc' },\n        { 50,\
    \ 'l' },\n        { 40, 'xl' },\n        { 10, 'x' },\n        { 9, 'ix' },\n\
    \        { 5, 'v' },\n        { 4, 'iv' },\n        { 1, 'i' }\n    }\n    local\
    \ result = ''\n    for i = 1, #roman do\n        while number >= roman[i][1] do\n\
    \            result = result .. roman[i][2]\n            number = number - roman[i][1]\n\
    \        end\n    end\n    return result\nend", "    local arabics = {1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n    local romans = {'m', 'cm', 'd',\
    \ 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i'}\n    local result = ''\n\
    \    for i, v in ipairs(arabics) do\n        while number >= v do\n          \
    \  result = result .. romans[i]\n            number = number - v\n        end\n\
    \    end\n    return result\nend", "    -- Define Roman numeral characters and\
    \ their values,\n    -- and the order in which they should be listed.\n    local\
    \ roman_numerals = {\n        'm', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x',\
    \ 'ix', 'v', 'iv', 'i'\n    }\n    local roman_numerals_values = {\n        1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    }\n    -- Define a table\
    \ for adding Roman numeral characters to the final string.\n    local mini_roman_string\
    \ = { }\n    -- Break down the number into Roman numeral characters,\n    -- and\
    \ add them to the final string.\n    local l = #roman_numerals\n    for i = 1,\
    \ l do\n        local numeral = roman_numerals[i]\n        local value = roman_numerals_values[i]\n\
    \        while number >= value do\n            table.insert(mini_roman_string,\
    \ numeral)\n            number = number - value\n        end\n    end\n    --\
    \ Return the resulting string.\n    return table.concat(mini_roman_string)\nend",
  "  assert(number > 0, \"Number must be greater than 0.\")\n  assert(number <= 1000,\
    \ \"Number must be less than 1000.\")\n  local a = {1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1}\n  local r = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l',\
    \ 'xl', 'x', 'ix', 'v', 'iv', 'i'}\n  local t = {}\n  for i = 1, #a do\n    while\
    \ number >= a[i] do\n      table.insert(t, r[i])\n      number = number - a[i]\n\
    \    end\n  end\n  return table.concat(t)\nend", "    local roman_numerals = {\n\
    \        {1, 'i'},\n        {4, 'iv'},\n        {5, 'v'},\n        {9, 'ix'},\n\
    \        {10, 'x'},\n        {40, 'xl'},\n        {50, 'l'},\n        {90, 'xc'},\n\
    \        {100, 'c'},\n        {400, 'cd'},\n        {500, 'd'},\n        {900,\
    \ 'cm'},\n        {1000, 'm'}\n    }\n    local result = \"\"\n    local temp\
    \ = number\n    for i = #roman_numerals, 1, -1 do\n        while temp >= roman_numerals[i][1]\
    \ do\n            result = result .. roman_numerals[i][2]\n            temp =\
    \ temp - roman_numerals[i][1]\n        end\n    end\n    return result\nend",
  "  local result = ''\n  local values = {1000, 900, 500, 400, 100, 90, 50, 40, 10,\
    \ 9, 5, 4, 1}\n  local letters = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl',\
    \ 'x', 'ix', 'v', 'iv', 'i'}\n  for i, v in ipairs(values) do\n    while number\
    \ >= v do\n      result = result .. letters[i]\n      number = number - v\n  \
    \  end\n  end\n  return result\nend", "  if number > MAX_ROMAN_NUMBER then\n \
    \   return nil\n  end\n  local result = {}\n  for _, dec_key in ipairs(dec_keys)\
    \ do\n    while number >= dec_key do\n      table.insert(result, romans[dec_key])\n\
    \      number = number - dec_key\n    end\n  end\n  return table.concat(result)\n\
    end", "    local roman_table = {\n        ['M'] = 1000,\n        ['CM'] = 900,\n\
    \        ['D'] = 500,\n        ['CD'] = 400,\n        ['C'] = 100,\n        ['XC']\
    \ = 90,\n        ['L'] = 50,\n        ['XL'] = 40,\n        ['X'] = 10,\n    \
    \    ['IX'] = 9,\n        ['V'] = 5,\n        ['IV'] = 4,\n        ['I'] = 1\n\
    \    }\n    local output = ''\n    while number > 0 do\n        for i, v in pairs(roman_table)\
    \ do\n            if number >= v then\n                output = output .. i\n\
    \                number = number - v\n                break\n            end\n\
    \        end\n    end\n    return output\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
