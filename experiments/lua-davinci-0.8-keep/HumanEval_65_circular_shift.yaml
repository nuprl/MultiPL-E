name: HumanEval_65_circular_shift
language: lua
prompt: "-- Circular shift the digits of the integer x, shift the digits right by\
  \ shift\n-- and return the result as a string.\n-- If shift > number of digits,\
  \ return digits reversed.\n-- >>> circular_shift(12, 1)\n-- \"21\"\n-- >>> circular_shift(12,\
  \ 2)\n-- \"12\"\nlocal function circular_shift(x, shift)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = circular_shift\n\
  \    lu.assertEquals(candidate(100, 2), '001')\n    lu.assertEquals(candidate(12,\
  \ 2), '12')\n    lu.assertEquals(candidate(97, 8), '79')\n    lu.assertEquals(candidate(12,\
  \ 1), '21')\n    lu.assertEquals(candidate(11, 101), '11')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    if x == 0 then\n        return \"0\"\n    end\n    if shift ==\
    \ 0 then\n        return tostring(x)\n    end\n    local s = tostring(x)\n   \
    \ local l = string.len(s)\n    if shift >= l then\n        return s:reverse()\n\
    \    end\n    return s:sub(l - shift + 1) .. s:sub(1, l - shift)\nend", "    local\
    \ bits = math.floor(math.log10(x))\n    if shift > bits then\n        return tostring(x):reverse()\n\
    \    end\n    local str = tostring(x)\n    local prefix = str:sub(1, bits - shift\
    \ + 1)\n    local suffix = str:sub(bits - shift + 2)\n    return suffix .. prefix\n\
    end", "\tlocal num = tostring(x)\n\tlocal len = #num\n\tif shift > len then\n\t\
    \treturn string.reverse(num)\n\tend\n\treturn string.sub(num, len - shift + 1)\
    \ .. string.sub(num, 1, len - shift)\nend", "  local t = {}\n  while x ~= 0 do\n\
    \    local digit = x % 10\n    t[#t + 1] = digit\n    x = math.floor(x / 10)\n\
    \  end\n  local n = #t\n  for i = 1, shift do\n    local a = t[n]\n    for j =\
    \ n, 2, -1 do\n      t[j] = t[j - 1]\n    end\n    t[1] = a\n  end\n  local res\
    \ = ''\n  for i = 1, n do\n    res = res .. tostring(t[i])\n  end\n  return res\n\
    end", "  local n = x\n  local l = {}\n  while n > 0 do\n    l[#l+1] = n % 10\n\
    \    n = math.floor(n / 10)\n  end\n  while shift > #l do\n    shift = shift -\
    \ #l\n  end\n  local s = l[#l-shift+1]\n  for i=1,#l-shift do\n    l[#l-i+1] =\
    \ l[#l-i-shift+1]\n  end\n  l[1] = s\n  return concat(l)\nend", "\tshift = (shift\
    \ % #x) + 1\n\treturn x:sub(shift) .. x:sub(1, shift - 1)\nend", "    local digits\
    \ = {}\n    for d in tostring(x):gmatch(\".\") do\n        table.insert(digits,\
    \ d)\n    end\n    local i = #digits\n    local first_digit = 1\n    while i >\
    \ 0 do\n        i = i - 1\n        first_digit = i - shift + 1\n        if first_digit\
    \ > 0 then\n            break\n        end\n    end\n    if first_digit > 0 then\n\
    \        local result = {}\n        for i = first_digit, #digits do\n        \
    \    table.insert(result, digits[i])\n        end\n        for i = 1, first_digit\
    \ - 1 do\n            table.insert(result, digits[i])\n        end\n        return\
    \ table.concat(result)\n    else\n        local result = {}\n        for i = #digits,\
    \ 1, -1 do\n            table.insert(result, digits[i])\n        end\n       \
    \ return table.concat(result)\n    end\nend", "\tx = tostring(x)\n\tif shift >=\
    \ #x then\n\t\treturn x:reverse()\n\tend\n\treturn x:sub(#x - shift + 1) .. x:sub(1,\
    \ #x - shift)\nend", "    local s = tostring(x)\n    local n = s:len()\n    local\
    \ a = shift\n    if a > n then\n        a = a % n\n    end\n    return s:sub(n\
    \ - a + 1) .. s:sub(1, n - a)\nend", "    x = math.abs(x)\n    local digits =\
    \ (\"%d\"):format(x):reverse()\n    shift = shift % #digits\n    return digits:sub(shift+1,\
    \ #digits) .. digits:sub(1, shift)\nend", "\tlocal x_str = tostring(x)\n\tlocal\
    \ len = x_str:len()\n\tif shift >= len then\n\t\treturn x_str:reverse()\n\tend\n\
    \treturn x_str:sub(len - shift + 1) .. x_str:sub(1, len - shift)\nend", "    local\
    \ n = #tostring(x)\n    if shift >= n then\n        return string.reverse(tostring(x))\n\
    \    end\n    return string.sub(tostring(x), shift + 1) .. string.sub(tostring(x),\
    \ 1, shift)\nend", "  if type(x) ~= \"number\" then\n    error(\"input must be\
    \ a number\")\n  end\n  local s = tostring(x)\n  local n = #s\n  local a = {}\n\
    \  for i = 1, n do\n    a[i] = s:sub(i, i)\n  end\n  local idx = (n - shift +\
    \ 1) % n\n  local result = {}\n  for i = 1, n do\n    result[i] = a[idx]\n   \
    \ idx = (idx % n) + 1\n  end\n  return table.concat(result)\nend", "    -- get\
    \ digits of x\n    local digits = {}\n    for d in (tostring(x)):gmatch(\"%d\"\
    ) do\n        table.insert(digits, d)\n    end\n    -- special case: more shifts\
    \ than digits\n    if shift >= #digits then\n        -- circular shift with shift\
    \ = (shift % #digits)\n        shift = shift % #digits\n        -- reverse the\
    \ list to get the digits in reverse order\n        local digits2 = {}\n      \
    \  for i=#digits,1,-1 do\n            table.insert(digits2, digits[i])\n     \
    \   end\n        -- circular shift\n        for i=1,shift do\n            table.insert(digits2,\
    \ 1, table.remove(digits2))\n        end\n        return table.concat(digits2)\n\
    \    end\n    -- circular shift with shift = #digits - shift\n    shift = #digits\
    \ - shift\n    -- circular shift\n    for i=1,shift do\n        table.insert(digits,\
    \ 1, table.remove(digits))\n    end\n    return table.concat(digits)\nend", " \
    \ local function shifts(x, shift)\n    if shift == 0 then\n      return x\n  \
    \  else\n      return shifts(math.floor(x / 10), shift - 1)\n    end\n  end\n\
    \  local s = shifts(x, shift)\n  local n = tostring(x):len()\n  local nshift =\
    \ tostring(s):len()\n  if nshift == n then\n    return tostring(s)\n  else\n \
    \   return tostring(reverse(s))\n  end\nend", "    local str = tostring(x)\n \
    \   if shift >= #str then\n        return strreverse(str)\n    end\n    local\
    \ head = strsub(str, 1, shift)\n    local tail = strsub(str, shift + 1)\n    return\
    \ tail .. head\nend", "    local digits = math.floor(math.log10(x)) + 1\n    local\
    \ circular_shift = x\n    if shift > digits then\n        for i = 1, digits do\n\
    \            circular_shift =\n                10 * (circular_shift % 10) + math.floor(circular_shift\
    \ / 10)\n        end\n    else\n        for i = 1, shift do\n            circular_shift\
    \ =\n                10 * (circular_shift % 10) + math.floor(circular_shift /\
    \ 10)\n        end\n    end\n    return circular_shift\nend", "    local len =\
    \ string.len(x)\n    local s = string.sub(x, shift + 1, len) .. string.sub(x,\
    \ 1, shift)\n    return s\nend", "\tshift = shift % #x\n\treturn x:sub(shift +\
    \ 1) .. x:sub(1, shift)\nend", "    local ndigits = (math.floor(math.log10(x))\
    \ + 1)\n    shift = shift % ndigits\n    if shift == 0 then\n        return tostring(x)\n\
    \    end\n    return tostring(x % 10^shift) .. tostring(math.floor(x / 10^shift))\n\
    end", "  local digits = tostring(x)\n  local l = #digits\n  local result = {}\n\
    \  if shift > l then\n    shift = shift % l\n  end\n  if shift > 0 then\n    for\
    \ i = shift + 1, l do\n      result[#result + 1] = digits:sub(i, i)\n    end\n\
    \    for i = 1, shift do\n      result[#result + 1] = digits:sub(i, i)\n    end\n\
    \  else\n    result = {digits}\n  end\n  return table.concat(result)\nend", " \
    \   return tostring(x):sub(shift + 1) .. tostring(x):sub(1, shift)\nend", "  \
    \  local digits = split(tostring(x))\n    if shift > #digits then\n        reverse(digits)\n\
    \    else\n        local first = take(digits, shift)\n        local last = drop(digits,\
    \ shift)\n        concat(last, first)\n    end\n    return concat(digits)\nend",
  "    -- Pad with zero digits to prevent indexing to a non-existant digit.\n    x\
    \ = string.format(\"%04d\", x)\n    -- Convert to a string.\n    x = tostring(x)\n\
    \    -- Reverse the digits so that they can be easily shifted.\n    x = x:reverse()\n\
    \    -- Shift and pad.\n    x = x:sub(shift + 1) .. x:sub(1, shift)\n    -- Return\
    \ reversed digits.\n    return x:reverse()\nend", "  local shift = shift or 0\n\
    \  local digits = {}\n  local len = 0\n  while x > 0 do\n    digits[len] = x %\
    \ 10\n    x = math.floor(x / 10)\n    len = len + 1\n  end\n  local result = 0\n\
    \  for i = 0, len - 1 do\n    local index = (i + shift) % len\n    result = result\
    \ * 10 + digits[index]\n  end\n  return tostring(result)\nend", "\tlocal x_str\
    \ = tostring(x)\n\tlocal x_len = #x_str\n\tlocal shift_str = ''\n\tlocal shift_len\
    \ = shift\n\tif shift > x_len then\n\t\tshift_len = x_len\n\tend\n\tlocal digit_pos\
    \ = x_len - shift_len + 1\n\tfor i = 1, x_len do\n\t\tif digit_pos > x_len then\n\
    \t\t\tdigit_pos = 1\n\t\tend\n\t\tshift_str = shift_str .. x_str:sub(digit_pos,\
    \ digit_pos)\n\t\tdigit_pos = digit_pos + 1\n\tend\n\treturn shift_str\nend",
  "  local t = {}\n  for digit in tostring(x):gmatch(\".\") do\n    t[#t + 1] = digit\n\
    \  end\n  local n = #t\n  if shift > n then\n    for i = 1, n // 2 do\n      t[i],\
    \ t[n - i + 1] = t[n - i + 1], t[i]\n    end\n    return table.concat(t)\n  end\n\
    \  for i = 1, shift do\n    t[n + i] = t[i]\n  end\n  for i = 1, n do\n    t[i]\
    \ = t[n + i]\n  end\n  return table.concat(t):sub(1, n)\nend", "    local s =\
    \ tostring(x)\n    if shift > #s then return s:reverse() end\n    return s:sub(shift+1)\
    \ .. s:sub(1, shift)\nend", "  local n = math.ceil(math.log10(x + 1))\n  shift\
    \ = (shift - 1) % n + 1\n  return (string.sub(tostring(x), shift + 1) .. string.sub(tostring(x),\
    \ 1, shift))\nend", "\tlocal str = tostring(x)\n\tlocal res = \"\"\n\tfor i =\
    \ shift, #str do\n\t\tres = res .. str:sub(i, i)\n\tend\n\tfor i = 1, shift -\
    \ 1 do\n\t\tres = res .. str:sub(i, i)\n\tend\n\treturn res\nend", "  local ln\
    \ = #tostring(x)\n  shift = shift % ln\n  return tostring(x):sub(ln - shift +\
    \ 1) .. tostring(x):sub(1, ln - shift)\nend", "  local digits = tostring(x)\n\
    \  local length = #digits\n  local reverse = false\n  if shift > length then\n\
    \    shift = shift % length\n    reverse = true\n  end\n  local result = digits:sub(length\
    \ - shift + 1) .. digits:sub(1, length - shift)\n  if reverse then\n    result\
    \ = string.reverse(result)\n  end\n  return result\nend", "    -- http://stackoverflow.com/questions/916920/how-to-reverse-a-number-in-lua\n\
    \    local digits = #tostring(x)\n    local reversed = 0\n    while x > 0 do\n\
    \        reversed = reversed * 10 + x % 10\n        x = math.floor(x / 10)\n \
    \   end\n    local shifted = reversed\n    for i = 1, shift do\n        shifted\
    \ = shifted % 10 * (10 ^ digits) + math.floor(shifted / 10)\n    end\n    local\
    \ result = 0\n    while shifted > 0 do\n        result = result * 10 + shifted\
    \ % 10\n        shifted = math.floor(shifted / 10)\n    end\n    return tostring(result)\n\
    end", "  local str = tostring(x)\n  if (shift > #str) then\n    return str:reverse()\n\
    \  end\n  return str:sub(#str - shift + 1) .. str:sub(1, #str - shift)\nend",
  "  return tostring(x):sub(1 - shift)\nend", "    local s = tostring(x)\n    return\
    \ (s:sub(shift + 1) .. s:sub(1, shift))\nend", "  local digits = lpegmatch(int_to_digits,\
    \ x)\n  local s = shift % #digits\n  if s > 0 then\n    local shifted = {}\n \
    \   for i = s, #digits do\n      shifted[#shifted + 1] = digits[i]\n    end\n\
    \    for i = 1, s do\n      shifted[#shifted + 1] = digits[i]\n    end\n    digits\
    \ = shifted\n  end\n  return lpegmatch(digits_to_int, digits)\nend", "  local\
    \ digits = tostring(x)\n  local len = #digits\n  if shift >= len then\n    return\
    \ string.reverse(digits)\n  end\n  local s1 = string.sub(digits, 1, shift)\n \
    \ local s2 = string.sub(digits, shift + 1, len)\n  return s2 .. s1\nend", "  local\
    \ s = tostring(x)\n  if shift > #s then\n    return s:reverse()\n  end\n  local\
    \ shift = shift % #s\n  return s:sub(shift + 1) .. s:sub(1, shift)\nend", "  local\
    \ t = { }\n  for i = 1, #x do\n    t[#t + 1] = x:sub(i, i)\n  end\n  local i =\
    \ 1\n  while shift > 0 do\n    local d = t[i]\n    table.remove(t, i)\n    table.insert(t,\
    \ d)\n    shift = shift - 1\n  end\n  return table.concat(t)\nend", "    local\
    \ function reverse(str)\n        return str:reverse()\n    end\n    local s =\
    \ tostring(x)\n    local n = #s\n    local shift = shift % n\n    return reverse(reverse(s:sub(shift\
    \ + 1)) .. reverse(s:sub(1, shift)))\nend", "    -- Return the digit string for\
    \ x.\n    local function digits(x)\n        local digits = {}\n        while x\
    \ > 0 do\n            digits[#digits + 1] = x % 10\n            x = (x - x % 10)\
    \ / 10\n        end\n        return digits\n    end", "  if x < 0 then x = -x\
    \ end\n  local n = digit_count(x)\n  if shift > n then return tostring(x):reverse()\
    \ end\n  x = x * 10^shift\n  return (tostring(x):sub(1, n) + \"0\"):sub(1, n)\n\
    end", "\tlocal str = tostring(x)\n\tlocal len = string.len(str)\n\tif shift >\
    \ len then\n\t\treturn string.reverse(str)\n\tend\n\treturn string.sub(str, len\
    \ - shift + 1) .. string.sub(str, 1, len - shift)\nend", "\tlocal digits = { }\n\
    \twhile x > 0 do\n\t\tdigits[#digits + 1] = x % 10\n\t\tx = x // 10\n\tend\n\t\
    if shift > #digits then\n\t\tfor i = 1, #digits / 2 do\n\t\t\tdigits[i], digits[#digits\
    \ - i + 1] = digits[#digits - i + 1], digits[i]\n\t\tend\n\telse\n\t\tlocal tmp\
    \ = { }\n\t\tfor i = 1, #digits do\n\t\t\ttmp[i] = digits[i]\n\t\tend\n\t\tfor\
    \ i = 1, #digits do\n\t\t\tdigits[i] = tmp[(i + shift - 1) % #digits + 1]\n\t\t\
    end\n\tend\n\tlocal result = 0\n\tfor i = 1, #digits do\n\t\tresult = result *\
    \ 10 + digits[i]\n\tend\n\treturn result\nend", "    local x_str = tostring(x)\n\
    \    local shifted = string.sub(x_str, shift + 1) .. string.sub(x_str, 1, shift)\n\
    \    return shifted\nend", "\tx = tostring(x)\n\tif shift > #x then\n\t\treturn\
    \ x:reverse()\n\tend\n\treturn x:sub(#x - shift + 1) .. x:sub(1, #x - shift)\n\
    end", "\tif x < 10 then\n\t\treturn tostring(x)\n\tend\n\tlocal digits = {}\n\t\
    local d = 0\n\twhile x > 0 do\n\t\td = d + 1\n\t\tdigits[d] = x % 10\n\t\tx =\
    \ math.floor(x / 10)\n\tend\n\tlocal d1 = (d + shift) % d\n\tif d1 == 0 then\n\
    \t\td1 = d\n\tend\n\tlocal str = \"\"\n\tfor i = d1, d do\n\t\tstr = str .. tostring(digits[i])\n\
    \tend\n\tfor i = 1, d1 - 1 do\n\t\tstr = str .. tostring(digits[i])\n\tend\n\t\
    return str\nend", "    local s = tostring(x)\n    if shift >= #s then\n      \
    \  return string.reverse(s)\n    end\n    return string.sub(s, shift + 1) .. string.sub(s,\
    \ 1, shift)\nend", "    local digits = {}\n    local pos = 0\n    local s = tostring(x)\n\
    \    for c in s:gmatch(\".\") do\n        pos = pos + 1\n        digits[pos] =\
    \ c\n    end\n    local t = {}\n    local pos = 0\n    if pos > #digits then\n\
    \        local j = 1\n        for i = #digits, 1, -1 do\n            t[j] = digits[i]\n\
    \            j = j + 1\n        end\n    else\n        local j = 1\n        for\
    \ i = shift, #digits do\n            t[j] = digits[i]\n            j = j + 1\n\
    \        end\n        for i = 1, shift do\n            t[j] = digits[i]\n    \
    \        j = j + 1\n        end\n    end\n    return table.concat(t)\nend", " \
    \   local t = {}\n    while x > 0 do\n        t[#t+1] = x % 10\n        x = math.floor(x\
    \ / 10)\n    end\n    local n = #t\n    local idx = (n - shift) % n\n    while\
    \ idx < 0 do\n        idx = idx + n\n    end\n    local result = {}\n    for i\
    \ = 1, n do\n        result[i] = t[(idx + i - 1) % n + 1]\n    end\n    return\
    \ table.concat(result)\nend", "    local s = tostring(x)\n    shift = shift %\
    \ #s\n    return s:sub(#s - shift + 1) .. s:sub(1, #s - shift)\nend", "  local\
    \ s = tostring(x)\n  local l = #s\n  if shift > l then\n    return s:reverse()\n\
    \  end\n  local r = s:sub(l - shift + 1, l) .. s:sub(1, l - shift)\n  return r\n\
    end", "    local n = math.floor(math.log10(x)) + 1 -- number of digits\n    if\
    \ shift >= n then\n        return x % 10 .. math.floor(x / 10)\n    else\n   \
    \     local first = math.floor(x / 10^(n - shift))\n        local second = x %\
    \ 10^(n - shift)\n        return first + second * 10^shift\n    end\nend", " \
    \ local digits = {}\n  -- get digits of x from least to most significant.\n  while\
    \ x ~= 0 do\n    digits[#digits + 1] = x % 10\n    x = x // 10\n  end\n  if shift\
    \ > #digits then\n    -- reversing is cheaper than circular shift, so use this\
    \ as a hack\n    -- to reverse the digits.\n    digits = digits:reverse()\n  else\n\
    \    local t = {}\n    for i = 1, #digits do\n      t[i] = digits[(i + shift -\
    \ 1) % #digits + 1]\n    end\n    digits = t\n  end\n  local result = \"\"\n \
    \ for i = 1, #digits do\n    result = result .. digits[i]\n  end\n  return result\n\
    end", "    local x = tostring(x)\n    local x_len = #x\n    if shift > x_len then\n\
    \        return x:reverse()\n    end\n    return x:sub(x_len - shift + 1) .. x:sub(1,\
    \ x_len - shift)\nend", "    local n = 0\n    local base = 1\n    local shifted\
    \ = 0\n    while x ~= 0 do\n        local digit = x % 10\n        if shift > n\
    \ then\n            shifted = shifted + digit * base\n            base = base\
    \ * 10\n        else\n            shifted = (shifted + digit) * 10\n        end\n\
    \        x = math.floor(x / 10)\n        n = n + 1\n    end\n    return tostring(shifted)\n\
    end", "    local dig_x = digits(x)\n    local len_x = #dig_x\n    if len_x ==\
    \ 0 then\n        return x\n    end\n    shift = shift % len_x\n    if shift ==\
    \ 0 then\n        return x\n    end\n    local digs = {}\n    for i = 1, len_x\
    \ do\n        digs[i] = dig_x[i+shift] or dig_x[i+shift-len_x]\n    end\n    return\
    \ table.concat(digs)\nend", "    return tostring(x):reverse():sub(1, shift):reverse()\
    \ .. tostring(x):sub(1, tostring(x):len() - shift)\nend", "  local str = tostring(x)\n\
    \  local n = #str\n  if shift >= n then\n    return string.reverse(str)\n  end\n\
    \  return string.sub(str, n - shift + 1) .. string.sub(str, 1, n - shift)\nend",
  "    -- Convert to a string\n    local xstr = tostring(x)\n    local xlen = #xstr\n\
    \    -- Circular shift\n    local xstr_shifted = xstr:sub(xlen - shift + 1) ..\
    \ xstr:sub(1, xlen - shift)\n    return xstr_shifted\nend", "  local x_str = tostring(x)\n\
    \  local len = #x_str\n  if shift >= len then\n    return string.reverse(x_str)\n\
    \  end\n  local ds = string.sub(x_str, shift + 1)\n  local ss = string.sub(x_str,\
    \ 1, shift)\n  return ds .. ss\nend", "    return string.reverse(string.sub(string.reverse(tostring(x))\
    \ .. \"0\", 1, shift + 1))\nend", "    local s = tostring(x)\n    local result\
    \ = \"\"\n    if shift <= 0 then\n        return s\n    end\n    local i = 1\n\
    \    while i <= #s do\n        result = result .. s:sub(i + shift - 1, i + shift\
    \ - 1)\n        i = i + 1\n    end\n    return result\nend", "    local m, result\
    \ = 10 ^ math.ceil(math.log10(x))\n    result = x % m\n    for i = 1, shift -\
    \ 1 do\n        result = (result * 10) + math.floor(x / m)\n        m = m / 10\n\
    \    end\n    return tostring(result)\nend", "    local cshift = x\n    for i\
    \ = 1, shift do\n        cshift = (cshift % 10) * 10 + math.floor(cshift / 10)\n\
    \    end\n    return tostring(cshift)\nend", "\tlocal x = tostring(x)\n\tlocal\
    \ a = x:sub(1, #x - shift)\n\tlocal b = x:sub(#x - shift + 1, #x)\n\treturn b\
    \ .. a\nend", "    local x = tostring(x)\n    if shift > #x then\n        return\
    \ x:reverse()\n    end\n    return x:sub(shift + 1) .. x:sub(1, shift)\nend",
  "    local x_str = tostring(x)\n    local x_len = #x_str\n    if shift < x_len then\n\
    \        local x_lhs = string.sub(x_str, 1, shift)\n        local x_rhs = string.sub(x_str,\
    \ shift + 1, x_len)\n        return x_rhs .. x_lhs\n    else\n        return string.reverse(x_str)\n\
    \    end\nend", "    local a = math.ceil(math.log10(x))\n    shift = shift % a\n\
    \    if shift == 0 then\n        return x\n    end\n    local s = math.floor(x\
    \ / 10^shift)\n    local t = x % 10^shift\n    return t*10^a + s\nend", "    if\
    \ shift == 0 then\n        return tostring(x)\n    end\n    local s = tostring(x)\n\
    \    shift = shift % #s\n    local n = #s - shift\n    return s:sub(n + 1) ..\
    \ s:sub(1, n)\nend", "  return string.reverse(string.format(\"%03d\", tonumber(string.reverse(string.format(\"\
    %03d\", x)))))\nend", "    if shift == 0 then\n        return x\n    end\n   \
    \ local str = tostring(x)\n    local len = #str\n    if shift > len then\n   \
    \     shift = shift % len\n    end\n    if shift == 0 then\n        return str\n\
    \    end\n    return str:sub(len - shift + 1) .. str:sub(1, len - shift)\nend",
  "    -- find the number of digits in x\n    local n = #(tostring(x))\n    -- For\
    \ shift > number of digits, we will just end up reversing the number.\n    if\
    \ shift > n then\n        shift = shift % n\n    end\n    -- If shift = 0, nothing\
    \ has to be done.\n    if shift == 0 then\n        return tostring(x)\n    end\n\
    \    -- Otherwise,\n    -- We first reverse the number, then shift it and reverse\
    \ it again.\n    -- The results of this example should be the same as\n    --\
    \ circular_shift(12, 2)\n    -- >>> circular_shift(21, 2)\n    -- \"12\"\n   \
    \ local s = tostring(x)\n    local y = string.reverse(s)\n    -- Divide y into\
    \ two parts, one of size shift and the other of size n - shift.\n    -- The two\
    \ parts are put together, but in reverse order.\n    return string.reverse(string.sub(y,\
    \ 1, shift) .. string.sub(y, shift + 1, n))\nend", "    local n = math.floor(math.log10(x))\n\
    \    local digits = {}\n    while n >= 0 do\n        digits[n + 1] = x % 10\n\
    \        x = math.floor(x / 10)\n        n = n - 1\n    end\n    digits = table.slice(digits,\
    \ -shift + 1) .. table.slice(digits, 1, -shift)\n    return table.concat(digits)\n\
    end", "    local digits = number_to_digits(x)\n    while shift > 0 do\n      \
    \  local last = table.remove(digits)\n        table.insert(digits, 1, last)\n\
    \        shift = shift - 1\n    end\n    return digits_to_number(digits)\nend",
  "\tlocal digits = digit_list(x)\n\ttable.insert(digits, 1, table.remove(digits,\
    \ #digits))\n\treturn table.concat(digits)\nend", "    local y = x\n    local\
    \ z = 0\n    local k = 0\n    local digits = 0\n    local base = 10\n    local\
    \ reversed = false\n    local result = \"\"", "    local digits = num_digits(x)\n\
    \    shift = shift % digits\n    local d = {}\n    for i = 1, digits do\n    \
    \    d[i] = x % 10\n        x = (x - d[i]) / 10\n    end\n    for i = 1, shift\
    \ do\n        local p = d[1]\n        for j = 1, digits - 1 do\n            d[j]\
    \ = d[j + 1]\n        end\n        d[digits] = p\n    end\n    local result =\
    \ ''\n    for i = 1, digits do\n        result = result .. tostring(d[i])\n  \
    \  end\n    return result\nend", "\tlocal str = tostring(x)\n\tlocal num = str:len()\n\
    \tif shift >= num then\n\t\treturn str:reverse()\n\tend\n\tlocal d1 = str:sub(1,\
    \ shift)\n\tlocal d2 = str:sub(shift + 1)\n\treturn d2 .. d1\nend", "    local\
    \ x_str = tostring(x)\n    if shift > #x_str then\n        local reverse = \"\"\
    \n        for i = #x_str, 1, -1 do\n            reverse = reverse .. x_str:sub(i,\
    \ i)\n        end\n        return reverse\n    end\n    return x_str:sub(shift\
    \ + 1) .. x_str:sub(1, shift)\nend", "\tlocal x = tostring(x)\n\tlocal n = #x\n\
    \tif shift >= n then\n\t\treturn string.reverse(x)\n\tend\n\treturn string.sub(x,\
    \ shift + 1, n) .. string.sub(x, 1, shift)\nend", "\tx = tostring(x)\n\tlocal\
    \ result = x:sub(#x - shift + 1) .. x:sub(1, #x - shift)\n\treturn result\nend",
  "  x = tostring(x)\n  shift = shift % #x\n  return x:sub(shift + 1) .. x:sub(1,\
    \ shift)\nend", "  -- turn into string\n  local digits = split_str(tostring(x))\n\
    \  -- reverse if shift > #digits\n  if shift > #digits then\n    digits = reverse(digits)\n\
    \  end\n  -- circular shift\n  for i = 1, shift do\n    table.insert(digits, 1,\
    \ table.remove(digits))\n  end\n  -- turn back into string\n  return table.concat(digits)\n\
    end", "  if shift > num_digits(x) then\n    return string.reverse(tostring(x))\n\
    \  end\n  local a = string.sub(tostring(x), 1, shift)\n  local b = string.sub(tostring(x),\
    \ shift + 1)\n  return b .. a\nend", "    local result = tostring(x)\n    local\
    \ len = #result\n    if shift >= len then\n        return result:reverse()\n \
    \   end\n    return result:sub(len - shift + 1) .. result:sub(1, len - shift)\n\
    end", "\tlocal t = {}\n\tlocal s = x % 10\n\tlocal i = 1\n\twhile x ~= 0 do\n\t\
    \tt[i] = s\n\t\tx = math.floor(x / 10)\n\t\ti = i + 1\n\t\ts = x % 10\n\tend\n\
    \tlocal shift = i - shift - 1\n\tif shift < 0 then\n\t\tshift = i - 1\n\tend\n\
    \tlocal result = ''\n\tfor i = 1, #t do\n\t\tshift = shift + 1\n\t\tif shift >\
    \ #t then\n\t\t\tshift = 1\n\t\tend\n\t\tresult = result .. t[shift]\n\tend\n\t\
    return result\nend", "  local x_s = tostring(x)\n  if shift > #x_s then\n    return\
    \ string.reverse(x_s)\n  end\n  local n = #x_s\n  local x_ls = {}\n  for i = 1,\
    \ n do\n    x_ls[i] = string.sub(x_s, i, i)\n  end\n  for i = 1, shift do\n  \
    \  local tmp = x_ls[n]\n    for j = n, 2, -1 do\n      x_ls[j] = x_ls[j - 1]\n\
    \    end\n    x_ls[1] = tmp\n  end\n  local x_ls_str = \"\"\n  for i = 1, n do\n\
    \    x_ls_str = x_ls_str .. x_ls[i]\n  end\n  return x_ls_str\nend", "    if x\
    \ == 0 then\n        return x\n    end\n    local x_str = tostring(x)\n    shift\
    \ = shift % #x_str\n    local b = x_str:sub(1, shift)\n    local a = x_str:sub(shift\
    \ + 1)\n    return a .. b\nend", "    local s = tostring(x)\n    local slen =\
    \ #s\n    local index = 1\n    local digits = {}\n    for _ = 1, slen do\n   \
    \     local digit = string.sub(s, index, index)\n        table.insert(digits,\
    \ digit)\n        index = index + 1\n    end\n    for _ = 1, shift do\n      \
    \  local last_digit = table.remove(digits)\n        table.insert(digits, 1, last_digit)\n\
    \    end\n    return table.concat(digits)\nend", "    local y = tostring(x)\n\
    \    shift = shift % #y\n    return y:sub(shift + 1) .. y:sub(1, shift)\nend",
  "    local x_len = #tostring(x)\n    if shift < x_len then\n        return tostring(x):sub(x_len\
    \ - shift + 1) .. tostring(x):sub(1, x_len - shift)\n    else\n        return\
    \ tostring(x):reverse()\n    end\nend", "\tlocal digits = integer_to_string(x)\n\
    \tlocal n = #digits\n\tif shift > n then\n\t\treturn string.reverse(digits)\n\t\
    end\n\tlocal suffix = string.sub(digits, 1, shift)\n\tlocal prefix = string.sub(digits,\
    \ shift + 1, n)\n\treturn prefix .. suffix\nend", "  local rev_str = string.reverse(tostring(x))\n\
    \  local n = #rev_str\n  local str = string.sub(rev_str, 1, shift)\n  str = str\
    \ .. string.sub(rev_str, shift + 1, n)\n  return string.reverse(str)\nend", " \
    \ if shift == 0 then\n    return tostring(x)\n  end\n  local digits = reverse(tostring(x))\n\
    \  local len = #digits\n  if shift > len then\n    return digits\n  end\n  local\
    \ prefix = substr(digits, shift + 1, len)\n  local suffix = substr(digits, 1,\
    \ shift)\n  return prefix .. suffix\nend", "    local t = {}\n    local sx = tostring(x)\n\
    \    local len = #sx\n    for i = 1, len do\n        t[i] = sx:sub(i, i)\n   \
    \ end\n    if shift > len then\n        return sx:reverse()\n    end\n    -- if\
    \ shift < len, then shift will be in range 1..len-1.\n    table.remove(t, 1)\n\
    \    local s = table.concat(t)\n    local ns = s:sub(1, len - shift)\n    local\
    \ a = s:sub(len - shift + 1, len)\n    return a .. ns\nend", "    -- Get rid of\
    \ leading zeros\n    x = tostring(x):gsub(\"^0*\", \"\")\n    local len = #x\n\
    \    if shift >= len then\n        return reverse(x)\n    end\n    local left\
    \ = x:sub(1, len - shift)\n    local right = x:sub(len - shift + 1)\n    return\
    \ right .. left\nend", "    -- convert x to string, if it's negative we need to\
    \ ignore the minus sign\n    -- and shift the number as positive and then prepend\
    \ the minus sign\n    local negative = false\n    if x < 0 then\n        negative\
    \ = true\n        x = math.abs(x)\n    end\n    local s = tostring(x)\n    local\
    \ digits = #s\n    if shift >= digits then\n        return string.reverse(s)\n\
    \    end\n    return string.sub(s, shift + 1) .. string.sub(s, 1, shift)\nend",
  "\tlocal a, b, res = x, 0, \"\"\n\twhile a > 0 do\n\t\ta, b = math.floor(a / 10),\
    \ a % 10\n\t\tb = b * 10 ^ shift\n\t\tres = tostring(b) .. res\n\tend\n\treturn\
    \ res\nend", "    local digits = tostring(x)\n    local len = #digits\n    if\
    \ len <= shift then\n        return string.reverse(digits)\n    end\n    local\
    \ x1 = string.sub(digits, 1, shift)\n    local x2 = string.sub(digits, shift +\
    \ 1, len)\n    return x2 .. x1\nend", "    local s = tostring(x)\n    shift =\
    \ shift % #s\n    return (string.sub(s, -shift) .. string.sub(s, 1, -shift - 1))\n\
    end", "    local str = tostring(x)\n    if shift > #str then\n        return (string.reverse(str))\n\
    \    end\n    return (string.sub(str, shift + 1) .. string.sub(str, 1, shift))\n\
    end", "    local digits = number_to_string(x)\n    local n = #digits\n    local\
    \ shift = shift % n\n    return string.sub(digits, n - shift + 1, n) .. string.sub(digits,\
    \ 1, n - shift)\nend", "    if shift >= x.value:len() then\n        return x.value:reverse()\n\
    \    end\n    local digits = {}\n    local digit_value = 0\n    while x.value:len()\
    \ > 0 do\n        digit_value = x.value:sub(1, 1)\n        digits[#digits + 1]\
    \ = digit_value\n        x.value = x.value:sub(2)\n    end\n    for i = 1, shift\
    \ do\n        table.insert(digits, 1, table.remove(digits))\n    end\n    local\
    \ result = table.concat(digits)\n    return result\nend", "\tlocal digits = digit_list(x)\n\
    \tlocal length = #digits\n\tif length <= shift then\n\t\treturn table.concat(digit_list(x,\
    \ true))\n\tend\n\tlocal r = {}\n\tfor i = shift + 1, length do\n\t\tr[#r + 1]\
    \ = digits[i]\n\tend\n\tfor i = 1, shift do\n\t\tr[#r + 1] = digits[i]\n\tend\n\
    \treturn table.concat(r)\nend", "\treturn string.reverse(\n\t\tstring.sub(\n\t\
    \t\tstring.reverse(tostring(x)) .. string.rep(\"0\", shift),\n\t\t\t1,\n\t\t\t\
    #tostring(x)\n\t\t)\n\t)\nend", "  local d = 2 ^ math.floor(math.log(x) / math.log(10))\n\
    \  for i = 1, shift do\n    local m = x % 10\n    x = math.floor(x / 10) + m *\
    \ d\n  end\n  return tostring(x)\nend", "\tlocal rx = reverse(x)\n\tfor i = 1,\
    \ shift do\n\t\tlocal r = mod(rx, 10)\n\t\trx = rx - r\n\t\trx = rx / 10\n\t\t\
    rx = rx + r * 10^(length(x) - 1)\n\tend\n\treturn tostring(rx)\nend", "  local\
    \ xstr = tostring(x)\n  local digits = xstr:len()\n  if shift > digits then\n\
    \    return xstr:reverse()\n  end\n  return xstr:sub(digits-shift+1) .. xstr:sub(1,\
    \ digits-shift)\nend", "  local str = tostring(x)\n  if #str <= shift then\n \
    \   return str:reverse()\n  end\n  return str:sub(shift + 1) .. str:sub(1, shift)\n\
    end", "\treturn tostring(x):gsub(\"^()(%d)(%d)(%d)(%d)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d?)(%d",
  "    local count = 0\n    local swap\n    local xs = tostring(x)\n    for i = 1,\
    \ shift do\n        swap = xs:sub(#xs)\n        xs = xs:sub(1, #xs - 1)\n    \
    \    xs = swap .. xs\n    end\n    return xs\nend", "    local digits = {}\n \
    \   local quotient = x\n    while quotient > 0 do\n        local digit = quotient\
    \ % 10\n        quotient = (quotient - digit) / 10\n        table.insert(digits,\
    \ digit)\n    end\n    for i = 1, shift do\n        local digit = table.remove(digits,\
    \ 1)\n        table.insert(digits, digit)\n    end\n    local ret = {}\n    for\
    \ i = #digits, 1, -1 do\n        table.insert(ret, digits[i])\n    end\n    return\
    \ table.concat(ret)\nend", "  local s = tostring(x)\n  local len = #s\n  if shift\
    \ > len then\n    return string.reverse(s)\n  end\n  return string.sub(s, shift\
    \ + 1, len) .. string.sub(s, 1, shift)\nend", "\tlocal digits = {}\n\tlocal i\
    \ = 0\n\twhile x > 0 do\n\t\tdigits[i] = x % 10\n\t\tx = math.floor(x / 10)\n\t\
    \ti = i + 1\n\tend\n\tshift = shift % i\n\tif shift > 0 then\n\t\tlocal j = i\
    \ - 1\n\t\tlocal k = j - shift\n\t\twhile k >= 0 do\n\t\t\tdigits[j] = digits[k]\n\
    \t\t\tj = j - 1\n\t\t\tk = k - 1\n\t\tend\n\t\twhile j >= 0 do\n\t\t\tdigits[j]\
    \ = digits[i - 1]\n\t\t\tj = j - 1\n\t\tend\n\tend\n\tlocal str = \"\"\n\tfor\
    \ j = 0, i - 1 do\n\t\tstr = str .. digits[j]\n\tend\n\treturn str\nend", "  \
    \  local s = tostring(x)\n    shift = shift % (#s)\n    return (s:sub(shift +\
    \ 1) .. s:sub(1, shift))\nend", "  local digit_count = math.floor(math.log10(x))\
    \ + 1\n  if shift > digit_count then\n    return string.reverse(x)\n  end\n  local\
    \ last_shifted = math.floor(x / math.pow(10, shift))\n  local last_shifted_digit_count\
    \ = math.floor(math.log10(last_shifted)) + 1\n  local high_order_digits = math.floor(x\
    \ / math.pow(10, digit_count - shift))\n  local low_order_digits = x % math.pow(10,\
    \ digit_count - shift)\n  return (low_order_digits * math.pow(10, last_shifted_digit_count))\
    \ + last_shifted\nend", "  local s = tostring(x)\n  local len = string.len(s)\n\
    \  local shifted = string.sub(s, len - shift + 1, len)\n  for i = 1, shift do\n\
    \    shifted = shifted .. string.sub(s, i, i)\n  end\n  return shifted\nend",
  "\tlocal digits = string.format(\"%d\", x)\n\tshift = shift % #digits\n\tif shift\
    \ == 0 then\n\t\treturn digits\n\telse\n\t\treturn string.sub(digits, #digits\
    \ - shift + 1) .. string.sub(digits, 1, #digits - shift)\n\tend\nend", "    local\
    \ digits = number_to_digits(x)\n    local n = #digits\n    if shift > n then\n\
    \        return table.concat(digits, \"\")\n    end\n    local res = {}\n    for\
    \ i = 1, n do\n        res[i] = digits[i-shift] or digits[i-shift+n]\n    end\n\
    \    return table.concat(res, \"\")\nend", "\tlocal rev = tostring(x):reverse()\n\
    \treturn (rev:sub(1, shift)..rev:sub(shift+1)):reverse()\nend", "    local s =\
    \ tostring(x)\n    local l = string.len(s)\n    local n = shift % l\n    if n\
    \ == 0 then\n        return s\n    elseif n > 0 then\n        return string.sub(s,\
    \ l - n + 1) .. string.sub(s, 1, l - n)\n    else\n        return string.sub(s,\
    \ -n + 1) .. string.sub(s, 1, -n)\n    end\nend", "    local digits = split_digits(x)\n\
    \    local l = #digits\n    for i = 1, shift do\n        local a = digits[1]\n\
    \        for j = 1, l - 1 do\n            digits[j] = digits[j + 1]\n        end\n\
    \        digits[l] = a\n    end\n    return table.concat(digits)\nend", "  local\
    \ digits = tostring(x)\n  if #digits <= shift then\n    return string.reverse(digits)\n\
    \  end\n  return string.sub(digits, shift + 1) .. string.sub(digits, 1, shift)\n\
    end", "\tlocal d = 1\n\tlocal x1 = x\n\tlocal x2 = x\n\tlocal s = 0\n\t\n\t--\
    \ Find the number of digits in x, and the largest digit.\n\twhile x1 > 0 do\n\t\
    \td = d + 1\n\t\tlocal r = x1 % 10\n\t\tif r > s then\n\t\t\ts = r\n\t\tend\n\t\
    \tx1 = math.floor(x1 / 10)\n\tend\n\t\n\t-- If shift is larger than the number\
    \ of digits, reverse digits.\n\tif shift >= d then\n\t\tshift = d - 1\n\tend\n\
    \t\n\t-- Shift each digit to the right by shift, store in x2.\n\tlocal i = 1\n\
    \twhile i <= d - shift do\n\t\tlocal r = x2 % 10\n\t\tx2 = math.floor(x2 / 10)\n\
    \t\tlocal p = 10 ^ (d - i - shift)\n\t\tx2 = x2 + r * p\n\t\ti = i + 1\n\tend\n\
    \t\n\t-- Convert x2 to a string and return the string.\n\treturn tostring(x2)\n\
    end", "    -- make a copy of x to prevent mutating it\n    local xx = x\n    local\
    \ base = 10\n    local total_digits = 0\n    local digits = {}\n    while xx >\
    \ 0 do\n        local digit = math.floor(xx % base)\n        table.insert(digits,\
    \ digit)\n        xx = math.floor(xx / base)\n        total_digits = total_digits\
    \ + 1\n    end\n    local retval = \"\"\n    for i = 1, #digits do\n        local\
    \ index = ((i - 1 + shift) % total_digits) + 1\n        retval = retval .. tostring(digits[index])\n\
    \    end\n    return retval\nend", "    if shift > 0 then\n        local str =\
    \ tostring(x)\n        local str_len = str:len()\n        return str:sub(shift\
    \ + 1, str_len) .. str:sub(1, shift)\n    else\n        return tostring(x)\n \
    \   end\nend", "\treturn string.gsub(tostring(x), \"(.*)\", \"%\" .. shift ..\
    \ \"1\")\nend", "\tlocal len = math.floor(math.log10(x)) + 1\n\tlocal form = string.format(\"\
    %%.%dd\", len)\n\tlocal s = string.format(form, x)\n\tlocal s2 = s:sub(1, shift)\n\
    \tlocal s3 = s:sub(shift + 1)\n\treturn s3 .. s2\nend", "\tlocal digits = num.todigits(x)\n\
    \tlocal tmp = num.get_digits(x)\n\tlocal result = {}\n\tfor i = 1, #digits do\n\
    \t\tresult[i] = digits[(i + shift - 1) % tmp + 1]\n\tend\n\treturn table.concat(result)\n\
    end", "  local str = tostring(x)\n  if shift > #str then\n    return string.reverse(str)\n\
    \  end\n  return string.sub(str, shift+1) .. string.sub(str, 1, shift)\nend",
  "    x = x % 10^shift\n    x = tostring(x)\n    if #x == shift then\n        return\
    \ x\n    else\n        return circular_shift(x..x, shift)\n    end\nend", "  local\
    \ y = x\n  for _ = 1, shift do\n    local remainder = y % 10\n    y = (y - remainder)\
    \ / 10\n    y = remainder * power(10, get_digits(x)) + y\n  end\n  return tostring(y)\n\
    end", "    x = tostring(x)\n    shift = shift % #x\n    return x:sub(#x - shift\
    \ + 1) .. x:sub(1, #x - shift)\nend", "    local digits = rev_digits(x)\n    local\
    \ n = #digits\n    shift = shift % n\n    if shift == 0 then\n        return table.concat(digits)\n\
    \    end\n    local res = {}\n    for i = shift + 1, n do\n        res[#res +\
    \ 1] = digits[i]\n    end\n    for i = 1, shift do\n        res[#res + 1] = digits[i]\n\
    \    end\n    return table.concat(res)\nend", "    local digits = tostring(x)\n\
    \    local len = #digits\n    if shift >= len then\n        return string.reverse(digits)\n\
    \    end\n    return digits:sub(shift + 1, len) .. digits:sub(1, shift)\nend",
  "    local digits = string.format(\"%d\", x)\n    if shift >= #digits then\n   \
    \     return string.reverse(digits)\n    end\n    local first = string.sub(digits,\
    \ 1, shift)\n    local last = string.sub(digits, shift + 1)\n    return last ..\
    \ first\nend", "\tlocal digit = n_digits(x)\n\tif shift > digit then\n\t\treturn\
    \ reverse(x)\n\tend\n\tlocal front = reverse(take(shift, x))\n\tlocal back = drop(shift,\
    \ x)\n\treturn front .. back\nend", "\tlocal n = tostring(x)\n\tlocal s = #n\n\
    \tshift = shift % s", "    local digits = {}\n    while x > 0 do\n        table.insert(digits,\
    \ 1, x % 10)\n        x = math.floor(x / 10)\n    end\n    for i = 1, shift do\n\
    \        table.insert(digits, 1, table.remove(digits))\n    end\n    local result\
    \ = ''\n    for i = 1, #digits do\n        result = result .. tostring(digits[i])\n\
    \    end\n    return result\nend", "    local digits = string.reverse(math.log10(x)\
    \ + 1)\n    local digits_shifted = shift > digits and\n        (digits - shift)\
    \ % digits or shift\n    local result = math.fmod(x, 10^digits_shifted) *\n  \
    \      10^(digits - digits_shifted) +\n        math.floor(x / 10^digits_shifted)\n\
    \    return tostring(result)\nend", "    local n = #tostring(x)\n    if n == 0\
    \ then\n        return x\n    end\n    if shift >= n then\n        return string.reverse(tostring(x))\n\
    \    end\n    local l = n - shift\n    local ld = tostring(x):sub(1, l)\n    local\
    \ rd = tostring(x):sub(l + 1, n)\n    return rd .. ld\nend", "\tlocal digits =\
    \ tostring(x)\n\tif #digits <= shift then\n\t\treturn string.reverse(digits)\n\
    \tend\n\treturn string.sub(digits, 1+shift) .. string.sub(digits, 1, shift)\n\
    end", "  local x = tostring(x)\n  if shift > #x then\n    return x:reverse()\n\
    \  end\n  local a = x:sub(1, #x - shift)\n  local b = x:sub(#x - shift + 1, #x)\n\
    \  return b .. a\nend", "    local s = tostring(x)\n    if shift >= #s then\n\
    \        return reverse(s)\n    end\n    return s:sub(shift + 1) .. s:sub(1, shift)\n\
    end", "    -- get original number of digits\n    local digits = #tostring(x)\n\
    \    -- if shift greater than number of digits, reverse digits\n    if shift >\
    \ digits then\n        return string.reverse(tostring(x))\n    else\n        --\
    \ right shift\n        local right = tonumber(string.sub(tostring(x), -shift))\n\
    \        -- left shift\n        local left = tonumber(string.sub(tostring(x),\
    \ 1, -shift - 1))\n        -- return circular shift\n        return string.format(\"\
    %s%s\", right, left)\n    end\nend", "    local s = tostring(x)\n    if shift\
    \ > #s then\n        return string.reverse(s)\n    end\n    return s:sub(shift\
    \ + 1) .. s:sub(1, shift)\nend", "    local digits = {}\n    local result = \"\
    \"\n    local l = 0\n    local i = 0\n    local k = 0\n    while x > 0 do\n  \
    \      digits[l + 1] = x % 10\n        x = math.floor(x / 10)\n        l = l +\
    \ 1\n    end\n    for i = 1, l do\n        k = ((l - i) + shift) % l + 1\n   \
    \     result = result .. digits[k]\n    end\n    return result\nend", "    local\
    \ digits = string.reverse(x)\n    local result = digits\n    if shift < string.len(digits)\
    \ then\n        local head = string.sub(digits, 1, shift)\n        local tail\
    \ = string.sub(digits, shift + 1)\n        result = tail .. head\n    end\n  \
    \  return result\nend", "\tx = tonumber(x)\n\tlocal digits = {}\n\tlocal str_x\
    \ = tostring(x)\n\tlocal len = string.len(str_x)\n\tfor i = 1, len do\n\t\ttable.insert(digits,\
    \ string.sub(str_x, i, i))\n\tend\n\tif shift > len then\n\t\treturn table.concat(digits,\
    \ \"\", 1, len)\n\tend\n\tfor i = 1, shift do\n\t\ttable.insert(digits, 1, table.remove(digits))\n\
    \tend\n\treturn table.concat(digits, \"\", 1, len)\nend", "    local str = tostring(x)\n\
    \    local N = #str\n    local factor = 10^(N-shift)\n    local r = math.floor(x/factor)\n\
    \    local l = x - factor*r\n    return tostring(r) .. tostring(l)\nend", "  local\
    \ digits = math.floor(math.log10(x))\n  local y = x\n  for i = 1, digits - shift\
    \ do\n    y = math.floor(y / 10)\n  end\n  return y\nend", "    local digits =\
    \ get_digits(x)\n    local len = #digits\n    if len <= shift then\n        return\
    \ table.concat(flip(digits))\n    end\n    local a = flip(table.slice(digits,\
    \ shift + 1, len))\n    local b = table.slice(digits, 1, shift)\n    return table.concat(flip(table.append(a,\
    \ b)))\nend", "    local s = \"\"\n    if shift == 0 then\n        s = tostring(x)\n\
    \    else\n        local digits = {}\n        local cnt = 0\n        while x >\
    \ 0 do\n            cnt = cnt + 1\n            local div = x % 10\n          \
    \  x = math.floor(x / 10)\n            digits[cnt] = div\n        end\n      \
    \  if shift > cnt then\n            shift = shift % cnt\n        end\n       \
    \ for i = 1, shift do\n            s = s .. tostring(digits[cnt])\n          \
    \  cnt = cnt - 1\n        end\n        for i = 1, cnt do\n            s = s ..\
    \ tostring(digits[i])\n        end\n    end\n    return s\nend", "\tif not x then\n\
    \t\treturn \"0\"\n\tend\n\tlocal digits = (x .. \"\")\n\tif #digits < shift then\n\
    \t\treturn string.reverse(digits)\n\tend\n\tlocal left = string.sub(digits, 1,\
    \ shift)\n\tlocal right = string.sub(digits, shift + 1)\n\treturn right .. left\n\
    end", "    local xs = math.abs(x)\n    if xs == 0 then\n        return '0'\n \
    \   end\n    local digits = {}\n    while xs > 0 do\n        digits[#digits +\
    \ 1] = tostring(xs % 10)\n        xs = math.floor(xs / 10)\n    end\n    shift\
    \ = shift % #digits\n    local result = {}\n    for i = 1, #digits do\n      \
    \  result[i] = digits[(i + shift - 1) % #digits + 1]\n    end\n    return table.concat(result)\n\
    end", "    local s = tostring(x)\n    local n = #s\n    if shift > n then\n  \
    \      return string.reverse(s)\n    end\n    local r = ''\n    r = r .. string.sub(s,\
    \ 1, shift)\n    r = r .. string.sub(s, shift + 1, n)\n    r = r .. string.sub(s,\
    \ 1, shift)\n    return r\nend", "    local digits = {}\n    local num_digits\
    \ = 0\n    local digit\n    repeat\n        num_digits = num_digits + 1\n    \
    \    digit = x % 10\n        x = (x - digit) / 10\n        digits[num_digits]\
    \ = digit\n    until x == 0\n    local result = {}\n    for i = 1, num_digits\
    \ do\n        result[i] = digits[((i - 1 + shift) % num_digits) + 1]\n    end\n\
    \    return table.concat(result)\nend", "    local str = tostring(x)\n    shift\
    \ = shift % #str\n    return str:sub(#str-shift+1) .. str:sub(1, #str-shift)\n\
    end", "    local orig = tostring(x)\n    local s = string.reverse(orig)\n    local\
    \ s = s .. string.sub(s, 1, shift)\n    return string.sub(s, 1, string.len(orig))\n\
    end", "    if x == 0 then\n        return \"0\"\n    end\n    local x_str = tostring(x)\n\
    \    local num_digits = #x_str\n    local shift = shift % num_digits\n    local\
    \ leading_str = string.sub(x_str, 1, shift)\n    local trailing_str = string.sub(x_str,\
    \ shift + 1, num_digits)\n    return trailing_str .. leading_str\nend", "  return\
    \ string.reverse(shifted_string(x, shift))\nend", "  local s = tostring(x)\n \
    \ shift = shift % #s\n  local left, right = sub(s, 1, shift), sub(s, shift + 1)\n\
    \  return right .. left\nend", "  if shift == 0 then\n    return tostring(x)\n\
    \  end\n  local s = tostring(x)\n  local l = s:len()\n  if shift < l then\n  \
    \  s = s:sub(shift + 1) .. s:sub(1, shift)\n  else\n    s = s:reverse()\n  end\n\
    \  return s\nend", "    local digits = string.format(\"%d\", x)\n    local len\
    \ = #digits\n    local m = math.max(len, shift)\n    return string.sub(digits,\
    \ shift + 1, m) .. string.sub(digits, 1, shift)\nend", "  local reversed_digits\
    \ = string.reverse(tostring(x))\n  local len = string.len(reversed_digits)\n \
    \ return string.sub(reversed_digits, shift + 1, len) .. string.sub(reversed_digits,\
    \ 1, shift)\nend", "\tlocal digits = number_to_digits(x)\n\tlocal s = table.concat(digits)\n\
    \tlocal count = #digits\n\tif shift >= count then\n\t\ts = string.reverse(s)\n\
    \telse\n\t\tfor i = 1, shift do\n\t\t\tlocal c = s:sub(1, 1)\n\t\t\ts = s:sub(2)\n\
    \t\t\ts = s .. c\n\t\tend\n\tend\n\treturn s\nend", "    local s = tostring(x)\n\
    \    return (s:sub(shift) .. s:sub(1, shift)):reverse()\nend", "  local str =\
    \ tostring(x)\n  if #str < shift then\n    str = string.reverse(str)\n  else\n\
    \    local arr = {}\n    for i = 1, #str do\n      arr[i] = str:sub(i, i)\n  \
    \  end\n    for i = 1, shift do\n      local t = arr[#arr]\n      table.remove(arr,\
    \ #arr)\n      table.insert(arr, 1, t)\n    end\n    str = table.concat(arr)\n\
    \  end\n  return str\nend", "    local s = tostring(x)\n    local l = #s\n   \
    \ if shift > l then\n        return s:reverse()\n    end\n    local e = l - shift\n\
    \    return s:sub(e + 1) .. s:sub(1, e)\nend", "  if shift > #tostring(x) then\n\
    \    return string.reverse(tostring(x))\n  end\n  local y = tostring(x)\n  local\
    \ z = y:sub(shift+1) .. y:sub(1, shift)\n  return z\nend", "  local i = x\n  local\
    \ str = ''\n  local pow = 10\n  local tmp = 0\n  local cshift = shift\n  -- find\
    \ highest power of 10 for x\n  while i > pow do\n    pow = pow * 10\n  end\n \
    \ -- make sure shift is within digits of x\n  if cshift > pow then\n    cshift\
    \ = cshift % pow\n  end\n  -- shift digits\n  for i = 1, cshift do\n    str =\
    \ str .. tostring(x % 10)\n    x = math.floor(x / 10)\n  end\n  -- add shifted\
    \ digits\n  while x > 0 do\n    str = str .. tostring(x % 10)\n    x = math.floor(x\
    \ / 10)\n  end\n  -- reverse string\n  local len = string.len(str)\n  local rev\
    \ = ''\n  for i = 1, len do\n    rev = rev .. string.sub(str, len - i + 1, len\
    \ - i + 1)\n  end\n  return rev\nend", "\tif shift == 0 then\n\t\treturn x\n\t\
    end\n\tlocal reversed = string.reverse(x)\n\treturn string.sub(reversed, shift\
    \ + 1) .. string.sub(reversed, 1, shift)\nend", "  local s = \"\"\n  if shift\
    \ >= num_digits(x) then\n    s = reverse(number_to_string(x))\n  else\n    s =\
    \ number_to_string(x)\n    s = string.sub(s, shift + 1) .. string.sub(s, 1, shift)\n\
    \  end\n  return s\nend", "    local s = tostring(x)\n    if shift < 0 then\n\
    \        shift = #s + shift\n    end\n    return s:sub(shift+1) .. s:sub(1, shift)\n\
    end", "    -- get number of digits in x\n    local num_digits = #tostring(x)\n\
    \    -- calculate the shift\n    shift = (shift > num_digits) and num_digits or\
    \ shift\n    -- get the first digit\n    local digit = x % 10\n    -- shift the\
    \ digit to the left by 1\n    x = x - digit\n    x = x + (digit * (10 ^ (num_digits\
    \ - 1)))\n    return tostring(x)\nend", "    local digits = floor(log10(x))\n\
    \    local ans = 0\n    local i = 0\n    while x > 0 do\n        local d = x %\
    \ 10\n        x = floor(x / 10)\n        ans = ans + d * 10^((i+shift) % (digits+1))\n\
    \        i = i + 1\n    end\n    return ans\nend", "  if shift == 0 then\n   \
    \ return tostring(x)\n  end\n  local digits = tostring(x)\n  local shift = shift\
    \ % #digits\n  local s1 = digits:sub(1, #digits - shift)\n  local s2 = digits:sub(#digits\
    \ - shift + 1, #digits)\n  return s2 .. s1\nend", "    local digits = int_to_digits(x)\n\
    \    local n = #digits\n    if shift >= n then\n        return table.concat(digits,\
    \ \"\")\n    end\n    local first = math.max(n - shift, 1)\n    local rest = table.slice(digits,\
    \ 1, first - 1)\n    return table.concat(table.merge(digits, rest), \"\")\nend",
  "\tlocal x = tostring(x)\n\tlocal shift = shift % #x\n\tlocal s = x:sub(#x - shift\
    \ + 1)\n\tlocal p = x:sub(1, #x - shift)\n\treturn s .. p\nend", "    local len\
    \ = #tostring(x)\n    local shift = shift % len\n    if shift == 0 then\n    \
    \    return tostring(x)\n    end\n    return tostring(x):sub(shift + 1) .. tostring(x):sub(1,\
    \ shift)\nend", "    local digits = tonumber(\n        table.concat(utils.reverse(utils.digits(x)),\
    \ \"\")\n    )\n    local n = shift % #tostring(x)\n    local s = tostring(digits)\n\
    \    local pre = string.sub(s, n + 1)\n    local post = string.sub(s, 1, n)\n\
    \    return pre .. post\nend", "    local s = tostring(x)\n    local t = string.reverse(s)\n\
    \    local n = #t\n    if shift > n then\n        return t\n    end\n    local\
    \ r = \"\"\n    for i = 1, shift do\n        r = r .. string.sub(t, i, i)\n  \
    \  end\n    for i = shift + 1, n do\n        r = r .. string.sub(t, i, i)\n  \
    \  end\n    return r\nend", "    local s = tostring(x)\n    if shift > #s then\n\
    \        return s:reverse()\n    end\n    return s:sub(shift + 1) .. s:sub(1,\
    \ shift)\nend", "    local s = tostring(x)\n    local l = s:len()\n    if shift\
    \ > l then\n        return string.reverse(s)\n    end\n    local l1 = l - shift\n\
    \    local s1 = s:sub(1, l1)\n    local s2 = s:sub(l1 + 1, l)\n    return s2 ..\
    \ s1\nend", "    local digits = {}\n    repeat\n        table.insert(digits, x\
    \ % 10)\n        x = math.floor(x / 10)\n    until x == 0\n    while shift > #digits\
    \ do\n        shift = shift - #digits\n    end\n    for i = 1, shift do\n    \
    \    table.insert(digits, 1, table.remove(digits))\n    end\n    return table.concat(digits)\n\
    end", "    local digits = digits_of(x)\n    local ndigits = #digits\n    local\
    \ shifted_digits = {}\n    if shift >= ndigits then\n        shifted_digits =\
    \ digits_reverse(digits)\n    else\n        for i = ndigits - shift + 1, ndigits\
    \ do\n            shifted_digits[#shifted_digits + 1] = digits[i]\n        end\n\
    \        for i = 1, ndigits - shift do\n            shifted_digits[#shifted_digits\
    \ + 1] = digits[i]\n        end\n    end\n    return table.concat(shifted_digits)\n\
    end", "\treturn tostring(x):reverse():sub(1, shift):reverse() .. tostring(x):sub(1,\
    \ #tostring(x) - shift)\nend", "    -- The number of digits in the number x\n\
    \    local digits = get_number_of_digits(x)\n    local remainder = shift % digits\n\
    \    -- Reverse and shift in one go\n    if remainder > 0 then\n        local\
    \ shifted = reverse_digits(x)\n        shifted = shift_digits(shifted, remainder)\n\
    \        shifted = reverse_digits(shifted)\n        return shifted\n    else\n\
    \        return x\n    end\nend", "  local digits = tostring(x)\n  local prefix\
    \ = string.sub(digits, 1, shift)\n  local suffix = string.sub(digits, shift +\
    \ 1)\n  return suffix .. prefix\nend", "\tx = x..\"\"\n\tshift = shift % #x\n\t\
    return x:sub(shift+1)..x:sub(1, shift)\nend", "    local rev_str = string.reverse(tostring(x))\n\
    \    local len = string.len(rev_str)\n    local len_right = len - shift", "  local\
    \ result = {}\n  for d in tostring(x):gmatch(\"%d\") do\n    local new_pos = shift\
    \ + tonumber(d)\n    if new_pos > #tostring(x) then\n      table.insert(result,\
    \ 1, tostring(new_pos - #tostring(x)))\n    else\n      table.insert(result, 1,\
    \ tostring(new_pos))\n    end\n  end\n  return table.concat(result)\nend", " \
    \   local str = tostring(x)\n    local rev = string.reverse(str)\n    local len\
    \ = #str\n    local str_end = string.sub(rev, 1, shift)\n    local str_start =\
    \ string.sub(rev, shift + 1, len)\n    local result = string.reverse(str_start\
    \ .. str_end)\n    return result\nend", "\tx = tostring(x)\n\tif shift > #x then\n\
    \t\treturn string.reverse(x)\n\tend\n\treturn string.sub(x, -shift) .. string.sub(x,\
    \ 1, -shift-1)\nend", "    local str = tostring(x)\n    local len = #str\n   \
    \ shift = shift % len\n    if shift == 0 then\n        return str\n    elseif\
    \ shift < 0 then\n        shift = len + shift\n    end\n    return str:sub(shift\
    \ + 1) .. str:sub(1, shift)\nend", "\tlocal str = tostring(x)\n\tif #str <= shift\
    \ then\n\t\tstr = reverse(str)\n\telse\n\t\tstr = sub(str, shift + 1) .. sub(str,\
    \ 1, shift)\n\tend\n\treturn str\nend", "    local digits = tostring(x)\n    local\
    \ result = string.reverse(digits)\n    for i = 1, shift do\n        local first\
    \ = string.sub(result,1,1)\n        result = string.sub(result,2) .. first\n \
    \   end\n    return result\nend", "    local x_str = tostring(x)\n    local s_str\
    \ = string.sub(x_str, shift + 1)\n    local s_str = string.sub(x_str, 1, shift)\n\
    \    return s_str .. s_str\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
