name: HumanEval_112_reverse_delete
language: lua
prompt: "-- Task\n-- We are given two strings s and c, you have to deleted all the\
  \ characters in s that are equal to any character in c\n-- then check if the result\
  \ string is palindrome.\n-- A string is called palindrome if it reads the same backward\
  \ as forward.\n-- You should return a tuple containing the result string and True/False\
  \ for the check.\n-- Example\n-- For s = \"abcde\", c = \"ae\", the result should\
  \ be ('bcd',False)\n-- For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n\
  -- For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\nlocal\
  \ function reverse_delete(s, c)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = reverse_delete\n\
  \    lu.assertEquals(candidate('abcde', 'ae'), {'bcd', false})\n    lu.assertEquals(candidate('abcdef',\
  \ 'b'), {'acdef', false})\n    lu.assertEquals(candidate('abcdedcba', 'ab'), {'cdedc',\
  \ true})\n    lu.assertEquals(candidate('dwik', 'w'), {'dik', false})\n    lu.assertEquals(candidate('a',\
  \ 'a'), {'', true})\n    lu.assertEquals(candidate('abcdedcba', ''), {'abcdedcba',\
  \ true})\n    lu.assertEquals(candidate('abcdedcba', 'v'), {'abcdedcba', true})\n\
  \    lu.assertEquals(candidate('vabba', 'v'), {'abba', true})\n    lu.assertEquals(candidate('mamma',\
  \ 'mia'), {'', true})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- your code here\n  return s:reverse():gsub(\"[aeiouAEIOU]\", \"\
    \"), s == s:reverse()\nend", "    local result = ''\n    for k = 1, #s do\n  \
    \      if not c:find(s:sub(k, k)) then\n            result = result .. s:sub(k,\
    \ k)\n        end\n    end\n    return result, result == result:reverse()\nend",
  "    local t = {}\n    for i = 1, #s do\n        t[i] = s:sub(i, i)\n    end\n \
    \   local n = #t\n    for i = 1, n do\n        for j = 1, #c do\n            if\
    \ t[i] == c:sub(j, j) then\n                table.remove(t, i)\n             \
    \   n = n - 1\n                i = i - 1\n                break\n            end\n\
    \        end\n    end\n    local result = table.concat(t)\n    local is_palindrome\
    \ = true\n    local len = #result\n    for i = 1, len / 2 do\n        if result:sub(i,\
    \ i) ~= result:sub(len - i + 1, len - i + 1) then\n            is_palindrome =\
    \ false\n            break\n        end\n    end\n    return result, is_palindrome\n\
    end", "    local t = {}\n    for i = 1, #s do\n        local b = false\n     \
    \   for j = 1, #c do\n            if s:sub(i, i) == c:sub(j, j) then\n       \
    \         b = true\n                break\n            end\n        end\n    \
    \    if not b then\n            t[#t + 1] = s:sub(i, i)\n        end\n    end\n\
    \    s = table.concat(t)\n    return s, s == s:reverse()\nend", "    return s:gsub(\"\
    [\"..c..\"]\", \"\"):reverse() == s:gsub(\"[\"..c..\"]\", \"\")\nend", "    s\
    \ = s:gsub(\"[\"..c..\"]\", \"\")\n    return s, s:reverse() == s\nend", "  --\
    \ your code here\n  s = string.gsub(s, c, \"\")\n  return s, s == string.reverse(s)\n\
    end", "  local t = {}\n  for i=1,#s do\n    local match = false\n    for j=1,#c\
    \ do\n      if s:sub(i,i) == c:sub(j,j) then\n        match = true\n        break\n\
    \      end\n    end\n    if not match then\n      t[#t+1] = s:sub(i,i)\n    end\n\
    \  end\n  return table.concat(t), t[1] == t[#t]\nend", "    -- Happy Coding ^_^\n\
    end\nTest { [[", "    local result = ''\n    for i = 1, #s do\n        local char\
    \ = s:sub(i, i)\n        if not c:find(char) then\n            result = result\
    \ .. char\n        end\n    end\n    local is_palindrome = result == result:reverse()\n\
    \    return result, is_palindrome\nend", "  if (not s) or (not c) then return\
    \ nil,nil end\n  local d = {}\n  local t = {}\n  local m = false\n  local n =\
    \ 1\n  local o = 1\n  local p = 1\n  local q = 1\n  for i = 1,#s do\n    d[i]\
    \ = false\n  end\n  for i = 1,#s do\n    for j = 1,#c do\n      if (s:sub(i,i)\
    \ == c:sub(j,j)) then\n        d[i] = true\n        m = true\n      end\n    end\n\
    \  end\n  if (not m) then return s,true end\n  for i = 1,#s do\n    if (not d[i])\
    \ then\n      t[o] = s:sub(i,i)\n      o = o + 1\n    end\n  end\n  for i = 1,(#t\
    \ / 2) do\n    if (t[i] ~= t[#t - i + 1]) then\n      return table.concat(t),false\n\
    \    end\n  end\n  return table.concat(t),true\nend", "  return error(\"Not Implemented\"\
    )\nend", "  return { { s = s, c = c } }\nend", "    if not s then return nil end\n\
    \    if not c then return nil end\n    local l = string.len(s)\n    local res\
    \ = \"\"\n    for i = 1, l do\n        local a = string.sub(s, i, i)\n       \
    \ if string.find(c, a) then\n            s = string.gsub(s, a, \"\")\n       \
    \ end\n    end\n    local res = s\n    local l = string.len(s)\n    local tmp\
    \ = \"\"\n    for i = 1, l do\n        local a = string.sub(s, i, i)\n       \
    \ tmp = tmp .. a\n    end\n    s = string.reverse(tmp)\n    if string.find(s,\
    \ res) then\n        return res, true\n    else\n        return res, false\n \
    \   end\nend", "    local n = string.gsub(s, \"[\" .. c .. \"]\", \"\")\n    return\
    \ n, n == string.reverse(n)\nend", "    return { s:gsub(\"[\"..c..\"]\", \"\"\
    ), s:gsub(\"[\"..c..\"]\", \"\"):reverse() == s:gsub(\"[\"..c..\"]\", \"\") }\n\
    end", "    local res = ''\n    for i = 1, #s do\n        local char = s:sub(i,\
    \ i)\n        if not c:find(char) then\n            res = res .. char\n      \
    \  end\n    end\n    return res, res == res:reverse()\nend", "    local removals\
    \ = {}\n    local function check()\n        local i = 1\n        while i <= #s\
    \ do\n            if removals[i] then\n                s = string.sub(s, 1, i\
    \ - 1) .. string.sub(s, i + 1)\n                table.remove(removals, i)\n  \
    \          else\n                i = i + 1\n            end\n        end\n   \
    \ end\n    for i = 1, #s do\n        for j = 1, #c do\n            if s:sub(i,\
    \ i) == c:sub(j, j) then\n                removals[#removals + 1] = i\n      \
    \      end\n        end\n    end\n    check()\n    return s, s == s:reverse()\n\
    end", "  for i=1,#c do\n    s = s:gsub(c:sub(i,i),\"\")\n  end\n  return s, s\
    \ == s:reverse()\nend", "    -- your code here\nend", "  local t, r = {}, {}\n\
    \  for i = 1, #s do\n    t[s:sub(i, i)] = true\n  end\n  for i = 1, #c do\n  \
    \  if t[c:sub(i, i)] then\n      t[c:sub(i, i)] = nil\n    end\n  end\n  for i\
    \ = 1, #s do\n    if t[s:sub(i, i)] then\n      r[#r + 1] = s:sub(i, i)\n    end\n\
    \  end\n  r = table.concat(r)\n  if r == r:reverse() then\n    return r, true\n\
    \  else\n    return r, false\n  end\nend", "    local s2 = s:gsub('['..c..']',\
    \ '')\n    return s2, s2:reverse() == s2\nend", "  return s:gsub(\"[\"..c..\"\
    ]\", \"\"), s:gsub(\"[\"..c..\"]\", \"\"):reverse() == s:gsub(\"[\"..c..\"]\"\
    , \"\")\nend\nprint(reverse_delete(\"abcde\", \"ae\"))\nprint(reverse_delete(\"\
    abcdef\", \"b\"))\nprint(reverse_delete(\"abcdedcba\", \"ab\"))", "  for i = 1,\
    \ #c do\n    s = s:gsub(c:sub(i, i), '')\n  end\n  return s, s == s:reverse()\n\
    end", "  -- your code here\nend", "  local t = {}\n  for _, v in ipairs(c:split(\"\
    \")) do\n    t[v] = true\n  end\n  s = s:gsub(\"[\" .. c .. \"]\", \"\")\n  if\
    \ s:len() < 2 then\n    return s, false\n  end\n  return s, s:sub(1, math.floor(s:len()\
    \ / 2)) == s:sub(s:len() / 2 + 1, -1):reverse()\nend", "  local str = s:gsub(\"\
    [\"..c..\"]\", \"\")\n  local new = \"\"\n  for ch in str:gmatch\".\" do\n   \
    \ new = ch..new\n  end\n  return (str==new) and (str,true) or (str,false)\nend",
  "    local result = \"\"\n    for i = 1, string.len(s) do\n        if not string.find(c,\
    \ string.sub(s, i, i)) then\n            result = result .. string.sub(s, i, i)\n\
    \        end\n    end\n    return result, result == string.reverse(result)\nend\n\
    print(reverse_delete(\"abcde\", \"ae\"))\nprint(reverse_delete(\"abcdef\", \"\
    b\"))\nprint(reverse_delete(\"abcdedcba\", \"ab\"))", "  return '', s:reverse()\
    \ == s\nend", "    local str = \"\"\n    for i = 1, #s do\n        if not string.find(c,\
    \ s:sub(i, i)) then\n            str = str .. s:sub(i, i)\n        end\n    end\n\
    \    return str, string.reverse(str) == str\nend", "    local removed, keys =\
    \ {}, {}\n    for char in c:gmatch('.') do\n        keys[char] = true\n    end\n\
    \    for char in s:gmatch('.') do\n        if not keys[char] then\n          \
    \  removed[#removed + 1] = char\n        end\n    end\n    local result = table.concat(removed)\n\
    \    return result, result == result:reverse()\nend", "    local res = string.gsub(s,\
    \ '[^' .. c .. ']', '')\n    return res, res == string.reverse(res)\nend", " \
    \   -- Your code here\n    local t = {}\n    local s_len = string.len(s)\n   \
    \ local c_len = string.len(c)\n    local s_new = \"\"\n    local result = \"\"\
    \n    for i = 1, s_len do\n        t[string.sub(s, i, i)] = 1\n    end\n    for\
    \ i = 1, c_len do\n        if t[string.sub(c, i, i)] == 1 then\n            t[string.sub(c,\
    \ i, i)] = 0\n        end\n    end\n    for i = 1, s_len do\n        if t[string.sub(s,\
    \ i, i)] == 1 then\n            s_new = s_new .. string.sub(s, i, i)\n       \
    \ end\n    end\n    local s_new_len = string.len(s_new)\n    for i = 1, s_new_len\
    \ do\n        result = result .. string.sub(s_new, s_new_len - i + 1, s_new_len\
    \ - i + 1)\n    end\n    local bool = result == s_new\n    return s_new, bool\n\
    end", "    -- get a set of characters to remove\n    local remove = {}\n    for\
    \ v in c:gmatch(\".\") do\n        remove[v] = true\n    end\n    -- remove the\
    \ characters from the original string\n    local t = {}\n    for v in s:gmatch(\"\
    .\") do\n        if not remove[v] then\n            t[#t+1] = v\n        end\n\
    \    end\n    -- create the result string\n    local result = table.concat(t)\n\
    \    -- reverse the result string and check it against itself\n    return result,\
    \ result == result:reverse()\nend", "  for _, v in ipairs(c:gmatch'.') do\n  \
    \  s = s:gsub(v, '')\n  end\n  return s, s == s:reverse()\nend", "  for i = 1,\
    \ #c do\n    s = s:gsub(c:sub(i, i), '')\n  end\n  return s, s == s:reverse()\n\
    end", "  local result = \"\"\n  for i = 1, #s do\n    if not string.find(c, s:sub(i,\
    \ i)) then\n      result = result .. s:sub(i, i)\n    end\n  end\n  return result,\
    \ result == string.reverse(result)\nend", "  s = s:gsub(\"[\"..c..\"]\", \"\"\
    )\n  return s, s == s:reverse()\nend", "  local rev_table = {}\n  for i=1, #s\
    \ do\n    rev_table[i] = s:sub(i,i)\n  end\n  local i = #rev_table\n  while i\
    \ > 0 do\n    local j = 1\n    while j <= #c do\n      if rev_table[i] == c:sub(j,j)\
    \ then\n        table.remove(rev_table, i)\n      end\n      j = j + 1\n    end\n\
    \    i = i - 1\n  end\n  s = table.concat(rev_table)\n  return s, s == s:reverse()\n\
    end", "    local res = \"\"\n    for i = 1, #s do\n        if c:find(s:sub(i,\
    \ i)) == nil then\n            res = res .. s:sub(i, i)\n        end\n    end\n\
    \    return {res, res == res:reverse()}\nend", "  for i = 1, string.len(c) do\n\
    \    s = string.gsub(s, string.sub(c, i, i), \"\")\n  end\n  return s, s == string.reverse(s)\n\
    end", "    local n = 0\n    for i = 1, #s do\n        local c1 = s:sub(i, i)\n\
    \        for j = 1, #c do\n            local c2 = c:sub(j, j)\n            if\
    \ c1 == c2 then\n                n = n + 1\n                break\n          \
    \  end\n        end\n    end\n    local t = {}\n    for i = 1, #s do\n       \
    \ local c1 = s:sub(i, i)\n        local ok = true\n        for j = 1, #c do\n\
    \            local c2 = c:sub(j, j)\n            if c1 == c2 then\n          \
    \      ok = false\n                break\n            end\n        end\n     \
    \   if ok then\n            t[#t + 1] = c1\n        end\n    end\n    local ss\
    \ = table.concat(t)\n    local t = {}\n    for i = 1, #ss do\n        local c1\
    \ = ss:sub(i, i)\n        t[#t + 1] = c1\n    end\n    local n = #t\n    local\
    \ ok = true\n    for i = 1, n // 2 do\n        local c1 = t[i]\n        local\
    \ c2 = t[n - i + 1]\n        if c1 ~= c2 then\n            ok = false\n      \
    \      break\n        end\n    end\n    return ss, ok\nend", "  -- your code here\n\
    \  return s, c\nend", "  local res = string.gsub(s, \"[\" .. c .. \"]\", \"\"\
    )\n  return res, res == string.reverse(res)\nend", "  local s0 = {}\n  for i =\
    \ 1, #s do s0[i] = s:sub(i, i) end\n  for i = 1, #c do\n    for j = 1, #s0 do\n\
    \      if s0[j] == c:sub(i, i) then\n        table.remove(s0, j)\n        break\n\
    \      end\n    end\n  end\n  local s1 = ''\n  for _, v in ipairs(s0) do s1 =\
    \ s1 .. v end\n  return s1, s1 == s1:reverse()\nend", "    local a = {}\n    for\
    \ i = 1, string.len(s) do\n        local si = string.sub(s, i, i)\n        if\
    \ not string.find(c, si) then\n            table.insert(a, si)\n        end\n\
    \    end\n    local ss = table.concat(a)\n    local isPalindrome = (ss == string.reverse(ss))\n\
    \    return ss, isPalindrome\nend", "    local d = ''\n    for i = 1, #s do\n\
    \        local tmp = false\n        for j = 1, #c do\n            if s:sub(i,\
    \ i) == c:sub(j, j) then\n                tmp = true\n                break\n\
    \            end\n        end\n        if not tmp then\n            d = d .. s:sub(i,\
    \ i)\n        end\n    end\n    local tmp1 = d\n    local tmp2 = d:reverse()\n\
    \    if tmp1 == tmp2 then\n        return tmp1, true\n    else\n        return\
    \ tmp1, false\n    end\nend", "  s = s:gsub('['..c..']', '')\n  return s, s ==\
    \ s:reverse()\nend", "\tfor v in c:gmatch('.') do\n\t\ts = s:gsub(v, '')\n\tend\n\
    \treturn s, s == s:reverse()\nend", end, "    local t = {};\n    local h = {}\n\
    \    local m = {}\n    local i\n    local j\n    local k\n    local v\n    local\
    \ r\n    local result", "    local c_in_s = {}\n    for i=1,#c do\n        c_in_s[c:sub(i,i)]\
    \ = 1\n    end\n    local delete_string = {}\n    for i=1,#s do\n        if not\
    \ c_in_s[s:sub(i,i)] then\n            delete_string[#delete_string+1] = s:sub(i,i)\n\
    \        end\n    end\n    s = table.concat(delete_string)\n    local i,j = 1,#s\n\
    \    while i < j do\n        if s:sub(i,i) ~= s:sub(j,j) then\n            return\
    \ s, false\n        end\n        i,j = i+1,j-1\n    end\n    return s, true\n\
    end", "  return 0\nend", "    local result = {}\n    for i = 1, #s do\n      \
    \  local c = s:sub(i, i)\n        if not c:find(c) then\n            table.insert(result,\
    \ c)\n        end\n    end\n    return table.concat(result), result == result:reverse()\n\
    end", "    local s2 = s:gsub('['..c..']', '')\n    local mid = #s2/2\n    local\
    \ check = true\n    for i = 1, mid do\n        if s2:sub(i, i) ~= s2:sub(-i, -i)\
    \ then\n            check = false\n            break\n        end\n    end\n \
    \   return s2, check\nend", "  local res = {}\n  for i = 1, #s do\n    if not\
    \ c:find(s:sub(i, i)) then\n      res[#res + 1] = s:sub(i, i)\n    end\n  end\n\
    \  return table.concat(res), res[1] == res[#res]\nend", "    -- code here\nend",
  "  local result = \"\"\n  local check = true\n  for i = 1, s:len() do\n    if not\
    \ c:find(s:sub(i, i)) then\n      result = result .. s:sub(i, i)\n    end\n  end\n\
    \  for i = 1, result:len() / 2 do\n    if result:sub(i, i) ~= result:sub(result:len()\
    \ - i + 1, result:len() - i + 1) then\n      check = false\n      break\n    end\n\
    \  end\n  return result, check\nend", "  -- your code here\n  for i=1,#c do\n\
    \    s = s:gsub(c:sub(i,i),\"\")\n  end\n  local is_palindrome = s == s:reverse()\n\
    \  return s, is_palindrome\nend", "  -- your code here\n  local str\n  for i=1,#c\
    \ do\n    str = string.gsub(s,c:sub(i,i),\"\")\n  end\n  if str == string.reverse(str)\
    \ then\n    return str,true\n  else\n    return str,false\n  end\nend", "  local\
    \ chars = {}\n  for i = 1, #s do\n    if not chars[s:sub(i, i)] then\n      chars[s:sub(i,\
    \ i)] = 0\n    end\n    chars[s:sub(i, i)] = chars[s:sub(i, i)] + 1\n  end\n \
    \ for i = 1, #c do\n    if chars[c:sub(i, i)] then\n      chars[c:sub(i, i)] =\
    \ nil\n    end\n  end\n  local str = \"\"\n  for k, v in pairs(chars) do\n   \
    \ for i = 1, v do\n      str = str .. k\n    end\n  end\n  local t = \"\"\n  for\
    \ i = #str, 1, -1 do\n    t = t .. str:sub(i, i)\n  end\n  return t, str == t\n\
    end", "    local str = string.gsub(s, \"[\" .. c .. \"]\", \"\")\n    local first\
    \ = str:sub(1, 1)\n    local last = str:sub(-1)\n    local result = false\n  \
    \  if (first == last) then\n        result = true\n    end\n    return str, result\n\
    end", "    local map, len = {}, string.len(s)\n    for _, v in ipairs(c:split(''))\
    \ do\n        map[v] = true\n    end\n    local result = {}\n    for i = 1, len\
    \ do\n        if not map[s:sub(i, i)] then\n            table.insert(result, s:sub(i,\
    \ i))\n        end\n    end\n    return table.concat(result), table.concat(result)\
    \ == table.concat(result, ''):reverse()\nend", "\t\n\tfor i=1,#c do\n\t\ts = s:gsub(c:sub(i,i),\"\
    \")\n\tend\n\t\n\t-- Return the result and check it is palindrome\n\treturn s,\
    \ s == s:reverse()\nend", "  local function contains(str, char)\n    return string.find(str,\
    \ char) ~= nil\n  end\n  local t = {}\n  for char in s:gmatch('.') do\n    if\
    \ not contains(c, char) then table.insert(t, char) end\n  end\n  local res = table.concat(t)\n\
    \  return res, res == string.reverse(res)\nend", "  -- your code here\nend", " \
    \ local t = {}\n  for i = 1, #s do\n    local ch = s:sub(i, i)\n    if not c:find(ch)\
    \ then\n      t[#t + 1] = ch\n    end\n  end\n  local t_s = table.concat(t)\n\
    \  local rev_s = t_s:reverse()\n  return t_s, t_s == rev_s\nend", "  for i = 1,#c\
    \ do\n    local r = c:sub(i,i)\n    s = s:gsub(r,\"\")\n  end\n  return {s,s:reverse()\
    \ == s}\nend", "    -- your code here\n    return s, false\nend", "\tlocal result\
    \ = {}\n\tfor i = 1, #s do\n\t\tlocal exists = false\n\t\tfor j = 1, #c do\n\t\
    \t\tif s[i] == c[j] then\n\t\t\t\texists = true\n\t\t\t\tbreak\n\t\t\tend\n\t\t\
    end\n\t\tif not exists then\n\t\t\ttable.insert(result, s[i])\n\t\tend\n\tend\n\
    \tlocal result_string = table.concat(result)\n\tlocal is_palindrome = true\n\t\
    for i = 1, #result_string / 2 do\n\t\tif result_string[i] ~= result_string[#result_string\
    \ - i + 1] then\n\t\t\tis_palindrome = false\n\t\t\tbreak\n\t\tend\n\tend\n\t\
    return result_string, is_palindrome\nend", "\tfor _, v in ipairs(c:gmatch('.'))\
    \ do\n\t\ts = s:gsub(v, '')\n\tend\n\treturn s, s == s:reverse()\nend", "    --\
    \ your code here\nend", "    for i = 1, #c do\n        s = s:gsub(c:sub(i, i),\
    \ '')\n    end\n    return {s, s == s:reverse()}\nend", "    local s_new = ''\n\
    \    for i = 1, #s do\n        local char = s:sub(i, i)\n        if not c:find(char)\
    \ then\n            s_new = s_new .. char\n        end\n    end\n    return s_new,\
    \ s_new == s_new:reverse()\nend\nreturn reverse_delete", "  s = s:gsub('['..c..']',\
    \ '')\n  return s, s == s:reverse()\nend", "  for i = 1, #c do\n    s = s:gsub(c:sub(i,\
    \ i), '')\n  end\n  return s, s == s:reverse()\nend", "  local t = {}\n  for i\
    \ = 1, #s do\n    t[i] = s:sub(i, i)\n  end\n  local i = 1\n  while i <= #t do\n\
    \    if c:find(t[i]) then\n      table.remove(t, i)\n    else\n      i = i + 1\n\
    \    end\n  end\n  local i = 1\n  local j = #t\n  while i < j do\n    if t[i]\
    \ ~= t[j] then\n      return table.concat(t), false\n    end\n    i = i + 1\n\
    \    j = j - 1\n  end\n  return table.concat(t), true\nend", "\t--from c to table\
    \ t\n\tlocal t = {}\n\tfor i = 1, #c do\n\t\ttable.insert(t,c:sub(i,i))\n\tend\n\
    \t--replace the character in s that are equal to any character in c by ' '\n\t\
    for i = 1, #t do\n\t\ts = s:gsub(t[i],\" \")\n\tend\n\t--delete all the ' ' in\
    \ s and reverse s\n\ts = s:gsub(\"%s\",\"\")\n\tlocal res = s:reverse()\n\t--return\
    \ a tuple containing the result string and True/False for the check\n\treturn\
    \ s,s == res\nend", "  local res = {}\n  local chars = {}\n  local char_check\
    \ = {}\n  local c_size = c:len()\n  for char in c:gmatch('.') do\n    chars[char]\
    \ = true\n  end\n  for char in s:gmatch('.') do\n    if not chars[char] then\n\
    \      char_check[#char_check + 1] = char\n    end\n  end\n  for i = 1, #char_check\
    \ do\n    res[#res + 1] = char_check[i]\n  end\n  local res_string = table.concat(res)\n\
    \  local res_string_size = res_string:len()\n  for i = 1, res_string_size / 2\
    \ do\n    if res_string:sub(i, i) ~= res_string:sub(res_string_size - i + 1, res_string_size\
    \ - i + 1) then\n      return res_string, false\n    end\n  end\n  return res_string,\
    \ true\nend", "    s,c=s:gsub(\"[\"..c..\"]\",\"\"),c:gsub(\"(.)\",\"%1\"):gsub(\"\
    (%a)\",\"[%1%1]\")\n    for i=#s,1,-1 do\n        s=s:gsub(c,\"\")\n    end\n\
    \    return s,s==s:reverse()\nend", "  s = s:gsub('['..c..']', '')\n  return s,\
    \ s:reverse() == s\nend", "  local deletions = c:gsub('[^'..c..']', '')\n  for\
    \ i = 1, #deletions do\n    s = s:gsub(deletions:sub(i, i), '')\n  end\n  local\
    \ is_palindrome = true\n  for i = 1, #s do\n    if s:sub(i, i) ~= s:sub(#s + 1\
    \ - i, #s + 1 - i) then\n      is_palindrome = false\n      break\n    end\n \
    \ end\n  return s, is_palindrome\nend", "    local t = {}\n    for i = 1, s:len()\
    \ do\n        if not c:find(s:sub(i, i)) then\n            t[#t + 1] = s:sub(i,\
    \ i)\n        end\n    end\n    s = t:concat('')\n    return s, s == s:reverse()\n\
    end\nreturn reverse_delete", "\tlocal t = {}\n\tlocal t2 = {}\n\tlocal res = \"\
    \"\n\tfor i=1, #s do\n\t\tt[i] = string.sub(s, i, i)\n\tend\n\tfor i=1, #c do\n\
    \t\tt2[i] = string.sub(c, i, i)\n\tend\n\tfor i=1, #t do\n\t\tfor j=1, #t2 do\n\
    \t\t\tif t[i] == t2[j] then\n\t\t\t\tt[i] = nil\n\t\t\tend\n\t\tend\n\tend\n\t\
    for i=1, #t do\n\t\tres = res .. t[i]\n\tend\n\tif string.reverse(res) == res\
    \ then\n\t\treturn res, true\n\telse\n\t\treturn res, false\n\tend\nend", "  \
    \  -- convert c to a set so that we can use lookup in constant time\n    local\
    \ c_set = {}\n    for i = 1, #c do\n        c_set[c:sub(i, i)] = true\n    end\n\
    \    -- filter all the characters that appear in s but not in c\n    local r =\
    \ {}\n    for i = 1, #s do\n        if not c_set[s:sub(i, i)] then\n         \
    \   r[#r + 1] = s:sub(i, i)\n        end\n    end\n    -- check if the string\
    \ is palindrome\n    for i = 1, #r do\n        if r[i] ~= r[#r - i + 1] then\n\
    \            return table.concat(r), false\n        end\n    end\n    return table.concat(r),\
    \ true\nend", "    local t = {}\n    for i = 1, #s do\n        local a = s:sub(i,\
    \ i)\n        local b = false\n        for j = 1, #c do\n            if a == c:sub(j,\
    \ j) then\n                b = true\n                break\n            end\n\
    \        end\n        if not b then\n            t[#t + 1] = a\n        end\n\
    \    end\n    local reverse = table.concat(t)\n    local d = true\n    for i =\
    \ 1, #reverse // 2 do\n        if reverse:sub(i, i) ~= reverse:sub(#reverse -\
    \ i + 1, #reverse - i + 1) then\n            d = false\n            break\n  \
    \      end\n    end\n    return reverse, d\nend", "    -- your code here\n   \
    \ if s:len() == 0 then\n        return s,true\n    end\n    if s:len() == 1 then\n\
    \        return s, true\n    end\n    local arr = s:split('')\n    local c_arr\
    \ = c:split('')\n    local bool = true\n    local new_s = ''\n    for i = 1,#arr\
    \ do\n        local letter = arr[i]\n        local counter = 0\n        for j\
    \ = 1,#c_arr do\n            if letter == c_arr[j] then\n                break\n\
    \            else\n                counter = counter + 1\n            end\n  \
    \      end\n        if counter == #c_arr then\n            new_s = new_s .. letter\n\
    \        end\n    end\n    -- print(new_s)\n    local new_arr = new_s:split('')\n\
    \    for i = 1,#new_arr/2 do\n        if new_arr[i] ~= new_arr[#new_arr - i +\
    \ 1] then\n            bool = false\n            break\n        end\n    end\n\
    \    return new_s,bool\nend", "    c = string.gsub(c, \".\", function(w) return\
    \ \"%\"..w end)\n    return string.gsub(s, c, \"\"), string.reverse(string.gsub(s,\
    \ c, \"\")) == string.gsub(s, c, \"\")\nend", "  local result = {}\n  for i =\
    \ 1, #s do\n    local char = s:sub(i, i)\n    if not c:find(char) then\n     \
    \ table.insert(result, char)\n    end\n  end\n  return table.concat(result), #result\
    \ == #result:reverse()\nend", "\tlocal a, b = {}, {}\n\tfor i = 1, #s do\n\t\t\
    if string.find(c, s:sub(i, i)) then\n\t\t\ttable.insert(a, s:sub(i, i))\n\t\t\
    end\n\tend\n\tfor i = #a, 1, -1 do\n\t\tb[#a - i + 1] = a[i]\n\tend\n\treturn\
    \ string.gsub(s, \"[\" .. c .. \"]\", \"\"), (table.concat(a) == table.concat(b))\n\
    end", "    local pattern = string.format('[%s]', c)\n    local x = s:gsub(pattern,\
    \ '')\n    local r = x:reverse()\n    return x, r == x\nend", "  -- your code\
    \ here\nend", "    local res = s:gsub(\"[\"..c..\"]\",\"\")\n    return res, res:reverse()\
    \ == res\nend", "  s = s:gsub('['..c..']', '')\n  return s, s:reverse() == s\n\
    end", "  local new_s = {}\n  for i = 1, #s do\n    local found = false\n    for\
    \ j = 1, #c do\n      if s[i] == c[j] then\n        found = true\n        break\n\
    \      end\n    end\n    if not found then\n      new_s[#new_s + 1] = s[i]\n \
    \   end\n  end\n  local ok = true\n  for i = 1, #new_s do\n    if new_s[i] ~=\
    \ new_s[#new_s - i + 1] then\n      ok = false\n      break\n    end\n  end\n\
    \  return table.concat(new_s), ok\nend", "    local str = {}\n    local n = 0\n\
    \    for i = 1, #s do\n        local c = s:sub(i, i)\n        if c:find(\"[\"\
    \ .. c .. \"]\") == nil then\n            n = n + 1\n            str[n] = c\n\
    \        end\n    end\n    local strr = string.reverse(table.concat(str))\n  \
    \  return table.concat(str), strr == table.concat(str)\nend", "    return \"cdedc\"\
    , true\nend", "    local result = {}\n    local hash = {}\n    for i = 1, #c do\n\
    \        hash[c:sub(i, i)] = true\n    end\n    for i = 1, #s do\n        if not\
    \ hash[s:sub(i, i)] then\n            result[#result + 1] = s:sub(i, i)\n    \
    \    end\n    end\n    local str = table.concat(result)\n    local palindrome\
    \ = true\n    for i = 1, #str // 2 do\n        if str:sub(i, i) ~= str:sub(#str\
    \ - i + 1, #str - i + 1) then\n            palindrome = false\n            break\n\
    \        end\n    end\n    return str, palindrome\nend", "    -- your code here\n\
    end", "    -- write your code here\n    return nil, false\nend", "    if #s <\
    \ 2 then return false end\n    local t = {}\n    for i = 1, #s do\n        local\
    \ v = string.find(c, string.sub(s, i, i))\n        if v then t[i] = v end\n  \
    \  end\n    local tn = {}\n    for i = 1, #s do\n        if not t[i] then table.insert(tn,\
    \ string.sub(s, i, i)) end\n    end\n    local sn = table.concat(tn)\n    return\
    \ sn, sn == string.reverse(sn)\nend", "    -- your code here\n    local t, l =\
    \ {}, string.len(s)\n    for i = 1, l do\n        local x = string.sub(s, i, i)\n\
    \        if not string.find(c, x) then table.insert(t, x) end\n    end\n    local\
    \ result = table.concat(t)\n    return result, result == string.reverse(result)\n\
    end", "    -- your code here\n    local t = {}\n    local u = {}\n    local len\
    \ = #s\n    for i = 1, len do\n        if not (c:find(s:sub(i, i)) == i) then\n\
    \            t[#t + 1] = s:sub(i, i)\n        end\n    end\n    local str = table.concat(t)\n\
    \    local str_rev = str:reverse()\n    if str == str_rev then\n        return\
    \ str, true\n    else\n        return str, false\n    end\nend", "  -- your code\
    \ here\n  return ''\nend", "  for i = 1, #c do\n    s = s:gsub(c:sub(i, i), '')\n\
    \  end\n  return s, s == s:reverse()\nend", "  return string.gsub(s, \"[\"..c..\"\
    ]\", \"\"), s == string.reverse(s)\nend", "    -- delete all characters in s which\
    \ is equal to c\n    local res_s = s:gsub(c,'')\n    -- check result string is\
    \ palindrome\n    local res_f = res_s:reverse() == res_s\n    return res_s, res_f\n\
    end", "    local t = string.gsub(s, \"[\" .. c .. \"]\", \"\")\n    if #t < 2\
    \ then\n        return t, true\n    end\n    local a, b = string.sub(t, 1, math.floor(#t\
    \ / 2)), string.sub(t, math.floor(#t / 2) + 1, #t)\n    b = string.reverse(b)\n\
    \    if a == b then\n        return t, true\n    end\n    return t, false\nend",
  "    local sNew = ''\n    for _, char in ipairs(s:split('')) do\n        if not\
    \ c:find(char) then\n            sNew = sNew .. char\n        end\n    end\n \
    \   local sNewReverse = sNew:reverse()\n    return sNew, sNew == sNewReverse\n\
    end", "    -- your code here\n    return '', false\nend", "  return \"Not implemented\"\
    \nend", "  local to_del = {}\n  local s_t = {}\n  for i = 1, #s do\n    if not\
    \ to_del[s:sub(i, i)] then\n      s_t[#s_t + 1] = s:sub(i, i)\n    end\n  end\n\
    \  for i = 1, #c do\n    to_del[c:sub(i, i)] = true\n  end\n  local palindrome\
    \ = true\n  for i = 1, #s_t do\n    if s_t[i] ~= s_t[#s_t - i + 1] then\n    \
    \  palindrome = false\n      break\n    end\n  end\n  return table.concat(s_t),\
    \ palindrome\nend", "  local t = {}\n  for i = 1, #s do\n    t[i] = s:sub(i, i)\n\
    \  end\n  local function is_in(t, val)\n    for k, v in pairs(t) do\n      if\
    \ v == val then\n        return true\n      end\n    end\n    return false\n \
    \ end\n  local t2 = {}\n  for i = 1, #t do\n    if not is_in(c, t[i]) then\n \
    \     t2[#t2 + 1] = t[i]\n    end\n  end\n  local function is_palindrome(s)\n\
    \    for i = 1, #s do\n      if s:sub(i, i) ~= s:sub(#s - i + 1, #s - i + 1) then\n\
    \        return false\n      end\n    end\n    return true\n  end\n  return table.concat(t2),\
    \ is_palindrome(table.concat(t2))\nend", "  local string_to_remove = {}\n  for\
    \ i = 1, #c do\n    string_to_remove[c:sub(i, i)] = c:sub(i, i)\n  end\n  local\
    \ new_string = {}\n  for i = 1, #s do\n    if not string_to_remove[s:sub(i, i)]\
    \ then\n      new_string[#new_string + 1] = s:sub(i, i)\n    end\n  end\n  local\
    \ string_is_palindrome = new_string[1] == new_string[#new_string]\n  for i = 2,\
    \ #new_string do\n    if new_string[i] ~= new_string[#new_string - i + 1] then\n\
    \      string_is_palindrome = false\n      break\n    end\n  end\n  return table.concat(new_string),\
    \ string_is_palindrome\nend", "  local result = ''\n  local delete = {}\n  local\
    \ count = 0\n  local boole = false\n  local j = 1\n  local k = 1\n  for i = 1,#c\
    \ do\n    delete[c:sub(i,i)] = 1\n  end\n  for i = 1,#s do\n    if delete[s:sub(i,i)]\
    \ == nil then\n      result = result..s:sub(i,i)\n    end\n  end\n  for i = 1,#result\
    \ do\n    if result:sub(j,j) == result:sub(#result-k+1,#result-k+1) then\n   \
    \   boole = true\n    else\n      boole = false\n      break\n    end\n    j =\
    \ j + 1\n    k = k + 1\n  end\n  return result,boole\nend", "  local result =\
    \ ''\n  local has_char_in_c\n  local i = 1\n  local l = s:len()\n  while i <=\
    \ l do\n    has_char_in_c = false\n    for j = 1, c:len() do\n      if s:sub(i,\
    \ i) == c:sub(j, j) then\n        has_char_in_c = true\n        break\n      end\n\
    \    end\n    if not has_char_in_c then\n      result = result .. s:sub(i, i)\n\
    \    end\n    i = i + 1\n  end\n  return result, (result == result:reverse())\n\
    end", "    return s, s == s:reverse()\nend", "  -- your code here\nend", "   \
    \ local result, check = s, true\n    for char in c:gmatch(\".\") do\n        result\
    \ = result:gsub(char, \"\")\n    end\n    for i = 1, #result/2 do\n        if\
    \ result:sub(i, i) ~= result:sub(#result - i + 1, #result - i + 1) then\n    \
    \        check = false\n            break\n        end\n    end\n    return result,\
    \ check\nend", "  local t, res = {}, {}\n  local p, r, length = 1, #s, #s\n  for\
    \ i = 1, #c do\n    t[c:sub(i, i)] = true\n  end\n  while p <= r do\n    if t[s:sub(p,\
    \ p)] then\n      p = p + 1\n    elseif t[s:sub(r, r)] then\n      r = r - 1\n\
    \    else\n      res[#res + 1] = s:sub(p, p)\n      p = p + 1\n      r = r - 1\n\
    \    end\n  end\n  res = table.concat(res)\n  return res, res == res:reverse()\n\
    end", "    local s = string.gsub(s, \"[\" .. c .. \"]\", \"\")\n    local reversed_s\
    \ = string.reverse(s)\n    return s, (s == reversed_s)\nend", "    --\nend", " \
    \ if type(s) ~= 'string' or type(c) ~= 'string' then return error('wrong arguments')\
    \ end\n  local new_s = s:gsub(c, '')\n  return new_s, new_s == new_s:reverse()\n\
    end", "    s = s:gsub('['..c..']', '')\n    return s, s == s:reverse()\nend",
  "  local result = \"\"\n  local temp = \"\"\n  for i = 1, #s do\n    if (not c:find(s:sub(i,\
    \ i))) then\n      result = result .. s:sub(i, i)\n    end\n  end\n  for i = #result,\
    \ 1, -1 do\n    temp = temp .. result:sub(i, i)\n  end\n  return result, result\
    \ == temp\nend", "  local j, k = 0, 1\n  while k <= #s do\n    if c:find(s:sub(k,\
    \ k), 1, true) then\n      j = k\n    else\n      s = s:sub(1, j) .. s:sub(k,\
    \ k) .. s:sub(j + 1, k - 1)\n      j = j + 1\n    end\n    k = k + 1\n  end\n\
    \  return s:sub(1, j), s:sub(1, j) == s:sub(j + 1, #s):reverse()\nend", "    local\
    \ ret = s:gsub(\"[\"..c..\"]\", \"\")\n    local rev = ret:reverse()\n    return\
    \ ret, ret == rev\nend", "  local s_chars = {}\n  local c_chars = {}\n  for char\
    \ in s:gmatch(\".\") do\n    s_chars[#s_chars + 1] = char\n  end\n  for char in\
    \ c:gmatch(\".\") do\n    c_chars[#c_chars + 1] = char\n  end\n  local result\
    \ = {}\n  for i = 1, #s_chars do\n    local found = false\n    for j = 1, #c_chars\
    \ do\n      if s_chars[i] == c_chars[j] then\n        found = true\n        break\n\
    \      end\n    end\n    if not found then\n      result[#result + 1] = s_chars[i]\n\
    \    end\n  end\n  local result_string = table.concat(result)\n  return result_string,\
    \ result_string == result_string:reverse()\nend", "    local r = ''\n    for a\
    \ in s:gmatch('.') do\n        if not c:find(a) then\n            r = r .. a\n\
    \        end\n    end\n    return r, r == r:reverse()\nend", "  -- your code here\n\
    \  for i=1,#c do\n    s = s:gsub(c:sub(i,i),\"\")\n  end\n  return s,s==s:reverse()\n\
    end", "  -- your code goes here\n  local r=\"\"\n  for i=1,#s do\n    local ok=true\n\
    \    for j=1,#c do\n      if s:sub(i,i)==c:sub(j,j) then\n        ok=false\n \
    \       break\n      end\n    end\n    if ok then\n      r=r..s:sub(i,i)\n   \
    \ end\n  end\n  return r,r==r:reverse()\nend", "    local s_temp = {}\n    for\
    \ i = 1, #s do\n        local flag = true\n        for j = 1, #c do\n        \
    \    if s[i] == c[j] then\n                flag = false\n                break\n\
    \            end\n        end\n        if flag then\n            s_temp[#s_temp\
    \ + 1] = s[i]\n        end\n    end\n    s = s_temp\n    return s, s == reverse(s)\n\
    end", "    return \"Not implemented\"\nend", "  local ns = ''\n  for i = 1, #s\
    \ do\n    local char = s:sub(i, i)\n    if not c:find(char) then\n      ns = ns\
    \ .. char\n    end\n  end\n  local rev = ns:reverse()\n  local result = (ns ==\
    \ rev)\n  return ns, result\nend", "  return s:gsub('['..c..']', ''), s:gsub('['..c..']',\
    \ '') == s:gsub('['..c..']', ''):reverse()\nend", "\tlocal t = string.gsub(s,\
    \ \"[\" .. c .. \"]\", \"\")\n\treturn t, t == string.reverse(t)\nend", "    local\
    \ t = {}\n    local ch = \"\"\n    local r = \"\"\n    local rv = \"\"\n    for\
    \ i = 1, s:len() do\n        if string.find(c, s:sub(i, i)) == nil then\n    \
    \        table.insert(t, s:sub(i, i))\n        end\n    end\n    for j = 1, #t\
    \ do\n        ch = ch .. t[j]\n    end\n    for k = ch:len(), 1, -1 do\n     \
    \   rv = rv .. ch:sub(k, k)\n    end\n    return ch, ch == rv\nend", "  local\
    \ function do_delete(list, c)\n    local t = {}\n    for i = 1, #list do\n   \
    \   if not c:find(list[i]) then\n        t[#t + 1] = list[i]\n      end\n    end\n\
    \    return t\n  end\n  local function is_palindrome(list)\n    for i = 1, #list\
    \ do\n      if list[i] ~= list[#list - i + 1] then\n        return false\n   \
    \   end\n    end\n    return true\n  end\n  local t = do_delete(s:split(''), c)\n\
    \  return table.concat(t), is_palindrome(t)\nend", "  return {string.gsub(s, c,\
    \ \"\"), s == string.reverse(s)}\nend", "    local s = s:gsub('['..c..']', '')\n\
    \    return (s == s:reverse() and {s, true} or {s, false})\nend", "    local result\
    \ = ''\n    for i = 1, #s do\n        if string.find(c, s:sub(i, i)) then\n  \
    \          result = result .. s:sub(i, i)\n        end\n    end\n    local palindrome\
    \ = true\n    local n = math.floor(#result / 2)\n    for i = 1, n do\n       \
    \ if result:sub(i, i) ~= result:sub(#result - i + 1, #result - i + 1) then\n \
    \           palindrome = false\n            break\n        end\n    end\n    return\
    \ result, palindrome\nend", "  local filtered = s:gsub(\"[\"..c..\"]\", \"\")\n\
    \  local reversed = filtered:reverse()\n  return (filtered == reversed), filtered\n\
    end", "  -- your code here\nend", "  local result = \"\"\n  for _,v in pairs(s:gmatch(\"\
    %w\")) do\n    if not c:find(v) then\n      result = result .. v\n    end\n  end\n\
    \  return result, result == result:reverse()\nend", "  local u = ''\n  for i=1,\
    \ #s do\n    if not s:match('['..c..']') then u = u..s:sub(i,i) end\n  end\n \
    \ return u, u == u:reverse()\nend", "  return (s:gsub('['..c..']', ''), s:gsub('['..c..']',\
    \ '') == s:gsub('['..c..']', ''):reverse())\nend", "  if #s < 2 then return s,\
    \ false end\n  local clean = s:gsub('['..c..']', '')\n  return clean, clean ==\
    \ clean:reverse()\nend", "    local res = {}\n    local r = {}\n    local lookup\
    \ = {}\n    local flag = true\n    for i = 1, #c do\n        lookup[c:sub(i, i)]\
    \ = true\n    end\n    for i = 1, #s do\n        if not lookup[s:sub(i, i)] then\n\
    \            table.insert(res, s:sub(i, i))\n            table.insert(r, s:sub(i,\
    \ i))\n        end\n    end\n    local l = #res\n    for i = 1, l do\n       \
    \ if res[i] ~= r[l + 1 - i] then\n            flag = false\n            break\n\
    \        end\n    end\n    return table.concat(res), flag\nend", "  local r =\
    \ {}\n  for i = 1, #s do\n    local exist = false\n    for j = 1, #c do\n    \
    \  if s[i] == c[j] then\n        exist = true\n        break\n      end\n    end\n\
    \    if not exist then\n      r[#r + 1] = s[i]\n    end\n  end\n  return table.concat(r),\
    \ reverse_string(r) == table.concat(r)\nend", "\ts = string.gsub(s, c, \"\")\n\
    \treturn s, s == string.reverse(s)\nend", "  -- your code goes here\nend", " \
    \   -- input: s, a string\n    --        c, a string\n    -- output: a tuple,\
    \ (s_new, True/False)\n    --         s_new is the new string after deletion\n\
    \    --         True/False is the check if the new string is palindrome\n    --\
    \ pseudo code:\n    --   s_new = nil\n    --   iterate all chars in s:\n    --\
    \       check if it's in c\n    --       if not, add to s_new\n    --   check\
    \ if s_new is palindrome\n    local s_new = nil\n    for char in s:gmatch('.')\
    \ do\n        if not c:find(char) then\n            if s_new == nil then\n   \
    \             s_new = char\n            else\n                s_new = s_new ..\
    \ char\n            end\n        end\n    end\n    local check = s_new == s_new:reverse()\n\
    \    return {s_new, check}\nend", end, "  for i=1, #c do\n    s = s:gsub(c:sub(i,i),\
    \ \"\")\n  end\n  local t = string.reverse(s)\n  return s, s == t\nend", "   \
    \ local t, s2 = {}, {}\n    for i = 1, #s do\n        t[i] = s:sub(i, i)\n   \
    \ end\n    for i = 1, #c do\n        s2[i] = c:sub(i, i)\n    end\n    for i =\
    \ 1, #s2 do\n        for k, v in pairs(t) do\n            if s2[i] == v then\n\
    \                table.remove(t, k)\n            end\n        end\n    end\n \
    \   local ss = table.concat(t)\n    local flag = true\n    for i = 1, #ss do\n\
    \        if ss:sub(i, i) ~= ss:sub(#ss - i + 1, #ss - i + 1) then\n          \
    \  flag = false\n            break\n        end\n    end\n    return ss, flag\n\
    end", "  --your code here\n  for i=1,#c do\n    s = s:gsub(c:sub(i,i),\"\")\n\
    \  end\n  local b = true\n  for i=1,#s/2 do\n    if s:sub(i,i) ~= s:sub(#s-i+1,#s-i+1)\
    \ then\n      b = false\n      break\n    end\n  end\n  return s,b\nend", "  local\
    \ ns = ''\n  for i = 1, s:len() do\n    local ci = s:sub(i, i)\n    if not c:find(ci)\
    \ then\n      ns = ns .. ci\n    end\n  end\n  local nn = ''\n  for i = 1, ns:len()\
    \ do\n    local ci = ns:sub(i, i)\n    nn = ci .. nn\n  end\n  local b\n  if ns\
    \ == nn then\n    b = true\n  else\n    b = false\n  end\n  return ns, b\nend",
  "    local res = s:gsub('['..c..']', '')\n    return res, res == res:reverse()\n\
    end", "  for i = 1, #c do\n    s = s:gsub(c:sub(i, i), '')\n  end\n  local l =\
    \ 1\n  local r = #s\n  while l < r do\n    if s:sub(l, l) ~= s:sub(r, r) then\n\
    \      return s, false\n    end\n    l = l + 1\n    r = r - 1\n  end\n  return\
    \ s, true\nend", "    for i=1,#c do s = s:gsub(c:sub(i,i), '') end\n    return\
    \ s, s == s:reverse()\nend", "    local regex = string.format(\"[%s]\", c)\n \
    \   local ss = s:gsub(regex, '')\n    local first = ss:sub(1, #ss / 2)\n    local\
    \ second = ss:sub(#ss / 2 + 1, #ss)\n    local revsecond = second:reverse()\n\
    \    return first == revsecond, ss\nend", "  local t = {}\n  local d = {}\n  local\
    \ i = 0\n  for k, v in utf8.codes(s) do\n    i = i + 1\n    t[i] = v\n  end\n\
    \  local i = 0\n  for k, v in utf8.codes(c) do\n    i = i + 1\n    d[i] = v\n\
    \  end\n  for i = #t, 1, -1 do\n    for j = 1, #d do\n      if t[i] == d[j] then\n\
    \        table.remove(t, i)\n      end\n    end\n  end\n  local p = {}\n  for\
    \ i = 1, #t do\n    p[i] = utf8.char(t[i])\n  end\n  local r = table.concat(p)\n\
    \  local res = r == string.reverse(r)\n  return r, res\nend", "  for i=1, #c do\n\
    \    s = s:gsub(c:sub(i,i), '')\n  end\n  local new_s = s:gsub('(.)(.*)', function(c,s)\
    \ return (s or '')..c end)\n  return new_s, s == new_s\nend", "    local new =\
    \ s:gsub(\"[\"..c..\"]\", \"\")\n    local len = new:len()\n    for i = 1, len\
    \ / 2 do\n        if new:sub(i, i) ~= new:sub(len - i + 1, len - i + 1) then\n\
    \            return new, false\n        end\n    end\n    return new, true\nend",
  "    local array = {}\n    local temp\n    for i = 1, #s do\n        temp = s:sub(i,\
    \ i)\n        if temp ~= c:sub(1, 1) and temp ~= c:sub(2, 2) then\n          \
    \  table.insert(array, temp)\n        end\n    end\n    temp = ''\n    for i =\
    \ 1, #array do\n        temp = temp .. array[i]\n    end\n    if temp == temp:reverse()\
    \ then\n        return temp, true\n    else\n        return temp, false\n    end\n\
    end", "    local res = {}\n    local set = {}\n    for i = 1,#c do\n        set[c:sub(i,i)]\
    \ = true\n    end\n    for i = 1,#s do\n        if not set[s:sub(i,i)] then\n\
    \            res[#res+1] = s:sub(i,i)\n        end\n    end\n    return table.concat(res),\
    \ res[1]==res[#res]\nend", "  local res = s:gsub(\"[\"..c..\"]\", \"\")\n  local\
    \ tmp = res:reverse()\n  return res, res == tmp\nend", "  return s:gsub(\"[\"\
    ..c..\"]\", \"\"):reverse() == s:gsub(\"[\"..c..\"]\", \"\")\nend", "  for c in\
    \ c:gmatch(\".\") do\n    s = s:gsub(c, \"\")\n  end\n  return s, s == s:reverse()\n\
    end", "\tlocal str = string.gsub(s, \"[\"..c..\"]\", \"\")\n\tlocal front = 1\n\
    \tlocal tail = string.len(str)\n\tlocal check = false\n\twhile tail >= front do\n\
    \t\tif string.sub(str,front,front) == string.sub(str,tail,tail) then\n\t\t\tfront\
    \ = front + 1\n\t\t\ttail = tail - 1\n\t\t\tcheck = true\n\t\telse\n\t\t\tcheck\
    \ = false\n\t\t\tbreak\n\t\tend\n\tend\n\treturn str, check\nend", "  for char\
    \ in c:gmatch(\"%a\") do\n    s = s:gsub(char, \"\")\n  end\n  return s, s ==\
    \ s:reverse()\nend", "  local function remove_chars(s, c)\n    local chars = {};\n\
    \    for char in s:gmatch('.') do\n      chars[#chars + 1] = char;\n    end\n\
    \    for char in c:gmatch('.') do\n      for i = 1, #chars do\n        if chars[i]\
    \ == char then\n          table.remove(chars, i);\n        end\n      end\n  \
    \  end\n    return table.concat(chars);\n  end\n  local function is_palindrome(s)\n\
    \    local chars = {};\n    for char in s:gmatch('.') do\n      chars[#chars +\
    \ 1] = char;\n    end\n    for i = 1, #chars do\n      if chars[i] ~= chars[#chars\
    \ - i + 1] then\n        return false;\n      end\n    end\n    return true;\n\
    \  end\n  return remove_chars(s, c), is_palindrome(remove_chars(s, c));\nend",
  "    local t = {}\n    local r = {}\n    for i = 1, #s do\n        t[i] = s:sub(i,\
    \ i)\n    end\n    for i = 1, #c do\n        r[i] = c:sub(i, i)\n    end\n   \
    \ for i = 1, #s do\n        for j = 1, #c do\n            if t[i] == r[j] then\n\
    \                table.remove(t, i)\n            end\n        end\n    end\n \
    \   local bool\n    if #t == 0 then\n        bool = true\n    else\n        bool\
    \ = false\n    end\n    return table.concat(t), bool\nend", "  for i = 1, #c do\n\
    \    s = s:gsub(c:sub(i, i), '')\n  end\n  return s, s == s:reverse()\nend", " \
    \ local t = {}\n  for i=1,#s do\n    local e = s:sub(i,i)\n    if not c:find(e)\
    \ then t[#t+1] = e end\n  end\n  local s = table.concat(t)\n  local f = true\n\
    \  for i=1,#s/2 do\n    if s:sub(i,i) ~= s:sub(#s-i+1,#s-i+1) then f = false end\n\
    \  end\n  return s, f\nend", "  s = s:gsub('['..c..']', '')\n  return s, s:reverse()\
    \ == s\nend", "\tfor i = 1, #c do\n\t\ts = s:gsub(c:sub(i, i), '')\n\tend\n\t\
    local rs = s:reverse()\n\treturn s, s == rs\nend", "  -- your code here\nend",
  "    local function is_palindrome(str)\n        return str == str:reverse()\n  \
    \  end\n    local new_str = s:gsub(\"[\" .. c .. \"]\", \"\")\n    return new_str,\
    \ is_palindrome(new_str)\nend", "    -- your code here\n    return s, false\n\
    end", "\t\n\tlocal a,b = {},{}\n\tfor i=1, #s do\n\t\ta[#a+1] = s:sub(i,i)\n\t\
    end\n\tfor i=1, #c do\n\t\tb[#b+1] = c:sub(i,i)\n\tend\n\tfor i=1, #b do\n\t\t\
    local index = 0\n\t\trepeat\n\t\t\tindex = index + 1\n\t\t\tlocal found = a[index]\
    \ == b[i]\n\t\t\tif found then table.remove(a, index) end\n\t\tuntil not found\n\
    \tend\n\tlocal s = table.concat(a)\n\treturn s, s == s:reverse()\nend", "  --\
    \ your code here\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n\
    \  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n\
    \  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n\
    \  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n\
    \  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n\
    \  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n\
    \  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n\
    \  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n\
    \  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n\
    \  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n\
    \  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n\
    \  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n\
    \  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n  --\n\
    \  --\n  --\n ", "    -- check if the result string is palindrome\n    local function\
    \ is_palindrome(s)\n        for i = 1, math.floor(#s / 2) do\n            if s:sub(i,\
    \ i) ~= s:sub(#s - i + 1, #s - i + 1) then\n                return false\n   \
    \         end\n        end\n        return true\n    end", "  for i = 1, #c do\n\
    \    local a = string.char(c:byte(i))\n    s = s:gsub(a, \"\")\n  end\n  return\
    \ (s:reverse() == s), s\nend", "  --your code here\n  local string = ''\n  for\
    \ i = 1, #s do\n      if not c:find(s:sub(i,i)) then\n          string = string\
    \ .. s:sub(i,i)\n      end\n  end\n  return string, string == string:reverse()\n\
    end", "    -- your code here\n    return nil\nend", "  local t = {}\n  for k,\
    \ v in s:gmatch('(.)') do\n    t[k] = not c:find(v) and v or ''\n  end\n  return\
    \ table.concat(t), table.concat(t) == table.concat(t, '', 1, #t / 2):reverse()\n\
    end", "  -- your code here\nend", "  local t = {};\n  local n = 1;\n  local c_table\
    \ = {};\n  for i = 1, #c do\n    c_table[c:sub(i, i)] = true;\n  end\n  for i\
    \ = 1, #s do\n    if not c_table[s:sub(i, i)] then\n      t[n] = s:sub(i, i);\n\
    \      n = n + 1;\n    end\n  end\n  local a = table.concat(t);\n  local b = table.concat(table.reverse(t));\n\
    \  return a, a == b;\nend", "  local reverse = {}\n  for i = #s, 1, -1 do\n  \
    \  local index = string.find(c, s:sub(i, i))\n    if index == nil then\n     \
    \ table.insert(reverse, s:sub(i, i))\n    end\n  end\n  local reverse_string =\
    \ table.concat(reverse)\n  local palindrome = true\n  for i = 1, #reverse_string\
    \ do\n    if reverse_string:sub(i, i) ~= reverse_string:sub(#reverse_string -\
    \ i + 1, #reverse_string - i + 1) then\n      palindrome = false\n      break\n\
    \    end\n  end\n  return reverse_string, palindrome\nend", "  c = \"(\" .. c:gsub(\"\
    .\", \"%%%1\") .. \")\"\n  s = s:gsub(c, \"\")\n  return s, s == s:reverse()\n\
    end", "   local s = s:gsub('['..c..']', '')\n   local b = s == s:reverse()\n \
    \  return s, b\nend", "  for ch in c:gmatch(\".\") do\n    s = s:gsub(ch, \"\"\
    )\n  end\n  return s, s == s:reverse()\nend", "    local res = \"\"\n    for _,\
    \ v in ipairs(s) do\n        local is_contain = false\n        for _, v1 in ipairs(c)\
    \ do\n            if v == v1 then\n                is_contain = true\n       \
    \         break\n            end\n        end\n        if not is_contain then\n\
    \            res = res .. v\n        end\n    end\n    return res, res == string.reverse(res)\n\
    end", "    local ss = s:gsub('['..c..']', '')\n    local lss = ss:len()\n    local\
    \ result = lss\n    if lss % 2 == 0 then\n        result = lss / 2\n    else\n\
    \        result = (lss + 1) / 2\n    end\n    local a, b = ss:sub(1, result),\
    \ ss:sub(result+1, -1)\n    return a == b:reverse() and true or false\nend", " \
    \ local res_str = ''\n  local res_bool = true\n  local s_table = {}\n  local c_table\
    \ = {}\n  for v in s:gmatch('.') do\n    table.insert(s_table, v)\n  end\n  for\
    \ v in c:gmatch('.') do\n    table.insert(c_table, v)\n  end\n  for i = 1, #s_table\
    \ do\n    local is_in = false\n    for j = 1, #c_table do\n      if s_table[i]\
    \ == c_table[j] then\n        is_in = true\n        break\n      end\n    end\n\
    \    if not is_in then\n      res_str = res_str .. s_table[i]\n    end\n  end\n\
    \  for i = 1, #res_str/2 do\n    if res_str:sub(i, i) ~= res_str:sub(#res_str\
    \ - i + 1, #res_str - i + 1) then\n      res_bool = false\n      break\n    end\n\
    \  end\n  return res_str, res_bool\nend", "  local t = {}\n  local r = {}\n  local\
    \ i, j = 1, #s\n  while i <= j do\n    local a, b = s:sub(i, i), s:sub(j, j)\n\
    \    if not t[a] and not t[b] then\n      r[#r + 1] = b\n      j = j - 1\n   \
    \ elseif t[a] and t[b] then\n      j = j - 1\n    elseif t[a] then\n      i =\
    \ i + 1\n    else\n      r[#r + 1] = b\n      j = j - 1\n    end\n  end\n  local\
    \ result = table.concat(r):gsub('%s', '')\n  return result, result == result:reverse()\n\
    end", "  local t = {}\n  for i = 1, string.len(s) do\n    t[string.sub(s, i, i)]\
    \ = true\n  end\n  local function del(t, s)\n    local res = \"\"\n    for i =\
    \ 1, string.len(s) do\n      if not t[string.sub(s, i, i)] then\n        res =\
    \ res .. string.sub(s, i, i)\n      end\n    end\n    return res\n  end\n  local\
    \ res = del(t, s)\n  local reversed = string.reverse(res)\n  return reversed,\
    \ res == reversed\nend", "    local res = {}\n    local t = {}\n    local pattern\
    \ = \"[\" .. c .. \"]\"\n    for i = 1, s:len() do\n        if not s:sub(i, i):find(pattern)\
    \ then\n            table.insert(res, s:sub(i, i))\n        end\n    end\n   \
    \ for i = res:len(), 1, -1 do\n        table.insert(t, res:sub(i, i))\n    end\n\
    \    return (table.concat(res), (res == t))\nend", "    s = s:gsub('['..c..']',\
    \ '')\n    local is_palindrome = s == s:reverse()\n    return s, is_palindrome\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
