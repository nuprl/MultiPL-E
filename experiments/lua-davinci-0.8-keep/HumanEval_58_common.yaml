name: HumanEval_58_common
language: lua
prompt: "-- Return sorted unique common elements for two lists.\n-- >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n-- [1, 5, 653]\n-- >>> common([5,\
  \ 3, 2, 8], [3, 2])\n-- [2, 3]\nlocal function common(l1, l2)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = common\n\
  \    lu.assertEquals(candidate({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}),\
  \ {1, 5, 653})\n    lu.assertEquals(candidate({5, 3, 2, 8}, {3, 2}), {2, 3})\n \
  \   lu.assertEquals(candidate({4, 3, 2, 8}, {3, 2, 4}), {2, 3, 4})\n    lu.assertEquals(candidate({4,\
  \ 3, 2, 8}, {}), {})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local res = {}\n    for _, val in ipairs(l1) do\n        if inlist(l2,\
    \ val) then\n            res[#res + 1] = val\n        end\n    end\n    table.sort(res)\n\
    \    return res\nend", "    if not l1 or not l2 then return {} end\n    local\
    \ res = {}\n    local d2 = dict(l2)\n    for _, v in ipairs(l1) do\n        if\
    \ d2[v] then table.insert(res, v) end\n    end\n    return unique(res)\nend",
  "  local set = {}\n  for _, v in ipairs(l1) do\n    set[v] = true\n  end\n  local\
    \ res = {}\n  for _, v in ipairs(l2) do\n    if set[v] then\n      res[#res +\
    \ 1] = v\n    end\n  end\n  sort(res)\n  return res\nend", "    local t = {}\n\
    \    for i = 1, #l1 do\n        for j = 1, #l2 do\n            if l1[i] == l2[j]\
    \ then\n                t[#t + 1] = l1[i]\n            end\n        end\n    end\n\
    \    return utils.unique(t)\nend", "  local t = {}\n  for _, v in ipairs(l1) do\n\
    \    t[v] = true\n  end\n  local r = {}\n  for _, v in ipairs(l2) do\n    if t[v]\
    \ then\n      r[#r + 1] = v\n    end\n  end\n  return sort_keys(r)\nend", "  local\
    \ t = {}\n  for _, n in ipairs(l1) do\n    t[n] = (t[n] or 0) + 1\n  end\n  for\
    \ _, n in ipairs(l2) do\n    t[n] = (t[n] or 0) + 1\n  end\n  local o = {}\n \
    \ for k, v in pairs(t) do\n    if v == 2 then\n      o[#o + 1] = k\n    end\n\
    \  end\n  sort(o)\n  return o\nend", "\tlocal t1 = {}\n\tlocal t2 = {}\n\tlocal\
    \ res = {}\n\tfor _, v in ipairs(l1) do\n\t\tt1[v] = true\n\tend\n\tfor _, v in\
    \ ipairs(l2) do\n\t\tt2[v] = true\n\tend\n\tfor v, _ in pairs(t1) do\n\t\tif t2[v]\
    \ then\n\t\t\ttable.insert(res, v)\n\t\tend\n\tend\n\ttable.sort(res)\n\treturn\
    \ res\nend", "  local common = {}\n  local set = {}\n  for _, v in ipairs(l1)\
    \ do\n    if not set[v] then\n      set[v] = true\n      table.insert(common,\
    \ v)\n    end\n  end\n  for _, v in ipairs(l2) do\n    if set[v] then\n      set[v]\
    \ = nil\n      table.insert(common, v)\n    end\n  end\n  return common\nend",
  "    local l3 = {}\n    local l4 = {}\n    for k,v in pairs(l1) do l3[v] = v end\n\
    \    for k,v in pairs(l2) do if l3[v] then l4[v] = v end end\n    l3 = {}\n  \
    \  for k,v in pairs(l4) do l3[#l3+1] = v end\n    return l3\nend", "    local\
    \ t = {}\n    for i = 1, #l1 do\n        t[l1[i]] = true\n    end\n    local common\
    \ = {}\n    for i = 1, #l2 do\n        if t[l2[i]] then\n            common[#common\
    \ + 1] = l2[i]\n        end\n    end\n    sort(common)\n    return common\nend",
  "    local res = {}\n    local rl1 = reverse(l1)\n    local rl2 = reverse(l2)\n\
    \    local len1 = #rl1\n    local len2 = #rl2\n    local i = 1\n    local j =\
    \ 1\n    while i <= len1 and j <= len2 do\n        if rl1[i] == rl2[j] then\n\
    \            res[#res + 1] = rl1[i]\n            i = i + 1\n            j = j\
    \ + 1\n        elseif rl1[i] < rl2[j] then\n            i = i + 1\n        else\n\
    \            j = j + 1\n        end\n    end\n    return reverse(res)\nend", " \
    \ local common = {}\n  local contained = {}\n  for _, el in ipairs(l1) do\n  \
    \  if not contained[el] then\n      contained[el] = {}\n    end\n    contained[el][#contained[el]\
    \ + 1] = l1\n  end\n  for _, el in ipairs(l2) do\n    if contained[el] then\n\
    \      contained[el][#contained[el] + 1] = l2\n    end\n  end\n  for el, lists\
    \ in pairs(contained) do\n    if #lists == 2 then\n      common[#common + 1] =\
    \ el\n    end\n  end\n  table.sort(common)\n  return common\nend", "  local t\
    \ = {}\n  for k, v in pairs(l1) do table.insert(t, v) end\n  for k, v in pairs(l2)\
    \ do table.insert(t, v) end\n  table.sort(t)\n  local last = nil\n  local i =\
    \ 1\n  while i <= #t do\n    if t[i] == last then\n      table.remove(t, i)\n\
    \    else\n      last = t[i]\n      i = i + 1\n    end\n  end\n  return t\nend",
  "  local s1 = {}\n  local s2 = {}\n  local res = {}\n  for _, l in ipairs{l1, l2}\
    \ do\n    for _, v in ipairs(l) do\n      s1[v] = (s1[v] or 0) + 1\n    end\n\
    \  end\n  for _, v in ipairs(l1) do\n    if s1[v] > 1 then\n      s2[v] = true\n\
    \    end\n  end\n  for _, v in ipairs(l2) do\n    if s2[v] then\n      res[#res+1]\
    \ = v\n    end\n  end\n  return res\nend", "    local r = {}\n    for _, v in\
    \ ipairs(l1) do\n        if list.contains(l2, v) then\n            table.insert(r,\
    \ v)\n        end\n    end\n    return unique(r)\nend", "  local new = {}\n  if\
    \ l1 == nil then return new end\n  for _, item in ipairs(l1) do\n    if find(l2,\
    \ item) then\n      table.insert(new, item)\n    end\n  end\n  return sort_unique(new)\n\
    end", "\tlocal c = {}\n\tlocal s = {}\n\tfor _, v in ipairs(l1) do\n\t\tc[v] =\
    \ true\n\tend\n\tfor _, v in ipairs(l2) do\n\t\tif c[v] then\n\t\t\tc[v] = nil\n\
    \t\t\ts[#s + 1] = v\n\t\tend\n\tend\n\tsort(s)\n\treturn s\nend", "  local map\
    \ = {}\n  for _, n in ipairs(l1) do\n    map[n] = true\n  end\n  local map2 =\
    \ {}\n  for _, n in ipairs(l2) do\n    if map[n] then\n      map2[n] = true\n\
    \    end\n  end\n  local ret = {}\n  for k, _ in pairs(map2) do\n    ret[#ret\
    \ + 1] = k\n  end\n  return sort(ret)\nend", "  local l3 = {}\n  for i = 1, #l1\
    \ do\n    local j = binsearch(l2, l1[i])\n    if j ~= nil then\n      l3[#l3 +\
    \ 1] = l1[i]\n    end\n  end\n  return sort(l3)\nend", "\tlocal tmp = {}\n\tlocal\
    \ c = {}\n\tfor _, v in ipairs(l1) do\n\t\tif not tmp[v] then\n\t\t\ttmp[v] =\
    \ 1\n\t\tend\n\tend\n\tfor _, v in ipairs(l2) do\n\t\tif tmp[v] then\n\t\t\tc[#c\
    \ + 1] = v\n\t\t\ttmp[v] = nil\n\t\tend\n\tend\n\treturn sort(c)\nend", "    local\
    \ l = {}\n    for _, item in ipairs(l1) do\n        if lua_util.table_find(l2,\
    \ item) then\n            table.insert(l, item)\n        end\n    end\n    return\
    \ uniq(l)\nend", "    local n = {}\n    for _, v in ipairs(l1) do\n        if\
    \ in_table(v, l2) then\n            n[#n + 1] = v\n        end\n    end\n    return\
    \ n\nend", "    local table = {}\n    for i, v in ipairs(l1) do\n        if l2[v]\
    \ then\n            table[v] = v\n        end\n    end\n    return values(table)\n\
    end", "  -- TODO: implement this\nend", "  -- Sorting unique elements of both\
    \ list in ascending order.\n  local s1 = ordered(l1)\n  local s2 = ordered(l2)\n\
    \  local ls = {}", "    return keys(intersect(l1, l2))\nend", "    local t = {}\n\
    \    for _, x in ipairs(l1) do\n        t[x] = t[x] and t[x] + 1 or 1\n    end\n\
    \    for _, x in ipairs(l2) do\n        t[x] = t[x] and t[x] + 1 or 1\n    end\n\
    \    local res = {}\n    for x, _ in pairs(t) do\n        if t[x] == 2 then\n\
    \            table.insert(res, x)\n        end\n    end\n    return res\nend",
  "  local intersection = {}\n  for i = 1, #l1 do\n    for j = 1, #l2 do\n      if\
    \ l1[i] == l2[j] then\n        intersection[#intersection + 1] = l1[i]\n     \
    \ end\n    end\n  end\n  return unique(intersection)\nend", "    local set = {}\n\
    \    for _, v in ipairs(l1) do\n        set[v] = true\n    end\n    local r =\
    \ {}\n    for _, v in ipairs(l2) do\n        if set[v] then\n            table.insert(r,\
    \ v)\n        end\n    end\n    table.sort(r)\n    return r\nend", "\tlocal t\
    \ = {}\n\tfor i,v in ipairs(l1) do\n\t\tt[v] = true\n\tend\n\tlocal r = {}\n\t\
    for i,v in ipairs(l2) do\n\t\tif t[v] then\n\t\t\tr[#r+1] = v\n\t\tend\n\tend\n\
    \treturn r\nend", "    local s1 = table.sort(l1)\n    local s2 = table.sort(l2)\n\
    \    local i, j = 1, 1\n    local result = {}\n    while i <= #s1 and j <= #s2\
    \ do\n        if s1[i] == s2[j] then\n            table.insert(result, s1[i])\n\
    \            i = i + 1\n            j = j + 1\n        elseif s1[i] < s2[j] then\n\
    \            i = i + 1\n        else\n            j = j + 1\n        end\n   \
    \ end\n    return result\nend", "    return unique(sort(intersect(l1, l2)))\n\
    end", "    if #l1 == 0 or #l2 == 0 then\n        return {}\n    end\n    -- sort\
    \ list\n    local sl1 = l1:sort()\n    local sl2 = l2:sort()\n    -- find index\
    \ of first common element\n    local idx = 1\n    while sl1[idx] ~= sl2[idx] do\n\
    \        idx = idx + 1\n        if idx > #sl1 or idx > #sl2 then\n           \
    \ return {}\n        end\n    end\n    -- find index of last common element\n\
    \    local idx2 = idx\n    while sl1[idx2] == sl2[idx2] do\n        idx2 = idx2\
    \ + 1\n        if idx2 > #sl1 or idx2 > #sl2 then\n            break\n       \
    \ end\n    end\n    idx2 = idx2 - 1\n    return {table.unpack(sl1, idx, idx2)}\n\
    end", "  local map = {}\n  for i = 1, #l1 do\n    map[l1[i]] = true\n  end\n \
    \ local res = {}\n  for i = 1, #l2 do\n    if map[l2[i]] then\n      table.insert(res,\
    \ l2[i])\n    end\n  end\n  table.sort(res)\n  return res\nend", "  local u =\
    \ union(l1, l2)\n  local t = {}\n  for _, v in ipairs(u) do\n    t[v] = (t[v]\
    \ or 0) + 1\n  end\n  local c = {}\n  for _, v in ipairs(u) do\n    if t[v] >\
    \ 1 then\n      c[#c + 1] = v\n    end\n  end\n  return sorted(c)\nend", "   \
    \ local u = {}\n    for _,v in ipairs(l1) do\n        if contains(l2, v) then\n\
    \            table.insert(u, v)\n        end\n    end\n    table.sort(u)\n   \
    \ return u\nend", "    local result = {}\n    for _, i in ipairs(l1) do\n    \
    \    for _, j in ipairs(l2) do\n            if i == j then\n                result[#result\
    \ + 1] = i\n            end\n        end\n    end\n    table.sort(result)\n  \
    \  return result\nend", "    -- Make a set from second list\n    local set = Set.new(l2)\n\
    \    -- Find common elements and return\n    return table.sorted_unique(filter(l1,\
    \ function(x) return set:contains(x) end))\nend", "  local tbl = {}\n  for _,\
    \ num in ipairs(l1) do\n    if contains(l2, num) then\n      tbl[#tbl + 1] = num\n\
    \    end\n  end\n  return unique(tbl)\nend", "  local h = {}\n  for i = 1, #l1\
    \ do\n    h[l1[i]] = true\n  end\n  local r = {}\n  for i = 1, #l2 do\n    if\
    \ h[l2[i]] then\n      r[#r + 1] = l2[i]\n    end\n  end\n  if #r > 0 then\n \
    \   table.sort(r)\n  end\n  return r\nend", "    return sorted(unique(l1), function(a,\
    \ b) return a < b end)\n          :filter(function(x) return contains(l2, x) end)\n\
    end", "    local m = map(set(l1), set(l2))\n    return sort(m[1] & m[2])\nend",
  "    return sort(unique(intersect(l1, l2)))\nend", "\tlocal result = {}\n\tlocal\
    \ is_seen = {}\n\tfor i=1, #l1 do\n\t\tis_seen[l1[i]] = 1\n\tend\n\tfor i=1, #l2\
    \ do\n\t\tif is_seen[l2[i]] == 1 then\n\t\t\tresult[#result+1] = l2[i]\n\t\t\t\
    is_seen[l2[i]] = nil\n\t\tend\n\tend\n\ttable.sort(result)\n\treturn result\n\
    end", "    local list = {}\n    for _, v in ipairs(l1) do\n        list[v] = true\n\
    \    end\n    for _, v in ipairs(l2) do\n        if list[v] then\n           \
    \ list[v] = nil\n            table.insert(list, v)\n        end\n    end\n   \
    \ table.sort(list)\n    return list\nend", "  local set = {}\n  for _, v in ipairs(l1)\
    \ do\n    set[v] = true\n  end\n  local t = {}\n  for _, v in ipairs(l2) do\n\
    \    if set[v] then\n      t[#t+1] = v\n    end\n  end\n  sort(t)\n  return t\n\
    end", "    local s = {}\n    local res = {}\n    for _, v in ipairs(l1) do\n \
    \       s[v] = true\n    end\n    for _, v in ipairs(l2) do\n        if s[v] then\n\
    \            res[#res+1] = v\n        end\n    end\n    return res\nend", "  local\
    \ tbl = {}\n  local i = 1\n  for _,v in ipairs(l1) do\n    for _,v2 in ipairs(l2)\
    \ do\n      if v == v2 then\n        tbl[i] = v\n        i = i + 1\n      end\n\
    \    end\n  end\n  sort(tbl)\n  return tbl\nend", "    local n1 = #l1\n    local\
    \ n2 = #l2\n    local j = 0\n    local s = {}\n    for i = 1, n1 do\n        local\
    \ v = l1[i]\n        for k = 1, n2 do\n            if v == l2[k] then\n      \
    \          s[j + 1] = v\n                j = j + 1\n                break\n  \
    \          end\n        end\n    end\n    if j > 0 then\n        sort(s)\n   \
    \     local j = 1\n        local m = 1\n        local n = #s\n        while j\
    \ < n do\n            if s[j] == s[j + 1] then\n                s[j] = nil\n \
    \           else\n                s[m] = s[j]\n                m = m + 1\n   \
    \         end\n            j = j + 1\n        end\n        s[m] = s[j]\n     \
    \   for i = n, m + 1, -1 do\n            s[i] = nil\n        end\n    end\n  \
    \  return s\nend", "\tlocal function oneInTwo(el)\n\t\tfor _, el2 in ipairs(l2)\
    \ do\n\t\t\tif el == el2 then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\t\treturn\
    \ false\n\tend\n\tlocal ret = {}\n\tfor _, el in ipairs(l1) do\n\t\tif oneInTwo(el)\
    \ then\n\t\t\ttable.insert(ret, el)\n\t\tend\n\tend\n\treturn table.unpack(merge_sort(ret))\n\
    end", "\tlocal function build_set(list)\n\t\tlocal set = {}\n\t\tfor _, value\
    \ in ipairs(list) do\n\t\t\tset[value] = true\n\t\tend\n\t\treturn set\n\tend",
  "\tlocal l = {}\n\tfor _, v in ipairs(l1) do\n\t\tif indexOf(l2, v) then\n\t\t\t\
    insertSorted(l, v)\n\t\tend\n\tend\n\treturn l\nend", "\tlocal s = {}\n\tfor _,\
    \ v in ipairs(l1) do\n\t\ts[v] = true\n\tend\n\tlocal c = {}\n\tfor _, v in ipairs(l2)\
    \ do\n\t\tif s[v] then\n\t\t\ttable.insert(c, v)\n\t\tend\n\tend\n\treturn c\n\
    end", "    local common = {}\n    for _, v in ipairs(l1) do\n        if contains(l2,\
    \ v) then\n            common[#common + 1] = v\n        end\n    end\n    table.sort(common)\n\
    \    return common\nend", "    local ret = {}\n    local cmp = {}\n    for _,\
    \ l in ipairs({l1, l2}) do\n        for _, v in ipairs(l) do\n            cmp[v]\
    \ = (cmp[v] or 0) + 1\n        end\n    end\n    for k, v in pairs(cmp) do\n \
    \       if v > 1 then\n            table.insert(ret, k)\n        end\n    end\n\
    \    return sort(ret)\nend", "  local common = {}\n  local l2_map = {}\n  for\
    \ _, v in ipairs(l2) do\n    l2_map[v] = true\n  end\n  for _, v in ipairs(l1)\
    \ do\n    if l2_map[v] then\n      common[#common + 1] = v\n    end\n  end\n \
    \ return common\nend", "    local n1 = {}\n    local n2 = {}\n    local n3 = {}\n\
    \    local m1 = #l1\n    local m2 = #l2\n    for i = 1, m1 do\n        n1[l1[i]]\
    \ = i\n    end\n    for i = 1, m2 do\n        if n1[l2[i]] then\n            n2[#n2\
    \ + 1] = l2[i]\n        end\n    end\n    for i = 1, #n2 do\n        n3[n2[i]]\
    \ = i\n    end\n    table.sort(n2)\n    return n2\nend", "  local hash = {}\n\
    \  local ret = {}\n  for i,v in ipairs(l1) do\n    hash[v] = true\n  end\n  for\
    \ i,v in ipairs(l2) do\n    if hash[v] then\n      ret[#ret+1] = v\n    end\n\
    \  end\n  table.sort(ret)\n  return ret\nend", "  local res = {}\n  local m =\
    \ map()\n  for i = 1, #l1 do\n    m[l1[i]] = 1\n  end\n  for i = 1, #l2 do\n \
    \   if m[l2[i]] then\n      res[#res + 1] = l2[i]\n    end\n  end\n  table.sort(res)\n\
    \  return res\nend", "    local tab = {}\n    local result = {}\n    for _, v\
    \ in ipairs(l1) do tab[v] = true end\n    for _, v in ipairs(l2) do\n        if\
    \ tab[v] == true then table.insert(result, v) end\n    end\n    table.sort(result)\n\
    \    return result\nend", "  local memo = {}\n  for _, elem in ipairs(l1) do\n\
    \    memo[elem] = true\n  end\n  local res = {}\n  for _, elem in ipairs(l2) do\n\
    \    if memo[elem] then table.insert(res, elem) end\n  end\n  table.sort(res)\n\
    \  return res\nend", "  local t = {}\n  for _, e in ipairs(l1) do\n    if list.find(l2,\
    \ e) then\n      table.insert(t, e)\n    end\n  end\n  return list.sort(t)\nend",
  "    local l, n = {}, 0\n    for _, v in ipairs(l1) do\n        if List.Contains(l2,\
    \ v) then\n            n = n + 1\n            l[n] = v\n        end\n    end\n\
    \    sort(l)\n    return l\nend", "    local t = {}\n    local l3 = {}\n    for\
    \ i, v in ipairs(l1) do\n        t[v] = true\n    end\n    for i, v in ipairs(l2)\
    \ do\n        if t[v] then\n            table.insert(l3, v)\n        end\n   \
    \ end\n    table.sort(l3)\n    return l3\nend", "  local t1 = {}\n  local t2 =\
    \ {}\n  for _, v in ipairs(l1) do\n    t1[v] = true\n  end\n  for _, v in ipairs(l2)\
    \ do\n    t2[v] = true\n  end\n  local c = {}\n  for k, _ in pairs(t1) do\n  \
    \  if t2[k] then\n      c[#c + 1] = k\n    end\n  end\n  table.sort(c)\n  return\
    \ c\nend", "\tlocal r = {}\n\tlocal s = {}\n\tfor _, v in ipairs(l1) do\n\t\t\
    r[v] = true\n\tend\n\tfor _, v in ipairs(l2) do\n\t\tif r[v] then\n\t\t\ts[v]\
    \ = true\n\t\tend\n\tend\n\tr = {}\n\tfor k in pairs(s) do\n\t\tr[#r + 1] = k\n\
    \tend\n\tsort(r)\n\treturn r\nend", "    local t = {}\n    for i,v in ipairs(l1)\
    \ do\n        for ii,vv in ipairs(l2) do\n            if v == vv then\n      \
    \          table.insert(t, v)\n            end\n        end\n    end\n    return\
    \ table.unpack(sort(t))\nend", "  local common = {}\n  for _, v in ipairs(l1)\
    \ do\n    for _, v2 in ipairs(l2) do\n      if v == v2 then\n        common[#common\
    \ + 1] = v\n      end\n    end\n  end\n  table.sort(common)\n  return unique(common)\n\
    end", "  return make_set(unpack(intersect(l1, l2)))\nend", "  local keys = {}\n\
    \  local ret = {}\n  for _, v in ipairs(l1) do\n    if not keys[v] then\n    \
    \  keys[v] = true\n    end\n  end\n  for _, v in ipairs(l2) do\n    if keys[v]\
    \ then\n      ret[#ret + 1] = v\n    end\n  end\n  table.sort(ret)\n  return ret\n\
    end", "    return s_uniq(s_sort(l1), s_sort(l2))\nend", "\tlocal t1 = {}\n\tlocal\
    \ t2 = {}\n\tfor _, v in ipairs(l1) do\n\t\tt1[v] = true\n\tend\n\tfor _, v in\
    \ ipairs(l2) do\n\t\tt2[v] = true\n\tend\n\tlocal t = {}\n\tfor k, _ in pairs(t1)\
    \ do\n\t\tif t2[k] then\n\t\t\tt[#t + 1] = k\n\t\tend\n\tend\n\ttable.sort(t)\n\
    \treturn t\nend", "    if not l1 or not l2 then return nil end\n    local l1_len\
    \ = #l1\n    local l2_len = #l2\n    if l1_len == 0 or l2_len == 0 then return\
    \ {} end\n    if l1_len < l2_len then\n        l1, l2 = l2, l1\n        l1_len,\
    \ l2_len = l2_len, l1_len\n    end\n    -- Now l1_len >= l2_len\n    -- A list\
    \ to store the results\n    local set = {}\n    -- Loop over the smaller list\n\
    \    for i = 1, l2_len do\n        local v = l2[i]\n        -- If the value is\
    \ in the larger list, then the value is a common element\n        if idx(l1, v)\
    \ then\n            -- Store the value in the set\n            set[#set + 1] =\
    \ v\n        end\n    end\n    -- Sort the set if needed\n    if options.common_sort\
    \ then\n        sort(set)\n    end\n    return set\nend", "  local r = {}\n  for\
    \ _,v in ipairs(l1) do\n    if contains(l2, v) then\n      r[#r+1] = v\n    end\n\
    \  end\n  return r\nend", "  local d = {}\n  for _, i in ipairs(l1) do\n    if\
    \ table.has(l2, i) then\n      table.insert(d, i)\n    end\n  end\n  return set(d)\n\
    end", "    local set = {}\n    for _, v in ipairs(l1) do\n        set[v] = (set[v]\
    \ or 0) + 1\n    end\n    local common = {}\n    for _, v in ipairs(l2) do\n \
    \       if set[v] and set[v] > 0 then\n            set[v] = set[v] - 1\n     \
    \       table.insert(common, v)\n        end\n    end\n    table.sort(common)\n\
    \    return common\nend", "\tlocal tmp = {}\n\tfor _, v in ipairs(l1) do\n\t\t\
    if table.contains(l2, v) then\n\t\t\ttable.insert(tmp, v)\n\t\tend\n\tend\n\t\
    return table.unique(tmp)\nend", "    local t = {}\n    for _, n in ipairs(l1)\
    \ do\n        if sort.binsearch(l2, n) ~= nil then\n            t[#t + 1] = n\n\
    \        end\n    end\n    return sort.uniq(t)\nend", "    local set = {}\n  \
    \  for _, v in ipairs(l1) do\n        set[v] = true\n    end\n    local ret =\
    \ {}\n    for _, v in ipairs(l2) do\n        if set[v] then\n            set[v]\
    \ = nil\n            table.insert(ret, v)\n        end\n    end\n    return ret\n\
    end", "    local r = {}\n    for i, v in ipairs(l1) do\n        if contains(l2,\
    \ v) then r[#r + 1] = v end\n    end\n    table.sort(r)\n    return r\nend", " \
    \   local seen = {}\n    local k, v, i\n    local result = {}\n    local unique\
    \ = {}\n    for i, v in ipairs(l1) do\n        seen[v] = true\n    end\n    for\
    \ i, v in ipairs(l2) do\n        if seen[v] then\n            if not unique[v]\
    \ then\n                unique[v] = true\n                table.insert(result,\
    \ v)\n            end\n        end\n    end\n    table.sort(result)\n    return\
    \ result\nend", "\tlocal rs = {}\n\tfor _,v in ipairs(l1) do\n\t\tfor _,v2 in\
    \ ipairs(l2) do\n\t\t\tif v == v2 then\n\t\t\t\trs[#rs+1] = v\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn sort_unique(rs)\nend", "  local t = {}\n  for _,v in ipairs(l1)\
    \ do\n    if contains(l2, v) then\n      table.insert(t, v)\n    end\n  end\n\
    \  table.sort(t)\n  return t\nend", "  local common = {}\n  local function append_unique(t,\
    \ l)\n    for i = 1, #l do\n      if not t[l[i]] then\n        t[l[i]] = true\n\
    \        table.insert(common, l[i])\n      end\n    end\n  end\n  append_unique(common,\
    \ l1)\n  append_unique(common, l2)\n  return common\nend", "  local r = {}\n \
    \ for _, v in ipairs(l1) do\n    if contains(l2, v) then r[#r + 1] = v end\n \
    \ end\n  return sort_unique(r)\nend", "    local common_elements = {}\n    local\
    \ l1_elements = {}\n    local l2_elements = {}\n    for _, value in ipairs(l1)\
    \ do\n        l1_elements[value] = true\n    end\n    for _, value in ipairs(l2)\
    \ do\n        l2_elements[value] = true\n    end\n    for value, _ in pairs(l1_elements)\
    \ do\n        if l2_elements[value] then\n            table.insert(common_elements,\
    \ value)\n        end\n    end\n    table.sort(common_elements)\n    return common_elements\n\
    end", "    local ret = {}\n    for _, x in ipairs(l1) do\n        for _, y in\
    \ ipairs(l2) do\n            if x == y then\n                table.insert(ret,\
    \ x)\n            end\n        end\n    end\n    return unique(ret)\nend", " \
    \ local out = {}\n  for _, val in ipairs(l1) do\n    if elem(val, l2) then\n \
    \     out[#out + 1] = val\n    end\n  end\n  sort(out)\n  return unique(out)\n\
    end", "    local c = {}\n    local o = {}\n    for _, v in ipairs(l1) do\n   \
    \     c[v] = true\n    end\n    for _, v in ipairs(l2) do\n        if c[v] then\n\
    \            o[#o + 1] = v\n        end\n    end\n    return sort(unique(o))\n\
    end", "  local t1 = {}\n  local t2 = {}\n  for _, v in ipairs(l1) do\n    t1[v]\
    \ = true\n  end\n  for _, v in ipairs(l2) do\n    t2[v] = true\n  end\n  local\
    \ t = {}\n  for k, _ in pairs(t1) do\n    if t2[k] then\n      t[#t + 1] = k\n\
    \    end\n  end\n  table.sort(t)\n  return t\nend", "    local ret = {}\n    local\
    \ l1_keys = {}\n    local l2_keys = {}\n    for i,v in ipairs(l1) do\n       \
    \ l1_keys[v] = i\n    end\n    for i,v in ipairs(l2) do\n        l2_keys[v] =\
    \ i\n    end\n    for i,v in ipairs(l1) do\n        if l2_keys[v] then table.insert(ret,\
    \ v) end\n    end\n    table.sort(ret)\n    return ret\nend", "\tlocal l_common\
    \ = {}\n\tfor _, el in ipairs(l1) do\n\t\tif contains(l2, el) then\n\t\t\tinsert_ordered(l_common,\
    \ el)\n\t\tend\n\tend\n\treturn l_common\nend", "    local c = {}\n    for _,\
    \ v in ipairs(l1) do if l2[v] then c[v] = true end end\n    local c2 = {}\n  \
    \  for k in pairs(c) do table.insert(c2, k) end\n    table.sort(c2)\n    return\
    \ c2\nend", "  local s = {}\n  for _, v in ipairs(l1) do\n    if table.array_member(l2,\
    \ v) then s[#s+1] = v end\n  end\n  table.sort(s)\n  return s\nend", "    local\
    \ a, b = {}, {}\n    for _, v in ipairs(l1) do a[v] = true end\n    for _, v in\
    \ ipairs(l2) do if a[v] then b[#b+1] = v end end\n    return sort(b)\nend", " \
    \ local ret = {}\n  for _, x in ipairs(l1) do\n    for _, y in ipairs(l2) do\n\
    \      if x == y then\n        ret[#ret + 1] = x\n      end\n    end\n  end\n\
    \  return sort(unique(ret))\nend", "\tlocal s = {}\n\tfor _, l in ipairs{l1, l2}\
    \ do\n\t\tfor _, v in ipairs(l) do\n\t\t\ts[v] = (s[v] or 0) + 1\n\t\tend\n\t\
    end\n\tlocal r = {}\n\tfor k, v in pairs(s) do\n\t\tif v > 1 then\n\t\t\ttable.insert(r,\
    \ k)\n\t\tend\n\tend\n\ttable.sort(r)\n\treturn r\nend", "    local l = {}\n \
    \   for k, v in pairs(l1) do\n        for k2, v2 in pairs(l2) do\n           \
    \ if v == v2 then\n                l[#l + 1] = v\n            end\n        end\n\
    \    end\n    return sorted(uniq(l))\nend", "    local set = {}\n    for _, l\
    \ in ipairs({l1, l2}) do\n        for _, v in ipairs(l) do\n            set[v]\
    \ = (set[v] or 0) + 1\n        end\n    end\n    local common = {}\n    for k,\
    \ v in pairs(set) do\n        if v == 2 then\n            table.insert(common,\
    \ k)\n        end\n    end\n    table.sort(common)\n    return common\nend", " \
    \ if #l1 == 0 or #l2 == 0 then return {} end\n  return list.unique(list.sort(list.intersect(l1,\
    \ l2)))\nend", "    local res = {}\n    for _, n in ipairs(l1) do\n        for\
    \ _, m in ipairs(l2) do\n            if n == m then\n                table.insert(res,\
    \ n)\n            end\n        end\n    end\n    table.sort(res)\n    return uniq(res)\n\
    end", "    if type(l1) ~= 'table' or type(l2) ~= 'table' then\n        error('expected\
    \ tables as arguments', 2)\n    end\n    local s = {}\n    for i = 1, #l1 do\n\
    \        s[l1[i]] = true\n    end\n    local res = {}\n    for i = 1, #l2 do\n\
    \        if s[l2[i]] then\n            res[#res + 1] = l2[i]\n        end\n  \
    \  end\n    sort(res)\n    return res\nend", "    local unique = unique(cat(l1,\
    \ l2))\n    local res = {}\n    for i, v in ipairs(unique) do\n        if index_of(l1,\
    \ v) and index_of(l2, v) then\n            table.insert(res, v)\n        end\n\
    \    end\n    return res\nend", "    local n = {}\n    for _, v in ipairs(l1)\
    \ do\n        if in_table(v, l2) then\n            n[#n + 1] = v\n        end\n\
    \    end\n    return n\nend", "  local unique = unique(union(l1, l2))\n  local\
    \ vals = {}\n  for _, val in ipairs(unique) do\n    if has(l1, val) and has(l2,\
    \ val) then\n      vals[#vals + 1] = val\n    end\n  end\n  return vals\nend",
  "  local t = {}\n  local n = #l1\n  for i = 1, n do\n    t[l1[i]] = i\n  end\n \
    \ local r = {}\n  n = #l2\n  for i = 1, n do\n    if t[l2[i]] then\n      r[#r\
    \ + 1] = l2[i]\n    end\n  end\n  table.sort(r)\n  return r\nend", "    local\
    \ result = {}\n    for _, v in ipairs(l1) do\n        for _, w in ipairs(l2) do\n\
    \            if v == w then\n                result[#result + 1] = v\n       \
    \     end\n        end\n    end\n    table.sort(result)\n    return result\nend",
  "\tlocal t = {}\n\tlocal r = {}\n\tfor i = 1, #l1 do\n\t\tt[l1[i]] = true\n\tend\n\
    \tfor i = 1, #l2 do\n\t\tif t[l2[i]] then\n\t\t\tr[#r + 1] = l2[i]\n\t\tend\n\t\
    end\n\treturn sorted(r)\nend", "  local set = {}\n  local res = {}\n  for _, l\
    \ in ipairs({l1, l2}) do\n    for _, v in ipairs(l) do\n      if not set[v] then\n\
    \        set[v] = true\n        table.insert(res, v)\n      end\n    end\n  end\n\
    \  table.sort(res)\n  return res\nend", "  local result = {}\n  for _, i in ipairs(l1)\
    \ do\n    if utils.contains(l2, i) then\n      table.insert(result, i)\n    end\n\
    \  end\n  return utils.sort_unique(result)\nend", "    local s = {}\n    for _,\
    \ v in ipairs(l1) do\n        s[v] = true\n    end\n    local res = {}\n    for\
    \ _, v in ipairs(l2) do\n        if s[v] then\n            res[#res+1] = v\n \
    \       end\n    end\n    return res\nend", "    local result = {}\n    for _,\
    \ v in ipairs(l1) do\n        if is_in(v, l2) then\n            if not is_in(v,\
    \ result) then\n                table.insert(result, v)\n            end\n   \
    \     end\n    end\n    table.sort(result)\n    return result\nend", "\tlocal\
    \ ret = {}\n\tlocal i, j = 1, 1\n\tlocal len1, len2 = #l1, #l2\n\twhile i <= len1\
    \ and j <= len2 do\n\t\tif l1[i] == l2[j] then\n\t\t\ttable.insert(ret, l1[i])\n\
    \t\t\ti = i + 1\n\t\t\tj = j + 1\n\t\telseif l1[i] < l2[j] then\n\t\t\ti = i +\
    \ 1\n\t\telse\n\t\t\tj = j + 1\n\t\tend\n\tend\n\treturn ret\nend", "    local\
    \ res = {}\n    for _, v in ipairs(l1) do\n        if not res[v] and exists(v,\
    \ l2) then\n            res[v] = true\n        end\n    end\n    local ret = {}\n\
    \    for k, _ in pairs(res) do\n        table.insert(ret, k)\n    end\n    table.sort(ret)\n\
    \    return ret\nend", "    local common = {}\n    for _, v in ipairs(l1) do\n\
    \        if table.hasvalue(l2, v) then\n            table.insert(common, v)\n\
    \        end\n    end\n    return common\nend", "\tlocal t = {}\n\tfor _, v in\
    \ ipairs(l1) do\n\t\tt[v] = (t[v] or 0) + 1\n\tend\n\tlocal ret = {}\n\tfor _,\
    \ v in ipairs(l2) do\n\t\tif t[v] and t[v] > 0 then\n\t\t\tt[v] = t[v] - 1\n\t\
    \t\ttable.insert(ret, v)\n\t\tend\n\tend\n\ttable.sort(ret)\n\treturn ret\nend",
  "    return unique(sort(intersect(l1, l2)))\nend", "  local t1 = list.table(l1)\n\
    \  local t2 = list.table(l2)\n  local t3 = {}\n  for k, v in pairs(t1) do\n  \
    \  if t2[v] then\n      t3[v] = true\n    end\n  end\n  local ret = {}\n  for\
    \ k, v in pairs(t3) do\n    table.insert(ret, k)\n  end\n  table.sort(ret)\n \
    \ return ret\nend", "    -- Initialize common list.\n    local common = {}\n \
    \   -- Iterate through all items in first list.\n    for _, i in ipairs(l1) do\n\
    \        -- Check if item exist in second list.\n        for _, j in ipairs(l2)\
    \ do\n            -- Add new unique item to common list.\n            if i ==\
    \ j and not util.table.hasitem(common, i) then\n                table.insert(common,\
    \ i)\n            end\n        end\n    end\n    -- Return sorted common list.\n\
    \    return util.table.sort(common)\nend", "    local result = {}\n    local m\
    \ = map(l1)\n    for i = 1, #l2 do\n        local v = l2[i]\n        if m[v] then\n\
    \            result[#result + 1] = v\n        end\n    end\n    return sort_uniq(result)\n\
    end", "    local l3 = {}\n    for _, v in ipairs(l1) do\n        if contains(l2,\
    \ v) then\n            l3[#l3 + 1] = v\n        end\n    end\n    table.sort(l3)\n\
    \    return l3\nend", "  local s = {}\n  for _, v in ipairs(l1) do\n    if has(l2,\
    \ v) then\n      s[#s + 1] = v\n    end\n  end\n  return sorted(s)\nend", "  local\
    \ d1, d2 = {}, {}\n  for _, v in ipairs(l1) do d1[v] = true end\n  for _, v in\
    \ ipairs(l2) do d2[v] = true end\n  local res = {}\n  for k, _ in pairs(d1) do\n\
    \    if d2[k] then\n      table.insert(res, k)\n    end\n  end\n  table.sort(res)\n\
    \  return res\nend", "  local tmp = {}\n  local res = {}\n  for i = 1, #l1 do\n\
    \    tmp[l1[i]] = true\n  end\n  for i = 1, #l2 do\n    if tmp[l2[i]] then\n \
    \     table.insert(res, l2[i])\n    end\n  end\n  table.sort(res)\n  return res\n\
    end", "    local table = {}\n    for _, l in ipairs({l1, l2}) do\n        for\
    \ _, v in ipairs(l) do\n            table[v] = (table[v] or 0) + 1\n        end\n\
    \    end\n    local result = {}\n    for k, v in pairs(table) do\n        if v\
    \ == 2 then table.insert(result, k) end\n    end\n    table.sort(result)\n   \
    \ return result\nend", "    local t = {}\n    for _, v in ipairs(l1) do\n    \
    \    t[v] = 1\n    end\n    for _, v in ipairs(l2) do\n        if t[v] then\n\
    \            t[v] = nil\n            table.insert(t, v)\n        end\n    end\n\
    \    return t\nend", "\tlocal s = {}\n\tfor _, v in ipairs(l1) do\n\t\tif contains(l2,\
    \ v) then s[#s+1] = v end\n\tend\n\ttable.sort(s)\n\treturn s\nend", "    local\
    \ res = {}\n    for _, v in ipairs(l1) do\n        if list.has(l2, v) then\n \
    \           res[#res + 1] = v\n        end\n    end\n    return sort(res)\nend",
  "  local t = {}\n  for i = 1, #l1 do\n    local elem = l1[i]\n    if indexOf(l2,\
    \ elem) then\n      t[#t + 1] = elem\n    end\n  end\n  return t\nend", "    local\
    \ res = {}\n    local i1, i2 = 1, 1\n    while i1 <= #l1 and i2 <= #l2 do\n  \
    \      if l1[i1] == l2[i2] then\n            res[#res + 1] = l1[i1]\n        \
    \    i1 = i1 + 1\n            i2 = i2 + 1\n        elseif l1[i1] < l2[i2] then\n\
    \            i1 = i1 + 1\n        else\n            i2 = i2 + 1\n        end\n\
    \    end\n    return res\nend", "\tlocal ret = {}\n\tlocal set = {}\n\tfor _,\
    \ v in ipairs(l1) do\n\t\tset[v] = true\n\tend\n\tfor _, v in ipairs(l2) do\n\t\
    \tif set[v] then\n\t\t\ttable.insert(ret, v)\n\t\tend\n\tend\n\treturn sort(ret)\n\
    end", "    local u = {}\n    local r = {}\n    local v\n    for _, v in ipairs(l1)\
    \ do\n        u[v] = true\n    end\n    for _, v in ipairs(l2) do\n        if\
    \ u[v] then\n            u[v] = nil\n            r[#r + 1] = v\n        end\n\
    \    end\n    return r\nend", "  local res = {}\n  local set = {}\n  local list\
    \ = merge(l1, l2)\n  for i = 1, #list do\n    if not set[list[i]] then\n     \
    \ res[#res + 1] = list[i]\n      set[list[i]] = true\n    end\n  end\n  table.sort(res)\n\
    \  return res\nend", "    local h = {}\n    for _, e in ipairs(l1) do\n      \
    \  h[e] = 1\n    end\n    for _, e in ipairs(l2) do\n        if h[e] then\n  \
    \          h[e] = h[e] + 1\n        end\n    end\n    local res = {}\n    for\
    \ k, v in pairs(h) do\n        if v > 1 then\n            table.insert(res, k)\n\
    \        end\n    end\n    return res\nend", "\tlocal out = {}\n\tfor k, v in\
    \ pairs(l1) do\n\t\tif contains(l2, v) then out[#out + 1] = v end\n\tend\n\treturn\
    \ sort(out)\nend", "    local t = {}\n    for _, v in ipairs(l1) do\n        if\
    \ table.has_value(l2, v) then\n            table.insert(t, v)\n        end\n \
    \   end\n    if #t == 0 then\n        return t\n    end\n    return unique(t)\n\
    end", "  return set(l1, l2)\nend", "    if type(l1) ~= \"table\" or type(l2) ~=\
    \ \"table\" then\n        return {}\n    end\n    local h = {}\n    for _, v in\
    \ ipairs(l1) do\n        h[v] = true\n    end\n    local ret = {}\n    for _,\
    \ v in ipairs(l2) do\n        if h[v] then\n            table.insert(ret, v)\n\
    \        end\n    end\n    table.sort(ret)\n    return ret\nend", "    local lookup\
    \ = {}\n    for _, val in ipairs(l1) do\n        lookup[val] = true\n    end\n\
    \    local result = {}\n    for _, val in ipairs(l2) do\n        if lookup[val]\
    \ then\n            lookup[val] = nil\n            result[#result + 1] = val\n\
    \        end\n    end\n    table.sort(result)\n    return result\nend", "    local\
    \ ret = {}\n    local ret_count = 0\n    for _, i in ipairs(l1) do\n        for\
    \ _, j in ipairs(l2) do\n            if i == j then\n                ret_count\
    \ = ret_count + 1\n                ret[ret_count] = i\n            end\n     \
    \   end\n    end\n    return sort(ret)\nend", "    local t = {}\n    local u =\
    \ {}\n    local dup = 0\n    local dup2 = 0\n    local c = 0\n    for _, v in\
    \ ipairs(l1) do\n        t[v] = t[v] and t[v] + 1 or 1\n    end\n    for _, v\
    \ in ipairs(l2) do\n        u[v] = u[v] and u[v] + 1 or 1\n    end\n    for k,\
    \ v in pairs(t) do\n        if u[k] and v <= u[k] then\n            dup = dup\
    \ + 1\n            if v == u[k] then\n                dup2 = dup2 + 1\n      \
    \      end\n        end\n    end\n    for k, v in pairs(u) do\n        if t[k]\
    \ and v <= t[k] then\n            dup = dup + 1\n            if v == t[k] then\n\
    \                dup2 = dup2 + 1\n            end\n        end\n    end\n    local\
    \ r = {}\n    for k, v in pairs(t) do\n        if u[k] and v <= u[k] then\n  \
    \          table.insert(r, k)\n        end\n    end\n    for k, v in pairs(u)\
    \ do\n        if t[k] and v <= t[k] then\n            table.insert(r, k)\n   \
    \     end\n    end\n    if dup ~= dup2 then\n        return table.sort(r)\n  \
    \  else\n        return r\n    end\nend", "  local c = {}\n  for _, v in ipairs(l1)\
    \ do\n    for _, v2 in ipairs(l2) do\n      if v == v2 then\n        if not contains(c,\
    \ v) then table.insert(c, v) end\n      end\n    end\n  end\n  table.sort(c)\n\
    \  return c\nend", "  local res = {}\n  for _,i in ipairs(l1) do\n    for _,j\
    \ in ipairs(l2) do\n      if i == j then table.insert(res, i) end\n    end\n \
    \ end\n  return table.sort(res)\nend", "    return unique(sort(intersect(l1, l2)))\n\
    end", "    local s = {}\n    for _,v in ipairs(l1) do\n        s[v] = true\n \
    \   end\n    local res = {}\n    for _,v in ipairs(l2) do\n        if s[v] then\n\
    \            res[#res+1] = v\n        end\n    end\n    return sort(res)\nend",
  "    local ret = {}\n    local tmp = {}\n    local l1_len = #l1\n    local l2_len\
    \ = #l2\n    local i = 1\n    local j = 1\n    local e", "  local t = {}\n  for\
    \ i,v in ipairs(l1) do\n    if isin(v, l2) then t[#t+1] = v end\n  end\n  table.sort(t)\n\
    \  return t\nend", "    local out = {}\n    local elements = {}\n    for i, v\
    \ in ipairs(l1) do\n        elements[v] = 1\n    end\n    for i, v in ipairs(l2)\
    \ do\n        if elements[v] then\n            elements[v] = elements[v] + 1\n\
    \        else\n            elements[v] = 1\n        end\n    end\n    for i, v\
    \ in pairs(elements) do\n        if v > 1 then\n            out[#out + 1] = i\n\
    \        end\n    end\n    table.sort(out)\n    return out\nend", "\tlocal t =\
    \ {}\n\tfor _, v in ipairs(l1) do\n\t\tif not t[v] then\n\t\t\tt[v] = true\n\t\
    \tend\n\tend\n\tlocal c = {}\n\tfor _, v in ipairs(l2) do\n\t\tif t[v] then\n\t\
    \t\tc[#c + 1] = v\n\t\tend\n\tend\n\treturn sort(c)\nend", "  return unique(sort(intersect(l1,\
    \ l2)))\nend", "    local r = {}\n    local f = {}\n    local s = {}\n    if type(l1)\
    \ == 'table' and type(l2) == 'table' then\n        for _, v in ipairs(l1) do\n\
    \            r[v] = true\n        end\n        for _, v in ipairs(l2) do\n   \
    \         if r[v] then\n                table.insert(f, v)\n            end\n\
    \        end\n        for _, v in ipairs(f) do\n            s[v] = true\n    \
    \    end\n        for _, v in ipairs(f) do\n            if s[v] then\n       \
    \         table.insert(s, v)\n                s[v] = nil\n            end\n  \
    \      end\n        return s\n    end\nend", "  return sorted_unique(intersect(l1,\
    \ l2))\nend", "\tlocal out = {}\n\tlocal count = 0\n\tfor i = 1, #l1 do\n\t\t\
    for j = 1, #l2 do\n\t\t\tif l1[i] == l2[j] then\n\t\t\t\ttable.insert(out, l1[i])\n\
    \t\t\t\tcount = count + 1\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ out\nend", "  local m = {};\n  for i, v in ipairs(l1) do\n    if contains(l2,\
    \ v) then\n      m[v] = true;\n    end\n  end\n  return sorted(keys(m));\nend",
  "    if #l1 == 0 or #l2 == 0 then\n        return {}\n    end\n    if #l1 == 1 then\n\
    \        for _, v in ipairs(l2) do\n            if v == l1[1] then\n         \
    \       return { v }\n            end\n        end\n        return {}\n    end\n\
    \    if #l2 == 1 then\n        for _, v in ipairs(l1) do\n            if v ==\
    \ l2[1] then\n                return { v }\n            end\n        end\n   \
    \     return {}\n    end\n    local mid1 = math.floor(#l1 / 2)\n    local mid2\
    \ = math.floor(#l2 / 2)\n    if l1[mid1] < l2[mid2] then\n        return common(slice(l1,\
    \ mid1), l2)\n    elseif l1[mid1] > l2[mid2] then\n        return common(l1, slice(l2,\
    \ mid2))\n    else\n        return append(\n            common(slice(l1, mid1),\
    \ slice(l2, mid2)),\n            l1[mid1])\n    end\nend", "    local result =\
    \ {}\n    local isCommon = function(el)\n        for _, e in ipairs(l2) do\n \
    \           if el == e then\n                return true\n            end\n  \
    \      end\n        return false\n    end\n    for _, el in ipairs(l1) do\n  \
    \      if isCommon(el) then\n            table.insert(result, el)\n        end\n\
    \    end\n    table.sort(result)\n    return result\nend", "  local list = {}\n\
    \  for k, v in pairs(l1) do\n    if l2[v] then\n      list[v] = v\n    end\n \
    \ end\n  return list\nend", "    local tab = {}\n    local res = {}\n    for _,\
    \ v in ipairs(l1) do tab[v] = true end\n    for _, v in ipairs(l2) do if tab[v]\
    \ then tab[v] = nil; table.insert(res, v) end end\n    table.sort(res)\n    return\
    \ res\nend", "  local t1 = {}\n  local t2 = {}\n  for _,v in ipairs(l1) do\n \
    \   t1[v] = true\n  end\n  for _,v in ipairs(l2) do\n    t2[v] = true\n  end\n\
    \  local common = {}\n  for k,_ in pairs(t1) do\n    if t2[k] then\n      table.insert(common,\
    \ k)\n    end\n  end\n  table.sort(common)\n  return common\nend", "    -- Checks\
    \ if a list contains the element at index i in l2.\n    local function contains(l1,\
    \ l2, i)\n        for j = 1, #l1 do\n            if l1[j] == l2[i] then\n    \
    \            return true\n            end\n        end\n        return false\n\
    \    end", "    local result = {}\n    local keys = {}\n    for _, v in ipairs(l1)\
    \ do\n        if exists(v, l2) then\n            if not keys[v] then\n       \
    \         table.insert(result, v)\n                keys[v] = true\n          \
    \  end\n        end\n    end\n    return result\nend", "\tif l1 == nil or l2 ==\
    \ nil then\n\t\treturn\n\tend\n\tlocal t = {}\n\tfor _, v in ipairs(l1) do\n\t\
    \tt[v] = true\n\tend\n\tlocal r = {}\n\tfor _, v in ipairs(l2) do\n\t\tif t[v]\
    \ then\n\t\t\tr[#r + 1] = v\n\t\tend\n\tend\n\treturn r\nend", "    local l3 =\
    \ {}\n    for _, v in ipairs(l1) do\n        if includes(l2, v) then\n       \
    \     table.insert(l3, v)\n        end\n    end\n    sort(l3)\n    local i = 1\n\
    \    while i < #l3 do\n        if l3[i] == l3[i + 1] then\n            table.remove(l3,\
    \ i)\n        else\n            i = i + 1\n        end\n    end\n    return l3\n\
    end", "    -- TODO: Implement it.\n    return nil\nend", "    local h = {}\n \
    \   for _, v in ipairs(l1) do\n        h[v] = true\n    end\n    local l = {}\n\
    \    for _, v in ipairs(l2) do\n        if h[v] then\n            l[#l + 1] =\
    \ v\n        end\n    end\n    table.sort(l)\n    return l\nend", "\tlocal c =\
    \ {}\n\tfor i, v in ipairs(l1) do\n\t\tif table.ifind(l2, v) then\n\t\t\ttable.insert(c,\
    \ v)\n\t\tend\n\tend\n\ttable.sort(c)\n\treturn c\nend", "    local common = {}\n\
    \    local hash = {}\n    for _, v in ipairs(l1) do\n        hash[v] = true\n\
    \    end\n    for _, v in ipairs(l2) do\n        if hash[v] then\n           \
    \ common[#common + 1] = v\n        end\n    end\n    if #common > 0 then\n   \
    \     table.sort(common)\n    end\n    return common\nend\n_M.common = common",
  "    local tmp = {}\n    for _, v in ipairs(l1) do\n        tmp[v] = true\n    end\n\
    \    local result = {}\n    for _, v in ipairs(l2) do\n        if tmp[v] then\n\
    \            table.insert(result, v)\n        end\n    end\n    table.sort(result)\n\
    \    return result\nend", "  local res = {}\n  local a1 = {}\n  local a2 = {}\n\
    \  for _, v in ipairs(l1) do\n    a1[v] = true\n  end\n  for _, v in ipairs(l2)\
    \ do\n    a2[v] = true\n  end\n  for k, _ in pairs(a1) do\n    if a2[k] then\n\
    \      res[#res + 1] = k\n    end\n  end\n  table.sort(res)\n  return res\nend",
  "    local res = {}\n    local ix = 1\n    local n1 = #l1\n    local n2 = #l2\n\
    \    local t1 = l1\n    local t2 = l2\n    if n1 > n2 then\n        t1 = l2\n\
    \        t2 = l1\n    end\n    -- n1 < n2\n    for i = 1, n1 do\n        local\
    \ e = t1[i]\n        if elem(e, t2) then\n            res[ix] = e\n          \
    \  ix = ix + 1\n        end\n    end\n    sort(res)\n    return res\nend", " \
    \   local r = {}\n    for _, e in ipairs(l1) do\n        if find(l2, e) then\n\
    \            r[#r + 1] = e\n        end\n    end\n    sort(r)\n    return r\n\
    end", "    local u = union(l1, l2)\n    local r = {}\n    for i, v in ipairs(u)\
    \ do\n        if l1[v] and l2[v] then\n            r[#r + 1] = v\n        end\n\
    \    end\n    return r\nend", "  local common = {}\n  for _, v in ipairs(l1) do\n\
    \    if in_list(v, l2) then\n      table.insert(common, v)\n    end\n  end\n \
    \ return unique(common)\nend", "    local set = {}\n    for i = 1, #l1 do\n  \
    \      set[l1[i]] = true\n    end\n    local out = {}\n    for i = 1, #l2 do\n\
    \        if set[l2[i]] then\n            out[#out + 1] = l2[i]\n        end\n\
    \    end\n    table.sort(out)\n    return out\nend", "    local rv = {}\n    for\
    \ _, v in ipairs(l1) do\n        for _, v2 in ipairs(l2) do\n            if v\
    \ == v2 then\n                table.insert(rv, v)\n            end\n        end\n\
    \    end\n    return uniq(rv)\nend", "  return unique(intersect(l1, l2))\nend",
  "    local t = {}\n    for i = 1, #l1 do\n        for j = 1, #l2 do\n          \
    \  if l1[i] == l2[j] then\n                t[#t + 1] = l1[i]\n            end\n\
    \        end\n    end\n    return sort_unique(t)\nend", "    if #l1 > #l2 then\n\
    \        local tmp = l1\n        l1 = l2\n        l2 = tmp\n    end\n    local\
    \ u_l2 = unique(l2)\n    local res = {}\n    for _, v in ipairs(l1) do\n     \
    \   if contains(u_l2, v) then\n            table.insert(res, v)\n        end\n\
    \    end\n    return sort(res)\nend", "  local seen = {}\n  local res = {}\n \
    \ local op = #l1 < #l2 and ipairs or pairs\n  for _, v in op(l1) do\n    seen[v]\
    \ = true\n  end\n  for _, v in pairs(l2) do\n    if seen[v] then\n      res[#res\
    \ + 1] = v\n    end\n  end\n  return sort_unique(res)\nend", "    local ret =\
    \ {}\n    for _, v in ipairs(l1) do\n        for _, v2 in ipairs(l2) do\n    \
    \        if v == v2 then\n                ret[#ret + 1] = v\n                break\n\
    \            end\n        end\n    end\n    return ret\nend", "  local common\
    \ = {}\n  local t = {}\n  if #l1 == 0 or #l2 == 0 then\n    return common\n  end\n\
    \  for _,v in ipairs(l1) do\n    t[v] = true\n  end\n  for _,v in ipairs(l2) do\n\
    \    if t[v] then\n      common[#common+1] = v\n    end\n  end\n  return common\n\
    end", "    local t = {}\n    local u = {}\n    local i1 = 1\n    local i2 = 1\n\
    \    local l1l = #l1\n    local l2l = #l2\n    while i1 <= l1l and i2 <= l2l do\n\
    \        if l1[i1] == l2[i2] then\n            t[#t + 1] = l1[i1]\n          \
    \  i1 = i1 + 1\n            i2 = i2 + 1\n        elseif l1[i1] < l2[i2] then\n\
    \            i1 = i1 + 1\n        else\n            i2 = i2 + 1\n        end\n\
    \    end\n    return t\nend", "  local l = {}\n  local m = {}\n  local lu = {}\n\
    \  local mn = math.min\n  local mx = math.max\n  local f = function(v)\n    local\
    \ a = l[v]\n    local b = m[v]\n    if a and b then\n      table.insert(lu, v)\n\
    \    end\n  end\n  for i, v in ipairs(l1) do\n    l[v] = true\n  end\n  for i,\
    \ v in ipairs(l2) do\n    m[v] = true\n  end\n  for i, v in ipairs(l1) do\n  \
    \  f(v)\n  end\n  for i, v in ipairs(l2) do\n    f(v)\n  end\n  table.sort(lu)\n\
    \  return lu\nend", "    local t = {}\n    for i = 1, #l1 do\n        for j =\
    \ 1, #l2 do\n            if l1[i] == l2[j] then\n                t[#t + 1] = l1[i]\n\
    \            end\n        end\n    end\n    table.sort(t)\n    local i = 1\n \
    \   while i < #t do\n        if t[i] == t[i + 1] then\n            table.remove(t,\
    \ i)\n        else\n            i = i + 1\n        end\n    end\n    return t\n\
    end", "  local set = {}\n  for _, v in ipairs(l1) do\n    set[v] = true\n  end\n\
    \  local ret = {}\n  for _, v in ipairs(l2) do\n    if set[v] then\n      table.insert(ret,\
    \ v)\n    end\n  end\n  table.sort(ret)\n  return ret\nend", "\tlocal result =\
    \ {}\n\tfor _,v in ipairs(l1) do\n\t\tfor _,v2 in ipairs(l2) do\n\t\t\tif v2 ==\
    \ v then\n\t\t\t\tresult[#result+1] = v\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\
    end\n\tif #result == 0 then\n\t\treturn result\n\tend\n\ttable.sort(result)\n\t\
    return result\nend", "    local res = {}\n    local m = #l1\n    local n = #l2\n\
    \    local i = 1\n    local j = 1\n    while i <= m and j <= n do\n        if\
    \ l1[i] == l2[j] then\n            res[#res + 1] = l1[i]\n            i = i +\
    \ 1\n            j = j + 1\n        elseif l1[i] < l2[j] then\n            i =\
    \ i + 1\n        else\n            j = j + 1\n        end\n    end\n    return\
    \ res\nend", "  local t1 = {}\n  local t2 = {}\n  local sorted = {}\n  local c\
    \ = {}\n  local i = 1\n  local c_i = 1\n  for k, v in pairs(l1) do\n    t1[i]\
    \ = v\n    i = i + 1\n  end\n  for k, v in pairs(l2) do\n    t2[i] = v\n    i\
    \ = i + 1\n  end\n  table.sort(t1)\n  table.sort(t2)\n  for i, v in ipairs(t1)\
    \ do\n    for j, k in ipairs(t2) do\n      if v == k then\n        c[c_i] = v\n\
    \        c_i = c_i + 1\n      end\n    end\n  end\n  return c\nend", "    local\
    \ r = {}\n    local s = {}\n    for _, v in ipairs(l1) do r[v] = true end\n  \
    \  for _, v in ipairs(l2) do if r[v] then s[v] = true end end\n    return sort_unique(keys(s))\n\
    end", "  local r = {}\n  local l = {}\n  for i, v in ipairs(l1) do\n    r[v] =\
    \ (r[v] or 0) + 1\n  end\n  for i, v in ipairs(l2) do\n    if r[v] then\n    \
    \  l[#l + 1] = v\n      r[v] = nil\n    end\n  end\n  return sort(l)\nend", " \
    \   local inter = {}\n    local uniq = {}\n    for _, v in ipairs(l1) do\n   \
    \     if index_of(l2, v) ~= nil then\n            table.insert(inter, v)\n   \
    \     end\n    end\n    for _, v in ipairs(inter) do\n        if index_of(uniq,\
    \ v) == nil then\n            table.insert(uniq, v)\n        end\n    end\n  \
    \  table.sort(uniq)\n    return uniq\nend", "  local l = merge(l1, l2)\n  l =\
    \ unique(l)\n  l = sort(l)\n  return l\nend", "    local set = {}\n    local res\
    \ = {}\n    for _, l in ipairs({l1, l2}) do\n        for _, v in ipairs(l) do\n\
    \            if not set[v] then\n                set[v] = true\n             \
    \   table.insert(res, v)\n            end\n        end\n    end\n    table.sort(res)\n\
    \    return res\nend", "  local t = {}\n  for k, v in pairs(l1) do\n    t[v] =\
    \ true\n  end\n  for k, v in pairs(l2) do\n    if t[v] then\n      t[v] = nil\n\
    \      t[#t + 1] = v\n    end\n  end\n  return t\nend", "    local unique = unique(l1)\n\
    \    local diff = {}\n    for i = 1, #unique do\n        if not list_contains(l2,\
    \ unique[i]) then\n            table.insert(diff, unique[i])\n        end\n  \
    \  end\n    return list_diff(unique, diff)\nend", "\tlocal t = {}\n\tfor _, v\
    \ in ipairs(l1) do\n\t\tif contains(l2, v) then\n\t\t\tif not contains(t, v) then\n\
    \t\t\t\tt[#t + 1] = v\n\t\t\tend\n\t\tend\n\tend\n\treturn sort(t)\nend", "  \
    \  local hash = {}\n    local result = {}\n    local i", "\tlocal common_list\
    \ = {}\n\tlocal unique_list = {}\n\tif #l1 >= #l2 then\n\t\tbig_list = l1\n\t\t\
    small_list = l2\n\telse\n\t\tbig_list = l2\n\t\tsmall_list = l1\n\tend\n\tfor\
    \ _,v in ipairs(small_list) do\n\t\tfor _,v2 in ipairs(big_list) do\n\t\t\tif\
    \ v == v2 then\n\t\t\t\tif unique(v, unique_list) then\n\t\t\t\t\ttable.insert(common_list,\
    \ v)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\ttable.sort(common_list)\n\treturn\
    \ common_list\nend", "  local cl = {}\n  for i = 1, #l1 do\n    for j = 1, #l2\
    \ do\n      if l1[i] == l2[j] then\n        cl[#cl + 1] = l1[i]\n      end\n \
    \   end\n  end\n  return unique(cl)\nend", "    local m = {}\n    for _, v in\
    \ ipairs(l1) do\n        m[v] = true\n    end\n    local l = {}\n    for _, v\
    \ in ipairs(l2) do\n        if m[v] then\n            table.insert(l, v)\n   \
    \     end\n    end\n    table.sort(l)\n    return l\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
