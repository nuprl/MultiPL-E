name: HumanEval_26_remove_duplicates
language: lua
prompt: "-- From a list of integers, remove all elements that occur more than once.\n\
  -- Keep order of elements left the same as in the input.\n-- >>> remove_duplicates([1,\
  \ 2, 3, 2, 4])\n-- [1, 3, 4]\nlocal function remove_duplicates(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = remove_duplicates\n\
  \    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, 2, 3,\
  \ 4}), {1, 2, 3, 4})\n    lu.assertEquals(candidate({1, 2, 3, 2, 4, 3, 5}), {1,\
  \ 4, 5})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local no_duplicates = {}\n    local already_seen = {}\n    for\
    \ _, v in ipairs(numbers) do\n        if not already_seen[v] then\n          \
    \  no_duplicates[#no_duplicates + 1] = v\n            already_seen[v] = true\n\
    \        end\n    end\n    return no_duplicates\nend", "    local result = {}\n\
    \    local duplicates = {}\n    for _,n in ipairs(numbers) do\n        if not\
    \ duplicates[n] then\n            result[#result+1] = n\n            duplicates[n]\
    \ = true\n        end\n    end\n    return result\nend", "    local set = Set()\n\
    \    local result = {}\n    for _, v in ipairs(numbers) do\n        if not set:contains(v)\
    \ then\n            set:add(v)\n            table.insert(result, v)\n        end\n\
    \    end\n    return result\nend", "  local seen = {}\n  local result = {}\n \
    \ for _, n in ipairs(numbers) do\n    if not seen[n] then\n      table.insert(result,\
    \ n)\n      seen[n] = true\n    end\n  end\n  return result\nend", "    local\
    \ numbers_set = {}\n    local non_duplicates = {}\n    for _, number in ipairs(numbers)\
    \ do\n        if not numbers_set[number] then\n            numbers_set[number]\
    \ = true\n            table.insert(non_duplicates, number)\n        end\n    end\n\
    \    return non_duplicates\nend", "    local result = {}\n    local set = {}\n\
    \    for _, n in ipairs(numbers) do\n        if not set[n] then\n            result[#result\
    \ + 1] = n\n            set[n] = true\n        end\n    end\n    return result\n\
    end", "    -- TODO\nend", "    return nub(numbers)\nend", "  local result = {}\n\
    \  local freq = {}\n  for _, number in ipairs(numbers) do\n    freq[number] =\
    \ freq[number] or 0\n    freq[number] = freq[number] + 1\n  end\n  for _, number\
    \ in ipairs(numbers) do\n    if freq[number] == 1 then\n      table.insert(result,\
    \ number)\n    end\n  end\n  return result\nend", "  local seen = {}\n  local\
    \ result = {}\n  for _, n in ipairs(numbers) do\n    if not seen[n] then\n   \
    \   table.insert(result, n)\n      seen[n] = true\n    end\n  end\n  return result\n\
    end", "  return foldl(function(list, number)\n    if count(number, numbers) ==\
    \ 1 then\n      table.insert(list, number)\n    end\n    return list\n  end, {},\
    \ numbers)\nend", "\tlocal ret = {}\n\tlocal uniques = {}\n\tfor _, number in\
    \ ipairs(numbers) do\n\t\tif not uniques[number] then\n\t\t\tuniques[number] =\
    \ true\n\t\t\ttable.insert(ret, number)\n\t\tend\n\tend\n\treturn ret\nend", " \
    \   local used = {}\n    local result = {}\n    for _, v in ipairs(numbers) do\n\
    \        if not used[v] then\n            table.insert(result, v)\n          \
    \  used[v] = true\n        end\n    end\n    return result\nend", "    local unique\
    \ = {}\n    for i, n in ipairs(numbers) do\n        if not unique[n] then\n  \
    \          unique[n] = true\n            numbers[i] = n\n        else\n      \
    \      numbers[i] = nil\n        end\n    end\n    return numbers\nend", "   \
    \ local ret = {}\n    local seen = {}\n    for i = 1, #numbers do\n        local\
    \ num = numbers[i]\n        if not seen[num] then\n            ret[#ret + 1] =\
    \ num\n            seen[num] = true\n        end\n    end\n    return ret\nend",
  "    local seen = {}\n    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        if not seen[number] then\n            seen[number] = true\n    \
    \        table.insert(result, number)\n        end\n    end\n    return result\n\
    end", "    local seen = {}\n    local result = {}\n    for _, v in ipairs(numbers)\
    \ do\n        if not seen[v] then\n            table.insert(result, v)\n     \
    \       seen[v] = true\n        end\n    end\n    return result\nend", "    local\
    \ set = {}\n    local result = {}\n    for _, n in ipairs(numbers) do\n      \
    \  if not set[n] then\n            table.insert(result, n)\n            set[n]\
    \ = true\n        end\n    end\n    return result\nend", "  local seen = {}\n\
    \  local result = {}\n  for _, num in ipairs(numbers) do\n    if not seen[num]\
    \ then\n      table.insert(result, num)\n      seen[num] = true\n    end\n  end\n\
    \  return result\nend", "\tlocal set = {}\n\tlocal res = {}\n\tfor _, v in ipairs(numbers)\
    \ do\n\t\tif not set[v] then\n\t\t\tset[v] = true\n\t\t\ttable.insert(res, v)\n\
    \t\tend\n\tend\n\treturn res\nend", "\tlocal res = {}\n\tlocal have = {}\n\tfor\
    \ _, num in ipairs(numbers) do\n\t\tif not have[num] then\n\t\t\ttable.insert(res,\
    \ num)\n\t\t\thave[num] = true\n\t\tend\n\tend\n\treturn res\nend", "  return\
    \ {}\nend", "    local set = {}\n    local ret = {}\n    for _, num in ipairs(numbers)\
    \ do\n        if not set[num] then\n            set[num] = true\n            table.insert(ret,\
    \ num)\n        end\n    end\n    return ret\nend", "  local seen = {}\n  local\
    \ output = {}\n  for index, number in ipairs(numbers) do\n    if not seen[number]\
    \ then\n      seen[number] = true\n      output[#output + 1] = number\n    end\n\
    \  end\n  return output\nend", "  local seen = {}\n  local result = {}\n  for\
    \ _, number in ipairs(numbers) do\n    if not seen[number] then\n      seen[number]\
    \ = true\n      table.insert(result, number)\n    end\n  end\n  return result\n\
    end", "    local unique = {}\n    for _, number in ipairs(numbers) do\n      \
    \  if not unique[number] then\n            unique[number] = true\n           \
    \ coroutine.yield(number)\n        end\n    end\nend", "\tlocal res = {}\n\tlocal\
    \ record = {}\n\tfor _, value in ipairs(numbers) do\n\t\tif not record[value]\
    \ then\n\t\t\tres[#res + 1] = value\n\t\t\trecord[value] = true\n\t\tend\n\tend\n\
    \treturn res\nend", "\tlocal output = {}\n\tlocal added = {}\n\tfor _, number\
    \ in ipairs(numbers) do\n\t\tif not added[number] then\n\t\t\ttable.insert(output,\
    \ number)\n\t\t\tadded[number] = true\n\t\tend\n\tend\n\treturn output\nend",
  "  -- TODO: implement\n  return numbers\nend", "    local known = {}\n    local\
    \ result = {}\n    for _, number in ipairs(numbers) do\n        if not known[number]\
    \ then\n            result[#result + 1] = number\n            known[number] =\
    \ true\n        end\n    end\n    return result\nend", "    local seen = {}\n\
    \    local result = {}\n    for _, num in ipairs(numbers) do\n        if not seen[num]\
    \ then\n            seen[num] = true\n            table.insert(result, num)\n\
    \        end\n    end\n    return result\nend", "    local function exists(needle,\
    \ haystack)\n        for _, value in ipairs(haystack) do\n            if value\
    \ == needle then\n                return true\n            end\n        end\n\
    \        return false\n    end", "    local unique = {}\n    for _, number in\
    \ ipairs(numbers) do\n        if not unique[number] then\n            unique[number]\
    \ = true\n            coroutine.yield(number)\n        end\n    end\nend", " \
    \   return table.from_array(array.unique(table.to_array(numbers)))\nend", "  local\
    \ result = {}\n  local seen = {}\n  for _, number in ipairs(numbers) do\n    if\
    \ not seen[number] then\n      table.insert(result, number)\n      seen[number]\
    \ = true\n    end\n  end\n  return result\nend", "    local unique = {}\n    for\
    \ _, number in ipairs(numbers) do\n        if unique[number] then\n          \
    \  unique[number] = nil\n        else\n            unique[number] = true\n   \
    \     end\n    end\n    local result = {}\n    for number, _ in pairs(unique)\
    \ do\n        table.insert(result, number)\n    end\n    return result\nend",
  "    local seen = {}\n    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        if not seen[number] then\n            seen[number] = true\n    \
    \        table.insert(result, number)\n        end\n    end\n    return result\n\
    end", "  local occurrences = {}\n  local uniques = {}\n  for _, number in ipairs(numbers)\
    \ do\n    if occurrences[number] then\n      occurrences[number] = occurrences[number]\
    \ + 1\n    else\n      occurrences[number] = 1\n    end\n  end\n  for _, number\
    \ in ipairs(numbers) do\n    if occurrences[number] == 1 then\n      table.insert(uniques,\
    \ number)\n    end\n  end\n  return uniques\nend", "    local seen = {}\n    local\
    \ result = {}\n    for _, num in ipairs(numbers) do\n        if not seen[num]\
    \ then\n            seen[num] = true\n            table.insert(result, num)\n\
    \        end\n    end\n    return result\nend", "    local set = {}\n    local\
    \ res = {}\n    for _,n in ipairs(numbers) do\n        if not set[n] then\n  \
    \          res[#res+1] = n\n            set[n] = true\n        end\n    end\n\
    \    return res\nend", "\tlocal map = {}\n\tlocal result = {}\n\tfor _, n in ipairs(numbers)\
    \ do\n\t\tif not map[n] then\n\t\t\tmap[n] = true\n\t\t\ttable.insert(result,\
    \ n)\n\t\tend\n\tend\n\treturn result\nend", "    local seen = {}\n    local output\
    \ = {}\n    for _, value in ipairs(numbers) do\n        if not seen[value] then\n\
    \            output[#output + 1] = value\n            seen[value] = true\n   \
    \     end\n    end\n    return output\nend", "  if #numbers == 0 then\n    return\
    \ {}\n  end\n  local seen = {}\n  local res = {}\n  for _, element in ipairs(numbers)\
    \ do\n    if not seen[element] then\n      seen[element] = true\n      res[#res\
    \ + 1] = element\n    end\n  end\n  return res\nend", "  local unique = {}\n \
    \ for _, v in ipairs(numbers) do\n    unique[v] = (unique[v] or 0) + 1\n  end\n\
    \  local result = {}\n  for _, v in ipairs(numbers) do\n    if unique[v] == 1\
    \ then\n      table.insert(result, v)\n    end\n  end\n  return result\nend",
  "  local seen = {}\n  for _, v in ipairs(numbers) do\n    if not seen[v] then\n\
    \      seen[v] = true\n    else\n      seen[v] = nil\n    end\n  end\n  local\
    \ result = {}\n  for k, _ in pairs(seen) do\n    table.insert(result, k)\n  end\n\
    \  return result\nend", "    local known = {}\n    local result = {}\n    for\
    \ _, n in ipairs(numbers) do\n        if not known[n] then\n            table.insert(result,\
    \ n)\n            known[n] = true\n        end\n    end\n    return result\nend",
  "    local seen = {}\n    for _, n in ipairs(numbers) do\n        if not seen[n]\
    \ then\n            seen[n] = true\n        else\n            seen[n] = nil\n\
    \        end\n    end\n    local r = {}\n    for k, _ in pairs(seen) do\n    \
    \    table.insert(r, k)\n    end\n    return r\nend", "    local unique = {}\n\
    \    for _, n in ipairs(numbers) do\n        if not unique[n] then\n         \
    \   unique[n] = true\n            coroutine.yield(n)\n        end\n    end\nend",
  "  local result = {}\n  local index = {}\n  for _, number in ipairs(numbers) do\n\
    \    if not index[number] then\n      index[number] = true\n      table.insert(result,\
    \ number)\n    end\n  end\n  return result\nend", "  local result = {}\n  local\
    \ seen = {}\n  for _, value in ipairs(numbers) do\n    if not seen[value] then\n\
    \      table.insert(result, value)\n      seen[value] = true\n    end\n  end\n\
    \  return result\nend", "    local numbers_seen = {}\n    local unique_numbers\
    \ = {}\n    for _, n in ipairs(numbers) do\n        if not numbers_seen[n] then\n\
    \            table.insert(unique_numbers, n)\n            numbers_seen[n] = true\n\
    \        end\n    end\n    return unique_numbers\nend", "    local numbers_no_dupes\
    \ = {}\n    local seen = {}\n    for _, number in ipairs(numbers) do\n       \
    \ if not seen[number] then\n            table.insert(numbers_no_dupes, number)\n\
    \            seen[number] = true\n        end\n    end\n    return numbers_no_dupes\n\
    end", "  local seen = {}\n  local seen_once = {}\n  for i = 1, #numbers do\n \
    \   local num = numbers[i]\n    if seen[num] then\n      seen[num] = 2\n    else\n\
    \      seen[num] = 1\n      seen_once[#seen_once + 1] = num\n    end\n  end\n\
    \  local result = {}\n  for i = 1, #seen_once do\n    local num = seen_once[i]\n\
    \    if seen[num] == 1 then\n      result[#result + 1] = num\n    end\n  end\n\
    \  return result\nend", "  local unique = {}\n  for _, n in ipairs(numbers) do\n\
    \    unique[n] = true\n  end\n  local copy = {}\n  for _, n in ipairs(numbers)\
    \ do\n    if unique[n] then\n      unique[n] = nil\n      table.insert(copy, n)\n\
    \    end\n  end\n  return copy\nend", "  local seen = {}\n  local result = {}\n\
    \  for _, n in ipairs(numbers) do\n    if not seen[n] then\n      seen[n] = true\n\
    \      table.insert(result, n)\n    end\n  end\n  return result\nend", "    local\
    \ unique = {}\n    for _, number in ipairs(numbers) do\n        if unique[number]\
    \ then\n            unique[number] = nil\n        else\n            unique[number]\
    \ = true\n        end\n    end\n    return table.keys(unique)\nend", "    local\
    \ result = {}\n    local prev = 0\n    for _, i in ipairs(numbers) do\n      \
    \  if i ~= prev then\n            result[#result + 1] = i\n        end\n     \
    \   prev = i\n    end\n    return result\nend", "  local seen = {}\n  local output\
    \ = {}\n  for _, n in ipairs(numbers) do\n    if not seen[n] then\n      table.insert(output,\
    \ n)\n      seen[n] = true\n    end\n  end\n  return output\nend", "    local\
    \ checked = {}\n    local result = {}\n    for i = 1, #numbers do\n        local\
    \ n = numbers[i]\n        if not checked[n] then\n            checked[n] = true\n\
    \            result[#result + 1] = n\n        end\n    end\n    return result\n\
    end", "  local seen = {}\n  local result = {}\n  for _, num in ipairs(numbers)\
    \ do\n    if not seen[num] then\n      seen[num] = true\n      table.insert(result,\
    \ num)\n    end\n  end\n  return result\nend", "  local result = {}\n  local seen\
    \ = {}\n  for _, v in ipairs(numbers) do\n    if not seen[v] then\n      result[#result\
    \ + 1] = v\n      seen[v] = true\n    end\n  end\n  return result\nend", "   \
    \ local occurences = {}\n    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        if not occurences[number] then\n            result[#result + 1]\
    \ = number\n            occurences[number] = true\n        end\n    end\n    return\
    \ result\nend", "\tlocal ht = {}\n\tlocal result = {}\n\tfor _, n in ipairs(numbers)\
    \ do\n\t\tif not ht[n] then\n\t\t\tht[n] = true\n\t\t\ttable.insert(result, n)\n\
    \t\tend\n\tend\n\treturn result\nend", "\tlocal no_duplicates = {}\n\tfor _, number\
    \ in ipairs(numbers) do\n\t\tlocal found = false\n\t\tfor i, _ in ipairs(no_duplicates)\
    \ do\n\t\t\tif no_duplicates[i] == number then\n\t\t\t\tfound = true\n\t\t\t\t\
    break\n\t\t\tend\n\t\tend\n\t\tif not found then\n\t\t\ttable.insert(no_duplicates,\
    \ number)\n\t\tend\n\tend\n\treturn no_duplicates\nend", "    local new_numbers\
    \ = {}\n    local already_in = {}\n    for i = 1, #numbers do\n        local number\
    \ = numbers[i]\n        if not already_in[number] then\n            already_in[number]\
    \ = true\n            new_numbers[#new_numbers + 1] = number\n        end\n  \
    \  end\n    return new_numbers\nend", "  return numbers\nend", "    local seen\
    \ = {}\n    local result = {}\n    for _, num in ipairs(numbers) do\n        if\
    \ not seen[num] then\n            seen[num] = true\n            table.insert(result,\
    \ num)\n        end\n    end\n    return result\nend", "    local len = #numbers\n\
    \    local keys = {}\n    local last_key\n    local value\n    local insert_pos\
    \ = 1\n    for i = 1, len do\n        last_key = keys[last_key]\n        value\
    \ = numbers[i]\n        if last_key == value then\n            last_key = nil\n\
    \        else\n            numbers[insert_pos] = value\n            last_key =\
    \ keys[value]\n            keys[value] = insert_pos\n            insert_pos =\
    \ insert_pos + 1\n        end\n    end\n    for i = insert_pos, len do\n     \
    \   numbers[i] = nil\n    end\n    return numbers\nend", "\tlocal seen = {}\n\t\
    for i, n in ipairs(numbers) do\n\t\tif seen[n] then\n\t\t\tnumbers[i] = nil\n\t\
    \telse\n\t\t\tseen[n] = true\n\t\tend\n\tend\n\treturn numbers\nend", "    local\
    \ seen = {}\n    local result = {}\n    for n, nv in ipairs(numbers) do\n    \
    \    if not seen[nv] then\n            table.insert(result, nv)\n            seen[nv]\
    \ = true\n        end\n    end\n    return result\nend", "    local result = {}\n\
    \    local indexes = {}\n    for _, number in ipairs(numbers) do\n        if not\
    \ indexes[number] then\n            result[#result + 1] = number\n           \
    \ indexes[number] = true\n        end\n    end\n    return result\nend", "   \
    \ local set = {}\n    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        if not set[number] then\n            set[number] = true\n      \
    \      table.insert(result, number)\n        end\n    end\n    return result\n\
    end", "  local seen = {}\n  local result = {}\n  for _, i in ipairs(numbers) do\n\
    \    if not seen[i] then\n      table.insert(result, i)\n      seen[i] = true\n\
    \    end\n  end\n  return result\nend", "    local tmp = {}\n    local rtn = {}\n\
    \    for _, value in ipairs(numbers) do\n        if tmp[value] then\n        \
    \    tmp[value] = tmp[value] + 1\n        else\n            tmp[value] = 1\n \
    \       end\n    end\n    for _, value in ipairs(numbers) do\n        if tmp[value]\
    \ == 1 then\n            table.insert(rtn, value)\n        end\n    end\n    return\
    \ rtn\nend", "    local keys = {}\n    local vals = {}\n    for _, v in ipairs(numbers)\
    \ do\n        keys[v] = (keys[v] or 0) + 1\n        if keys[v] == 1 then\n   \
    \         table.insert(vals, v)\n        end\n    end\n    return vals\nend",
  "  local unique = {}\n  for _, number in ipairs(numbers) do\n    unique[number]\
    \ = true\n  end\n  return keys(unique)\nend", "    local uniques = {}\n    local\
    \ seen = {}\n    for _, num in ipairs(numbers) do\n        if not seen[num] then\n\
    \            uniques[#uniques + 1] = num\n            seen[num] = true\n     \
    \   end\n    end\n    return uniques\nend", "  local seen = {}\n  local result\
    \ = {}\n  for _, n in ipairs(numbers) do\n    if not seen[n] then\n      table.insert(result,\
    \ n)\n      seen[n] = true\n    end\n  end\n  return result\nend", "\tlocal length\
    \ = #numbers\n\tlocal set = {}\n\tlocal result = {}\n\tfor i = 1, length do\n\t\
    \tlocal num = numbers[i]\n\t\tif not set[num] then\n\t\t\tresult[#result + 1]\
    \ = num\n\t\t\tset[num] = true\n\t\tend\n\tend\n\treturn result\nend", "    local\
    \ unique = {}\n    for _,number in ipairs(numbers) do\n        if not unique[number]\
    \ then\n            unique[number] = true\n            table.insert(unique, number)\n\
    \        end\n    end\n    return unique\nend", "  -- idx is a table where each\
    \ index holds a list of all the input numbers seen\n  -- so far with that value.\n\
    \  local idx = {}\n  local ret = {}\n  for i, n in ipairs(numbers) do\n    --\
    \ If we've seen this number before, then mark it as nil\n    if idx[n] then\n\
    \      numbers[i] = nil\n    else\n      idx[n] = true\n      ret[#ret+1] = n\n\
    \    end\n  end\n  return ret\nend", "    local seen = {}\n    local result =\
    \ {}\n    for _, number in ipairs(numbers) do\n        if not seen[number] then\n\
    \            seen[number] = true\n            table.insert(result, number)\n \
    \       end\n    end\n    return result\nend", "    local set = Set(numbers)\n\
    \    local list = {}\n    for _, v in pairs(set.items) do\n        table.insert(list,\
    \ v)\n    end\n    return list\nend", "    local table = {}\n    local result\
    \ = {}\n    for _, v in ipairs(numbers) do\n        if table[v] == nil then\n\
    \            table[v] = true\n            table.insert(result, v)\n        end\n\
    \    end\n    return result\nend", "    local seen = {}\n    local result = {}\n\
    \    for _, v in ipairs(numbers) do\n        if not seen[v] then\n           \
    \ table.insert(result, v)\n            seen[v] = true\n        end\n    end\n\
    \    return result\nend", "    local found = {}\n    local result = {}\n    for\
    \ _,v in ipairs(numbers) do\n        if not found[v] then\n            table.insert(result,\
    \ v)\n            found[v] = true\n        end\n    end\n    return result\nend",
  "    -- Use a table for fast checking of membership.\n    local seen = {}\n    local\
    \ unique = {}\n    for _, number in ipairs(numbers) do\n        if not seen[number]\
    \ then\n            table.insert(unique, number)\n            seen[number] = true\n\
    \        end\n    end\n    return unique\nend", "    local result = {}\n    local\
    \ added = {}\n    for i, n in ipairs(numbers) do\n        if not added[n] then\n\
    \            result[#result + 1] = n\n            added[n] = true\n        end\n\
    \    end\n    return result\nend", "  local seen = {}\n  local output = {}\n \
    \ for _,x in ipairs(numbers) do\n    if not seen[x] then\n      table.insert(output,\
    \ x)\n      seen[x] = true\n    end\n  end\n  return output\nend", "  local seen\
    \ = {}\n  local function add_unique(v)\n    if not seen[v] then\n      seen[v]\
    \ = true\n      return true\n    end\n  end\n  return filter(add_unique, numbers)\n\
    end", "  local hash = {}\n  local result = {}\n  for _, i in ipairs(numbers) do\n\
    \    if not hash[i] then\n      hash[i] = true\n      table.insert(result, i)\n\
    \    end\n  end\n  return result\nend", "  local result = {}\n  local count =\
    \ {}\n  for i, n in ipairs(numbers) do\n    if count[n] == nil then\n      count[n]\
    \ = 0\n    end\n    count[n] = count[n] + 1\n    if count[n] == 1 then\n     \
    \ table.insert(result, n)\n    end\n  end\n  return result\nend", "\tlocal unique\
    \ = {}\n\tfor _, num in ipairs(numbers) do\n\t\tunique[num] = true\n\tend\n\t\
    local result = {}\n\tfor _, num in ipairs(numbers) do\n\t\tif unique[num] then\n\
    \t\t\ttable.insert(result, num)\n\t\t\tunique[num] = false\n\t\tend\n\tend\n\t\
    return result\nend", "\t-- TODO\nend", "  -- I take it the order matters?\n  local\
    \ ordered = {}\n  local unordered = {}\n  local result = {}\n  for _, v in ipairs(numbers)\
    \ do\n    if unordered[v] == nil then\n      ordered[#ordered + 1] = v\n     \
    \ unordered[v] = true\n    end\n  end\n  return ordered\nend", "    local uniques\
    \ = {}\n    local no_dups = {}\n    for _, n in ipairs(numbers) do\n        if\
    \ not uniques[n] then\n            uniques[n] = true\n            table.insert(no_dups,\
    \ n)\n        end\n    end\n    return no_dups\nend", "  local processed = {}\n\
    \  local not_occured = {}\n  for i, v in ipairs(numbers) do\n    if not processed[v]\
    \ then\n      table.insert(not_occured, v)\n      processed[v] = true\n    end\n\
    \  end\n  return not_occured\nend", "  local unique = {}\n  for _, v in ipairs(numbers)\
    \ do\n    unique[v] = true\n  end\n  local res = {}\n  for _, v in ipairs(numbers)\
    \ do\n    if unique[v] then\n      res[#res + 1] = v\n      unique[v] = nil\n\
    \    end\n  end\n  return res\nend", "    local seen = {}\n    local result =\
    \ {}\n    for _, num in ipairs(numbers) do\n        if not seen[num] then\n  \
    \          table.insert(result, num)\n            seen[num] = true\n        end\n\
    \    end\n    return result\nend", "    local set = {}\n    local result = {}\n\
    \    for _, num in ipairs(numbers) do\n        if not set[num] then\n        \
    \    table.insert(result, num)\n            set[num] = true\n        end\n   \
    \ end\n    return result\nend", "  local result = {}\n  local dict = {}\n  for\
    \ _, n in ipairs(numbers) do\n    if not dict[n] then\n      dict[n] = true\n\
    \      table.insert(result, n)\n    end\n  end\n  return result\nend", "    local\
    \ seen = {}\n    local unique = {}\n    for _, value in ipairs(numbers) do\n \
    \       if not seen[value] then\n            table.insert(unique, value)\n   \
    \         seen[value] = true\n        end\n    end\n    return unique\nend", " \
    \   local unique = {}\n    for _, n in ipairs(numbers) do\n        if not unique[n]\
    \ then\n            unique[n] = true\n            coroutine.yield(n)\n       \
    \ end\n    end\nend", "    local set = {}\n    local result = {}\n    for i, v\
    \ in ipairs(numbers) do\n        if not set[v] then\n            result[#result\
    \ + 1] = v\n            set[v] = true\n        end\n    end\n    return result\n\
    end", "    local i = 1\n    while i <= #numbers do\n        if utils.contains(numbers,\
    \ numbers[i], i + 1) then\n            table.remove(numbers, i)\n        else\n\
    \            i = i + 1\n        end\n    end\n    return numbers\nend", "    local\
    \ seen = {}\n    local result = {}\n    for _, n in ipairs(numbers) do\n     \
    \   if not seen[n] then\n            table.insert(result, n)\n            seen[n]\
    \ = true\n        end\n    end\n    return result\nend", "    local found = {}\n\
    \    local unique = {}\n    for _, number in ipairs(numbers) do\n        if not\
    \ found[number] then\n            unique[#unique + 1] = number\n            found[number]\
    \ = true\n        end\n    end\n    return unique\nend", "  local set = {}\n \
    \ local result = {}\n  for _, v in ipairs(numbers) do\n    if not set[v] then\n\
    \      table.insert(result, v)\n      set[v] = true\n    end\n  end\n  return\
    \ result\nend", "\tlocal unique = {}\n\tfor _, n in ipairs(numbers) do\n\t\tif\
    \ not unique[n] then\n\t\t\tunique[n] = true\n\t\t\tcoroutine.yield(n)\n\t\tend\n\
    \tend\nend\nassert(table.concat(remove_duplicates {}, \",\") == \"\")\nassert(table.concat(remove_duplicates\
    \ {1}, \",\") == \"1\")\nassert(table.concat(remove_duplicates {1, 2, 3, 2, 4},\
    \ \",\") == \"1,3,4\")", "    local ret = {}\n    local seen = {}\n    for _,\
    \ n in ipairs(numbers) do\n        if not seen[n] then\n            ret[#ret +\
    \ 1] = n\n            seen[n] = true\n        end\n    end\n    return ret\nend",
  "  local known = {}\n  local result = {}\n  for index, number in ipairs(numbers)\
    \ do\n    if not known[number] then\n      table.insert(result, number)\n    \
    \  known[number] = true\n    end\n  end\n  return result\nend", "  local seen\
    \ = {}\n  local result = {}\n  for i, number in ipairs(numbers) do\n    if not\
    \ seen[number] then\n      table.insert(result, number)\n      seen[number] =\
    \ true\n    end\n  end\n  return result\nend", "\tlocal counts = {}\n\tfor i =\
    \ 1, #numbers do\n\t\tcounts[numbers[i]] = (counts[numbers[i]] or 0) + 1\n\tend\n\
    \tlocal result = {}\n\tfor i = 1, #numbers do\n\t\tif counts[numbers[i]] == 1\
    \ then\n\t\t\tresult[#result + 1] = numbers[i]\n\t\tend\n\tend\n\treturn result\n\
    end", "    local result = {}\n    local seen = {}\n    for i = 1, #numbers do\n\
    \        local n = numbers[i]\n        if not seen[n] then\n            table.insert(result,\
    \ n)\n            seen[n] = true\n        end\n    end\n    return result\nend",
  "\tlocal hash = {}\n\tlocal list = {}\n\tfor _, n in ipairs(numbers) do\n\t\tif\
    \ not hash[n] then\n\t\t\thash[n] = true\n\t\t\ttable.insert(list, n)\n\t\tend\n\
    \tend\n\treturn list\nend", "    return niltable(reduce(numbers, function(acc,\
    \ n)\n        local keep = acc[n] == nil\n        acc[n] = true\n        return\
    \ acc, keep and n or nil\n    end))\nend", "    local seen = {}\n    local result\
    \ = {}\n    for _, element in ipairs(numbers) do\n        if not seen[element]\
    \ then\n            seen[element] = true\n            table.insert(result, element)\n\
    \        end\n    end\n    return result\nend", "    -- Keep track of occurrences\
    \ in a dict\n    local occurrences = {}\n    for _, n in ipairs(numbers) do\n\
    \        local _ = occurrences[n] or 0\n        occurrences[n] = occurrences[n]\
    \ + 1\n    end", "  local visited = {}\n  local result = {}\n  for _, number in\
    \ ipairs(numbers) do\n    if not visited[number] then\n      table.insert(result,\
    \ number)\n      visited[number] = true\n    end\n  end\n  return result\nend",
  "    local seen = {}\n    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        if not seen[number] then\n            table.insert(result, number)\n\
    \            seen[number] = true\n        end\n    end\n    return result\nend",
  "    local result = {}\n    local seen = {}\n    for _, number in ipairs(numbers)\
    \ do\n        if not seen[number] then\n            table.insert(result, number)\n\
    \            seen[number] = true\n        end\n    end\n    return result\nend",
  "    local found_set = {}\n    local unique_numbers = {}\n    for _, value in ipairs(numbers)\
    \ do\n        if found_set[value] == nil then\n            unique_numbers[#unique_numbers\
    \ + 1] = value\n            found_set[value] = true\n        end\n    end\n  \
    \  return unique_numbers\nend", "\tlocal res = {}\n\tlocal flags = {}\n\tfor _,\
    \ number in ipairs(numbers) do\n\t\tif not flags[number] then\n\t\t\ttable.insert(res,\
    \ number)\n\t\t\tflags[number] = true\n\t\tend\n\tend\n\treturn res\nend", " \
    \ local no_duplicates = {}\n  local hash = {}\n  for _, number in ipairs(numbers)\
    \ do\n    if not hash[number] then\n      hash[number] = true\n      table.insert(no_duplicates,\
    \ number)\n    end\n  end\n  return no_duplicates\nend", "    local already_seen\
    \ = {}\n    local not_duplicates = {}\n    for _,number in ipairs(numbers) do\n\
    \        if not already_seen[number] then\n            table.insert(not_duplicates,\
    \ number)\n            already_seen[number] = true\n        end\n    end\n   \
    \ return not_duplicates\nend", "    local checked = {}\n    local duplicates =\
    \ {}\n    local result = {}\n    for i, n in ipairs(numbers) do\n        if not\
    \ checked[n] then\n            checked[n] = true\n        else\n            duplicates[n]\
    \ = true\n        end\n    end\n    for i, n in ipairs(numbers) do\n        if\
    \ not duplicates[n] then\n            table.insert(result, n)\n        end\n \
    \   end\n    return result\nend", "  local seen = {}\n  local result = {}\n  for\
    \ _, n in ipairs(numbers) do\n    if not seen[n] then\n      table.insert(result,\
    \ n)\n      seen[n] = true\n    end\n  end\n  return result\nend", "  local result\
    \ = {}\n  local seen = {}\n  for _, number in ipairs(numbers) do\n    if not seen[number]\
    \ then\n      result[#result + 1] = number\n      seen[number] = true\n    end\n\
    \  end\n  return result\nend", "\tlocal unique = {}\n\tlocal unique_result = {}\n\
    \tfor _, num in ipairs(numbers) do\n\t\tif not unique[num] then\n\t\t\tunique[num]\
    \ = true\n\t\t\ttable.insert(unique_result, num)\n\t\tend\n\tend\n\treturn unique_result\n\
    end", "    local result = {}\n    local table = {}\n    for _, n in ipairs(numbers)\
    \ do\n        if not table[n] then\n            table[n] = true\n            result[#result\
    \ + 1] = n\n        end\n    end\n    return result\nend", "    local seen = {}\n\
    \    local result = {}\n    for _, item in ipairs(numbers) do\n        if not\
    \ seen[item] then\n            seen[item] = true\n            table.insert(result,\
    \ item)\n        end\n    end\n    return result\nend", "  local copy = {}\n \
    \ for _, number in ipairs(numbers) do\n    copy[number] = true\n  end\n  local\
    \ result = {}\n  for _, number in ipairs(numbers) do\n    if copy[number] then\n\
    \      table.insert(result, number)\n      copy[number] = false\n    end\n  end\n\
    \  return result\nend", "    local seen = {}\n    local dupes = {}\n    for _,\
    \ number in ipairs(numbers) do\n        if seen[number] then\n            dupes[number]\
    \ = true\n        else\n            seen[number] = true\n        end\n    end\n\
    \    local result = {}\n    for _, number in ipairs(numbers) do\n        if not\
    \ dupes[number] then\n            table.insert(result, number)\n        end\n\
    \    end\n    return result\nend", "    local result = {}\n    local value_counts\
    \ = {}\n    for _, value in ipairs(numbers) do\n        if value_counts[value]\
    \ then\n            value_counts[value] = value_counts[value] + 1\n        else\n\
    \            value_counts[value] = 1\n        end\n    end\n    for _, value in\
    \ ipairs(numbers) do\n        if value_counts[value] == 1 then\n            table.insert(result,\
    \ value)\n        end\n    end\n    return result\nend", "    local seen = {}\n\
    \    local result = {}\n    for _, n in ipairs(numbers) do\n        if not seen[n]\
    \ then\n            table.insert(result, n)\n            seen[n] = true\n    \
    \    end\n    end\n    return result\nend", "    local res = {}\n    local cache\
    \ = {}\n    for _, number in ipairs(numbers) do\n        if not cache[number]\
    \ then\n            cache[number] = true\n            table.insert(res, number)\n\
    \        end\n    end\n    return res\nend", "  local nset = set.new(numbers)\n\
    \  local uniques = {}\n  for n in values(nset) do\n    uniques[#uniques + 1] =\
    \ n\n  end\n  return uniques\nend", "    -- first we need to create a map from\
    \ all the numbers to their counts.\n    local counts = {}\n    for i = 1, #numbers\
    \ do\n        local number = numbers[i]\n        counts[number] = (counts[number]\
    \ or 0) + 1\n    end", "    local unique = {}\n    for _, n in ipairs(numbers)\
    \ do\n        if unique[n] then\n            unique[n] = nil\n        else\n \
    \           unique[n] = true\n        end\n    end\n    local result = {}\n  \
    \  for k, _ in pairs(unique) do\n        table.insert(result, k)\n    end\n  \
    \  return result\nend", "  local t = {}\n  for _, number in ipairs(numbers) do\n\
    \    t[number] = (t[number] or 0) + 1\n  end\n  local out = {}\n  for _, number\
    \ in ipairs(numbers) do\n    if t[number] == 1 then\n      table.insert(out, number)\n\
    \    end\n  end\n  return out\nend", "    local list = {}\n    for _, number in\
    \ ipairs(numbers) do\n        if list[number] == nil then\n            list[number]\
    \ = true\n        else\n            list[number] = nil\n        end\n    end\n\
    \    local result = {}\n    for number, _ in pairs(list) do\n        table.insert(result,\
    \ number)\n    end\n    return result\nend", "    local dict = {}\n    local output\
    \ = {}\n    for i = 1, #numbers do\n        local num = numbers[i]\n        if\
    \ dict[num] == nil then\n            dict[num] = 1\n            output[#output\
    \ + 1] = num\n        end\n    end\n    return output\nend", "  local unique =\
    \ {}\n  for _, number in ipairs(numbers) do\n    unique[number] = (unique[number]\
    \ or 0) + 1\n  end\n  local result = {}\n  for _, number in ipairs(numbers) do\n\
    \    if unique[number] == 1 then\n      table.insert(result, number)\n    end\n\
    \  end\n  return result\nend", "    local number_occurrences = {}\n    for _,\
    \ number in ipairs(numbers) do\n        if number_occurrences[number] then\n \
    \           number_occurrences[number] = number_occurrences[number] + 1\n    \
    \    else\n            number_occurrences[number] = 1\n        end\n    end\n\
    \    local result = {}\n    for _, number in ipairs(numbers) do\n        if number_occurrences[number]\
    \ == 1 then\n            table.insert(result, number)\n        end\n    end\n\
    \    return result\nend", "\tlocal hash = {}\n\tlocal duplicates = {}\n\tlocal\
    \ result = {}\n\tfor _, value in ipairs(numbers) do\n\t\tif hash[value] then\n\
    \t\t\tduplicates[value] = true\n\t\telse\n\t\t\thash[value] = true\n\t\tend\n\t\
    end\n\tfor _, value in ipairs(numbers) do\n\t\tif not duplicates[value] then\n\
    \t\t\ttable.insert(result, value)\n\t\tend\n\tend\n\treturn result\nend", "  --\
    \ First, we build a reverse index with keys being the numbers and values being\n\
    \  -- the count of this number in the input list.\n  local count = {}\n  for _,\
    \ number in ipairs(numbers) do\n    count[number] = (count[number] or 0) + 1\n\
    \  end\n  -- Then, we iterate on the input list and only keep an item if its count\n\
    \  -- is 1. Otherwise, we ignore it.\n  local result = {}\n  for _, number in\
    \ ipairs(numbers) do\n    if count[number] == 1 then\n      table.insert(result,\
    \ number)\n    end\n  end\n  return result\nend", "\tlocal seen = {}\n\tlocal\
    \ remove = {}\n\tfor k, v in ipairs(numbers) do\n\t\tif seen[v] then\n\t\t\ttable.insert(remove,\
    \ k)\n\t\telse\n\t\t\tseen[v] = true\n\t\tend\n\tend\n\ttable.sort(remove, function(a,\
    \ b) return a > b end)\n\tfor _, v in ipairs(remove) do\n\t\ttable.remove(numbers,\
    \ v)\n\tend\n\treturn numbers\nend", "    local seen = {}\n    local result =\
    \ {}\n    for _, number in ipairs(numbers) do\n        if not seen[number] then\n\
    \            seen[number] = true\n            table.insert(result, number)\n \
    \       end\n    end\n    return result\nend", "    local r = {}\n    local duplicates\
    \ = {}\n    for _, number in ipairs(numbers) do\n        if r[number] then\n \
    \           duplicates[number] = true\n        else\n            r[number] = true\n\
    \        end\n    end\n    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        if not duplicates[number] then\n            table.insert(result,\
    \ number)\n        end\n    end\n    return result\nend", "  local seen = {}\n\
    \  local result = {}\n  for _, number in ipairs(numbers) do\n    if not seen[number]\
    \ then\n      table.insert(result, number)\n      seen[number] = true\n    end\n\
    \  end\n  return result\nend", "  local used = {}\n  local result = {}\n  for\
    \ _, number in ipairs(numbers) do\n    if not used[number] then\n      result[#result\
    \ + 1] = number\n      used[number] = true\n    end\n  end\n  return result\n\
    end", "    local freq = {}\n    for i = 1, #numbers do\n        freq[numbers[i]]\
    \ = (freq[numbers[i]] or 0) + 1\n    end\n    local ret = {}\n    for i = 1, #numbers\
    \ do\n        if freq[numbers[i]] == 1 then\n            ret[#ret + 1] = numbers[i]\n\
    \        end\n    end\n    return ret\nend", "    local no_duplicates = {}\n \
    \   local duplicates = {}\n    for _, n in ipairs(numbers) do\n        if duplicates[n]\
    \ then\n            -- Duplicate number, do nothing\n        elseif no_duplicates[n]\
    \ then\n            duplicates[n] = true\n            table.insert(no_duplicates,\
    \ n)\n        else\n            no_duplicates[n] = true\n            table.insert(no_duplicates,\
    \ n)\n        end\n    end\n    return no_duplicates\nend", "\tlocal result =\
    \ {}\n\tlocal hash = {}\n\tfor _, number in ipairs(numbers) do\n\t\tif not hash[number]\
    \ then\n\t\t\ttable.insert(result, number)\n\t\t\thash[number] = true\n\t\tend\n\
    \tend\n\treturn result\nend", "  local seen = {}\n  local result = {}\n  for _,\
    \ n in ipairs(numbers) do\n    if not seen[n] then\n      seen[n] = true\n   \
    \   table.insert(result, n)\n    end\n  end\n  return result\nend", "  -- TODO:\
    \ Replace the body of this function to make the test pass.\n  return {}\nend",
  "\tlocal unique = {}\n\tfor i,v in ipairs(numbers) do\n\t\tunique[v] = (unique[v]\
    \ or 0) + 1\n\tend\n\tlocal uniq_count = 0\n\tfor k,v in pairs(unique) do\n\t\t\
    if v == 1 then\n\t\t\tuniq_count = uniq_count + 1\n\t\tend\n\tend\n\tlocal res\
    \ = {}\n\tlocal j = 1\n\tfor i,v in ipairs(numbers) do\n\t\tif unique[v] == 1\
    \ then\n\t\t\tres[j] = v\n\t\t\tj = j + 1\n\t\tend\n\tend\n\treturn res\nend",
  "  local seen = {}\n  local result = {}\n  for _, n in ipairs(numbers) do\n    if\
    \ not seen[n] then\n      table.insert(result, n)\n      seen[n] = true\n    end\n\
    \  end\n  return result\nend", "    local known = {}\n    local pos = 1\n    for\
    \ _, num in ipairs(numbers) do\n        if not known[num] then\n            numbers[pos]\
    \ = num\n            pos = pos + 1\n            known[num] = true\n        end\n\
    \    end\n    return numbers\nend", "    local dict = {}\n    local list = {}\n\
    \    for _, number in ipairs(numbers) do\n        if not dict[number] then\n \
    \           table.insert(list, number)\n            dict[number] = true\n    \
    \    end\n    end\n    return list\nend", "\t-- Check if given arguments are of\
    \ the proper type.\n\tif (type(numbers) ~= \"table\") then\n\t\terror(\"bad argument\
    \ #1 to 'remove_duplicates' (table expected, got \" .. type(numbers) .. \")\"\
    , 2)\n\tend", "    local cache = {}\n    local result = {}\n    for _, n in ipairs(numbers)\
    \ do\n        if not cache[n] then\n            cache[n] = true\n            table.insert(result,\
    \ n)\n        end\n    end\n    return result\nend", "    local unique = {}\n\
    \    for _,number in ipairs(numbers) do\n        if not unique[number] then\n\
    \            unique[number] = true\n            coroutine.yield(number)\n    \
    \    end\n    end\nend", "  local u = {}\n  local r = {}\n  for _, v in ipairs(numbers)\
    \ do\n    if not u[v] then\n      u[v] = true\n      r[#r + 1] = v\n    end\n\
    \  end\n  return r\nend", "    local keys = {}\n    local result = {}\n    for\
    \ _, i in ipairs(numbers) do\n        if not keys[i] then\n            result[#result\
    \ + 1] = i\n            keys[i] = true\n        end\n    end\n    return result\n\
    end", "    local seen = {}\n    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        if not seen[number] then\n            table.insert(result, number)\n\
    \            seen[number] = true\n        end\n    end\n    return result\nend",
  "  local unique = {}\n  for _, n in ipairs(numbers) do\n    unique[n] = true\n \
    \ end\n  return util.list_from_dict(unique)\nend", "  local result = {}\n  local\
    \ has_seen = {}\n  for _, number in ipairs(numbers) do\n    if not has_seen[number]\
    \ then\n      result[#result + 1] = number\n      has_seen[number] = true\n  \
    \  end\n  end\n  return result\nend", "    local seen = {}\n    local unique =\
    \ {}\n    for _, value in ipairs(numbers) do\n        if not seen[value] then\n\
    \            unique[#unique + 1] = value\n            seen[value] = true\n   \
    \     end\n    end\n    return unique\nend", "    local result = {}\n    local\
    \ seen = {}\n    for _, number in ipairs(numbers) do\n        if not seen[number]\
    \ then\n            table.insert(result, number)\n            seen[number] = true\n\
    \        end\n    end\n    return result\nend", "    local visited = {}\n    local\
    \ result = {}\n    for k,v in ipairs(numbers) do\n        if not visited[v] then\n\
    \            table.insert(result, v)\n            visited[v] = true\n        end\n\
    \    end\n    return result\nend", "  local result = {}\n  local found = {}\n\
    \  for _, n in ipairs(numbers) do\n    if not found[n] then\n      result[#result\
    \ + 1] = n\n      found[n] = true\n    end\n  end\n  return result\nend", "  --\
    \ TODO: return list of unique numbers\n  if #numbers == 0 then\n    return {}\n\
    \  end\n  local result = {}\n  local prev = numbers[1]\n  local ocurr = { prev\
    \ }\n  for i = 2, #numbers do\n    local curr = numbers[i]\n    if prev == curr\
    \ then\n      table.insert(ocurr, curr)\n    else\n      if #ocurr == 1 then\n\
    \        table.insert(result, ocurr[1])\n      end\n      ocurr = { curr }\n \
    \   end\n    prev = curr\n  end\n  if #ocurr == 1 then\n    table.insert(result,\
    \ ocurr[1])\n  end\n  return result\nend", "    local ret = {}\n    local seen\
    \ = {}\n    for _, n in ipairs(numbers) do\n        if not seen[n] then\n    \
    \        ret[#ret + 1] = n\n            seen[n] = true\n        end\n    end\n\
    \    return ret\nend", "    local output = {}\n    local seen = {}\n    for _,\
    \ v in ipairs(numbers) do\n        if not seen[v] then\n            table.insert(output,\
    \ v)\n            seen[v] = true\n        end\n    end\n    return output\nend",
  "    local no_duplicates = {}\n    local duplicates = {}\n    for _, v in ipairs(numbers)\
    \ do\n        if no_duplicates[v] then\n            duplicates[v] = true\n   \
    \     else\n            no_duplicates[v] = true\n        end\n    end\n    local\
    \ result = {}\n    for _, v in ipairs(numbers) do\n        if not duplicates[v]\
    \ then\n            table.insert(result, v)\n        end\n    end\n    return\
    \ result\nend", "    local results = {}\n    local checked = {}\n    for _, number\
    \ in ipairs(numbers) do\n        if not checked[number] then\n            checked[number]\
    \ = true\n            table.insert(results, number)\n        end\n    end\n  \
    \  return results\nend", "    local lookup = {}\n    local result = {}\n    for\
    \ _, v in ipairs(numbers) do\n        if not lookup[v] then\n            table.insert(result,\
    \ v)\n            lookup[v] = true\n        end\n    end\n    return result\n\
    end", "    return map(numbers, function(x) return x end)\nend", "\tlocal seen\
    \ = {}\n\tlocal n_duplicates = 0\n\tlocal n = #numbers\n\tfor i = 1, n do\n\t\t\
    local value = numbers[i]\n\t\tif seen[value] then\n\t\t\tn_duplicates = n_duplicates\
    \ + 1\n\t\telse\n\t\t\tseen[value] = true\n\t\tend\n\tend\n\tlocal duplicates\
    \ = {}\n\tlocal index = 1\n\tfor i = 1, n do\n\t\tlocal value = numbers[i]\n\t\
    \tif not seen[value] then\n\t\t\tduplicates[index] = value\n\t\t\tindex = index\
    \ + 1\n\t\tend\n\tend\n\treturn duplicates\nend", "    local s = {}\n    local\
    \ out = {}\n    for _,v in ipairs(numbers) do\n        if not s[v] then\n    \
    \        table.insert(out, v)\n            s[v] = true\n        end\n    end\n\
    \    return out\nend", "  local processed = {}\n  local result = {}\n  for _,\
    \ number in ipairs(numbers) do\n    if not processed[number] then\n      processed[number]\
    \ = true\n      table.insert(result, number)\n    end\n  end\n  return result\n\
    end", "  local unique = {}\n  for _,v in ipairs(numbers) do\n    unique[v] = true\n\
    \  end\n  local result = {}\n  for _,v in ipairs(numbers) do\n    if unique[v]\
    \ then\n      table.insert(result, v)\n      unique[v] = nil\n    end\n  end\n\
    \  return result\nend", "  local table = {}\n  local new_table = {}\n  for i,n\
    \ in ipairs(numbers) do\n    if table[n] then\n      table[n] = table[n] + 1\n\
    \    else\n      table[n] = 1\n    end\n  end\n  for i,n in ipairs(numbers) do\n\
    \    if table[n] == 1 then\n      table.insert(new_table, n)\n    end\n  end\n\
    \  return new_table\nend", "  local unique = {}\n  for _, number in ipairs(numbers)\
    \ do\n    unique[number] = (unique[number] or 0) + 1\n  end\n  local result =\
    \ {}\n  for _, number in ipairs(numbers) do\n    if unique[number] == 1 then\n\
    \      table.insert(result, number)\n    end\n  end\n  return result\nend", " \
    \   local dict = {}\n    local result = {}\n    for i, n in ipairs(numbers) do\n\
    \        if not dict[n] then\n            dict[n] = true\n            result[#result\
    \ + 1] = n\n        end\n    end\n    return result\nend", "    local seen_numbers\
    \ = {}\n    local unique_numbers = {}\n    for _, num in ipairs(numbers) do\n\
    \        if not seen_numbers[num] then\n            seen_numbers[num] = true\n\
    \            table.insert(unique_numbers, num)\n        end\n    end\n    return\
    \ unique_numbers\nend", "    local cnt = {}\n    for _, num in ipairs(numbers)\
    \ do\n        cnt[num] = (cnt[num] or 0) + 1\n    end\n    local uniques = {}\n\
    \    for _, num in ipairs(numbers) do\n        if cnt[num] == 1 then\n       \
    \     table.insert(uniques, num)\n        end\n    end\n    return uniques\nend",
  "    local already_seen = {}\n    local result = {}\n    for _, n in ipairs(numbers)\
    \ do\n        if not already_seen[n] then\n            already_seen[n] = true\n\
    \            table.insert(result, n)\n        end\n    end\n    return result\n\
    end", "  local result = {}\n  local lookup = {}\n  for _, v in ipairs(numbers)\
    \ do\n    if not lookup[v] then\n      table.insert(result, v)\n      lookup[v]\
    \ = true\n    end\n  end\n  return result\nend", "    local unique = {}\n    for\
    \ _, number in ipairs(numbers) do\n        if not unique[number] then\n      \
    \      unique[number] = true\n            coroutine.yield(number)\n        end\n\
    \    end\nend", "    local last_number = nil\n    local number_count = 0\n   \
    \ local unique_numbers = {}\n    for _, number in ipairs(numbers) do\n       \
    \ if number == last_number then\n            number_count = number_count + 1\n\
    \        else\n            number_count = 1\n        end\n        if number_count\
    \ == 1 then\n            table.insert(unique_numbers, number)\n        end\n \
    \       last_number = number\n    end\n    return unique_numbers\nend", "  local\
    \ elements = {}\n  local result = {}\n  for _, n in ipairs(numbers) do\n    if\
    \ not elements[n] then\n      result[#result + 1] = n\n      elements[n] = true\n\
    \    end\n  end\n  return result\nend", "    local seen = {}\n    local result\
    \ = {}\n    for _, number in ipairs(numbers) do\n        if not seen[number] then\n\
    \            table.insert(result, number)\n            seen[number] = true\n \
    \       end\n    end\n    return result\nend", "    return sort_unique(numbers)\n\
    end", "\tlocal m = {}\n\tlocal res = {}\n\tfor i, v in ipairs(numbers) do\n\t\t\
    if not m[v] then\n\t\t\tm[v] = i\n\t\t\tres[#res + 1] = v\n\t\tend\n\tend\n\t\
    return res\nend", "    local seen = {}\n    local result = {}\n    for _, element\
    \ in ipairs(numbers) do\n        if not seen[element] then\n            table.insert(result,\
    \ element)\n            seen[element] = true\n        end\n    end\n    return\
    \ result\nend", "  local hash_table = {}\n  local uniques = {}\n  for _, number\
    \ in ipairs(numbers) do\n    if not hash_table[number] then\n      hash_table[number]\
    \ = true\n      uniques[#uniques + 1] = number\n    end\n  end\n  return uniques\n\
    end", "    local unique = {}\n    for _, number in ipairs(numbers) do\n      \
    \  if not table_contains(unique, number) then\n            table.insert(unique,\
    \ number)\n        end\n    end\n    return unique\nend", "    local seen = {}\n\
    \    local result = {}\n    for _, number in ipairs(numbers) do\n        if not\
    \ seen[number] then\n            seen[number] = true\n            table.insert(result,\
    \ number)\n        end\n    end\n    return result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
