name: HumanEval_90_next_smallest
language: lua
prompt: "-- You are given a list of integers.\n-- Write a function next_smallest()\
  \ that returns the 2nd smallest element of the list.\n-- Return None if there is\
  \ no such element.\n-- next_smallest([1, 2, 3, 4, 5]) == 2\n-- next_smallest([5,\
  \ 1, 4, 3, 2]) == 2\n-- next_smallest([]) == None\n-- next_smallest([1, 1]) == None\n\
  local function next_smallest(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = next_smallest\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4, 5}), 2)\n    lu.assertEquals(candidate({5,\
  \ 1, 4, 3, 2}), 2)\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({1,\
  \ 1}), None)\n    lu.assertEquals(candidate({1, 1, 1, 1, 0}), 1)\n    lu.assertEquals(candidate({1,\
  \ 1}), None)\n    lu.assertEquals(candidate({-35, 34, 12, -45}), -35)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- your code here\nend", "    if #lst < 2 then\n        return nil\n\
    \    end\n    local min = lst[1]\n    local next_min = lst[2]\n    for i = 3,\
    \ #lst do\n        if min > lst[i] then\n            next_min = min\n        \
    \    min = lst[i]\n        elseif next_min > lst[i] then\n            next_min\
    \ = lst[i]\n        end\n    end\n    return next_min\nend", "    if not lst or\
    \ #lst < 2 then\n        return nil\n    end\n    local first = lst[1]\n    local\
    \ second = lst[2]\n    if first < second then\n        first, second = second,\
    \ first\n    end\n    for i = 3, #lst do\n        local val = lst[i]\n       \
    \ if val < first then\n            second = first\n            first = val\n \
    \       elseif val < second then\n            second = val\n        end\n    end\n\
    \    return second\nend", "    local iter, first, second = pairs(lst)\n    local\
    \ a, b = iter(lst, first)\n    if a == nil then\n        return nil\n    end\n\
    \    if b == nil then\n        return nil\n    end\n    if a < b then\n      \
    \  first, second = a, b\n    else\n        first, second = b, a\n    end\n   \
    \ for i, v in iter, lst, second do\n        if v < first then\n            first,\
    \ second = v, first\n        elseif v < second then\n            second = v\n\
    \        end\n    end\n    return second\nend", "    local min, next_min\n   \
    \ for i, val in ipairs(lst) do\n        if not min or val < min then\n       \
    \     next_min = min\n            min = val\n        elseif not next_min or val\
    \ < next_min then\n            next_min = val\n        end\n    end\n    return\
    \ next_min\nend", "  local count = {}\n  for _, v in ipairs(lst) do\n    count[v]\
    \ = (count[v] or 0) + 1\n  end\n  local number, second_number\n  for _, v in ipairs(lst)\
    \ do\n    if count[v] > 1 then\n      return nil\n    end\n    if not number or\
    \ v < number then\n      second_number = number\n      number = v\n    elseif\
    \ not second_number or v < second_number then\n      second_number = v\n    end\n\
    \  end\n  return second_number\nend", "  local i = {}\n  local n = {}\n  for _,\
    \ v in ipairs(lst) do\n    if #i == 0 then\n      table.insert(i, v)\n    elseif\
    \ #i == 1 then\n      if v > i[1] then\n        table.insert(i, v)\n      else\n\
    \        table.insert(i, 1, v)\n      end\n    else\n      if v > i[1] then\n\
    \        table.insert(i, v)\n      elseif v > i[2] then\n        i[2] = v\n  \
    \    else\n        table.insert(i, 1, v)\n      end\n    end\n  end\n  for _,\
    \ v in ipairs(i) do\n    table.insert(n, v)\n  end\n  if #n == 2 then\n    return\
    \ n[2]\n  else\n    return nil\n  end\nend", "    local first = math.huge\n  \
    \  local second = math.huge\n    for _, v in ipairs(lst) do\n        if v < first\
    \ then\n            second = first\n            first = v\n        elseif v <\
    \ second then\n            second = v\n        end\n    end\n    return second\n\
    end", "\tlocal min, min2\n\tfor _,v in ipairs(lst) do\n\t\tif not min or v < min\
    \ then\n\t\t\tmin2 = min\n\t\t\tmin = v\n\t\telseif not min2 or v < min2 then\n\
    \t\t\tmin2 = v\n\t\tend\n\tend\n\treturn min2\nend", "    if #lst < 2 then\n \
    \       return nil\n    end\n    local smallest = lst[1]\n    local next_smallest\
    \ = nil\n    for i = 2, #lst do\n        if lst[i] < smallest then\n         \
    \   next_smallest = smallest\n            smallest = lst[i]\n        elseif next_smallest\
    \ == nil or lst[i] < next_smallest then\n            next_smallest = lst[i]\n\
    \        end\n    end\n    return next_smallest\nend", "    if #lst <= 1 then\n\
    \        return nil\n    end\n    local min = math.min(table.unpack(lst))\n  \
    \  local t = {}\n    for i,v in ipairs(lst) do\n        if v > min then\n    \
    \        table.insert(t, v)\n        end\n    end\n    if #t == 0 then\n     \
    \   return nil\n    end\n    return math.min(table.unpack(t))\nend", "\tlocal\
    \ t = {}\n\tfor i = 1, #lst do\n\t\tt[i] = lst[i]\n\tend\n\ttable.sort(t)\n\t\
    if #t < 2 then\n\t\treturn nil\n\tend\n\treturn t[2]\nend", "  local min, min2\n\
    \  for i, v in ipairs(lst) do\n    if not min or v < min then\n      min2 = min\n\
    \      min = v\n    elseif not min2 or v < min2 then\n      min2 = v\n    end\n\
    \  end\n  return min2\nend", "  return nthsmallest(lst, 2)\nend", "  local smallest,\
    \ second_smallest\n  for _, n in ipairs(lst) do\n    if not smallest or n < smallest\
    \ then\n      second_smallest = smallest\n      smallest = n\n    elseif not second_smallest\
    \ or n < second_smallest then\n      second_smallest = n\n    end\n  end\n  return\
    \ second_smallest\nend", "    local function sort_by_asc_order(a, b)\n       \
    \ return a < b\n    end\n    table.sort(lst, sort_by_asc_order)\n    for idx,\
    \ num in ipairs(lst) do\n        if idx > 1 and lst[idx - 1] ~= num then\n   \
    \         return num\n        end\n    end\n    return nil\nend", "    local min,\
    \ min2 = math.huge, math.huge\n    for _, x in ipairs(lst) do\n        if x <\
    \ min then\n            min2 = min\n            min = x\n        elseif x < min2\
    \ then\n            min2 = x\n        end\n    end\n    return min2 == math.huge\
    \ and nil or min2\nend", "    -- # Return None if there is no such element.\n\
    \    if #lst < 2 then\n        return nil\n    end\n    local min = lst[1]\n \
    \   local min_idx = 1\n    for i, val in ipairs(lst) do\n        if val < min\
    \ then\n            min = val\n            min_idx = i\n        end\n    end\n\
    \    table.remove(lst, min_idx)\n    min = lst[1]\n    for _, val in ipairs(lst)\
    \ do\n        if val < min then\n            min = val\n        end\n    end\n\
    \    return min\nend", "    if #lst < 2 then\n        return nil\n    end\n  \
    \  local result = nil\n    local tmp = nil\n    for i,v in ipairs(lst) do\n  \
    \      if result == nil then\n            result = v\n        elseif v < result\
    \ then\n            tmp = result\n            result = v\n        elseif v > result\
    \ and (tmp == nil or v < tmp) then\n            tmp = v\n        end\n    end\n\
    \    return tmp\nend", "\t-- Your code goes here.\nend", "  local min1, min2\n\
    \  for i,v in ipairs(lst) do\n    if not min1 or v < min1 then\n      min2 = min1\n\
    \      min1 = v\n    elseif not min2 or v < min2 then\n      min2 = v\n    end\n\
    \  end\n  return min2\nend", "  local i, m1, m2 = 1, math.huge, math.huge\n  while\
    \ i <= #lst do\n    if lst[i] < m1 then\n      m2 = m1\n      m1 = lst[i]\n  \
    \  elseif lst[i] < m2 then\n      m2 = lst[i]\n    end\n    i = i + 1\n  end\n\
    \  return m2 < math.huge and m2 or nil\nend", "    table.sort(lst)\n    for i,v\
    \ in ipairs(lst) do\n        if v ~= lst[1] then\n            return v\n     \
    \   end\n    end\n    return nil\nend", "  return lst:sort()[2]\nend", "    local\
    \ min, second_min\n    for _, v in ipairs(lst) do\n        if not min or v < min\
    \ then\n            second_min = min\n            min = v\n        elseif not\
    \ second_min or v < second_min then\n            second_min = v\n        end\n\
    \    end\n    return second_min\nend", "  local n = table.remove(lst,1)\n  local\
    \ sm = math.min(table.unpack(lst))\n  if n == sm then\n    return nil\n  else\n\
    \    for i,v in ipairs(lst) do\n      if n == v then\n        return sm\n    \
    \  end\n    end\n    return n\n  end\nend", "    return lst\nend", "    if #lst\
    \ == 0 then\n        return nil\n    end\n    if #lst == 1 then\n        return\
    \ nil\n    end\n    if #lst == 2 then\n        if lst[1] == lst[2] then\n    \
    \        return nil\n        end\n    end\n    table.sort(lst)\n    local last\
    \ = lst[1]\n    for i = 2, #lst do\n        if lst[i] > last then\n          \
    \  return lst[i]\n        end\n        last = lst[i]\n    end\n    return nil\n\
    end", "    if #lst < 2 then\n        return nil\n    end\n    local smallest,\
    \ second_smallest = lst[1], lst[2]\n    if second_smallest < smallest then\n \
    \       smallest, second_smallest = second_smallest, smallest\n    end\n    for\
    \ i = 3, #lst do\n        if lst[i] < smallest then\n            second_smallest\
    \ = smallest\n            smallest = lst[i]\n        elseif lst[i] < second_smallest\
    \ then\n            second_smallest = lst[i]\n        end\n    end\n    return\
    \ second_smallest\nend", "  local min = math.huge\n  local min2 = math.huge\n\
    \  for i, v in ipairs(lst) do\n    if v < min then\n      min2 = min\n      min\
    \ = v\n    elseif v < min2 then\n      min2 = v\n    end\n  end\n  return min2\
    \ == math.huge and nil or min2\nend", "\tlocal sorted = {}\n\tfor _,v in ipairs(lst)\
    \ do table.insert(sorted, v) end\n\ttable.sort(sorted)\n\tif #sorted <= 1 then\
    \ return nil end\n\treturn sorted[2]\nend", "    local min, min2\n    for _, x\
    \ in ipairs(lst) do\n        if min2 then\n            if x < min2 then\n    \
    \            if x < min then\n                    min2 = min\n               \
    \     min = x\n                else\n                    min2 = x\n          \
    \      end\n            end\n        elseif min then\n            if x < min then\n\
    \                min2 = min\n                min = x\n            else\n     \
    \           min2 = x\n            end\n        else\n            min = x\n   \
    \     end\n    end\n    return min2\nend", "  if #lst < 2 then return nil end\n\
    \  local min = math.min(table.unpack(lst))\n  if lst[1] == min then\n    table.remove(lst,\
    \ 1)\n  else\n    for i, n in ipairs(lst) do\n      if n == min then\n       \
    \ table.remove(lst, i)\n        break\n      end\n    end\n  end\n  return math.min(table.unpack(lst))\n\
    end", "  local smallest, next_smallest = 2^32, 2^32\n  for i, val in ipairs(lst)\
    \ do\n    if val < smallest then\n      next_smallest = smallest\n      smallest\
    \ = val\n    elseif val < next_smallest then\n      next_smallest = val\n    end\n\
    \  end\n  return next_smallest == 2^32 and nil or next_smallest\nend", "    local\
    \ min, min2 = math.huge, math.huge\n    for _, v in ipairs(lst) do\n        if\
    \ v < min then\n            min2 = min\n            min = v\n        elseif v\
    \ < min2 then\n            min2 = v\n        end\n    end\n    return min2 ~=\
    \ math.huge and min2 or nil\nend", "    local ret\n    local min = math.min(unpack(lst))\n\
    \    for _, v in ipairs(lst) do\n        if v > min then\n            ret = ret\
    \ and math.min(ret, v) or v\n        end\n    end\n    return ret\nend", "  table.sort(lst)\n\
    \  local last = nil\n  for _, item in ipairs(lst) do\n    if item ~= last then\n\
    \      if last ~= nil then\n        return last\n      end\n      last = item\n\
    \    end\n  end\n  return nil\nend\nprint(next_smallest({5, 1, 4, 3, 2}))", " \
    \ local min1, min2 = math.huge, math.huge\n  for _, x in ipairs(lst) do\n    if\
    \ x < min1 then\n      min2 = min1\n      min1 = x\n    elseif x < min2 then\n\
    \      min2 = x\n    end\n  end\n  return min2 == math.huge and nil or min2\n\
    end", "  local smallest = math.huge\n  local smallest_second = math.huge\n  for\
    \ i = 1, #lst do\n    if lst[i] < smallest then\n      smallest_second = smallest\n\
    \      smallest = lst[i]\n    elseif lst[i] < smallest_second then\n      smallest_second\
    \ = lst[i]\n    end\n  end\n  if smallest_second == math.huge then\n    return\
    \ nil\n  end\n  return smallest_second\nend", "    local min = lst[1]\n    local\
    \ nextMin = nil\n    for i = 2, #lst do\n        if (lst[i] < min) then\n    \
    \        nextMin = min\n            min = lst[i]\n        elseif (nextMin == nil)\
    \ then\n            nextMin = lst[i]\n        elseif (lst[i] < nextMin) then\n\
    \            nextMin = lst[i]\n        end\n    end\n    return nextMin\nend",
  "  -- your code here\nend", "  local arr = {}\n  for i = 1, #lst do\n    if lst[i]\
    \ > lst[i + 1] then\n      return lst[i + 1]\n    end\n  end\nend", "  if #lst\
    \ <= 1 then return nil end\n  local min = math.min(unpack(lst))\n  local copy\
    \ = {}\n  for i, v in ipairs(lst) do\n    if v > min then copy[#copy + 1] = v\
    \ end\n  end\n  if #copy == 0 then return nil end\n  return math.min(unpack(copy))\n\
    end", "  local min, min2\n  for _, val in ipairs(lst) do\n    if min == nil or\
    \ val < min then\n      min2 = min\n      min = val\n    elseif min2 == nil or\
    \ val < min2 then\n      min2 = val\n    end\n  end\n  return min2\nend", "  \
    \  if #lst < 2 then\n        return nil\n    end\n    local min = lst[1]\n   \
    \ local nmin = lst[2]\n    for i = 2, #lst do\n        if lst[i] < min then\n\
    \            nmin = min\n            min = lst[i]\n        elseif lst[i] < nmin\
    \ then\n            nmin = lst[i]\n        end\n    end\n    return nmin\nend",
  "    --[[\n    Create a list of tuples (v,i) where i is a list of indices of lst\
    \ where\n    the elements are equal to v. Sort the tuples and return the 2nd smallest\n\
    \    element.\n    --]]\n    local value_dict = {}\n    for k,v in ipairs(lst)\
    \ do\n        local indices = value_dict[v]\n        if indices then\n       \
    \     table.insert(indices, k)\n        else\n            value_dict[v] = {k}\n\
    \        end\n    end\n    local tuples = {}\n    for v, i in pairs(value_dict)\
    \ do\n        table.insert(tuples, {v, i})\n    end\n    table.sort(tuples, function(a,b)\
    \ return a[1] < b[1] end)\n    return tuples[2] and tuples[2][1]\nend", "    if\
    \ #lst < 2 then\n        return nil\n    end\n    local min1, min2\n    for i,\
    \ v in ipairs(lst) do\n        if min1 == nil or v < min1 then\n            min2\
    \ = min1\n            min1 = v\n        elseif min2 == nil or v < min2 then\n\
    \            min2 = v\n        end\n    end\n    return min2\nend", "  -- your\
    \ code here\nend", "\tif #lst == 0 then\n\t\treturn nil\n\tend\n\t\n\tlocal smallest\
    \ = lst[1]\n\tlocal next_smallest = nil\n\t\n\tfor i,x in ipairs(lst) do\n\t\t\
    if x < smallest then\n\t\t\tnext_smallest = smallest\n\t\t\tsmallest = x\n\t\t\
    elseif x ~= smallest and (next_smallest == nil or x < next_smallest) then\n\t\t\
    \tnext_smallest = x\n\t\tend\n\tend\n\t\n\treturn next_smallest\nend", "\tlocal\
    \ smallest, smallest2\n\tfor _, value in ipairs(lst) do\n\t\tif not smallest or\
    \ value < smallest then\n\t\t\tsmallest2 = smallest\n\t\t\tsmallest = value\n\t\
    \telseif value < smallest2 or not smallest2 then\n\t\t\tsmallest2 = value\n\t\t\
    end\n\tend\n\treturn smallest2\nend", "    if #lst < 2 then\n        return nil\n\
    \    end\n    local smaller = math.min(lst[1], lst[2])\n    local other = math.max(lst[1],\
    \ lst[2])\n    for i = 3, #lst do\n        if lst[i] < smaller then\n        \
    \    other = smaller\n            smaller = lst[i]\n        elseif lst[i] < other\
    \ then\n            other = lst[i]\n        end\n    end\n    return other\nend",
  "\tif #lst == 0 then\n\t\treturn nil\n\tend\n\tlocal min, min2 = math.huge, math.huge\n\
    \tfor _, v in ipairs(lst) do\n\t\tif v < min then\n\t\t\tmin2 = min\n\t\t\tmin\
    \ = v\n\t\telseif v < min2 then\n\t\t\tmin2 = v\n\t\tend\n\tend\n\tif min2 ==\
    \ math.huge then\n\t\treturn nil\n\tend\n\treturn min2\nend", "    if #lst < 2\
    \ then\n        return nil\n    end\n    local min1, min2 = math.huge, math.huge\n\
    \    for _, v in ipairs(lst) do\n        if v < min1 then\n            min2 =\
    \ min1\n            min1 = v\n        elseif v < min2 then\n            min2 =\
    \ v\n        end\n    end\n    return min2 ~= math.huge and min2 or nil\nend",
  "    if #lst < 2 then\n        return nil\n    end\n    local min = math.min(unpack(lst))\n\
    \    local second_min = math.max(unpack(lst))\n    for i = 1, #lst do\n      \
    \  if lst[i] < second_min and lst[i] > min then\n            second_min = lst[i]\n\
    \        end\n    end\n    if second_min == math.max(unpack(lst)) then\n     \
    \   return nil\n    end\n    return second_min\nend", "\tif #lst < 2 then return\
    \ nil end\n\tlocal s,n\n\tfor _,v in ipairs(lst) do\n\t\tif not s or v < s then\
    \ s,n = v,s\n\t\telseif not n or v < n then n = v end\n\tend\n\treturn n\nend",
  "\tif #lst < 2 then return nil end\n\ttable.sort(lst)\n\treturn lst[2]\nend", " \
    \ -- your code here\nend", "\tlocal min, min2\n\tfor _, v in ipairs(lst) do\n\t\
    \tif not min or v < min then\n\t\t\tmin2 = min\n\t\t\tmin = v\n\t\telseif not\
    \ min2 or v < min2 then\n\t\t\tmin2 = v\n\t\tend\n\tend\n\treturn min2\nend",
  "  local smallest = math.huge\n  local n_smallest = math.huge\n  for _,i in ipairs(lst)\
    \ do\n    if i < smallest then\n      n_smallest = smallest\n      smallest =\
    \ i\n    elseif i < n_smallest then\n      n_smallest = i\n    end\n  end\n  return\
    \ n_smallest == math.huge and nil or n_smallest\nend", "    local iter = function(i,\
    \ seen)\n        if #lst == 0 then\n            return nil\n        end\n    \
    \    if i > #lst then\n            return seen[2] or nil\n        end\n      \
    \  if seen[1] == nil then\n            seen[1] = lst[i]\n        elseif lst[i]\
    \ < seen[1] then\n            seen[2] = seen[1]\n            seen[1] = lst[i]\n\
    \        elseif lst[i] < seen[2] or seen[2] == nil then\n            seen[2] =\
    \ lst[i]\n        end\n        return iter(i + 1, seen)\n    end\n    return iter(1,\
    \ {})\nend", "  local min1, min2 = math.huge, math.huge\n  for _, val in ipairs(lst)\
    \ do\n    if val < min1 then\n      min2 = min1\n      min1 = val\n    elseif\
    \ val < min2 then\n      min2 = val\n    end\n  end\n  return min2 ~= math.huge\
    \ and min2 or nil\nend", "    local function is_smallest(i, lst)\n        for\
    \ k, v in ipairs(lst) do\n            if v < lst[i] then\n                return\
    \ false\n            end\n        end\n        return true\n    end", "    --\
    \ WRITE YOUR CODE HERE\nend", "    local min, second\n    for _, value in ipairs(lst)\
    \ do\n        if not min or value < min then\n            second = min\n     \
    \       min = value\n        elseif not second or value < second then\n      \
    \      second = value\n        end\n    end\n    return second\nend", "    if\
    \ #lst == 0 then\n        return nil\n    end\n    if #lst == 1 then\n       \
    \ return nil\n    end\n    local min = math.min(unpack(lst))\n    local result\
    \ = min\n    for i, v in ipairs(lst) do\n        if v > min and v < result then\n\
    \            result = v\n        end\n    end\n    if result == min then\n   \
    \     return nil\n    end\n    return result\nend\nassert(next_smallest({1, 2,\
    \ 3, 4, 5}) == 2)\nassert(next_smallest({5, 1, 4, 3, 2}) == 2)\nassert(next_smallest({})\
    \ == nil)\nassert(next_smallest({1, 1}) == nil)\nassert(next_smallest({1, 2, 3,\
    \ 3, 4, 5}) == 2)\nassert(next_smallest({5, 4, 3, 2, 1}) == nil)\nassert(next_smallest({1,\
    \ 2, 2, 3, 4, 5}) == 2)\nassert(next_smallest({5, 1, 2, 3, 4, 5}) == 2)", "  local\
    \ min = math.min(unpack(lst))\n  local min2 = math.max(unpack(lst))\n  for i =\
    \ 1, #lst do\n    if lst[i] < min2 and lst[i] > min then\n      min2 = lst[i]\n\
    \    end\n  end\n  if min2 == math.max(unpack(lst)) then\n    return nil\n  else\n\
    \    return min2\n  end\nend", "  local min = math.min(unpack(lst))\n  local min2\n\
    \  for i = 1, #lst do\n    if lst[i] ~= min then\n      if not min2 or lst[i]\
    \ < min2 then\n        min2 = lst[i]\n      end\n    end\n  end\n  return min2\n\
    end\nassert(next_smallest({1, 2, 3, 4, 5}) == 2)\nassert(next_smallest({5, 1,\
    \ 4, 3, 2}) == 2)\nassert(next_smallest({}) == nil)\nassert(next_smallest({1,\
    \ 1}) == nil)", "    local smallest = math.huge\n    local second = math.huge\n\
    \    for _, v in ipairs(lst) do\n        if v < smallest then\n            second\
    \ = smallest\n            smallest = v\n        elseif v < second then\n     \
    \       second = v\n        end\n    end\n    return second ~= math.huge and second\
    \ or nil\nend", "  table.sort(lst)\n  if lst[1] == lst[2] then\n    return nil\n\
    \  end\n  return lst[2]\nend", "    local min = math.min(unpack(lst))\n    local\
    \ t = {}\n    for _, item in ipairs(lst) do\n        if item ~= min then\n   \
    \         table.insert(t, item)\n        end\n    end\n    if #t > 0 then\n  \
    \      return math.min(unpack(t))\n    end\nend", "  local sorted_lst = quick_sort(lst)\n\
    \  if #sorted_lst == 0 then\n    return nil\n  end\n  if #sorted_lst == 1 then\n\
    \    return nil\n  end\n  local unique_lst = unique(sorted_lst)\n  return unique_lst[2]\n\
    end", "  if #lst < 2 then return nil end\n  local sorted = lst\n  table.sort(sorted)\n\
    \  return sorted[2]\nend", "    local min, min2 = math.huge, math.huge\n    for\
    \ _, val in ipairs(lst) do\n        if val < min then\n            min2 = min\n\
    \            min = val\n        elseif val < min2 then\n            min2 = val\n\
    \        end\n    end\n    return min2 == math.huge and nil or min2\nend", " \
    \ if #lst < 2 then return nil end\n  local first, second = math.huge, math.huge\n\
    \  for _,n in ipairs(lst) do\n    if n < first then\n      second = first\n  \
    \    first = n\n    elseif n < second then\n      second = n\n    end\n  end\n\
    \  return second\nend", "    return ''\nend", "\ttable.sort(lst)\n\tif lst[1]\
    \ == lst[2] then\n\t\treturn nil\n\tend\n\treturn lst[2]\nend", "    if #lst <\
    \ 2 then\n        return nil\n    end\n    local result = nil\n    local first\
    \ = lst[1]\n    for i = 2, #lst do\n        if lst[i] < first then\n         \
    \   first = lst[i]\n        end\n    end\n    local found = false\n    for i =\
    \ 1, #lst do\n        if first == lst[i] then\n            found = true\n    \
    \    elseif (not found) and (lst[i] > first) then\n            result = lst[i]\n\
    \            found = true\n        elseif result > lst[i] then\n            result\
    \ = lst[i]\n        end\n    end\n    return result\nend", "    local min, second_min\n\
    \    for _, v in ipairs(lst) do\n        if not min or v < min then\n        \
    \    second_min = min\n            min = v\n        elseif not second_min or v\
    \ < second_min then\n            second_min = v\n        end\n    end\n    return\
    \ second_min\nend", "    local min, min2\n    for _, v in ipairs(lst) do\n   \
    \     if not min then\n            min = v\n        elseif not min2 then\n   \
    \         if v < min then\n                min2 = min\n                min = v\n\
    \            elseif v > min then\n                min2 = v\n            end\n\
    \        elseif v < min then\n            min2 = min\n            min = v\n  \
    \      elseif v > min and v < min2 then\n            min2 = v\n        end\n \
    \   end\n    return min2\nend", "    local min, sec_min\n    for _, el in ipairs(lst)\
    \ do\n        if not min or el < min then\n            sec_min = min\n       \
    \     min = el\n        elseif not sec_min or el < sec_min then\n            sec_min\
    \ = el\n        end\n    end\n    return sec_min\nend", "\ttable.sort(lst)\n\t\
    local a = {}\n\tfor i = 1, #lst do\n\t\tif a[lst[i]] then\n\t\t\ta[lst[i]] = a[lst[i]]\
    \ + 1\n\t\telse\n\t\t\ta[lst[i]] = 1\n\t\tend\n\tend\n\tif #lst == 1 then\n\t\t\
    return nil\n\telseif #lst == 2 then\n\t\tif a[lst[1]] == 1 then\n\t\t\treturn\
    \ lst[1]\n\t\telse\n\t\t\treturn nil\n\t\tend\n\telse\n\t\tif a[lst[1]] == 1 then\n\
    \t\t\treturn lst[1]\n\t\telse\n\t\t\treturn lst[2]\n\t\tend\n\tend\nend", "  local\
    \ smallest = lst[1]\n  local nextSmallest = nil\n  for i = 2, #lst do\n    if\
    \ lst[i] < smallest then\n      nextSmallest = smallest\n      smallest = lst[i]\n\
    \    elseif nextSmallest == nil or (lst[i] < nextSmallest and lst[i] ~= smallest)\
    \ then\n      nextSmallest = lst[i]\n    end\n  end\n  return nextSmallest\nend",
  "    local min1, min2 = math.huge, math.huge\n    for _, n in ipairs(lst) do\n \
    \       if n <= min1 then\n            min2 = min1\n            min1 = n\n   \
    \     elseif n < min2 then\n            min2 = n\n        end\n    end\n    return\
    \ min2 == math.huge and nil or min2\nend", "    if #lst == 0 then\n        return\
    \ nil\n    end\n    if #lst == 1 then\n        return nil\n    end\n    if #lst\
    \ == 2 then\n        if lst[1] == lst[2] then\n            return nil\n      \
    \  end\n    end\n    local min = math.min(table.unpack(lst))\n    for _, v in\
    \ ipairs(lst) do\n        if v > min then\n            return v\n        end\n\
    \    end\nend", "    if #lst < 2 then\n        return nil\n    end\n    local\
    \ function argmin(t)\n        local m = math.huge\n        local k = nil\n   \
    \     for kk, v in pairs(t) do\n            if v < m then\n                m =\
    \ v\n                k = kk\n            end\n        end\n        return k, m\n\
    \    end\n    local m1, m2 = math.huge, math.huge\n    for _, v in ipairs(lst)\
    \ do\n        if v < m1 then\n            m2 = m1\n            m1 = v\n      \
    \  elseif v < m2 then\n            m2 = v\n        end\n    end\n    return m2\n\
    end", "  table.sort(lst)\n  if lst[1] == lst[2] then\n    return nil\n  end\n\
    \  return lst[2]\nend", "  if (#lst < 2) then return nil end\n  local m = math.min(table.unpack(lst))\n\
    \  for _,v in ipairs(lst) do\n    if v > m then return v end\n  end\n  return\
    \ nil\nend", "  if #lst < 2 then return nil end\n  table.sort(lst)\n  return lst[2]\n\
    end", "  local n, n2\n  for _, v in ipairs(lst) do\n    if not n then\n      n\
    \ = v\n    elseif not n2 then\n      if v < n then\n        n2 = n\n        n\
    \ = v\n      elseif v > n then\n        n2 = v\n      end\n    elseif v < n then\n\
    \      n2 = n\n      n = v\n    elseif v > n and v < n2 then\n      n2 = v\n \
    \   end\n  end\n  return n2\nend", "\tlocal min, min_index = lst[1], 1\n\tfor\
    \ i, v in ipairs(lst) do\n\t\tif v < min then\n\t\t\tmin, min_index = v, i\n\t\
    \tend\n\tend\n\tlocal min_2, min_2_index = lst[1], 1\n\tfor i, v in ipairs(lst)\
    \ do\n\t\tif v > min and (v < min_2 or (v == min_2 and i > min_2_index)) then\n\
    \t\t\tmin_2, min_2_index = v, i\n\t\tend\n\tend\n\treturn min_2 ~= min and min_2\
    \ or nil\nend", "  if #lst == 0 then return nil end\n  table.sort(lst)\n  for\
    \ i=2,#lst do\n    if lst[i] ~= lst[1] then return lst[i] end\n  end\n  return\
    \ nil\nend", "  --  return\nend", "  local min, min2\n  for _, x in ipairs(lst)\
    \ do\n    if min == nil or x < min then\n      min2 = min\n      min = x\n   \
    \ elseif min2 == nil or x < min2 then\n      min2 = x\n    end\n  end\n  return\
    \ min2\nend", "  if #lst == 0 then return nil end\n  local min = lst[1]\n  local\
    \ min2 = math.huge\n  for i = 2, #lst do\n    if lst[i] < min then\n      min2\
    \ = min\n      min = lst[i]\n    elseif lst[i] < min2 then\n      min2 = lst[i]\n\
    \    end\n  end\n  if min2 == math.huge then return nil end\n  return min2\nend",
  "\tif #lst < 2 then return nil end\n\tlocal min_elem = math.huge\n\tlocal min_elem_2\
    \ = math.huge\n\tfor i = 1, #lst do\n\t\tif lst[i] < min_elem then\n\t\t\tmin_elem_2\
    \ = min_elem\n\t\t\tmin_elem = lst[i]\n\t\telseif lst[i] < min_elem_2 then\n\t\
    \t\tmin_elem_2 = lst[i]\n\t\tend\n\tend\n\treturn min_elem_2\nend\nassert(next_smallest({1,\
    \ 2, 3, 4, 5}) == 2)\nassert(next_smallest({5, 1, 4, 3, 2}) == 2)\nassert(next_smallest({})\
    \ == nil)\nassert(next_smallest({1, 1}) == nil)", "  -- TODO: See if we can do\
    \ this in a more concise way.\n  local min, min_i = 1/0, 0\n  local min2, min2_i\
    \ = 1/0, 0\n  for i,v in ipairs(lst) do\n    if v < min then\n      min2, min2_i\
    \ = min, min_i\n      min, min_i = v, i\n    elseif v < min2 then\n      min2,\
    \ min2_i = v, i\n    end\n  end\n  if min2 == 1/0 then\n    return nil\n  else\n\
    \    return min2\n  end\nend", "\treturn sort(lst)[2]\nend", "  local a = {}\n\
    \  for i = 1, #lst do\n    local min\n    local min_ind\n    for j = 1, #lst do\n\
    \      if (not min or min > lst[j]) and not a[j] then\n        min = lst[j]\n\
    \        min_ind = j\n      end\n    end\n    a[min_ind] = true\n    if i == 2\
    \ then\n      return min\n    end\n  end\nend", "  local min_el, sec_min_el =\
    \ lst[1], nil\n  for i = 2, #lst do\n    if lst[i] < min_el then\n      sec_min_el\
    \ = min_el\n      min_el = lst[i]\n    elseif lst[i] ~= min_el and (sec_min_el\
    \ == nil or lst[i] < sec_min_el) then\n      sec_min_el = lst[i]\n    end\n  end\n\
    \  return sec_min_el\nend", "  local s, ns\n  for i, v in ipairs(lst) do\n   \
    \ if not s or v < s then\n      ns, s = s, v\n    elseif not ns or v < ns then\n\
    \      ns = v\n    end\n  end\n  return ns\nend", "\tlocal min = math.huge\n\t\
    local m = math.huge\n\tlocal n = math.huge\n\tfor i = 1, #lst do\n\t\tif lst[i]\
    \ < m then\n\t\t\tn = m\n\t\t\tm = lst[i]\n\t\telseif lst[i] < n then\n\t\t\t\
    n = lst[i]\n\t\tend\n\tend\n\tif n == math.huge then\n\t\treturn nil\n\tend\n\t\
    return n\nend", "    if #lst < 2 then\n        return nil\n    end\n    -- TODO:\
    \ your code here\nend", "\tlocal min, min2, min2i = math.huge, math.huge, 0\n\t\
    for i, v in ipairs(lst) do\n\t\tif v < min then\n\t\t\tmin2, min2i = min, i\n\t\
    \t\tmin = v\n\t\telseif v < min2 then\n\t\t\tmin2 = v\n\t\tend\n\tend\n\treturn\
    \ min2 == math.huge and nil or min2\nend", "  local copy = copy_list(lst)\n  sort(copy)\n\
    \  if #copy < 2 then\n    return nil\n  end\n  return copy[2]\nend", "    local\
    \ res = {}\n    for _, i in ipairs(lst) do\n        if not res[i] then\n     \
    \       res[i] = 0\n        end\n        res[i] = res[i] + 1\n    end\n    local\
    \ min = 2^31\n    local min2 = min\n    for k, v in pairs(res) do\n        if\
    \ v == 1 then\n            if k < min then\n                min2 = min\n     \
    \           min = k\n            elseif k < min2 then\n                min2 =\
    \ k\n            end\n        end\n    end\n    if min2 == min then\n        return\
    \ nil\n    end\n    return min2\nend", "    if #lst < 2 then\n        return nil\n\
    \    end\n    local min = lst[1]\n    local min2 = nil\n    for _, val in ipairs(lst)\
    \ do\n        if val < min then\n            min2 = min\n            min = val\n\
    \        elseif val > min and (not min2 or val < min2) then\n            min2\
    \ = val\n        end\n    end\n    return min2\nend", "    local smallest, nextSmallest\n\
    \    for i, v in ipairs(lst) do\n        if v ~= smallest then\n            if\
    \ not smallest or v < smallest then\n                nextSmallest = smallest\n\
    \                smallest = v\n            elseif not nextSmallest or v < nextSmallest\
    \ then\n                nextSmallest = v\n            end\n        end\n    end\n\
    \    return nextSmallest\nend", "    local min1, min2\n    for _, v in ipairs(lst)\
    \ do\n        if not min1 or v < min1 then\n            min2 = min1\n        \
    \    min1 = v\n        elseif not min2 or v < min2 then\n            min2 = v\n\
    \        end\n    end\n    return min2\nend", "    table.sort(lst)\n    if lst[1]\
    \ == lst[2] then\n        return nil\n    end\n    return lst[2]\nend\nprint(next_smallest({1,\
    \ 2, 3, 4, 5}))\nprint(next_smallest({5, 1, 4, 3, 2}))\nprint(next_smallest({}))\n\
    print(next_smallest({1, 1}))", "  local t = {}\n  for _, v in ipairs(lst) do\n\
    \    t[v] = true\n  end\n  local l = {}\n  for n in pairs(t) do\n    table.insert(l,\
    \ n)\n  end\n  table.sort(l)\n  return l[2]\nend", "    return 0\nend", "  local\
    \ smallest, smallest_idx = lst[1], 1\n  local next_smallest, next_smallest_idx\
    \ = lst[2], 2\n  if not smallest then return nil end\n  for i = 2, #lst do\n \
    \   if lst[i] < smallest then\n      next_smallest, next_smallest_idx = smallest,\
    \ smallest_idx\n      smallest, smallest_idx = lst[i], i\n    elseif lst[i] <\
    \ next_smallest then\n      next_smallest, next_smallest_idx = lst[i], i\n   \
    \ end\n  end\n  return next_smallest\nend", "    local iter = ipairs(lst)\n  \
    \  local smallest, second_smallest\n    local n\n    for i, v in iter do\n   \
    \     n = n + 1\n        if n == 1 then\n            smallest = v\n        elseif\
    \ n == 2 then\n            second_smallest = v\n        else\n            if v\
    \ < smallest then\n                second_smallest = smallest\n              \
    \  smallest = v\n            elseif v < second_smallest then\n               \
    \ second_smallest = v\n            end\n        end\n    end\n    if n < 2 then\n\
    \        return nil\n    end\n    return second_smallest\nend", "  return sort(lst)[2]\n\
    end", "  local smallest, second_smallest = math.huge, math.huge\n  for _, elem\
    \ in ipairs(lst) do\n    if elem < smallest then\n      second_smallest = smallest\n\
    \      smallest = elem\n    elseif elem < second_smallest then\n      second_smallest\
    \ = elem\n    end\n  end\n  return second_smallest == math.huge and nil or second_smallest\n\
    end", "    if lst == nil or #lst == 0 then\n        return nil\n    end\n    table.sort(lst)\n\
    \    local min, second = lst[1], nil\n    for i, v in ipairs(lst) do\n       \
    \ if v ~= min then\n            second = v\n            break\n        end\n \
    \   end\n    return second\nend", "  table.sort(lst)\n  local last = lst[1]\n\
    \  for i = 2, #lst do\n    if lst[i] > last then\n      return lst[i]\n    end\n\
    \    last = lst[i]\n  end\n  return nil\nend", "    if #lst < 2 then\n       \
    \ return nil\n    end\n    local next_min = math.huge\n    local min = math.huge\n\
    \    for _, i in ipairs(lst) do\n        if i < min then\n            next_min\
    \ = min\n            min = i\n        elseif i < next_min then\n            next_min\
    \ = i\n        end\n    end\n    if next_min == math.huge then\n        return\
    \ nil\n    end\n    return next_min\nend", "    table.sort(lst)\n    if lst[1]\
    \ ~= lst[2] then\n        return lst[2]\n    end\n    return nil\nend", "    if\
    \ #lst < 2 then\n        return nil\n    end\n    local sorted = {}\n    for i,\
    \ v in ipairs(lst) do\n        sorted[i] = v\n    end\n    table.sort(sorted)\n\
    \    for i, v in ipairs(sorted) do\n        if v ~= sorted[1] then\n         \
    \   return v\n        end\n    end\n    return nil\nend", "  local min = lst[1]\n\
    \  local min2 = nil\n  for i, el in ipairs(lst) do\n    if el < min then\n   \
    \   min2 = min\n      min = el\n    elseif el < min2 or min2 == nil then\n   \
    \   min2 = el\n    end\n  end\n  return min2\nend", "  table.sort(lst)\n  return\
    \ lst[2]\nend\nassert(next_smallest({1, 2, 3, 4, 5}) == 2)\nassert(next_smallest({5,\
    \ 1, 4, 3, 2}) == 2)\nassert(next_smallest({}) == nil)\nassert(next_smallest({1,\
    \ 1}) == nil)", "    if #lst < 2 then\n        return nil\n    end\n    table.sort(lst)\n\
    \    local smallest, second_smallest = lst[1], lst[2]\n    for i, v in ipairs(lst)\
    \ do\n        if i > 2 and v == smallest then\n            return nil\n      \
    \  end\n        if i > 2 and v > smallest and v < second_smallest then\n     \
    \       second_smallest = v\n        end\n    end\n    return second_smallest\n\
    end", "    local curr_smallest = lst[1]\n    local prev_smallest = nil\n    for\
    \ i, v in ipairs(lst) do\n        if v < curr_smallest then\n            prev_smallest\
    \ = curr_smallest\n            curr_smallest = v\n        elseif v > curr_smallest\
    \ and (prev_smallest == nil or v < prev_smallest) then\n            prev_smallest\
    \ = v\n        end\n    end\n    return prev_smallest\nend", "\tlocal m1, m2 =\
    \ math.huge, math.huge\n\tfor _, v in ipairs(lst) do\n\t\tif v < m1 then\n\t\t\
    \tm2 = m1\n\t\t\tm1 = v\n\t\telseif v < m2 then\n\t\t\tm2 = v\n\t\tend\n\tend\n\
    \treturn m2 == math.huge and nil or m2\nend", "    local min\n    local min2\n\
    \    for _,v in ipairs(lst) do\n        if not min or v < min then\n         \
    \   min2 = min\n            min = v\n        elseif not min2 or v < min2 then\n\
    \            min2 = v\n        end\n    end\n    return min2\nend", "  local l\
    \ = table.copy(lst)\n  table.sort(l)\n  if l[2] then\n    return l[2]\n  end\n\
    end", "    if #lst < 2 then\n        return nil\n    end\n    local min = lst[1]\n\
    \    local second = lst[2]\n    for i, v in ipairs(lst) do\n        if v < min\
    \ then\n            second = min\n            min = v\n        elseif v < second\
    \ then\n            second = v\n        end\n    end\n    return second\nend",
  "  table.sort(lst)\n  local tmp = nil\n  for _,v in ipairs(lst) do\n    if tmp ~=\
    \ nil and tmp ~= v then\n      return v\n    end\n    tmp = v\n  end\n  return\
    \ nil\nend", "  local smallest, smallest_index, second_smallest\n  for index,\
    \ number in ipairs(lst) do\n    if smallest == nil or number < smallest then\n\
    \      second_smallest = smallest\n      smallest = number\n      smallest_index\
    \ = index\n    elseif second_smallest == nil or number < second_smallest then\n\
    \      second_smallest = number\n    end\n  end\n  return second_smallest\nend",
  "    return select(2, table.sort(lst))\nend", "    local lowest = math.huge\n  \
    \  local secondLowest = math.huge\n    local current", "  table.sort(lst)\n  return\
    \ lst[2]\nend", "  local res = min(lst)\n  if #lst == 1 then return nil end\n\
    \  return min(filter(function(x) return x ~= res end, lst))\nend", "  -- your\
    \ code here\nend", "  -- your code here\nend", "  local min = math.huge\n  local\
    \ min2 = math.huge\n  for i,v in ipairs(lst) do\n    if v < min then\n      min2\
    \ = min\n      min = v\n    elseif v > min and v < min2 then\n      min2 = v\n\
    \    end\n  end\n  return min2 == math.huge and nil or min2\nend", "    if #lst\
    \ < 2 then\n        return nil\n    end\n    table.sort(lst)\n    for i = 2, #lst\
    \ do\n        if lst[i] ~= lst[1] then\n            return lst[i]\n        end\n\
    \    end\n    return nil\nend", "    if #lst < 2 then\n        return nil\n  \
    \  end\n    local smallest = math.min(unpack(lst))\n    if smallest == lst[1]\
    \ then\n        table.remove(lst, 1)\n    else\n        table.remove(lst, get_index(lst,\
    \ smallest))\n    end\n    return math.min(unpack(lst))\nend", "  local _, second\
    \ = table.unpack(lst)\n  for _, i in ipairs(lst) do\n    if i < second then\n\
    \      second = i\n    end\n  end\n  return second\nend", "  local min, min2 =\
    \ nil, nil\n  for _, v in ipairs(lst) do\n    if not min or v < min then\n   \
    \   min2 = min\n      min = v\n    elseif not min2 or v < min2 then\n      min2\
    \ = v\n    end\n  end\n  return min2\nend", "\tif not lst or #lst < 2 then return\
    \ nil end\n\t-- Implementation here\nend", "  local min, min2 = math.huge, math.huge\n\
    \  for _, v in ipairs(lst) do\n    if v < min then\n      min2 = min\n      min\
    \ = v\n    elseif v < min2 then\n      min2 = v\n    end\n  end\n  return min2\
    \ ~= math.huge and min2 or nil\nend", "    if #lst < 2 then\n        return nil\n\
    \    end\n    local smallest, smallest_idx = math.huge, nil\n    local second_smallest,\
    \ second_smallest_idx = math.huge, nil\n    for i, v in ipairs(lst) do\n     \
    \   if v < smallest then\n            second_smallest, second_smallest_idx = smallest,\
    \ smallest_idx\n            smallest, smallest_idx = v, i\n        elseif v <\
    \ second_smallest then\n            second_smallest, second_smallest_idx = v,\
    \ i\n        end\n    end\n    return second_smallest\nend\nassert(next_smallest({1,\
    \ 2, 3, 4, 5}) == 2)\nassert(next_smallest({5, 1, 4, 3, 2}) == 2)\nassert(next_smallest({})\
    \ == nil)\nassert(next_smallest({1, 1}) == nil)\nassert(next_smallest({1}) ==\
    \ nil)", "  if #lst < 2 then return nil end\n  local lst1 = tablex.copy(lst)\n\
    \  table.sort(lst1)\n  for i = 2, #lst1 do\n    if lst1[i] ~= lst1[1] then\n \
    \     return lst1[i]\n    end\n  end\n  return nil\nend", "  local smallest, smallest_index\
    \ = math.huge, 0\n  local second_smallest, second_smallest_index = math.huge,\
    \ 0\n  for i, v in ipairs(lst) do\n    if v < smallest then\n      second_smallest,\
    \ second_smallest_index = smallest, smallest_index\n      smallest, smallest_index\
    \ = v, i\n    elseif v < second_smallest then\n      second_smallest, second_smallest_index\
    \ = v, i\n    end\n  end\n  return second_smallest_index > 0 and second_smallest\
    \ or nil\nend", "  local min, next_min\n  for _,v in ipairs(lst) do\n    if not\
    \ min or v < min then\n      next_min = min\n      min = v\n    elseif not next_min\
    \ or v < next_min then\n      next_min = v\n    end\n  end\n  return next_min\n\
    end", "  local function uniq(a)\n    local t = {}\n    for i = 1, #a do\n    \
    \  t[a[i]] = true\n    end\n    return t\n  end\n  local l = #lst\n  local t =\
    \ uniq(lst)\n  local c = 0\n  for k, _ in pairs(t) do\n    c = c + 1\n  end\n\
    \  if c == l or c == 1 then\n    return nil\n  end\n  local a = {}\n  for i =\
    \ 1, #lst do\n    a[i] = lst[i]\n  end\n  table.sort(a)\n  return a[2]\nend",
  "  local smallest = nil\n  local next_smallest = nil\n  for _, e in ipairs(lst)\
    \ do\n    if smallest == nil or e < smallest then\n      next_smallest = smallest\n\
    \      smallest = e\n    elseif next_smallest == nil or e < next_smallest then\n\
    \      next_smallest = e\n    end\n  end\n  return next_smallest\nend", "  if\
    \ (#lst <= 1) then return nil end\n  local min, min2 = math.huge, math.huge\n\
    \  for i = 1, #lst do\n    if (lst[i] < min) then\n      min2 = min\n      min\
    \ = lst[i]\n    elseif (lst[i] < min2) then\n      min2 = lst[i]\n    end\n  end\n\
    \  return min2\nend", "    local x = math.huge\n    local y = math.huge\n    local\
    \ small = true\n    for _, n in ipairs(lst) do\n        if n < x then\n      \
    \      x, y = n, x\n            small = true\n        elseif n < y then\n    \
    \        y = n\n            small = false\n        end\n    end\n    return small\
    \ and y or nil\nend\nassert(next_smallest({1, 2, 3, 4, 5}) == 2)\nassert(next_smallest({5,\
    \ 1, 4, 3, 2}) == 2)\nassert(next_smallest({}) == nil)\nassert(next_smallest({1,\
    \ 1}) == nil)\nassert(next_smallest({1, 2, 2, 3, 3, 3}) == 2)\nassert(next_smallest({1,\
    \ 1, 1, 2, 2, 2}) == 2)\nassert(next_smallest({2, 1, 1, 1, 1, 1}) == nil)", " \
    \ local min = math.huge\n  local min2 = math.huge\n  for _, v in ipairs(lst) do\n\
    \    if v <= min then\n      min2 = min\n      min = v\n    elseif v < min2 then\n\
    \      min2 = v\n    end\n  end\n  return min2 == math.huge and nil or min2\n\
    end", "  local min_val = math.huge\n  local next_val = math.huge\n  for _, v in\
    \ ipairs(lst) do\n    if v < min_val then\n      next_val = min_val\n      min_val\
    \ = v\n    elseif v < next_val then\n      next_val = v\n    end\n  end\n  return\
    \ min_val == next_val and next_val or nil\nend", end, "  local function smallest(lst)\n\
    \    local last = math.huge\n    for _,e in ipairs(lst) do\n      if e < last\
    \ then\n        last = e\n      end\n    end\n    return last\n  end\n  local\
    \ function remove(e, lst)\n    local i = 1\n    while lst[i] ~= e do\n      i\
    \ = i + 1\n    end\n    table.remove(lst, i)\n  end\n  local sm = smallest(lst)\n\
    \  if not sm then\n    return nil\n  end\n  remove(sm, lst)\n  return smallest(lst)\n\
    end\nassert(not next_smallest({}))\nassert(not next_smallest({1, 1}))\nassert(next_smallest({1,\
    \ 2, 3, 4, 5}) == 2)\nassert(next_smallest({5, 1, 4, 3, 2}) == 2)", "  -- your\
    \ code here\nend", "  table.sort(lst)\n  if lst[1] ~= lst[2] then\n    return\
    \ lst[2]\n  end\n  return nil\nend", "    if #lst < 2 then\n        return nil\n\
    \    end\n    local min, min2\n    for _, v in ipairs(lst) do\n        if not\
    \ min or v < min then\n            min2 = min\n            min = v\n        elseif\
    \ not min2 or v < min2 then\n            min2 = v\n        end\n    end\n    return\
    \ min2\nend\nassert(next_smallest({1, 2, 3, 4, 5}) == 2)\nassert(next_smallest({5,\
    \ 1, 4, 3, 2}) == 2)\nassert(next_smallest({}) == nil)\nassert(next_smallest({1,\
    \ 1}) == nil)\nassert(next_smallest({4, 1, 1}) == nil)", "  local t = {}\n  for\
    \ i, v in ipairs(lst) do\n    if not t[v] then\n      t[v] = true\n    end\n \
    \ end\n  local len = 0\n  for _ in pairs(t) do\n    len = len + 1\n  end\n  if\
    \ len < 2 then\n    return nil\n  end\n  table.sort(lst)\n  local prev = nil\n\
    \  for i, v in ipairs(lst) do\n    if v ~= prev then\n      return v\n    end\n\
    \    prev = v\n  end\nend\nassert(next_smallest({1, 2, 3, 4, 5}) == 2)\nassert(next_smallest({5,\
    \ 1, 4, 3, 2}) == 2)\nassert(next_smallest({}) == nil)\nassert(next_smallest({1,\
    \ 1}) == nil)", end, "  local min, min2 = lst[1], nil\n  for _, v in ipairs(lst)\
    \ do\n    if v < min then\n      min2 = min\n      min = v\n    elseif v < min2\
    \ or min2 == nil then\n      min2 = v\n    end\n  end\n  return min2\nend", " \
    \ local len = #lst\n  if len <= 1 then return nil end\n  local first, second =\
    \ math.min(lst[1], lst[2]), math.max(lst[1], lst[2])\n  if len == 2 then return\
    \ first end\n  for i = 3, len do\n    if lst[i] < first then\n      second = first\n\
    \      first = lst[i]\n    elseif lst[i] < second then\n      second = lst[i]\n\
    \    end\n  end\n  return second\nend", "  local _, n = next(lst)\n  if n == nil\
    \ then return nil end\n  local small, nsmall = n, nil\n  for _, i in ipairs(lst)\
    \ do\n    if i < small then\n      nsmall = small\n      small = i\n    elseif\
    \ i > small and (nsmall == nil or i < nsmall) then\n      nsmall = i\n    end\n\
    \  end\n  return nsmall\nend", "  local _,min = math.min(unpack(lst))\n  for _,v\
    \ in ipairs(lst) do\n    if v>min then return v end\n  end\nend", "  local min\
    \ = nil\n  local min2 = nil\n  for _, v in ipairs(lst) do\n    if not min or v\
    \ < min then\n      min2 = min\n      min = v\n    elseif not min2 or v < min2\
    \ then\n      min2 = v\n    end\n  end\n  return min2\nend", "  local smallest\
    \ = math.huge\n  local nsmallest = math.huge\n  for _, v in ipairs(lst) do\n \
    \   if v < smallest then\n      nsmallest = smallest\n      smallest = v\n   \
    \ elseif v < nsmallest then\n      nsmallest = v\n    end\n  end\n  return nsmallest\
    \ < math.huge and nsmallest or nil\nend", "  local min_el, min_idx, curr_min_el,\
    \ curr_min_idx = math.huge, -1, math.huge, -1\n  for i = 1, #lst do\n    if lst[i]\
    \ < min_el then\n      min_el, min_idx = lst[i], i\n    end\n  end\n  for i =\
    \ 1, #lst do\n    if lst[i] > min_el and lst[i] < curr_min_el then\n      curr_min_el,\
    \ curr_min_idx = lst[i], i\n    end\n  end\n  return curr_min_idx ~= -1 and curr_min_el\
    \ or nil\nend", "  -- your code here\nend", "    if #lst < 2 then\n        return\
    \ nil\n    end\n    local min = lst[1]\n    local min2 = nil\n    for _, v in\
    \ ipairs(lst) do\n        if v < min then\n            min2 = min\n          \
    \  min = v\n        elseif v ~= min and (min2 == nil or v < min2) then\n     \
    \       min2 = v\n        end\n    end\n    return min2\nend", "  if #lst <= 1\
    \ then return nil end\n  local smallest, smallest_index = lst[1], 1\n  local next_smallest,\
    \ next_smallest_index = nil, 1\n  for i, x in ipairs(lst) do\n    if x < smallest\
    \ then\n      next_smallest, next_smallest_index = smallest, smallest_index\n\
    \      smallest, smallest_index = x, i\n    elseif next_smallest == nil or x <\
    \ next_smallest then\n      next_smallest, next_smallest_index = x, i\n    end\n\
    \  end\n  return next_smallest, next_smallest_index\nend", "  if (#lst < 2) then\
    \ return nil end\n  local smallest = lst[1]\n  local second = nil\n  for _,v in\
    \ ipairs(lst) do\n    if (v < smallest) then\n      second = smallest\n      smallest\
    \ = v\n    elseif (v ~= smallest and (second == nil or v < second)) then\n   \
    \   second = v\n    end\n  end\n  return second\nend", "  -- insert code here\n\
    end", "  if #lst < 2 then return nil end\n  table.sort(lst)\n  local max, min\
    \ = lst[#lst], lst[1]\n  if min == max then return nil end\n  return lst[2]\n\
    end", "  local secondSmallest\n  local smallest\n  for i, v in ipairs(lst) do\n\
    \    if not smallest or smallest > v then\n      secondSmallest = smallest\n \
    \     smallest = v\n    elseif not secondSmallest or secondSmallest > v then\n\
    \      secondSmallest = v\n    end\n  end\n  return secondSmallest\nend", "  local\
    \ t = {}\n  for i = 1, #lst do\n    t[i] = lst[i]\n  end\n  table.sort(t)\n  local\
    \ current = nil\n  for i = 1, #t do\n    if current == nil then\n      current\
    \ = t[i]\n    elseif current ~= t[i] then\n      return t[i]\n    end\n  end\n\
    \  return nil\nend\nassert(next_smallest({1, 2, 3, 4, 5}) == 2)\nassert(next_smallest({5,\
    \ 1, 4, 3, 2}) == 2)\nassert(next_smallest({}) == nil)\nassert(next_smallest({1,\
    \ 1}) == nil)\nassert(next_smallest({1, 1, 2}) == 2)", "\tlocal smallest, sm_smallest\
    \ = math.huge, math.huge\n\tfor _, v in ipairs(lst) do\n\t\tif v < smallest then\n\
    \t\t\tsm_smallest = smallest\n\t\t\tsmallest = v\n\t\telseif v < sm_smallest then\n\
    \t\t\tsm_smallest = v\n\t\tend\n\tend\n\treturn sm_smallest == math.huge and nil\
    \ or sm_smallest\nend", "    if #lst == 0 then\n        return nil\n    end\n\
    \    if #lst == 1 then\n        return nil\n    end\n    if #lst == 2 then\n \
    \       if lst[1] < lst[2] then\n            return lst[2]\n        else\n   \
    \         return lst[1]\n        end\n    end\n    local min = lst[1]\n    local\
    \ min2 = lst[2]\n    for i, v in ipairs(lst) do\n        if v < min then\n   \
    \         min2 = min\n            min = v\n        elseif v < min2 then\n    \
    \        min2 = v\n        end\n    end\n    return min2\nend", "  local sorted\
    \ = {}\n  for i = 1, #lst do\n    sorted[i] = lst[i]\n  end\n  table.sort(sorted)\n\
    \  local smallest = sorted[1]\n  local next_smallest = sorted[2]\n  if next_smallest\
    \ == smallest then\n    return nil\n  end\n  return next_smallest\nend", "   \
    \ return nil\nend", "  local smallest, smallest_index, second_smallest, second_smallest_index\
    \ =\n    math.huge, nil, math.huge, nil\n  for index, value in ipairs(lst) do\n\
    \    if value < smallest then\n      second_smallest, second_smallest_index =\
    \ smallest, smallest_index\n      smallest, smallest_index = value, index\n  \
    \  elseif value < second_smallest then\n      second_smallest, second_smallest_index\
    \ = value, index\n    end\n  end\n  return second_smallest, second_smallest_index\n\
    end", "  local s = math.huge\n  local ss = math.huge\n  for _,x in ipairs(lst)\
    \ do\n    if x < s then\n      ss = s\n      s = x\n    elseif x < ss then\n \
    \     ss = x\n    end\n  end\n  return s ~= ss and ss or nil\nend", "    if #lst\
    \ == 0 then\n        return nil\n    end\n    local smallest = lst[1]\n    local\
    \ nextSmallest = lst[1]\n    for i = 2, #lst do\n        if lst[i] < smallest\
    \ then\n            nextSmallest = smallest\n            smallest = lst[i]\n \
    \       elseif lst[i] < nextSmallest then\n            nextSmallest = lst[i]\n\
    \        end\n    end\n    if nextSmallest == smallest then\n        return nil\n\
    \    end\n    return nextSmallest\nend", "  local sec_small = math.huge\n  local\
    \ smallest = math.huge\n  for i = 1, #lst do\n    if lst[i] < smallest then\n\
    \      sec_small = smallest\n      smallest = lst[i]\n    elseif lst[i] < sec_small\
    \ then\n      sec_small = lst[i]\n    end\n  end\n  if sec_small == math.huge\
    \ then\n    return nil\n  end\n  return sec_small\nend", "  table.sort(lst)\n\
    \  for i = 1, #lst - 1 do\n    if lst[i] ~= lst[i + 1] then\n      return lst[i\
    \ + 1]\n    end\n  end\n  return nil\nend", "    local min2\n    local min1\n\
    \    for _, l in ipairs(lst) do\n        if l < min1 or min1 == nil then\n   \
    \         min2 = min1\n            min1 = l\n        elseif l < min2 or min2 ==\
    \ nil then\n            min2 = l\n        end\n    end\n    return min2\nend",
  "  table.sort(lst)\n  return lst[2] or nil\nend", "  local min = math.huge\n  local\
    \ min_2 = math.huge\n  for _, v in ipairs(lst) do\n    if v < min then\n     \
    \ min_2 = min\n      min = v\n    elseif v < min_2 then\n      min_2 = v\n   \
    \ end\n  end\n  return min_2 == math.huge and nil or min_2\nend", "  local min,\
    \ min2\n  for i = 1, #lst do\n    if min == nil or lst[i] < min then\n      min2\
    \ = min\n      min = lst[i]\n    elseif min2 == nil or lst[i] < min2 then\n  \
    \    min2 = lst[i]\n    end\n  end\n  return min2\nend", "    local fst, sec =\
    \ lst[1], lst[2]\n    if fst == nil or sec == nil then\n        return nil\n \
    \   end\n    if fst > sec then\n        fst, sec = sec, fst\n    end\n    for\
    \ i = 3, #lst do\n        if lst[i] <= fst then\n            fst, sec = lst[i],\
    \ fst\n        elseif lst[i] < sec then\n            sec = lst[i]\n        end\n\
    \    end\n    return sec\nend", "  local n1, n2\n  for _, v in ipairs(lst) do\n\
    \    if n1 then\n      if n2 then\n        if v < n1 then\n          n2 = n1\n\
    \          n1 = v\n        elseif v < n2 then\n          n2 = v\n        end\n\
    \      else\n        if v < n1 then\n          n2 = n1\n          n1 = v\n   \
    \     else\n          n2 = v\n        end\n      end\n    else\n      n1 = v\n\
    \    end\n  end\n  return n2\nend", "\tlocal min = math.huge\n\tlocal min2 = min\n\
    \tfor _, v in ipairs(lst) do\n\t\tif v < min then\n\t\t\tmin2 = min\n\t\t\tmin\
    \ = v\n\t\telseif v < min2 then\n\t\t\tmin2 = v\n\t\tend\n\tend\n\treturn min2\
    \ == math.huge and nil or min2\nend", "  local sorted = {}\n  local sorted_count\
    \ = 0\n  local count = #lst\n  if count == 0 then\n    return nil\n  end\n  for\
    \ i = 1, count do\n    if sorted_count == 0 then\n      sorted[1] = lst[i]\n \
    \     sorted_count = 1\n    else\n      for j = 1, sorted_count do\n        if\
    \ lst[i] < sorted[j] then\n          table.insert(sorted, j, lst[i])\n       \
    \   sorted_count = sorted_count + 1\n          break\n        elseif j == sorted_count\
    \ then\n          sorted[sorted_count + 1] = lst[i]\n          sorted_count =\
    \ sorted_count + 1\n          break\n        end\n      end\n    end\n  end\n\
    \  if sorted_count == 1 then\n    return nil\n  end\n  return sorted[2]\nend",
  "  if #lst <= 1 then return nil end\n  local smallest = math.min(table.unpack(lst))\n\
    \  local second_smallest = math.max(table.unpack(lst))\n  for _, v in ipairs(lst)\
    \ do\n    if v ~= smallest and v < second_smallest then\n      second_smallest\
    \ = v\n    end\n  end\n  if second_smallest == math.max(table.unpack(lst)) then\n\
    \    return nil\n  else\n    return second_smallest\n  end\nend", "  if #lst <\
    \ 2 then return nil end\n  local smaller, smaller_i = lst[1], 1\n  for i, v in\
    \ ipairs(lst) do\n    if v < smaller then\n      smaller, smaller_i = v, i\n \
    \   end\n  end\n  local second_smaller, second_smaller_i = lst[1], 1\n  for i,\
    \ v in ipairs(lst) do\n    if i ~= smaller_i and v < second_smaller then\n   \
    \   second_smaller, second_smaller_i = v, i\n    end\n  end\n  return second_smaller\n\
    end", "  table.sort(lst)\n  for i,v in ipairs(lst) do\n    if v ~= lst[1] then\n\
    \      return v\n    end\n  end\n  return nil\nend", "  local num = math.huge\n\
    \  local num2 = math.huge\n  for _, v in ipairs(lst) do\n    if num2 > v then\n\
    \      if num > v then\n        num2 = num\n        num = v\n      else\n    \
    \    num2 = v\n      end\n    end\n  end\n  if num == math.huge then\n    return\
    \ nil\n  end\n  return num2\nend", "  table.sort(lst)\n  if #lst == 0 then\n \
    \   return nil\n  elseif #lst == 1 then\n    return nil\n  elseif #lst == 2 then\n\
    \    if lst[1] == lst[2] then\n      return nil\n    else\n      return lst[2]\n\
    \    end\n  else\n    local smallest = lst[1]\n    local second_smallest = lst[2]\n\
    \    for i=3,#lst do\n      if lst[i] < smallest then\n        second_smallest\
    \ = smallest\n        smallest = lst[i]\n      elseif second_smallest == smallest\
    \ then\n        second_smallest = lst[i]\n      elseif lst[i] < second_smallest\
    \ then\n        second_smallest = lst[i]\n      end\n    end\n    return second_smallest\n\
    \  end\nend", "  if #lst < 2 then return nil end\n  local max, curr = lst[1],\
    \ lst[2]\n  for i = 3, #lst do\n    if lst[i] < max then\n      max, curr = lst[i],\
    \ max\n    elseif lst[i] < curr then\n      curr = lst[i]\n    end\n  end\n  return\
    \ curr\nend", "  table.sort(lst)\n  return lst[2]\nend", "  return head(tail(sort(lst)))\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
