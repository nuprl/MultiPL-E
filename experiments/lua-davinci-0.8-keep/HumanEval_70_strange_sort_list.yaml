name: HumanEval_70_strange_sort_list
language: lua
prompt: "-- Given list of integers, return list in strange order.\n-- Strange sorting,\
  \ is when you start with the minimum value,\n-- then maximum of the remaining integers,\
  \ then minimum and so on.\n-- Examples:\n-- strange_sort_list([1, 2, 3, 4]) == [1,\
  \ 4, 2, 3]\n-- strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n-- strange_sort_list([])\
  \ == []\nlocal function strange_sort_list(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = strange_sort_list\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 4, 2, 3})\n    lu.assertEquals(candidate({5,\
  \ 6, 7, 8, 9}), {5, 9, 6, 8, 7})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5}),\
  \ {1, 5, 2, 4, 3})\n    lu.assertEquals(candidate({5, 6, 7, 8, 9, 1}), {1, 9, 5,\
  \ 8, 6, 7})\n    lu.assertEquals(candidate({5, 5, 5, 5}), {5, 5, 5, 5})\n    lu.assertEquals(candidate({}),\
  \ {})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8}), {1, 8, 2, 7, 3,\
  \ 6, 4, 5})\n    lu.assertEquals(candidate({0, 2, 2, 2, 5, 5, -5, -5}), {-5, 5,\
  \ -5, 5, 0, 2, 2, 2})\n    lu.assertEquals(candidate({111111}), {111111})\nend\n\
  \nos.exit(lu.LuaUnit.run())"
completions: ["    return min_max_sort(lst)\nend", "\tlocal result = {}\n\tlocal temp\
    \ = {}\n\tfor k, v in pairs(lst) do\n\t\ttemp[k] = v\n\tend\n\ttable.sort(temp)\n\
    \tlocal pos = 2\n\tfor i = 1, #temp / 2 do\n\t\tresult[i * 2 - 1] = temp[i]\n\t\
    \tresult[i * 2] = temp[#temp - i + 1]\n\tend\n\tif (#temp % 2) == 1 then\n\t\t\
    result[#result + 1] = temp[math.ceil(#temp / 2)]\n\tend\n\treturn result\nend",
  "    table.sort(lst)\n    local b\n    local res = {}\n    for i=1, #lst do\n  \
    \      if i % 2 == 1 then\n            b = i\n        else\n            b = #lst\
    \ - i + 1\n        end\n        table.insert(res, lst[b])\n    end\n    return\
    \ res\nend", "    if #lst == 0 then\n        return lst\n    end\n    local new_lst\
    \ = {}\n    local val_max, val_min\n    for i = 1, #lst do\n        local val\
    \ = table.remove(lst, 1)\n        if val_max == nil or val > val_max then\n  \
    \          table.insert(new_lst, val)\n            val_max = val\n        elseif\
    \ val_min == nil or val < val_min then\n            table.insert(new_lst, 1, val)\n\
    \            val_min = val\n        else\n            table.insert(lst, val)\n\
    \        end\n    end\n    return new_lst\nend", "\tlocal function _strange_sort_list(lst,\
    \ idx)\n\t\tif #lst == 0 then return {} end\n\t\tlocal first = math.min(unpack(lst))\n\
    \t\tlocal second = math.max(unpack(remove_item(lst, first)))\n\t\tlocal first_idx\
    \ = idx\n\t\tlocal second_idx = math.floor(idx/2)\n\t\tif idx % 2 == 0 then\n\t\
    \t\tfirst_idx = math.floor(idx/2)\n\t\t\tsecond_idx = idx\n\t\tend\n\t\tlocal\
    \ new_lst = {}\n\t\tfor i = 1, #lst do\n\t\t\tif i == first_idx then\n\t\t\t\t\
    table.insert(new_lst, first)\n\t\t\telseif i == second_idx then\n\t\t\t\ttable.insert(new_lst,\
    \ second)\n\t\t\telse\n\t\t\t\ttable.insert(new_lst, lst[i])\n\t\t\tend\n\t\t\
    end\n\t\treturn _strange_sort_list(remove_item(new_lst, second), idx + 1)\n\t\
    end\n\treturn _strange_sort_list(lst, 1)\nend", "    local function apply(lst,\
    \ fn)\n        local res = {}\n        for i = 1, #lst do\n            res[i]\
    \ = fn(lst[i])\n        end\n        return res\n    end", "    if not lst then\
    \ return nil end\n    if #lst == 0 then return {} end\n    local res = {}\n  \
    \  local slst = table.sort(lst)\n    local cnt = #lst\n    local from = 1\n  \
    \  local to = cnt\n    local i = 1\n    while true do\n        if i % 2 == 1 then\n\
    \            table.insert(res, slst[from])\n            from = from + 1\n    \
    \    else\n            table.insert(res, slst[to])\n            to = to - 1\n\
    \        end\n        if #res == cnt then break end\n        i = i + 1\n    end\n\
    \    return res\nend", "  local res = {}\n  local idx = 1\n  local left = #lst\n\
    \  local lo, hi\n  while #res < #lst do\n    lo, hi = 1, left\n    for i = 1,\
    \ left do\n      if lst[i] < lst[lo] then\n        lo = i\n      end\n      if\
    \ lst[i] > lst[hi] then\n        hi = i\n      end\n    end\n    res[idx] = lst[lo]\n\
    \    lst[lo] = lst[left]\n    idx = idx + 1\n    res[idx] = lst[hi]\n    lst[hi]\
    \ = lst[left]\n    idx = idx + 1\n    left = left - 1\n  end\n  return res\nend",
  "    if not lst or #lst == 0 then\n        return lst\n    end\n    local copy =\
    \ copy_list(lst)\n    table.sort(copy)\n    local ind = 1\n    local res = {}\n\
    \    while ind <= #copy do\n        table.insert(res, copy[ind])\n        table.insert(res,\
    \ copy[#copy - ind + 1])\n        ind = ind + 1\n    end\n    return res\nend",
  "  local lst_sort = {}\n  local lst_norm = {}\n  for i, val in ipairs(lst) do\n\
    \    lst_norm[#lst_norm + 1] = val\n  end\n  table.sort(lst_norm)\n  local min,\
    \ max = lst_norm[1], lst_norm[#lst_norm]\n  local min_start = true\n  while #lst_norm\
    \ > 0 do\n    if min_start then\n      lst_sort[#lst_sort + 1] = min\n      table.remove(lst_norm,\
    \ 1)\n      min_start = false\n    else\n      lst_sort[#lst_sort + 1] = max\n\
    \      table.remove(lst_norm, #lst_norm)\n      min_start = true\n    end\n  end\n\
    \  return lst_sort\nend", "    table.sort(lst)\n    local n = math.floor(#lst\
    \ / 2)\n    for i = 1, n do\n        local l = lst[2 * i - 1]\n        lst[2 *\
    \ i - 1] = lst[#lst - i + 1]\n        lst[#lst - i + 1] = l\n    end\n    return\
    \ lst\nend", "    local aux = {}\n    local i = 1\n    local j = #lst\n    while\
    \ i <= #lst and j >= 1 do\n        aux[#aux + 1] = lst[i]\n        aux[#aux +\
    \ 1] = lst[j]\n        i = i + 1\n        j = j - 1\n    end\n    return aux\n\
    end", "  local res = {}\n  table.sort(lst)\n  for i = 1, #lst do\n    if #res\
    \ % 2 == 0 then\n      table.insert(res, 1, lst[i])\n    else\n      table.insert(res,\
    \ lst[i])\n    end\n  end\n  return res\nend", "    table.sort(lst)\n    local\
    \ len = #lst\n    local res = {}\n    for i = 1, len, 2 do\n        res[i] = lst[i]\n\
    \        res[i + 1] = lst[len - i + 1]\n    end\n    return res\nend", "    if\
    \ #lst == 0 then\n        return lst\n    end\n    local min_val = math.min(unpack(lst))\n\
    \    local new_lst = {min_val}\n    table.remove(lst, table.index_of(lst, min_val))\n\
    \    while #lst > 0 do\n        local max_val = math.max(unpack(lst))\n      \
    \  table.insert(new_lst, max_val)\n        table.remove(lst, table.index_of(lst,\
    \ max_val))\n        if #lst > 0 then\n            local min_val = math.min(unpack(lst))\n\
    \            table.insert(new_lst, min_val)\n            table.remove(lst, table.index_of(lst,\
    \ min_val))\n        end\n    end\n    return new_lst\nend", "\tif #lst == 0 then\
    \ return {} end\n\tif #lst == 1 then return lst end\n\tif #lst == 2 then return\
    \ {lst[1], lst[2]} end\n\tlocal res = {}\n\tlocal lst_1 = {}\n\tlocal lst_2 =\
    \ {}\n\tlocal index = #lst\n\tlocal flag = true\n\twhile index > 0 do\n\t\tif\
    \ flag then\n\t\t\ttable.insert(lst_1, table.remove(lst, 1))\n\t\telse\n\t\t\t\
    table.insert(lst_2, table.remove(lst, 1))\n\t\tend\n\t\tflag = not flag\n\t\t\
    index = index - 1\n\tend\n\treturn strange_sort_list(lst_1)..\n\t\t\tstrange_sort_list(lst_2)\n\
    end", "    table.sort(lst)\n    local new_lst = {}\n    for i = 1, #lst, 2 do\n\
    \        table.insert(new_lst, lst[i])\n        if lst[i + 1] then\n         \
    \   table.insert(new_lst, lst[#lst - i + 1])\n        end\n    end\n    return\
    \ new_lst\nend", "    local result = {}\n    local max_idx = 0\n    local min_idx\
    \ = 0\n    local n = #lst\n    for i = 1, n do\n        max_idx = math.max(table.unpack(lst))\n\
    \        min_idx = math.min(table.unpack(lst))\n        table.insert(result, min_idx)\n\
    \        table.insert(result, max_idx)\n        lst[max_idx] = nil\n        lst[min_idx]\
    \ = nil\n    end\n    return result\nend", "  local res = {}\n  local a, b, c\n\
    \  local tmp = {}\n  local idx = 0\n  for _, v in ipairs(lst) do\n    table.insert(tmp,\
    \ v)\n  end\n  while idx < #tmp do\n    a = table.remove(tmp, 1)\n    b = table.remove(tmp,\
    \ 1)\n    c = table.remove(tmp, 1)\n    table.insert(res, a)\n    table.insert(res,\
    \ c)\n    table.insert(res, b)\n    idx = idx + 3\n  end\n  return res\nend",
  "  local o = {}\n  local odd = {}\n  local even = {}\n  for i, v in ipairs(lst)\
    \ do\n    if v % 2 == 0 then\n      table.insert(even, v)\n    else\n      table.insert(odd,\
    \ v)\n    end\n  end\n  table.sort(odd)\n  table.sort(even)\n  local i = 1\n \
    \ local j = 1\n  while i <= #odd and j <= #even do\n    table.insert(o, odd[i])\n\
    \    table.insert(o, even[j])\n    i = i + 1\n    j = j + 1\n  end\n  if i > #odd\
    \ then\n    for k = j, #even do\n      table.insert(o, even[k])\n    end\n  else\n\
    \    for k = i, #odd do\n      table.insert(o, odd[k])\n    end\n  end\n  return\
    \ o\nend", "  local lst_len = #lst\n  if lst_len == 0 then\n    return lst\n \
    \ end\n  local res = {}\n  local i = 1\n  local acc = 0\n  while i <= lst_len\
    \ do\n    table.insert(res, i, lst[acc + 1])\n    i = i + 1\n    acc = acc + lst_len\
    \ - i + 1\n  end\n  return res\nend", "  table.sort(lst)\n  local out = {}\n \
    \ for i = 1, #lst, 2 do\n    out[#out + 1] = lst[i]\n    if i + 1 <= #lst then\n\
    \      out[#out + 1] = lst[#lst - i + 1]\n    end\n  end\n  return out\nend",
  "  local lst1 = {}\n  local lst2 = {}\n  local lst3 = {}\n  local lst4 = {}\n  for\
    \ i = 1, #lst do\n    if (lst[i] < lst[i + 1]) then\n      lst1[#lst1 + 1] = lst[i]\n\
    \    elseif (lst[i] > lst[i + 1]) then\n      lst2[#lst2 + 1] = lst[i]\n    elseif\
    \ (lst[i] == lst[i + 1]) then\n      lst3[#lst3 + 1] = lst[i]\n    end\n  end\n\
    \  table.sort(lst1)\n  table.sort(lst2)\n  table.sort(lst3)\n  for i = 1, #lst1\
    \ do\n    lst4[#lst4 + 1] = lst1[i]\n    lst4[#lst4 + 1] = lst2[i]\n  end\n  for\
    \ i = 1, #lst3 do\n    lst4[#lst4 + 1] = lst3[i]\n  end\n  return lst4\nend",
  "\tlocal t = {}\n\tlocal len = #lst\n\tlocal min = math.min(unpack(lst))\n\tlocal\
    \ max = math.max(unpack(lst))\n\tfor i = 1, len do\n\t\tif i % 2 == 1 then\n\t\
    \t\ttable.insert(t, min)\n\t\t\ttable.remove(lst, table.index_of(lst, min))\n\t\
    \telse\n\t\t\ttable.insert(t, max)\n\t\t\ttable.remove(lst, table.index_of(lst,\
    \ max))\n\t\tend\n\tend\n\treturn t\nend", "    if not lst then return nil end\n\
    \    if lst.len and lst.len() == 0 then return {} end\n    if type(lst) ~= 'table'\
    \ then return nil end\n    if #lst == 0 then return {} end\n    local st, sl,\
    \ s = {}, {}, {}\n    for i, v in ipairs(lst) do\n        st[#st + 1] = v\n  \
    \  end\n    while #st > 0 do\n        table.sort(st)\n        sl[#sl + 1] = st[1]\n\
    \        s[st[1]] = true\n        table.remove(st, 1)\n        if #st > 0 then\n\
    \            table.sort(st, function(a, b) return a > b end)\n            sl[#sl\
    \ + 1] = st[1]\n            s[st[1]] = true\n            table.remove(st, 1)\n\
    \        end\n    end\n    for i, v in ipairs(lst) do\n        if not s[v] then\n\
    \            sl[#sl + 1] = v\n        end\n    end\n    return sl\nend", "   \
    \ if #lst == 0 then\n        return lst\n    end\n    local min = math.min(unpack(lst))\n\
    \    local max = math.max(unpack(lst))\n    local start = true\n    local ret\
    \ = {}\n    for i = 1, #lst do\n        if start then\n            ret[i] = min\n\
    \            start = false\n        else\n            ret[i] = max\n         \
    \   start = true\n        end\n    end\n    return ret\nend", "  return {}\nend",
  "    local res = {}\n    local asc_lst = lst:sort()\n    local asc_lst_len = #asc_lst\n\
    \    local pos = 1\n    while pos <= asc_lst_len do\n        local min = asc_lst[1]\n\
    \        res[#res + 1] = min\n        asc_lst:remove(min)\n        local max =\
    \ asc_lst[1]\n        if max then\n            res[#res + 1] = max\n         \
    \   asc_lst:remove(max)\n        end\n        pos = pos + 2\n    end\n    return\
    \ res\nend", "  table.sort(lst)\n  local left = 1\n  local right = #lst\n  local\
    \ res = {}\n  while right >= left do\n    res[#res + 1] = lst[left]\n    if right\
    \ > left then\n      res[#res + 1] = lst[right]\n    end\n    left = left + 1\n\
    \    right = right - 1\n  end\n  return res\nend", "    -- your code here\n  \
    \  local result = {}\n    table.sort(lst)\n    local left = 1\n    local right\
    \ = #lst\n    local count = 1\n    while right > left do\n        result[count]\
    \ = lst[left]\n        result[count + 1] = lst[right]\n        left = left + 1\n\
    \        right = right - 1\n        count = count + 2\n    end\n    if right ==\
    \ left then\n        result[count] = lst[left]\n    end\n    return result\nend",
  "    if #lst <= 1 then\n        return lst\n    end\n    table.sort(lst)\n    local\
    \ t = {}\n    local f = true\n    for i = 1, #lst do\n        if f then\n    \
    \        t[#t + 1] = lst[i]\n        else\n            t[#t + 1] = lst[#lst -\
    \ i + 1]\n        end\n        f = not f\n    end\n    return t\nend", "    local\
    \ ret = {}\n    local i = 1\n    while #lst > 0 do\n        local min, max = get_min_max(lst)\n\
    \        if i % 2 == 1 then\n            ret[i] = min\n            i = i + 1\n\
    \            table.remove(lst, get_index(lst, min))\n        else\n          \
    \  ret[i] = max\n            i = i + 1\n            table.remove(lst, get_index(lst,\
    \ max))\n        end\n    end\n    return ret\nend", "    return {}\nend", " \
    \ local list = {}\n  local list1 = {}\n  local list2 = {}\n  local res = {}\n\
    \  for k, v in pairs(lst) do\n    table.insert(list, v)\n  end\n  table.sort(list)\n\
    \  for k, v in pairs(list) do\n    if k % 2 == 0 then\n      table.insert(list1,\
    \ v)\n    else\n      table.insert(list2, v)\n    end\n  end\n  for k, v in pairs(list2)\
    \ do\n    table.insert(res, v)\n  end\n  for k, v in pairs(list1) do\n    table.insert(res,\
    \ v)\n  end\n  return res\nend", "\tif #lst == 0 then return lst end\n\tlocal\
    \ result = {}\n\ttable.sort(lst)\n\tlocal n = #lst\n\tlocal nh = math.floor(n\
    \ / 2)\n\tfor i = 1, nh do\n\t\tlocal p1 = (2 * i) - 1\n\t\tlocal p2 = 2 * i\n\
    \t\tif p2 > n then p2 = nil end\n\t\tresult[p1] = lst[i]\n\t\tresult[p2] = lst[n\
    \ + 1 - i]\n\tend\n\treturn result\nend", "\tlocal idx_copy = {}\n\tlocal lst_sorted\
    \ = {}\n\tlocal i = 1\n\tlocal j = 1\n\tlocal d, mx, mn\n\tlocal lst_len = table.getn(lst)\n\
    \tlocal lst_res = {}\n\tlocal e = 1\n\twhile e <= lst_len do\n\t\tidx_copy[e]\
    \ = e\n\t\te = e + 1\n\tend\n\td = 1\n\twhile d <= 2 do\n\t\ti = 1\n\t\tj = 1\n\
    \t\twhile i <= lst_len do\n\t\t\tmx = lst[idx_copy[i]]\n\t\t\tj = i + 1\n\t\t\t\
    while j <= lst_len do\n\t\t\t\tif d == 1 then\n\t\t\t\t\tif lst[idx_copy[j]] >\
    \ mx then\n\t\t\t\t\t\tmx = lst[idx_copy[j]]\n\t\t\t\t\t\tidx_copy[i], idx_copy[j]\
    \ = idx_copy[j], idx_copy[i]\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tif lst[idx_copy[j]]\
    \ < mx then\n\t\t\t\t\t\tmx = lst[idx_copy[j]]\n\t\t\t\t\t\tidx_copy[i], idx_copy[j]\
    \ = idx_copy[j], idx_copy[i]\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tj = j + 1\n\t\
    \t\tend\n\t\t\ti = i + 1\n\t\tend\n\t\td = d + 1\n\tend\n\te = 1\n\twhile e <=\
    \ lst_len do\n\t\tlst_res[e] = lst[idx_copy[e]]\n\t\te = e + 1\n\tend\n\treturn\
    \ lst_res\nend", "  local function helper(lst, curr_min, rst)\n    if #lst <=\
    \ 0 then\n      return rst\n    end\n    if #lst == 1 then\n      rst[#rst + 1]\
    \ = lst[1]\n      return rst\n    end\n    local min = math.min(unpack(lst))\n\
    \    local max = math.max(unpack(lst))\n    if curr_min then\n      if min ==\
    \ curr_min then\n        rst[#rst + 1] = max\n        for i = 1, #lst do\n   \
    \       if lst[i] ~= max then\n            lst[i] = lst[i]\n          else\n \
    \           lst[i] = nil\n          end\n        end\n        return helper(lst,\
    \ max, rst)\n      else\n        rst[#rst + 1] = min\n        for i = 1, #lst\
    \ do\n          if lst[i] ~= min then\n            lst[i] = lst[i]\n         \
    \ else\n            lst[i] = nil\n          end\n        end\n        return helper(lst,\
    \ min, rst)\n      end\n    else\n      rst[#rst + 1] = min\n      for i = 1,\
    \ #lst do\n        if lst[i] ~= min then\n          lst[i] = lst[i]\n        else\n\
    \          lst[i] = nil\n        end\n      end\n      return helper(lst, min,\
    \ rst)\n    end\n  end\n  return helper(lst, nil, {})\nend", "    if #lst == 0\
    \ then\n        return lst\n    end\n    local res = {}\n    local sorted = table.sort(lst)\n\
    \    local min, max = sorted[1], sorted[#sorted]\n    local status = 'min'\n \
    \   for i = 1, #sorted do\n        if #res == #sorted then\n            break\n\
    \        end\n        if status == 'min' then\n            table.insert(res, min)\n\
    \            status = 'max'\n        else\n            table.insert(res, max)\n\
    \            status = 'min'\n        end\n    end\n    return res\nend", end,
  "    if next(lst) == nil then\n        return {}\n    end\n    local sort_lst =\
    \ {}\n    local even = true\n    while #lst > 0 do\n        if even then\n   \
    \         table.insert(sort_lst, min(lst))\n        else\n            table.insert(sort_lst,\
    \ max(lst))\n        end\n        even = not even\n    end\n    return sort_lst\n\
    end", "    local left, right = {}, {}\n    for i, v in ipairs(lst) do\n      \
    \  if i % 2 == 0 then\n            left[#left + 1] = v\n        else\n       \
    \     right[#right + 1] = v\n        end\n    end\n    table.sort(left)\n    table.sort(right,\
    \ function(a, b) return a > b end)\n    local res = {}\n    for i = 1, #left +\
    \ #right do\n        if i % 2 == 0 then\n            res[i] = left[i / 2]\n  \
    \      else\n            res[i] = right[math.ceil(i / 2)]\n        end\n    end\n\
    \    return res\nend", "    local res = {}\n    local m = 1\n    local n = #lst\n\
    \    while m <= n do\n        table.insert(res, lst[m])\n        if m == n then\n\
    \            break\n        end\n        table.insert(res, lst[n])\n        m\
    \ = m + 1\n        n = n - 1\n    end\n    return res\nend", "\tlocal a = lst\
    \ or {}\n\tlocal res = {}\n\tlocal i = 1\n\tlocal iter = #a\n\trepeat\n\t\tlocal\
    \ mn, mx = math.min(unpack(a)), math.max(unpack(a))\n\t\tres[i], res[iter] = mn,\
    \ mx\n\t\ti, iter = i + 1, iter - 1\n\t\tfor k, v in ipairs(a) do\n\t\t\tif v\
    \ == mn or v == mx then\n\t\t\t\ttable.remove(a, k)\n\t\t\t\tbreak\n\t\t\tend\n\
    \t\tend\n\tuntil #a == 0\n\treturn res\nend", "    table.sort(lst)\n    local\
    \ res = {}\n    for i=1, #lst do\n        if i % 2 == 1 then\n            table.insert(res,\
    \ lst[i])\n        else\n            table.insert(res, 1, lst[i])\n        end\n\
    \    end\n    return res\nend", "    local list = table.copy(lst)\n    local start\
    \ = {}\n    local rev = {}\n    local result = {}\n    if #list == 0 then\n  \
    \      return list\n    end\n    start = table.get_min_and_max(list)\n    local\
    \ min = start[1]\n    local max = start[2]\n    local min_max = true\n    while\
    \ #list > 0 do\n        if min_max then\n            table.remove_value(list,\
    \ min)\n            table.insert(result, min)\n            if #list > 0 then\n\
    \                start = table.get_min_and_max(list)\n                min = start[1]\n\
    \                max = start[2]\n            end\n            min_max = false\n\
    \        else\n            table.remove_value(list, max)\n            table.insert(result,\
    \ max)\n            if #list > 0 then\n                start = table.get_min_and_max(list)\n\
    \                min = start[1]\n                max = start[2]\n            end\n\
    \            min_max = true\n        end\n    end\n    return result\nend", " \
    \ if #lst == 0 then return lst end\n  table.sort(lst)\n  local head = lst[1]\n\
    \  table.remove(lst, 1)\n  local tail = lst[#lst]\n  table.remove(lst, #lst)\n\
    \  return {head, tail, table.unpack(strange_sort_list(lst))}\nend", "    local\
    \ lst = table.copy(lst)\n    local result = {}\n    while #lst > 0 do\n      \
    \  local i = 1\n        local j = 1\n        for k, v in ipairs(lst) do\n    \
    \        if v > lst[i] then\n                i = k\n            end\n        \
    \    if v < lst[j] then\n                j = k\n            end\n        end\n\
    \        result[#result + 1] = lst[i]\n        table.remove(lst, i)\n        if\
    \ #lst > 0 then\n            result[#result + 1] = lst[j]\n            table.remove(lst,\
    \ j)\n        end\n    end\n    return result\nend", end, "    -- TODO: implement\
    \ me\nend", "\tlocal res = {}\n\tlocal minn, maxx = math.min(table.unpack(lst)),\
    \ math.max(table.unpack(lst))\n\tlocal min, max = false, false\n\tlocal curr =\
    \ lst\n\twhile #curr > 0 do\n\t\tif not min then\n\t\t\tmin = math.min(table.unpack(curr))\n\
    \t\t\ttable.insert(res, min)\n\t\t\ttable.remove(curr, index_of(curr, min))\n\t\
    \t\tmin = false\n\t\telse\n\t\t\tmax = math.max(table.unpack(curr))\n\t\t\ttable.insert(res,\
    \ max)\n\t\t\ttable.remove(curr, index_of(curr, max))\n\t\t\tmax = false\n\t\t\
    end\n\tend\n\treturn res\nend", "    if #lst == 0 then\n        return lst\n \
    \   end\n    local sorted = lst\n    local new_list = {}\n    for i = 1, #lst\
    \ do\n        if i % 2 == 1 then\n            table.insert(new_list, math.min(unpack(sorted)))\n\
    \        else\n            table.insert(new_list, math.max(unpack(sorted)))\n\
    \        end\n        for index, value in ipairs(sorted) do\n            if value\
    \ == new_list[i] then\n                table.remove(sorted, index)\n         \
    \       break\n            end\n        end\n    end\n    return new_list\nend",
  "  table.sort(lst)\n  for i = 1, #lst / 2 do\n    lst[i], lst[#lst - i + 1] = lst[#lst\
    \ - i + 1], lst[i]\n  end\n  return lst\nend", "    local ls = table.copy(lst)\n\
    \    table.sort(ls)\n    local n = math.floor(#ls / 2)\n    local res = {}\n \
    \   for i = 1, n do\n        res[#res + 1] = ls[i]\n        res[#res + 1] = ls[#ls\
    \ - i + 1]\n    end\n    if #ls % 2 == 1 then\n        res[#res + 1] = ls[n +\
    \ 1]\n    end\n    return res\nend", "  local front, back = {}, {}\n  for i, v\
    \ in ipairs(lst) do\n    table.insert(front, v)\n    table.insert(back, v)\n \
    \ end\n  table.sort(front)\n  table.sort(back, function(a, b) return a > b end)\n\
    \  local res = {}\n  while #front > 0 do\n    table.insert(res, table.remove(front,\
    \ 1))\n    if #front > 0 then\n      table.insert(res, table.remove(back, 1))\n\
    \    end\n  end\n  return res\nend", "  table.sort(lst)\n  local out, i = {},\
    \ 1\n  while #lst > 0 do\n    if i % 2 == 1 then\n      table.insert(out, table.remove(lst,\
    \ 1))\n    else\n      table.insert(out, table.remove(lst))\n    end\n    i =\
    \ i + 1\n  end\n  return out\nend", "    return {}\nend", "    -- get min and\
    \ max values\n    local min = math.min(unpack(lst))\n    local max = math.max(unpack(lst))\n\
    \    -- add them to the result table\n    local result = {min, max}\n    -- remove\
    \ them from the list (to avoid duplicates)\n    remove_from_list(lst, min)\n \
    \   remove_from_list(lst, max)\n    -- do the same thing with the remaining values\n\
    \    while #lst > 0 do\n        min = math.min(unpack(lst))\n        max = math.max(unpack(lst))\n\
    \        result[#result + 1] = min\n        result[#result + 1] = max\n      \
    \  remove_from_list(lst, min)\n        remove_from_list(lst, max)\n    end\n \
    \   return result\nend", "\tif (#lst == 0) then\n\t\treturn {}\n\tend\n\tif (#lst\
    \ == 1) then\n\t\treturn lst\n\tend\n\tlocal sorted = {}\n\twhile (#lst > 0) do\n\
    \t\tlocal min_index = 1\n\t\tlocal max_index = 1\n\t\tfor i, v in ipairs(lst)\
    \ do\n\t\t\tif (v < lst[min_index]) then\n\t\t\t\tmin_index = i\n\t\t\tend\n\t\
    \t\tif (v > lst[max_index]) then\n\t\t\t\tmax_index = i\n\t\t\tend\n\t\tend\n\t\
    \tlocal min = table.remove(lst, min_index)\n\t\tlocal max = table.remove(lst,\
    \ max_index)\n\t\tif (min_index < max_index) then\n\t\t\ttable.insert(sorted,\
    \ min)\n\t\t\ttable.insert(sorted, max)\n\t\telse\n\t\t\ttable.insert(sorted,\
    \ max)\n\t\t\ttable.insert(sorted, min)\n\t\tend\n\tend\n\treturn sorted\nend",
  "    if #lst == 0 then\n        return lst\n    end\n    -- TODO: Implement strange\
    \ sort\n    return lst\nend", "\tif not lst then return nil end\n\tlocal t = {}\n\
    \tfor _, v in ipairs(lst) do table.insert(t, v) end\n\tlocal sz = #t\n\tif sz\
    \ < 2 then return t end\n\ttable.sort(t)\n\tlocal out = {}\n\tlocal cnt = math.floor(sz\
    \ / 2)\n\tfor i = 1, cnt do\n\t\ttable.insert(out, t[i])\n\t\ttable.insert(out,\
    \ t[sz + 1 - i])\n\tend\n\tif sz % 2 ~= 0 then table.insert(out, t[cnt + 1]) end\n\
    \treturn out\nend", "    if #lst <= 1 then\n        return lst\n    end\n    local\
    \ function get_min_max(lst)\n        local min, max = lst[1], lst[1]\n       \
    \ for i, v in ipairs(lst) do\n            if v < min then\n                min\
    \ = v\n            end\n            if v > max then\n                max = v\n\
    \            end\n        end\n        return min, max\n    end\n    local min,\
    \ max = get_min_max(lst)\n    local min_index, max_index = -1, -1\n    for i,\
    \ v in ipairs(lst) do\n        if v == min then\n            min_index = i\n \
    \       end\n        if v == max then\n            max_index = i\n        end\n\
    \    end\n    local ret = {}\n    local idx = 1\n    while min_index ~= -1 or\
    \ max_index ~= -1 do\n        if min_index ~= -1 then\n            ret[idx] =\
    \ min\n            min_index = -1\n            idx = idx + 1\n        end\n  \
    \      if max_index ~= -1 then\n            ret[idx] = max\n            max_index\
    \ = -1\n            idx = idx + 1\n        end\n    end\n    return ret\nend",
  "    local res, min, max = {}, {}, {}\n    for _, v in ipairs(lst) do\n        if\
    \ v == lst[1] then\n            table.insert(min, v)\n        elseif v == lst[#lst]\
    \ then\n            table.insert(max, v)\n        else\n            for i, j in\
    \ ipairs(lst) do\n                if v == j then\n                    if i < #lst/2\
    \ + 1 then\n                        table.insert(min, v)\n                   \
    \ else\n                        table.insert(max, v)\n                    end\n\
    \                end\n            end\n        end\n    end\n    while #min ~=\
    \ 0 or #max ~= 0 do\n        if #min ~= 0 then\n            table.insert(res,\
    \ table.remove(min, 1))\n        end\n        if #max ~= 0 then\n            table.insert(res,\
    \ table.remove(max, 1))\n        end\n    end\n    return res\nend", "    if #lst\
    \ == 0 then\n        return lst\n    end\n    local sort_lst = {}\n    local size\
    \ = #lst\n    while #sort_lst < size do\n        local min = math.min(unpack(lst))\n\
    \        table.insert(sort_lst, min)\n        local max = math.max(unpack(lst))\n\
    \        table.insert(sort_lst, max)\n        for i, v in ipairs(lst) do\n   \
    \         if v == min or v == max then\n                table.remove(lst, i)\n\
    \            end\n        end\n    end\n    return sort_lst\nend", "  if not lst\
    \ or #lst == 0 then return {} end\n  table.sort(lst)\n  local res = {}\n  local\
    \ cnt = 1\n  for i = 1, #lst do\n    if i%2 == 1 then\n      res[cnt] = lst[i]\n\
    \      cnt = cnt + 1\n    else\n      res[#lst - i + 1] = lst[i]\n    end\n  end\n\
    \  return res\nend", "\tlocal function sort (lst, acc)\n\t\tif #lst == 0 then\
    \ return acc end\n\t\tlocal min = math.min(unpack(lst))\n\t\tlocal i = index_of(lst,\
    \ min)\n\t\ttable.remove(lst, i)\n\t\tif #lst == 0 then return acc end\n\t\tlocal\
    \ max = math.max(unpack(lst))\n\t\tlocal j = index_of(lst, max)\n\t\ttable.remove(lst,\
    \ j)\n\t\ttable.insert(acc, min)\n\t\ttable.insert(acc, max)\n\t\treturn sort(lst,\
    \ acc)\n\tend\n\treturn sort(lst, {})\nend", "  if #lst == 0 then return lst end\n\
    \  local l = {}\n  table.sort(lst)\n  local min, max = lst[1], lst[#lst]\n  for\
    \ i = 1, #lst do\n    l[i] = (i % 2 == 1) and min or max\n    if i % 2 == 1 then\n\
    \      min = lst[(i // 2) + 2]\n    else\n      max = lst[(i // 2) + 1]\n    end\n\
    \  end\n  return l\nend", "\t-- step 1: sort list\n\tlocal sorted_lst = lst:sort()\n\
    \t\n\t-- step 2: create new list\n\tlocal new_lst = {}\n\t\n\t-- step 3: move\
    \ first element to last\n\ttable.insert(new_lst, table.remove(sorted_lst, 1))\n\
    \t\n\t-- step 4: put first element of sorted list to the new list\n\t-- and the\
    \ last one to the end of the sorted list\n\twhile #sorted_lst ~= 0 do\n\t\ttable.insert(new_lst,\
    \ table.remove(sorted_lst, 1))\n\t\ttable.insert(sorted_lst, table.remove(sorted_lst,\
    \ #sorted_lst))\n\tend\n\t\n\t-- step 5: return new list\n\treturn new_lst\nend",
  "    -- TODO: Implement the function\nend", "    -- your code here\n    return {}\n\
    end", "    if not lst then return nil end\n    if #lst == 0 then return {} end\n\
    \    table.sort(lst)\n    local min = table.remove(lst, 1)\n    local max = table.remove(lst,\
    \ #lst)\n    return strange_sort_list(lst) and {min, max, unpack(strange_sort_list(lst))}\n\
    end", "    -- your code here\n    if not next(lst) then return {} end\n    table.sort(lst)\n\
    \    local left = {}\n    local right = {}\n    for i = 1, #lst do\n        if\
    \ i % 2 == 1 then\n            table.insert(left, lst[i])\n        else\n    \
    \        table.insert(right, lst[i])\n        end\n    end\n    local res = {}\n\
    \    for i = 1, #left do\n        table.insert(res, left[i])\n        table.insert(res,\
    \ right[i])\n    end\n    return res\nend", "  local function sort_func(a, b)\n\
    \    return a > b\n  end\n  table.sort(lst, sort_func)\n  return lst\nend", " \
    \ local sorted = table.sort(lst)\n  local ret = {}\n  local llen = #lst\n  local\
    \ idx = 1\n  local count = 1\n  while count <= llen do\n    ret[count] = sorted[idx]\n\
    \    idx = idx + 1\n    count = count + 1\n    if idx <= llen then\n      ret[count]\
    \ = sorted[llen - idx + 1]\n      count = count + 1\n    end\n  end\n  return\
    \ ret\nend", "    local is_odd = #lst % 2 == 1\n    local mid_i = is_odd and math.ceil(#lst\
    \ / 2) or #lst / 2\n    local ret = { lst[mid_i] }\n    local left_i = mid_i -\
    \ 1\n    local right_i = mid_i + 1\n    while left_i >= 1 or right_i <= #lst do\n\
    \        if left_i >= 1 then\n            table.insert(ret, lst[left_i])\n   \
    \         left_i = left_i - 1\n        end\n        if right_i <= #lst then\n\
    \            table.insert(ret, lst[right_i])\n            right_i = right_i +\
    \ 1\n        end\n    end\n    return ret\nend", "    if #lst == 0 then\n    \
    \    return lst\n    end\n    table.sort(lst)\n    local i = 1\n    local j =\
    \ #lst\n    local res = {}\n    while i <= j do\n        res[#res + 1] = lst[i]\n\
    \        if i ~= j then\n            res[#res + 1] = lst[j]\n        end\n   \
    \     i = i + 1\n        j = j - 1\n    end\n    return res\nend", "    local\
    \ result = {}\n    table.sort(lst)\n    local i = 1\n    local j = #lst\n    local\
    \ start = true\n    while i <= j do\n        if start then\n            table.insert(result,\
    \ lst[i])\n            i = i + 1\n        else\n            table.insert(result,\
    \ lst[j])\n            j = j - 1\n        end\n        start = not start\n   \
    \ end\n    return result\nend", "  local sorted = {}\n  local min = math.min(unpack(lst))\n\
    \  local max = math.max(unpack(lst))\n  for _, n in ipairs(lst) do\n    if n ==\
    \ min then\n      table.insert(sorted, min)\n      min = max\n    elseif n ==\
    \ max then\n      table.insert(sorted, max)\n      max = min\n    end\n  end\n\
    \  return sorted\nend", "  if #lst == 0 then return lst end\n  local res = {}\n\
    \  table.sort(lst)\n  while #lst > 0 do\n    table.insert(res, table.remove(lst,\
    \ 1))\n    if #lst > 0 then\n      table.insert(res, table.remove(lst))\n    end\n\
    \  end\n  return res\nend", "    local res = {}\n    local values = {}\n    local\
    \ pos = 1\n    local min, max\n    local min_pos, max_pos\n    for i, el in ipairs(lst)\
    \ do\n        values[i] = el\n    end\n    for i = 1, #lst do\n        min = 1000000\n\
    \        max = -1000000\n        for j, el in ipairs(values) do\n            if\
    \ el ~= nil then\n                if el > max then\n                    max =\
    \ el\n                    max_pos = j\n                end\n                if\
    \ el < min then\n                    min = el\n                    min_pos = j\n\
    \                end\n            end\n        end\n        if pos % 2 == 1 then\n\
    \            res[pos] = min\n            values[min_pos] = nil\n        else\n\
    \            res[pos] = max\n            values[max_pos] = nil\n        end\n\
    \        pos = pos + 1\n    end\n    return res\nend", "    -- Implementation\
    \ here\nend", "    if #lst == 0 then\n        return lst\n    end\n    table.sort(lst)\n\
    \    local a = {}\n    local b = {}\n    local n = #lst\n    for i = 1, n/2 do\n\
    \        a[i] = lst[i]\n        b[i] = lst[n - i + 1]\n    end\n    if n % 2 ==\
    \ 1 then\n        a[n/2 + 1] = lst[n/2 + 1]\n    end\n    local res = {}\n   \
    \ for i = 1, #a do\n        res[2*i - 1] = a[i]\n        res[2*i] = b[i]\n   \
    \ end\n    return res\nend", "  if #lst == 0 then return lst end\n  -- print(table.concat(lst,\
    \ ' '))\n  local sorted = {}\n  local min = lst[1]\n  local min_idx = 1\n  local\
    \ max = lst[1]\n  local max_idx = 1\n  for idx, val in ipairs(lst) do\n    if\
    \ val > max then\n      max = val\n      max_idx = idx\n    end\n    if val <\
    \ min then\n      min = val\n      min_idx = idx\n    end\n  end\n  table.insert(sorted,\
    \ min)\n  table.insert(sorted, max)\n  table.remove(lst, min_idx)\n  table.remove(lst,\
    \ max_idx)\n  -- print(min_idx, max_idx)\n  -- print(table.concat(lst, ' '))\n\
    \  return table.concat({table.concat(sorted, ' '), strange_sort_list(lst)}, '\
    \ ')\nend", "\tlocal function max(a, b) return a > b end\n\tlocal function min(a,\
    \ b) return a < b end\n\tlocal new_list = {}\n\ttable.sort(lst)\n\twhile #lst\
    \ > 0 do\n\t\ttable.insert(new_list, lst[1])\n\t\ttable.remove(lst, 1)\n\t\ttable.sort(lst,\
    \ max)\n\t\ttable.insert(new_list, lst[1])\n\t\ttable.remove(lst, 1)\n\t\ttable.sort(lst,\
    \ min)\n\tend\n\treturn new_list\nend", "    if #lst == 0 then\n        return\
    \ lst\n    end\n    local min = math.min(unpack(lst))\n    table.remove(lst, array.index_of(lst,\
    \ min))\n    local max = math.max(unpack(lst))\n    table.remove(lst, array.index_of(lst,\
    \ max))\n    return {min, max} .. strange_sort_list(lst)\nend", "    -- your code\
    \ goes here\nend", "\tlocal res = {}\n\tlocal n = #lst\n\ttable.sort(lst)\n\t\
    for i = 1, n do\n\t\tlocal d = (i % 2 == 0) and -1 or 1\n\t\tres[i] = lst[math.ceil(i\
    \ / 2) * d]\n\tend\n\treturn res\nend", "  if #lst == 0 then return lst end\n\
    \  table.sort(lst)\n  local first, last = lst[1], lst[#lst]\n  lst[1], lst[#lst]\
    \ = last, first\n  return lst\nend", "\tlocal max = math.max\n\tlocal min = math.min\n\
    \tlocal order = 1\n\tlocal function get_max()\n\t\torder = -order\n\t\treturn\
    \ max(unpack(lst))\n\tend\n\tlocal function get_min()\n\t\torder = -order\n\t\t\
    return min(unpack(lst))\n\tend\n\treturn table.map(lst, function(x)\n\t\tlocal\
    \ val = x\n\t\tif val == get_max() or val == get_min() then\n\t\t\tlst = table.filter(lst,\
    \ function(x) return x ~= val end)\n\t\tend\n\t\treturn val\n\tend)\nend", " \
    \ if #lst == 0 then return lst end\n  table.sort(lst)\n  local result = {lst[1]}\n\
    \  local left = 2\n  local right = #lst\n  while left <= right do\n    result[#result\
    \ + 1] = lst[right]\n    result[#result + 1] = lst[left]\n    left = left + 1\n\
    \    right = right - 1\n  end\n  return result\nend", "  local function remove_by_value(t,\
    \ value)\n    local index = nil\n    for i = 1, #t do\n      if t[i] == value\
    \ then\n        index = i\n        break\n      end\n    end\n    if index then\n\
    \      table.remove(t, index)\n    end\n  end", "  -- body\nend", "  local res\
    \ = {}\n  local min, max = math.min(unpack(lst)), math.max(unpack(lst))\n  local\
    \ odd, even = false, true\n  if min == max then return lst end\n  while #lst >\
    \ 0 do\n    if odd then\n      min = math.min(unpack(lst))\n      table.insert(res,\
    \ min)\n      table.remove(lst, __.find(lst, min))\n      odd = false\n    else\n\
    \      max = math.max(unpack(lst))\n      table.insert(res, max)\n      table.remove(lst,\
    \ __.find(lst, max))\n      odd = true\n    end\n  end\n  return res\nend", " \
    \ -- your code here\nend", "    -- YOUR CODE HERE\nend", "    if #lst == 0 then\n\
    \        return lst\n    end\n    -- sorting list\n    table.sort(lst)\n    --\
    \ init new list\n    local new_lst = {}\n    local i = 1\n    local k = #lst\n\
    \    while i <= #lst do\n        -- adding minimum value\n        table.insert(new_lst,\
    \ lst[i])\n        -- checking what index of list have minimum value\n       \
    \ if i == #lst then\n            -- if i == k, then adding maximum value\n   \
    \         table.insert(new_lst, lst[k])\n        else\n            -- else adding\
    \ next maximum value\n            table.insert(new_lst, lst[k - 1])\n        end\n\
    \        -- decreasing index of maximum value\n        k = k - 1\n        -- increasing\
    \ index of minimum value\n        i = i + 1\n    end\n    return new_lst\nend",
  "    -- if lst is empty, return empty list\n    if #lst == 0 then\n        return\
    \ {}\n    -- if lst contains 1 item, return lst\n    elseif #lst == 1 then\n \
    \       return lst\n    -- else, do some weird sorting\n    else\n        -- copy\
    \ the list\n        local new_lst = {}\n        for _, v in ipairs(lst) do\n \
    \           table.insert(new_lst, v)\n        end\n        -- sort the copied\
    \ list, remove minimum\n        -- and append it to the end of the original list\n\
    \        -- repeat until new_lst is empty\n        while #new_lst > 0 do\n   \
    \         table.sort(new_lst)\n            table.insert(lst, table.remove(new_lst,\
    \ 1))\n            table.sort(new_lst, function(a, b) return a > b end)\n    \
    \        table.insert(lst, table.remove(new_lst, 1))\n        end\n        return\
    \ lst\n    end\nend", "    if #lst == 0 then\n        return lst\n    end\n  \
    \  local min = math.min(unpack(lst))\n    local max = math.max(unpack(lst))\n\
    \    local min_index = table.index_of(lst, min)\n    local max_index = table.index_of(lst,\
    \ max)\n    local ret = {min}\n    for i = 1, #lst do\n        if i ~= min_index\
    \ and i ~= max_index then\n            ret[#ret + 1] = lst[i]\n        end\n \
    \   end\n    ret[#ret + 1] = max\n    return ret\nend", "    local function sort_list(lst,\
    \ result)\n        if #lst == 0 then\n            return result\n        end\n\
    \        if #lst == 1 then\n            table.insert(result, lst[1])\n       \
    \     return result\n        end\n        table.insert(result, math.min(unpack(lst)))\n\
    \        local min_key = nil\n        for k, v in ipairs(lst) do\n           \
    \ if v == math.min(unpack(lst)) then\n                min_key = k\n          \
    \      break\n            end\n        end\n        table.remove(lst, min_key)\n\
    \        table.insert(result, math.max(unpack(lst)))\n        local max_key =\
    \ nil\n        for k, v in ipairs(lst) do\n            if v == math.max(unpack(lst))\
    \ then\n                max_key = k\n                break\n            end\n\
    \        end\n        table.remove(lst, max_key)\n        return sort_list(lst,\
    \ result)\n    end\n    return sort_list(lst, {})\nend", "  local sorted_lst =\
    \ {}\n  local unsorted_lst = lst\n  while #unsorted_lst > 0 do\n    table.insert(sorted_lst,\
    \ table.remove(unsorted_lst, 1))\n    table.insert(sorted_lst, table.remove(unsorted_lst,\
    \ #unsorted_lst))\n  end\n  return sorted_lst\nend", "    -- check for empty list\n\
    \    if #lst == 0 then\n        return lst\n    end\n    -- initialize return\
    \ list\n    local ret_lst = {}\n    -- get minimum and remove it from the list\n\
    \    local min = math.min(unpack(lst))\n    for i = 1, #lst do\n        if lst[i]\
    \ == min then\n            table.remove(lst, i)\n            break\n        end\n\
    \    end\n    -- initialize the rest of return list\n    ret_lst[1] = min\n  \
    \  -- loop over the list until it is empty\n    while #lst > 0 do\n        --\
    \ get maximum and remove it from the list\n        local max = math.max(unpack(lst))\n\
    \        for i = 1, #lst do\n            if lst[i] == max then\n             \
    \   table.remove(lst, i)\n                break\n            end\n        end\n\
    \        -- get minimum and remove it from the list\n        local min = math.min(unpack(lst))\n\
    \        for i = 1, #lst do\n            if lst[i] == min then\n             \
    \   table.remove(lst, i)\n                break\n            end\n        end\n\
    \        -- add the new values to the return list\n        table.insert(ret_lst,\
    \ max)\n        table.insert(ret_lst, min)\n    end\n    -- return the list\n\
    \    return ret_lst\nend", "    local sorted_table = {}\n    for i = 1, #lst do\n\
    \        local min = math.min(unpack(lst))\n        table.insert(sorted_table,\
    \ min)\n        table.remove(lst, table_index(lst, min))\n    end\n    return\
    \ sorted_table\nend", "    local minimum = math.min(unpack(lst))\n    local maximum\
    \ = math.max(unpack(lst))\n    local result = {}\n    while #lst > 0 do\n    \
    \    table.insert(result, minimum)\n        table.remove(lst, minimum)\n     \
    \   table.insert(result, maximum)\n        table.remove(lst, maximum)\n    end\n\
    \    return result\nend", "    if #lst % 2 == 0 then\n        local n = #lst\n\
    \        local res = {}\n        for i = 1, n, 2 do\n            res[i] = math.min(table.unpack(lst))\n\
    \            table.remove(lst, lst:index_of(res[i]))\n            res[i + 1] =\
    \ math.max(table.unpack(lst))\n            table.remove(lst, lst:index_of(res[i\
    \ + 1]))\n        end\n        return res\n    else\n        local n = #lst\n\
    \        local res = {}\n        for i = 1, n - 1, 2 do\n            res[i] =\
    \ math.min(table.unpack(lst))\n            table.remove(lst, lst:index_of(res[i]))\n\
    \            res[i + 1] = math.max(table.unpack(lst))\n            table.remove(lst,\
    \ lst:index_of(res[i + 1]))\n        end\n        res[n] = lst[1]\n        return\
    \ res\n    end\nend", "    local ret = {}\n    local n = #lst\n    if n == 0 then\n\
    \        return ret\n    end\n    local i = 1\n    while n > 0 do\n        local\
    \ mn = math.min(unpack(lst))\n        table.insert(ret, mn)\n        table.remove(lst,\
    \ mn)\n        local mx = math.max(unpack(lst))\n        table.insert(ret, mx)\n\
    \        table.remove(lst, mx)\n        n = n - 2\n    end\n    return ret\nend",
  "    if #lst <= 1 then\n        return lst\n    end\n    table.sort(lst)\n    local\
    \ sorted = {lst[1]}\n    for i = #lst, 2, -1 do\n        table.insert(sorted,\
    \ lst[i])\n    end\n    return sorted\nend", "  local function helper(lst)\n \
    \   local min_ = math.min(unpack(lst))\n    local max_ = math.max(unpack(lst))\n\
    \    if min_ == max_ then\n      return lst\n    end\n    local new_lst = {}\n\
    \    for i = 1, #lst do\n      if lst[i] == min_ then\n        table.insert(new_lst,\
    \ min_)\n        min_ = math.huge\n      elseif lst[i] == max_ then\n        table.insert(new_lst,\
    \ max_)\n        max_ = -math.huge\n      end\n    end\n    return helper(new_lst)\n\
    \  end\n  return helper(lst)\nend", "  return {}\nend", "    return {}\nend",
  "  local k, j, res = 1, #lst, {}\n  local min, max = minmax(lst)\n  for i = 1, j\
    \ do\n    if k % 2 == 1 then\n      res[k] = min\n      table.remove(lst, table.indexof(lst,\
    \ min))\n    else\n      res[k] = max\n      table.remove(lst, table.indexof(lst,\
    \ max))\n    end\n    min, max = minmax(lst)\n    k = k + 1\n  end\n  return res\n\
    end", "  if #lst == 0 then return lst end\n  local lstmin = lst[1]\n  local lstmax\
    \ = lst[1]\n  local lstmin_idx = 1\n  local lstmax_idx = 1\n  for i = 1, #lst\
    \ do\n    if lst[i] < lstmin then\n      lstmin = lst[i]\n      lstmin_idx = i\n\
    \    end\n    if lst[i] > lstmax then\n      lstmax = lst[i]\n      lstmax_idx\
    \ = i\n    end\n  end\n  table.remove(lst, lstmin_idx)\n  if lstmax_idx > lstmin_idx\
    \ then\n    table.remove(lst, lstmax_idx - 1)\n  else\n    table.remove(lst, lstmax_idx)\n\
    \  end\n  return {lstmin, lstmax} .. strange_sort_list(lst)\nend", "    table.sort(lst)\n\
    \    local new_list = {}\n    local mid = #lst/2\n    for i = 1, mid do\n    \
    \    new_list[i*2-1] = lst[i]\n        new_list[i*2] = lst[mid + i]\n    end\n\
    \    return new_list\nend", "    if #lst == 0 then\n        return lst\n    end\n\
    \    local copy = table.clone(lst)\n    table.sort(copy)\n    local r = {}\n \
    \   local half = math.floor(#copy / 2)\n    local is_odd = #copy % 2 == 1\n  \
    \  local k = 1\n    for i = 1, half do\n        if is_odd and i == half then\n\
    \            r[k] = copy[half]\n            k = k + 1\n        else\n        \
    \    r[k] = copy[i]\n            r[k + 1] = copy[#copy - i + 1]\n            k\
    \ = k + 2\n        end\n    end\n    return r\nend", "\tlocal function odd_filter(a,b)\n\
    \t\tif a%2 == 1 then\n\t\t\treturn true\n\t\telse\n\t\t\treturn false\n\t\tend\n\
    \tend\n\tlocal odd_list = table.filter(lst, odd_filter)\n\tlocal even_list = table.filter(lst,\
    \ function(a,b) return not odd_filter(a,b) end)\n\ttable.sort(odd_list)\n\ttable.sort(even_list)\n\
    \tlocal odd_list_max = table.maxn(odd_list)\n\tlocal even_list_max = table.maxn(even_list)\n\
    \tlocal sort_list = {}\n\tfor i=1,odd_list_max+even_list_max do\n\t\tif i%2 ==\
    \ 1 then\n\t\t\ttable.insert(sort_list, table.remove(odd_list, 1))\n\t\telse\n\
    \t\t\ttable.insert(sort_list, table.remove(even_list, 1))\n\t\tend\n\tend\n\t\
    return sort_list\nend\nassert(table.equal(strange_sort_list({1, 2, 3, 4}), {1,\
    \ 4, 2, 3}))\nassert(table.equal(strange_sort_list({5, 5, 5, 5}), {5, 5, 5, 5}))\n\
    assert(table.equal(strange_sort_list({}), {}))", "  if lst == nil or next(lst)\
    \ == nil then\n    return lst\n  end\n  local sort_lst = {}\n  local min = math.min(unpack(lst))\n\
    \  local max = math.max(unpack(lst))\n  local pos = 0\n  local len = #lst\n  while\
    \ len > 0 do\n    pos = pos + 1\n    sort_lst[pos] = min\n    len = len - 1\n\
    \    if len > 0 then\n      pos = pos + 1\n      sort_lst[pos] = max\n      len\
    \ = len - 1\n    end\n  end\n  return sort_lst\nend", "  local result = {}\n \
    \ local len = #lst\n  table.sort(lst)\n  local i = 1\n  local j = len\n  while\
    \ i <= len do\n    result[i] = lst[i]\n    i = i + 1\n    if i <= len then\n \
    \     result[i] = lst[j]\n      j = j - 1\n      i = i + 1\n    end\n  end\n \
    \ return result\nend", "  local _, lst = is_list(lst)\n  if #lst == 0 then return\
    \ lst end\n  local min = table.remove(lst, 1)\n  return {min, strange_sort_list(lst)}\n\
    end", "  if #lst == 0 then return lst end\n  local sorted = {}\n  local list =\
    \ {}\n  for i = 1, #lst do\n    list[i] = lst[i]\n  end\n  table.sort(list)\n\
    \  local min, max = list[1], list[#list]\n  while #list > 0 do\n    table.insert(sorted,\
    \ table.remove(list, 1))\n    if #list == 0 then break end\n    table.insert(sorted,\
    \ table.remove(list))\n  end\n  if sorted[1] == max then\n    table.remove(sorted,\
    \ 1)\n    table.insert(sorted, min)\n  end\n  return sorted\nend", "\tif #lst\
    \ == 0 then return {} end\n\ttable.sort(lst)\n\tlocal min, max = table.remove(lst,\
    \ 1), table.remove(lst, #lst)\n\tlocal f, s = {min}, {max}\n\twhile #lst > 0 do\n\
    \t\ttable.insert(f, table.remove(lst, #lst))\n\t\tif #lst > 0 then\n\t\t\ttable.insert(s,\
    \ table.remove(lst, 1))\n\t\tend\n\tend\n\treturn r_merge(f, s)\nend", "  local\
    \ sorted = {}\n  local len = #lst\n  if len == 0 then return sorted end\n  local\
    \ l, r = 1, len\n  table.sort(lst)\n  for i = 1, len, 2 do\n    sorted[i] = lst[l]\n\
    \    sorted[i + 1] = lst[r]\n    l = l + 1\n    r = r - 1\n  end\n  return sorted\n\
    end", "    local res, min, max = {}, math.min(unpack(lst)), math.max(unpack(lst))\n\
    \    while #res < #lst do\n        table.insert(res, min)\n        min = math.min(unpack(lst))\n\
    \        table.insert(res, max)\n        max = math.max(unpack(lst))\n    end\n\
    \    return res\nend", "  local sorted = table.sort(lst)\n  local res = {}\n \
    \ local low = 1\n  local high = #sorted", "  local sort_lst = {}\n  local length\
    \ = 0\n  local min = 0\n  local max = 0\n  local min_index = 0\n  local max_index\
    \ = 0\n  if length == 0 then\n    return {}\n  end\n  length = #lst\n  min = lst[1]\n\
    \  max = lst[1]\n  for i = 1, length do\n    if lst[i] > max then\n      max =\
    \ lst[i]\n      max_index = i\n    end\n    if lst[i] < min then\n      min =\
    \ lst[i]\n      min_index = i\n    end\n  end\n  for i = 1, length do\n    if\
    \ i % 2 == 1 then\n      sort_lst[i] = min\n      lst[min_index] = max\n    else\n\
    \      sort_lst[i] = max\n      lst[max_index] = min\n    end\n  end\n  return\
    \ sort_lst\nend", "  -- TODO\nend", "    if #lst == 0 then\n        return lst\n\
    \    end\n    local odd = {}\n    local even = {}\n    for i = 1, #lst do\n  \
    \      if i % 2 == 0 then\n            table.insert(even, lst[i])\n        else\n\
    \            table.insert(odd, lst[i])\n        end\n    end\n    table.sort(odd)\n\
    \    table.sort(even, function(a, b) return a > b end)\n    local output = {}\n\
    \    for i = 1, #odd do\n        table.insert(output, odd[i])\n        table.insert(output,\
    \ even[i])\n    end\n    return output\nend", "  if not lst then return nil end\n\
    \  table.sort(lst)\n  local function sort_by_index(indexes)\n    local sorted\
    \ = {}\n    for i = 1, #indexes do\n      sorted[i] = lst[indexes[i]]\n    end\n\
    \    return sorted\n  end\n  local indexes = {}\n  local i = 1\n  local size =\
    \ #lst\n  while i <= size do\n    if i % 2 == 1 then\n      table.insert(indexes,\
    \ i)\n    else\n      table.insert(indexes, size + 1 - i)\n    end\n    i = i\
    \ + 1\n  end\n  return sort_by_index(indexes)\nend", "  if #lst == 0 then return\
    \ lst end\n  table.sort(lst)\n  local result = {lst[1]}\n  lst[1] = nil\n  while\
    \ next(lst) do\n    result[#result + 1] = lst[#lst]\n    lst[#lst] = nil\n   \
    \ if next(lst) then\n      result[#result + 1] = lst[1]\n      lst[1] = nil\n\
    \    end\n  end\n  return result\nend", "    table.sort(lst)\n    local i, j =\
    \ 1, #lst\n    local new_list = {}\n    while i <= j do\n        table.insert(new_list,\
    \ lst[i])\n        table.insert(new_list, lst[j])\n        i = i + 1\n       \
    \ j = j - 1\n    end\n    return new_list\nend", "    if #lst == 0 then\n    \
    \    return lst\n    end\n    table.sort(lst)\n    local res = {}\n    local left\
    \ = 1\n    local right = #lst\n    while left <= right do\n        table.insert(res,\
    \ lst[left])\n        if left ~= right then\n            table.insert(res, lst[right])\n\
    \        end\n        left = left + 1\n        right = right - 1\n    end\n  \
    \  return res\nend", "\t\nend", "    if #lst == 0 then\n        return lst\n \
    \   end\n    local min = math.min(unpack(lst))\n    local max = math.max(unpack(lst))\n\
    \    local cnt = lst\n    local new_lst = {}\n    local odd = true\n    while\
    \ #cnt > 0 do\n        if odd then\n            local pos = get_pos(cnt, min)\n\
    \            new_lst[#new_lst + 1] = cnt[pos]\n            table.remove(cnt, pos)\n\
    \        else\n            local pos = get_pos(cnt, max)\n            new_lst[#new_lst\
    \ + 1] = cnt[pos]\n            table.remove(cnt, pos)\n        end\n        odd\
    \ = not odd\n    end\n    return new_lst\nend", "  local result = {}\n  local\
    \ min_idx = 0\n  local max_idx = #lst\n  local max_positive = math.max(0, max_idx)\n\
    \  for i = 1, max_positive do\n    result[i] = lst[min_idx]\n    min_idx = min_idx\
    \ + 1\n    if i ~= max_positive then\n      result[max_idx] = lst[max_idx]\n \
    \     max_idx = max_idx - 1\n    end\n  end\n  return result\nend", "  local res\
    \ = {}\n  local len = #lst\n  local half_len = math.floor(len / 2)\n  local half_lst\
    \ = lst[1]\n  if len % 2 == 0 then\n    half_lst = lst[half_len]\n  end\n  while\
    \ true do\n    table.insert(res, lst[1])\n    table.remove(lst, 1)\n    len =\
    \ len - 1\n    if len > 0 then\n      table.insert(res, lst[len])\n      table.remove(lst,\
    \ len)\n      len = len - 1\n    else\n      break\n    end\n  end\n  return res\n\
    end", "    local function sort_list(lst, min_list, max_list)\n        if #lst\
    \ == 0 then\n            return min_list\n        end\n        if #lst == 1 then\n\
    \            table.insert(min_list, lst[1])\n            return min_list\n   \
    \     end\n        if #lst == 2 then\n            if lst[1] < lst[2] then\n  \
    \              table.insert(min_list, lst[1])\n                table.insert(max_list,\
    \ lst[2])\n            else\n                table.insert(min_list, lst[2])\n\
    \                table.insert(max_list, lst[1])\n            end\n           \
    \ return min_list\n        end\n        table.insert(min_list, lst[1])\n     \
    \   table.insert(max_list, lst[2])\n        table.remove(lst, 1)\n        table.remove(lst,\
    \ 1)\n        return sort_list(lst, min_list, max_list)\n    end\n    local min_list\
    \ = {}\n    local max_list = {}\n    local result = sort_list(lst, min_list, max_list)\n\
    \    local i = 1\n    while i <= #max_list do\n        table.insert(result, #result\
    \ + 1, max_list[i])\n        i = i + 1\n    end\n    return result\nend", "  \
    \  if #lst == 0 then\n        return lst\n    end\n    local min = math.min(unpack(lst))\n\
    \    local max = math.max(unpack(lst))\n    local result = {}\n    while #lst\
    \ > 0 do\n        if #lst == 1 then\n            table.insert(result, table.remove(lst,\
    \ 1))\n        else\n            local new_min = math.min(unpack(lst))\n     \
    \       local new_max = math.max(unpack(lst))\n            if min == new_min and\
    \ max == new_max then\n                table.insert(result, table.remove(lst,\
    \ 1))\n            elseif min == new_min then\n                table.insert(result,\
    \ table.remove(lst, 1))\n                table.insert(result, table.remove(lst,\
    \ #lst))\n            elseif max == new_max then\n                table.insert(result,\
    \ table.remove(lst, #lst))\n                table.insert(result, table.remove(lst,\
    \ 1))\n            else\n                table.insert(result, table.remove(lst,\
    \ #lst))\n            end\n        end\n    end\n    return result\nend", "  local\
    \ str = \"\"\n  for i,v in ipairs(lst) do\n    str = str .. tostring(v)\n  end\n\
    \  str = string.gsub(str, '()', ':')\n  return lst\nend", "    if #lst == 0 then\n\
    \        return lst\n    end\n    local tbl = {}\n    local idx = 1\n    table.sort(lst)\n\
    \    local max = #lst\n    for i = 1, max do\n        if idx % 2 == 1 then\n \
    \           tbl[idx] = lst[i]\n        else\n            tbl[idx] = lst[max-i+1]\n\
    \        end\n        idx = idx + 1\n    end\n    return tbl\nend", "  local sort_func\
    \ = function(a, b)\n    return a < b\n  end\n  local min_lst = {}\n  local max_lst\
    \ = {}\n  local res = {}\n  table.sort(lst, sort_func)\n  local lst_len = #lst\n\
    \  local half_len = math.floor(lst_len / 2)\n  for i, v in ipairs(lst) do\n  \
    \  if i <= half_len then\n      min_lst[i] = v\n    else\n      max_lst[i - half_len]\
    \ = v\n    end\n  end\n  for i = 1, half_len do\n    res[2 * i - 1] = min_lst[i]\n\
    \    res[2 * i] = max_lst[i]\n  end\n  if lst_len % 2 == 1 then\n    res[lst_len]\
    \ = max_lst[half_len + 1]\n  end\n  return res\nend", "    -- body\nend", "  --\
    \ body\nend", "  local result = {}\n  local _lst = utils.shallow_copy(lst)\n \
    \ local list_length = #_lst\n  local i = 1\n  local j = 1\n  local k = 1\n  local\
    \ flag = false\n  local m = 1\n  while i <= list_length do\n    flag = false\n\
    \    if i % 2 == 1 then\n      j = 1\n      for _, v in ipairs(_lst) do\n    \
    \    if not flag or v < result[i] then\n          result[i] = v\n          flag\
    \ = true\n          m = j\n        end\n        j = j + 1\n      end\n    else\n\
    \      j = 1\n      for _, v in ipairs(_lst) do\n        if not flag or v > result[i]\
    \ then\n          result[i] = v\n          flag = true\n          m = j\n    \
    \    end\n        j = j + 1\n      end\n    end\n    table.remove(_lst, m)\n \
    \   i = i + 1\n  end\n  return result\nend", "    -- Get the max function from\
    \ the table:\n    local max = table.maxn\n    -- Get the length of the list.\n\
    \    local length = max(lst)\n    -- Create a new list:\n    local new_list =\
    \ {}\n    -- Get an incr, decr list:\n    local incr, decr = misc.incr_decr_list(length)\n\
    \    -- Reverse the decr list.\n    decr = misc.reverse_list(decr)\n    -- Merge\
    \ the two lists into one.\n    local merged = misc.merge_lists(incr, decr)\n \
    \   -- Create a new list:\n    local new_list = {}\n    -- Iterate over the list\
    \ of lst:\n    for i = 1, length do\n        -- Get the current item:\n      \
    \  local item = lst[merged[i]]\n        -- Append it to the new list:\n      \
    \  table.insert(new_list, item)\n    end\n    -- Return the new list:\n    return\
    \ new_list\nend", "    table.sort(lst)\n    local r = {}\n    local left, right\
    \ = 1, #lst\n    while left <= right do\n        r[#r + 1] = lst[left]\n     \
    \   if left ~= right then\n            r[#r + 1] = lst[right]\n        end\n \
    \       left = left + 1\n        right = right - 1\n    end\n    return r\nend",
  "    return {}\nend", "  if #lst == 0 then return lst end\n  table.sort(lst)\n \
    \ local result = {lst[1]}\n  local idx = 2\n  local swap = true\n  for i = 2,\
    \ #lst do\n    if swap then\n      result[i] = lst[#lst - idx + 2]\n      idx\
    \ = idx + 1\n    else\n      result[i] = lst[idx]\n      idx = idx + 1\n    end\n\
    \    swap = not swap\n  end\n  return result\nend", "  local lst_len = #lst\n\
    \  local max_index = lst_len\n  local min_index = 1\n  local first = true\n  local\
    \ ret = {}\n  local i = 1\n  while i <= lst_len do\n    if first then\n      ret[i]\
    \ = lst[min_index]\n      min_index = min_index + 1\n    else\n      ret[i] =\
    \ lst[max_index]\n      max_index = max_index - 1\n    end\n    first = not first\n\
    \    i = i + 1\n  end\n  return ret\nend", "  local function srt(l, s)\n    if\
    \ #l == 0 then return end\n    table.insert(s, l[(#l - #l // 2) + 1])\n    srt(l[(#l\
    \ - #l // 2) + 1] > l and {table.unpack(l, 1, #l // 2)} or {table.unpack(l, #l\
    \ // 2 + 1, #l)}, s)\n    srt(l[(#l - #l // 2) + 1] < l and {table.unpack(l, 1,\
    \ #l // 2)} or {table.unpack(l, #l // 2 + 1, #l)}, s)\n  end\n  local t = {}\n\
    \  srt(lst, t)\n  return t\nend", "    local function strange_sort(t, result)\n\
    \        local min, min_index, max, max_index = nil, nil, nil, nil\n        for\
    \ i, v in ipairs(t) do\n            if not min or v < min then\n             \
    \   min = v\n                min_index = i\n            end\n            if not\
    \ max or v > max then\n                max = v\n                max_index = i\n\
    \            end\n        end\n        if not max then\n            return result\n\
    \        end\n        table.insert(result, min)\n        table.insert(result,\
    \ max)\n        table.remove(t, max_index)\n        table.remove(t, min_index)\n\
    \        return strange_sort(t, result)\n    end\n    return strange_sort(lst,\
    \ {})\nend", "    local result = {}\n    for i = 1, #lst do\n        local min\
    \ = math.min(unpack(lst))\n        local max = math.max(unpack(lst))\n       \
    \ result[i] = min\n        table.remove(lst, find_elem(lst, min))\n        if\
    \ i ~= #lst then\n            result[#lst - i + 1] = max\n            table.remove(lst,\
    \ find_elem(lst, max))\n        end\n    end\n    return result\nend", "    local\
    \ result = {}\n    if not next(lst) then\n        return result\n    end\n   \
    \ local t = {}\n    for i, x in ipairs(lst) do\n        t[i] = x\n    end\n  \
    \  local top = {}\n    local bottom = {}\n    local inc = 1\n    while #t > 0\
    \ do\n        local v = table.remove(t, inc)\n        if not next(result) then\n\
    \            table.insert(result, v)\n        else\n            local last = result[#result]\n\
    \            if last > v then\n                table.insert(bottom, v)\n     \
    \       else\n                table.insert(top, v)\n            end\n        \
    \    if #top == 0 then\n                table.insert(result, table.remove(bottom))\n\
    \            elseif #bottom == 0 then\n                table.insert(result, table.remove(top))\n\
    \            end\n        end\n        inc = #top > 0 and 1 or -1\n    end\n \
    \   return result\nend", "    table.sort(lst)\n    local result = {}\n    local\
    \ len = #lst\n    local from = 1\n    local to = len\n    for i = 1, len do\n\
    \        if i % 2 == 1 then\n            table.insert(result, lst[from])\n   \
    \         from = from + 1\n        else\n            table.insert(result, lst[to])\n\
    \            to = to - 1\n        end\n    end\n    return result\nend", "   \
    \ -- your code here\n    if #lst <= 0 then\n        return lst\n    end\n    local\
    \ sorted = {}\n    local min = math.min(unpack(lst))\n    local max = math.max(unpack(lst))\n\
    \    table.insert(sorted, min)\n    table.insert(sorted, max)\n    for i = 1,\
    \ #lst do\n        if lst[i] ~= min and lst[i] ~= max then\n            table.insert(sorted,\
    \ lst[i])\n        end\n    end\n    return sorted\nend", "\tlocal t = {}\n\t\
    for k, v in pairs(lst) do\n\t\ttable.insert(t, v)\n\tend\n\tlocal function f(t,\
    \ l)\n\t\tlocal m = table.remove(t, l)\n\t\tif #t == 0 then\n\t\t\treturn m\n\t\
    \tend\n\t\tlocal n = table.remove(t, 1)\n\t\ttable.insert(t, l, n)\n\t\treturn\
    \ m, f(t, l)\n\tend\n\treturn f(t, #t)\nend", "    table.sort(lst)\n    local\
    \ reverse, sorted = false, {}\n    while #lst > 0 do\n        if reverse then\n\
    \            table.insert(sorted, table.remove(lst))\n        else\n         \
    \   table.insert(sorted, 1, table.remove(lst))\n        end\n        reverse =\
    \ not reverse\n    end\n    return sorted\nend", "  if #lst == 0 then return lst\
    \ end\n  local pair = find_max_min(lst)\n  local res = { pair[1] }\n  local cur\
    \ = 2\n  while #lst > 0 do\n    if cur % 2 == 0 then\n      local max = find_max(lst)\n\
    \      res[#res + 1] = max\n      table.remove(lst, lst[max])\n    else\n    \
    \  local min = find_min(lst)\n      res[#res + 1] = min\n      table.remove(lst,\
    \ lst[min])\n    end\n    cur = cur + 1\n  end\n  return res\nend", "\tif #lst\
    \ == 0 then return {} end\n\tlocal a, b = {lst[1]}, {}\n\tfor i=2, #lst do\n\t\
    \tif i % 2 == 0 then\n\t\t\ttable.insert(a, lst[i])\n\t\telse\n\t\t\ttable.insert(b,\
    \ lst[i])\n\t\tend\n\tend\n\treturn table.insert_to_head(a, b)\nend", "  if #lst\
    \ == 0 then return lst end\n  local min_idx = 1\n  for i = 2, #lst do\n    if\
    \ lst[i] < lst[min_idx] then min_idx = i end\n  end\n  local res = {lst[min_idx]}\n\
    \  table.remove(lst, min_idx)\n  for i = 1, #lst / 2 do\n    local max_idx = 1\n\
    \    for j = 2, #lst do\n      if lst[j] > lst[max_idx] then max_idx = j end\n\
    \    end\n    table.insert(res, lst[max_idx])\n    table.remove(lst, max_idx)\n\
    \    if #lst == 0 then break end\n    local min_idx = 1\n    for j = 2, #lst do\n\
    \      if lst[j] < lst[min_idx] then min_idx = j end\n    end\n    table.insert(res,\
    \ lst[min_idx])\n    table.remove(lst, min_idx)\n  end\n  return res\nend", "\t\
    local function increment(a, b)\n\t\treturn (a + b) % 2 == 0 and a + b or a + b\
    \ - 1\n\tend\n\tlocal function odd_even(n)\n\t\treturn (n % 2 == 0) and \"even\"\
    \ or \"odd\"\n\tend\n\tlocal function strange_sort(lst, i, dir)\n\t\ti = i or\
    \ 1\n\t\tdir = dir or \"asc\"\n\t\tlocal result = {}\n\t\tif lst[i] ~= nil then\n\
    \t\t\tif dir == \"asc\" then\n\t\t\t\tlocal min = lst[i]\n\t\t\t\tlocal min_i\
    \ = i\n\t\t\t\tfor j = i, #lst do\n\t\t\t\t\tif lst[j] < min then\n\t\t\t\t\t\t\
    min = lst[j]\n\t\t\t\t\t\tmin_i = j\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tresult[#result\
    \ + 1] = min\n\t\t\t\tresult = merge(result, strange_sort(lst, increment(min_i,\
    \ 1), odd_even(#result + 1)))\n\t\t\telse\n\t\t\t\tlocal max = lst[i]\n\t\t\t\t\
    local max_i = i\n\t\t\t\tfor j = i, #lst do\n\t\t\t\t\tif lst[j] > max then\n\t\
    \t\t\t\t\tmax = lst[j]\n\t\t\t\t\t\tmax_i = j\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\
    \t\tresult[#result + 1] = max\n\t\t\t\tresult = merge(result, strange_sort(lst,\
    \ increment(max_i, 1), odd_even(#result + 1)))\n\t\t\tend\n\t\tend\n\t\treturn\
    \ result\n\tend\n\treturn strange_sort(lst)\nend", "\tif #lst < 2 then\n\t\treturn\
    \ lst\n\tend\n\tlocal sorted = {}\n\tlocal min, max = math.min(unpack(lst)), math.max(unpack(lst))\n\
    \tlocal sign = 1\n\tfor _ = 1, #lst do\n\t\tlocal i = sorted[#sorted] and (sorted[#sorted]\
    \ + sign) or (min + sign)\n\t\twhile (i < min) or (i > max) or list_contains(sorted,\
    \ i) do\n\t\t\ti = i + sign\n\t\tend\n\t\ttable.insert(sorted, i)\n\t\tsign =\
    \ sign * -1\n\tend\n\treturn sorted\nend", "  local sorted = {}\n  local min =\
    \ table.remove(lst, 1)\n  local max = min\n  for _, v in ipairs(lst) do\n    if\
    \ v < min then\n      min = v\n    elseif v > max then\n      max = v\n    end\n\
    \  end\n  table.insert(sorted, min)\n  table.insert(sorted, max)\n  table.sort(lst)\n\
    \  for i = 1, #lst do\n    if i % 2 == 1 then\n      table.insert(sorted, lst[i])\n\
    \    else\n      table.insert(sorted, 1, lst[i])\n    end\n  end\n  return sorted\n\
    end", "    if #lst == 0 then\n        return lst\n    end\n    local min_val =\
    \ min(lst)\n    local max_val = max(lst)\n    local min_pos = 1\n    local max_pos\
    \ = 1\n    local new_lst = {}\n    for i = 1, #lst do\n        if lst[i] == min_val\
    \ then\n            min_pos = i\n        end\n        if lst[i] == max_val then\n\
    \            max_pos = i\n        end\n    end\n    for i = 1, #lst do\n     \
    \   if i % 2 == 1 then\n            new_lst[i] = min_val\n        else\n     \
    \       new_lst[i] = max_val\n        end\n    end\n    if #lst % 2 == 0 then\n\
    \        new_lst[#lst] = min_val\n    end\n    return new_lst\nend", "    local\
    \ result = {}\n    for _, item in ipairs(lst) do\n        table.insert(result,\
    \ item)\n    end\n    table.sort(result)\n    local result2 = {}\n    local length\
    \ = #result\n    local i = 1\n    local j = 1\n    while i <= length and j <=\
    \ length do\n        if i <= length then\n            table.insert(result2, result[i])\n\
    \            i = i + 1\n        end\n        if j <= length then\n           \
    \ table.insert(result2, result[length - j + 1])\n            j = j + 1\n     \
    \   end\n    end\n    return result2\nend", "  return {}\nend", "    if #lst ==\
    \ 0 then\n        return lst\n    end\n    if #lst == 1 then\n        return lst\n\
    \    end\n    local sorted_lst = {}\n    local tmp_lst = {}\n    for i, v in ipairs(lst)\
    \ do\n        table.insert(tmp_lst, v)\n    end\n    table.sort(tmp_lst)\n   \
    \ local min_i = 1\n    local max_i = #tmp_lst\n    local min_max = min_i\n   \
    \ while min_i <= max_i do\n        table.insert(sorted_lst, tmp_lst[min_i])\n\
    \        min_i = min_i + 1\n        if min_i <= max_i then\n            table.insert(sorted_lst,\
    \ tmp_lst[max_i])\n            max_i = max_i - 1\n        end\n    end\n    return\
    \ sorted_lst\nend", "    -- your code here\n    table.sort(lst)\n    local j =\
    \ #lst\n    local i = 1\n    local res = {}\n    while i <= j do\n        table.insert(res,\
    \ lst[i])\n        table.insert(res, lst[j])\n        i = i + 1\n        j = j\
    \ - 1\n    end\n    if #lst % 2 == 1 then\n        table.remove(res, #res)\n \
    \   end\n    return res\nend", "  local sort = {}\n  local min = math.min(unpack(lst))\n\
    \  local max = math.max(unpack(lst))\n  local count = 0\n  local len = #lst\n\
    \  while len ~= count do\n    count = count + 1\n    local val = max == min and\
    \ max or (count % 2 == 0 and max or min)\n    table.insert(sort, val)\n    for\
    \ i,v in ipairs(lst) do\n      if v == val then\n        table.remove(lst, i)\n\
    \        break\n      end\n    end\n    min = math.min(unpack(lst))\n    max =\
    \ math.max(unpack(lst))\n  end\n  return sort\nend", "  local result = {}\n  local\
    \ sorted = {}\n  local minimum = {}\n  local maximum = {}\n  local first = true\n\
    \  local min = 0\n  local max = 0\n  local len = table.getn(lst)\n  local i =\
    \ 1\n  while i <= len do\n    table.insert(sorted, lst[i])\n    i = i + 1\n  end\n\
    \  table.sort(sorted)\n  i = 1\n  while i <= len do\n    if first then\n     \
    \ table.insert(result, sorted[i])\n      first = false\n    else\n      if #minimum\
    \ > 0 then\n        table.insert(result, minimum[#minimum])\n        table.remove(minimum,\
    \ #minimum)\n      end\n      if #maximum > 0 then\n        table.insert(result,\
    \ maximum[#maximum])\n        table.remove(maximum, #maximum)\n      end\n   \
    \ end\n    min = i + 1\n    max = len - i + 1\n    if min <= len then\n      table.insert(minimum,\
    \ sorted[min])\n    end\n    if max > 0 then\n      table.insert(maximum, sorted[max])\n\
    \    end\n    i = i + 1\n  end\n  return result\nend", "    return {}\nend", " \
    \   local r, res = {}, {}\n    for i, v in ipairs(lst) do\n        r[#r + 1] =\
    \ v\n    end\n    table.sort(r)\n    local i = 1\n    while #r > 0 do\n      \
    \  if i % 2 == 1 then\n            res[#res + 1] = table.remove(r, 1)\n      \
    \  else\n            res[#res + 1] = table.remove(r)\n        end\n        i =\
    \ i + 1\n    end\n    return res\nend", "\tif #lst < 2 then\n\t\treturn lst\n\t\
    end\n\tlocal lst_sorted = {}\n\tlocal lst_min, lst_max = lst[1], lst[1]\n\tlocal\
    \ lst_min_pos, lst_max_pos = 1, 1\n\tfor i, v in ipairs(lst) do\n\t\tif v > lst_max\
    \ then\n\t\t\tlst_max = v\n\t\t\tlst_max_pos = i\n\t\tend\n\t\tif v < lst_min\
    \ then\n\t\t\tlst_min = v\n\t\t\tlst_min_pos = i\n\t\tend\n\tend\n\tlst_sorted[1]\
    \ = lst_min\n\tlst_sorted[2] = lst_max\n\tlocal lst_min_odd = true\n\tfor i =\
    \ 1, #lst - 2 do\n\t\tif lst_min_odd then\n\t\t\tif lst_min_pos + 1 > #lst then\n\
    \t\t\t\tlst_min_pos = 1\n\t\t\telse\n\t\t\t\tlst_min_pos = lst_min_pos + 1\n\t\
    \t\tend\n\t\t\tlst_sorted[i + 2] = lst[lst_min_pos]\n\t\t\tlst_min_odd = false\n\
    \t\telse\n\t\t\tif lst_max_pos + 1 > #lst then\n\t\t\t\tlst_max_pos = 1\n\t\t\t\
    else\n\t\t\t\tlst_max_pos = lst_max_pos + 1\n\t\t\tend\n\t\t\tlst_sorted[i + 2]\
    \ = lst[lst_max_pos]\n\t\t\tlst_min_odd = true\n\t\tend\n\tend\n\treturn lst_sorted\n\
    end", "  -- your code here\nend", end, "  local n = #lst\n  local k = 1\n  local\
    \ new_lst = {}\n  local s, e = 1, n\n  local incr = 1\n  local curr_max = -math.huge\n\
    \  local curr_min = math.huge\n  for i = 1, n do\n    new_lst[i] = lst[k]\n  \
    \  if k == s then\n      if incr == 1 then\n        curr_max = -math.huge\n  \
    \      for i = 1, n do\n          if lst[i] > curr_max and i ~= k then\n     \
    \       curr_max = lst[i]\n            k = i\n          end\n        end\n   \
    \     incr = -1\n      else\n        curr_min = math.huge\n        for i = 1,\
    \ n do\n          if lst[i] < curr_min and i ~= k then\n            curr_min =\
    \ lst[i]\n            k = i\n          end\n        end\n        incr = 1\n  \
    \    end\n    elseif k == e then\n      if incr == 1 then\n        curr_max =\
    \ -math.huge\n        for i = n, 1, -1 do\n          if lst[i] > curr_max and\
    \ i ~= k then\n            curr_max = lst[i]\n            k = i\n          end\n\
    \        end\n        incr = -1\n      else\n        curr_min = math.huge\n  \
    \      for i = n, 1, -1 do\n          if lst[i] < curr_min and i ~= k then\n \
    \           curr_min = lst[i]\n            k = i\n          end\n        end\n\
    \        incr = 1\n      end\n    else\n      if incr == 1 then\n        if k\
    \ < s then\n          s = k\n        elseif k > e then\n          e = k\n    \
    \    end\n      else\n        if k > e then\n          e = k\n        elseif k\
    \ < s then\n          s = k\n        end\n      end\n    end\n  end\n  return\
    \ new_lst\nend", "  if #lst == 0 then return lst end\n  local min, max, result\
    \ = math.min(unpack(lst)), math.max(unpack(lst)), {}\n  lst = filter(function(x)\
    \ return x ~= min and x ~= max end, lst)\n  repeat\n    result[#result + 1] =\
    \ min\n    result[#result + 1] = max\n    min, max = math.min(unpack(lst)), math.max(unpack(lst))\n\
    \    lst = filter(function(x) return x ~= min and x ~= max end, lst)\n  until\
    \ #lst == 0\n  return result\nend", "    local function lists_equal(lst1, lst2)\n\
    \        if #lst1 ~= #lst2 then\n            return false\n        end\n     \
    \   for i = 1, #lst1 do\n            if lst1[i] ~= lst2[i] then\n            \
    \    return false\n            end\n        end\n        return true\n    end",
  "    if #lst == 0 then\n        return lst\n    end\n    local res = {}\n    while\
    \ #lst > 0 do\n        local min, max = math.min(unpack(lst)), math.max(unpack(lst))\n\
    \        table.insert(res, min)\n        table.insert(res, max)\n        if min\
    \ == max then\n            table.remove(lst, table.index_of(lst, min))\n     \
    \   else\n            table.remove(lst, table.index_of(lst, min))\n          \
    \  table.remove(lst, table.index_of(lst, max))\n        end\n    end\n    return\
    \ res\nend", "  local retval = {}\n  local min_value, max_value\n  while lst ~=\
    \ {} do\n    min_value = lst[1]\n    max_value = min_value\n    for k, v in ipairs(lst)\
    \ do\n      if v < min_value then\n        min_value = v\n      elseif v > max_value\
    \ then\n        max_value = v\n      end\n    end\n    table.insert(retval, min_value)\n\
    \    table.insert(retval, max_value)\n    for k, v in ipairs(lst) do\n      if\
    \ v == min_value or v == max_value then\n        table.remove(lst, k)\n      \
    \  break\n      end\n    end\n  end\n  return retval\nend", "    local idx_even,\
    \ idx_odd = 1, #lst\n    local res = {}\n    while idx_even <= idx_odd do\n  \
    \      table.insert(res, lst[idx_even])\n        if idx_even ~= idx_odd then\n\
    \            table.insert(res, lst[idx_odd])\n        end\n        idx_even =\
    \ idx_even + 1\n        idx_odd = idx_odd - 1\n    end\n    return res\nend",
  "  -- YOUR CODE HERE\nend", "    return {}\nend", "  local function helper(acc,\
    \ lst)\n    if lst == nil then return acc end\n    local min, min_idx = unpack(min_max(lst))\n\
    \    local max, max_idx = unpack(min_max(remove_idx(lst, min_idx)))\n    if max\
    \ == nil then return cons(min, acc) end\n    return helper(cons(min, helper(cons(max,\
    \ acc), remove_idx(lst, max_idx))), remove_idx(lst, min_idx))\n  end\n  return\
    \ helper(nil, lst)\nend", "  -- put your code here\nend", "    if lst == nil or\
    \ #lst == 0 then\n        return lst\n    end\n    -- sort list\n    local sorted\
    \ = {}\n    for i=1,#lst do\n        table.insert(sorted, lst[i])\n    end\n \
    \   table.sort(sorted)\n    -- create new list\n    local new_lst = {}\n    local\
    \ min_max = 1\n    while #sorted > 0 do\n        if min_max % 2 == 1 then\n  \
    \          table.insert(new_lst, table.remove(sorted, 1))\n        else\n    \
    \        table.insert(new_lst, table.remove(sorted))\n        end\n        min_max\
    \ = min_max + 1\n    end\n    return new_lst\nend", "    local odd_list = {}\n\
    \    local even_list = {}\n    local result = {}\n    local length = #lst\n  \
    \  if length == 0 then\n        return result\n    end\n    if length == 1 then\n\
    \        return lst\n    end\n    local odd_list_length = length // 2\n    local\
    \ even_list_length = length - odd_list_length\n    for i, v in ipairs(lst) do\n\
    \        if (i % 2) == 0 then\n            table.insert(even_list, v)\n      \
    \  else\n            table.insert(odd_list, v)\n        end\n    end\n    table.sort(odd_list)\n\
    \    table.sort(even_list)\n    for i = 1, odd_list_length do\n        table.insert(result,\
    \ odd_list[i])\n        table.insert(result, even_list[i])\n    end\n    if even_list_length\
    \ > odd_list_length then\n        table.insert(result, even_list[odd_list_length\
    \ + 1])\n    end\n    return result\nend", "    if #lst == 0 then\n        return\
    \ lst\n    end\n    local lst1 = {}\n    local lst2 = {}\n    for i = 1, #lst\
    \ / 2 do\n        lst1[i] = lst[i]\n        lst2[i] = lst[#lst - i + 1]\n    end\n\
    \    return lst1, lst2\nend", "  -- your code here\nend", "    if #lst == 0 then\n\
    \        return lst\n    end\n    local asc = (lst[1] < lst[2])\n    for i = 2,\
    \ #lst - 1 do\n        if asc and lst[i] > lst[i + 1] then\n            asc =\
    \ false\n        elseif not asc and lst[i] < lst[i + 1] then\n            asc\
    \ = true\n        end\n    end\n    if asc then\n        return strange_sort_list(lst)\n\
    \    end\n    local first = math.min(unpack(lst))\n    local rest = {}\n    for\
    \ i = 1, #lst do\n        if lst[i] ~= first then\n            table.insert(rest,\
    \ lst[i])\n        end\n    end\n    return {first, unpack(strange_sort_list(rest))}\n\
    end", "    if #lst == 0 then\n        return lst\n    end\n    local res = {}\n\
    \    table.sort(lst)\n    for i = 1, #lst, 2 do\n        table.insert(res, lst[i])\n\
    \        if i + 1 <= #lst then\n            table.insert(res, lst[#lst - i + 1])\n\
    \        end\n    end\n    return res\nend", "    if #lst == 0 then\n        return\
    \ lst\n    end\n    local min, max = math.min(unpack(lst)), math.max(unpack(lst))\n\
    \    local temp = {}\n    local result = {}\n    local flag = true\n    for _,\
    \ v in ipairs(lst) do\n        if v ~= min and v ~= max then\n            table.insert(temp,\
    \ v)\n        end\n    end\n    if #temp > 0 then\n        if #temp % 2 == 0 then\n\
    \            for i = 1, #temp, 2 do\n                table.insert(result, temp[i])\n\
    \                table.insert(result, temp[i + 1])\n            end\n        else\n\
    \            for i = 1, #temp - 1, 2 do\n                table.insert(result,\
    \ temp[i])\n                table.insert(result, temp[i + 1])\n            end\n\
    \            table.insert(result, temp[#temp])\n        end\n    end\n    if flag\
    \ then\n        table.insert(result, min)\n        table.insert(result, max)\n\
    \    else\n        table.insert(result, max)\n        table.insert(result, min)\n\
    \    end\n    return result\nend", "  --write your code here\n  return nil\nend",
  "\t-- will contain sorted elements\n\tlocal res = {}\n\t-- will contain values that\
    \ are not yet sorted\n\tlocal tmp = {}\n\t-- will contain minimum and maximum\
    \ values of tmp\n\tlocal min, max = nil, nil\n\t-- if lst is empty, return empty\
    \ lst\n\tif #lst == 0 then\n\t\treturn lst\n\tend\n\t-- fill tmp with values from\
    \ lst\n\tfor i, v in ipairs(lst) do\n\t\ttable.insert(tmp, v)\n\tend\n\t-- as\
    \ long as we haven't sorted all of the elements\n\twhile #tmp > 0 do\n\t\t-- if\
    \ we haven't sorted any elements yet\n\t\tif #res == 0 then\n\t\t\t-- save minimum\
    \ value of tmp\n\t\t\tmin = math.min(unpack(tmp))\n\t\t\t-- add minimum value\
    \ to res\n\t\t\ttable.insert(res, min)\n\t\t\t-- remove minimum value from tmp\n\
    \t\t\tfor i, v in ipairs(tmp) do\n\t\t\t\tif v == min then\n\t\t\t\t\ttable.remove(tmp,\
    \ i)\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\t-- if length of tmp is 0\
    \ we don't need to continue\n\t\t\tif #tmp == 0 then\n\t\t\t\tbreak\n\t\t\tend\n\
    \t\t\t-- save maximum value of tmp\n\t\t\tmax = math.max(unpack(tmp))\n\t\t\t\
    -- add maximum value to res\n\t\t\ttable.insert(res, max)\n\t\t\t-- remove maximum\
    \ value from tmp\n\t\t\tfor i, v in ipairs(tmp) do\n\t\t\t\tif v == max then\n\
    \t\t\t\t\ttable.remove(tmp, i)\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\
    else\n\t\t\t-- we've sorted at least 1 element\n\t\t\tif #tmp > 1 then\n\t\t\t\
    \t-- if length of tmp is 2 or more we need to swap the minimum and maximum values\n\
    \t\t\t\t-- save minimum value of tmp\n\t\t\t\tmin = math.min(unpack(tmp))\n\t\t\
    \t\t-- add", "\tlocal res = {}\n\tlocal n = #lst\n\twhile n > 0 do\n\t\tlocal\
    \ max = math.max(unpack(lst))\n\t\tlocal min = math.min(unpack(lst))\n\t\ttable.insert(res,\
    \ min)\n\t\tif max ~= min then\n\t\t\ttable.insert(res, max)\n\t\tend\n\t\tfor\
    \ i = 1, n do\n\t\t\tif lst[i] == max or lst[i] == min then\n\t\t\t\ttable.remove(lst,\
    \ i)\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tn = n - 1\n\tend\n\treturn res\n\
    end", "    local len = #lst\n    local fun = function(lst,i)\n        if not i\
    \ then i = 1 end\n        if i > len then return end\n        local mn, mx, index_mn,\
    \ index_mx = math.min(unpack(lst)), math.max(unpack(lst))\n        if mn == mx\
    \ then return end\n        local p1, p2 = mn, mx\n        table.remove(lst,index_mn)\n\
    \        table.remove(lst,index_mx-1)\n        table.insert(lst,i,p1)\n      \
    \  table.insert(lst,i+1,p2)\n        fun(lst,i+2)\n    end\n    fun(lst)\n   \
    \ return lst\nend", "    local res = {}\n    local min, max\n    repeat\n    \
    \    min = math.min(unpack(lst))\n        max = math.max(unpack(lst))\n      \
    \  table.insert(res, min)\n        table.insert(res, max)\n        lst = table.reduce(lst,\
    \ function(e, acc)\n            if e ~= min and e ~= max then\n              \
    \  table.insert(acc, e)\n            end\n            return acc\n        end,\
    \ {})\n    until #lst == 0\n    return res\nend", "    if #lst <= 1 then\n   \
    \     return lst\n    end\n    --[[\n    local sorted = {}\n    local n = #lst\n\
    \    while n > 0 do\n        local min_i = 0\n        local min_v = math.huge\n\
    \        local max_i = 0\n        local max_v = -math.huge\n        for i = 1,\
    \ n do\n            local v = lst[i]\n            if v < min_v then\n        \
    \        min_i = i\n                min_v = v\n            end\n            if\
    \ v > max_v then\n                max_i = i\n                max_v = v\n     \
    \       end\n        end\n        table.insert(sorted, min_v)\n        table.remove(lst,\
    \ min_i)\n        n = n - 1\n        if n > 0 then\n            table.insert(sorted,\
    \ max_v)\n            table.remove(lst, max_i)\n            n = n - 1\n      \
    \  end\n    end\n    return sorted\n    --]]\n    local sorted = {}\n    local\
    \ n = #lst\n    while n > 0 do\n        local min_i = 0\n        local min_v =\
    \ math.huge\n        local max_i = 0\n        local max_v = -math.huge\n     \
    \   for i = 1, n do\n            local v = lst[i]\n            if v < min_v then\n\
    \                min_i = i\n                min_v = v\n            end\n     \
    \       if v > max_v then\n                max_i = i\n                max_v =\
    \ v\n            end\n        end\n        table.insert(sorted, min_v)\n     \
    \   table.remove(lst, min_i)\n        n = n - 1\n        if n > 0 then\n     \
    \       table.insert(sorted, max_v)\n            table.remove(lst, max_i)\n  \
    \          n = n - 1\n        end\n    end\n    return sorted\nend", "    local\
    \ _, sorted_lst = stable_sort(lst, function(a, b) return a < b end)\n    local\
    \ n = #sorted_lst\n    local result = {}\n    local i, j = 1, n\n    while i <=\
    \ n and j >= 1 do\n        result[#result + 1] = sorted_lst[i]\n        result[#result\
    \ + 1] = sorted_lst[j]\n        i = i + 1\n        j = j - 1\n    end\n    return\
    \ result\nend", "  if #lst == 0 then return lst end\n  local l = {}\n  local m\
    \ = min(lst)\n  for i = 1, #lst do\n    if m == lst[i] then\n      table.insert(l,\
    \ m)\n      table.remove(lst, i)\n      break\n    end\n  end\n  if #lst == 0\
    \ then return l end\n  local m = max(lst)\n  for i = 1, #lst do\n    if m == lst[i]\
    \ then\n      table.insert(l, m)\n      table.remove(lst, i)\n      break\n  \
    \  end\n  end\n  return strange_sort_list(lst)\nend", "    if #lst == 0 then\n\
    \        return lst\n    end\n    local sorted = {}\n    local mini, maxi = math.min(unpack(lst)),\
    \ math.max(unpack(lst))\n    for i = 1, #lst do\n        if i % 2 == 1 then\n\
    \            table.insert(sorted, mini)\n            table.remove(lst, table.indexof(lst,\
    \ mini))\n        else\n            table.insert(sorted, maxi)\n            table.remove(lst,\
    \ table.indexof(lst, maxi))\n        end\n        mini, maxi = math.min(unpack(lst)),\
    \ math.max(unpack(lst))\n    end\n    return sorted\nend", "    local result =\
    \ {}\n    local len = #lst\n    local lower = lst[1]\n    local upper = lst[len]\n\
    \    local index = 1\n    for i=1,len do\n        if i%2 == 1 then\n         \
    \   table.insert(result, lower)\n            lower = lst[i+1]\n        else\n\
    \            table.insert(result, upper)\n            upper = lst[len-index]\n\
    \            index = index + 1\n        end\n    end\n    return result\nend",
  "    local clone = lst\n    local res = {}\n    local res_len = 0\n    while #clone\
    \ > 0 do\n        local val = math.min(unpack(clone))\n        table.insert(res,\
    \ val)\n        table.remove(clone, find_element(clone, val))\n        val = math.max(unpack(clone))\n\
    \        table.insert(res, val)\n        table.remove(clone, find_element(clone,\
    \ val))\n    end\n    return res\nend", "    if #lst == 0 then\n        return\
    \ lst\n    end\n    local answer = {}\n    local half = #lst / 2\n    if #lst\
    \ % 2 == 1 then\n        half = half + 1\n    end\n    table.sort(lst)\n    for\
    \ i = 1, half do\n        answer[#answer + 1] = lst[i]\n        answer[#answer\
    \ + 1] = lst[#lst - i + 1]\n    end\n    return answer\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
