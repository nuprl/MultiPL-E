name: HumanEval_49_modp
language: lua
results:
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  return fmod(n,\
    \ p)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpnm2rrjtq.lua:13:\
    \ attempt to call a nil value (global 'fmod')\nstack traceback:\n\t/tmp/tmpnm2rrjtq.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpnm2rrjtq.lua:19: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n < p then\n\
    \        return n\n    end\n    local q = math.floor(n / p)\n    local r = n -\
    \ q * p\n    return modp(q, p) + r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgmskmfbn.lua:25:\
    \ expected: 2, actual: 101\nstack traceback:\n\t/tmp/tmpgmskmfbn.lua:25: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n % 2 == 0 then\n        return modp(n/2, p)^2 %\
    \ p\n    else\n        return (modp(n-1, p) * 2) % p\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local res =\
    \ 1\n    while n > 0 do\n        if n % 2 == 1 then\n            res = (res *\
    \ 2) % p\n        end\n        n = floor(n / 2)\n    end\n    return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpj2m5f81y.lua:18:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmpj2m5f81y.lua:18:\
    \ in local 'candidate'\n\t/tmp/tmpj2m5f81y.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n == 1 then\n        return 2\n    elseif n % 2\
    \ == 0 then\n        local mod = modp(n/2, p)\n        return (mod*mod) % p\n\
    \    else\n        local mod = modp(n-1, p)\n        return (2*mod) % p\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n==0 then\
    \ return 1 end\n    if n%2==0 then\n        return modp(2*n, p)^2 % p\n    else\n\
    \        return 2*modp(n-1, p) % p\n    end\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy49jahvc.lua:24:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpy49jahvc.lua:24: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local m = 1\n\
    \  local b = 2\n  while n > 0 do\n    if n % 2 == 1 then\n      m = (m * b) %\
    \ p\n    end\n    n = math.floor(n / 2)\n    b = (b * b) % p\n  end\n  return\
    \ m\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local r = n\
    \ % p\n    return r == 0 and p or r\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6yd18kao.lua:21:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmp6yd18kao.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n < 0 then\n\
    \        error(\"Negative exponent in modp\")\n    end\n    -- We use x^n = (x^(n/2))^2\n\
    \    -- x^n = (x^((n-1)/2))^2 * x\n    if n == 0 then\n        return 1\n    elseif\
    \ n % 2 == 0 then\n        local x = modp(n/2, p)\n        return (x * x) % p\n\
    \    else\n        local x = modp((n-1)/2, p)\n        return (x * x * 2) % p\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    return n % p\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppersi1ae.lua:20:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmppersi1ae.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local result\
    \ = 1\n    local a = 2 % p\n    while n > 0 do\n        if n % 2 == 1 then\n \
    \           result = (result * a) % p\n        end\n        n = math.floor(n /\
    \ 2)\n        a = (a * a) % p\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local q = math.floor(p/2)\n\
    \    local r = n % p\n    if r == 0 then\n        return 1\n    elseif r > q then\n\
    \        return (2*(r-q)) % p\n    else\n        return (2*r) % p\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptm6ct816.lua:27:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmptm6ct816.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  return big.mod(big.pow(2,\
    \ n), p)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpx50d2ew3.lua:13:\
    \ attempt to index a nil value (global 'big')\nstack traceback:\n\t/tmp/tmpx50d2ew3.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpx50d2ew3.lua:19: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  -- It is faster\
    \ to take (mod p) after every multiplication, but be aware\n  -- of numerics.\n\
    \  if n < p then\n    return n\n  end\n  local r = 1\n  local k = 1\n  local x\
    \ = 2\n  while k < n do\n    if k * 2 > n then\n      r = (r * x) % p\n      k\
    \ = k + 1\n    else\n      x = (x * x) % p\n      k = k * 2\n    end\n  end\n\
    \  return r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprrdd596v.lua:37:\
    \ expected: 2, actual: 25\nstack traceback:\n\t/tmp/tmprrdd596v.lua:37: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  n = n % p\n  if n == 0 then return 1 end\n  for i = 1, n do\n    res = (res\
    \ * 2) % p\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9ouqjewz.lua:26:\
    \ expected: 2, actual: 29\nstack traceback:\n\t/tmp/tmp9ouqjewz.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  local x = modp(n/2, p)\n  x = x*x % p\n  if n % 2 == 1 then\n\
    \    x = x*2 % p\n  end\n  return x\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpu6i6citq.lua:25:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpu6i6citq.lua:25: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  local m = n % (p - 1)\n  for i = 1, m do\n    res = (res * 2) % p\n  end\n\
    \  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local n = n %\
    \ p\n  if n == 0 then\n    return 1\n  else\n    return n\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl901r247.lua:25:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmpl901r247.lua:25: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tif n == 0 then\n\
    \t\treturn 1\n\telseif n == 1 then\n\t\treturn n\n\telseif n == p then\n\t\treturn\
    \ 0\n\telseif n < p then\n\t\treturn n\n\telse\n\t\tlocal t = floor(n / p)\n\t\
    \tlocal r = n - t * p\n\t\tif r == 1 then\n\t\t\treturn 1\n\t\telseif r == 0 then\n\
    \t\t\treturn 0\n\t\telse\n\t\t\treturn r\n\t\tend\n\tend\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpei9ui8ww.lua:22:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmpei9ui8ww.lua:22:\
    \ in local 'candidate'\n\t/tmp/tmpei9ui8ww.lua:38: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    -- Simple modulus.\n\
    \    if n < p then\n        return n\n    end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpf3dze432.lua:30: 'end' expected (to close 'function' at line\
    \ 12) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local r = 1\n\
    \    local q = 2\n    local b = bit.band(n, 1)\n    if b == 1 then\n        r\
    \ = q\n    end\n    n = bit.rshift(n, 1)\n    while n > 0 do\n        b = bit.band(n,\
    \ 1)\n        n = bit.rshift(n, 1)\n        q = (q * q) % p\n        if b == 1\
    \ then\n            r = (r * q) % p\n        end\n    end\n    return r\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6ivzjj29.lua:15:\
    \ attempt to index a nil value (global 'bit')\nstack traceback:\n\t/tmp/tmp6ivzjj29.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmp6ivzjj29.lua:34: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tif p == 1 then\n\
    \t\treturn 0\n\tend\n\tlocal res = 1\n\tn = n % p\n\twhile n > 0 do\n\t\tif n\
    \ % 2 == 1 then\n\t\t\tres = (res * 2) % p\n\t\tend\n\t\tn = floor(n / 2)\n\t\
    end\n\treturn res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_k6ya4pu.lua:22:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmp_k6ya4pu.lua:22:\
    \ in local 'candidate'\n\t/tmp/tmp_k6ya4pu.lua:30: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local res =\
    \ 1\n    for i = 1, n do\n        res = res * 2 % p\n    end\n    return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local sum =\
    \ 1\n    for i = 1, n do\n        sum = (sum * 2) % p\n    end\n    return sum\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n == 1 then\n        return 0\n    elseif n % 2\
    \ == 0 then\n        local res = modp(n / 2, p)\n        return (res * res) %\
    \ p\n    else\n        return (2 * modp(n - 1, p)) % p\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpeg0y8yes.lua:28:\
    \ expected: 3, actual: 0\nstack traceback:\n\t/tmp/tmpeg0y8yes.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local b = 1\n\
    \  for i = 1, n do\n    b = b * 2 % p\n  end\n  return b\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  -- TODO: implement\
    \ an optimised algorithm, e.g. a square-and-multiply algorithm\n  return n % p\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxlm3k9db.lua:21:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmpxlm3k9db.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  return fmod(fmod(n,\
    \ 2^53)*p, 1)*p\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgfns7owm.lua:13:\
    \ attempt to call a nil value (global 'fmod')\nstack traceback:\n\t/tmp/tmpgfns7owm.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpgfns7owm.lua:19: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local m = 1\n\
    \    while n > 0 do\n        if n % 2 == 1 then\n            m = (m * 2) % p\n\
    \        end\n        n = n // 2\n    end\n    return m\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2aauwtyx.lua:26:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmp2aauwtyx.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\t-- 32-bit numerics\
    \ range from 2^31-1 to -2^31.\n\t-- 64-bit numerics range from 2^63-1 to -2^63.\n\
    \tlocal big = 2^30-1\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmph2n7z2og.lua:29: 'end' expected (to close 'function' at line\
    \ 12) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  if n % 2 == 0 then\n    return (modp(n/2, p)^2) % p\n  else\n\
    \    return (modp(n/2, p)^2 * 2) % p\n  end\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuitt5ykv.lua:25:\
    \ expected: 2, actual: 34\nstack traceback:\n\t/tmp/tmpuitt5ykv.lua:25: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local v = 2^n\
    \ % p\n  if v == 0 then return p else return v end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp34tg0ar0.lua:21:\
    \ expected: 2, actual: #NaN\nstack traceback:\n\t/tmp/tmp34tg0ar0.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tassert(n >= 0\
    \ and p > 0, \"Invalid arguments.\")\n\treturn modm(2^n, p)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpv1otpn5m.lua:14:\
    \ attempt to call a nil value (global 'modm')\nstack traceback:\n\t/tmp/tmpv1otpn5m.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmpv1otpn5m.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local rem =\
    \ 0\n    for c in string.gmatch(tostring(n), \".\") do\n        rem = (rem * 10\
    \ + tonumber(c)) % p\n    end\n    return rem\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa33jhjuw.lua:24:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmpa33jhjuw.lua:24: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n == 1 then\n        return 2\n    elseif p == 2\
    \ then\n        return 2\n    elseif p == 3 then\n        return 2\n    elseif\
    \ p == 5 then\n        return 2\n    elseif p == 7 then\n        return 3\n  \
    \  elseif p == 11 then\n        return 8\n    elseif p == 13 then\n        return\
    \ 4\n    elseif p == 17 then\n        return 3\n    elseif p == 19 then\n    \
    \    return 16\n    elseif p == 23 then\n        return 10\n    elseif p == 29\
    \ then\n        return 23\n    elseif p == 31 then\n        return 16\n    elseif\
    \ p == 37 then\n        return 33\n    elseif p == 41 then\n        return 3\n\
    \    elseif p == 43 then\n        return 32\n    elseif p == 47 then\n       \
    \ return 20\n    elseif p == 53 then\n        return 33\n    elseif p == 59 then\n\
    \        return 47\n    elseif p == 61 then\n        return 5\n    elseif p ==\
    \ 67 then\n        return 18\n    elseif p == 71 then\n        return 5\n    elseif\
    \ p == 73 then\n        return 3\n    elseif p == 79 then\n        return 39\n\
    \    elseif p == 83 then\n        return 1\n    elseif p == 89 then\n        return\
    \ 40\n    elseif p == 97 then\n        return 8\n    elseif p == 101 then\n  \
    \      return 2\n    elseif p == 103 then\n        return 22\n    elseif p ==\
    \ 107 then\n        return 77\n    elseif p == 109 then\n        return 17\n \
    \   elseif p == 113 then\n        return 38\n    elseif p == 127 then\n      \
    \  return 42\n    elseif p == 131 then\n        return 91\n    elseif p == 137\
    \ then\n        return 36\n    elseif p == 139 then\n        return 17\n    elseif\
    \ p == 149 then\n        return 101\n    elseif p == 151 then\n        return\
    \ 2\n    elseif p == 157 then\n        return 9\n    elseif p == 163 then\n  \
    \      return 55\n    elseif p == 167 then\n        return 31\n    elseif p ==\
    \ 173 then\n        return 35\n    elseif p == 179 then\n\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp161o6hn_.lua:112: 'end' expected (to close 'if' at line 13)\
    \ near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\t-- assert(n ~=\
    \ math.huge, \"Division by infinity\")\n\tassert(n ~= math.huge and n ~= -math.huge,\
    \ \"Division by infinity\")\n\tlocal r\n\tif n == 0 then return 1 end\n\tif n\
    \ < 0 then return modp(p - n, p) end\n\t-- n >= 0\n\tif n % 2 == 0 then\n\t\t\
    r = modp(n / 2, p)\n\t\treturn (r * r) % p\n\telse\n\t\tr = modp((n - 1) / 2,\
    \ p)\n\t\treturn (2 * r * r) % p\n\tend\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local b, c = 0,\
    \ 1\n  for i = 0, 31 do\n    if bit.band(n, 1) == 1 then\n      c = c * 2\n  \
    \    if c >= p then\n        c = c - p\n      end\n    end\n    n = bit.rshift(n,\
    \ 1)\n    if n == 0 then\n      break\n    end\n  end\n  return c\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgjanbi6o.lua:15:\
    \ attempt to index a nil value (global 'bit')\nstack traceback:\n\t/tmp/tmpgjanbi6o.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpgjanbi6o.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n < 0 then\n        return nil\n    end\n    local\
    \ base = n % p\n    n = n - base\n    while n > 0 do\n        n = n / 2\n    \
    \    base = (base * base) % p\n    end\n    return base\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb9m4kr13.lua:31:\
    \ expected: 2, actual: 1\nstack traceback:\n\t/tmp/tmpb9m4kr13.lua:31: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  -- assert(n >=\
    \ 0)\n  -- assert(p >= 2)\n  -- we need some extra space for the numerics\n  local\
    \ k = 1\n  while k < p do\n    k = k * 2\n  end\n  return (n % p) % k\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppwgxkk74.lua:27:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmppwgxkk74.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\t-- See:\n\t--\
    \ https://en.wikipedia.org/wiki/Exponentiation_by_squaring#Modular_exponentiation\n\
    \tif p <= 0 then return end\n\tn = n % p\n\tif n == 0 then return 1 end\n\tlocal\
    \ c = 1\n\twhile n > 1 do\n\t\tif n % 2 == 1 then\n\t\t\tc = (c * n) % p\n\t\t\
    end\n\t\tn = n * n\n\t\tn = n % p\n\tend\n\treturn c\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdxwbtk1a.lua:33:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmpdxwbtk1a.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if p == 1 then\n\
    \        return 0\n    end\n    -- TODO: implement the simple \"p mod 2 == 0\"\
    \ case.\n    local a = 1\n    local t = n\n    while t > 0 do\n        if t %\
    \ 2 == 1 then\n            a = (a * n) % p\n        end\n        t = math.floor(t\
    \ / 2)\n        n = (n * n) % p\n    end\n    return a\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7s2d5yzj.lua:32:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmp7s2d5yzj.lua:32: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal r = 1\n\t\
    local x = n\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tr = (r * x) % p\n\
    \t\tend\n\t\tx = (x * x) % p\n\t\tn = n / 2\n\tend\n\treturn r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8vljuylp.lua:29:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmp8vljuylp.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tif (n < 0) then\n\
    \t\tn = n % p + p\n\tend\n\tif (n < p) then\n\t\treturn n\n\tend\n\tlocal r =\
    \ 1\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tr = (r * 2) % p\n\t\tend\n\
    \t\tn = n // 2\n\tend\n\treturn r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmps2u4f181.lua:33:\
    \ expected: 2, actual: 32\nstack traceback:\n\t/tmp/tmps2u4f181.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    assert(n >=\
    \ 0, 'n is smaller than 0!')\n    if p <= n then\n        n = n % p\n    end\n\
    \    if n == 0 then\n        return 1\n    elseif n == 1 then\n        return\
    \ 2\n    else\n        local a = 2\n        local b = 2\n        for i = 2, n\
    \ do\n            a = (a * b) % p\n        end\n        return a\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcz1msq0x.lua:35:\
    \ expected: 2, actual: 29\nstack traceback:\n\t/tmp/tmpcz1msq0x.lua:35: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if p <= 0 then\n\
    \        error(\"modp: non-positive modulus: \" .. p)\n    end\n    if n == 0\
    \ then\n        return 1\n    end\n    if n < 0 then\n        return modp(-n,\
    \ p)\n    end\n    if n == 1 then\n        return n\n    end\n    if n > p then\n\
    \        return modp(n % p, p)\n    end\n    -- otherwise n < p and n > 1\n  \
    \  local n2 = bit32.band(n, 1)\n    local x2 = bit32.band(p, 1)\n    if n2 ==\
    \ 0 then\n        return modp(n / 2, p)\n    end\n    if x2 == 0 then\n      \
    \  return modp(n, p / 2) * 2\n    end\n    -- otherwise n2, x2 = 1\n    return\
    \ (modp(n - 1, p) + p - modp(p - 1, n)) / 2\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppphgcp1m.lua:44:\
    \ expected: 3, actual: 2.5\nstack traceback:\n\t/tmp/tmppphgcp1m.lua:44: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    assert(type(n)\
    \ == \"number\", \"n has to be a number\")\n    assert(type(p) == \"number\",\
    \ \"p has to be a number\")\n    assert(n == math.floor(n), \"n has to be an integer\"\
    )\n    assert(p == math.floor(p), \"p has to be an integer\")\n    assert(p >\
    \ 1, \"p has to be > 1\")\n    assert(n >= 0, \"n has to be >= 0\")\n    assert(p\
    \ >= 2, \"p has to be >= 2\")\n    local result = 1\n    local z = n\n    local\
    \ x = 2\n    while z > 0 do\n        while z % 2 == 0 do\n            z = z /\
    \ 2\n            local y = x * x % p\n            if y == 1 and x ~= 1 and x ~=\
    \ p - 1 then\n                return 0\n            end\n            x = y\n \
    \       end\n        z = z - 1\n        result = (result * x) % p\n    end\n \
    \   return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if p < 0 then\n\
    \    return modp(n, -p)\n  end\n  local a = 1\n  local b = 0\n  local c = 0\n\
    \  local d = 1\n  local x = math.floor(p / 2)\n  local y = n % p\n  while y ~=\
    \ 0 do\n    q = math.floor(x / y)\n    r = x - q * y\n    x = y\n    y = r\n \
    \   s = a - q * c\n    t = b - q * d\n    a = c\n    b = d\n    c = s\n    d =\
    \ t\n  end\n  if x ~= 1 then\n    print(\"assertion failed\")\n  end\n  if a <\
    \ 0 then\n    a = a + p\n  end\n  return a\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqjvhf17i.lua:46:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmpqjvhf17i.lua:46: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  assert(type(n)\
    \ == \"number\", \"n is not a number\")\n  assert(type(p) == \"number\", \"p is\
    \ not a number\")\n  assert(p > 1, \"p is not a prime\")\n  if n < 0 then n =\
    \ n + p end\n  if n == 0 then return 1 end\n  local rslt = 2\n  while (n ~= 1)\
    \ do\n    if n % 2 == 1 then\n      rslt = (rslt * 2) % p\n    end\n    n = n\
    \ / 2\n  end\n  return rslt\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local d = 1\n\
    \  for i = 1, n do\n    d = d * 2 % p\n  end\n  return d\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local result\
    \ = 1\n    for i = 1, n do\n        result = (result * 2) % p\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tassert(n >= 0,\
    \ \"n must be non-negative\")\n\tassert(p > 1, \"p must be greater than 1\")\n\
    \tlocal x = n\n\twhile x >= p do\n\t\tx = (x * n) % p\n\tend\n\treturn x\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc5on8irh.lua:26:\
    \ expected: 2, actual: 100\nstack traceback:\n\t/tmp/tmpc5on8irh.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  while n > 0 do\n    if n % 2 == 1 then\n      res = (res * n) % p\n    end\n\
    \    n = (n - n % 2) / 2\n    n = n % p\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoluh8l18.lua:28:\
    \ expected: 2, actual: 96\nstack traceback:\n\t/tmp/tmpoluh8l18.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  local t = modp(n // 2, p)\n  t = (t * t) % p\n  if n % 2 ==\
    \ 1 then\n    t = (t * 2) % p\n  end\n  return t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    -- Calculate\
    \ and return 2^n modulo p.\n    if n < 0 then\n        -- Negative exponent, use\
    \ modular exponentiation.\n        return exp(n, p-2, p)\n    else\n        --\
    \ Non-negative exponent.\n        -- Initialize.\n        local s = 1\n      \
    \  local f = 2\n        local t = n\n        while t > 0 do\n            -- Calculate\
    \ f^2 and then the next value of s.\n            f = (f * f) % p\n           \
    \ if t % 2 == 1 then\n                s = (s * f) % p\n            end\n     \
    \       -- Next iteration.\n            t = math.floor(t / 2)\n        end\n \
    \       return s\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprk6to028.lua:39:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmprk6to028.lua:39: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    return n % p\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp88dyd6rz.lua:20:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmp88dyd6rz.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local m = 1\n\
    \  while n ~= 0 do\n    if n % 2 == 1 then\n      m = (m * 2) % p\n    end\n \
    \   n = math.floor(n / 2)\n  end\n  return m\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw1ypif1n.lua:26:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmpw1ypif1n.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal result =\
    \ 1\n\twhile n ~= 0 do\n\t\tif n % 2 == 1 then\n\t\t\tresult = result * 2 % p\n\
    \t\tend\n\t\tn = n // 2\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa7rmx2ig.lua:26:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmpa7rmx2ig.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local r = 1\n\
    \    local a = n\n    local b = p\n    while b ~= 0 do\n        if b % 2 == 1\
    \ then\n            r = (r * a) % p\n        end\n        a = (a * a) % p\n  \
    \      b = math.floor(b / 2)\n    end\n    return r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy3xkm0pg.lua:30:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmpy3xkm0pg.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local k = 1\n\
    \  local d = 2\n  while n > 0 do\n    if n % 2 == 1 then\n      k = (k * d) %\
    \ p\n    end\n    n = math.floor(n / 2)\n    d = (d * d) % p\n  end\n  return\
    \ k\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  local b = n\n  while b > 0 do\n    if b % 2 == 1 then\n      res = res * n\
    \ % p\n    end\n    n = n * n % p\n    b = math.floor(b / 2)\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpurmc4lnp.lua:28:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpurmc4lnp.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal m = 1;\n\
    \twhile (n > 0) do\n\t\tif (n % 2 == 1) then\n\t\t\tm = (m * 2) % p;\n\t\tend\n\
    \t\tn = math.floor(n / 2);\n\tend\n\treturn m;\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpayyypd27.lua:26:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmpayyypd27.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n < 0 then\n\
    \        return p - modp(-n, p)\n    end\n    local res = 1\n    for i = 1, n\
    \ do\n        res = res * 2 % p\n    end\n    return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\t-- use a somewhat\
    \ optimized version of the obvious variant:\n\t-- local r = 1\n\t-- for i = 1,\
    \ n do\n\t-- \tr = (r * 2) % p\n\t-- end\n\t-- return r\n\tlocal r = 1\n\twhile\
    \ n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tr = (r * 2) % p\n\t\tend\n\t\tn = math.floor(n\
    \ / 2)\n\tend\n\treturn r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw90li18p.lua:32:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmpw90li18p.lua:32: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  if n % 2 == 0 then\n    return modp(n / 2, p)^2 % p\n  else\n\
    \    return (2 * modp(n - 1, p)) % p\n  end\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local n1 = n\n\
    \    local d = 1\n    while n1 ~= 0 do\n        local r = n1 % 2\n        n1 =\
    \ (n1 - r) / 2\n        if r == 1 then\n            d = (d * n) % p\n        end\n\
    \        n = (n * n) % p\n    end\n    return d\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8yd04mdv.lua:29:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmp8yd04mdv.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tif n < 0 then\n\
    \t\treturn modp(n + p, p)\n\tend\n\tif n < p then\n\t\treturn n\n\tend\n\tlocal\
    \ k = n % p\n\tif n / p % 2 == 0 then\n\t\treturn k\n\tend\n\treturn k - p\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuc_j1_ze.lua:30:\
    \ expected: 2, actual: -10\nstack traceback:\n\t/tmp/tmpuc_j1_ze.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tif n == 0 then\n\
    \t\treturn 1\n\telseif n % 2 == 0 then\n\t\treturn modp(n/2, p)^2 % p\n\telse\n\
    \t\treturn modp(n/2, p)^2 * 2 % p\n\tend\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp2dw7lf1.lua:26:\
    \ expected: 2, actual: 34\nstack traceback:\n\t/tmp/tmpp2dw7lf1.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if p == 1 then\n\
    \        return 0\n    end\n    local res = 1\n    local exp = n\n    while exp\
    \ > 0 do\n        if exp % 2 == 1 then\n            res = (res * n) % p\n    \
    \    end\n        exp = exp // 2\n        n = (n * n) % p\n    end\n    return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfuasgke0.lua:31:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpfuasgke0.lua:31: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\t--raise error\
    \ if not tonumber\n\tlocal x = 2 % p\n\tlocal a = x\n\twhile n > 0 do\n\t\tif\
    \ (n % 2) == 1 then\n\t\t\tx = x * a % p\n\t\tend\n\t\ta = a ^ 2 % p\n\t\tn =\
    \ math.floor(n / 2)\n\tend\n\treturn x\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjl_qrb73.lua:29:\
    \ expected: 3, actual: 1\nstack traceback:\n\t/tmp/tmpjl_qrb73.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  -- source: http://stackoverflow.com/a/10336481/323821\n\
    \  -- The answer in the link above is wrong. This is the correct version:\n  if\
    \ n == 0 then return 1 end\n  local res = 1\n  local v = n\n  -- Formula: 2^n\
    \ = 2^(n/2) * 2^(n/2) * 2^(n%2)\n  while v > 0 do\n    if v % 2 == 1 then\n  \
    \    res = (res * 2) % p\n    end\n    v = v / 2\n    if v > 0 then\n      res\
    \ = (res * res) % p\n    end\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxgh1is6u.lua:34:\
    \ expected: 3, actual: 1\nstack traceback:\n\t/tmp/tmpxgh1is6u.lua:34: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  local x = n % p\n  while n > 0 do\n    if n % 2 == 1 then\n      res = (res\
    \ * x) % p\n    end\n    n = math.floor(n / 2)\n    x = (x * x) % p\n  end\n \
    \ return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsy3pi8os.lua:28:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpsy3pi8os.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local x = 1\n\
    \    for i = 0, n do\n        x = (x * 2) % p\n    end\n    return x\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmcg62e0s.lua:23:\
    \ expected: 3, actual: 1\nstack traceback:\n\t/tmp/tmpmcg62e0s.lua:23: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal r = 1\n\t\
    while n > 0 do\n\t\tif n % 2 ~= 0 then\n\t\t\tr = r * 2 % p\n\t\tend\n\t\tn =\
    \ math.floor(n / 2)\n\tend\n\treturn r\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpshsfbv8p.lua:26:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmpshsfbv8p.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n < 0 then\n\
    \    return modp(p-((-n)%p), p)\n  end\n  if n <= 1 then\n    return n\n  end\n\
    \  if n%2 == 0 then\n    return (modp(n/2, p)^2)%p\n  else\n    return (modp(n/2,\
    \ p)^2 * 2)%p\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpv1itdbj7.lua:29:\
    \ expected: 3, actual: 2.53125\nstack traceback:\n\t/tmp/tmpv1itdbj7.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  while n > 0 do\n    if n % 2 == 1 then\n      res = (res * 2) % p\n    end\n\
    \    n = math.floor(n / 2)\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpv1xh5opk.lua:26:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmpv1xh5opk.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local r = 1\n\
    \    while n > 0 do\n        local a = n % 2\n        n = (n - a) / 2\n      \
    \  if a == 1 then\n            r = (r * 2) % p\n        end\n    end\n    return\
    \ r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptpxt44ie.lua:27:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmptpxt44ie.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal s = 1\n\t\
    local r = n % p\n\twhile n > 0 do\n\t\tn = math.floor(n / 2)\n\t\tif n % 2 ==\
    \ 1 then\n\t\t\ts = (s * r) % p\n\t\tend\n\t\tr = (r * r) % p\n\tend\n\treturn\
    \ s\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp31vn6d_k.lua:29:\
    \ expected: 2, actual: 100\nstack traceback:\n\t/tmp/tmp31vn6d_k.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  while n > 0 do\n    if (n & 1) == 1 then\n      res = (res * p) % m\n    end\n\
    \    p = (p * p) % m\n    n = n >> 1\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpolv1k5gz.lua:16:\
    \ attempt to perform arithmetic on a nil value (global 'm')\nstack traceback:\n\
    \t/tmp/tmpolv1k5gz.lua:16: in local 'candidate'\n\t/tmp/tmpolv1k5gz.lua:27: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n == 1 then\n        return 2\n    elseif n % 2\
    \ == 0 then\n        return (modp(n/2, p)^2 - 1) % p\n    else\n        return\
    \ (2 * modp((n-1)/2, p)^2) % p\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgs1dscdb.lua:28:\
    \ expected: 2, actual: 18\nstack traceback:\n\t/tmp/tmpgs1dscdb.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local n_p =\
    \ n % p\n    return n_p < 0 and n_p + p or n_p\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph8mgr18b.lua:21:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmph8mgr18b.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  if n == 1 then return 2 end\n  if n == 2 then return 4 end\n\
    \  local d = modp(n//2, p)\n  if n % 2 == 0 then\n    return (d*d) % p\n  else\n\
    \    return (d*d*2) % p\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tif p == 2 then\n\
    \t\treturn 1\n\tend\n\tlocal d = 1\n\tn = n % p\n\twhile n > 0 do\n\t\tif n %\
    \ 2 == 1 then\n\t\t\td = (d * 2) % p\n\t\tend\n\t\tn = math.floor(n / 2)\n\t\t\
    if n > 0 then\n\t\t\td = (d * d) % p\n\t\tend\n\tend\n\treturn d\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp05rje5h_.lua:34:\
    \ expected: 2, actual: 7\nstack traceback:\n\t/tmp/tmp05rje5h_.lua:34: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\treturn p < 3 and\
    \ (n%p) or ((n%p) + p) % p\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt8a5kf7d.lua:20:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmpt8a5kf7d.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\t-- modulus powers\
    \ of 2 are fast\n\tif bit.band(p, p - 1) == 0 then\n\t\treturn bit.band(n, p -\
    \ 1)\n\tend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpyv27d0bl.lua:30: 'end' expected (to close 'function' at line\
    \ 12) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal res = 1\n\
    \tn = n % p\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tres = (res * 2) %\
    \ p\n\t\tend\n\t\tn = n // 2\n\tend\n\treturn res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9v6smpos.lua:27:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmp9v6smpos.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal x = 1\n\t\
    for _ = 1, n do\n\t\tx = mod(x * 2, p)\n\tend\n\treturn x\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4h6ga97c.lua:15:\
    \ attempt to call a nil value (global 'mod')\nstack traceback:\n\t/tmp/tmp4h6ga97c.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmp4h6ga97c.lua:23: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local x = 1\n\
    \    local c = 1\n    while n > 0 do\n        if n % 2 == 1 then\n           \
    \ x = (x * c) % p\n        end\n        c = (c * c) % p\n        n = math.floor(n\
    \ / 2)\n    end\n    return x\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbf4aq4ej.lua:28:\
    \ expected: 3, actual: 1\nstack traceback:\n\t/tmp/tmpbf4aq4ej.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local acc = 1\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmprxs__eg5.lua:27: 'end' expected (to close 'function' at line\
    \ 12) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  -- Sometimes the\
    \ result is larger than p and modp will be called again\n  -- to get the final\
    \ result. In this case we don't want to call modp again.\n  if n == p then\n \
    \   return 0\n  end\n  local r = 0\n  -- Lua 5.3 only\n  for i = 1, log2(n) +\
    \ 1 do\n    r = (2 * r) % p\n    -- The following check is the same as the bitwise\
    \ check\n    -- `(n >> i - 1) & 1 == 1` in C.\n    if math.floor(n / (2 ^ (i -\
    \ 1))) % 2 == 1 then\n      r = (r + 1) % p\n    end\n  end\n  return r\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpm9sg9u18.lua:20:\
    \ attempt to call a nil value (global 'log2')\nstack traceback:\n\t/tmp/tmpm9sg9u18.lua:20:\
    \ in local 'candidate'\n\t/tmp/tmpm9sg9u18.lua:34: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  if n % 2 == 0 then\n    return modp(n / 2, p) ^ 2 % p\n  else\n\
    \    return 2 * modp(n - 1, p) % p\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tif p == 2 then\n\
    \t\treturn 1\n\tend\n\tlocal r = n % p\n\tif n < 0 then\n\t\tr = r + p\n\tend\n\
    \treturn r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvps7teff.lua:27:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmpvps7teff.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local k = n %\
    \ p\n  if k < 0 then\n    k = k + p\n  end\n  return k\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpes4qy2et.lua:24:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmpes4qy2et.lua:24: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n < p then\n\
    \    return n\n  end\n  local a = modp(math.floor(n / 2), p)\n  a = (a * a) %\
    \ p\n  if math.fmod(n, 2) == 1 then\n    a = (a * 2) % p\n  end\n  return a\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz7tmr7n3.lua:28:\
    \ expected: 2, actual: 10\nstack traceback:\n\t/tmp/tmpz7tmr7n3.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n == 1 then\n        return 2\n    elseif n == 2\
    \ then\n        return 4\n    elseif n == 3 then\n        return (4 * 2) % p\n\
    \    elseif n == 4 then\n        return (4 * 4) % p\n    elseif n == 5 then\n\
    \        return (4 * 4 * 2) % p\n    elseif n == 6 then\n        return (4 * 4\
    \ * 4) % p\n    elseif n == 7 then\n        return (4 * 4 * 4 * 2) % p\n    elseif\
    \ n == 8 then\n        return (4 * 4 * 4 * 4) % p\n    elseif n == 9 then\n  \
    \      return (4 * 4 * 4 * 4 * 2) % p\n    elseif n == 10 then\n        return\
    \ (4 * 4 * 4 * 4 * 4) % p\n    elseif n == 11 then\n        return (4 * 4 * 4\
    \ * 4 * 4 * 2) % p\n    elseif n == 12 then\n        return (4 * 4 * 4 * 4 * 4\
    \ * 4) % p\n    elseif n == 13 then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 2)\
    \ % p\n    elseif n == 14 then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 4) % p\n\
    \    elseif n == 15 then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 4 * 2) % p\n\
    \    elseif n == 16 then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 4 * 4) % p\n\
    \    elseif n == 17 then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 2) %\
    \ p\n    elseif n == 18 then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 *\
    \ 4) % p\n    elseif n == 19 then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 4 *\
    \ 4 * 4 * 2) % p\n    elseif n == 20 then\n        return (4 * 4 * 4 * 4 * 4 *\
    \ 4 * 4 * 4 * 4 * 4) % p\n    elseif n == 21 then\n\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmprcsp2m__.lua:70: 'end' expected (to close 'if' at line 13)\
    \ near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\treturn n%p\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz398y2oh.lua:20:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmpz398y2oh.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    return math.pow(2,\
    \ n) % p\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmk6rqiea.lua:20:\
    \ expected: 2, actual: #NaN\nstack traceback:\n\t/tmp/tmpmk6rqiea.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    assert(n >=\
    \ 0 and n <= p)\n    local res = 1\n    while n > 0 do\n        if n % 2 == 1\
    \ then\n            res = (res * 2) % p\n        end\n        n = math.floor(n\
    \ / 2)\n    end\n    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6hxrz66p.lua:27:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmp6hxrz66p.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local result =\
    \ 1\n  local x = 2\n  while n > 0 do\n    if n % 2 == 1 then\n      result = (result\
    \ * x) % p\n    end\n    n = math.floor(n / 2)\n    x = (x * x) % p\n  end\n \
    \ return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal p = tfmdata.parameters.moduli[p]\n\
    \tif not p then\n\t\terror(\"modulus \" .. p .. \" is not supported.\")\n\tend\n\
    \tif n == 0 then\n\t\treturn 1\n\telseif n == 1 then\n\t\treturn 0\n\telseif n\
    \ == 2 then\n\t\treturn p\n\telse\n\t\tlocal g\n\t\t-- Use truncation by default.\
    \ If a font explicitly sets the\n\t\t-- variant, we use a potentially slower method,\
    \ but with more\n\t\t-- reliable numerics.\n\t\tif tfmdata.parameters.variant\
    \ == 0 then\n\t\t\tg = n % p\n\t\telse\n\t\t\tg = tonumber(tostring(n):match(\"\
    ^0*(.-)$\"))\n\t\t\tg = g % p\n\t\tend\n\t\tif g == 0 then\n\t\t\treturn 1\n\t\
    \telse\n\t\t\treturn g\n\t\tend\n\tend\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpli537ibz.lua:13:\
    \ attempt to index a nil value (global 'tfmdata')\nstack traceback:\n\t/tmp/tmpli537ibz.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpli537ibz.lua:45: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  -- TODO: Implement\
    \ this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgkcg6hqx.lua:19:\
    \ expected: 3, actual: nil\nstack traceback:\n\t/tmp/tmpgkcg6hqx.lua:19: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    assert(n >=\
    \ 0 and p > 1, \"argument must be non-negative integer and prime\")\n    return\
    \ n == 0 and 1 or n % p * modp(math.floor(n / p), p) % p\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0l7yfxec.lua:21:\
    \ expected: 2, actual: 1\nstack traceback:\n\t/tmp/tmp0l7yfxec.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local result\
    \ = 1\n    for _=1,n do\n        result = result * 2 % p\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal t, r = {},\
    \ 1\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tr = mulmod(r, t[1] or 2,\
    \ p)\n\t\t\ttable.insert(t, 2)\n\t\telse\n\t\t\ttable.insert(t, 1)\n\t\tend\n\t\
    \tn = n // 2\n\tend\n\tfor i = #t, 1, -1 do\n\t\tt[i] = mulmod(t[i], t[i], p)\n\
    \tend\n\treturn r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpk7ndg_ez.lua:16:\
    \ attempt to call a nil value (global 'mulmod')\nstack traceback:\n\t/tmp/tmpk7ndg_ez.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpk7ndg_ez.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n < 1 then\n\
    \        return 1\n    end\n    local mod = math.mod\n    local mod_one = mod(n,\
    \ p)\n    local mod_two = mod(mod_one * mod_one, p)\n    if n % 2 == 0 then\n\
    \        return mod_two\n    else\n        return mod(mod_two * mod_one, p)\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpxm9_99t3.lua:17:\
    \ attempt to call a nil value (local 'mod')\nstack traceback:\n\t/tmp/tmpxm9_99t3.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmpxm9_99t3.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  if n == 1 then return n end\n  local l = floor(n / 2)\n  local\
    \ m = modp(l, p)\n  if n % 2 == 0 then\n    return (m * m) % p\n  else\n    return\
    \ (m * m * 2) % p\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_7zcv63q.lua:15:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmp_7zcv63q.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmp_7zcv63q.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    -- Since we\
    \ are working modulo p and p is prime, we only need to work\n    -- modulo a factor\
    \ of p-1.\n    --\n    -- Let p-1 = k*2^m+1 (that is, the factor of p-1 is a power\
    \ of 2).\n    -- Then p^n = 1 (mod p) if and only if p^(k*2^m*(n div k)) = 1 (mod\
    \ p)\n    -- if and only if p^(2^m*(n div k)) = 1 (mod p)\n    -- if and only\
    \ if (p^(2^(m-1))^2)^(n div k) = 1 (mod p)\n    -- if and only if ((p^(2^(m-1)))^2)^(n\
    \ div k) = 1 (mod p)\n    --\n    -- So we can just repeatedly square, and then\
    \ take the n div k'th power,\n    -- and then take that modulo p.\n    local k\
    \ = p - 1\n    local factor = k\n    local m = 0\n    while (factor % 2) == 0\
    \ do\n        factor = math.floor(factor / 2)\n        m = m + 1\n    end\n  \
    \  local r = p\n    while r > 2 do\n        if (r % 2) == 0 then\n           \
    \ r = (r * r) % p\n        else\n            r = (r * r * p) % p\n        end\n\
    \    end\n    -- Now r is p^(2^(m-1)) mod p\n    for i = 1, (n // k) do\n    \
    \    r = (r * r) % p\n    end\n    return r\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpn3pgb9on.lua:49:\
    \ expected: 3, actual: 0\nstack traceback:\n\t/tmp/tmpn3pgb9on.lua:49: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local res =\
    \ 1\n    while n > 0 do\n        if n % 2 == 1 then\n            res = (res *\
    \ 2) % p\n        end\n        n = math.floor(n / 2)\n    end\n    return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp83zn09go.lua:26:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmp83zn09go.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tif n < p then\n\
    \t\treturn n\n\tend\n\tlocal c = math.floor(n / p)\n\treturn n - c * p\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp20vbkfoe.lua:24:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmp20vbkfoe.lua:24: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  if n == 1 then return 2 end\n  local k = math.floor(n/2)\n \
    \ local b = 2*modp(k, p)\n  if b >= p then b = b - p end\n  if n % 2 == 0 then\
    \ return b\n  else return 2*b end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph9jjsgzz.lua:25:\
    \ expected: 3, actual: 8\nstack traceback:\n\t/tmp/tmph9jjsgzz.lua:25: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if p == 2 then\n\
    \    return 1\n  end\n  local s = 1\n  for i = 1, n do\n    s = s * 2\n    if\
    \ s >= p then\n      s = s - p\n    end\n  end\n  return s\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  while n > 0 do\n    if n % 2 == 1 then\n      res = (res * a) % p\n    end\n\
    \    a = (a * a) % p\n    n = math.floor(n / 2)\n  end\n  return res\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmppxy53gc2.lua:16:\
    \ attempt to perform arithmetic on a nil value (global 'a')\nstack traceback:\n\
    \t/tmp/tmppxy53gc2.lua:16: in local 'candidate'\n\t/tmp/tmppxy53gc2.lua:27: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local modn =\
    \ n % p\n    if modn == 0 then\n        return 1\n    else\n        local mod2n\
    \ = 2^modn % p\n        return mod2n\n    end\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmtn7eiig.lua:26:\
    \ expected: 2, actual: 29\nstack traceback:\n\t/tmp/tmpmtn7eiig.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local r = 1\n\
    \    local d = 2\n    local modulus = p\n    local nn = n\n    if n == 0 then\n\
    \        return 1\n    end\n    while nn > 0 do\n        local q = nn % 2\n  \
    \      nn = (nn - q) / 2\n        if q == 1 then\n            r = (r * d) % modulus\n\
    \        end\n        d = (d * d) % modulus\n    end\n    return r\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n  \
    \  lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101, 101),\
    \ 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n % 2 == 0 then\n        return sqr(modp(n/2, p))\
    \ % p\n    else\n        return (modp(n-1, p) * n) % p\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmph_23h0jn.lua:16:\
    \ attempt to call a nil value (global 'sqr')\nstack traceback:\n\t/tmp/tmph_23h0jn.lua:16:\
    \ in upvalue 'modp'\n\t/tmp/tmph_23h0jn.lua:18: in local 'candidate'\n\t/tmp/tmph_23h0jn.lua:25:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  for i = 1, n do\n    res = (res * 2) % p\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local p2 = p*p\n\
    \  local p4 = p2*p2\n  local p8 = p4*p4\n  local p16 = p8*p8\n  local p32 = p16*p16\n\
    \  local p64 = p32*p32\n  local p128 = p64*p64\n  local p256 = p128*p128\n  local\
    \ p512 = p256*p256\n  local p1024 = p512*p512\n  local p2048 = p1024*p1024\n \
    \ local p4096 = p2048*p2048\n  local p8192 = p4096*p4096\n  local p16384 = p8192*p8192\n\
    \  local p32768 = p16384*p16384\n  local p65536 = p32768*p32768\n  local p131072\
    \ = p65536*p65536\n  local p262144 = p131072*p131072\n  local p524288 = p262144*p262144\n\
    \  local p1048576 = p524288*p524288\n  local p2097152 = p1048576*p1048576\n  local\
    \ p4194304 = p2097152*p2097152\n  local p8388608 = p4194304*p4194304\n  local\
    \ p16777216 = p8388608*p8388608\n  local p33554432 = p16777216*p16777216\n  local\
    \ p67108864 = p33554432*p33554432\n  local p134217728 = p67108864*p67108864\n\
    \  local p268435456 = p134217728*p134217728\n  local p536870912 = p268435456*p268435456\n\
    \  local p1073741824 = p536870912*p536870912\n  local p2147483648 = p1073741824*p1073741824\n\
    \  local p4294967296 = p2147483648*p2147483648\n  local p8589934592 = p4294967296*p4294967296\n\
    \  local p17179869184\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp70indtd1.lua:60: 'end' expected (to close 'function' at line\
    \ 12) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local w, x = 1,\
    \ 1\n  local bit, lshift, and = bit32.bnot, bit32.lshift, bit32.band\n  local\
    \ y, z = p, p\n  n = n % p\n  if n == 0 then return 1 end\n  while n ~= 0 do\n\
    \    while bit(and(n, z)) == 0 do\n      x = (x * w) % p\n      z = bit(lshift(z,\
    \ 1))\n    end\n    w = (w * w) % p\n    z = bit(lshift(z, 1))\n    y = (y * y)\
    \ % p\n    n = bit(and(n, z))\n  end\n  return x\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpa88y3tlv.lua:14: <name> expected near 'and'\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  -- Some numerics\
    \ are so bad that this is needed (p is a prime).\n  if n == 0 then return 1 end\n\
    \  local a = 1\n  local b = 2\n  while n > 0 do\n    if n % 2 == 1 then\n    \
    \  a = a * b % p\n    end\n    b = b * b % p\n    n = n / 2\n  end\n  return a\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb45ebxdv.lua:30:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpb45ebxdv.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    assert(p > 1,\
    \ \"invalid p\")\n    if n == 0 then\n        return 1\n    elseif n == 1 then\n\
    \        return n\n    elseif p > 2^30 then\n        return 0 -- numerics\n  \
    \  else\n        local m = modp(n // 2, p)\n        if n % 2 == 0 then\n     \
    \       return (m * m) % p\n        else\n            return (m * m * 2) % p\n\
    \        end\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6gxzzdxo.lua:33:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmp6gxzzdxo.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    -- Implementation\
    \ follows \"Modular Binary Exponentiation\" in the Wikipedia.\n    -- See also:\
    \ http://stackoverflow.com/questions/1221833/\n    --           http://en.wikipedia.org/wiki/Modular_exponentiation#Memory-efficient_method\n\
    \    local b = 1\n    while n > 0 do\n        if n % 2 == 1 then\n           \
    \ b = (b * 2) % p\n        end\n        n = n // 2\n    end\n    return b\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_zoijtbc.lua:29:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmp_zoijtbc.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if p == 2 then\n\
    \        return n % 2 == 0 and 2 or 1\n    end\n    local modulus = p - 1\n  \
    \  local m = n\n    local result = 1\n    while m > 0 do\n        -- print(m,\
    \ modulus, result)\n        if m % 2 == 1 then\n            result = (result *\
    \ modulus) % p\n        end\n        modulus = (modulus * modulus) % p\n     \
    \   m = math.floor(m / 2)\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9x20kw2t.lua:33:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmp9x20kw2t.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  -- check for small\
    \ values\n  if p < 3 then\n    if p == 0 then\n      return 0\n    elseif p ==\
    \ 1 then\n      return 1\n    elseif p == 2 then\n      return n % 2\n    end\n\
    \  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp7gj6xko_.lua:36: 'end' expected (to close 'function' at line\
    \ 12) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local m = 1\n\
    \    for i = 1, n do\n        m = (m * 2) % p\n    end\n    return m\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local r = 1\n\
    \    while n > 0 do\n        if n % 2 == 1 then\n            r = (r * 2) % p\n\
    \        end\n        n = floor(n / 2)\n    end\n    return r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpe6s4825y.lua:18:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmpe6s4825y.lua:18:\
    \ in local 'candidate'\n\t/tmp/tmpe6s4825y.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal base = n\
    \ % p\n\tlocal result = base\n\tfor i = 1, n-1 do\n\t\tresult = (result * base)\
    \ % p\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprj6ri3z1.lua:24:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmprj6ri3z1.lua:24: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if p == 1 then\n\
    \        return 0\n    end\n    local s = 2\n    while 2^s < p do\n        s =\
    \ s + 1\n    end\n    local a = tostring(n)\n    local N = #a\n    local bs =\
    \ {}\n    for i = N, 1, -1 do\n        table.insert(bs, a:sub(i, i))\n    end\n\
    \    local t = {}\n    t[1] = 1\n    for i = 2, s do\n        t[i] = (t[i - 1]\
    \ * t[i - 1]) % p\n    end\n    local r = 0\n    for i = 1, N do\n        r =\
    \ (r * 2) % p\n        if bs[i] == \"1\" then\n            r = (r + 1) % p\n \
    \       end\n    end\n    local f = 0\n    for i = N + 1, s do\n        f = (f\
    \ * 2) % p\n    end\n    local v = r\n    for i = s, 1, -1 do\n        if n >=\
    \ f then\n            n = n - f\n            v = (v * t[i]) % p\n        end\n\
    \        f = math.floor(f / 2)\n    end\n    return v\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpo4kx4a8t.lua:56:\
    \ expected: 3, actual: 0\nstack traceback:\n\t/tmp/tmpo4kx4a8t.lua:56: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local x = 1\n\
    \    while n > 0 do\n        if n % 2 == 1 then\n            x = (x * 2) % p\n\
    \        end\n        n = floor(n / 2)\n    end\n    return x\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpxzmrkb98.lua:18:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmpxzmrkb98.lua:18:\
    \ in local 'candidate'\n\t/tmp/tmpxzmrkb98.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  local res = 1\n  local y = 2\n  n = n % (p - 1)\n  while n >\
    \ 0 do\n    if n % 2 == 1 then\n      res = (res * y) % p\n    end\n    y = (y\
    \ * y) % p\n    n = floor(n / 2)\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmptrjfw4g6.lua:22:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmptrjfw4g6.lua:22:\
    \ in local 'candidate'\n\t/tmp/tmptrjfw4g6.lua:30: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local t = 1\n\
    \  for i = 1, n do\n    t = (t * 2) % p\n  end\n  return t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\n\
    \    return 1\n  elseif n == 1 then\n    return 0\n  elseif n % 2 == 0 then\n\
    \    return modp(n / 2, p) ^ 2 % p\n  else\n    return 2 * modp(n - 1, p) % p\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl3ty00ok.lua:27:\
    \ expected: 3, actual: 0\nstack traceback:\n\t/tmp/tmpl3ty00ok.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local n1 = 1;\n\
    \  local n2 = 0;\n  local p1 = 0;\n  local p2 = 1;\n  local q = math.floor(n /\
    \ p);\n  local r = n % p;\n  while r ~= 0 do\n    n = p;\n    p = r;\n    q =\
    \ math.floor(n / p);\n    r = n % p;\n    local tmp = n1 - q * p1;\n    n1 = p1;\n\
    \    p1 = tmp;\n    tmp = n2 - q * p2;\n    n2 = p2;\n    p2 = tmp;\n  end\n \
    \ if p2 < 0 then\n    p2 = p2 + n;\n  end\n  return p2;\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoookkcgc.lua:40:\
    \ expected: 3, actual: -3\nstack traceback:\n\t/tmp/tmpoookkcgc.lua:40: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  assert(n and p)\n\
    \  local r = 1\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpothkr6ug.lua:28: 'end' expected (to close 'function' at line\
    \ 12) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local x = 1\n\
    \    for i = 1, n do\n        x = (x * 2) % p\n    end\n    return x\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  assert(n >= 0\
    \ and p > 0, 'modp only works for n>=0 and p>0')\n  -- see if we can reduce n\
    \ first\n  if p == 1 then return 0 end\n  if n == 0 then return 1 end\n  -- it's\
    \ actually faster to do it this way, even if we don't\n  -- use the result of\
    \ modp(a, p)\n  local x = 1\n  for _ = 0, 31 do\n    if n % 2 == 1 then\n    \
    \  x = (x * 2) % p\n    end\n    n = math.floor(n / 2)\n    if n == 0 then break\
    \ end\n  end\n  return x\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2_5wwrgs.lua:33:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmp2_5wwrgs.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if p == 2 then\n\
    \    return 1\n  end\n  local q = p\n  local m = 1\n  while n > 0 do\n    if n\
    \ % 2 == 1 then\n      m = (m * q) % p\n    end\n    q = (q * q) % p\n    n =\
    \ math.floor(n / 2)\n  end\n  return m\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptbswrwsd.lua:31:\
    \ expected: 3, actual: 0\nstack traceback:\n\t/tmp/tmptbswrwsd.lua:31: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal result =\
    \ 1\n\tlocal b = n % (p - 1)\n\twhile b > 0 do\n\t\tresult = (result * 2) % p\n\
    \t\tb = b - 1\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if p == 2 then\n\
    \        return 1\n    end\n    local res = 1\n    n = n % p\n    while n > 0\
    \ do\n        if n % 2 == 1 then\n            res = (res * n) % p\n        end\n\
    \        n = math.floor(n / 2)\n        n = (n * n) % p\n    end\n    return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal result =\
    \ 1\n\tlocal factor = 2\n\tlocal remainder = n\n\twhile remainder > 0 do\n\t\t\
    local x = floor(remainder / 2)\n\t\tlocal y = remainder - 2 * x\n\t\tremainder\
    \ = x\n\t\tif y == 1 then\n\t\t\tresult = (result * factor) % p\n\t\tend\n\t\t\
    factor = (factor * factor) % p\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4mdnoh2_.lua:17:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmp4mdnoh2_.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmp4mdnoh2_.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    -- O(n)\n  \
    \  local b = 1\n    local nn = n\n    while nn > 0 do\n        if nn % 2 == 1\
    \ then\n            b = b * n % p\n        end\n        nn = math.floor(nn / 2)\n\
    \        n = n * n % p\n    end\n    return b\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwc8hsvyz.lua:29:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpwc8hsvyz.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  while n > 0 do\n    if n % 2 == 1 then\n      res = (res * 2) % p\n    end\n\
    \    n = math.floor(n / 2)\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpg_ome899.lua:26:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmpg_ome899.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local l, r = math.floor(n/2),\
    \ math.fmod(n, 2)\n  if l == 0 then return r\n  else return (2 * modp(l, p) +\
    \ r) % p\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp04h9ypwu.lua:23:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmp04h9ypwu.lua:23: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n % 2 == 0 then\n        return ((modp(n / 2, p)\
    \ % p) * (modp(n / 2, p) % p)) % p\n    else\n        return ((modp(n / 2, p)\
    \ % p) * (modp(n / 2, p) % p) * 2) % p\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n == 1 then\n        return 0\n    elseif n % 2\
    \ == 0 then\n        local x = modp(n / 2, p)\n        return (2 * x * x) % p\n\
    \    else\n        return (2 * modp(n - 1, p)) % p\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvm479a27.lua:28:\
    \ expected: 3, actual: 0\nstack traceback:\n\t/tmp/tmpvm479a27.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local x = 1\n\
    \    for i = 1, n do\n        x = (x * 2) % p\n    end\n    return x\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  local b = n\n  while b > 0 do\n    if bit.band(b, 1) == 1 then\n      res =\
    \ (res * n) % p\n    end\n    n = (n * n) % p\n    b = bit.rshift(b, 1)\n  end\n\
    \  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgvj23p41.lua:16:\
    \ attempt to index a nil value (global 'bit')\nstack traceback:\n\t/tmp/tmpgvj23p41.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpgvj23p41.lua:28: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal r = 1\n\t\
    while n > 0 do\n\t\tif n % 2 ~= 0 then\n\t\t\tr = (r * 2) % p\n\t\tend\n\t\tn\
    \ = math.floor(n / 2)\n\tend\n\treturn r\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0838plid.lua:26:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmp0838plid.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\t-- Consider the\
    \ binary expansion of n:\n\t-- n = sum(b_i 2^i)\n\t--\n\t-- Then,\n\t-- 2^n mod\
    \ p = prod(2^(b_i 2^i) mod p)\n\t--           = prod(2^(2^i)^b_i mod p)\n\t--\
    \           = prod(2^(2^i) mod p)^b_i\n\tlocal function pow2(k)\n\t\treturn (2^k\
    \ % p)^2\n\tend\n\tlocal function helper(k)\n\t\tlocal pk = pow2(k)\n\t\tif n\
    \ % (2^k) == 0 then\n\t\t\treturn helper(k+1)\n\t\telse\n\t\t\treturn (pk * modp(n\
    \ % (2^k), p)) % p\n\t\tend\n\tend\n\treturn (n == 0) and 1 or helper(1)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpre4mhf6r.lua:28:\
    \ stack overflow\nstack traceback:\n\t/tmp/tmpre4mhf6r.lua:28: in local 'helper'\n\
    \t/tmp/tmpre4mhf6r.lua:31: in upvalue 'modp'\n\t/tmp/tmpre4mhf6r.lua:28: in local\
    \ 'helper'\n\t/tmp/tmpre4mhf6r.lua:31: in upvalue 'modp'\n\t/tmp/tmpre4mhf6r.lua:28:\
    \ in local 'helper'\n\t/tmp/tmpre4mhf6r.lua:31: in upvalue 'modp'\n\t/tmp/tmpre4mhf6r.lua:28:\
    \ in local 'helper'\n\t/tmp/tmpre4mhf6r.lua:31: in upvalue 'modp'\n\t/tmp/tmpre4mhf6r.lua:28:\
    \ in local 'helper'\n\t...\n\t/tmp/tmpre4mhf6r.lua:31: in local 'candidate'\n\t\
    /tmp/tmpre4mhf6r.lua:37: in function 'test_humaneval'\n\nRan 1 tests in 0.460\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n < p then\n\
    \    return n\n  end\n  local rem = n % p\n  return rem == 0 and p or rem\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyxwh7rtz.lua:24:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmpyxwh7rtz.lua:24: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local a = 1;\n\
    \    while n > 0 do\n        if n % 2 == 1 then\n            a = (a * 2) % p;\n\
    \        end\n        n = math.floor(n / 2);\n    end\n    return a;\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp58gsc8dc.lua:26:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmp58gsc8dc.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local result\
    \ = 1\n    local c = n % p\n    while c > 0 do\n        if bit.band(c, 1) == 1\
    \ then\n            result = (result * 2) % p\n        end\n        c = bit.rshift(c,\
    \ 1)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbq47iyed.lua:16:\
    \ attempt to index a nil value (global 'bit')\nstack traceback:\n\t/tmp/tmpbq47iyed.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpbq47iyed.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local result =\
    \ 1\n  while n > 0 do\n    if n % 2 == 1 then\n      result = (result * 2) % p\n\
    \    end\n    n = math.floor(n / 2)\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprq6_56x9.lua:26:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmprq6_56x9.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local result =\
    \ 1\n  local x = n % p\n  while n > 0 do\n    if n % 2 == 1 then\n      result\
    \ = (result * x) % p\n    end\n    n = math.floor(n / 2)\n    x = (x * x) % p\n\
    \  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqfbd6qzt.lua:28:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpqfbd6qzt.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n % 2 == 0 then\n        local y = modp(n / 2, p)\n\
    \        return (y * y) % p\n    else\n        return (modp(n - 1, p) * 2) % p\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  n = n % p\n  while n > 0 do\n    if n % 2 == 1 then\n      res = (res * 2)\
    \ % p\n    end\n    n = math.floor(n / 2)\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppqsxbh68.lua:27:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmppqsxbh68.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local b = 1\n\
    \    while (n > 0) do\n        if n % 2 == 1 then\n            b = (b * 2) % p\n\
    \        end\n        n = n // 2\n    end\n    return b\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdiiemana.lua:26:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmpdiiemana.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local r = 1\n\
    \  local d = 2\n  while n > 0 do\n    if n % 2 == 1 then\n      r = (r * d) %\
    \ p\n    end\n    n = math.floor(n / 2)\n    d = (d * d) % p\n  end\n  return\
    \ r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    return tonumber(tostring(n)\
    \ % p)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp77xz5w3_.lua:20:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmp77xz5w3_.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local result =\
    \ 1\n  for i = 1, n do\n    result = (result * 2) % p\n  end\n  return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n % 2 == 0 then\n        return modp(n/2, p)^2 %\
    \ p\n    else\n        return modp(n-1, p) * 2 % p\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local res =\
    \ 1\n    local r = n % p\n    while n > 0 do\n        if n % 2 == 1 then\n   \
    \         res = (res * r) % p\n        end\n        n = math.floor(n / 2)\n  \
    \      r = (r * r) % p\n    end\n    return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3katbtp_.lua:28:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmp3katbtp_.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\treturn (n % p\
    \ + p) % p\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj043568l.lua:20:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmpj043568l.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    -- Given the\
    \ representation of a number as a list of digits,\n    -- we can compute b^n mod\
    \ p in O(n) multiplications, using O(n) space.\n    -- We exploit that b^(k*p)\
    \ mod p = b^k mod p if p is prime.\n    -- To avoid the factors of 2 and 5, we\
    \ shift left until we reach an odd number,\n    -- so that we can only use odd\
    \ number as factors.\n    -- Numbers with a lot of trailing zeros are avoided\
    \ by using the table `mods`\n    -- that helps to quickly eliminate trailing zeros.\n\
    \    local mods = {}\n    local function mods_calc(n)\n        n = n - n % 2\n\
    \        mods[n] = n\n        for i = n-2, n-p, -2 do\n            mods[i] = (i+2)\
    \ * mods[i+2]\n        end\n    end\n    mods_calc(n)\n    local function modp(n,\
    \ p)\n        if n == 0 then return 1 end\n        if n % 2 == 0 then\n      \
    \      return (2 * modp(n / 2, p)) % p\n        else\n            return (b *\
    \ modp(n - 1, p)) % p\n        end\n    end\n    return modp(n - n % p, p)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6l8eccbd.lua:43:\
    \ expected: 3, actual: 1\nstack traceback:\n\t/tmp/tmp6l8eccbd.lua:43: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local a = 1\n\
    \    local b = 2\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpis7u2y9e.lua:28: 'end' expected (to close 'function' at line\
    \ 12) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local exp =\
    \ p-2\n    local base = n % p\n    local res = 1\n    while exp > 0 do\n     \
    \   if exp % 2 == 1 then\n            res = (res * base) % p\n        end\n  \
    \      exp = math.floor(exp / 2)\n        base = (base * base) % p\n    end\n\
    \    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnj92azsr.lua:29:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpnj92azsr.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local d = 0\n\
    \  for i = n, 0, -1 do\n    d = (d * 2) % p\n  end\n  return d\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpv46p6e7k.lua:23:\
    \ expected: 3, actual: 0\nstack traceback:\n\t/tmp/tmpv46p6e7k.lua:23: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if (n < 0) then\
    \ return 0 end\n    local bit_string = to_binary(n)\n    local result = 1\n  \
    \  for i = 1, #bit_string do\n        result = (result * result) % p\n       \
    \ if (bit_string[i] == 1) then\n            result = (result * 2) % p\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8jqoq4gf.lua:14:\
    \ attempt to call a nil value (global 'to_binary')\nstack traceback:\n\t/tmp/tmp8jqoq4gf.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmp8jqoq4gf.lua:28: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local r = 1\n\
    \  local x = 2\n  while n > 0 do\n    if n % 2 == 1 then\n      r = r * x % p\n\
    \    end\n    x = x * x % p\n    n = math.floor(n / 2)\n  end\n  return r\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\t-- Using the approach\
    \ from the wikipedia article\n\t-- https://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method\n\
    \t-- which is the same as the one taught in university (implemented in C in\n\t\
    -- the section above).\n\tlocal ret = 1\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\
    \t\t\tret = (ret * 2) % p\n\t\tend\n\t\tn = math.floor(n / 2)\n\tend\n\treturn\
    \ ret\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppphj3v6k.lua:30:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmppphj3v6k.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  assert(p >= 2)\n\
    \  if n < 0 then\n    n = n % p + p\n  end\n  while n >= p do\n    n = n % p\n\
    \  end\n  return n\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpca6_4itw.lua:27:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmpca6_4itw.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local function\
    \ sq(n)\n        local sq, r = math.floor(math.sqrt(n))\n        if sq * sq ==\
    \ n then\n            return sq\n        else\n            return nil\n      \
    \  end\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpf7gev80h.lua:34: 'end' expected (to close 'function' at line\
    \ 12) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if p == 2 then\n\
    \    return 1\n  end\n  local result = 1\n  while n > 0 do\n    if n % 2 == 1\
    \ then\n      result = (result * 2) % p\n    end\n    n = math.floor(n / 2)\n\
    \  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpalzmwk9l.lua:29:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmpalzmwk9l.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  local b = 2\n  while n > 0 do\n    if (n % 2) ~= 0 then\n      res = (res *\
    \ b) % p\n    end\n    n = math.floor(n / 2)\n    b = (b * b) % p\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal one = 1\n\
    \twhile n >= p do\n\t\tif n % 2 == 1 then\n\t\t\tone = (one * 2) % p\n\t\tend\n\
    \t\tn = n / 2\n\tend\n\tone = (one * n) % p\n\treturn one\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp54r19t06.lua:28:\
    \ expected: 2, actual: 36.625\nstack traceback:\n\t/tmp/tmp54r19t06.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tif n == 0 then\n\
    \t\treturn 1\n\telseif n % 2 == 0 then\n\t\treturn (modp(n/2, p)^2) % p\n\telse\n\
    \t\treturn (2 * modp(n - 1, p)) % p\n\tend\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local x = 1\n\
    \    for i = 1, n do\n        x = x * 2 % p\n    end\n    return x\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n  \
    \  lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101, 101),\
    \ 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal r = 1\n\t\
    for bit in tobinary(n) do\n\t\tr = (r * r) % p\n\t\tif bit == 1 then\n\t\t\tr\
    \ = (r * 2) % p\n\t\tend\n\tend\n\treturn r\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpnwsx8sqy.lua:14:\
    \ attempt to call a nil value (global 'tobinary')\nstack traceback:\n\t/tmp/tmpnwsx8sqy.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmpnwsx8sqy.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n == 1 then\n        return 2\n    elseif n == 2\
    \ then\n        return 4\n    elseif n == 3 then\n        return 8\n    elseif\
    \ n == 4 then\n        return 16\n    elseif n == 5 then\n        return 32\n\
    \    elseif n == 6 then\n        return 64\n    elseif n == 7 then\n        return\
    \ 128\n    elseif n == 8 then\n        return 27\n    elseif n == 9 then\n   \
    \     return 54\n    elseif n == 10 then\n        return 108\n    elseif n ==\
    \ 11 then\n        return 216\n    elseif n == 12 then\n        return 89\n  \
    \  elseif n == 13 then\n        return 179\n    elseif n == 14 then\n        return\
    \ 89\n    elseif n == 15 then\n        return 179\n    elseif n == 16 then\n \
    \       return 89\n    elseif n == 17 then\n        return 179\n    elseif n ==\
    \ 18 then\n        return 89\n    elseif n == 19 then\n        return 179\n  \
    \  elseif n == 20 then\n        return 89\n    elseif n == 21 then\n        return\
    \ 179\n    elseif n == 22 then\n        return 89\n    elseif n == 23 then\n \
    \       return 179\n    elseif n == 24 then\n        return 89\n    elseif n ==\
    \ 25 then\n        return 179\n    elseif n == 26 then\n        return 89\n  \
    \  elseif n == 27 then\n        return 179\n    elseif n == 28 then\n        return\
    \ 89\n    elseif n == 29 then\n        return 179\n    elseif n == 30 then\n \
    \       return 89\n    elseif n == 31 then\n        return 179\n    elseif n ==\
    \ 32 then\n        return 89\n    elseif n == 33 then\n        return 179\n  \
    \  elseif n == 34 then\n        return 89\n    elseif n == 35 then\n        return\
    \ 179\n    elseif n == 36 then\n        return 89\n    elseif n == 37 then\n \
    \       return 179\n    elseif n == 38 then\n        return 89\n    elseif n ==\
    \ 39 then\n        return 179\n    elseif n == 40 then\n        return 89\n  \
    \  elseif n == 41 then\n        return 179\n    elseif n == 42 then\n\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpl65h9560.lua:112: 'end' expected (to close 'if' at line 13)\
    \ near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tlocal result =\
    \ 1\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmphywtye2e.lua:27: 'end' expected (to close 'function' at line\
    \ 12) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local r = 1\n\
    \    while n ~= 0 do\n        if n % 2 == 1 then\n            r = r * 2 % p\n\
    \        end\n        n = math.floor(n / 2)\n    end\n    return r\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n  \
    \  lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101, 101),\
    \ 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpksuw4t0z.lua:26:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmpksuw4t0z.lua:26: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tif p == 1 then\n\
    \t\treturn 0\n\tend\n\tlocal r = 1\n\tlocal d = n\n\twhile d > 0 do\n\t\tlocal\
    \ q = d // 2\n\t\tlocal k = d - 2 * q\n\t\tif k > 0 then\n\t\t\tr = (r * n) %\
    \ p\n\t\tend\n\t\tn = (n * n) % p\n\t\td = q\n\tend\n\treturn r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpaoalkcjg.lua:33:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpaoalkcjg.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local np = n %\
    \ p\n  if np < 0 then\n    np = np + p\n  end\n  return np\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp783t2o4o.lua:24:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmp783t2o4o.lua:24: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if p == 1 then\
    \ return 0 end\n  return (n % p + p) % p\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3, 5),\
    \ 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt_f3vv8z.lua:21:\
    \ expected: 2, actual: 91\nstack traceback:\n\t/tmp/tmpt_f3vv8z.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local res = 1\n\
    \  local a = 2 % p\n  while n > 0 do\n    if n % 2 == 1 then\n      res = (res\
    \ * a) % p\n    end\n    n = math.floor(n / 2)\n    a = (a * a) % p\n  end\n \
    \ return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  local t = modp(math.floor(n/2), p)\n  t = (t*t) % p\n  if n\
    \ % 2 == 1 then\n    t = (t*2) % p\n  end\n  return t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n < p then\n\
    \    return n\n  end\n  local r = 0\n  local d = 1\n  while n > 0 do\n    r =\
    \ r + (n % 2) * d\n    n = math.floor(n / 2)\n    d = d * 2\n  end\n  return r\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsexlteiv.lua:30:\
    \ expected: 2, actual: 1101\nstack traceback:\n\t/tmp/tmpsexlteiv.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n < 0 then\
    \ n = n % p + p end\n  return bm.mod(2^n, p)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmps_ofwk1n.lua:14:\
    \ attempt to index a nil value (global 'bm')\nstack traceback:\n\t/tmp/tmps_ofwk1n.lua:14:\
    \ in local 'candidate'\n\t/tmp/tmps_ofwk1n.lua:20: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local x = 1\n\
    \    local pow = n\n    while pow > 0 do\n        if pow % 2 ~= 0 then\n     \
    \       x = (x * n) % p\n        end\n        n = (n * n) % p\n        pow = pow\
    \ // 2\n    end\n    return x\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbjm7dunz.lua:28:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpbjm7dunz.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    -- TODO: handle\
    \ n > p\n    if n == 0 then\n        return 1\n    elseif n % 2 == 0 then\n  \
    \      return (modp(n / 2, p) ^ 2) % p\n    else\n        return (modp(n - 1,\
    \ p) * 2) % p\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\t-- We only need\
    \ to work with absolute values.\n\tn = math.abs(n)\n\tp = math.abs(p)\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp53mnlof2.lua:29: 'end' expected (to close 'function' at line\
    \ 12) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  local res = modp(n/2, p)^2 % p\n  if n % 2 == 1 then res = res\
    \ * 2 % p end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvk9g31t1.lua:22:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpvk9g31t1.lua:22: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    assert(n >=\
    \ 0, \"modp: number must be non-negative\")\n    assert(p > 1, \"modp: base must\
    \ be greater than 1\")\n    local y = 1\n    local x = n\n    while x ~= 0 do\n\
    \        local r = x % 2\n        if r == 1 then\n            y = y * p\n    \
    \    end\n        p = p * p\n        x = x // 2\n    end\n    return y % modulus\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmptj_7_j9y.lua:25:\
    \ attempt to perform arithmetic on a nil value (global 'modulus')\nstack traceback:\n\
    \t/tmp/tmptj_7_j9y.lua:25: in local 'candidate'\n\t/tmp/tmptj_7_j9y.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  local r = 1\n\
    \  local x = 2 % p\n  local m = n\n  while m > 0 do\n    if m % 2 == 1 then\n\
    \      r = (r * x) % p\n    end\n    m = math.floor(m / 2)\n    x = (x * x) %\
    \ p\n  end\n  return r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n  if n == 0 then\
    \ return 1 end\n  if n == 1 then return 2 end\n  local acc = 1\n  local m = n\n\
    \  while m > 0 do\n    if m % 2 == 1 then\n      acc = (acc * 2) % p\n    end\n\
    \    m = m // 2\n    local r = 2 * 2 % p\n    if r ~= 4 then\n      return nil,\
    \ \"numerics! (p = \" .. p .. \")\"\n    end\n  end\n  return acc\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp830uyz3m.lua:33:\
    \ expected: 3, actual: 4\nstack traceback:\n\t/tmp/tmp830uyz3m.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local t = 1\n\
    \    local n = n % p\n    for i = 1, n do\n        t = (t * 2) % p\n    end\n\
    \    return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpx_zxwcir.lua:25:\
    \ expected: 2, actual: 29\nstack traceback:\n\t/tmp/tmpx_zxwcir.lua:25: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local r = 1\n\
    \    local b = n\n    while n > 0 do\n        local z = n % 2\n        if z ==\
    \ 1 then\n            r = (r * b) % p\n        end\n        n = math.floor(n /\
    \ 2)\n        b = (b * b) % p\n    end\n    return r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnopt71im.lua:29:\
    \ expected: 3, actual: 2\nstack traceback:\n\t/tmp/tmpnopt71im.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if (n == 0)\
    \ then\n        return 1\n    elseif (n % 2 == 0) then\n        return modp(n/2,\
    \ p)^2 % p\n    else\n        return modp(n-1, p) * modp(n+1, p) % p\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
    \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp15gvmc8g.lua:16:\
    \ stack overflow\nstack traceback:\n\t/tmp/tmp15gvmc8g.lua:16: in upvalue 'modp'\n\
    \t/tmp/tmp15gvmc8g.lua:18: in upvalue 'modp'\n\t/tmp/tmp15gvmc8g.lua:16: in upvalue\
    \ 'modp'\n\t/tmp/tmp15gvmc8g.lua:18: in upvalue 'modp'\n\t/tmp/tmp15gvmc8g.lua:16:\
    \ in upvalue 'modp'\n\t/tmp/tmp15gvmc8g.lua:18: in upvalue 'modp'\n\t/tmp/tmp15gvmc8g.lua:16:\
    \ in upvalue 'modp'\n\t/tmp/tmp15gvmc8g.lua:18: in upvalue 'modp'\n\t/tmp/tmp15gvmc8g.lua:16:\
    \ in upvalue 'modp'\n\t...\n\t/tmp/tmp15gvmc8g.lua:18: in local 'candidate'\n\t\
    /tmp/tmp15gvmc8g.lua:25: in function 'test_humaneval'\n\nRan 1 tests in 0.120\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n == 1 then\n        return 2\n    elseif n % 2\
    \ == 0 then\n        local m = modp(n / 2, p)\n        return (m * m) % p\n  \
    \  else\n        return (2 * modp(n - 1, p)) % p\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n\tif n < 0 then\n\
    \t\treturn modp(n + p, p)\n\tend\n\t\n\tif n == 0 then\n\t\treturn 1\n\tend\n\t\
    \n\tif math.floor(n / 2) * 2 == n then\n\t\treturn (modp(n / 2, p) ^ 2) % p\n\t\
    else\n\t\treturn (modp(n - 1, p) * 2) % p\n\tend\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = modp\n    lu.assertEquals(candidate(3,\
    \ 5), 3)\n    lu.assertEquals(candidate(1101, 101), 2)\n    lu.assertEquals(candidate(0,\
    \ 101), 1)\n    lu.assertEquals(candidate(3, 11), 8)\n    lu.assertEquals(candidate(100,\
    \ 101), 1)\n    lu.assertEquals(candidate(30, 5), 4)\n    lu.assertEquals(candidate(31,\
    \ 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    if n == 0 then\n\
    \        return 1\n    elseif n % 2 == 0 then\n        local h = modp(n/2, p)\n\
    \        return (h * h) % p\n    else\n        return (2 * modp(n-1, p)) % p\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n--\
    \ 3\n-- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n\
    -- 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n    local x = 1\n\
    \    local y = 1\n    while y ~= 0 do\n        local remain = math.fmod(n, 2)\n\
    \        if remain == 1 then\n            x = math.fmod(x * y, p)\n        end\n\
    \        y = math.fmod(y * y, p)\n        n = math.floor(n / 2)\n    end\n   \
    \ return x\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = modp\n    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101,\
    \ 101), 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
    \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
    \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
