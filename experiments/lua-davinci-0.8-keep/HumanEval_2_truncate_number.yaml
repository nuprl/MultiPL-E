name: HumanEval_2_truncate_number
language: lua
prompt: "-- Given a positive floating point number, it can be decomposed into\n--\
  \ and integer part (largest integer smaller than given number) and decimals\n--\
  \ (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
  -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
  \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
  \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local _, _, integer_part, decimal_part = string.find(\n       \
    \ tostring(number),\n        \"(%d+)%.(%d+)\"\n    )\n    return tonumber(decimal_part)\n\
    end", "  return math.abs(number - math.floor(number))\nend", "    return number\
    \ - math.floor(number)\nend", "    local integer, decimals = string.modf(number)\n\
    \    return decimals\nend", "  return number - math.floor(number)\nend", "   \
    \ return number - math.floor(number)\nend", "  return math.fmod(number, math.floor(number))\n\
    end", "    local decimals = number - math.floor(number)\n    return decimals\n\
    end", "    return math.abs(number - math.floor(number))\nend", "  if number >=\
    \ 0 then\n    return number - math.floor(number)\n  else\n    return number -\
    \ math.ceil(number)\n  end\nend", "    if type(number) ~= \"number\" then\n  \
    \      err(\"Expected number as argument, got %s\", type(number))\n    end\n \
    \   local num = math.floor(number)\n    return number - num\nend", "    return\
    \ number - math.floor(number)\nend", "  return number - math.floor(number)\nend",
  "    if number > 0 then\n        return number - math.floor(number)\n    else\n\
    \        return 0\n    end\nend", "  return number - math.floor(number)\nend",
  "    return number - math.floor(number)\nend", "  return number - math.floor(number)\n\
    end", "    local string_number = tostring(number)\n    local integer_part, decimal_part\
    \ = string_number:match('(%d+)%.(%d*)')\n    -- ensure number is rounded down\n\
    \    local integer_part = tonumber(integer_part)\n    local decimal_part = tonumber('0.'\
    \ .. decimal_part)\n    return decimal_part\nend", "    return number - math.floor(number)\n\
    end", "  return number - math.floor(number)\nend", "    local _, i = math.modf(number)\n\
    \    return i\nend", "    if number > 0 then\n        return number - math.floor(number)\n\
    \    else\n        return math.ceil(number) - number\n    end\nend", "  local\
    \ integer_part = math.floor(number)\n  return number - integer_part\nend", " \
    \ local integer_part = math.floor(number)\n  return number - integer_part\nend",
  "    local integer_part = math.floor(number)\n    return number - integer_part\n\
    end", "    local temp_number = number\n    local integer_part = math.floor(temp_number)\n\
    \    temp_number = temp_number - integer_part\n    return temp_number\nend", " \
    \   return number - math.floor(number)\nend", "  return number - math.floor(number)\n\
    end", "    return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "    local integer_part = math.floor(number)\n    return number - integer_part\n\
    end", "    local integer_part = math.floor(number)\n    return number - integer_part\n\
    end", "    if (number >= 0) then\n        return number - math.floor(number)\n\
    \    else\n        return number - math.ceil(number)\n    end\nend", "    return\
    \ number - math.floor(number)\nend", "    local ip, fp = math.modf(number)\n \
    \   return fp\nend", "    return number - math.floor(number)\nend", "    if number\
    \ < 0 then\n        error(\"Expected positive number.\")\n    end\n    local integer_part\
    \ = math.floor(number)\n    return number - integer_part\nend", "    return number\
    \ - math.floor(number)\nend", "    return number - math.floor(number)\nend", " \
    \   return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "    return number - math.floor(number)\nend", "    local ineg = number\
    \ < 0 and 1 or 0\n    local integer = math.floor(math.abs(number))\n    local\
    \ decimal = math.abs(number) - integer\n    return (ineg == 1 and -1 or 1) * decimal\n\
    end", "    local integer_part = math.floor(number)\n    return number - integer_part\n\
    end", "    return math.modf(number)\nend", "    return number - math.floor(number)\n\
    end", "  local rounded_number = floor(number)\n  return number - rounded_number\n\
    end", "  return number - math.floor(number)\nend", "\treturn number % 1\nend",
  "    local result = number % 1\n    return result\nend", "    return number - math.floor(number)\n\
    end", "    return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "\tlocal truncated_number, _ = math.modf(number)\n\treturn number - truncated_number\n\
    end", "  return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "    return number - math.floor(number)\nend", "  if number == math.floor(number)\
    \ then\n    return 0\n  else\n    return number - math.floor(number)\n  end\n\
    end", "  return math.floor(number + 0.5)\nend", "    local integer,decimal = math.modf(number)\n\
    \    return decimal\nend", "    return number - math.floor(number)\nend", "  \
    \  return number - math.floor(number)\nend", "    local integer, decimals = math.modf(number)\n\
    \    return decimals\nend", "    return number - math.floor(number)\nend", " \
    \   return math.modf(number)\nend", "  return math.fmod(number, 1)\nend", "  \
    \  local integer_part = math.floor(number)\n    return number - integer_part\n\
    end", "    local integer_part = math.floor(number)\n    return number - integer_part\n\
    end", "    return number - math.floor(number)\nend", "\tlocal _,decimal = math.modf(number)\n\
    \treturn decimal\nend", "  return number - math.floor(number)\nend", "  return\
    \ math.modf(number)\nend", "  return number - math.floor(number)\nend", "  return\
    \ number - math.floor(number)\nend", "    local sign = number > 0 and 1 or -1\n\
    \    return math.floor(math.abs(number)) * sign\nend", "  return number - math.floor(number)\n\
    end", "    local ipart,fpart = math.modf(number)\n    return fpart\nend", "  if\
    \ number >= 0 then\n    return number - math.floor(number)\n  else\n    return\
    \ number - math.ceil(number)\n  end\nend", "    local integer, decimal = math.modf(number)\n\
    \    return decimal\nend", "    return number - math.floor(number)\nend", "  return\
    \ math.fmod(number, 1)\nend", "    return math.modf(number)\nend", "    if number\
    \ >= 0 then\n        return math.modf(number)\n    else\n        local truncated\
    \ = math.modf(number)\n        return truncated - 1, 1 + (truncated - truncated)\n\
    \    end\nend", "    return number - math.floor(number)\nend", "    return math.fmod(number,\
    \ 1)\nend", "    return number - math.floor(number)\nend", "\treturn number -\
    \ math.floor(number)\nend", "    local integral, decimals = math.modf(number)\n\
    \    return decimals\nend", "    return math.fmod(number, 1)\nend", "    return\
    \ number - math.floor(number)\nend", "    local int_part = math.floor(number)\n\
    \    return number - int_part\nend", "    local _, decimals = math.modf(number)\n\
    \    return decimals\nend", "    return number - math.floor(number)\nend", " \
    \   local decimal, integer = math.modf(number)\n    return decimal\nend", "\t\
    local int, dec = math.modf(number)\n\treturn dec\nend", "    return number - math.floor(number)\n\
    end", "    local integral, decimal = math.modf(number)\n    return decimal\nend",
  "    return number - math.floor(number)\nend", "    local _, decimals = math.modf(number)\n\
    \    return decimals\nend", "    local integer, decimal = math.modf(number)\n\
    \    return decimal\nend", "    return number - math.floor(number)\nend", "  local\
    \ i, f = math.modf(number)\n  return f\nend", "    return number - math.floor(number)\n\
    end", "    return math.fmod(number, 1)\nend", "    if not is_float(number) then\n\
    \        fatal(\"truncate_number was passed a non-float value: %s\", number)\n\
    \    end\n    local ivalue = math.floor(number)\n    local decimal = number -\
    \ ivalue\n    return decimal\nend", "    if number < 0 then\n        number =\
    \ -number\n    end\n    local integer = math.floor(number)\n    return number\
    \ - integer\nend", "    if type(number) ~= \"number\" then\n        return 0\n\
    \    end\n    return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "    return number - math.floor(number)\nend", "    return math.modf(number)\n\
    end", "  local integer_part = math.floor(number)\n  return number - integer_part\n\
    end", "    local a,b = math.modf(number)\n    return b\nend", "    return number\
    \ - math.floor(number)\nend", "    local truncated_number = number - math.floor(number)\n\
    \    return truncated_number\nend", "    if number < 0 then return 0\n    else\
    \ return number % 1 end\nend", "\treturn number - math.floor(number)\nend", " \
    \ local _, decimal = math.modf(number)\n  return decimal\nend", "    return number\
    \ - math.floor(number)\nend", "  return number - math.floor(number)\nend", " \
    \   return number - math.floor(number)\nend", "  return number - math.floor(number)\n\
    end", "  return number - math.floor(number)\nend", "  local integer_part = math.floor(number)\n\
    \  return number - integer_part\nend", "    local float_decimals, int_part = math.modf(number)\n\
    \    return float_decimals\nend", "    return number - math.floor(number)\nend",
  "  return number - math.floor(number)\nend", "  return number - math.floor(number)\n\
    end", "    local truncated = math.floor(number)\n    return number - truncated\n\
    end", "    local integer_part = math.floor(number)\n    return number - integer_part\n\
    end", "  return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "    local decimal, integer = math.modf(number)\n    return decimal\nend",
  "    local truncated_number = number - math.floor(number)\n    if truncated_number\
    \ < 0 then\n        truncated_number = 1 + truncated_number\n    end\n    return\
    \ truncated_number\nend", "    return number - math.floor(number)\nend", "  return\
    \ number - math.floor(number)\nend", "  local i, f = math.modf(number)\n  return\
    \ f\nend", "    return number - math.floor(number)\nend", "    return number -\
    \ math.floor(number)\nend", "    return number - math.floor(number)\nend", " \
    \ if number >= 0 then\n    return number % 1\n  else\n    return 1 - (math.abs(number)\
    \ % 1)\n  end\nend", "  return number - math.floor(number)\nend", "    local int,\
    \ decimal = math.modf(number)\n    return decimal\nend", "    if math.type(number)\
    \ ~= \"float\" then\n        return nil\n    end\n    local int, dec = math.modf(number)\n\
    \    return dec\nend", "  return number - math.floor(number)\nend", "    local\
    \ truncated_number, integer_part = math.modf(number)\n    return truncated_number\n\
    end", "  return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "    return number - math.floor(number)\nend", "  local m = math.modf(number)\n\
    \  return m[1] - m[2]\nend", "    if not number then return nil end\n    if type(number)\
    \ ~= \"number\" then return nil end\n    if number < 0 then return nil end\n \
    \   return number % 1\nend", "    local truncated_number, integer_part = modf(number)\n\
    \    return truncated_number\nend", "    return number - math.floor(number)\n\
    end", "  return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "  if number > 0 then\n    return number - math.floor(number)\n  else\n\
    \    return number - math.ceil(number)\n  end\nend", "    local integer_part =\
    \ math.floor(number)\n    return number - integer_part\nend", "    local decimal_part,\
    \ integer_part = math.modf(number)\n    return decimal_part\nend", "    return\
    \ number - math.floor(number)\nend", "    local whole, decimals = math.modf(number)\n\
    \    return decimals\nend", "  local fpart = number - math.floor(number)\n  return\
    \ fpart\nend", "    return number - math.floor(number)\nend", "    return number\
    \ - math.floor(number)\nend", "    return number - math.floor(number)\nend", " \
    \ local integer, decimals = math.modf(number)\n  return decimals\nend", "  local\
    \ _, decimal = math.modf(number)\n  return decimal\nend", "    return number -\
    \ math.floor(number)\nend", "    return math.floor(number * 100) / 100\nend",
  "    return number - math.floor(number)\nend", "\treturn number % 1\nend", "   \
    \ return number - math.floor(number)\nend", "  local int_part = math.floor(number)\n\
    \  return number - int_part\nend", "    return math.modf(number)\nend", "  return\
    \ number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "    local int, dec = math.modf(number)\n    return dec\nend", "    return\
    \ number - math.floor(number)\nend", "    local integral, fractional = math.modf(number)\n\
    \    return fractional\nend", "    return math.modf(number)\nend", "    return\
    \ number - math.floor(number)\nend", "  local number_str = string.format(\"%f\"\
    , number)\n  local number_split = string.split(number_str, \".\")\n  return tonumber(\"\
    0.\" .. number_split[2])\nend", "    return number - math.floor(number)\nend",
  "    return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "  return math.fmod(number, 1)\nend", "    local integer_part = math.floor(number)\n\
    \    return number - integer_part\nend", "    local int_part = math.floor(number)\n\
    \    return number - int_part\nend", "    return number - math.floor(number)\n\
    end", "  local _,fractional = math.modf(number)\n  return fractional\nend", " \
    \   return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "\tif number > 0 then\n\t\treturn number % 1\n\telse\n\t\treturn 1 + number\
    \ % 1\n\tend\nend", "    return number - floor(number)\nend", "    local integer_part\
    \ = math.floor(number)\n    return number - integer_part\nend", "    if number\
    \ >= 0 then\n        return number - math.floor(number)\n    else\n        return\
    \ number - math.ceil(number)\n    end\nend", "    local integer, decimals = math.modf(number)\n\
    \    return decimals\nend", "    return number - math.floor(number)\nend", " \
    \ local f,i = math.modf(number)\n  return f\nend", "    return number - math.floor(number)\n\
    end", "    return number - math.floor(number)\nend", "    local truncated = math.floor(number)\n\
    \    return number - truncated\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
