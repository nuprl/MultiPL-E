name: HumanEval_154_cycpattern_check
language: lua
prompt: "-- You are given 2 words. You need to return True if the second word or any\
  \ of its rotations is a substring in the first word\n-- cycpattern_check(\"abcd\"\
  ,\"abd\") => False\n-- cycpattern_check(\"hello\",\"ell\") => True\n-- cycpattern_check(\"\
  whassup\",\"psus\") => False\n-- cycpattern_check(\"abab\",\"baa\") => True\n--\
  \ cycpattern_check(\"efef\",\"eeff\") => False\n-- cycpattern_check(\"himenss\"\
  ,\"simen\") => True\nlocal function cycpattern_check(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = cycpattern_check\n\
  \    lu.assertEquals(candidate('xyzw', 'xyw'), false)\n    lu.assertEquals(candidate('yello',\
  \ 'ell'), true)\n    lu.assertEquals(candidate('whattup', 'ptut'), false)\n    lu.assertEquals(candidate('efef',\
  \ 'fee'), true)\n    lu.assertEquals(candidate('abab', 'aabb'), false)\n    lu.assertEquals(candidate('winemtt',\
  \ 'tinem'), true)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  b = b .. b\n  return b:find(a) ~= nil\nend", "\treturn a:find(b)\
    \ or b:sub(2) .. b:sub(1, 1):find(a)\nend", "  local len_a = #a\n  local len_b\
    \ = #b\n  if len_a > len_b then\n    if len_a % len_b == 0 then\n      return\
    \ false\n    end\n    local b_s = b .. b\n    local f = string.find(a, b_s)\n\
    \    if f == 1 then\n      return true\n    end\n    if f == len_a - len_b + 1\
    \ then\n      return true\n    end\n    return false\n  else\n    if len_b % len_a\
    \ == 0 then\n      return false\n    end\n    local a_s = a .. a\n    local f\
    \ = string.find(b, a_s)\n    if f == 1 then\n      return true\n    end\n    if\
    \ f == len_b - len_a + 1 then\n      return true\n    end\n    return false\n\
    \  end\nend", "    local l = #b\n    for _ = 1, #a do\n        if a:sub(1, l)\
    \ == b then\n            return true\n        end\n        a = a:sub(2) .. a:sub(1,\
    \ 1)\n    end\n    return false\nend", "\tfor i = 1, #b do\n\t\tlocal rotated\
    \ = b:sub(i) .. b:sub(1, i - 1)\n\t\tif a:find(rotated) then\n\t\t\treturn true\n\
    \t\tend\n\tend\n\treturn false\nend", "  if #a < #b then return false end\n  b\
    \ = (b .. b):sub(1, #b)\n  for i = 1, #a do\n    if b:sub(1, #a - i + 1) == a:sub(i)\
    \ then\n      return true\n    end\n  end\n  return false\nend", "    local lenb\
    \ = #b\n    local len_pattern = lenb + 1\n    local _a = a..a\n    local b1 =\
    \ b:sub(1, 1)\n    local f_idx = 0\n    while true do\n        f_idx = string.find(_a,\
    \ b1, f_idx + 1)\n        if not f_idx then\n            break\n        end\n\
    \        if b == _a:sub(f_idx, f_idx + lenb - 1) then\n            return true\n\
    \        end\n    end\n    return false\nend", "    if #a ~= #b then\n       \
    \ return false\n    end\n    for i = 1, #a do\n        local substr = string.sub(a,\
    \ i, #a) .. string.sub(a, 1, i - 1)\n        if substr == b then\n           \
    \ return true\n        end\n    end\n    return false\nend", "\nend", "  if #a\
    \ < #b then return false end\n  local b_table = { [b] = true }\n  for i = 2, #b\
    \ do\n    local c = string.sub(b, i) .. string.sub(b, 1, i - 1)\n    b_table[c]\
    \ = true\n  end\n  return b_table[a] == true\nend", "  local n = #a\n  local function\
    \ aux(i)\n    local m = #b\n    for j = 1, n do\n      local k = i + j - 1\n \
    \     if k > n then k = k - n end\n      if a:sub(k, k) ~= b:sub(j, j) then return\
    \ end\n    end\n    return true\n  end\n  for i = 1, n do\n    if aux(i) then\
    \ return true end\n  end\n  return false\nend", "  return (b .. b):find(a)\nend",
  "  -- print(a, b)\n  local bn = b:len()\n  local cnt = 0\n  local n = a:len()\n\
    \  for i = 1, n do\n    if a:sub(i, i) == b:sub(1, 1) then\n      cnt = cnt +\
    \ 1\n      local s = a:sub(i, i + bn - 1)\n      if s:len() == bn then\n     \
    \   local s = s .. a:sub(1, i - 1)\n        -- print(s)\n        if s == b then\n\
    \          return true\n        end\n      end\n    end\n  end\n  return false\n\
    end", "    local n = #a\n    local m = #b\n    local div = n // m\n    local rem\
    \ = n % m\n    return a:sub(1, rem) == b:sub(m - rem + 1) and a:sub(rem + 1) ==\
    \ b:sub(1, m - rem)\nend\nassert(cycpattern_check(\"abcd\", \"abd\") == false)\n\
    assert(cycpattern_check(\"hello\", \"ell\") == true)\nassert(cycpattern_check(\"\
    whassup\", \"psus\") == false)\nassert(cycpattern_check(\"abab\", \"baa\") ==\
    \ true)\nassert(cycpattern_check(\"efef\", \"eeff\") == false)\nassert(cycpattern_check(\"\
    himenss\", \"simen\") == true)", "  -- Put your code here\n  local function rotation(str)\n\
    \    local front, rear = string.sub(str,1,1), string.sub(str,2)\n    rear = rear\
    \ .. front\n    return rear\n  end\n  local str1, str2 = a, b\n  if #str1 == #str2\
    \ then\n    while str1 ~= str2 do\n      str2 = rotation(str2)\n      if str1\
    \ == str2 then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "  local res = nil\n  for i = 1, #b do\n    if string.sub(a,1,#b) == string.sub(b,i,i+#b-1)\
    \ then\n      res = true\n      break\n    end\n  end\n  if res == nil then\n\
    \    res = false\n  end\n  return res\nend", "    local l = string.len(b)\n  \
    \  for i = 1, l do\n        if string.find(a, b) then\n            return true\n\
    \        end\n        b = string.sub(b, 2) .. string.sub(b, 1, 1)\n    end\n \
    \   return false\nend", "  local check = false\n  local x = #b\n  if x > #a then\n\
    \    return false\n  end\n  local s = string.sub(a,1,x)\n  local l = x\n  for\
    \ i = 1,#a do\n    if s == b then\n      check = true\n      break\n    end\n\
    \    if i + l > #a then\n      s = string.sub(a,i,#a) .. string.sub(a,1,l - (#a\
    \ - i))\n    else\n      s = string.sub(a,i,i + l - 1)\n    end\n  end\n  return\
    \ check\nend", "    local rot = a:sub(1, #b) .. a:sub(#b + 1)\n    return b ==\
    \ rot or cycpattern_check(rot, b)\nend", end, "  local m, n = #a, #b\n  for i\
    \ = 1, n do\n    local a1, a2 = b:sub(1, i - 1), b:sub(i)\n    if a:find(a1) and\
    \ a:find(a2) then\n      return true\n    end\n  end\n  return false\nend", " \
    \   if #a < #b then return false end\n    local cnt = 0\n    for i = 1, #a do\n\
    \        if a:sub(i, i) == b:sub(1, 1) then\n            local indx = i\n    \
    \        local j = 1\n            while j <= #b do\n                if a:sub(indx,\
    \ indx) ~= b:sub(j, j) then\n                    break\n                end\n\
    \                if j == #b then\n                    cnt = cnt + 1\n        \
    \        end\n                j = j + 1\n                indx = indx + 1\n   \
    \             if indx > #a then\n                    indx = 1\n              \
    \  end\n            end\n        end\n    end\n    return cnt > 0\nend", "  return\
    \ a:find(b, 1, true) or a:find(b:sub(2) .. b:sub(1, 1), 1, true)\nend", "  for\
    \ i = 1, #b do\n    if b:sub(i) .. b:sub(1, i - 1) == a then\n      return true\n\
    \    end\n  end\n  return false\nend", "  local i = 0\n  while i < #b do\n   \
    \ if string.find(a, b, 1, true) then\n      return true\n    end\n    b = string.sub(b,\
    \ -1) .. string.sub(b, 1, -2)\n    i = i + 1\n  end\n  return false\nend", " \
    \ local size = #b\n  local asize = #a\n  local i = 1\n  while i <= asize do\n\
    \    local j = 1\n    local k = i\n    while k <= asize and j <= size and a:sub(k,\
    \ k) == b:sub(j, j) do\n      j = j + 1\n      k = k + 1\n    end\n    if j >\
    \ size then\n      return true\n    end\n    i = i + 1\n  end\n  return false\n\
    end", "\tlocal function rot_string(s)\n\t\treturn s:sub(2) .. s:sub(1, 1)\n\t\
    end\n\tlocal b = rot_string(b)\n\twhile b ~= b:sub(1, 1) do\n\t\tif a:find(b)\
    \ then\n\t\t\treturn true\n\t\tend\n\t\tb = rot_string(b)\n\tend\n\treturn false\n\
    end", "    if #a < #b then return false end\n    local b = b:gsub(\"(.)\", \"\
    %1 \")\n    for _,v in pairs({1, 2, 3}) do\n        b = b:gsub(\"(%w) (%w)\",\
    \ \"%2%1\")\n        if b:find(a) then return true end\n    end\n    return false\n\
    end", "  local b2 = b .. b\n  return string.find(b2, a) ~= nil\nend", "  -- no\
    \ need to check if a is longer than b.\n  if #a < #b then return false end\n \
    \ -- find the first letter of b in a.\n  local ai = find_first_letter(a, b)\n\
    \  -- if not found return false.\n  if not ai then return false end\n  -- the\
    \ last index of a.\n  local a_end = #a\n  -- the last index of b.\n  local b_end\
    \ = #b\n  -- while ai is less than the last index of a, and the next letter in\
    \ b is not\n  -- the same as the next letter in a, rotate a and try again.\n \
    \ while ai < a_end and b:sub(1, 1) ~= a:sub(ai + 1, ai + 1) do\n    a = a:sub(ai\
    \ + 1, a_end) .. a:sub(1, ai)\n    ai = find_first_letter(a, b)\n    if not ai\
    \ then return false end\n  end\n  -- while b_end is greater than 0 and the last\
    \ letter in b is not the same as\n  -- the letter in a, rotate b and try again.\n\
    \  while b_end > 0 and b:sub(b_end, b_end) ~= a:sub(1, 1) do\n    b = b:sub(2,\
    \ b_end) .. b:sub(1, 1)\n    b_end = b_end - 1\n  end\n  -- return whether b is\
    \ a substring of a.\n  return b == a:sub(1, b_end)\nend", "    if not a or not\
    \ b then return false end\n    local shifted = function(s)\n        return (s:sub(2)\
    \ .. s:sub(1, 1))\n    end\n    local a2 = a\n    for i = 1, #a do\n        if\
    \ a2:find(b) then return true end\n        a2 = shifted(a2)\n    end\n    return\
    \ false\nend", "  if not a or not b then return false end\n  local n = #b\n  local\
    \ concat = b .. b\n  return concat:match(a)\nend", "\nend", "\nend", "    local\
    \ a_len = #a\n    local b_len = #b\n    for i = 1, a_len do\n        if string.sub(a,\
    \ i, i + b_len - 1) == b then\n            return true\n        end\n    end\n\
    \    return false\nend", "  local n = #a\n  local function same(i, j)\n    return\
    \ a:sub(i, j) == b:sub(1, j - i + 1)\n  end\n  for i = 1, n do\n    if same(i,\
    \ n) and same(1, i - 1) then\n      return true\n    end\n  end\n  return false\n\
    end", "\t-- Write code here\n\tlocal len = #b\n\tlocal words = a:sub(1, len)\n\
    \tlocal first = a:sub(1, 1)\n\tfor i = 1, len do\n\t\tif words == b then\n\t\t\
    \treturn true\n\t\tend\n\t\twords = words:sub(2) .. first\n\t\tfirst = a:sub(i\
    \ + 1, i + 1)\n\tend\n\treturn false\nend", "  -- your code here\n  if a == b\
    \ then\n    return true\n  end\n  if string.len(a) == string.len(b) then\n   \
    \ local bfront = string.sub(b,1,1)\n    local bfrontindex = string.find(a,bfront)\n\
    \    if bfrontindex == nil then\n      return false\n    end\n    local lena =\
    \ string.len(a)\n    local a1 = string.sub(a,1,bfrontindex - 1)\n    local a2\
    \ = string.sub(a,bfrontindex)\n    if a2 == b then\n      return true\n    end\n\
    \    local bback = string.sub(b,string.len(b),string.len(b))\n    local bbackindex\
    \ = string.find(a,bback)\n    local a1back = string.sub(a1,bbackindex)\n    local\
    \ a2front = string.sub(a2,1,string.len(a2) - 1)\n    local temp = a1back .. a2front\n\
    \    if temp == b then\n      return true\n    end\n  end\n  return false\nend",
  "    --#code\n    if #a == #b then\n        return a:find(b) and true or false\n\
    \    end\n    local i = 1\n    while i <= #a do\n        if a:sub(i, i + #b -\
    \ 1) == b then\n            return true\n        end\n        i = i + 1\n    end\n\
    \    return false\nend", "\nend", "\tlocal n = #a\n\tlocal m = #b\n\tfor i = 1,\
    \ n do\n\t\tif b == a:sub(i, m + i - 1) then\n\t\t\treturn true\n\t\tend\n\tend\n\
    \treturn false\nend", "    local l = #b\n    local f\n    for i = 1, l do\n  \
    \      f = b:sub(i, -1) .. b:sub(1, i - 1)\n        if a:find(f) then\n      \
    \      return true\n        end\n    end\n    return false\nend", "  return a:find(b:sub(2)\
    \ .. b:sub(1, 1))\nend", "    local n = #a\n    local m = #b\n    if n ~= m then\n\
    \        return false\n    end\n    local bb = b\n    for i = 1, n do\n      \
    \  if a:find(bb) then\n            return true\n        end\n        bb = bb:sub(2)\
    \ .. bb:sub(1, 1)\n    end\n    return false\nend", "  local tmp = a\n  for i\
    \ = 1, #a do\n    if tmp:find(b) then\n      return true\n    end\n    tmp = tmp:sub(2)\
    \ .. tmp:sub(1, 1)\n  end\n  return false\nend", "  if string.find(a, b) then\n\
    \    return true\n  end\n  for i = 2, string.len(b) do\n    local c = string.sub(b,\
    \ i) .. string.sub(b, 1, i - 1)\n    if string.find(a, c) then\n      return true\n\
    \    end\n  end\n  return false\nend", "\tlocal a_len = #a\n\tlocal b_len = #b\n\
    \tif b_len == 1 then\n\t\treturn a:find(b) ~= nil\n\tend\n\t\n\tif a_len < b_len\
    \ then\n\t\treturn false\n\tend\n\tlocal first_char = b:sub(1, 1)\n\tfor i = 1,\
    \ a_len do\n\t\tif a:sub(i, i) == first_char then\n\t\t\tlocal j = 2\n\t\t\twhile\
    \ j <= b_len do\n\t\t\t\tif a:sub(i + j - 1, i + j - 1) ~= b:sub(j, j) then\n\t\
    \t\t\t\tbreak\n\t\t\t\tend\n\t\t\t\tj = j + 1\n\t\t\tend\n\t\t\tif j > b_len then\n\
    \t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\t\n\tfor i = 1, a_len do\n\t\t\
    if a:sub(i, i) == first_char then\n\t\t\tlocal j = 2\n\t\t\twhile j <= b_len do\n\
    \t\t\t\tif a:sub(i + j - 1 - a_len, i + j - 1 - a_len) ~= b:sub(j, j) then\n\t\
    \t\t\t\tbreak\n\t\t\t\tend\n\t\t\t\tj = j + 1\n\t\t\tend\n\t\t\tif j > b_len then\n\
    \t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn false\nend", "\t\
    --local str = \"\"\n\t--for i = 1, #b do\n\t--\tstr = str .. string.sub(b, i,\
    \ i)\n\t--end\n\t--return string.find(a, str)\n\treturn (a:find(b) or a:find(b:sub(2)\
    \ .. b:sub(1, 1)))\nend", "    a, b = a:lower(), b:lower()\n    if a:find(b) or\
    \ a:find(b:sub(2) .. b:sub(1, 1)) or a:find(b:sub(3) .. b:sub(1, 2)) or a:find(b:sub(4)\
    \ .. b:sub(1, 3)) then\n        return true\n    end\n    return false\nend",
  '  local len = #b', "  -- TODO\nend", "  -- TODO\nend", "  -- your code here\n \
    \ return nil\nend", "  local l = #b\n  for i = 1, l do\n    local str = string.sub(b,\
    \ l - i + 1, l) .. string.sub(b, 1, l - i)\n    local in_a = string.find(a, str)\n\
    \    if in_a then\n      return true\n    end\n  end\n  return false\nend", "\t\
    local str = a\n\tlocal l = #str\n\tfor i = 1, l do\n\t\tstr = str:sub(2) .. str:sub(1,\
    \ 1)\n\t\tif str:find(b) then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\n\
    end", "\tif not a or not b then return false end\n\tif b == \"\" then return true\
    \ end\n\tlocal last_char = b:sub(1,1)\n\tlocal first_char = b:sub(-1,-1)\n\tlocal\
    \ next_char = last_char\n\tif last_char == first_char then\n\t\tif a:find(b) then\
    \ return true end\n\t\tlocal word_to_match = b:sub(2,-2)\n\t\tlocal word_size\
    \ = word_to_match:len()\n\t\tlocal word_to_match_index = 0\n\t\twhile word_to_match_index\
    \ < word_size do\n\t\t\tnext_char = word_to_match:sub(1,1)\n\t\t\tword_to_match\
    \ = word_to_match:sub(2,-1) .. next_char\n\t\t\tif a:find(word_to_match) then\
    \ return true end\n\t\t\tword_to_match_index = word_to_match_index + 1\n\t\tend\n\
    \telse\n\t\tlocal new_word = b\n\t\twhile new_word:sub(-1,-1) ~= last_char do\n\
    \t\t\tnew_word = new_word:sub(2,-1) .. new_word:sub(1,1)\n\t\t\tif a:find(new_word)\
    \ then return true end\n\t\tend\n\tend\n\treturn false\nend", "  if type(a) ~=\
    \ \"string\" or type(b) ~= \"string\" then\n    return false\n  end\n  for i =\
    \ 1, #b do\n    if a:find(b) then\n      return true\n    end\n    b = b:sub(2)\
    \ .. b:sub(1, 1)\n  end\n  return false\nend", "    local function is_substring(l1,\
    \ l2)\n        if #l1 < #l2 then\n            return false\n        end\n    \
    \    for i = 1, #l1 do\n            if l1:sub(i, i + #l2 - 1) == l2 then\n   \
    \             return true\n            end\n        end\n        return false\n\
    \    end\n    if not is_substring(a, b) then\n        return false\n    end\n\
    \    for i = 1, #b do\n        b = b:sub(2) .. b:sub(1, 1)\n        if is_substring(a,\
    \ b) then\n            return true\n        end\n    end\n    return false\nend",
  "  -- look for the whole string b in a\n  if a:find(b) then\n    return true\n \
    \ end\n  -- now we loop through the string and rotate it\n  for i = 1, #b do\n\
    \    -- take the first letter of the string and add it to the end\n    b = b:sub(2)\
    \ .. b:sub(1, 1)\n    -- look for the whole string b in a\n    if a:find(b) then\n\
    \      return true\n    end\n  end\n  return false\nend", "    local first = #a\n\
    \    local second = #b\n    local count = 0\n    if first < second then\n    \
    \    return false\n    end\n    for i = 1, first do\n        if a:sub(i, i + second\
    \ - 1) == b then\n            return true\n        end\n    end\n    return false\n\
    end", "  if #a == #b then\n    local s, t = a .. a, 0\n    local i, j = string.find(s,\
    \ b, 1, true)\n    if i then\n      return true\n    end\n  end\n  return false\n\
    end", "  -- body\n  local state = false\n  for i = 1, #b do\n    local tmp = string.sub(b,\
    \ i, #b)..string.sub(b, 1, i-1)\n    if string.find(a, tmp) then\n      state\
    \ = true\n      break\n    end\n  end\n  return state\nend", "    local fp = a:sub(1,\
    \ 1)\n    local lp = a:sub(-1)\n    a = fp .. a .. lp\n    local patt = lp ..\
    \ b .. fp\n    return a:find(patt) ~= nil\nend", "  if #a < #b then return false\
    \ end\n  for i = 1, #a do\n    if a:sub(i, i + #b - 1) == b then return true end\n\
    \  end\n  return false\nend", "    return false\nend", "\tlocal pattern = ''\n\
    \tfor i = 1, #b do\n\t\tpattern = pattern .. b:sub(i, i)\n\tend\n\tpattern = pattern\
    \ .. b\n\treturn pattern:find(a)\nend", "  if a == b then return true end\n  local\
    \ l = string.len(b)\n  if l < 2 then return false end\n  local x = b\n  while\
    \ x ~= b do\n    if string.find(a, x) then return true end\n    x = string.sub(x,\
    \ 2) .. string.sub(x, 1, 1)\n  end\n  return false\nend", "\t--modify a and b\
    \ to all lowercase letters\n\ta = a:lower()\n\tb = b:lower()\n\t--loop from the\
    \ first letter of b to the end of b\n\tfor i = 1, b:len() do\n\t\t--check if the\
    \ first letter of b is in a, and get the index it is at\n\t\tlocal pos = a:find(b:sub(1,\
    \ 1))\n\t\t--check if the first letter of b is in a\n\t\tif pos then\n\t\t\t--check\
    \ if the substring of a (from the index of the letter found to the end of a) plus\
    \ the substring of a (from the beginning of a to the index of the letter found)\
    \ contains b\n\t\t\tif (a:sub(pos, a:len()) .. a:sub(1, pos-1)):find(b) then\n\
    \t\t\t\treturn true\n\t\t\tend\n\t\tend\n\t\t--move the first letter of b to the\
    \ end of b\n\t\tb = b:sub(2, b:len()) .. b:sub(1, 1)\n\tend\n\treturn false\n\
    end", "  local last = #b\n  for i = 1, #b do\n    if string.find(a, b:sub(i) ..\
    \ b:sub(1, i - 1)) then\n      return true\n    end\n  end\n  return false\nend",
  "\tif string.len(a) ~= string.len(b) then\n\t\treturn false\n\tend\n\ta = a:lower()\n\
    \tb = b:lower()\n\tlocal pattern = '(' .. b .. ')%1*'\n\tlocal _, num = a:gsub(pattern,\
    \ '')\n\treturn num == 0\nend", "    local s = a..a\n    return s:find(b)\nend\n\
    assert(cycpattern_check(\"abcd\",\"abd\") == false)\nassert(cycpattern_check(\"\
    hello\",\"ell\") == true)\nassert(cycpattern_check(\"whassup\",\"psus\") == false)\n\
    assert(cycpattern_check(\"abab\",\"baa\") == true)\nassert(cycpattern_check(\"\
    efef\",\"eeff\") == false)\nassert(cycpattern_check(\"himenss\",\"simen\") ==\
    \ true)", "    if string.find(a, b) then\n        return true\n    end\n    for\
    \ i = 1, string.len(b) do\n        b = string.sub(b, 2) .. string.sub(b, 1, 1)\n\
    \        if string.find(a, b) then\n            return true\n        end\n   \
    \ end\n    return false\nend", "  if not a or not b then return false end\n  for\
    \ i = 1, #b do\n    local c = b:sub(i, i)\n    if not a:find(c) then return false\
    \ end\n  end\n  return true\nend", end, "    b = b..b\n    return b:find(a) ~=\
    \ nil\nend", "\tlocal c = a .. a\n\treturn c:find(b) ~= nil\nend", "  if #a <\
    \ #b then return false end\n  for i = 1, #a - #b + 1 do\n    local sub = a:sub(i,\
    \ i + #b - 1)\n    if sub == b then return true end\n    if #b == #sub then\n\
    \      sub = sub:sub(2) .. sub:sub(1, 1)\n      if sub == b then return true end\n\
    \    end\n  end\n  return false\nend", "    local len = #b\n    local b = b ..\
    \ b\n    return b:find(a) ~= nil\nend", "  return false\nend", "  local c = #b\n\
    \  if #a < c then return false end\n  if a:sub(1, c) == b then return true end\n\
    \  local x = c - 1\n  while x > 0 do\n    if a:sub(1, x) == b:sub(c - x + 1, c)\
    \ then\n      local y = c - x + 1\n      while y < c do\n        if a:sub(x +\
    \ 1, x + y) == b:sub(1, y) then\n          return true\n        end\n        y\
    \ = y + 1\n      end\n    end\n    x = x - 1\n  end\n  return false\nend", end,
  "  -- Code here\n  a, b = a:lower(), b:lower()\n  local len = string.len(b)\n  for\
    \ i = 1, len do\n    local substr = string.sub(b, i, len) .. string.sub(b, 1,\
    \ i - 1)\n    if string.find(a, substr) then\n      return true\n    end\n  end\n\
    \  return false\nend", "  local b = string.sub(b,1,1)..string.sub(b,2)\n  if string.find(a,b)\
    \ then\n    return true\n  else\n    return cycpattern_check(a,b)\n  end\nend",
  "  local a_size = #a\n  local b_size = #b\n  local iter = 0\n  if b_size > a_size\
    \ then\n    return false\n  end\n  local test_string = string.sub(a, 1, b_size)\n\
    \  if test_string == b then\n    return true\n  end\n  while iter < a_size - 1\
    \ do\n    iter = iter + 1\n    test_string = string.sub(a, iter, a_size) .. string.sub(a,\
    \ 1, iter - 1)\n    if test_string == b then\n      return true\n    end\n  end\n\
    \  return false\nend", "  if a and b then\n    local alen = a:len()\n    local\
    \ blen = b:len()\n    if alen == blen then\n      local blen = b:len()\n     \
    \ local b = (b..b):sub(blen+1,blen*2)\n      if a:find(b) then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "\nend", "    local function\
    \ compare_rotation(a, b)\n        if #a == #b then\n            if a == b then\n\
    \                return true\n            end\n            local rotations = {}\n\
    \            local length = #a\n            local index = 0\n            for i\
    \ = 1, length do\n                index = index + 1\n                if #rotations\
    \ == 0 then\n                    rotations[1] = string.sub(a, index, length) ..\
    \ string.sub(a, 1, index - 1)\n                else\n                    rotations[#rotations\
    \ + 1] = string.sub(rotations[#rotations], index, length) .. string.sub(rotations[#rotations],\
    \ 1, index - 1)\n                end\n            end\n            for i = 1,\
    \ #rotations do\n                if rotations[i] == b then\n                 \
    \   return true\n                end\n            end\n        end\n        return\
    \ false\n    end\n    if #a > #b then\n        return compare_rotation(a, b)\n\
    \    else\n        return compare_rotation(b, a)\n    end\nend", "  if #a < #b\
    \ then return false end\n  local b1 = b .. b\n  return b1:find(a)\nend", "  local\
    \ b_pairs = {}\n  for i=1,#b do\n    b_pairs[#b_pairs+1] = b:sub(i, i+1)\n  end\n\
    \  for i=1,#b do\n    local str = {}\n    for j=i,#b do\n      str[#str+1] = b_pairs[j]\n\
    \    end\n    for j=1,i-1 do\n      str[#str+1] = b_pairs[j]\n    end\n    if\
    \ a:find(table.concat(str)) then\n      return true\n    end\n  end\n  return\
    \ false\nend", "  if a:find(b) then return true end\n  local bt = b:sub(2)..b:sub(1,1)\n\
    \  if a:find(bt) then return true end\n  local btt = bt:sub(2)..bt:sub(1,1)\n\
    \  if a:find(btt) then return true end\n  local bttt = btt:sub(2)..btt:sub(1,1)\n\
    \  if a:find(bttt) then return true end\n  return false\nend", "    -- your code\
    \ here\n    -- pattern, search_string \n    -- pattern = abd\n    -- search_string\
    \ = abcd\n    -- n = 3\n    -- (n-1) = 2\n    -- pattern = (n-1)%n\n    -- 2%3\
    \ = 2\n    -- search_string = (search_string + (n-1))%n\n    -- abcd + 2 = abdcd\n\
    \    -- 0 = c (abdcd[0])\n    -- 1 = d (abdcd[1])\n    -- 2 = a (abdcd[2])\n \
    \   -- 3 = b (abdcd[3])\n    -- 4 = c (abdcd[4])\n    -- 5 = d (abdcd[5])\n  \
    \  -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n\
    \    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 =\
    \ 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3\
    \ = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    --\
    \ 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n  \
    \  -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n\
    \    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 =\
    \ 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3\
    \ = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n    -- 2%3 = 2\n", "  return 'YOUR_CODE_HERE'\n\
    end", "\tif a == b then return true end\n\tlocal str = \"\"\n\tfor i = 1, string.len(b)\
    \ do\n\t\tstr = str .. string.sub(b, i, i)\n\t\tlocal c = string.sub(b, i, i)\n\
    \t\tlocal sub = string.sub(b, 1, i)\n\t\tlocal cnt = 0\n\t\twhile c ~= sub do\n\
    \t\t\tcnt = cnt + 1\n\t\t\tc = string.sub(b, cnt, cnt)\n\t\tend\n\t\tif string.find(a,\
    \ str) then return true end\n\tend\n\treturn false\nend", "  local l = #b\n  for\
    \ i = 1, l do\n    if string.find(a, b) then\n      return true\n    end\n   \
    \ b = string.sub(b, 2) .. string.sub(b, 1, 1)\n  end\n  return false\nend", "\t\
    local i, j = 1, 1\n\twhile j <= #b do\n\t\tif a:sub(i, i) == b:sub(j, j) then\n\
    \t\t\tj = j + 1\n\t\t\ti = i + 1\n\t\t\tif i > #a then\n\t\t\t\ti = 1\n\t\t\t\
    end\n\t\telse\n\t\t\treturn false\n\t\tend\n\tend\n\treturn true\nend", end, " \
    \ -- body\n  a = a:lower()\n  b = b:lower()\n  local n = a:len()\n  local m =\
    \ b:len()\n  if n < m then\n    return false\n  end\n  local function check(a,\
    \ b)\n    if a:find(b) then\n      return true\n    end\n    return false\n  end\n\
    \  for i = 1, n do\n    if check(a, b) then\n      return true\n    end\n    b\
    \ = b:sub(2) .. b:sub(1, 1)\n  end\n  return false\nend", "    -- check if b is\
    \ a substring of a\n    if (string.find(a, b) ~= nil) then\n        return true\n\
    \    end\n    -- b is not a substring of a, but what if b is a substring of a\
    \ rotated a\n    -- we will create bs and a concatenated with a and then check\
    \ if bs has a\n    -- substring of b\n    local bs = b .. b\n    local ar = a\
    \ .. a\n    if (string.find(bs, a) ~= nil) then\n        return true\n    end\n\
    \    return false\nend", "\tfor i = 1, #b do\n\t\tb = b:sub(2) .. b:sub(1, 1)\n\
    \t\tif a:find(b) then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend",
  "  if string.len(a) < string.len(b) then\n    return false\n  end\n  local pat =\
    \ string.sub(a, 1, string.len(b))\n  for i = 1, string.len(b) do\n    if pat ==\
    \ b then\n      return true\n    end\n    pat = string.sub(pat, 2) .. string.sub(pat,\
    \ 1, 1)\n  end\n  return false\nend", "\t-- body\n\t-- return a:find(b) ~= nil\n\
    \tlocal is_cyc = a:find(b) ~= nil\n\tif is_cyc then return true end\n\tfor i =\
    \ 1, #b do\n\t\tlocal first_letter = b:sub(1, 1)\n\t\tb = b:sub(2) .. first_letter\n\
    \t\tif b == a then return true end\n\tend\n\treturn false\nend", "    -- TODO\n\
    end", "  b = b..b\n  if b:find(a) then\n    return true\n  else\n    return false\n\
    \  end\nend", "\tlocal n = string.len(a)\n\tfor i = 1, n do\n\t\tif string.sub(a,\
    \ i, i + string.len(b) - 1) == b then\n\t\t\treturn true\n\t\tend\n\t\ta = string.sub(a,\
    \ 2, n) .. string.sub(a, 1, 1)\n\tend\n\treturn false\nend", "  local max = math.max(#a,\
    \ #b)\n  local min = math.min(#a, #b)\n  local short, long = (max == #a) and a\
    \ or b, (max == #a) and b or a\n  local len_short = #short\n  local len_long =\
    \ #long\n  local first, last = string.sub(short, 1, 1), string.sub(short, -1,\
    \ -1)\n  for i = 1, len_short do\n    if (string.sub(short, i, i) == first) then\n\
    \      if (string.find(short, string.sub(short, i, len_short) .. string.sub(short,\
    \ 1, i - 1), 1, true)) then\n        if (string.find(long, string.sub(short, i,\
    \ len_short) .. string.sub(short, 1, i - 1), 1, true)) then\n          return\
    \ true\n        end\n      end\n    end\n  end\n  return false\nend", "  --your\
    \ code here\nend", "  for i = 1, #b do\n    if a:find(b:sub(i) .. b:sub(1, i -\
    \ 1)) then\n      return true\n    end\n  end\n  return false\nend", "  if a and\
    \ b then\n    local found_it\n    local a_len = a:len()\n    local b_len = b:len()\n\
    \    local k = a_len-b_len\n    -- if the second string is longer than the first\
    \ string, there is no chance\n    if b_len > a_len then\n      return false\n\
    \    end\n    for i = 1, k do\n      -- for i=1, the second string is at the end\
    \ of the first string\n      -- for i=k, the second string is at the beginning\
    \ of the first string\n      found_it = true\n      for j = 1, b_len do\n    \
    \    -- compare each character of the two strings. If a difference is found,\n\
    \        -- go to the next i.\n        if a:sub(i+j-1, i+j-1) ~= b:sub(j, j) then\n\
    \          found_it = false\n          break\n        end\n      end\n      if\
    \ found_it then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "    for i = 1, #b do\n        local nb = b:sub(i, #b) .. b:sub(1, i - 1)\n\
    \        if nb == a then\n            return true\n        end\n    end\n    return\
    \ false\nend\nassert(cycpattern_check(\"abcd\", \"abd\") == false)\nassert(cycpattern_check(\"\
    hello\", \"ell\") == true)\nassert(cycpattern_check(\"whassup\", \"psus\") ==\
    \ false)\nassert(cycpattern_check(\"abab\", \"baa\") == true)\nassert(cycpattern_check(\"\
    efef\", \"eeff\") == false)\nassert(cycpattern_check(\"himenss\", \"simen\") ==\
    \ true)", "    local s = b .. b\n    return s:find(a) ~= nil\nend", "\treturn\
    \ (\"*\" .. b):find(a:sub(2, -1) .. a:sub(1, 1))\nend", "  local function rotate(str)\n\
    \    return str:sub(2) .. str:sub(1, 1)\n  end\n  for i = 1, b:len() do\n    if\
    \ a:find(b) then\n      return true\n    end\n    b = rotate(b)\n  end\n  return\
    \ false\nend", "  -- your code here\nend", "  local function cycle_str(s)\n  \
    \  local t = {}\n    for i = 1, #s do\n      table.insert(t,s:sub(i))\n    end\n\
    \    return table.concat(t)\n  end\n  local sub = b\n  local tmp = {}\n  for i\
    \ = 1, #sub do\n    local t = cycle_str(sub)\n    table.insert(tmp,t)\n    sub\
    \ = t\n  end\n  for _,v in ipairs(tmp) do\n    if a:find(v) then\n      return\
    \ true\n    end\n  end\n  return false\nend", "\treturn a:find(b) or a:find(b:sub(2)\
    \ .. b:sub(1, 1))\nend", end, "  for i = 1,#b do\n    if a:find(b:sub(i)..b:sub(1,i-1))\
    \ then\n      return true\n    end\n  end\n  return false\nend", "  --TODO: implement\
    \ this function\nend", "  if a:len() ~= b:len() then return false end\n  local\
    \ c = b:sub(2) .. b:sub(1, 1)\n  while c ~= b do\n    if a:find(c) then return\
    \ true end\n    c = c:sub(2) .. c:sub(1, 1)\n  end\n  return false\nend", "\t\
    local n, m = #a, #b\n\tfor i = 1, n do\n\t\tlocal c = a:sub(i, i + m - 1)\n\t\t\
    if c == b then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend", "  if\
    \ #a < #b then return false end\n  local str = string.rep(b, 1 + math.floor(#a\
    \ / #b))\n  return string.find(a, str) ~= nil\nend", "  local len_a = #a\n  local\
    \ len_b = #b\n  local i, j, i_max, j_max\n  local a_sub, b_sub", "  if not a or\
    \ not b then return false end\n  local b = b:rep(#a)\n  return b:match(a)\nend",
  "\t-- Determine string length(s)\n\tlocal slen_a = string.len(a)\n\tlocal slen_b\
    \ = string.len(b)\n\t-- If string lengths are not equal, return\n\tif slen_a ~=\
    \ slen_b then\n\t\treturn false\n\tend\n\t-- Create a variable holding the length\
    \ of the subpattern\n\tlocal patternlen = string.len(b)\n\t-- Convert the initial\
    \ string into a table\n\tlocal tal_a = {}\n\tfor i = 1, slen_a do\n\t\ttable.insert(tal_a,\
    \ string.sub(a, i, i))\n\tend\n\t-- Create a variable holding the length of the\
    \ initial string table\n\tlocal talen_a = #tal_a\n\t-- Create a variable holding\
    \ the remaining length of the initial string table\n\tlocal rmalen_a = talen_a\n\
    \t-- Create a variable for storing the pattern position\n\tlocal patpos = 1\n\t\
    -- Create a variable for storing the position of the 1st subpattern letter\n\t\
    local stpos = 0\n\t-- Create a variable for storing the position of the 2nd subpattern\
    \ letter\n\tlocal ndpos = 0\n\t-- Create a variable for storing the position of\
    \ the 3rd subpattern letter\n\tlocal rdpos = 0\n\t-- Create a variable for storing\
    \ the position of the 4th subpattern letter\n\tlocal thpos = 0\n\t-- Keep looping\
    \ until the length of the remaining initial string table is zero (or the pattern\
    \ is found)\n\twhile rmalen_a > 0 do\n\t\t-- Loop while the pattern position is\
    \ less than the length of the pattern\n\t\twhile patpos <= patternlen do\n\t\t\
    \t-- If pattern position is 1, then:\n\t\t\tif patpos == 1 then\n\t\t\t\t-- Loop\
    \ through the initial string table\n\t\t\t\tfor i = 1, talen_a do\n\t\t\t\t\t\
    -- If the 1st subpattern letter is found:\n\t\t\t\t\tif tal_a[i] == string.sub(b,\
    \ patpos, patpos) then\n\t\t\t\t\t\t-- Store the position of the 1st subpattern\
    \ letter\n\t\t\t\t\t\tstpos = i\n\t\t\t\t\t\t", "\tlocal c, x = string.len(a),\
    \ string.len(b)\n\tfor i = 1, c do\n\t\tif string.sub(a, i, i + x - 1) == b then\n\
    \t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend", "  if string.len(a) <\
    \ string.len(b) then\n    return false\n  end\n  for i = 1, string.len(a) do\n\
    \    if string.sub(a, i, i + string.len(b) - 1) == b then\n      return true\n\
    \    end\n  end\n  return false\nend", "  if not string.find(a, b) then\n    return\
    \ false\n  end\n  return true\nend", "\nend", "  local n = #a\n  local k = #b\n\
    \  if k > n then return false end\n  local temp = string.sub(a,1,k)\n  for i =\
    \ 1, n-k do\n    temp = string.sub(temp, 2) .. string.sub(a,i+k,i+k)\n    if temp\
    \ == b then return true end\n  end\n  return false\nend", "  if #a < #b then return\
    \ false end\n  local b = b .. b\n  for i = 1, #a do\n    if b:find(a:sub(i, #b))\
    \ then return true end\n  end\n  return false\nend", "  if #a < #b then return\
    \ false end\n  local new_word = a .. a\n  return string.find(new_word, b)\nend",
  "  local a_len = a:len()\n  local b_len = b:len()\n  if a_len < b_len then\n   \
    \ return false\n  end\n  local cyc_a = a:sub(2, a_len) .. a:sub(1, 1)\n  local\
    \ cmp = a:sub(1, b_len)\n  if cmp == b then\n    return true\n  end\n  for i =\
    \ 1, a_len - 1 do\n    cmp = cyc_a:sub(1, b_len)\n    if cmp == b then\n     \
    \ return true\n    end\n    cyc_a = cyc_a:sub(2, a_len) .. cyc_a:sub(1, 1)\n \
    \ end\n  return false\nend", "  --your code here\nend", "    for i = 1, #b do\n\
    \        b = b:sub(2) .. b:sub(1, 1)\n        if b == a then\n            return\
    \ true\n        end\n    end\n    return false\nend", "    if b == nil or #b ==\
    \ 0 then\n        return true\n    end\n    if a == nil or #a == 0 then\n    \
    \    return false\n    end\n    local b_idx = 1\n    local a_idx = 1\n    while\
    \ a_idx <= #a do\n        local a_idx_start = a_idx\n        while b_idx <= #b\
    \ and a_idx <= #a and b:sub(b_idx, b_idx) == a:sub(a_idx, a_idx) do\n        \
    \    b_idx = b_idx + 1\n            a_idx = a_idx + 1\n        end\n        if\
    \ b_idx > #b then\n            return true\n        end\n        if a_idx > #a\
    \ then\n            a_idx = 1\n        end\n        if a_idx == a_idx_start then\n\
    \            return false\n        end\n    end\n    return false\nend", "  if\
    \ #a < #b then return false end\n  local a, b = a:lower(), b:lower()\n  local\
    \ sub = string.sub\n  local f = false\n  for i = 1, #a do\n    if sub(a, i, i\
    \ + #b - 1) == b then f = true end\n  end\n  return f\nend", "  a, b = tostring(a),\
    \ tostring(b)\n  for i = 1, #b do\n    local s = b:sub(i) .. b:sub(1, i - 1)\n\
    \    if a:find(s) then return true end\n  end\n  return false\nend", "\tlocal\
    \ firstWord = string.gsub(a, \"[^%a]\", \"\")\n\tlocal secondWord = string.gsub(b,\
    \ \"[^%a]\", \"\")\n\t\n\tfor i = 1, #secondWord do\n\t\tlocal firstChar = string.sub(secondWord,\
    \ 1, 1)\n\t\tlocal otherChars = string.sub(secondWord, 2)\n\t\t\n\t\tif string.find(firstWord,\
    \ firstChar..otherChars) then\n\t\t\treturn true\n\t\tend\n\t\t\n\t\tsecondWord\
    \ = otherChars..firstChar\n\tend\n\t\n\treturn false\nend", "    local word_len\
    \ = #a\n    local pattern_len = #b\n    local i = 0\n    for _ in b:gmatch(a)\
    \ do\n        i = i + 1\n    end\n    return i == 1\nend", "  -- YOUR CODE HERE\n\
    \  return false\nend", "  -- Find the length of 2 words and rotate the word b\
    \ for\n  -- the lenght of word a.\n  -- Return true if word b or any of its rotations\
    \ is a substring\n  -- in word a\n  local len_a = string.len(a)\n  local len_b\
    \ = string.len(b)\n  if len_a < len_b then\n    return false\n  end\n  for i =\
    \ 1, len_a do\n    local new_b = b:sub(len_b - i + 1, len_b) .. b:sub(1, len_b\
    \ - i)\n    if a:find(new_b) then\n      return true\n    end\n  end\n  return\
    \ false\nend", "  a, b = a:lower(), b:lower()\n  local n = #b\n  for i = 1, n\
    \ do\n    if a:find(b, 1, true) then\n      return true\n    end\n    b = b:sub(2)\
    \ .. b:sub(1, 1)\n  end\n  return false\nend", "    local l1, l2 = #a, #b\n  \
    \  if l1 < l2 then return false end\n    if b == a:sub(1, l2) then return true\
    \ end\n    for i = 2, l1 do\n        if b == a:sub(i, i + l2 - 1) then return\
    \ true end\n    end\n    return false\nend", "    return a:find(b)\n        or\
    \ a:find(b:sub(2, b:len()) .. b:sub(1, 1))\n        or a:find(b:sub(3, b:len())\
    \ .. b:sub(1, 2))\n        or a:find(b:sub(4, b:len()) .. b:sub(1, 3))\n     \
    \   or a:find(b:sub(5, b:len()) .. b:sub(1, 4))\n        or a:find(b:sub(6, b:len())\
    \ .. b:sub(1, 5))\n        or a:find(b:sub(7, b:len()) .. b:sub(1, 6))\n     \
    \   or a:find(b:sub(8, b:len()) .. b:sub(1, 7))\n        or a:find(b:sub(9, b:len())\
    \ .. b:sub(1, 8))\n        or a:find(b:sub(10, b:len()) .. b:sub(1, 9))\n    \
    \    or a:find(b:sub(11, b:len()) .. b:sub(1, 10))\n        or a:find(b:sub(12,\
    \ b:len()) .. b:sub(1, 11))\n        or a:find(b:sub(13, b:len()) .. b:sub(1,\
    \ 12))\n        or a:find(b:sub(14, b:len()) .. b:sub(1, 13))\n        or a:find(b:sub(15,\
    \ b:len()) .. b:sub(1, 14))\n        or a:find(b:sub(16, b:len()) .. b:sub(1,\
    \ 15))\n        or a:find(b:sub(17, b:len()) .. b:sub(1, 16))\n        or a:find(b:sub(18,\
    \ b:len()) .. b:sub(1, 17))\n        or a:find(b:sub(19, b:len()) .. b:sub(1,\
    \ 18))\n        or a:find(b:sub(20, b:len()) .. b:sub(1, 19))\n        or a:find(b:",
  "    if (a == nil or b == nil) then\n        return false\n    end\n    a_length\
    \ = string.len(a)\n    b_length = string.len(b)\n    if (a_length == 0 or b_length\
    \ == 0) then\n        return false\n    end\n    if (b_length > a_length) then\n\
    \        return false\n    end\n    if (string.find(a, b) ~= nil) then\n     \
    \   return true\n    end\n    if (b_length == 1) then\n        return false\n\
    \    end\n    for i = 1, (b_length - 1) do\n        b_first = string.sub(b, 1,\
    \ 1)\n        b_rest = string.sub(b, 2, b_length)\n        b = b_rest .. b_first\n\
    \        if (string.find(a, b) ~= nil) then\n            return true\n       \
    \ end\n    end\n    return false\nend", "  a = a:gsub(\"%s\", \"\")\n  b = b:gsub(\"\
    %s\", \"\")\n  local a_len = a:len()\n  local b_len = b:len()\n  if b_len > a_len\
    \ then\n    return false\n  end\n  local i = 1\n  local j = 1\n  local k = 1\n\
    \  local a_rotated = a\n  while i <= a_len do\n    j = 1\n    while j <= b_len\
    \ do\n      if a_rotated:sub(i, i) == b:sub(j, j) then\n        k = 1\n      \
    \  while k <= b_len do\n          if a_rotated:sub(i + k - 1, i + k - 1) ~= b:sub(j\
    \ + k - 1, j + k - 1) then\n            return false\n          end\n        \
    \  k = k + 1\n        end\n        return true\n      end\n      j = j + 1\n \
    \   end\n    a_rotated = a_rotated:sub(2, a_len) .. a_rotated:sub(1, 1)\n    i\
    \ = i + 1\n  end\n  return false\nend", "    local table_a = {}\n    local table_b\
    \ = {}\n    for i = 1, #a do\n        table_a[i] = a:sub(i, i)\n    end\n    for\
    \ i = 1, #b do\n        table_b[i] = b:sub(i, i)\n    end\n    for i = 1, #table_a\
    \ do\n        if table_a[i] == table_b[1] then\n            for j = 1, #table_b\
    \ do\n                if not table_a[j + i - 1] or table_a[j + i - 1] ~= table_b[j]\
    \ then\n                    break\n                end\n                if j ==\
    \ #table_b then\n                    return true\n                end\n      \
    \      end\n        end\n    end\n    return false\nend", "  --your code here\n\
    end", "    for i = 1, #b do\n        local c = b:sub(i) .. b:sub(1, i - 1)\n \
    \       if a:find(c) then\n            return true\n        end\n    end\n   \
    \ return false\nend", "\tlocal len1 = #a\n\tlocal len2 = #b\n\tif len1 == len2\
    \ then\n\t\tif a == b then\n\t\t\treturn true\n\t\tend\n\telseif len1 > len2 then\n\
    \t\tif a:find(b) then\n\t\t\treturn true\n\t\tend\n\tend\n\tif len1 >= len2 then\n\
    \t\tfor i = 1, len1 do\n\t\t\tlocal word = a:sub(i, len1) .. a:sub(1, i - 1)\n\
    \t\t\tif word == b then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ false\nend", "    if #a < #b then return false end\n    local bb = b..b\n  \
    \  local f = bb:find(a)\n    if f then return true end\n    return false\nend",
  "\t--this function should return True if the second word or any of its rotations\
    \ is a substring in the first word\n\tlocal result = false\n\tlocal i = 1\n\t\
    local count = 0\n\tlocal len = #b\n\twhile i <= len do\n\t\tif string.find(a,b)\
    \ then\n\t\t\tresult = true\n\t\t\treturn result\n\t\telse\n\t\t\tb = string.sub(b,2)\
    \ .. string.sub(b,1,1)\n\t\t\tcount = count + 1\n\t\t\tif count >= len then\n\t\
    \t\t\treturn result\n\t\t\tend\n\t\tend\n\t\ti = i + 1\n\tend\nend", "\tif #a\
    \ < #b then return false end\n\tfor i = 1, #a - #b + 1 do\n\t\tif a:sub(i, i +\
    \ #b - 1) == b then return true end\n\tend\n\treturn false\nend", "  if #a < #b\
    \ then return false end\n  local s = a .. a\n  for i = 1, #a do\n    if s:sub(i,\
    \ i + #b - 1) == b then return true end\n  end\n  return false\nend", "    return\
    \ a:match(b) or a:match(b:sub(2) .. b:sub(1, 1))\nend", "  local result = false\n\
    \  if string.find(a, b) or string.find(a, b:sub(2) .. b:sub(1, 1)) then\n    result\
    \ = true\n  end\n  return result\nend", "  if a:len() < b:len() then return false\
    \ end\n  if b:len() == 1 then return true end\n  for i = 1, a:len() do\n    local\
    \ pattern = a:sub(i, i + b:len() - 1)\n    if pattern == b then return true end\n\
    \  end\n  return false\nend", "  local function sub_check(s, sub)\n    local i\
    \ = s:find(sub)\n    return i == 1\n  end\n  for i = 1, #b do\n    local s = b:sub(i,\
    \ #b) .. b:sub(1, i - 1)\n    if sub_check(a, s) then\n      return true\n   \
    \ end\n  end\n  return false\nend", "    return string.find(a, b) ~= nil or\n\
    \           string.find(a, string.sub(b, 2) .. string.sub(b, 1, 1)) ~= nil or\n\
    \           string.find(a, string.sub(b, 3) .. string.sub(b, 1, 2)) ~= nil or\n\
    \           string.find(a, string.sub(b, 4) .. string.sub(b, 1, 3)) ~= nil or\n\
    \           string.find(a, string.sub(b, 5) .. string.sub(b, 1, 4)) ~= nil or\n\
    \           string.find(a, string.sub(b, 6) .. string.sub(b, 1, 5)) ~= nil or\n\
    \           string.find(a, string.sub(b, 7) .. string.sub(b, 1, 6)) ~= nil or\n\
    \           string.find(a, string.sub(b, 8) .. string.sub(b, 1, 7)) ~= nil or\n\
    \           string.find(a, string.sub(b, 9) .. string.sub(b, 1, 8)) ~= nil or\n\
    \           string.find(a, string.sub(b, 10) .. string.sub(b, 1, 9)) ~= nil\n\
    end", "    local al = string.len(a)\n    local bl = string.len(b)\n    if (bl\
    \ > al) then\n        return false\n    end\n    local pattern = a\n    for i\
    \ = 1, bl do\n        if string.find(pattern, b) then\n            return true\n\
    \        end\n        pattern = string.sub(pattern, 2) .. string.sub(pattern,\
    \ 1, 1)\n    end\n    return false\nend", "  if #a < #b then return false end\n\
    \  return a:find(b) ~= nil or a:find(b:sub(2) .. b:sub(1, 1)) ~= nil\nend", end,
  "    if #a<#b then return false end\n    for i=1,#a do\n        local c = a:sub(i,#a)..a:sub(1,i-1)\n\
    \        if c:find(b) then return true end\n    end\n    return false\nend", "\t\
    if #a ~= #b then return false end\n\tlocal word, word2 = a:match(\"(%a+)(%a*)\"\
    )\n\tlocal word_orig = word\n\tlocal word_len = #word\n\tword2 = (word2 ~= \"\"\
    \ and word2 .. word or word)\n\tfor i = 1, word_len do\n\t\tif word:find(b) then\
    \ return true end\n\t\tword = word:sub(2) .. word:sub(1, 1)\n\tend\n\treturn false\n\
    end", "  local n = #a\n  for i = 1, n do\n    if b == a:sub(i, n) .. a:sub(1,\
    \ i - 1) then\n      return true\n    end\n  end\n  return false\nend", "    if\
    \ string.find(a, b) then\n        return true\n    end\n    local s = string.sub(b,\
    \ 2) .. string.sub(b, 1, 1)\n    return cycpattern_check(a, s)\nend", "    local\
    \ b2 = b .. b\n    return b2:find(a) ~= nil\nend", "  -- your code here\nend",
  "\tlocal bb = b .. b\n\treturn bb:find(a) ~= nil\nend", "\tlocal len = #b\n\tlocal\
    \ rot = b\n\tfor i = 1, len do\n\t\trot = rot:sub(2) .. rot:sub(1, 1)\n\t\tif\
    \ a:find(rot) then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend", " \
    \ -- define another variable to store the length of b\n  local len = #b\n  --\
    \ loop through a using length of b as the incrementor\n  for i = 1, #a, len do\n\
    \    -- check if each substring of a using length of b is equal to b\n    if string.sub(a,\
    \ i, i + len - 1) == b then\n      -- return true if the substring is equal to\
    \ b\n      return true\n    end\n  end\n  -- return false if no substring of a\
    \ is equal to b\n  return false\nend", "\tfor i = 1, #b do\n\t\tlocal c = b:sub(i,\
    \ #b) .. b:sub(1, i - 1)\n\t\tif a:find(c) then\n\t\t\treturn true\n\t\tend\n\t\
    end\n\treturn false\nend", "\treturn (a:find(b))\nend", "  return false\nend",
  "    if string.find(a, b) then\n        return true\n    end\n    local s = string.sub(b,\
    \ 2) .. string.sub(b, 1, 1)\n    return cycpattern_check(a, s)\nend", "    for\
    \ i = 1, #b do\n        b = b:sub(2) .. b:sub(1, 1)\n        if a:find(b) then\n\
    \            return true\n        end\n    end\n    return false\nend", "\nend",
  "  if #a < #b then return false end\n  for i = 1, #a - #b + 1 do\n    if string.sub(a,\
    \ i, i + #b - 1) == b then return true end\n  end\n  local b2 = string.sub(b,\
    \ 2)\n  local b1 = string.sub(b, 1, 1)\n  return cycpattern_check(a, b2 .. b1)\n\
    end", "    -- your code here\n    return false\nend", "    local pattern = \"\
    .*\" .. b\n    for i = 1, string.len(b) do\n        pattern = string.sub(b, i,\
    \ string.len(b)) .. string.sub(b, 1, i - 1)\n        if string.match(a, pattern)\
    \ then\n            return true\n        end\n    end\n    return false\nend",
  "    if not (a and b) then return false end\n    local len_a = a:len()\n    local\
    \ len_b = b:len()\n    local chk = false\n    for i = 1, len_b do\n        chk\
    \ = false\n        for j = 1, len_a do\n            if b:sub(i, i) == a:sub(j,\
    \ j) then\n                chk = true\n                local s = i\n         \
    \       local e = j\n                local cnt = 0\n                while cnt\
    \ < len_b do\n                    if s > len_b then s = 1 end\n              \
    \      if e > len_a then e = 1 end\n                    if b:sub(s, s) ~= a:sub(e,\
    \ e) then chk = false end\n                    s = s + 1\n                   \
    \ e = e + 1\n                    cnt = cnt + 1\n                end\n        \
    \        if chk then return true end\n            end\n        end\n    end\n\
    \    return false\nend", "    local le = string.len(b)\n    local a2 = string.sub(a,\
    \ 1, le)\n    return string.find(a, a2, 1, true)\nend", "    return a:find(b)\
    \ or a:find(b:sub(2) .. b:sub(1, 1))\nend", "\tlocal pattern\n\tif #b == 1 then\n\
    \t\tpattern = b\n\telse\n\t\tpattern = b:sub(2, #b) .. b:sub(1, 1)\n\tend\n\t\
    return a:find(pattern)\nend", "\tlocal i, j, endi = 1, 1, #a\n\twhile i <= endi\
    \ do\n\t\tlocal c = a:sub(i, i)\n\t\tlocal d = b:sub(j, j)\n\t\tif c == d then\n\
    \t\t\ti = i + 1\n\t\t\tj = j + 1\n\t\t\tif j > #b then\n\t\t\t\treturn true\n\t\
    \t\tend\n\t\telse\n\t\t\ti = i + 1\n\t\tend\n\tend\n\treturn false\nend", end,
  "  for i = 1, #b do\n    b = b:sub(2) .. b:sub(1, 1)\n    if a:find(b) then\n  \
    \    return true\n    end\n  end\n  return false\nend", "\tlocal pattern = b..b\n\
    \treturn pattern:find(a) ~= nil\nend", end, "  local word, pattern = a, b\n  local\
    \ word_len, pattern_len = #word, #pattern\n  local index = 1\n  local i = 1\n\
    \  local found = false\n  local pattern_first_letter = pattern:sub(1, 1)\n  while\
    \ i <= word_len do\n    if word:sub(i, i) == pattern_first_letter then\n     \
    \ for j = 1, pattern_len do\n        index = i + j - 1\n        if index > word_len\
    \ then\n          index = index - word_len\n        end\n        if word:sub(index,\
    \ index) ~= pattern:sub(j, j) then\n          break\n        end\n        if j\
    \ == pattern_len then\n          found = true\n          break\n        end\n\
    \      end\n    end\n    if found then\n      break\n    end\n    i = i + 1\n\
    \  end\n  return found\nend", "    if a == b then return true end\n    if #a <\
    \ #b then return false end\n    return cycpattern_check(a:sub(2, #a) .. a:sub(1,\
    \ 1), b)\nend", "  local function check(s)\n    local _, i = a:find(s)\n    return\
    \ i ~= nil\n  end\n  local len = #b\n  local patterns = {}\n  for i = 1, len do\n\
    \    local s = b:sub(i, len) .. b:sub(1, i - 1)\n    table.insert(patterns, s)\n\
    \  end\n  for _, s in ipairs(patterns) do\n    if check(s) then\n      return\
    \ true\n    end\n  end\n  return false\nend", "  local function gen(a)\n    local\
    \ n = string.len(a)\n    local i = 0\n    return function()\n      i = i + 1\n\
    \      if i > n then return nil end\n      return string.sub(a, i) .. string.sub(a,\
    \ 1, i - 1)\n    end\n  end\n  local function gen_pattern(a)\n    local s = \"\
    \"\n    for i in gen(a) do\n      s = s .. i .. \"|\"\n    end\n    return s\n\
    \  end\n  local s = gen_pattern(b)\n  s = string.sub(s, 1, string.len(s) - 1)\n\
    \  return string.find(a, s) ~= nil\nend", "  local str = a\n  local pattern =\
    \ b\n  local pattern_start = 0\n  local pattern_end = #pattern\n  local str_start\
    \ = 0\n  local str_end = #str\n  for i = 1, #str do\n    str_start = str_start\
    \ + 1\n    str_end = str_end + 1\n    if str_end > #str then\n      str_end =\
    \ 1\n    end\n    local sub_str = str:sub(str_start, str_end)\n    -- check if\
    \ the substring matches the pattern\n    local found = 0\n    for j = 1, #sub_str\
    \ do\n      if sub_str:sub(j, j) == pattern:sub(j, j) then\n        found = found\
    \ + 1\n      end\n    end\n    if found == #pattern then\n      return true\n\
    \    end\n  end\n  return false\nend", "    if #a == #b then\n        return a:find(b)\
    \ or b:find(a)\n    end\n    return false\nend", "    if not a or not b then return\
    \ false end\n    local first, second = a:gsub(\"%s+\", \"\"), b:gsub(\"%s+\",\
    \ \"\")\n    if #first == 0 or #second == 0 then return false end\n    if #first\
    \ < #second then return false end\n    for i = 1, #first do\n        local first_start,\
    \ first_end = (i - 1), (i + #second - 1)\n        local sub = first:sub(first_start,\
    \ first_end)\n        if sub == second then return true end\n    end\n    return\
    \ false\nend", "    local len = #b\n    for i = 1, len do\n        local s = string.sub(b,\
    \ i, len) .. string.sub(b, 1, i - 1)\n        if string.find(a, s) then\n    \
    \        return true\n        end\n    end\n    return false\nend", "  return\
    \ false\nend", "\tlocal a_len = #a\n\tlocal b_len = #b\n\tlocal full_b = b..b\n\
    \tlocal len = a_len - b_len + 1\n\tfor i = 1, len do\n\t\tif a:sub(i, i + b_len\
    \ - 1) == b then\n\t\t\treturn true\n\t\tend\n\tend\n\tfor i = 1, len do\n\t\t\
    if a:sub(i, i + b_len - 1) == full_b:sub(1, b_len) then\n\t\t\treturn true\n\t\
    \tend\n\tend\n\treturn false\nend", "    return a:find(b)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
