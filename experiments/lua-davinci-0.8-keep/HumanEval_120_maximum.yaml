name: HumanEval_120_maximum
language: lua
prompt: "-- Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n-- of length k with the maximum k numbers in arr.\n-- Example 1:\n-- Input:\
  \ arr = [-3, -4, 5], k = 3\n-- Output: [-4, -3, 5]\n-- Example 2:\n-- Input: arr\
  \ = [4, -4, 4], k = 2\n-- Output: [4, 4]\n-- Example 3:\n-- Input: arr = [-3, 2,\
  \ 1, 2, -1, -2, 1], k = 1\n-- Output: [2]\n-- Note:\n-- 1. The length of the array\
  \ will be in the range of [1, 1000].\n-- 2. The elements in the array will be in\
  \ the range of [-1000, 1000].\n-- 3. 0 <= k <= len(arr)\nlocal function maximum(arr,\
  \ k)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = maximum\n\
  \    lu.assertEquals(candidate({-3, -4, 5}, 3), {-4, -3, 5})\n    lu.assertEquals(candidate({4,\
  \ -4, 4}, 2), {4, 4})\n    lu.assertEquals(candidate({-3, 2, 1, 2, -1, -2, 1}, 1),\
  \ {2})\n    lu.assertEquals(candidate({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20,\
  \ 123})\n    lu.assertEquals(candidate({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20})\n\
  \    lu.assertEquals(candidate({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3,\
  \ 5, 15})\n    lu.assertEquals(candidate({-1, 0, 2, 5, 3, -10}, 2), {3, 5})\n  \
  \  lu.assertEquals(candidate({1, 0, 5, -7}, 1), {5})\n    lu.assertEquals(candidate({4,\
  \ -4}, 2), {-4, 4})\n    lu.assertEquals(candidate({-10, 10}, 2), {-10, 10})\n \
  \   lu.assertEquals(candidate({1, 2, 3, -23, 243, -400, 0}, 0), {})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    table.sort(arr)\n    local ret = {}\n    for i = #arr, #arr - k\
    \ + 1, -1 do\n        table.insert(ret, arr[i])\n    end\n    return ret\nend",
  "    local n = #arr\n    if n == 0 then return {} end\n    if k == 0 then return\
    \ {} end\n    if k == 1 then return {math.max(unpack(arr))} end\n    if k == n\
    \ then return arr end\n    local heap = {}\n    local function push(x)\n     \
    \   table.insert(heap, x)\n        local i = #heap\n        while i > 1 do\n \
    \           local j = math.floor(i / 2)\n            if heap[j] < heap[i] then\n\
    \                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n\
    \            else\n                break\n            end\n        end\n    end\n\
    \    local function pop()\n        local res = heap[1]\n        heap[1] = heap[#heap]\n\
    \        table.remove(heap)\n        local i = 1\n        while i * 2 <= #heap\
    \ do\n            local l = i * 2\n            local r = i * 2 + 1\n         \
    \   local j = l\n            if r <= #heap and heap[r] > heap[l] then\n      \
    \          j = r\n            end\n            if heap[i] < heap[j] then\n   \
    \             heap[i], heap[j] = heap[j], heap[i]\n                i = j\n   \
    \         else\n                break\n            end\n        end\n        return\
    \ res\n    end\n    for i = 1, k do\n        push(arr[i])\n    end\n    for i\
    \ = k + 1, n do\n        if arr[i] > heap[1] then\n            pop()\n       \
    \     push(arr[i])\n        end\n    end\n    local res = {}\n    for i = 1, k\
    \ do\n        table.insert(res, 1, pop())\n    end\n    return res\nend", "  \
    \  table.sort(arr)\n    return arr\nend", "    table.sort(arr)\n    local result\
    \ = {}\n    for i = #arr, #arr - k + 1, -1 do\n        table.insert(result, arr[i])\n\
    \    end\n    return result\nend", "    local function partition(left, right)\n\
    \        local pivot = arr[left]\n        local l = left + 1\n        local r\
    \ = right\n        while l <= r do\n            if arr[l] < pivot and arr[r] >\
    \ pivot then\n                arr[l], arr[r] = arr[r], arr[l]\n              \
    \  l = l + 1\n                r = r - 1\n            end\n            if arr[l]\
    \ >= pivot then\n                l = l + 1\n            end\n            if arr[r]\
    \ <= pivot then\n                r = r - 1\n            end\n        end\n   \
    \     arr[left], arr[r] = arr[r], arr[left]\n        return r\n    end\n    local\
    \ function quickSelect(left, right, k)\n        if left >= right then\n      \
    \      return\n        end\n        local idx = partition(left, right)\n     \
    \   if idx == k then\n            return\n        elseif idx < k then\n      \
    \      quickSelect(idx + 1, right, k)\n        else\n            quickSelect(left,\
    \ idx - 1, k)\n        end\n    end\n    quickSelect(1, #arr, #arr - k + 1)\n\
    \    local ret = {}\n    for i = #arr - k + 1, #arr do\n        ret[#ret + 1]\
    \ = arr[i]\n    end\n    return ret\nend\nreturn maximum", "\ttable.sort(arr)\n\
    \tlocal result = {}\n\tfor i = #arr - k + 1, #arr do\n\t\ttable.insert(result,\
    \ arr[i])\n\tend\n\treturn result\nend", "    local len = #arr\n    if k > len\
    \ then\n        k = len\n    end\n    local tmp = {}\n    for i = 1, len do\n\
    \        table.insert(tmp, arr[i])\n    end\n    table.sort(tmp, function(a, b)\
    \ return a > b end)\n    local res = {}\n    for i = 1, k do\n        table.insert(res,\
    \ tmp[i])\n    end\n    return res\nend\nreturn maximum", "    table.sort(arr)\n\
    \    local result = {}\n    for i = 1, k do\n        result[i] = arr[#arr - i\
    \ + 1]\n    end\n    return result\nend\nreturn maximum", "    local len = #arr\n\
    \    if k == len then\n        table.sort(arr)\n        return arr\n    end\n\
    \    local function helper(left, right)\n        if left == right then\n     \
    \       return left\n        end\n        local pivot = math.random(left, right)\n\
    \        swap(arr, left, pivot)\n        local m = left\n        for i = left\
    \ + 1, right do\n            if arr[i] >= arr[left] then\n                m =\
    \ m + 1\n                swap(arr, m, i)\n            end\n        end\n     \
    \   swap(arr, left, m)\n        if m == k then\n            return m\n       \
    \ elseif m < k then\n            return helper(m + 1, right)\n        else\n \
    \           return helper(left, m - 1)\n        end\n    end\n    helper(1, len)\n\
    \    local res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n    end\n \
    \   return res\nend", "    table.sort(arr)\n    local res = {}\n    for i = #arr,\
    \ #arr - k + 1, -1 do\n        table.insert(res, arr[i])\n    end\n    return\
    \ res\nend", "    local size = #arr\n    local max = {0, 0}\n    for i = 1, k\
    \ do\n        max[1] = math.max(max[1], arr[i])\n        max[2] = i\n    end\n\
    \    for i = k + 1, size do\n        if arr[i] > max[1] then\n            max[1]\
    \ = arr[i]\n            max[2] = i\n        end\n    end\n    local result = {max[1]}\n\
    \    for i = 1, k - 1 do\n        local max_next = {0, 0}\n        for j = 1,\
    \ size do\n            if j ~= max[2] and arr[j] > max_next[1] then\n        \
    \        max_next[1] = arr[j]\n                max_next[2] = j\n            end\n\
    \        end\n        max = max_next\n        result[i + 1] = max[1]\n    end\n\
    \    return result\nend", "  table.sort(arr)\n  local res = {}\n  for i = #arr,\
    \ #arr - k + 1, -1 do\n    table.insert(res, arr[i])\n  end\n  return res\nend",
  "    local p = partition(arr, 0, #arr - 1)\n    while p ~= k - 1 do\n        if\
    \ p > k - 1 then\n            p = partition(arr, 0, p - 1)\n        else\n   \
    \         p = partition(arr, p + 1, #arr - 1)\n        end\n    end\n    return\
    \ copy(arr, 1, k)\nend", "  local t = {}\n  for i = 1, k do\n    local max = math.mininteger\n\
    \    local max_i = 0\n    for j = 1, #arr do\n      if arr[j] > max then\n   \
    \     max = arr[j]\n        max_i = j\n      end\n    end\n    t[i] = max\n  \
    \  table.remove(arr, max_i)\n  end\n  return t\nend", "    if #arr == k then\n\
    \        return arr\n    end\n    table.sort(arr)\n    local res = {}\n    for\
    \ i = #arr, #arr - k + 1, -1 do\n        table.insert(res, arr[i])\n    end\n\
    \    return res\nend", "    local buf = {}\n    for i, v in ipairs(arr) do\n \
    \       if #buf < k then\n            buf[#buf + 1] = v\n        else\n      \
    \      table.sort(buf)\n            if v > buf[1] then\n                buf[1]\
    \ = v\n            end\n        end\n    end\n    table.sort(buf)\n    return\
    \ buf\nend", "    table.sort(arr)\n    local result = {}\n    for i = #arr, #arr\
    \ - k + 1, -1 do\n        table.insert(result, arr[i])\n    end\n    return result\n\
    end", "    local data = {}\n    for i, v in ipairs(arr) do\n        data[i] =\
    \ v\n    end\n    local function l_heapify(a, i, length)\n        local left,\
    \ right = 2 * i, 2 * i + 1\n        local largest = i\n        if left <= length\
    \ and a[left] > a[largest] then\n            largest = left\n        end\n   \
    \     if right <= length and a[right] > a[largest] then\n            largest =\
    \ right\n        end\n        if largest ~= i then\n            a[i], a[largest]\
    \ = a[largest], a[i]\n            l_heapify(a, largest, length)\n        end\n\
    \    end\n    local function build_heap(a, length)\n        for i = math.floor(length\
    \ / 2), 1, -1 do\n            l_heapify(a, i, length)\n        end\n    end\n\
    \    local function l_heapsort(a, length)\n        for i = length, 2, -1 do\n\
    \            a[1], a[i] = a[i], a[1]\n            l_heapify(a, 1, i - 1)\n   \
    \     end\n    end\n    build_heap(data, #data)\n    l_heapsort(data, #data)\n\
    \    local ret = {}\n    for i = 1, k do\n        ret[i] = data[i]\n    end\n\
    \    return ret\nend", "    local function heapInsert(arr, value)\n        local\
    \ n = #arr\n        arr[n + 1] = value\n        local i = n + 1\n        while\
    \ i > 1 do\n            local j = math.floor(i / 2)\n            if arr[j] < arr[i]\
    \ then\n                arr[i], arr[j] = arr[j], arr[i]\n                i = j\n\
    \            else\n                break\n            end\n        end\n    end\n\
    \    local function heapShift(arr)\n        local n = #arr\n        arr[1], arr[n]\
    \ = arr[n], arr[1]\n        arr[n] = nil\n        local i = 1\n        while i\
    \ < n do\n            local j = i * 2\n            if j < n then\n           \
    \     if j + 1 < n and arr[j + 1] > arr[j] then\n                    j = j + 1\n\
    \                end\n                if arr[i] < arr[j] then\n              \
    \      arr[i], arr[j] = arr[j], arr[i]\n                    i = j\n          \
    \      else\n                    break\n                end\n            else\n\
    \                break\n            end\n        end\n    end\n    local res =\
    \ {}\n    for _, value in ipairs(arr) do\n        if #res < k then\n         \
    \   heapInsert(res, value)\n        else\n            if value > res[1] then\n\
    \                heapShift(res)\n                heapInsert(res, value)\n    \
    \        end\n        end\n    end\n    return res\nend", "    if k == 1 then\n\
    \        local r, max = 1, arr[1]\n        for i = 2, #arr do\n            if\
    \ arr[i] > max then\n                r, max = i, arr[i]\n            end\n   \
    \     end\n        return {arr[r]}\n    end\n    local m = math.floor(k / 2)\n\
    \    local pivot = arr[m]\n    local i, j = 1, #arr\n    while i <= j do\n   \
    \     while i <= j and arr[i] >= pivot do\n            i = i + 1\n        end\n\
    \        while i <= j and arr[j] < pivot do\n            j = j - 1\n        end\n\
    \        if i <= j then\n            arr[i], arr[j] = arr[j], arr[i]\n       \
    \     i = i + 1\n            j = j - 1\n        end\n    end\n    if j >= k then\n\
    \        return maximum(arr, k)\n    elseif j >= k - 1 then\n        return {pivot,\
    \ unpack(maximum(arr, k - 1))}\n    else\n        return {unpack(maximum(arr,\
    \ k - j - 1)), pivot, unpack(arr, 1, j)}\n    end\nend", "    table.sort(arr)\n\
    \    local results = {}\n    for i=1,k do\n        results[i] = arr[#arr - i +\
    \ 1]\n    end\n    return results\nend", "    local function partition(arr, l,\
    \ r)\n        local pivot = arr[r]\n        local index = l\n        for i = l,\
    \ r - 1 do\n            if arr[i] > pivot then\n                arr[i], arr[index]\
    \ = arr[index], arr[i]\n                index = index + 1\n            end\n \
    \       end\n        arr[index], arr[r] = arr[r], arr[index]\n        return index\n\
    \    end\n    local function quickSelect(arr, l, r, k)\n        if l == r then\n\
    \            return arr[l]\n        end\n        local p = partition(arr, l, r)\n\
    \        if p == k then\n            return arr[p]\n        elseif p > k then\n\
    \            return quickSelect(arr, l, p - 1, k)\n        else\n            return\
    \ quickSelect(arr, p + 1, r, k)\n        end\n    end\n    local res = {}\n  \
    \  for i = 1, k do\n        res[i] = quickSelect(arr, 1, #arr, i)\n    end\n \
    \   return res\nend", "    local function partition(lo, hi)\n        local pivot\
    \ = arr[hi]\n        local i = lo\n        for j = lo, hi - 1 do\n           \
    \ if arr[j] > pivot then\n                arr[i], arr[j] = arr[j], arr[i]\n  \
    \              i = i + 1\n            end\n        end\n        arr[i], arr[hi]\
    \ = arr[hi], arr[i]\n        return i\n    end\n    local function qsort(lo, hi)\n\
    \        if lo < hi then\n            local p = partition(lo, hi)\n          \
    \  if p > k then\n                qsort(lo, p - 1)\n            elseif p < k then\n\
    \                qsort(p + 1, hi)\n            end\n        end\n    end\n   \
    \ qsort(1, #arr)\n    return {table.unpack(arr, 1, k)}\nend", "    if not arr\
    \ or k < 1 or k > #arr then\n        return {}\n    end\n    local heap = {}\n\
    \    for i, v in ipairs(arr) do\n        heap[i] = v\n        local p = math.floor(i\
    \ / 2)\n        local j = i\n        while p > 0 and heap[p] < heap[j] do\n  \
    \          heap[p], heap[j] = heap[j], heap[p]\n            j = p\n          \
    \  p = math.floor(p / 2)\n        end\n    end\n    local ans = {}\n    for i\
    \ = 1, k do\n        ans[i] = heap[1]\n        heap[1] = heap[#heap]\n       \
    \ heap[#heap] = nil\n        local j = 1\n        while j * 2 <= #heap do\n  \
    \          local c = j * 2\n            if c + 1 <= #heap and heap[c + 1] > heap[c]\
    \ then\n                c = c + 1\n            end\n            if heap[j] >=\
    \ heap[c] then\n                break\n            end\n            heap[j], heap[c]\
    \ = heap[c], heap[j]\n            j = c\n        end\n    end\n    return ans\n\
    end", "    local res = {}\n    for i = 1, k do\n        res[i] = -1000\n    end\n\
    \    for i = 1, #arr do\n        local j = 1\n        while j <= k do\n      \
    \      if arr[i] > res[j] then\n                for l = k, j + 1, -1 do\n    \
    \                res[l] = res[l - 1]\n                end\n                res[j]\
    \ = arr[i]\n                break\n            end\n            j = j + 1\n  \
    \      end\n    end\n    return res\nend", "    local max = {}\n    for i = 1,\
    \ k do\n        max[i] = arr[i]\n    end\n    table.sort(max)\n    for i = k +\
    \ 1, #arr do\n        if arr[i] > max[1] then\n            max[1] = arr[i]\n \
    \           table.sort(max)\n        end\n    end\n    return max\nend", "   \
    \ local n = #arr\n    local j = 0\n    for i = 1, n - 1 do\n        if arr[i]\
    \ > arr[i + 1] then\n            j = i\n            break\n        end\n    end\n\
    \    if j == 0 then\n        return arr\n    end\n    while k < j do\n       \
    \ local index = j\n        for i = j - 1, k, -1 do\n            if arr[i] > arr[index]\
    \ then\n                index = i\n            end\n        end\n        arr[j],\
    \ arr[index] = arr[index], arr[j]\n        j = index\n    end\n    return arr\n\
    end", "    local res = {}\n    for i = 1, k do\n        local max = -math.huge\n\
    \        local index = 1\n        for j = 1, #arr do\n            if arr[j] >\
    \ max then\n                max = arr[j]\n                index = j\n        \
    \    end\n        end\n        table.insert(res, max)\n        table.remove(arr,\
    \ index)\n    end\n    return res\nend", "    local n = #arr\n    if n == 0 then\
    \ return {} end\n    if k == 0 then return {} end\n    if k >= n then\n      \
    \  table.sort(arr)\n        return arr\n    end\n    local l, r = 1, n\n    local\
    \ ret = {}\n    while l <= r do\n        local mid = (l + r) >> 1\n        if\
    \ mid == n or arr[mid] < arr[mid + 1] then\n            for j = mid, n do\n  \
    \              table.insert(ret, arr[j])\n            end\n            for i =\
    \ 1, n - mid do\n                for j = #ret, 2, -1 do\n                    if\
    \ ret[j] < ret[j - 1] then\n                        ret[j], ret[j - 1] = ret[j\
    \ - 1], ret[j]\n                    else\n                        break\n    \
    \                end\n                end\n            end\n            if #ret\
    \ > k then\n                for i = #ret, k + 1, -1 do\n                    table.remove(ret)\n\
    \                end\n            end\n            return ret\n        elseif\
    \ mid == 1 or arr[mid] > arr[mid - 1] then\n            for j = mid, n do\n  \
    \              table.insert(ret, arr[j])\n            end\n            for i =\
    \ 1, n - mid do\n                for j = #ret, 2, -1 do\n                    if\
    \ ret[j] < ret[j - 1] then\n                        ret[j], ret[j - 1] = ret[j\
    \ - 1], ret[j]\n                    else\n                        break\n    \
    \                end\n                end\n            end\n            if #ret\
    \ > k then\n                for i = #ret, k + 1, -1 do\n                    table.remove(ret)\n\
    \                end\n            end\n            return ret\n        else\n\
    \            if arr[mid] > arr[mid + 1] then\n                r = mid - 1\n  \
    \          else\n                l = mid + 1\n            end\n        end\n \
    \   end\nend", "    return table.pack(table.unpack(arr, 1, k))\nend", "    local\
    \ h = {}\n    for i = 1, k do\n        h[#h + 1] = arr[i]\n    end\n    heapify(h)\n\
    \    for i = k + 1, #arr do\n        if arr[i] > h[1] then\n            h[1] =\
    \ arr[i]\n            sift_down(h, 1)\n        end\n    end\n    table.sort(h)\n\
    \    return h\nend", "    local res = {}\n    local p = 1\n    local n = #arr\n\
    \    for i = 1, k do\n        local maxi = -(math.huge)\n        for j = p, n\
    \ do\n            if arr[j] > maxi then\n                maxi = arr[j]\n     \
    \           p = j\n            end\n        end\n        res[i] = maxi\n     \
    \   p = p + 1\n    end\n    return res\nend", "    local len = #arr\n    if k\
    \ == len then\n        return arr\n    end\n    local t, n = {}, 0\n    for i\
    \ = 1, len do\n        if n > 0 and arr[i] > t[n] then\n            t[n] = arr[i]\n\
    \            n = n + 1\n            local c = n\n            while c > 1 do\n\
    \                if t[c] > t[c-1] then\n                    t[c], t[c-1] = t[c-1],\
    \ t[c]\n                    c = c - 1\n                else\n                \
    \    break\n                end\n            end\n        elseif n < k then\n\
    \            t[n] = arr[i]\n            n = n + 1\n            local c = n\n \
    \           while c > 1 do\n                if t[c] > t[c-1] then\n          \
    \          t[c], t[c-1] = t[c-1], t[c]\n                    c = c - 1\n      \
    \          else\n                    break\n                end\n            end\n\
    \        end\n    end\n    return t\nend\nreturn maximum", "    local sorted_arr\
    \ = {}\n    for _, v in ipairs(arr) do\n        local i = 1\n        while i <=\
    \ #sorted_arr and v > sorted_arr[i] do\n            i = i + 1\n        end\n \
    \       table.insert(sorted_arr, i, v)\n    end\n    local max_k = {}\n    for\
    \ i = 1, k do\n        max_k[i] = sorted_arr[i]\n    end\n    return max_k\nend",
  "    table.sort(arr)\n    local res = {}\n    for i = #arr, #arr - k + 1, -1 do\n\
    \        table.insert(res, arr[i])\n    end\n    return res\nend", "    local\
    \ n = #arr\n    if n == 0 then return arr end\n    for i = math.floor(k / 2),\
    \ 1, -1 do\n        adjust(arr, i, k)\n    end\n    for i = k + 1, n do\n    \
    \    if arr[i] > arr[1] then\n            arr[1] = arr[i]\n            adjust(arr,\
    \ 1, k)\n        end\n    end\n    return arr\nend", "    local function quickSort(arr,\
    \ start, finish)\n        if start < finish then\n            local pivot = start\n\
    \            local i = start + 1\n            local j = finish\n            while\
    \ i <= j do\n                while i <= j and arr[i] >= arr[pivot] do\n      \
    \              i = i + 1\n                end\n                while i <= j and\
    \ arr[j] <= arr[pivot] do\n                    j = j - 1\n                end\n\
    \                if i < j then\n                    arr[i], arr[j] = arr[j], arr[i]\n\
    \                end\n            end\n            arr[pivot], arr[j] = arr[j],\
    \ arr[pivot]\n            quickSort(arr, start, j - 1)\n            quickSort(arr,\
    \ j + 1, finish)\n        end\n    end\n    quickSort(arr, 1, #arr)\n    local\
    \ res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n    end\n    return\
    \ res\nend", "    table.sort(arr)\n    local res = {}\n    for i = #arr, #arr\
    \ - k + 1, -1 do\n        table.insert(res, arr[i])\n    end\n    return res\n\
    end", "    table.sort(arr)\n    local res = {}\n    for i = #arr, #arr - k + 1,\
    \ -1 do\n        table.insert(res, arr[i])\n    end\n    return res\nend", " \
    \   local len = #arr\n    if k == len then\n        table.sort(arr)\n        return\
    \ arr\n    end\n    local res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n\
    \    end\n    table.sort(res)\n    for i = k + 1, len do\n        if arr[i] >\
    \ res[1] then\n            table.remove(res, 1)\n            table.insert(res,\
    \ arr[i])\n            table.sort(res)\n        end\n    end\n    return res\n\
    end", "    local index = 1\n    local function partition(low, high)\n        local\
    \ pivot = arr[high]\n        local i = low\n        for j = low, high - 1 do\n\
    \            if arr[j] > pivot then\n                arr[i], arr[j] = arr[j],\
    \ arr[i]\n                i = i + 1\n            end\n        end\n        arr[i],\
    \ arr[high] = arr[high], arr[i]\n        return i\n    end\n    local function\
    \ quickselect(low, high)\n        if low < high then\n            local mid =\
    \ partition(low, high)\n            if index == mid then\n                return\n\
    \            elseif index < mid then\n                quickselect(low, mid - 1)\n\
    \            else\n                quickselect(mid + 1, high)\n            end\n\
    \        end\n    end\n    quickselect(1, #arr)\n    return {table.unpack(arr,\
    \ 1, k)}\nend", "    table.sort(arr)\n    local max = {}\n    for i = 1, k do\n\
    \        max[i] = arr[#arr - i + 1]\n    end\n    return max\nend", "    local\
    \ maxs = {}\n    local cnt = 0\n    for i = 1, #arr do\n        while cnt > 0\
    \ and #maxs >= k and arr[i] > maxs[#maxs] do\n            table.remove(maxs)\n\
    \            cnt = cnt - 1\n        end\n        if cnt < k then\n           \
    \ table.insert(maxs, arr[i])\n            cnt = cnt + 1\n        end\n    end\n\
    \    return maxs\nend", "    local s = {}\n    for i = 1, k do\n        s[i] =\
    \ arr[i]\n    end\n    for i = k + 1, #arr do\n        local m = math.max(table.unpack(s))\n\
    \        if arr[i] > m then\n            for j = 1, k do\n                if s[j]\
    \ == m then\n                    s[j] = arr[i]\n                    break\n  \
    \              end\n            end\n        end\n    end\n    table.sort(s)\n\
    \    return s\nend", "    local heap = {}\n    for i = 1, #arr do\n        if\
    \ i <= k then\n            heap[i] = arr[i]\n        else\n            if arr[i]\
    \ > heap[1] then\n                heap[1] = arr[i]\n            end\n        end\n\
    \        local j = i\n        while j > 1 and heap[j] > heap[j / 2] do\n     \
    \       heap[j], heap[j / 2] = heap[j / 2], heap[j]\n            j = j / 2\n \
    \       end\n    end\n    for i = k, 2, -1 do\n        heap[i], heap[1] = heap[1],\
    \ heap[i]\n        local j = 1\n        while true do\n            local l = j\
    \ * 2\n            local r = l + 1\n            if l > k then\n              \
    \  break\n            elseif r > k then\n                if heap[j] < heap[l]\
    \ then\n                    heap[j], heap[l] = heap[l], heap[j]\n            \
    \    end\n                break\n            else\n                if heap[l]\
    \ > heap[r] then\n                    if heap[j] < heap[l] then\n            \
    \            heap[j], heap[l] = heap[l], heap[j]\n                        j =\
    \ l\n                    else\n                        break\n               \
    \     end\n                else\n                    if heap[j] < heap[r] then\n\
    \                        heap[j], heap[r] = heap[r], heap[j]\n               \
    \         j = r\n                    else\n                        break\n   \
    \                 end\n                end\n            end\n        end\n   \
    \ end\n    return heap\nend", "    local function quick_sort(arr, begin, finish)\n\
    \        if begin < finish then\n            local pivot = math.random(begin,\
    \ finish)\n            arr[pivot], arr[finish] = arr[finish], arr[pivot]\n   \
    \         local idx = begin\n            for i = begin, finish - 1 do\n      \
    \          if arr[i] > arr[finish] then\n                    arr[i], arr[idx]\
    \ = arr[idx], arr[i]\n                    idx = idx + 1\n                end\n\
    \            end\n            arr[idx], arr[finish] = arr[finish], arr[idx]\n\
    \            quick_sort(arr, begin, idx - 1)\n            quick_sort(arr, idx\
    \ + 1, finish)\n        end\n    end\n    local len = #arr\n    quick_sort(arr,\
    \ 1, len)\n    return arr, len\nend", "    table.sort(arr)\n    local res = {}\n\
    \    for i = #arr, #arr - k + 1, -1 do\n        table.insert(res, arr[i])\n  \
    \  end\n    return res\nend", "    local len = #arr\n    if len == 0 then\n  \
    \      return {}\n    end\n    if k == 0 then\n        return {}\n    end\n  \
    \  if k == len then\n        return arr\n    end\n    local res = {}\n    for\
    \ i = 1, k do\n        res[i] = arr[i]\n    end\n    for i = k, len do\n     \
    \   table.sort(res)\n        if arr[i] > res[1] then\n            res[1] = arr[i]\n\
    \        end\n    end\n    table.sort(res)\n    return res\nend", "  local t =\
    \ {}\n  for i = 1, #arr do\n    if #t == 0 then\n      table.insert(t, i)\n  \
    \  else\n      for j = #t, 1, -1 do\n        if arr[t[j]] < arr[i] then\n    \
    \      table.insert(t, j + 1, i)\n          break\n        elseif j == 1 then\n\
    \          table.insert(t, 1, i)\n        end\n      end\n    end\n  end\n  local\
    \ result = {}\n  for i = 1, k do\n    result[i] = arr[t[i]]\n  end\n  return result\n\
    end", "    local function _max(a, b)\n        return a > b\n    end\n    local\
    \ function _min(a, b)\n        return a < b\n    end\n    local function _heapify(arr,\
    \ i, max_or_min)\n        local c = i * 2\n        while c <= #arr do\n      \
    \      if c + 1 <= #arr and max_or_min(arr[c + 1], arr[c]) then\n            \
    \    c = c + 1\n            end\n            if max_or_min(arr[i], arr[c]) then\n\
    \                break\n            end\n            arr[i], arr[c] = arr[c],\
    \ arr[i]\n            i = c\n            c = i * 2\n        end\n    end\n   \
    \ local function _build_heap(arr, max_or_min)\n        for i = #arr / 2, 1, -1\
    \ do\n            _heapify(arr, i, max_or_min)\n        end\n    end\n    local\
    \ function _heap_sort(arr, max_or_min)\n        _build_heap(arr, max_or_min)\n\
    \        for i = #arr, 2, -1 do\n            arr[1], arr[i] = arr[i], arr[1]\n\
    \            _heapify(arr, 1, max_or_min)\n        end\n    end\n    local res\
    \ = {}\n    for i = 1, k do\n        res[i] = arr[i]\n    end\n    _heap_sort(res,\
    \ _max)\n    for i = k + 1, #arr do\n        if arr[i] < res[1] then\n       \
    \     res[1] = arr[i]\n            _heapify(res, 1, _max)\n        end\n    end\n\
    \    _heap_sort(res, _min)\n    return res\nend", "    local len = #arr\n    for\
    \ i = 1, len do\n        for j = i, len do\n            if arr[i] < arr[j] then\n\
    \                arr[i], arr[j] = arr[j], arr[i]\n            end\n        end\n\
    \    end\n    local res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n \
    \   end\n    return res\nend", "    local size = #arr\n    local function quick_sort(arr,\
    \ start, end)\n        if start >= end then\n            return\n        end\n\
    \        local pivot = arr[start]\n        local index = start\n        for i\
    \ = start + 1, end do\n            if arr[i] < pivot then\n                index\
    \ = index + 1\n                arr[i], arr[index] = arr[index], arr[i]\n     \
    \       end\n        end\n        arr[start], arr[index] = arr[index], arr[start]\n\
    \        quick_sort(arr, start, index - 1)\n        quick_sort(arr, index + 1,\
    \ end)\n    end\n    quick_sort(arr, 1, size)\n    return arr\nend", "    local\
    \ len = #arr\n    local idx = len - k + 1\n    local tmp = {}\n    for i = 1,\
    \ len do\n        if i < idx then\n            if arr[i] > arr[i - 1] then\n \
    \               arr[i - 1] = nil\n            else\n                arr[i] = nil\n\
    \            end\n        else\n            table.insert(tmp, arr[i])\n      \
    \  end\n    end\n    table.sort(tmp)\n    for i = #tmp, 1, -1 do\n        table.insert(arr,\
    \ tmp[i])\n    end\n    return arr\nend", "    table.sort(arr)\n    return arr[#arr\
    \ - k + 1], arr[#arr - k + 2], arr[#arr - k + 3]\nend", "    local count = {}\n\
    \    for _, x in ipairs(arr) do\n        count[x] = (count[x] or 0) + 1\n    end\n\
    \    local n = 0\n    for x, c in pairs(count) do\n        if n < k then\n   \
    \         count[x] = nil\n            n = n + c\n        else\n            count[x]\
    \ = nil\n            break\n        end\n    end\n    local res = {}\n    for\
    \ x, c in pairs(count) do\n        for i = 1, c do\n            table.insert(res,\
    \ x)\n        end\n    end\n    return res\nend", "    local function swap(arr,\
    \ i, j)\n        local temp = arr[i]\n        arr[i] = arr[j]\n        arr[j]\
    \ = temp\n    end\n    local function heapify(arr, n, i)\n        local max, l,\
    \ r = i, 2 * i, 2 * i + 1\n        if l <= n and arr[l] > arr[max] then\n    \
    \        max = l\n        end\n        if r <= n and arr[r] > arr[max] then\n\
    \            max = r\n        end\n        if max ~= i then\n            swap(arr,\
    \ i, max)\n            heapify(arr, n, max)\n        end\n    end\n    local function\
    \ heap_sort(arr, n)\n        for i = math.floor(n / 2), 1, -1 do\n           \
    \ heapify(arr, n, i)\n        end\n        for i = n, 2, -1 do\n            swap(arr,\
    \ 1, i)\n            heapify(arr, i - 1, 1)\n        end\n    end\n    heap_sort(arr,\
    \ #arr)\n    local result = {}\n    for i = 1, k do\n        result[i] = arr[i]\n\
    \    end\n    return result\nend", "    return arr\nend", "    local res = {}\n\
    \    local len = #arr\n    for i = 1, len do\n        if #res == 0 then\n    \
    \        table.insert(res, arr[i])\n        else\n            local insert = false\n\
    \            for j = 1, #res do\n                if insert then\n            \
    \        break\n                end\n                if arr[i] >= res[j] then\n\
    \                    table.insert(res, j, arr[i])\n                    insert\
    \ = true\n                end\n            end\n            if not insert then\n\
    \                table.insert(res, arr[i])\n            end\n        end\n   \
    \     if #res > k then\n            table.remove(res)\n        end\n    end\n\
    \    return res\nend\nreturn maximum", "    if #arr == 0 then return {} end\n\
    \    local k = math.min(k, #arr)\n    local r, ri = arr[1], 1\n    for i = 2,\
    \ #arr do\n        if arr[i] > r then r, ri = arr[i], i end\n    end\n    local\
    \ res = {r}\n    table.remove(arr, ri)\n    for i = 1, k - 1 do\n        local\
    \ l = res[#res]\n        local r, ri = arr[1], 1\n        for j = 2, #arr do\n\
    \            if arr[j] > r and arr[j] < l then r, ri = arr[j], j end\n       \
    \ end\n        table.insert(res, r)\n        table.remove(arr, ri)\n    end\n\
    \    return res\nend", "    local size = #arr\n    if size == 0 then\n       \
    \ return {}\n    end\n    if size <= k then\n        table.sort(arr)\n       \
    \ return arr\n    end\n    table.sort(arr)\n    local n = 1\n    for i = 2, size\
    \ do\n        if arr[i] ~= arr[n] then\n            n = n + 1\n            arr[n]\
    \ = arr[i]\n        end\n    end\n    if n == k then\n        return arr\n   \
    \ end\n    if n < k then\n        for i = n + 1, k do\n            arr[i] = nil\n\
    \        end\n        return arr\n    end\n    for i = k + 1, n do\n        arr[i]\
    \ = nil\n    end\n    return arr\nend", "    local function quickselect(arr, l,\
    \ r, k)\n        local oi = math.random(l, r)\n        local pivot = arr[oi]\n\
    \        arr[oi], arr[r] = arr[r], arr[oi]\n        local i = l\n        for j\
    \ = l, r - 1 do\n            if arr[j] >= pivot then\n                arr[i],\
    \ arr[j] = arr[j], arr[i]\n                i = i + 1\n            end\n      \
    \  end\n        arr[i], arr[r] = arr[r], arr[i]\n        if i - l == k - 1 then\n\
    \            return arr[i]\n        elseif i - l > k - 1 then\n            return\
    \ quickselect(arr, l, i - 1, k)\n        else\n            return quickselect(arr,\
    \ i + 1, r, k - (i - l + 1))\n        end\n    end\n    local res = {}\n    for\
    \ i = 1, k do\n        res[i] = quickselect(arr, 1, #arr, i)\n    end\n    return\
    \ res\nend", "\t-- list of sorted elements (top k)\n\tlocal sorted_list = {}\n\
    \tfor _, v in ipairs(arr) do\n\t\tif (#sorted_list < k) then\n\t\t\t-- insert\
    \ element in sorted list\n\t\t\tlocal iserted = false\n\t\t\tfor i, w in ipairs(sorted_list)\
    \ do\n\t\t\t\tif (v > w) then\n\t\t\t\t\ttable.insert(sorted_list, i, v)\n\t\t\
    \t\t\ttable.remove(sorted_list)\n\t\t\t\t\tiserted = true\n\t\t\t\t\tbreak\n\t\
    \t\t\tend\n\t\t\tend\n\t\t\tif (not iserted) then\n\t\t\t\ttable.insert(sorted_list,\
    \ v)\n\t\t\tend\n\t\telse\n\t\t\t-- check if element must be inserted in sorted\
    \ list\n\t\t\tfor i, w in ipairs(sorted_list) do\n\t\t\t\tif (v > w) then\n\t\t\
    \t\t\ttable.insert(sorted_list, i, v)\n\t\t\t\t\ttable.remove(sorted_list)\n\t\
    \t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn sorted_list\n\
    end", "    local cmp = function(a, b) return b[1] < a[1] end\n    table.sort(arr,\
    \ cmp)\n    local res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n   \
    \ end\n    return res\nend", "    local len = #arr\n    local tmp = {}\n    for\
    \ i = 1, len do\n        table.insert(tmp, arr[i])\n    end\n    table.sort(tmp)\n\
    \    local res = {}\n    for i = 1, k do\n        table.insert(res, tmp[len -\
    \ i + 1])\n    end\n    return res\nend", "    local function qsort(arr, start,\
    \ stop)\n        if start >= stop then\n            return arr\n        end\n\
    \        local mid = start\n        for i = start, stop do\n            if arr[i]\
    \ > arr[stop] then\n                arr[i], arr[mid] = arr[mid], arr[i]\n    \
    \            mid = mid + 1\n            end\n        end\n        arr[mid], arr[stop]\
    \ = arr[stop], arr[mid]\n        qsort(arr, start, mid - 1)\n        qsort(arr,\
    \ mid + 1, stop)\n        return arr\n    end\n    qsort(arr, 1, #arr)\n    return\
    \ arr[1], arr[2], arr[3]\nend", "    local len = #arr\n    if len == 0 then\n\
    \        return {}\n    end\n    if k == len then\n        table.sort(arr)\n \
    \       return arr\n    end\n    table.sort(arr, function(a, b) return a > b end)\n\
    \    local r = {}\n    for i = 1, k do\n        r[i] = arr[i]\n    end\n    return\
    \ r\nend", "    local length = #arr\n    if length == 0 then\n        return {}\n\
    \    end\n    if k == 0 then\n        return {}\n    end\n    if k == length then\n\
    \        return arr\n    end\n    local pos = 1\n    local stack = {}\n    local\
    \ function isempty()\n        return pos == 1\n    end\n    local function top()\n\
    \        return stack[pos - 1]\n    end\n    local function push(v)\n        stack[pos]\
    \ = v\n        pos = pos + 1\n    end\n    local function pop()\n        pos =\
    \ pos - 1\n        return stack[pos]\n    end\n    local function peek()\n   \
    \     return stack[pos]\n    end\n    for i = 1, length do\n        local j =\
    \ i\n        while not isempty() and arr[j] > peek() do\n            pop()\n \
    \       end\n        push(arr[j])\n    end\n    local result = {}\n    for i =\
    \ 1, k do\n        result[i] = pop()\n    end\n    return result\nend", "    for\
    \ i = 1, k do\n        for j = i + 1, #arr do\n            if arr[i] < arr[j]\
    \ then\n                arr[i], arr[j] = arr[j], arr[i]\n            end\n   \
    \     end\n    end\n    return arr\nend", "    if #arr == 0 then return {} end\n\
    \    local heap = {}\n    for i = 1, k do\n        table.insert(heap, arr[i])\n\
    \    end\n    for i = k, #arr do\n        if arr[i] > heap[1] then\n         \
    \   heap[1] = arr[i]\n            heap = f.heapify(heap, 1, k)\n        end\n\
    \    end\n    table.sort(heap)\n    return heap\nend", "    local len = #arr\n\
    \    if k == len then\n        table.sort(arr)\n        return arr\n    end\n\
    \    local function swap(nums, i, j)\n        local t = nums[i]\n        nums[i]\
    \ = nums[j]\n        nums[j] = t\n    end\n    local function partition(nums,\
    \ s, e)\n        local pivot = nums[e]\n        local i = s\n        local j =\
    \ s\n        while j < e do\n            if nums[j] <= pivot then\n          \
    \      swap(nums, i, j)\n                i = i + 1\n            end\n        \
    \    j = j + 1\n        end\n        swap(nums, i, e)\n        return i\n    end\n\
    \    local function quickselect(nums, s, e, k)\n        if s < e then\n      \
    \      local pivot = partition(nums, s, e)\n            if pivot == k then\n \
    \               return\n            elseif pivot < k then\n                quickselect(nums,\
    \ pivot + 1, e, k)\n            else\n                quickselect(nums, s, pivot\
    \ - 1, k)\n            end\n        end\n    end\n    quickselect(arr, 1, len,\
    \ len - k + 1)\n    return arr\nend", "    local len = #arr\n    local hi = len\
    \ - 1\n    local lo = 0\n    while lo < hi do\n        local j = partition(arr,\
    \ lo, hi)\n        if j < k then\n            lo = j + 1\n        elseif j > k\
    \ then\n            hi = j - 1\n        else\n            break\n        end\n\
    \    end\n    local result = {}\n    for i = 1, k do\n        result[i] = arr[i]\n\
    \    end\n    return result\nend", "    local buf = {}\n    for i = 1, #arr do\n\
    \        if #buf == 0 then\n            table.insert(buf, arr[i])\n        else\n\
    \            if #buf == k then\n                if arr[i] > buf[#buf] then\n \
    \                   table.remove(buf)\n                    table.insert(buf, arr[i])\n\
    \                end\n            else\n                if arr[i] < buf[#buf]\
    \ then\n                    table.insert(buf, arr[i])\n                else\n\
    \                    local index = 0\n                    for j = 1, #buf do\n\
    \                        if arr[i] > buf[j] then\n                           \
    \ index = j\n                            break\n                        end\n\
    \                    end\n                    if index > 0 then\n            \
    \            table.insert(buf, index, arr[i])\n                    else\n    \
    \                    table.insert(buf, arr[i])\n                    end\n    \
    \            end\n            end\n        end\n    end\n    return buf\nend",
  "    table.sort(arr)\n    local res = {}\n    for i = #arr, #arr - k + 1, -1 do\n\
    \        table.insert(res, arr[i])\n    end\n    return res\nend", "    local\
    \ tmp = {}\n    for i = 1, #arr do\n        tmp[#tmp + 1] = arr[i]\n        for\
    \ j = #tmp - 1, 1, -1 do\n            if tmp[j] < tmp[j + 1] then\n          \
    \      tmp[j], tmp[j + 1] = tmp[j + 1], tmp[j]\n            else\n           \
    \     break\n            end\n        end\n    end\n    local res = {}\n    for\
    \ i = 1, k do\n        res[#res + 1] = tmp[i]\n    end\n    return res\nend",
  "    local heap = {\n        { -arr[1], 1 },\n    }\n    local r = {}\n    local\
    \ i = 1\n    while i <= k do\n        local v, idx = table.unpack(heap[1])\n \
    \       table.remove(heap, 1)\n        r[i] = -v\n        idx = idx + 1\n    \
    \    if idx <= #arr then\n            table.insert(heap, { -arr[idx], idx })\n\
    \        end\n        local j = #heap\n        while j > 1 do\n            local\
    \ vj = heap[j][1]\n            local vj1 = heap[j - 1][1]\n            if vj >\
    \ vj1 then\n                heap[j], heap[j - 1] = heap[j - 1], heap[j]\n    \
    \            j = j - 1\n            else\n                break\n            end\n\
    \        end\n        i = i + 1\n    end\n    return r\nend", "    if k == 0 then\
    \ return {} end\n    local res = {}\n    for i = 1, #arr do\n        local j =\
    \ #res\n        while j > 0 and res[j] < arr[i] do\n            j = j - 1\n  \
    \      end\n        if j < k then\n            table.insert(res, j + 1, arr[i])\n\
    \            if #res > k then\n                table.remove(res)\n           \
    \ end\n        end\n    end\n    return res\nend", "    local n = #arr\n    if\
    \ n == 0 then return {} end\n    table.sort(arr)\n    local function binarySearch(arr,\
    \ value)\n        local low, high = 1, #arr\n        while low <= high do\n  \
    \          local mid = math.floor((low + high) / 2)\n            if arr[mid] <\
    \ value then\n                low = mid + 1\n            elseif arr[mid] > value\
    \ then\n                high = mid - 1\n            else\n                return\
    \ mid\n            end\n        end\n        return low\n    end\n    local res\
    \ = {}\n    for i = 1, k do\n        res[i] = arr[i]\n    end\n    for i = k +\
    \ 1, n do\n        local idx = binarySearch(res, arr[i])\n        if idx <= k\
    \ then\n            table.insert(res, idx, arr[i])\n            table.remove(res)\n\
    \        end\n    end\n    return res\nend", "    local len = #arr\n    local\
    \ h = {}\n    local function insert(h, x)\n        local i = 1\n        while\
    \ i <= k and h[i] do\n            if x > h[i] then\n                break\n  \
    \          end\n            i = i + 1\n        end\n        if i > k then\n  \
    \          return false\n        end\n        if h[i] then\n            for j\
    \ = k, i + 1, -1 do\n                h[j] = h[j - 1]\n            end\n      \
    \  end\n        h[i] = x\n        return true\n    end\n    for i = 1, k do\n\
    \        h[i] = arr[i]\n    end\n    for i = k + 1, len do\n        insert(h,\
    \ arr[i])\n    end\n    table.sort(h)\n    return h\nend", "    if not arr or\
    \ k <= 0 then\n        return {}\n    end\n    if k >= #arr then\n        table.sort(arr)\n\
    \        return arr\n    end\n    local result = {}\n    for i = 1, k do\n   \
    \     result[i] = arr[i]\n    end\n    table.sort(result)\n    for i = k + 1,\
    \ #arr do\n        if arr[i] > result[1] then\n            result[1] = arr[i]\n\
    \            table.sort(result)\n        end\n    end\n    return result\nend",
  "    local k = k or 1\n    local size = #arr\n    if size == 0 then\n        return\
    \ {}\n    end\n    if size == 1 then\n        return {arr[1]}\n    end\n    local\
    \ max = math.max\n    local res = {}\n    for i = 1, k do\n        local entry\
    \ = i\n        local num = arr[i]\n        for j = i + 1, size do\n          \
    \  if arr[j] > num then\n                entry = j\n                num = arr[j]\n\
    \            end\n        end\n        for j = entry, i + 1, -1 do\n         \
    \   arr[j] = arr[j - 1]\n        end\n        arr[i] = num\n        res[i] = num\n\
    \    end\n    return res\nend", "    if k == 0 then return {} end\n    local function\
    \ helper(arr, i, j, k)\n        if i == j then return {arr[i]} end\n        local\
    \ p = math.random(i, j)\n        local a = {arr[p]}\n        local l, r = i, j\n\
    \        while l <= r do\n            while l <= r and arr[l] >= arr[p] do l =\
    \ l + 1 end\n            while l <= r and arr[r] <= arr[p] do r = r - 1 end\n\
    \            if l <= r then\n                arr[l], arr[r] = arr[r], arr[l]\n\
    \                l = l + 1\n                r = r - 1\n            end\n     \
    \   end\n        local a1 = helper(arr, i, r, k - #a)\n        for _, v in ipairs(a1)\
    \ do\n            table.insert(a, v)\n        end\n        if #a >= k then return\
    \ a end\n        local a2 = helper(arr, l, j, k - #a)\n        for _, v in ipairs(a2)\
    \ do\n            table.insert(a, v)\n        end\n        return a\n    end\n\
    \    return helper(arr, 1, #arr, k)\nend", "    table.sort(arr)\n    local res\
    \ = {}\n    for i = #arr, #arr - k + 1, -1 do\n        table.insert(res, arr[i])\n\
    \    end\n    return res\nend", "\ttable.sort(arr)\n\tlocal res = {}\n\tfor i\
    \ = #arr - k + 1, #arr do\n\t\ttable.insert(res, arr[i])\n\tend\n\treturn res\n\
    end", "    local heap = {}\n    for i = 1, k do\n        heap[i] = arr[i]\n  \
    \  end\n    table.sort(heap)\n    for i = k + 1, #arr do\n        if arr[i] >\
    \ heap[1] then\n            heap[1] = arr[i]\n            table.sort(heap)\n \
    \       end\n    end\n    return heap\nend", "  local min = 0\n  local max = #arr\n\
    \  local count = 0\n  local i = 1\n  local res = {}\n  while i <= #arr do\n  \
    \  if arr[i] < 0 then\n      i = i + 1\n    else\n      count = count + 1\n  \
    \    if count == k then\n        local j = 1\n        while j <= i do\n      \
    \    table.insert(res, arr[j])\n          j = j + 1\n        end\n        table.sort(res)\n\
    \        return res\n      end\n      i = i + 1\n    end\n  end\n  if count <\
    \ k then\n    return arr\n  end\nend", "    if k > #arr then\n        table.sort(arr)\n\
    \        return arr\n    end\n    table.sort(arr, function(a, b) return math.abs(a)\
    \ > math.abs(b) end)\n    return {table.unpack(arr, 1, k)}\nend", "  local pq\
    \ = PriorityQueue:new()\n  for _, e in ipairs(arr) do\n    pq:push(e)\n    if\
    \ pq:size() > k then\n      pq:pop()\n    end\n  end\n  local ret = {}\n  while\
    \ not pq:empty() do\n    ret[#ret + 1] = pq:pop()\n  end\n  return ret\nend",
  "    local function partition(arr, lo, hi)\n        local v = arr[lo]\n        local\
    \ i, j = lo, hi\n        while i < j do\n            while i < j and arr[j] >=\
    \ v do\n                j = j - 1\n            end\n            arr[i] = arr[j]\n\
    \            while i < j and arr[i] <= v do\n                i = i + 1\n     \
    \       end\n            arr[j] = arr[i]\n        end\n        arr[i] = v\n  \
    \      return i\n    end\n    local function randomized_partition(arr, lo, hi)\n\
    \        local r = math.random(lo, hi)\n        arr[lo], arr[r] = arr[r], arr[lo]\n\
    \        return partition(arr, lo, hi)\n    end\n    local function randomized_select(arr,\
    \ lo, hi, k)\n        if lo == hi then\n            return arr[lo]\n        end\n\
    \        local mid = randomized_partition(arr, lo, hi)\n        local left_len\
    \ = mid - lo + 1\n        if left_len == k then\n            return arr[mid]\n\
    \        elseif left_len > k then\n            return randomized_select(arr, lo,\
    \ mid - 1, k)\n        else\n            return randomized_select(arr, mid + 1,\
    \ hi, k - left_len)\n        end\n    end\n    local max = randomized_select(arr,\
    \ 1, #arr, k)\n    local res = {}\n    for i = 1, #arr do\n        if arr[i] >=\
    \ max then\n            res[#res + 1] = arr[i]\n        end\n    end\n    table.sort(res)\n\
    \    return res\nend", "    local len = #arr\n    if k >= len then return arr\
    \ end\n    local max = math.max\n    for i = 1, len do\n        local v = arr[i]\n\
    \        for j = i + 1, len do\n            if arr[j] > v then\n             \
    \   v, arr[j] = arr[j], v\n            end\n        end\n        arr[i] = v\n\
    \    end\n    return arr\nend", "    local ret = {}\n    for i = 1, k do\n   \
    \     local m = arr[i]\n        local mi = i\n        for j = i + 1, #arr do\n\
    \            if arr[j] > m then\n                m = arr[j]\n                mi\
    \ = j\n            end\n        end\n        ret[i] = m\n        arr[mi] = arr[i]\n\
    \        arr[i] = m\n    end\n    return ret\nend", "    local t = {}\n    for\
    \ i, v in ipairs(arr) do\n        if #t < k then\n            table.insert(t,\
    \ v)\n        else\n            table.sort(t)\n            if v > t[1] then\n\
    \                table.remove(t, 1)\n                table.insert(t, v)\n    \
    \        end\n        end\n    end\n    table.sort(t)\n    return t\nend", " \
    \   local function partition(arr, start, finish)\n        local pivot = arr[finish]\n\
    \        local i = start - 1\n        for j = start, finish - 1 do\n         \
    \   if arr[j] > pivot then\n                i = i + 1\n                arr[i],\
    \ arr[j] = arr[j], arr[i]\n            end\n        end\n        arr[i + 1], arr[finish]\
    \ = arr[finish], arr[i + 1]\n        return i + 1\n    end\n    local start, finish\
    \ = 1, #arr\n    while start <= finish do\n        local pivot = partition(arr,\
    \ start, finish)\n        if pivot == k then\n            break\n        elseif\
    \ pivot < k then\n            start = pivot + 1\n        else\n            finish\
    \ = pivot - 1\n        end\n    end\n    return arr\nend", "    local function\
    \ get(i, j)\n        local v = 0\n        if i >= 0 and i < #arr then\n      \
    \      v = arr[i]\n        end\n        if j >= 0 and j < #arr then\n        \
    \    v = math.max(v, arr[j])\n        end\n        return v\n    end\n    local\
    \ function min(a, b)\n        return (a < b) and a or b\n    end\n    local n\
    \ = #arr\n    for i = 1, k do\n        local max = math.maxinteger\n        local\
    \ j = -1\n        for m = math.max(0, i - n), min(i, n - 1) do\n            local\
    \ v = get(i - m - 1, i + m - 1)\n            if v > max then\n               \
    \ max = v\n                j = m\n            end\n        end\n        table.insert(arr,\
    \ i, arr[i - j - 1])\n        table.remove(arr, i - j)\n    end\n    return arr\n\
    end", "\tlocal function qsort(arr, lo, hi)\n\t\tif lo < hi then\n\t\t\tlocal i,\
    \ j = lo, hi\n\t\t\tlocal tmp = arr[i]\n\t\t\twhile i < j do\n\t\t\t\twhile i\
    \ < j and arr[j] < tmp do\n\t\t\t\t\tj = j - 1\n\t\t\t\tend\n\t\t\t\tif i < j\
    \ then\n\t\t\t\t\tarr[i] = arr[j]\n\t\t\t\t\ti = i + 1\n\t\t\t\tend\n\t\t\t\t\
    while i < j and arr[i] > tmp do\n\t\t\t\t\ti = i + 1\n\t\t\t\tend\n\t\t\t\tif\
    \ i < j then\n\t\t\t\t\tarr[j] = arr[i]\n\t\t\t\t\tj = j - 1\n\t\t\t\tend\n\t\t\
    \tend\n\t\t\tarr[i] = tmp\n\t\t\tqsort(arr, lo, i - 1)\n\t\t\tqsort(arr, i + 1,\
    \ hi)\n\t\tend\n\tend\n\tqsort(arr, 1, #arr)\n\treturn arr[{{-k + 1, -1}}]\nend",
  "    if not arr or #arr == 0 then\n        return arr\n    end\n    local len =\
    \ #arr\n    if k == 0 then\n        return {}\n    elseif k == len then\n    \
    \    return arr\n    end\n    local function merge(left, right)\n        local\
    \ result = {}\n        local i, j = 1, 1\n        while i <= #left and j <= #right\
    \ do\n            if left[i] > right[j] then\n                table.insert(result,\
    \ left[i])\n                i = i + 1\n            else\n                table.insert(result,\
    \ right[j])\n                j = j + 1\n            end\n        end\n       \
    \ while i <= #left do\n            table.insert(result, left[i])\n           \
    \ i = i + 1\n        end\n        while j <= #right do\n            table.insert(result,\
    \ right[j])\n            j = j + 1\n        end\n        return result\n    end\n\
    \    local function mergeSort(arr)\n        if #arr <= 1 then\n            return\
    \ arr\n        end\n        local left = {}\n        local right = {}\n      \
    \  for i = 1, #arr do\n            if i <= #arr / 2 then\n                table.insert(left,\
    \ arr[i])\n            else\n                table.insert(right, arr[i])\n   \
    \         end\n        end\n        left = mergeSort(left)\n        right = mergeSort(right)\n\
    \        return merge(left, right)\n    end\n    local temp = mergeSort(arr)\n\
    \    local result = {}\n    for i = 1, k do\n        table.insert(result, temp[i])\n\
    \    end\n    return result\nend", "    for i = k, #arr do\n        local min\
    \ = i\n        for j = i + 1, #arr do\n            if arr[j] < arr[min] then\n\
    \                min = j\n            end\n        end\n        arr[i], arr[min]\
    \ = arr[min], arr[i]\n    end\n    return arr\nend", "  local n = #arr\n  local\
    \ sz = n - k + 1\n  table.sort(arr)\n  local res = {}\n  for i = n, sz, -1 do\n\
    \    table.insert(res, arr[i])\n  end\n  return res\nend", "    local len = #arr\n\
    \    if len < k then\n        return arr\n    end\n    local function quickSort(arr,\
    \ l, r)\n        if l < r then\n            local temp = arr[l]\n            local\
    \ i, j = l, r\n            while i < j do\n                while i < j and arr[j]\
    \ <= temp do\n                    j = j - 1\n                end\n           \
    \     arr[i] = arr[j]\n                while i < j and arr[i] >= temp do\n   \
    \                 i = i + 1\n                end\n                arr[j] = arr[i]\n\
    \            end\n            arr[i] = temp\n            quickSort(arr, l, i -\
    \ 1)\n            quickSort(arr, i + 1, r)\n        end\n    end\n    quickSort(arr,\
    \ 1, len)\n    local res = {}\n    for i = 1, k do\n        res[i] = arr[i]\n\
    \    end\n    return res\nend", "    local function partition(arr, left, right)\n\
    \        local pivot = arr[left]\n        local i = left + 1\n        local j\
    \ = right\n        while true do\n            while arr[i] >= pivot and i < right\
    \ do\n                i = i + 1\n            end\n            while arr[j] <=\
    \ pivot and j > left do\n                j = j - 1\n            end\n        \
    \    if i >= j then\n                break\n            end\n            arr[i],\
    \ arr[j] = arr[j], arr[i]\n        end\n        arr[left], arr[j] = arr[j], arr[left]\n\
    \        return j\n    end\n    local function quick_select(arr, left, right,\
    \ k)\n        if left == right then\n            return arr[left]\n        end\n\
    \        local i = partition(arr, left, right)\n        if i == k then\n     \
    \       return arr[i]\n        elseif i > k then\n            return quick_select(arr,\
    \ left, i - 1, k)\n        else\n            return quick_select(arr, i + 1, right,\
    \ k)\n        end\n    end\n    if k > #arr then\n        k = #arr\n    end\n\
    \    quick_select(arr, 1, #arr, k)\n    local result = {}\n    for i = 1, k do\n\
    \        result[i] = arr[i]\n    end\n    return result\nend", "    local res\
    \ = {}\n    local max\n    local idx\n    for i = 1, k do\n        max = -math.huge\n\
    \        for j = 1, #arr do\n            if arr[j] > max then\n              \
    \  max = arr[j]\n                idx = j\n            end\n        end\n     \
    \   res[i] = max\n        arr[idx] = -math.huge\n    end\n    return res\nend",
  "    local newarr = {}\n    for _, v in ipairs(arr) do\n        local n = #newarr\n\
    \        if n < k then\n            table.insert(newarr, v)\n        else\n  \
    \          local minv = math.min(unpack(newarr))\n            if v > minv then\n\
    \                for i, vv in ipairs(newarr) do\n                    if vv ==\
    \ minv then\n                        newarr[i] = v\n                        break\n\
    \                    end\n                end\n            end\n        end\n\
    \    end\n    table.sort(newarr)\n    return newarr\nend", "    if #arr == 0 then\
    \ return {} end\n    table.sort(arr)\n    local res = {}\n    for i = #arr - k\
    \ + 1, #arr do\n        table.insert(res, arr[i])\n    end\n    return res\nend",
  "    local h = {}\n    for i = 1, #arr do\n        if i <= k then\n            heap.push(h,\
    \ arr[i])\n        else\n            local max = heap.pop(h)\n            if arr[i]\
    \ > max then\n                heap.push(h, arr[i])\n            else\n       \
    \         heap.push(h, max)\n            end\n        end\n    end\n    return\
    \ heap.sort(h)\nend", "    local q = {}\n    for i, v in ipairs(arr) do\n    \
    \    local d = {v, i}\n        local c = 1\n        while c <= #q and d[1] < q[c][1]\
    \ do\n            c = c + 1\n        end\n        if c <= k then\n           \
    \ table.insert(q, c, d)\n        end\n    end\n    local result = {}\n    for\
    \ i = 1, #q do\n        table.insert(result, q[i][1])\n    end\n    return result\n\
    end", "    local new_arr = {}\n    local len = #arr\n    if len <= k then\n  \
    \      return arr\n    end\n    for i = 1, k do\n        table.insert(new_arr,\
    \ arr[i])\n    end\n    for i = k + 1, len do\n        local idx = nil\n     \
    \   for j = 1, k do\n            if arr[i] > new_arr[j] then\n               \
    \ idx = j\n                break\n            end\n        end\n        if idx\
    \ then\n            for j = k, idx + 1, -1 do\n                new_arr[j] = new_arr[j\
    \ - 1]\n            end\n            new_arr[idx] = arr[i]\n        end\n    end\n\
    \    return new_arr\nend", "  if k == 0 then return {} end\n  if k == 1 then return\
    \ {math.max(unpack(arr))} end\n  local len = #arr\n  if k >= len then\n    table.sort(arr)\n\
    \    return arr\n  end\n  local res = {}\n  local max = 0\n  for i = 1, len do\n\
    \    if i <= k then\n      res[i] = arr[i]\n      if arr[i] > max then max = arr[i]\
    \ end\n    else\n      if arr[i] < max then\n        local s = k\n        for\
    \ j = 1, k do\n          if res[j] > arr[i] then\n            res[j] = arr[i]\n\
    \            s = j\n            break\n          end\n        end\n        if\
    \ s == k then\n          max = arr[i]\n          for j = 1, k do\n           \
    \ if res[j] > max then max = res[j] end\n          end\n        end\n      end\n\
    \    end\n  end\n  table.sort(res)\n  return res\nend", "    table.sort(arr)\n\
    \    local result = {}\n    for i = #arr, #arr - k + 1, -1 do\n        table.insert(result,\
    \ arr[i])\n    end\n    return result\nend", "    if #arr < k then return {} end\n\
    \    table.sort(arr)\n    local out = {}\n    for i = #arr - k + 1, #arr do\n\
    \        table.insert(out, arr[i])\n    end\n    return out\nend", "    local\
    \ heap = Heap()\n    local n = #arr\n    for i = 1, n do\n        heap:push(arr[i])\n\
    \    end\n    local res = {}\n    for i = 1, k do\n        res[i] = heap:pop()\n\
    \    end\n    return res\nend", "    local len = #arr\n    if k == len then\n\
    \        table.sort(arr)\n        return arr\n    end\n    local out = {}\n  \
    \  for i = 1, k do\n        out[i] = arr[i]\n    end\n    table.sort(out)\n  \
    \  for i = k + 1, len do\n        if arr[i] > out[1] then\n            table.remove(out,\
    \ 1)\n            table.insert(out, arr[i])\n            table.sort(out)\n   \
    \     end\n    end\n    return out\nend", "  table.sort(arr)\n  local ret = {}\n\
    \  for i = #arr, #arr - k + 1, -1 do\n    table.insert(ret, arr[i])\n  end\n \
    \ return ret\nend\nreturn maximum", "    if k >= #arr then return arr end\n  \
    \  local heap = {}\n    local res = {}\n    for i = 1, k do\n        heap[i] =\
    \ arr[i]\n    end\n    table.sort(heap)\n    for i = k + 1, #arr do\n        if\
    \ arr[i] > heap[1] then\n            heap[1] = arr[i]\n            table.sort(heap)\n\
    \        end\n    end\n    for i = 1, k do\n        res[i] = heap[i]\n    end\n\
    \    return res\nend", "    table.sort(arr)\n    local size = #arr\n    local\
    \ res = {}\n    for i = size, size - k + 1, -1 do\n        table.insert(res, arr[i])\n\
    \    end\n    return res\nend", "    -- heap\n    local function sift_down(t,\
    \ i, n)\n        while i * 2 <= n do\n            local tmp = t[i]\n         \
    \   local c = i * 2\n            if c + 1 <= n and t[c + 1] > t[c] then\n    \
    \            c = c + 1\n            end\n            if tmp >= t[c] then\n   \
    \             break\n            end\n            t[i] = t[c]\n            i =\
    \ c\n        end\n        t[i] = tmp\n    end\n    local function sift_up(t, i)\n\
    \        local tmp = t[i]\n        while i > 1 do\n            local p = math.floor(i\
    \ / 2)\n            if t[p] >= tmp then\n                break\n            end\n\
    \            t[i] = t[p]\n            i = p\n        end\n        t[i] = tmp\n\
    \    end\n    local function heap_init(t, n)\n        for i = math.floor(n / 2),\
    \ 1, -1 do\n            sift_down(t, i, n)\n        end\n    end\n    -- solution\n\
    \    local heap = {}\n    for i = 1, k do\n        heap[i] = arr[i]\n    end\n\
    \    heap_init(heap, k)\n    for i = k + 1, #arr do\n        if arr[i] > heap[1]\
    \ then\n            heap[1] = arr[i]\n            sift_down(heap, 1, k)\n    \
    \    end\n    end\n    return heap\nend", "    local min_heap = { }\n    for _,\
    \ v in ipairs(arr) do\n        table.insert(min_heap, v)\n        local i = #min_heap\n\
    \        while i > 1 do\n            local j = math.floor(i / 2)\n           \
    \ if min_heap[i] < min_heap[j] then\n                min_heap[i], min_heap[j]\
    \ = min_heap[j], min_heap[i]\n                i = j\n            else\n      \
    \          break\n            end\n        end\n        if #min_heap > k then\n\
    \            local last = table.remove(min_heap)\n            table.insert(min_heap,\
    \ 1, last)\n            local i = 1\n            local n = #min_heap\n       \
    \     while true do\n                local j = i * 2\n                if j > n\
    \ then\n                    break\n                elseif j < n then\n       \
    \             if min_heap[j] > min_heap[j + 1] then\n                        j\
    \ = j + 1\n                    end\n                end\n                if min_heap[i]\
    \ > min_heap[j] then\n                    min_heap[i], min_heap[j] = min_heap[j],\
    \ min_heap[i]\n                    i = j\n                else\n             \
    \       break\n                end\n            end\n        end\n    end\n  \
    \  local result = { }\n    for i = 1, k do\n        table.insert(result, min_heap[i])\n\
    \    end\n    return result\nend", "    local n = #arr\n    local m = {}\n   \
    \ local rm = {}\n    local function init()\n        for i = 1, k do\n        \
    \    table.insert(m, arr[i])\n        end\n        table.sort(m)\n    end\n  \
    \  local function loop()\n        for i = k + 1, n do\n            local x = arr[i]\n\
    \            local j = 1\n            local t\n            while j <= k do\n \
    \               if x > m[j] then\n                    t = x\n                \
    \    x = m[j]\n                    m[j] = t\n                end\n           \
    \     j = j + 1\n            end\n        end\n    end\n    init()\n    loop()\n\
    \    for _, v in ipairs(m) do\n        table.insert(rm, v)\n    end\n    return\
    \ rm\nend", "    table.sort(arr)\n    local i = 1\n    local r = {}\n    for i\
    \ = #arr, #arr - k + 1, -1 do\n        table.insert(r, arr[i])\n    end\n    return\
    \ r\nend\nreturn maximum", "  local res = {}\n  local pq = {}\n  local n = #arr\n\
    \  for i = 1, n do\n    table.insert(pq, -arr[i])\n  end\n  local function down(i)\n\
    \    local v = pq[i]\n    while i * 2 <= k do\n      local j = i * 2\n      if\
    \ j < k and pq[j + 1] < pq[j] then\n        j = j + 1\n      end\n      if pq[j]\
    \ < v then\n        pq[i] = pq[j]\n        i = j\n      else\n        break\n\
    \      end\n    end\n    pq[i] = v\n  end\n  local function up(i)\n    local v\
    \ = pq[i]\n    while i > 1 do\n      local j = math.floor(i / 2)\n      if pq[j]\
    \ < v then\n        pq[i] = pq[j]\n        i = j\n      else\n        break\n\
    \      end\n    end\n    pq[i] = v\n  end\n  local function add(v)\n    table.insert(pq,\
    \ v)\n    up(#pq)\n  end\n  local function remove()\n    local v = pq[1]\n   \
    \ local n = #pq\n    pq[1] = pq[n]\n    pq[n] = nil\n    down(1)\n    return v\n\
    \  end\n  for i = 1, k do\n    add(arr[i])\n  end\n  for i = k + 1, n do\n   \
    \ if arr[i] > pq[1] then\n      remove()\n      add(arr[i])\n    end\n  end\n\
    \  for i = 1, k do\n    table.insert(res, 1, -remove())\n  end\n  return res\n\
    end", "    local n = #arr\n    local indexs = {}\n    for i = 1, k do\n      \
    \  indexs[i] = i\n    end\n    local min_index = 1\n    for i = k + 1, n do\n\
    \        if arr[i] < arr[indexs[min_index]] then\n            indexs[min_index]\
    \ = i\n            min_index = 1\n            for j = 2, k do\n              \
    \  if arr[indexs[j]] < arr[indexs[min_index]] then\n                    min_index\
    \ = j\n                end\n            end\n        end\n    end\n    for i =\
    \ 1, k do\n        for j = i + 1, k do\n            if arr[indexs[i]] < arr[indexs[j]]\
    \ then\n                indexs[i], indexs[j] = indexs[j], indexs[i]\n        \
    \    end\n        end\n    end\n    local result = {}\n    for i = 1, k do\n \
    \       result[i] = arr[indexs[i]]\n    end\n    return result\nend", "    local\
    \ heap = {}\n    local ret = {}\n    for i = 1, #arr do\n        table.insert(heap,\
    \ {value = arr[i], index = i})\n    end\n    table.sort(heap, function(a, b) return\
    \ a.value > b.value end)\n    for i = 1, k do\n        table.insert(ret, heap[i].value)\n\
    \    end\n    return ret\nend", "    local n = #arr\n    local res = {}\n    for\
    \ i = 1, k do\n        res[i] = arr[i]\n    end\n    local heapify = function(arr,\
    \ p, n)\n        local l, r, largest = 2 * p, 2 * p + 1, p\n        if l <= n\
    \ and arr[l] > arr[largest] then\n            largest = l\n        end\n     \
    \   if r <= n and arr[r] > arr[largest] then\n            largest = r\n      \
    \  end\n        if largest ~= p then\n            arr[p], arr[largest] = arr[largest],\
    \ arr[p]\n            heapify(arr, largest, n)\n        end\n    end\n    for\
    \ i = n // 2, 1, -1 do\n        heapify(res, i, k)\n    end\n    for i = k + 1,\
    \ n do\n        if arr[i] < res[1] then\n            res[1] = arr[i]\n       \
    \     heapify(res, 1, k)\n        end\n    end\n    for i = 1, k // 2 do\n   \
    \     res[i], res[k - i + 1] = res[k - i + 1], res[i]\n    end\n    return res\n\
    end", "    local x = {}\n    for i = 1, #arr do\n        local v = arr[i]\n  \
    \      local y = {}\n        local insert = true\n        for j = 1, #x do\n \
    \           if insert then\n                if v > x[j] then\n               \
    \     table.insert(y, v)\n                    table.insert(y, x[j])\n        \
    \            insert = false\n                else\n                    table.insert(y,\
    \ x[j])\n                end\n            else\n                table.insert(y,\
    \ x[j])\n            end\n        end\n        if insert then\n            table.insert(y,\
    \ v)\n        end\n        if #y > k then\n            x = {}\n            for\
    \ j = 1, k do\n                table.insert(x, y[j])\n            end\n      \
    \  else\n            x = y\n        end\n    end\n    return x\nend\nreturn maximum",
  "    table.sort(arr)\n    local t = {}\n    for i = #arr, #arr - k + 1, -1 do\n\
    \        table.insert(t, arr[i])\n    end\n    return t\nend", "    local pq =\
    \ {}\n    local cmp = function(a, b)\n        return a > b\n    end\n    for i,\
    \ v in ipairs(arr) do\n        table.insert(pq, v)\n        table.sort(pq, cmp)\n\
    \        if #pq > k then\n            table.remove(pq, 1)\n        end\n    end\n\
    \    return pq\nend\nreturn maximum", "    local len = #arr\n    if k > len then\n\
    \        k = len\n    end\n    local max = arr[1]\n    for i = 2, len do\n   \
    \     if arr[i] > max then\n            max = arr[i]\n        end\n    end\n \
    \   local function split(arr, start, endd, len)\n        local max_len = math.max(len,\
    \ endd - start + 1)\n        local res = {}\n        for i = 1, max_len do\n \
    \           res[i] = arr[start]\n            start = start + 1\n        end\n\
    \        return res\n    end\n    local function merge(arr1, arr2)\n        local\
    \ len1, len2 = #arr1, #arr2\n        local i, j, r, res = 1, 1, 1, {}\n      \
    \  while i <= len1 and j <= len2 do\n            if arr1[i] < arr2[j] then\n \
    \               res[r] = arr1[i]\n                i = i + 1\n            else\n\
    \                res[r] = arr2[j]\n                j = j + 1\n            end\n\
    \            r = r + 1\n        end\n        while i <= len1 do\n            res[r]\
    \ = arr1[i]\n            i = i + 1\n            r = r + 1\n        end\n     \
    \   while j <= len2 do\n            res[r] = arr2[j]\n            j = j + 1\n\
    \            r = r + 1\n        end\n        return res\n    end\n    local function\
    \ mergesort(arr, len)\n        if len == 1 then\n            return arr\n    \
    \    end\n        local mid = math.floor(len / 2)\n        local larr = split(arr,\
    \ 1, mid, len)\n        local rarr = split(arr, mid + 1, len, len)\n        local\
    \ sarr1 = mergesort(larr, mid)\n        local sarr2 = mergesort(rarr, len - mid)\n\
    \        return merge(sarr1, sarr2)\n    end\n    return mergesort(arr, len)\n\
    end\nreturn maximum", "    table.sort(arr)\n    local result = {}\n    for i =\
    \ #arr, #arr - k + 1, -1 do\n        table.insert(result, arr[i])\n    end\n \
    \   return result\nend", "    local tmp = {}\n    for i=1,k do\n        table.insert(tmp,\
    \ arr[i])\n    end\n    for i=k+1,#arr do\n        local _, idx = table.min(tmp)\n\
    \        if arr[i] > tmp[idx] then\n            tmp[idx] = arr[i]\n        end\n\
    \    end\n    table.sort(tmp)\n    return tmp\nend", "    if k == 0 then return\
    \ {} end\n    local n = #arr\n    local h = {}\n    local p = 1\n    for i = 1,\
    \ k do\n        h[i] = arr[i]\n        for j = i, p, -1 do\n            if h[j]\
    \ > h[j - 1] then\n                h[j], h[j - 1] = h[j - 1], h[j]\n         \
    \   else\n                break\n            end\n        end\n        p = i\n\
    \    end\n    for i = k + 1, n do\n        if arr[i] > h[1] then\n           \
    \ h[1] = arr[i]\n            p = 1\n            for j = 1, k - 1 do\n        \
    \        if h[j] > h[j + 1] then\n                    h[j], h[j + 1] = h[j + 1],\
    \ h[j]\n                    p = j\n                else\n                    break\n\
    \                end\n            end\n        end\n    end\n    return h\nend",
  "    table.sort(arr)\n    return arr\nend", "    table.sort(arr)\n    local result\
    \ = {}\n    for i = #arr, #arr - k + 1, -1 do\n        table.insert(result, arr[i])\n\
    \    end\n    return result\nend", "    table.sort(arr)\n    local res = {}\n\
    \    for i = #arr, #arr - k + 1, -1 do\n        table.insert(res, arr[i])\n  \
    \  end\n    return res\nend\nreturn maximum", "    local res = {}\n    for i,\
    \ v in ipairs(arr) do\n        if k > 0 then\n            if #res == 0 then\n\
    \                table.insert(res, v)\n            else\n                local\
    \ added = false\n                for j, p in ipairs(res) do\n                \
    \    if v > p then\n                        table.insert(res, j, v)\n        \
    \                k = k - 1\n                        added = true\n           \
    \             break\n                    end\n                end\n          \
    \      if not added then\n                    table.insert(res, v)\n         \
    \       end\n            end\n        else\n            break\n        end\n \
    \   end\n    return res\nend", "    local heap = {}\n    local function push(v)\n\
    \        local i = #heap + 1\n        heap[i] = v\n        while i > 1 do\n  \
    \          local p = i >> 1\n            if heap[p] > heap[i] then\n         \
    \       heap[p], heap[i] = heap[i], heap[p]\n                i = p\n         \
    \   else\n                break\n            end\n        end\n    end\n    local\
    \ function pop()\n        local v = heap[1]\n        heap[1] = heap[#heap]\n \
    \       heap[#heap] = nil\n        local i = 1\n        while i < #heap do\n \
    \           local l = i * 2\n            local r = l + 1\n            if r <=\
    \ #heap then\n                if heap[l] < heap[r] then\n                    if\
    \ heap[i] > heap[l] then\n                        heap[i], heap[l] = heap[l],\
    \ heap[i]\n                        i = l\n                    else\n         \
    \               break\n                    end\n                else\n       \
    \             if heap[i] > heap[r] then\n                        heap[i], heap[r]\
    \ = heap[r], heap[i]\n                        i = r\n                    else\n\
    \                        break\n                    end\n                end\n\
    \            elseif l <= #heap then\n                if heap[i] > heap[l] then\n\
    \                    heap[i], heap[l] = heap[l], heap[i]\n                   \
    \ i = l\n                else\n                    break\n                end\n\
    \            else\n                break\n            end\n        end\n     \
    \   return v\n    end\n    for i = 1, k do\n        push(arr[i])\n    end\n  \
    \  for i = k + 1, #arr do\n        if arr[i] > heap[1] then\n            pop()\n\
    \            push(arr[i])\n        end\n    end\n    local res = {}\n    for i\
    \ = 1, k do\n        res[#res + 1] = pop()\n    end\n    return res\nend", " \
    \   local pq = {}\n    for i, v in ipairs(arr) do\n        if #pq < k then\n \
    \           table.insert(pq, v)\n        else\n            if v > pq[1] then\n\
    \                table.remove(pq, 1)\n                table.insert(pq, v)\n  \
    \          end\n        end\n    end\n    table.sort(pq)\n    return pq\nend",
  "    local heap = {}\n    local heapcnt = 0\n    local function heapify(i)\n   \
    \     local l = i * 2\n        local r = i * 2 + 1\n        local idx = i\n  \
    \      if l <= heapcnt and heap[l] > heap[idx] then\n            idx = l\n   \
    \     end\n        if r <= heapcnt and heap[r] > heap[idx] then\n            idx\
    \ = r\n        end\n        if idx ~= i then\n            heap[i], heap[idx] =\
    \ heap[idx], heap[i]\n            heapify(idx)\n        end\n    end\n    local\
    \ function insert(x)\n        heapcnt = heapcnt + 1\n        heap[heapcnt] = x\n\
    \        local i = heapcnt\n        while i > 1 do\n            local j = math.floor(i\
    \ / 2)\n            if heap[j] < heap[i] then\n                heap[i], heap[j]\
    \ = heap[j], heap[i]\n                i = j\n            else\n              \
    \  break\n            end\n        end\n    end\n    local function pop()\n  \
    \      if heapcnt == 0 then\n            return nil\n        end\n        local\
    \ res = heap[1]\n        heap[1] = heap[heapcnt]\n        heapcnt = heapcnt -\
    \ 1\n        heapify(1)\n        return res\n    end\n    for i = 1, #arr do\n\
    \        if heapcnt < k then\n            insert(arr[i])\n        else\n     \
    \       if arr[i] > heap[1] then\n                pop()\n                insert(arr[i])\n\
    \            end\n        end\n    end\n    local res = {}\n    for i = 1, k do\n\
    \        table.insert(res, 1, pop())\n    end\n    return res\nend", "    local\
    \ len = #arr\n    if k <= 0 or k > len then\n        return {}\n    end\n    table.sort(arr)\n\
    \    return {table.unpack(arr, len - k + 1, len)}\nend", "\tif #arr == k then\n\
    \t\treturn arr\n\tend\n\tlocal p = 0\n\tlocal q = k\n\tfor i = k + 1, #arr do\n\
    \t\tif arr[i] > arr[p] then\n\t\t\tp = p + 1\n\t\t\tif p == q then\n\t\t\t\tq\
    \ = q + 1\n\t\t\t\tp = 0\n\t\t\tend\n\t\tend\n\tend\n\tlocal ret = {}\n\tfor i\
    \ = 0, p - 1 do\n\t\tret[#ret + 1] = arr[i]\n\tend\n\tfor i = q, #arr do\n\t\t\
    ret[#ret + 1] = arr[i]\n\tend\n\treturn ret\nend", "  local heap = {}\n  local\
    \ len = k\n  local function swim(x)\n    while x > 1 and heap[x // 2] < heap[x]\
    \ do\n      heap[x // 2], heap[x] = heap[x], heap[x // 2]\n      x = x // 2\n\
    \    end\n  end\n  local function sink(x)\n    while x * 2 <= len do\n      local\
    \ j = x * 2\n      if j < len and heap[j] < heap[j + 1] then\n        j = j +\
    \ 1\n      end\n      if heap[x] >= heap[j] then\n        break\n      end\n \
    \     heap[x], heap[j] = heap[j], heap[x]\n      x = j\n    end\n  end\n  local\
    \ function delmax()\n    local res = heap[1]\n    heap[1] = heap[len]\n    len\
    \ = len - 1\n    sink(1)\n    return res\n  end\n  for i = 1, #arr do\n    if\
    \ len < k then\n      heap[len + 1] = arr[i]\n      len = len + 1\n      swim(len)\n\
    \    elseif arr[i] > heap[1] then\n      heap[1] = arr[i]\n      sink(1)\n   \
    \ end\n  end\n  for i = k, 1, -1 do\n    arr[i] = delmax()\n  end\n  return arr\n\
    end", "  local function partition(arr, low, high)\n    local i, j = low, high\n\
    \    local pivot = arr[i]\n    while i < j do\n      while i < j and arr[j] <=\
    \ pivot do\n        j = j - 1\n      end\n      arr[i] = arr[j]\n      while i\
    \ < j and arr[i] >= pivot do\n        i = i + 1\n      end\n      arr[j] = arr[i]\n\
    \    end\n    arr[i] = pivot\n    return i\n  end\n  local function quickSelect(arr,\
    \ low, high, k)\n    if low == high then\n      return\n    end\n    local mid\
    \ = partition(arr, low, high)\n    if mid == k then\n      return\n    elseif\
    \ mid < k then\n      quickSelect(arr, mid + 1, high, k)\n    else\n      quickSelect(arr,\
    \ low, mid - 1, k)\n    end\n  end\n  quickSelect(arr, 1, #arr, #arr - k + 1)\n\
    \  local res = {}\n  for i = #arr - k + 1, #arr do\n    res[#res + 1] = arr[i]\n\
    \  end\n  return res\nend", "    local t = {}\n    for i = 1, #arr do\n      \
    \  table.insert(t, arr[i])\n    end\n    local kk = math.min(k, #t)\n    table.sort(t,\
    \ function(a, b) return a > b end)\n    local res = {}\n    for i = 1, kk do\n\
    \        table.insert(res, t[i])\n    end\n    return res\nend", "    table.sort(arr)\n\
    \    local result = {}\n    for i = #arr, #arr - k + 1, -1 do\n        table.insert(result,\
    \ arr[i])\n    end\n    return result\nend", "    table.sort(arr)\n    local l\
    \ = #arr\n    local res = {}\n    for i = l, l - k + 1, -1 do\n        table.insert(res,\
    \ arr[i])\n    end\n    return res\nend", "    local min, min_index = math.huge,\
    \ -1\n    for i = 1, k do\n        local pmin, pmin_index = math.huge, -1\n  \
    \      for j = 1, #arr do\n            if arr[j] < pmin then\n               \
    \ pmin, pmin_index = arr[j], j\n            end\n        end\n        arr[pmin_index]\
    \ = math.huge\n        if pmin_index < min_index then\n            min_index =\
    \ pmin_index\n        end\n        if pmin > min then\n            min = pmin\n\
    \        end\n    end\n    return min_index, min\nend", "    local len = #arr\n\
    \    local heap = {}\n    local heap_size = 0\n    for i = 1, k do\n        heap_size\
    \ = heap_size + 1\n        heap[heap_size] = arr[i]\n        local j = heap_size\n\
    \        while j > 1 do\n            local parent = math.floor(j / 2)\n      \
    \      if heap[parent] < heap[j] then\n                heap[parent], heap[j] =\
    \ heap[j], heap[parent]\n                j = parent\n            else\n      \
    \          break\n            end\n        end\n    end\n    for i = k + 1, len\
    \ do\n        if arr[i] > heap[1] then\n            heap[1] = arr[i]\n       \
    \     local j = 1\n            while true do\n                local child = j\
    \ * 2\n                if child > heap_size then\n                    break\n\
    \                end\n                if child + 1 <= heap_size and heap[child\
    \ + 1] > heap[child] then\n                    child = child + 1\n           \
    \     end\n                if heap[j] < heap[child] then\n                   \
    \ heap[j], heap[child] = heap[child], heap[j]\n                    j = child\n\
    \                else\n                    break\n                end\n      \
    \      end\n        end\n    end\n    return heap\nend", "    if k == 0 then return\
    \ {} end\n    local res = {}\n    for i=1,k do\n        local max = -999999\n\
    \        local maxi = 0\n        for j=1,#arr do\n            if arr[j] > max\
    \ then\n                max = arr[j]\n                maxi = j\n            end\n\
    \        end\n        res[i] = max\n        table.remove(arr, maxi)\n    end\n\
    \    return res\nend", "    local function partition(l, r)\n        local pivot\
    \ = arr[r]\n        local i = l - 1\n        for j = l, r - 1 do\n           \
    \ if arr[j] >= pivot then\n                i = i + 1\n                arr[i],\
    \ arr[j] = arr[j], arr[i]\n            end\n        end\n        arr[i + 1], arr[r]\
    \ = arr[r], arr[i + 1]\n        return i + 1\n    end\n    local function qsort(l,\
    \ r)\n        if l < r then\n            local m = partition(l, r)\n         \
    \   qsort(l, m - 1)\n            qsort(m + 1, r)\n        end\n    end\n    qsort(1,\
    \ #arr)\n    return arr\nend", "    local len = #arr\n    if len == k then\n \
    \       return table.sort(arr)\n    end\n    local stack = {}\n    for i = 1,\
    \ k do\n        stack[i] = arr[i]\n    end\n    for i = k + 1, len do\n      \
    \  local max_value = -math.huge\n        local max_pos = 0\n        for j = 1,\
    \ k do\n            if stack[j] > max_value then\n                max_value =\
    \ stack[j]\n                max_pos = j\n            end\n        end\n      \
    \  if arr[i] > max_value then\n            stack[max_pos] = arr[i]\n        end\n\
    \    end\n    return table.sort(stack)\nend", "    local heap = {}\n    local\
    \ heap_size = 0\n    local function heap_swap(i, j)\n        heap[i], heap[j]\
    \ = heap[j], heap[i]\n    end\n    local function heap_max_heapify(i)\n      \
    \  local left = 2 * i\n        local right = 2 * i + 1\n        local largest\
    \ = i\n        if left <= heap_size and heap[left] > heap[largest] then\n    \
    \        largest = left\n        end\n        if right <= heap_size and heap[right]\
    \ > heap[largest] then\n            largest = right\n        end\n        if largest\
    \ ~= i then\n            heap_swap(i, largest)\n            heap_max_heapify(largest)\n\
    \        end\n    end\n    local function heap_insert(x)\n        heap_size =\
    \ heap_size + 1\n        heap[heap_size] = x\n        local i = heap_size\n  \
    \      while i > 1 and heap[i // 2] < heap[i] do\n            heap_swap(i, i //\
    \ 2)\n            i = i // 2\n        end\n    end\n    local function heap_extract_max()\n\
    \        local max = heap[1]\n        heap[1] = heap[heap_size]\n        heap_size\
    \ = heap_size - 1\n        heap_max_heapify(1)\n        return max\n    end\n\
    \    local function heap_remove(i)\n        heap[i] = math.huge\n        local\
    \ parent = i // 2\n        while i > 1 and heap[parent] < heap[i] do\n       \
    \     heap_swap(i, parent)\n            i = parent\n            parent = i //\
    \ 2\n        end\n        heap_extract_max()\n    end\n    local function heap_replace(x)\n\
    \        heap[1] = x\n        heap_max_heapify(1)\n    end\n    for i = 1, k do\n\
    \        heap_insert(arr[i])\n    end\n    for i = k + 1, #arr do\n        if\
    \ arr[i] > heap[1] then\n            heap_replace(arr[i])\n        end\n    end\n\
    \    local res = {}", "    local len = #arr\n    if len == 0 then\n        return\
    \ arr\n    end\n    table.sort(arr)\n    local list = {}\n    for i = 1, k do\n\
    \        list[i] = arr[len - k + i]\n    end\n    return list\nend", "    table.sort(arr)\n\
    \    return table.slice(arr, #arr - k + 1, #arr)\nend", "    table.sort(arr)\n\
    \    local karr = {}\n    for i = #arr, #arr - k + 1, -1 do\n        table.insert(karr,\
    \ arr[i])\n    end\n    return karr\nend", "  return heap.heap_sort(arr, heap.MAX_HEAP,\
    \ k)\nend", "    local function merge(l, r)\n        local i, j, res = 1, 1, {}\n\
    \        while i <= #l and j <= #r do\n            if l[i] < r[j] then\n     \
    \           res[#res + 1] = l[i]\n                i = i + 1\n            else\n\
    \                res[#res + 1] = r[j]\n                j = j + 1\n           \
    \ end\n        end\n        while i <= #l do\n            res[#res + 1] = l[i]\n\
    \            i = i + 1\n        end\n        while j <= #r do\n            res[#res\
    \ + 1] = r[j]\n            j = j + 1\n        end\n        return res\n    end\n\
    \    local function mergeSort(arr)\n        if #arr == 1 then\n            return\
    \ arr\n        end\n        local mid = math.floor(#arr / 2)\n        local l\
    \ = mergeSort(arr, 1, mid)\n        local r = mergeSort(arr, mid + 1, #arr)\n\
    \        return merge(l, r)\n    end\n    arr = mergeSort(arr)\n    local res\
    \ = {}\n    for i = 1, k do\n        res[i] = arr[#arr - i + 1]\n    end\n   \
    \ return res\nend", "\tlocal t = {unpack(arr)}\n\tlocal len = #t\n\tlocal i =\
    \ 1\n\tlocal j = i + k - 1\n\ttable.sort(t, function(l, r) return l > r end)\n\
    \treturn {unpack(t, i, j)}\nend", "    table.sort(arr)\n    local res = {}\n \
    \   for i = #arr, #arr - k + 1, -1 do\n        table.insert(res, arr[i])\n   \
    \ end\n    return res\nend\nreturn maximum", "    local function partition(l,\
    \ r)\n        local p = arr[l]\n        local i = l + 1\n        for j = l + 1,\
    \ r do\n            if arr[j] > p then\n                arr[i], arr[j] = arr[j],\
    \ arr[i]\n                i = i + 1\n            end\n        end\n        arr[l],\
    \ arr[i - 1] = arr[i - 1], arr[l]\n        return i - 1\n    end\n    local l,\
    \ r = 1, #arr\n    while l <= r do\n        local p = partition(l, r)\n      \
    \  if p == k then\n            break\n        elseif p < k then\n            l\
    \ = p + 1\n        else\n            r = p - 1\n        end\n    end\n    return\
    \ arr\nend", "    local heap = {}\n    for i = 1, #arr do\n        table.insert(heap,\
    \ arr[i])\n        if #heap == k + 1 then\n            table.remove(heap, 1)\n\
    \        end\n    end\n    table.sort(heap)\n    return heap\nend", "    -- remove\
    \ all elements smaller than the kth element\n    local function remove_small(arr,\
    \ k)\n        local i = 1\n        while i <= #arr do\n            if arr[i] <\
    \ arr[k] then\n                table.remove(arr, i)\n            else\n      \
    \          i = i + 1\n            end\n        end\n    end\n    for i = 1, k\
    \ - 1 do\n        remove_small(arr, i)\n    end\n    table.sort(arr)\n    return\
    \ arr\nend", "    table.sort(arr)\n    local len = #arr\n    local result = {}\n\
    \    for i = 1, k do\n        result[i] = arr[len - i + 1]\n    end\n    return\
    \ result\nend", "    if k == 0 then return {} end\n    local rv = {}\n    for\
    \ i = 1, #arr do\n        local cnt = #rv\n        if cnt == 0 then\n        \
    \    table.insert(rv, i)\n        elseif cnt < k then\n            local j = cnt\n\
    \            while j > 0 and arr[i] > arr[rv[j]] do\n                j = j - 1\n\
    \            end\n            table.insert(rv, j + 1, i)\n        elseif arr[i]\
    \ > arr[rv[cnt]] then\n            local j = cnt - 1\n            while j > 0\
    \ and arr[i] > arr[rv[j]] do\n                j = j - 1\n            end\n   \
    \         rv[cnt] = rv[j + 1]\n            rv[j + 1] = i\n        end\n    end\n\
    \    local ret = {}\n    for i = 1, k do\n        table.insert(ret, arr[rv[i]])\n\
    \    end\n    return ret\nend", "    local n = #arr\n    local lo, hi = arr[1],\
    \ arr[1]\n    for i = 2, n do\n        if arr[i] < lo then\n            lo = arr[i]\n\
    \        elseif arr[i] > hi then\n            hi = arr[i]\n        end\n    end\n\
    \    local buckets = {}\n    for i = 0, k - 1 do\n        buckets[i] = {}\n  \
    \  end\n    local l = hi - lo + 1\n    local function hash(x)\n        return\
    \ math.floor((x - lo) * (k - 1) / l)\n    end\n    for i = 1, n do\n        local\
    \ idx = hash(arr[i])\n        local bucket = buckets[idx]\n        local r = #bucket\n\
    \        if r == 0 then\n            bucket[1] = arr[i]\n        elseif r < k\
    \ then\n            local j = r\n            while j > 1 and bucket[j - 1] < arr[i]\
    \ do\n                bucket[j] = bucket[j - 1]\n                j = j - 1\n \
    \           end\n            bucket[j] = arr[i]\n        elseif bucket[1] < arr[i]\
    \ then\n            local j = 1\n            while j < k and bucket[j + 1] < arr[i]\
    \ do\n                bucket[j] = bucket[j + 1]\n                j = j + 1\n \
    \           end\n            bucket[j] = arr[i]\n        end\n    end\n    local\
    \ res = {}\n    for i = k - 1, 0, -1 do\n        local bucket = buckets[i]\n \
    \       local r = #bucket\n        if r == 0 then\n            break\n       \
    \ end\n        local j = 1\n        while j <= r do\n            res[#res + 1]\
    \ = bucket[j]\n            j = j + 1\n        end\n    end\n    return res\nend",
  "  -- print(table.concat(arr, \", \"))\n  local n = #arr\n  if n == k then\n   \
    \ return arr\n  end\n  local max_idx = 1\n  for i = 2, n do\n    if arr[i] > arr[max_idx]\
    \ then\n      max_idx = i\n    end\n  end\n  -- print(arr[max_idx])\n  if max_idx\
    \ > k then\n    return maximum(arr, k)\n  else\n    local result = {arr[max_idx]}\n\
    \    table.remove(arr, max_idx)\n    local remain = maximum(arr, k - 1)\n    for\
    \ i = 1, #remain do\n      table.insert(result, remain[i])\n    end\n    return\
    \ result\n  end\nend", "    table.sort(arr)\n    local ret = {}\n    for i = #arr,\
    \ #arr - k + 1, -1 do\n        table.insert(ret, arr[i])\n    end\n    return\
    \ ret\nend", "    local n = #arr\n    if n == k then\n        return arr\n   \
    \ end\n    local ans = {}\n    for i = 1, k do\n        ans[i] = arr[i]\n    end\n\
    \    for i = k + 1, n do\n        for j = 1, k do\n            if arr[i] > ans[j]\
    \ then\n                table.insert(ans, j, arr[i])\n                table.remove(ans)\n\
    \                break\n            end\n        end\n    end\n    return ans\n\
    end", "    if not arr or k < 1 or k > #arr then\n        return {}\n    end\n\
    \    local heap = {}\n    for i = 1, k do\n        heap[i] = arr[i]\n    end\n\
    \    function adjust(heap, i, n)\n        while i <= math.floor(n / 2) do\n  \
    \          local left = i * 2\n            local right = i * 2 + 1\n         \
    \   local max = i\n            if left <= n and heap[left] > heap[max] then\n\
    \                max = left\n            end\n            if right <= n and heap[right]\
    \ > heap[max] then\n                max = right\n            end\n           \
    \ if max ~= i then\n                heap[i], heap[max] = heap[max], heap[i]\n\
    \                i = max\n            else\n                break\n          \
    \  end\n        end\n    end\n    for i = math.floor(k / 2), 1, -1 do\n      \
    \  adjust(heap, i, k)\n    end\n    for i = k + 1, #arr do\n        if arr[i]\
    \ > heap[1] then\n            heap[1] = arr[i]\n            adjust(heap, 1, k)\n\
    \        end\n    end\n    table.sort(heap)\n    return heap\nend", "  local heap\
    \ = {0}\n  local size = 0\n  local function pop()\n    local ret = heap[1]\n \
    \   size = size - 1\n    local n = 1\n    while n * 2 <= size do\n      local\
    \ max\n      if n * 2 + 1 <= size then\n        if heap[n * 2] > heap[n * 2 +\
    \ 1] then\n          max = n * 2\n        else\n          max = n * 2 + 1\n  \
    \      end\n      else\n        max = n * 2\n      end\n      if heap[max] <=\
    \ heap[size + 1] then\n        break\n      end\n      heap[n], heap[max] = heap[max],\
    \ heap[n]\n      n = max\n    end\n    heap[n] = heap[size + 1]\n    return ret\n\
    \  end\n  local function push(x)\n    size = size + 1\n    local n = size\n  \
    \  while n > 1 do\n      if heap[n // 2] >= x then\n        break\n      end\n\
    \      heap[n] = heap[n // 2]\n      n = n // 2\n    end\n    heap[n] = x\n  end\n\
    \  for i = 1, #arr do\n    if size < k then\n      push(arr[i])\n    elseif arr[i]\
    \ > heap[1] then\n      pop()\n      push(arr[i])\n    end\n  end\n  while size\
    \ > 0 do\n    heap[size + 1], heap[1] = heap[1], heap[size + 1]\n    pop()\n \
    \ end\n  return heap\nend", "    local size = #arr\n    local heap = {}\n    for\
    \ i = 1, k do\n        heap[i] = arr[i]\n    end\n    for i = 1, k // 2 do\n \
    \       local j = i * 2\n        if j + 1 <= k and heap[j + 1] > heap[j] then\n\
    \            j = j + 1\n        end\n        if heap[i] < heap[j] then\n     \
    \       heap[i], heap[j] = heap[j], heap[i]\n        end\n    end\n    for i =\
    \ k + 1, size do\n        if arr[i] > heap[1] then\n            heap[1] = arr[i]\n\
    \            local j = 1\n            while j * 2 <= k do\n                local\
    \ l = j * 2\n                if l + 1 <= k and heap[l + 1] > heap[l] then\n  \
    \                  l = l + 1\n                end\n                if heap[j]\
    \ < heap[l] then\n                    heap[j], heap[l] = heap[l], heap[j]\n  \
    \                  j = l\n                else\n                    break\n  \
    \              end\n            end\n        end\n    end\n    table.sort(heap)\n\
    \    return heap\nend", "    local n = #arr\n    if n == 0 then return {} end\n\
    \    if k >= n then return arr end\n    table.sort(arr)\n    local r = {}\n  \
    \  for i = n - k + 1, n do\n        table.insert(r, arr[i])\n    end\n    return\
    \ r\nend", "    local s = {}\n    for i,v in ipairs(arr) do\n        if (#s <\
    \ k) or (v > s[1]) then\n            if #s < k then\n                s[#s+1] =\
    \ v\n            else\n                s[1] = v\n            end\n           \
    \ for i=#s-1,1,-1 do\n                if s[i] < s[i+1] then\n                \
    \    s[i], s[i+1] = s[i+1], s[i]\n                else\n                    break\n\
    \                end\n            end\n        end\n    end\n    return s\nend",
  "    local l, r = 1, #arr\n    local function helper(arr, l, r, k)\n        local\
    \ pivot = math.random(l, r)\n        arr[pivot], arr[r] = arr[r], arr[pivot]\n\
    \        local j = l\n        for i = l, r - 1 do\n            if arr[i] >= arr[r]\
    \ then\n                arr[i], arr[j] = arr[j], arr[i]\n                j = j\
    \ + 1\n            end\n        end\n        arr[j], arr[r] = arr[r], arr[j]\n\
    \        if j - l + 1 == k then\n            return\n        elseif j - l + 1\
    \ < k then\n            helper(arr, j + 1, r, k - (j - l + 1))\n        else\n\
    \            helper(arr, l, j - 1, k)\n        end\n    end\n    helper(arr, l,\
    \ r, k)\n    local result = {}\n    for i = 1, k do\n        result[i] = arr[i]\n\
    \    end\n    return result\nend", "    for i = k, #arr do\n        local min\
    \ = math.huge\n        local min_j = 0\n        for j = 1, k do\n            if\
    \ arr[j] < min then\n                min = arr[j]\n                min_j = j\n\
    \            end\n        end\n        if arr[i] > min then\n            arr[min_j]\
    \ = arr[i]\n        end\n    end\n    local ret = {}\n    for i = 1, k do\n  \
    \      ret[i] = arr[i]\n    end\n    return ret\nend", "    local heap = {}\n\
    \    local result = {}\n    local function swap(i, j)\n        heap[i], heap[j]\
    \ = heap[j], heap[i]\n    end\n    local function push(i)\n        local p = i\
    \ // 2\n        while p > 0 and heap[p] < heap[i] do\n            swap(p, i)\n\
    \            i = p\n            p = i // 2\n        end\n    end\n    local function\
    \ pop(i)\n        while i * 2 <= k do\n            local j = i * 2\n         \
    \   if j + 1 <= k and heap[j + 1] > heap[j] then\n                j = j + 1\n\
    \            end\n            if heap[i] > heap[j] then\n                break\n\
    \            end\n            swap(i, j)\n            i = j\n        end\n   \
    \ end\n    for i = 1, #arr do\n        heap[i] = arr[i]\n        push(i)\n   \
    \ end\n    for i = 1, k do\n        result[i] = heap[1]\n        swap(1, k - i\
    \ + 1)\n        pop(1)\n    end\n    return result\nend", "    local function\
    \ sort_func(a, b)\n        return a > b\n    end\n    table.sort(arr, sort_func)\n\
    \    local ans = {}\n    for i = 1, k do\n        ans[i] = arr[i]\n    end\n \
    \   return ans\nend", "    local function qs(start, endi)\n        if start >=\
    \ endi then\n            return\n        end\n        local pivot = arr[endi]\n\
    \        local left = start\n        local right = endi - 1\n        while left\
    \ < right do\n            while left < right and arr[left] <= pivot do\n     \
    \           left = left + 1\n            end\n            while left < right and\
    \ arr[right] >= pivot do\n                right = right - 1\n            end\n\
    \            arr[left], arr[right] = arr[right], arr[left]\n        end\n    \
    \    if arr[left] > pivot then\n            arr[left], arr[endi] = arr[endi],\
    \ arr[left]\n        else\n            left = left + 1\n        end\n        qs(start,\
    \ left - 1)\n        qs(left + 1, endi)\n    end\n    if k > #arr then\n     \
    \   k = #arr\n    end\n    qs(1, #arr)\n    local res = {}\n    for i = 1, k do\n\
    \        res[i] = arr[i]\n    end\n    return res\nend", "    if not arr or #arr\
    \ == 0 then\n        return nil\n    end\n    table.sort(arr)\n    local res =\
    \ {}\n    for i = #arr, #arr - k + 1, -1 do\n        table.insert(res, arr[i])\n\
    \    end\n    return res\nend", "    local max_vals = {}\n    for _, v in ipairs(arr)\
    \ do\n        if #max_vals < k then\n            table.insert(max_vals, v)\n \
    \       else\n            local i = 1\n            while i <= k do\n         \
    \       if v > max_vals[i] then\n                    table.remove(max_vals, i)\n\
    \                    table.insert(max_vals, i, v)\n                    break\n\
    \                end\n                i = i + 1\n            end\n        end\n\
    \    end\n    return max_vals\nend", "    if k == 0 then return {} end\n    local\
    \ n = #arr\n    local buf = {}\n    for i = 1, k do\n        local x = i\n   \
    \     for j = i + 1, n do\n            if arr[j] > arr[x] then\n             \
    \   x = j\n            end\n        end\n        buf[i] = arr[x]\n        arr[x]\
    \ = arr[i]\n    end\n    return buf\nend", "    local pq = minheap_init(k, function(lhs,\
    \ rhs) return lhs > rhs end)\n    for _, n in ipairs(arr) do\n        pq:insert(n)\n\
    \    end\n    local res = {}\n    for i = 1, k do\n        res[i] = pq:pop()\n\
    \    end\n    return res\nend", "    local len = #arr\n    local heap = {}\n \
    \   local heap_size = 0\n    local function sink()\n        local i = 1\n    \
    \    while true do\n            local j = i * 2\n            if j > heap_size\
    \ then\n                break\n            end\n            if j + 1 <= heap_size\
    \ and heap[j + 1] > heap[j] then\n                j = j + 1\n            end\n\
    \            if heap[i] >= heap[j] then\n                break\n            end\n\
    \            heap[i], heap[j] = heap[j], heap[i]\n            i = j\n        end\n\
    \    end\n    local function swim()\n        local i = heap_size\n        while\
    \ i > 1 do\n            local j = math.floor(i / 2)\n            if heap[j] >=\
    \ heap[i] then\n                break\n            end\n            heap[i], heap[j]\
    \ = heap[j], heap[i]\n            i = j\n        end\n    end\n    local function\
    \ push(val)\n        heap_size = heap_size + 1\n        heap[heap_size] = val\n\
    \        swim()\n    end\n    local function pop()\n        if heap_size == 0\
    \ then\n            return nil\n        end\n        local val = heap[1]\n   \
    \     heap[1] = heap[heap_size]\n        heap_size = heap_size - 1\n        sink()\n\
    \        return val\n    end\n    for i = 1, len do\n        push(arr[i])\n  \
    \      if heap_size > k then\n            pop()\n        end\n    end\n    local\
    \ res = {}\n    for i = 1, k do\n        table.insert(res, 1, pop())\n    end\n\
    \    return res\nend", "    if k == 0 then return {} end\n    local n = #arr\n\
    \    if k >= n then return arr end\n    local ans = {unpack(arr, 1, k)}\n    table.sort(ans)\n\
    \    for i = k + 1, n do\n        local j = 1\n        while j <= k and ans[j]\
    \ < arr[i] do\n            j = j + 1\n        end\n        if j <= k then\n  \
    \          table.insert(ans, j, arr[i])\n            table.remove(ans)\n     \
    \   end\n    end\n    return ans\nend", "    local function partition(left, right)\n\
    \        local pivot = arr[left]\n        local index = left\n        for i =\
    \ left + 1, right do\n            if arr[i] < pivot then\n                index\
    \ = index + 1\n                arr[i], arr[index] = arr[index], arr[i]\n     \
    \       end\n        end\n        arr[left], arr[index] = arr[index], arr[left]\n\
    \        return index\n    end\n    local left, right = 1, #arr\n    while left\
    \ <= right do\n        local index = partition(left, right)\n        if index\
    \ + 1 == k then\n            return arr\n        elseif index + 1 < k then\n \
    \           left = index + 1\n        else\n            right = index - 1\n  \
    \      end\n    end\nend", "    local heap = {}\n    for i = 1, k do\n       \
    \ table.insert(heap, arr[i])\n    end\n    for _, v in ipairs(heap) do\n     \
    \   print(v)\n    end\n    for i = k + 1, #arr do\n        local j = 1\n     \
    \   while heap[j] < arr[i] do\n            j = j + 1\n        end\n        if\
    \ j <= k then\n            table.insert(heap, j, arr[i])\n            table.remove(heap)\n\
    \        end\n    end\n    return heap\nend", "    local heap = {}\n    for i,\
    \ v in ipairs(arr) do\n        if #heap < k then\n            table.insert(heap,\
    \ v)\n        else\n            table.insert(heap, v)\n            table.sort(heap)\n\
    \            table.remove(heap, 1)\n        end\n    end\n    table.sort(heap)\n\
    \    return heap\nend", "    for i=1,k do\n        for j=1,#arr-i do\n       \
    \     if arr[j] > arr[j+1] then\n                arr[j], arr[j+1] = arr[j+1],\
    \ arr[j]\n            end\n        end\n    end\n    return arr\nend", "\tif arr\
    \ == nil or #arr == 0 then\n\t\treturn {}\n\tend\n\tif k == 0 then\n\t\treturn\
    \ {}\n\tend\n\ttable.sort(arr)\n\tlocal result = {}\n\tfor i = #arr, #arr - k\
    \ + 1, -1 do\n\t\ttable.insert(result, arr[i])\n\tend\n\treturn result\nend",
  "    return table.maxn(arr, k)\nend", "    local heap = Heap:new()\n    for _, v\
    \ in ipairs(arr) do\n        heap:insert(v)\n    end\n    local ret = {}\n   \
    \ while k > 0 do\n        local n = heap:pop()\n        ret[#ret + 1] = n\n  \
    \      k = k - 1\n    end\n    return ret\nend", "    table.sort(arr)\n    local\
    \ res = {}\n    for i = #arr, #arr - k + 1, -1 do\n        table.insert(res, arr[i])\n\
    \    end\n    return res\nend", "    if k >= #arr then\n        table.sort(arr)\n\
    \        return arr\n    end\n    local p = 1\n    local res = {}\n    for i =\
    \ 1, k do\n        res[i] = arr[i]\n    end\n    while p < #arr do\n        table.sort(res)\n\
    \        if arr[p + 1] > res[1] then\n            table.remove(res, 1)\n     \
    \       table.insert(res, arr[p + 1])\n        end\n        p = p + 1\n    end\n\
    \    table.sort(res)\n    return res\nend\nreturn maximum", "  local n = #arr\n\
    \  if n <= k then\n    table.sort(arr)\n    return arr\n  end\n  local xs = {}\n\
    \  for i = 1, k do\n    table.insert(xs, arr[i])\n  end\n  table.sort(xs)\n  for\
    \ i = k + 1, n do\n    if arr[i] > xs[1] then\n      table.remove(xs, 1)\n   \
    \   table.insert(xs, arr[i])\n      table.sort(xs)\n    end\n  end\n  return xs\n\
    end", "    for i = 1, k do\n        for j = i, #arr do\n            if arr[i]\
    \ < arr[j] then\n                arr[i], arr[j] = arr[j], arr[i]\n           \
    \ end\n        end\n    end\n    return arr\nend", "\ttable.sort(arr)\n\tlocal\
    \ res = {}\n\tfor i = #arr - k + 1, #arr do\n\t\ttable.insert(res, arr[i])\n\t\
    end\n\treturn res\nend", "    local n = #arr\n    table.sort(arr)\n    local res\
    \ = {}\n    for i = n - k + 1, n do\n        table.insert(res, arr[i])\n    end\n\
    \    return res\nend", "    local len = #arr\n    if k > len then return arr end\n\
    \    local t = {}\n    for i = 1, k do\n        t[i] = arr[i]\n    end\n    table.sort(t)\n\
    \    for i = k + 1, len do\n        local j = k\n        while j > 1 and t[j]\
    \ < arr[i] do\n            t[j], t[j - 1] = t[j - 1], t[j]\n            j = j\
    \ - 1\n        end\n        if t[j] < arr[i] then\n            t[j] = arr[i]\n\
    \        end\n    end\n    return t\nend", "    return table.pack(table.unpack(arr,\
    \ 1, k))\nend", "    local Q = {}\n    for i = 1, k do\n        Q[i] = arr[i]\n\
    \    end\n    table.sort(Q)\n    for i = k + 1, #arr do\n        local j = 1\n\
    \        while j <= k and Q[j] < arr[i] do\n            j = j + 1\n        end\n\
    \        if j <= k then\n            for l = k, j + 1, -1 do\n               \
    \ Q[l] = Q[l - 1]\n            end\n            Q[j] = arr[i]\n        end\n \
    \   end\n    return Q\nend", "    local sz = #arr\n    if sz <= k then\n     \
    \   table.sort(arr)\n        return arr\n    end\n    local tb = {}\n    for i\
    \ = 1, sz do\n        table.insert(tb, arr[i])\n        local n = #tb\n      \
    \  if n > k then\n            table.remove(tb, 1)\n        end\n    end\n    table.sort(tb)\n\
    \    return tb\nend", "    return {table.unpack(arr, #arr - k + 1, #arr)}\nend",
  "    local l, r = 1, #arr\n    local ans = {}\n    while l <= r do\n        local\
    \ i = l\n        for j = l + 1, r do\n            if arr[j] > arr[i] then\n  \
    \              i = j\n            end\n        end\n        table.insert(ans,\
    \ 1, arr[i])\n        if #ans == k then\n            break\n        end\n    \
    \    if i == l then\n            l = l + 1\n        elseif i == r then\n     \
    \       r = r - 1\n        else\n            local p = arr[i]\n            while\
    \ i < r do\n                arr[i] = arr[i + 1]\n                i = i + 1\n \
    \           end\n            arr[r] = p\n            r = r - 1\n        end\n\
    \    end\n    return ans\nend", "    if not arr or k < 1 or k > #arr then\n  \
    \      return nil\n    end\n    table.sort(arr)\n    local res = {}\n    for i\
    \ = #arr - k + 1, #arr do\n        table.insert(res, arr[i])\n    end\n    return\
    \ res\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
