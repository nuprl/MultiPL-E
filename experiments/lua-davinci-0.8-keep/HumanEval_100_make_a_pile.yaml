name: HumanEval_100_make_a_pile
language: lua
prompt: "-- Given a positive integer n, you have to make a pile of n levels of stones.\n\
  -- The first level has n stones.\n-- The number of stones in the next level is:\n\
  -- - the next odd number if n is odd.\n-- - the next even number if n is even.\n\
  -- Return the number of stones in each level in a list, where element at index\n\
  -- i represents the number of stones in the level (i+1).\n-- Examples:\n-- >>> make_a_pile(3)\n\
  -- [3, 5, 7]\nlocal function make_a_pile(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_a_pile\n\
  \    lu.assertEquals(candidate(3), {3, 5, 7})\n    lu.assertEquals(candidate(4),\
  \ {4, 6, 8, 10})\n    lu.assertEquals(candidate(5), {5, 7, 9, 11, 13})\n    lu.assertEquals(candidate(6),\
  \ {6, 8, 10, 12, 14, 16})\n    lu.assertEquals(candidate(8), {8, 10, 12, 14, 16,\
  \ 18, 20, 22})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    -- return a list of numbers\n    return {}\nend", "  local function\
    \ next_value(x)\n    if x % 2 == 0 then\n      return x + 2\n    else\n      return\
    \ x + 1\n    end\n  end\n  local res = {}\n  while n > 0 do\n    table.insert(res,\
    \ 1, n)\n    n = next_value(n)\n  end\n  return res\nend", "  local s = {n}\n\
    \  while n > 0 do\n    n = n % 2 == 0 and n / 2 or n + 1\n    s[#s+1] = n\n  end\n\
    \  return s\nend", "  local stones = {n}\n  while stones[#stones] ~= 1 do\n  \
    \  if stones[#stones] % 2 == 0 then\n      stones[#stones + 1] = stones[#stones]\
    \ / 2\n    else\n      stones[#stones + 1] = (stones[#stones] + 1) / 2\n    end\n\
    \  end\n  return stones\nend", "  local t = {n}\n  for i = 1, math.floor(n / 2)\
    \ do\n    local num = t[i] + 2\n    t[i + 1] = num\n  end\n  return t\nend", " \
    \ if n == 1 then\n    return {1}\n  end\n  if n % 2 == 0 then\n    return {n,\
    \ make_a_pile(n + 1)}\n  else\n    return {n, make_a_pile(n + 2)}\n  end\nend",
  "  local result = {}\n  while n > 0 do\n    table.insert(result, n)\n    if n %\
    \ 2 == 0 then\n      n = n + 1\n    else\n      n = n + 2\n    end\n  end\n  return\
    \ result\nend", "  local pile = {n}\n  while n > 1 do\n    if n % 2 == 0 then\n\
    \      n = n / 2\n    else\n      n = (n + 1) / 2\n    end\n    table.insert(pile,\
    \ n)\n  end\n  return pile\nend", "    local pile = {}\n    local stones = n\n\
    \    for _ = 1, n do\n        table.insert(pile, stones)\n        if stones %\
    \ 2 == 0 then\n            stones = stones + 1\n        else\n            stones\
    \ = stones + 2\n        end\n    end\n    return pile\nend", "  local res = {}\n\
    \  for _ = 1, n do\n    table.insert(res, n)\n    if n % 2 == 0 then\n      n\
    \ = n + 1\n    else\n      n = n + 2\n    end\n  end\n  return res\nend", "  local\
    \ result = {}\n  local i = 1\n  while i <= n do\n    table.insert(result, n)\n\
    \    if n % 2 == 0 then\n      n = n + 1\n    else\n      n = n + 2\n    end\n\
    \    i = i + 1\n  end\n  return result\nend", "    local pile = {}\n    while\
    \ n > 0 do\n        table.insert(pile, n)\n        if n % 2 == 0 then\n      \
    \      n = n + 1\n        else\n            n = n + 2\n        end\n    end\n\
    \    return pile\nend", "  local pile = {n}\n  for i = 1, n - 1 do\n    if n %\
    \ 2 == 0 then\n      n = n + 1\n    else\n      n = n + 2\n    end\n    pile[i\
    \ + 1] = n\n  end\n  return pile\nend", "  local stones = {n}\n  local next_level\
    \ = (n % 2 == 0) and (n + 2) or (n + 1)\n  while next_level <= n do\n    table.insert(stones,\
    \ next_level)\n    next_level = (next_level % 2 == 0) and (next_level + 2) or\
    \ (next_level + 1)\n  end\n  return stones\nend", "    local t = { n }\n    local\
    \ i = 1\n    while t[i] > 1 do\n        if t[i] % 2 == 0 then\n            t[i+1]\
    \ = t[i] / 2\n        else\n            t[i+1] = (t[i] + 1) / 2\n        end\n\
    \        i = i + 1\n    end\n    return t\nend", "    local res = {}\n    for\
    \ i = n, 1, -1 do\n        res[#res + 1] = n\n        if n % 2 == 0 then\n   \
    \         n = n + 1\n        else\n            n = n + 2\n        end\n    end\n\
    \    return res\nend", "  local result = {}\n  while n > 0 do\n    table.insert(result,\
    \ n)\n    if n % 2 == 0 then\n      n = n + 1\n    else\n      n = n + 2\n   \
    \ end\n  end\n  return result\nend", "  assert(n > 0, 'n must be greater than\
    \ 0')\n  local ret = {n}\n  while n > 1 do\n    n = n % 2 == 0 and n + 1 or n\
    \ + 2\n    table.insert(ret, n)\n  end\n  return ret\nend", "  local pile = {n}\n\
    \  for i = 1, n - 1 do\n    pile[i + 1] = pile[i] + i % 2 == 0 and 2 or 1\n  end\n\
    \  return pile\nend", "  assert(n >= 1, 'n must be a positive integer')\n  local\
    \ result = {n}\n  while n > 1 do\n    n = n % 2 == 0 and n - 1 or n + 1\n    table.insert(result,\
    \ n)\n  end\n  return result\nend", "  local r = {n}\n  for i = 1, n-1 do\n  \
    \  if n % 2 == 0 then\n      r[i+1] = r[i] + 2\n    else\n      r[i+1] = r[i]\
    \ + 1\n    end\n  end\n  return r\nend", "    local function aux(n, m)\n     \
    \   if n == 0 then\n            return {}\n        else\n            return aux(n\
    \ - 1, m + 2)\n        end\n    end\n    return aux(n, n)\nend", "  local res\
    \ = {}\n  for i = 1, n do\n    table.insert(res, n)\n    if n % 2 == 0 then\n\
    \      n = n + 1\n    else\n      n = n + 2\n    end\n  end\n  return res\nend",
  "  local pile = {n}\n  for i = 2, n do\n    pile[i] = (pile[i-1] + 2) % 4 + pile[i-1]\n\
    \  end\n  return pile\nend", "  local pile = {n}\n  while pile[#pile] > 1 do\n\
    \    local last = pile[#pile]\n    if last % 2 == 0 then\n      table.insert(pile,\
    \ last / 2)\n    else\n      table.insert(pile, (last - 1) / 2)\n    end\n  end\n\
    \  return pile\nend", "  -- YOUR CODE HERE\n  local function make_a_pile_helper(n,\
    \ acc)\n    if n <= 0 then\n      return acc\n    else\n      local level = n\
    \ + 2\n      if n % 2 == 0 then\n        level = n + 1\n      end\n      table.insert(acc,\
    \ level)\n      return make_a_pile_helper(n - 1, acc)\n    end\n  end\n  local\
    \ t = {}\n  return make_a_pile_helper(n, t)\nend", "  if n == 1 then\n    return\
    \ {1}\n  end\n  if n % 2 == 0 then\n    return {n, make_a_pile(n - 1)}\n  else\n\
    \    return {n, make_a_pile(n + 1)}\n  end\nend", "    local pile = {}\n    for\
    \ i = n, 1, -1 do\n        if i % 2 == 0 then\n            table.insert(pile,\
    \ i + 1)\n        else\n            table.insert(pile, i - 1)\n        end\n \
    \   end\n    return pile\nend", "  local result = {}\n  while n > 0 do\n    result[#result\
    \ + 1] = n\n    if n % 2 == 0 then\n      n = n + 1\n    else\n      n = n + 2\n\
    \    end\n  end\n  return result\nend", "  local t = {n}\n  while true do\n  \
    \  n = n % 2 == 0 and n + 1 or n + 2\n    if n > 9 then break end\n    t[#t+1]\
    \ = n\n  end\n  return t\nend", "  local pile = {n}\n  for i = 2, n do\n    local\
    \ next_i = i % 2 == 0 and pile[i-1] + 2 or pile[i-1] + 1\n    pile[i] = next_i\n\
    \  end\n  return pile\nend", "    local pile = {}\n    for i = 1, n do\n     \
    \   if i % 2 == 0 then\n            pile[i] = pile[i - 1] + 2\n        else\n\
    \            pile[i] = pile[i - 1] + 1\n        end\n    end\n    return pile\n\
    end", "    local result = {}\n    for i = 1, n do\n        result[i] = (i - 1)\
    \ * 2 + n\n    end\n    return result\nend", "    local pile = {}\n    while n\
    \ > 0 do\n        table.insert(pile, n)\n        if n % 2 == 0 then\n        \
    \    n = n + 1\n        else\n            n = n + 2\n        end\n    end\n  \
    \  return pile\nend", "  local pile = {n}\n  for i = 1, n - 1 do\n    local next\
    \ = pile[i]\n    if next % 2 == 0 then\n      pile[i + 1] = next + 2\n    else\n\
    \      pile[i + 1] = next + 1\n    end\n  end\n  return pile\nend", "  local res\
    \ = {}\n  for i = n, 1, -1 do\n    res[#res+1] = i\n    n = n + (i%2 == 0 and\
    \ 1 or 2)\n  end\n  return res\nend", "  local l = {}\n  for i = n, 1, -1 do\n\
    \    table.insert(l, i)\n  end\n  local count = 0\n  for i = 1, #l do\n    count\
    \ = count + l[i]\n    if l[i] % 2 == 0 then\n      table.insert(l, count + 2)\n\
    \    else\n      table.insert(l, count + 1)\n    end\n  end\n  table.remove(l,\
    \ 1)\n  return l\nend", "    local stones = { n }\n    while stones[#stones] >\
    \ 0 do\n        local stones_this_level = stones[#stones] - 1\n        if stones_this_level\
    \ > 0 then\n            table.insert(stones, stones_this_level)\n        end\n\
    \    end\n    table.remove(stones)\n    return stones\nend", "  local stones =\
    \ {}\n  for i = 1, n do\n    stones[i] = n + (i - 1) * 2\n  end\n  return stones\n\
    end", "    local function step(n)\n        if n == 1 then\n            return\
    \ 1\n        elseif n % 2 == 0 then\n            return n + 2\n        else\n\
    \            return n + 1\n        end\n    end\n    local level, t = n, {}\n\
    \    for i = 1, n do\n        t[i] = level\n        level = step(level)\n    end\n\
    \    return t\nend", "  -- Write your code here\n  local function predicate(n)\n\
    \    return n % 2 == 0\n  end\n  local function iter(n, i)\n    if n <= 0 then\n\
    \      return {}\n    else\n      return {n} .. iter(n + 2, i - 1)\n    end\n\
    \  end\n  return iter(n, n)\nend", "  local result = {}\n  local c = n\n  for\
    \ i = 1, n do\n    table.insert(result, c)\n    if c % 2 == 0 then\n      c =\
    \ c + 1\n    else\n      c = c + 2\n    end\n  end\n  return result\nend", " \
    \   local i = 1\n    local p = {}\n    while i <= n do\n        p[i] = n\n   \
    \     if n % 2 == 0 then\n            n = n + 1\n        else\n            n =\
    \ n + 2\n        end\n        i = i + 1\n    end\n    return p\nend", "  local\
    \ stones = {n}\n  while n > 1 do\n    n = n - 1\n    if n % 2 == 0 then\n    \
    \  n = n - 1\n    end\n    table.insert(stones, n)\n  end\n  return stones\nend",
  "    local res = {}\n    local counter = n\n    while counter > 0 do\n        table.insert(res,\
    \ 1, counter)\n        if counter % 2 == 0 then\n            counter = counter\
    \ - 1\n        else\n            counter = counter - 2\n        end\n    end\n\
    \    return res\nend", "  assert(n >= 1, 'n must be >= 1')\n  local pile = { n\
    \ }\n  for i = 1, n - 1 do\n    if n % 2 == 0 then\n      n = n + 1\n    else\n\
    \      n = n + 2\n    end\n    pile[i + 1] = n\n  end\n  return pile\nend", " \
    \ local pile = {n}\n  for i = 1, n - 1 do\n    pile[i + 1] = pile[i] + 1\n   \
    \ if pile[i + 1] % 2 == 0 then\n      pile[i + 1] = pile[i + 1] + 1\n    end\n\
    \  end\n  return pile\nend", "    local pile = {}\n    for i = 1, n do\n     \
    \   pile[i] = i * 2 - 1\n    end\n    return pile\nend", "    local res = {}\n\
    \    while n > 0 do\n        table.insert(res, n)\n        if n % 2 == 0 then\n\
    \            n = n + 1\n        else\n            n = n + 2\n        end\n   \
    \ end\n    return res\nend", "  local next_num = n % 2 == 0 and n + 2 or n + 1\n\
    \  return n == 1 and {n} or {n, make_a_pile(next_num)}\nend", "  local pile =\
    \ {n}\n  while n > 1 do\n    if n % 2 == 0 then\n      n = n + 1\n    else\n \
    \     n = n + 2\n    end\n    table.insert(pile, n)\n  end\n  return pile\nend",
  "  local res = {}\n  local m = n\n  while m > 0 do\n    table.insert(res, 1, m)\n\
    \    if m % 2 == 0 then\n      m = m + 1\n    else\n      m = m + 2\n    end\n\
    \  end\n  return res\nend", "  local t = {n}\n  while n > 1 do\n    n = n % 2\
    \ == 0 and n - 1 or n + 1\n    t[#t + 1] = n\n  end\n  return t\nend", "  local\
    \ xs = {n}\n  local i = 2\n  while xs[i - 1] > 2 do\n    if i % 2 == 0 then\n\
    \      xs[i] = xs[i - 1] - 2\n    else\n      xs[i] = xs[i - 1] - 1\n    end\n\
    \    i = i + 1\n  end\n  return xs\nend", "    local pile = {}\n    for i = n,\
    \ 1, -1 do\n        pile[#pile + 1] = n\n        if n % 2 == 0 then\n        \
    \    n = n + 1\n        else\n            n = n + 2\n        end\n    end\n  \
    \  return pile\nend", "  if n == 1 then\n    return {1}\n  end\n  if n == 2 then\n\
    \    return {2, 3}\n  end\n  local pile = {n}\n  for i = 1, n - 2 do\n    pile[i\
    \ + 1] = pile[i] + 2\n  end\n  return pile\nend", "    local levels = { n }\n\
    \    for _, v in ipairs(levels) do\n        table.insert(levels, ((v % 2 == 0)\
    \ and (v + 2) or (v + 1)))\n    end\n    return levels\nend", "    local stones\
    \ = { n }\n    while stones[#stones] ~= 1 do\n        stones[#stones + 1] = stones[#stones]\
    \ - 2\n    end\n    return stones\nend", "    assert(n >= 1)\n    local t = {n}\n\
    \    local i = 1\n    while t[i] <= n do\n        t[i+1] = t[i] + 2\n        if\
    \ t[i+1] > n then\n            t[i+1] = nil\n        end\n        i = i + 1\n\
    \    end\n    return t\nend", "  local function next_level(x)\n    if x % 2 ==\
    \ 0 then\n      return x + 2\n    else\n      return x + 1\n    end\n  end\n \
    \ local pile = { n }\n  while pile[#pile] > 1 do\n    pile[#pile + 1] = next_level(pile[#pile])\n\
    \  end\n  return pile\nend", "  local pile = { n }\n  while n > 1 do\n    n =\
    \ n % 2 == 0 and n - 1 or n + 1\n    table.insert(pile, n)\n  end\n  return pile\n\
    end", "  local pile = {n}\n  while true do\n    local new_level = (n % 2 == 0)\
    \ and (n + 2) or (n + 1)\n    if new_level > n then\n      table.insert(pile,\
    \ new_level)\n      n = new_level\n    else\n      break\n    end\n  end\n  return\
    \ pile\nend", "  assert(n > 0, \"n must be positive\")\n  local current = n\n\
    \  local result = {n}\n  while current > 1 do\n    current = (current % 2 == 0)\
    \ and (current - 1) or (current - 2)\n    table.insert(result, current)\n  end\n\
    \  return result\nend", "  local result = {}\n  while n > 0 do\n    result[#result\
    \ + 1] = n\n    if n % 2 == 0 then\n      n = n + 1\n    else\n      n = n + 2\n\
    \    end\n  end\n  return result\nend", "    local stones = {n}\n    for i = 1,\
    \ n - 1 do\n        if stones[i] % 2 == 0 then\n            stones[i + 1] = stones[i]\
    \ + 2\n        else\n            stones[i + 1] = stones[i] + 1\n        end\n\
    \    end\n    return stones\nend", "    local result = {}\n    for i = 1, n do\n\
    \        if (i % 2 == 0) then\n            result[i] = i + 1\n        else\n \
    \           result[i] = i + 2\n        end\n    end\n    return result\nend",
  "    local function make_a_level(n)\n        return n + (n % 2 == 0 and 2 or 1)\n\
    \    end\n    local levels = {}\n    while n > 0 do\n        table.insert(levels,\
    \ n)\n        n = make_a_level(n)\n    end\n    return levels\nend", "  assert(n\
    \ > 0)\n  local p = {n}\n  while n > 0 do\n    if n % 2 == 0 then\n      n = n\
    \ + 1\n    else\n      n = n + 2\n    end\n    table.insert(p, n)\n  end\n  return\
    \ p\nend", "    local stones = { n }\n    while stones[#stones] > 1 do\n     \
    \   local n = stones[#stones]\n        local next_n = n % 2 == 0 and n + 2 or\
    \ n + 1\n        stones[#stones + 1] = next_n\n    end\n    return stones\nend",
  "  local t = {n}\n  for i = 2, n do\n    t[i] = t[i-1] + (i % 2 == 0 and 2 or 1)\n\
    \  end\n  return t\nend", "  if n <= 0 then return {} end\n  return {n, n + (n\
    \ % 2 * 2)}\nend", "  local pile = {n}\n  while pile[#pile] > 1 do\n    local\
    \ stone = pile[#pile]\n    if stone % 2 == 0 then\n      table.insert(pile, stone\
    \ - 1)\n    else\n      table.insert(pile, stone - 2)\n    end\n  end\n  return\
    \ pile\nend", "  local res = {}\n  while n > 0 do\n    table.insert(res, n)\n\
    \    if n % 2 == 0 then\n      n = n - 1\n    else\n      n = n - 2\n    end\n\
    \  end\n  return res\nend", "  if n == 1 then\n    return {1}\n  end\n  if n ==\
    \ 2 then\n    return {2, 2}\n  end\n  if n % 2 == 0 then\n    local levels = make_a_pile(n\
    \ - 1)\n    table.insert(levels, n + 1)\n    return levels\n  else\n    local\
    \ levels = make_a_pile(n - 1)\n    table.insert(levels, n + 2)\n    return levels\n\
    \  end\nend", "    local pile = {}\n    for i = 1, n do\n        pile[i] = i *\
    \ 2 - 1\n    end\n    return pile\nend", "  local res = {}\n  for i = 1, n do\n\
    \    local current = res[i - 1] or n\n    local next = current + 2\n    if (current\
    \ % 2 == 0) then\n      next = current + 1\n    end\n    res[i] = next\n  end\n\
    \  return res\nend", "    local stones = {n}\n    while stones[#stones] > 0 do\n\
    \        if stones[#stones] % 2 == 0 then\n            table.insert(stones, stones[#stones]\
    \ - 1)\n        else\n            table.insert(stones, stones[#stones] - 2)\n\
    \        end\n    end\n    return stones\nend", "  local t = {n}\n  while t[#t]\
    \ ~= 1 do\n    if t[#t] % 2 == 0 then\n      t[#t+1] = t[#t] / 2\n    else\n \
    \     t[#t+1] = (t[#t] + 1) / 2\n    end\n  end\n  return t\nend", "  local stones\
    \ = {}\n  for i = 1, n do\n    table.insert(stones, n)\n    if n % 2 == 0 then\n\
    \      n = n + 1\n    else\n      n = n + 2\n    end\n  end\n  return stones\n\
    end", "    local pile = {}\n    for i = n, 1, -1 do\n        table.insert(pile,\
    \ n)\n        if n % 2 == 0 then\n            n = n + 1\n        else\n      \
    \      n = n + 2\n        end\n    end\n    return pile\nend", "    -- Add your\
    \ code here!\nend", "  local pile = {n}\n  for i = 2, n do\n    if pile[i-1] %\
    \ 2 == 0 then\n      pile[i] = pile[i-1] + 2\n    else\n      pile[i] = pile[i-1]\
    \ + 1\n    end\n  end\n  return pile\nend", "    local pile = {}\n    while n\
    \ > 0 do\n        table.insert(pile, n)\n        if n % 2 == 0 then\n        \
    \    n = n + 1\n        else\n            n = n + 2\n        end\n    end\n  \
    \  return pile\nend", "  if n == 1 then\n    return {1}\n  end\n  if n % 2 ==\
    \ 0 then\n    local new = n + 2\n    return {n, unpack(make_a_pile(new))}\n  else\n\
    \    local new = n + 1\n    return {n, unpack(make_a_pile(new))}\n  end\nend",
  "  if n == 1 then\n    return {1}\n  end\n  if n % 2 == 0 then\n    return merge({n},\
    \ make_a_pile(n + 1))\n  else\n    return merge({n}, make_a_pile(n + 2))\n  end\n\
    end", "  local pile = {n}\n  local n_prev = n\n  while true do\n    if n_prev\
    \ % 2 == 0 then\n      n_prev = n_prev + 1\n    else\n      n_prev = n_prev +\
    \ 2\n    end\n    if n_prev > n * 2 then\n      break\n    end\n    table.insert(pile,\
    \ n_prev)\n  end\n  return pile\nend", "  local ret = {}\n  for i = 1, n do\n\
    \    if n % 2 == 0 then\n      n = n + 1\n    else\n      n = n + 2\n    end\n\
    \    table.insert(ret, n)\n  end\n  return ret\nend", end, "    local levels =\
    \ {n}\n    while levels[#levels] > 1 do\n        if levels[#levels] % 2 == 0 then\n\
    \            levels[#levels + 1] = levels[#levels] - 1\n        else\n       \
    \     levels[#levels + 1] = levels[#levels] - 2\n        end\n    end\n    return\
    \ levels\nend", "  local l = {}\n  while n > 0 do\n    l[#l+1] = n\n    if n %\
    \ 2 == 0 then\n      n = n / 2\n    else\n      n = n * 3 + 1\n    end\n  end\n\
    \  return l\nend", "  if n == 1 then\n    return {n}\n  end\n  local l = {n}\n\
    \  if n % 2 == 0 then\n    l[#l+1] = n + 2\n  else\n    l[#l+1] = n + 1\n  end\n\
    \  return l\nend", end, "   if n == 1 then\n      return {1}\n   else\n      local\
    \ a = {n}\n      if n % 2 == 0 then\n         a[2] = n + 2\n      else\n     \
    \    a[2] = n + 1\n      end\n      for i = 3, n do\n         if a[i-1] % 2 ==\
    \ 0 then\n            a[i] = a[i-1] + 2\n         else\n            a[i] = a[i-1]\
    \ + 1\n         end\n      end\n      return a\n   end\nend", "    if n <= 0 then\n\
    \        return {}\n    end\n    local res = { n }\n    local m = n % 2 == 0 and\
    \ n + 1 or n + 2\n    while m > 0 do\n        table.insert(res, m)\n        m\
    \ = m % 2 == 0 and m + 1 or m + 2\n    end\n    return res\nend", "    if n ==\
    \ 1 then\n        return {n}\n    end\n    if n % 2 == 0 then\n        n = n +\
    \ 1\n    end\n    local t = {n}\n    for i = 1, math.floor(n / 2) do\n       \
    \ table.insert(t, n - 2 * i)\n    end\n    return t\nend", "  local pile = {n}\n\
    \  for i = 1, n-1 do\n    if n % 2 == 0 then\n      n = n + 2\n    else\n    \
    \  n = n + 1\n    end\n    table.insert(pile, n)\n  end\n  return pile\nend",
  "    local l = {n}\n    while l[#l] > 1 do\n        l[#l+1] = l[#l] - (l[#l] % 2\
    \ == 0 and 2 or 1)\n    end\n    return l\nend", "  -- your code here\nend", " \
    \   assert(n > 0)\n    local res = {n}\n    for i = 2, n do\n        res[i] =\
    \ res[i - 1] + (i % 2 == 0 and 2 or 1)\n    end\n    return res\nend", "   local\
    \ res = {}\n   for i = 1, n do\n      res[i] = i * 2 - 1\n   end\n   return res\n\
    end", "  local p = {n}\n  for i = 1, n - 1 do\n    table.insert(p, p[i] + 2 *\
    \ (i % 2 + 1))\n  end\n  return p\nend", "    if n <= 0 then\n        return {}\n\
    \    end\n    local t = {n}\n    if n % 2 == 0 then\n        table.insert(t, make_a_pile(n\
    \ + 1))\n    else\n        table.insert(t, make_a_pile(n + 2))\n    end\n    return\
    \ t\nend", "  -- ...\nend", "    local pile = {}\n    for i = 1, n do\n      \
    \  pile[i] = 2 * i - 1\n    end\n    return pile\nend", "  assert(n > 0, \"n must\
    \ be positive\")\n  local l = {n}\n  local next_ = n % 2 == 0 and (n+2) or (n+1)\n\
    \  while next_ < 2*n do\n    l[#l+1] = next_\n    next_ = next_ % 2 == 0 and (next_+2)\
    \ or (next_+1)\n  end\n  return l\nend", "  local result = {}\n  for i = 1, n\
    \ do\n    result[i] = i + i\n  end\n  return result\nend", end, "   local f =\
    \ coroutine.wrap(function(n)\n      for i = n, 1, -1 do\n         coroutine.yield(i)\n\
    \      end\n   end)\n   local l = {}\n   for n in f, n do\n      l[#l+1] = n\n\
    \   end\n   return l\nend", "    local stones = { n }\n    repeat\n        local\
    \ next_stone_count = n % 2 == 0 and n + 2 or n + 1\n        table.insert(stones,\
    \ next_stone_count)\n        n = next_stone_count\n    until next_stone_count\
    \ % 2 == 1 and next_stone_count > 9\n    return stones\nend", "  local pile =\
    \ {n}\n  for i = 1, n - 1 do\n    local s = pile[i]\n    local t = (s % 2 == 0)\
    \ and (s + 2) or (s + 1)\n    pile[i + 1] = t\n  end\n  return pile\nend", " \
    \ local result = {}\n  for i = 1, n do\n    result[i] = 2 * i - 1\n  end\n  return\
    \ result\nend", "    local pile = {}\n    local num_stones = n\n    while num_stones\
    \ > 0 do\n        pile[#pile+1] = num_stones\n        if num_stones % 2 == 0 then\n\
    \            num_stones = num_stones + 1\n        else\n            num_stones\
    \ = num_stones + 2\n        end\n    end\n    return pile\nend", "  if n < 1 then\
    \ return {} end\n  local function f(n, r)\n    if n == 1 then return r end\n \
    \   return f(n - 1, {n, n + 2}:sub(n % 2 + 1, n % 2 + 1))\n  end\n  return f(n,\
    \ {n})\nend", "  local stone_pile = {}\n  local num_stones = n\n  while (num_stones\
    \ > 0) do\n    table.insert(stone_pile, num_stones)\n    if (num_stones % 2 ==\
    \ 0) then\n      num_stones = num_stones + 1\n    else\n      num_stones = num_stones\
    \ + 2\n    end\n  end\n  return stone_pile\nend", "    local stones = { n }\n\
    \    local k = 1\n    while k < n do\n        if stones[k] % 2 == 0 then\n   \
    \         table.insert(stones, stones[k] + 2)\n        else\n            table.insert(stones,\
    \ stones[k] + 1)\n        end\n        k = k + 1\n    end\n    return stones\n\
    end", "    local t = {n}\n    for i = 1, n-1 do\n        t[i+1] = (n % 2 == 0)\
    \ and t[i] + 2 or t[i] + 1\n    end\n    return t\nend", "  local pile = {[1]\
    \ = n}\n  while pile[#pile] > 1 do\n    if pile[#pile] % 2 == 0 then\n      pile[#pile\
    \ + 1] = pile[#pile] / 2\n    else\n      pile[#pile + 1] = (pile[#pile] + 1)\
    \ / 2\n    end\n  end\n  return pile\nend", "  local pile = {n}\n  for i = 1,\
    \ #pile do\n    local s = pile[i]\n    if s == 1 then\n      break\n    end\n\
    \    pile[i+1] = s + 2 * (s % 2 == 0 and 1 or -1)\n  end\n  return pile\nend",
  "  local pile = {n}\n  local last = n\n  while n > 1 do\n    if n % 2 == 0 then\n\
    \      n = n / 2\n    else\n      n = n - 1\n    end\n    last = last + n\n  \
    \  table.insert(pile, last)\n  end\n  return pile\nend", "    if n == 1 then\n\
    \        return {1}\n    end\n    if n % 2 == 0 then\n        return {n, n + 2,\
    \ make_a_pile(n + 2)}\n    else\n        return {n, n + 1, make_a_pile(n + 1)}\n\
    \    end\nend", "    local pile = {}\n    for level=1,n do\n        table.insert(pile,\
    \ n+2*(level-1))\n    end\n    return pile\nend", "  local res = {}\n  if n ==\
    \ 1 then\n    res[1] = 1\n  else\n    local level = 1\n    local num_stones =\
    \ n\n    while num_stones > 0 do\n      table.insert(res, num_stones)\n      level\
    \ = level + 1\n      num_stones =\n        num_stones % 2 == 0 and num_stones\
    \ + 2 or num_stones + 1\n    end\n  end\n  return res\nend", "  local pile = {n}\n\
    \  local level = n\n  while level > 0 do\n    if level % 2 == 0 then\n      level\
    \ = level + 1\n    else\n      level = level + 2\n    end\n    table.insert(pile,\
    \ level)\n  end\n  return pile\nend", "  local function next_number(number)\n\
    \    if number % 2 == 0 then\n      return number + 2\n    else\n      return\
    \ number + 1\n    end\n  end", "  local nums = {}\n  for i = 1, n do\n    nums[i]\
    \ = n + (i-1)*2 + (n % 2)\n  end\n  return nums\nend", "  local res = {}\n  local\
    \ is_odd = (n % 2 == 1)\n  for i = 1, n do\n    res[i] = n + (i - 1) * (is_odd\
    \ and 2 or 1)\n  end\n  return res\nend", "  local function is_odd(n)\n    return\
    \ (n%2 == 1)\n  end\n  local function next_odd(n)\n    return (n + (is_odd(n)\
    \ and 2 or 1))\n  end\n  local function next_even(n)\n    return (n + (is_odd(n)\
    \ and 1 or 2))\n  end\n  local function next_step(n)\n    return (is_odd(n) and\
    \ next_odd(n) or next_even(n))\n  end\n  local pile = {}\n  local level = n\n\
    \  local i = 1\n  while level > 0 do\n    pile[i] = level\n    level = next_step(level)\n\
    \    i = i + 1\n  end\n  return pile\nend", "  local pile = {n}\n  while n > 0\
    \ do\n    if n % 2 == 0 then\n      n = n - 1\n    else\n      n = n - 2\n   \
    \ end\n    pile[#pile + 1] = n\n  end\n  return pile\nend", "  local res = {}\n\
    \  while n > 0 do\n    n = n - 1\n    table.insert(res, 1 + n*2)\n  end\n  return\
    \ res\nend", "  local function make_a_pile_tr(n, _, acc)\n    if n == 0 then\n\
    \      return acc\n    else\n      local next_n = n - 1\n      local next_i =\
    \ n % 2 == 0 and 1 or 2\n      return make_a_pile_tr(next_n, next_i, {(2 * n)\
    \ + next_i, table.unpack(acc)})\n    end\n  end\n  return make_a_pile_tr(n, 0,\
    \ {})\nend", "    local r = {n}\n    while r[#r] > 1 do\n        local i = r[#r]\n\
    \        if i % 2 == 0 then\n            r[#r+1] = i - 1\n        else\n     \
    \       r[#r+1] = i - 2\n        end\n    end\n    return r\nend", "    -- Write\
    \ your code here.\n    local res = {}\n    local i = 1\n    while n >= 0 do\n\
    \        if n == 0 then\n            return res\n        end\n        res[i] =\
    \ n\n        n = n % 2 == 0 and n + 1 or n + 2\n        i = i + 1\n    end\nend",
  "  local a = {}\n  for i = 1, n do\n    a[i] = (2 * i - 1) * n\n  end\n  return\
    \ a\nend", "    local result = {}\n    result[1] = n\n    for i = 2, n do\n  \
    \      if n % 2 == 0 then\n            result[i] = n + i\n        else\n     \
    \       result[i] = n + i + 1\n        end\n    end\n    return result\nend",
  "  local res = {}\n  local i = 1\n  while n ~= 0 do\n    res[i] = n\n    if n %\
    \ 2 == 0 then\n      n = n + 1\n    else\n      n = n + 2\n    end\n    i = i\
    \ + 1\n  end\n  return res\nend", "  local r = {n}\n  while r[#r] > 1 do\n   \
    \ if r[#r] % 2 == 0 then\n      r[#r+1] = r[#r] - 1\n    else\n      r[#r+1] =\
    \ r[#r] + 1\n    end\n  end\n  return r\nend", end, "  local stones = {n}\n  local\
    \ stones_in_next_level = n + (n % 2 == 0 and 2 or 1)\n  for _ = 1, n - 1 do\n\
    \    table.insert(stones, stones_in_next_level)\n    stones_in_next_level = stones_in_next_level\
    \ + (stones_in_next_level % 2 == 0 and 2 or 1)\n  end\n  return stones\nend",
  "    -- Your code here\nend", "  local t = { n }\n  while true do\n    if n % 2\
    \ == 0 then\n      n = n + 1\n    else\n      n = n + 2\n    end\n    t[#t+1]\
    \ = n\n    if n == n^2 then\n      break\n    end\n  end\n  return t\nend", " \
    \ local r = {n}\n  for i = n, 1, -1 do\n    if n % 2 == 0 then n = n + 1 else\
    \ n = n + 2 end\n    r[#r+1] = n\n  end\n  return r\nend", "    local pile = {}\n\
    \    local num_stones = n\n    while num_stones > 0 do\n        num_stones = num_stones\
    \ - 1\n        pile[#pile + 1] = num_stones\n        if num_stones % 2 == 0 then\n\
    \            num_stones = num_stones - 1\n        end\n    end\n    return pile\n\
    end", "    local stones = {n}\n    local i = n\n    while i ~= 1 do\n        if\
    \ i % 2 == 0 then\n            i = i / 2\n        else\n            i = (i * 3)\
    \ + 1\n        end\n        table.insert(stones, i)\n    end\n    return stones\n\
    end", "    local result = {}\n    while n > 0 do\n        table.insert(result,\
    \ n)\n        if n % 2 == 0 then\n            n = n + 1\n        else\n      \
    \      n = n + 2\n        end\n    end\n    return result\nend", "   if n == 1\
    \ then\n      return { 1 }\n   else\n      return { n } .. make_a_pile(n + 2 *\
    \ (n % 2) - 1)\n   end\nend", "  local pile = {n}\n  while n > 1 do\n    n = n\
    \ - 1\n    if n % 2 == 0 then\n      n = n - 1\n    end\n    table.insert(pile,\
    \ n)\n  end\n  return pile\nend", "  -- YOUR CODE HERE\n  local pile = {}\n  pile[1]\
    \ = n\n  if n % 2 == 0 then\n    pile[2] = n + 2\n  else\n    pile[2] = n + 1\n\
    \  end\n  local i = 3\n  while true do\n    if pile[i-1] % 2 == 0 then\n     \
    \ pile[i] = pile[i-1] + 2\n    else\n      pile[i] = pile[i-1] + 1\n    end\n\
    \    if pile[i] == 2*n then\n      break\n    end\n    i = i + 1\n  end\n  return\
    \ pile\nend", "    assert(n > 0)\n    local stones = {}\n    for i = 1, n do\n\
    \        stones[i] = n + 2 * i - 1\n    end\n    return stones\nend", end, " \
    \ if n <= 0 then\n    return {}\n  end\n  local pile = {n}\n  local next_level\
    \ = n % 2 == 0 and n + 2 or n + 1\n  while next_level > 0 do\n    pile[#pile +\
    \ 1] = next_level\n    next_level = next_level % 2 == 0 and next_level + 2 or\
    \ next_level + 1\n  end\n  return pile\nend", "    local res = {}\n    local value\
    \ = n\n    while value > 0 do\n        res[#res + 1] = value\n        if value\
    \ % 2 == 0 then\n            value = value + 1\n        else\n            value\
    \ = value + 2\n        end\n    end\n    return res\nend", "    assert(n > 0,\
    \ \"n must be a positive integer\")\n    local result = { n }\n    for i = 2,\
    \ n do\n        local next = result[i - 1] + (next_number(next_number(result[i\
    \ - 1])) - result[i - 1])\n        table.insert(result, next)\n    end\n    return\
    \ result\nend", "    local function is_odd(n)\n        return n % 2 == 1\n   \
    \ end\n    local function is_even(n)\n        return n % 2 == 0\n    end\n   \
    \ local function next_odd(n)\n        if is_odd(n) then\n            return n\
    \ + 2\n        else\n            return n + 1\n        end\n    end\n    local\
    \ function next_even(n)\n        if is_even(n) then\n            return n + 2\n\
    \        else\n            return n + 1\n        end\n    end\n    local function\
    \ next_level(n)\n        if is_odd(n) then\n            return next_odd(n)\n \
    \       else\n            return next_even(n)\n        end\n    end\n    local\
    \ pile = {}\n    local level = n\n    while n > 0 do\n        table.insert(pile,\
    \ level)\n        level = next_level(level)\n        n = n - 1\n    end\n    return\
    \ pile\nend", "  local lst = {n}\n  while n > 1 do\n    if n % 2 == 0 then\n \
    \     n = n / 2\n    else\n      n = (n + 1) / 2\n    end\n    lst[#lst + 1] =\
    \ 2 * n\n  end\n  return lst\nend", "  local res = {}\n  while n > 0 do\n    res[#res+1]\
    \ = n\n    if n % 2 == 0 then\n      n = n - 1\n    else\n      n = n - 2\n  \
    \  end\n  end\n  return res\nend", "  local function next(x)\n    return (x%2==0)\
    \ and (x+2) or (x+1)\n  end\n  local result = {n}\n  while result[#result] > 1\
    \ do\n    result[#result+1] = next(result[#result])\n  end\n  return result\n\
    end", "  local pile = {n}\n  while pile[#pile] > 0 do\n    local last = pile[#pile]\n\
    \    if last % 2 == 0 then\n      table.insert(pile, last - 1)\n    else\n   \
    \   table.insert(pile, last - 2)\n    end\n  end\n  return pile\nend", "    assert(n\
    \ >= 1, \"n must be positive\")\n    local res = { n }\n    while n > 1 do\n \
    \       n = n % 2 == 0 and n - 1 or n + 1\n        res[#res + 1] = n\n    end\n\
    \    return res\nend", "  local s = {n}\n  for i = 2, n do\n    s[i] = (n + (i\
    \ % 2))\n  end\n  return s\nend", "  local stones = {}\n  local t = n\n  while\
    \ n > 0 do\n    table.insert(stones, n)\n    if n % 2 == 0 then\n      n = n +\
    \ 1\n    else\n      n = n + 2\n    end\n  end\n  return stones\nend", "  local\
    \ result = {}\n  if n == 1 then\n    result[1] = 1\n  else\n    result[1] = n\n\
    \    for i = 2, n do\n      if i % 2 == 0 then\n        result[i] = result[i -\
    \ 1] + 2\n      else\n        result[i] = result[i - 1] + 1\n      end\n    end\n\
    \  end\n  return result\nend", "    local result = {}\n    while n > 0 do\n  \
    \      table.insert(result, n)\n        if n % 2 == 0 then\n            n = n\
    \ + 1\n        else\n            n = n + 2\n        end\n    end\n    return result\n\
    end", "  local result = {}\n  for i = 1, n do\n    result[i] = (i * 2) - 1\n \
    \ end\n  return result\nend", "  local result = {}\n  result[#result+1] = n\n\
    \  while n > 1 do\n    if n % 2 == 0 then\n      n = n / 2\n    else\n      n\
    \ = (n + 1) / 2\n    end\n    result[#result+1] = 2 * n\n  end\n  return result\n\
    end", "  local pile = {n}\n  while n > 1 do\n    if n % 2 == 0 then\n      n =\
    \ n / 2\n    else\n      n = (n * 3 + 1) / 2\n    end\n    table.insert(pile,\
    \ n)\n  end\n  return pile\nend", "    local pile = {}\n    for i = n, 1, -1 do\n\
    \        pile[#pile + 1] = i\n        i = i + (i % 2) * 2\n    end\n    return\
    \ pile\nend", "    local levels = {n}\n    local next_level = n\n    while next_level\
    \ ~= 1 do\n        if next_level % 2 == 0 then\n            next_level = next_level\
    \ / 2\n        else\n            next_level = (next_level + 1) / 2\n        end\n\
    \        table.insert(levels, next_level)\n    end\n    return levels\nend", " \
    \ local ans = {}\n  while n > 0 do\n    table.insert(ans, n)\n    if n % 2 ==\
    \ 0 then\n      n = n - 1\n    else\n      n = n - 2\n    end\n  end\n  return\
    \ ans\nend", "    local pile = {}\n    local stones_on_level = n\n    while stones_on_level\
    \ > 0 do\n        table.insert(pile, stones_on_level)\n        if stones_on_level\
    \ % 2 == 0 then\n            stones_on_level = stones_on_level + 1\n        else\n\
    \            stones_on_level = stones_on_level + 2\n        end\n    end\n   \
    \ return pile\nend", "    local t = {n}\n    while t[#t] > 0 do\n        if t[#t]\
    \ % 2 == 0 then\n            t[#t+1] = t[#t] - 1\n        else\n            t[#t+1]\
    \ = t[#t] - 2\n        end\n    end\n    return t\nend", "    local pile = {}\n\
    \    for i = 1, n do\n        if i == 1 then\n            pile[#pile + 1] = n\n\
    \        else\n            pile[#pile + 1] = pile[#pile] + (i % 2 == 0 and 2 or\
    \ 1)\n        end\n    end\n    return pile\nend", "  -- Your code here\nend",
  "  local pile = {n}\n  for i = 1, n - 1 do\n    local prev = pile[i]\n    pile[i\
    \ + 1] = ((prev % 2 == 0) and (prev + 2)) or (prev + 1)\n  end\n  return pile\n\
    end", "  -- TODO\nend", end, "  local output = {}\n  while n > 0 do\n    output[#output+1]\
    \ = n\n    if n % 2 == 0 then\n      n = n + 1\n    else\n      n = n + 2\n  \
    \  end\n  end\n  return output\nend", "    local pile = {}\n    for i = 1, n do\n\
    \        pile[i] = i * 2 - 1\n    end\n    return pile\nend", "  local num = n\n\
    \  local level = 1\n  local t = {}\n  while level <= n do\n    t[level] = num\n\
    \    num = num + 2\n    level = level + 1\n  end\n  return t\nend", "    local\
    \ ret = {}\n    ret[#ret+1] = n\n    while n > 0 do\n        if n % 2 == 0 then\n\
    \            n = n + 1\n        else\n            n = n + 2\n        end\n   \
    \     ret[#ret+1] = n\n    end\n    ret[#ret] = nil\n    return ret\nend", " \
    \   local res = {}\n    local ln = n\n    while ln > 0 do\n        if ln % 2 ==\
    \ 0 then\n            ln = ln / 2\n        else\n            ln = (ln + 1) / 2\n\
    \        end\n        table.insert(res, 2 * ln + 1)\n    end\n    return res\n\
    end", "  local result = {}\n  while n >= 1 do\n    result[#result+1] = n\n   \
    \ if n % 2 == 0 then\n      n = n + 1\n    else\n      n = n + 2\n    end\n  end\n\
    \  return result\nend", "    local res = {}\n    local i = 1\n    while n > 0\
    \ do\n        res[i] = n\n        if n % 2 == 0 then\n            n = n + 1\n\
    \        else\n            n = n + 2\n        end\n        i = i + 1\n    end\n\
    \    return res\nend", "   local pile = { n }\n   while pile[#pile] > 1 do\n \
    \     pile[#pile+1] = (pile[#pile] % 2 == 0) and pile[#pile] - 1 or pile[#pile]\
    \ - 2\n   end\n   return pile\nend", "  local ret = {}\n  for i = 1, n do\n  \
    \  ret[i] = 2 * i - 1\n  end\n  return ret\nend", "  local next_level_stone_count\n\
    \  if n % 2 == 0 then\n    next_level_stone_count = function(x) return x + 2 end\n\
    \  else\n    next_level_stone_count = function(x) return x + 1 end\n  end\n  local\
    \ pile = {n}\n  for i = 1, n - 1 do\n    n = next_level_stone_count(n)\n    table.insert(pile,\
    \ n)\n  end\n  return pile\nend", "  local pile = {n}\n  for i = 2, n do\n   \
    \ if pile[i-1] % 2 == 0 then\n      pile[i] = pile[i-1] + 2\n    else\n      pile[i]\
    \ = pile[i-1] + 1\n    end\n  end\n  return pile\nend", "    local pile = {}\n\
    \    for i = 1, n do\n        table.insert(pile, n)\n        if n % 2 == 0 then\n\
    \            n = n + 1\n        else\n            n = n + 2\n        end\n   \
    \ end\n    return pile\nend", "  local stones = {}\n  for i = 1, n do\n    stones[i]\
    \ = i * 2 + (i - 1)\n  end\n  return stones\nend", "  local function next_level(n)\n\
    \    if n % 2 == 0 then\n      return n + 2\n    else\n      return n + 1\n  \
    \  end\n  end\n  local function helper(n, l)\n    if n == 0 then\n      return\
    \ l\n    else\n      table.insert(l, 1, n)\n      return helper(next_level(n),\
    \ l)\n    end\n  end\n  return helper(n, {})\nend", "  assert(n >= 1)\n  local\
    \ level = n\n  local stones = {n}\n  repeat\n    level = level + (level % 2 ==\
    \ 0 and 2 or 1)\n    stones[#stones + 1] = level\n  until level == n\n  return\
    \ stones\nend", "  local result = {}\n  for i = 1, n do\n    if n % 2 == 0 then\n\
    \      table.insert(result, n + i + i - 1)\n    else\n      table.insert(result,\
    \ n + i + i)\n    end\n  end\n  return result\nend", "  local result = {}\n  for\
    \ i = 1, n do\n    local new_level = 2 * i\n    if (i - 1) % 2 == 0 then new_level\
    \ = new_level + 1 end\n    table.insert(result, new_level)\n  end\n  return result\n\
    end", "  local pile = {n}\n  while n > 1 do\n    n = (n%2==0) and (n-1) or (n+1)\n\
    \    table.insert(pile, n)\n  end\n  return pile\nend", "    local function aux(m,\
    \ acc)\n        if m == 0 then\n            return acc\n        else\n       \
    \     return aux(m - 1, {m, acc[1] + 2, acc[2] + 2})\n        end\n    end\n \
    \   return aux(n, {n, n + 2, n + 2})\nend", "   local list = {}\n   for i = 1,\
    \ n do\n      table.insert(list, i)\n   end\n   return list\nend", "    local\
    \ pile = {}\n    while n > 0 do\n        table.insert(pile, n)\n        if n %\
    \ 2 == 0 then\n            n = n + 1\n        else\n            n = n + 2\n  \
    \      end\n    end\n    return pile\nend", "  local function aux(i, stones)\n\
    \    if i == 0 then\n      return stones\n    else\n      local stones_num = (n\
    \ + i) % 2 == 0 and n + i + 1 or n + i\n      return aux(i - 1, append(stones,\
    \ stones_num))\n    end\n  end\n  return aux(n - 1, {n})\nend", "  local t = {n}\n\
    \  while n>1 do\n    if (n%2)==0 then n = n + 1 else n = n + 2 end\n    t[#t+1]\
    \ = n\n  end\n  return t\nend\nassert(e.make_a_pile(3)=={3,5,7})\nassert(e.make_a_pile(4)=={4,6,8,10})\n\
    assert(e.make_a_pile(5)=={5,7,9,11,13})", "  local make_pile_n = function(n, pile)\n\
    \    if n == 0 then\n      return pile\n    else\n      local level = n + (n %\
    \ 2)\n      return make_pile_n(n - 1, {level, unpack(pile)})\n    end\n  end\n\
    \  return make_pile_n(n, {})\nend", "  if n < 1 then return {} end\n  local t\
    \ = {n}\n  local num = n % 2 == 0 and n+1 or n+2\n  while num < n * 2 do\n   \
    \ t[#t+1] = num\n    num = num % 2 == 0 and num+1 or num+2\n  end\n  return t\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
