name: HumanEval_5_intersperse
language: lua
prompt: "-- Insert a number 'delimeter' between every two consecutive elements of\
  \ input list `numbers'\n-- >>> intersperse([], 4)\n-- []\n-- >>> intersperse([1,\
  \ 2, 3], 4)\n-- [1, 4, 2, 4, 3]\nlocal function intersperse(numbers, delimeter)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersperse\n\
  \    lu.assertEquals(candidate({}, 7), {})\n    lu.assertEquals(candidate({5, 6,\
  \ 3, 2}, 8), {5, 8, 6, 8, 3, 8, 2})\n    lu.assertEquals(candidate({2, 2, 2}, 2),\
  \ {2, 2, 2, 2, 2})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local result = {}\n    for i = 1, #numbers - 1 do\n        result[#result\
    \ + 1] = numbers[i]\n        result[#result + 1] = delimeter\n    end\n    result[#result\
    \ + 1] = numbers[#numbers]\n    return result\nend", "  local result = {}\n  for\
    \ i, number in ipairs(numbers) do\n    table.insert(result, number)\n    if i\
    \ < #numbers then\n      table.insert(result, delimeter)\n    end\n  end\n  return\
    \ result\nend", "  local result = {}\n  for i, number in ipairs(numbers) do\n\
    \    result[#result + 1] = number\n    if i < #numbers then\n      result[#result\
    \ + 1] = delimeter\n    end\n  end\n  return result\nend", "    local result =\
    \ {}\n    for i = 1, #numbers - 1 do\n        result[i * 2 - 1] = numbers[i]\n\
    \        result[i * 2] = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n\
    \    return result\nend", "    local output = {}\n    for i = 1, #numbers - 1\
    \ do\n        output[i * 2 - 1] = numbers[i]\n        output[i * 2] = delimeter\n\
    \    end\n    output[#output] = numbers[#numbers]\n    return output\nend", " \
    \   local out = {}\n    for i, v in ipairs(numbers) do\n        table.insert(out,\
    \ v)\n        if i ~= #numbers then\n            table.insert(out, delimeter)\n\
    \        end\n    end\n    return out\nend", "  local tmp = {}\n  for i, v in\
    \ ipairs(numbers) do\n    if i > 1 then\n      tmp[#tmp + 1] = delimeter\n   \
    \ end\n    tmp[#tmp + 1] = v\n  end\n  return tmp\nend", "    if #numbers == 0\
    \ then\n        return {}\n    end\n    local numbers_with_delimeter = {}\n  \
    \  local insert_position = 0\n    for i, v in ipairs(numbers) do\n        insert_position\
    \ = insert_position + 1\n        numbers_with_delimeter[insert_position] = v\n\
    \        if i ~= #numbers then\n            insert_position = insert_position\
    \ + 1\n            numbers_with_delimeter[insert_position] = delimeter\n     \
    \   end\n    end\n    return numbers_with_delimeter\nend", "  local result = {}\n\
    \  for i = 1, #numbers do\n    result[#result + 1] = numbers[i]\n    if i < #numbers\
    \ then\n      result[#result + 1] = delimeter\n    end\n  end\n  return result\n\
    end", "\tif numbers == nil or #numbers == 0 then\n\t\treturn numbers\n\tend\n\t\
    local result = {numbers[1]}\n\tfor i = 2, #numbers do\n\t\ttable.insert(result,\
    \ delimeter)\n\t\ttable.insert(result, numbers[i])\n\tend\n\treturn result\nend",
  "    local n = #numbers\n    if n == 0 then\n        return {}\n    elseif n ==\
    \ 1 then\n        return numbers\n    else\n        local new_numbers = {}\n \
    \       for i = 1, n - 1 do\n            new_numbers[2 * i - 1] = numbers[i]\n\
    \            new_numbers[2 * i] = delimeter\n        end\n        new_numbers[2\
    \ * n - 1] = numbers[n]\n        return new_numbers\n    end\nend", "    local\
    \ new_list = {}\n    local len = #numbers\n    if len == 0 then\n        return\
    \ new_list\n    end\n    for i, v in ipairs(numbers) do\n        table.insert(new_list,\
    \ v)\n        if i < len then\n            table.insert(new_list, delimeter)\n\
    \        end\n    end\n    return new_list\nend", "  local result = {}\n  for\
    \ i, number in ipairs(numbers) do\n    result[#result + 1] = number\n    if i\
    \ < #numbers then\n      result[#result + 1] = delimeter\n    end\n  end\n  return\
    \ result\nend", "  local r = {}\n  for i = 1, #numbers - 1 do\n    r[#r + 1] =\
    \ numbers[i]\n    r[#r + 1] = delimeter\n  end\n  r[#r + 1] = numbers[#numbers]\n\
    \  return r\nend", "    local ret = {}\n    for i, num in ipairs(numbers) do\n\
    \        ret[#ret + 1] = num\n        if i < #numbers then\n            ret[#ret\
    \ + 1] = delimeter\n        end\n    end\n    return ret\nend", "    local result\
    \ = {}\n    for i = 1, #numbers - 1 do\n        table.insert(result, numbers[i])\n\
    \        table.insert(result, delimeter)\n    end\n    table.insert(result, numbers[#numbers])\n\
    \    return result\nend", "    local res = {}\n    for i = 1, #numbers - 1 do\n\
    \        res[#res + 1] = numbers[i]\n        res[#res + 1] = delimeter\n    end\n\
    \    res[#res + 1] = numbers[#numbers]\n    return res\nend", "\tif #numbers <\
    \ 2 then\n\t\treturn numbers\n\tend\n\tlocal result = {}\n\tfor i = 1, #numbers\
    \ - 1 do\n\t\tresult[#result + 1] = numbers[i]\n\t\tresult[#result + 1] = delimeter\n\
    \tend\n\tresult[#result + 1] = numbers[#numbers]\n\treturn result\nend", "   \
    \ local result = {}\n    for i, v in ipairs(numbers) do\n        result[#result\
    \ + 1] = v\n        if i < #numbers then\n            result[#result + 1] = delimeter\n\
    \        end\n    end\n    return result\nend", "    local result = {}\n    for\
    \ i = 1, #numbers - 1 do\n        result[#result + 1] = numbers[i]\n        result[#result\
    \ + 1] = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n   \
    \ return result\nend", "    local result = {}\n    for i = 1, #numbers do\n  \
    \      result[2 * i - 1] = numbers[i]\n        result[2 * i] = delimeter\n   \
    \ end\n    result[#result] = nil\n    return result\nend", "    local result =\
    \ {}\n    local index = 1\n    for i = 1, #numbers do\n        result[index] =\
    \ numbers[i]\n        if i < #numbers then\n            index = index + 1\n  \
    \          result[index] = delimeter\n        end\n        index = index + 1\n\
    \    end\n    return result\nend", "  local result = {}\n  for i = 1, #numbers\
    \ - 1 do\n    table.insert(result, numbers[i])\n    table.insert(result, delimeter)\n\
    \  end\n  table.insert(result, numbers[#numbers])\n  return result\nend", "  local\
    \ out = {}\n  for i = 1, #numbers do\n    out[#out + 1] = numbers[i]\n    if i\
    \ < #numbers then\n      out[#out + 1] = delimeter\n    end\n  end\n  return out\n\
    end", "\tlocal t = {}\n\tfor i = 1, #numbers - 1 do\n\t\tt[#t + 1] = numbers[i]\n\
    \t\tt[#t + 1] = delimeter\n\tend\n\tt[#t + 1] = numbers[#numbers]\n\treturn t\n\
    end", "    local result = {}\n    for i = 1, #numbers - 1 do\n        result[i\
    \ * 2 - 1] = numbers[i]\n        result[i * 2] = delimeter\n    end\n    result[#result\
    \ + 1] = numbers[#numbers]\n    return result\nend", "    local result = {}\n\
    \    local n = #numbers\n    for i = 1, n - 1 do\n        result[#result + 1]\
    \ = numbers[i]\n        result[#result + 1] = delimeter\n    end\n    result[#result\
    \ + 1] = numbers[n]\n    return result\nend", "    local result = {}\n    for\
    \ i = 1, #numbers - 1 do\n        result[#result + 1] = numbers[i]\n        result[#result\
    \ + 1] = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n   \
    \ return result\nend", "  if (#numbers == 0) then\n    return numbers\n  end\n\
    \  if (#numbers == 1) then\n    return numbers\n  end\n  local result = {}\n \
    \ for i, number in ipairs(numbers) do\n    if (i ~= 1) then\n      table.insert(result,\
    \ delimeter)\n    end\n    table.insert(result, number)\n  end\n  return result\n\
    end", "  if #numbers == 0 then\n    return {}\n  elseif #numbers == 1 then\n \
    \   return numbers\n  else\n    return {numbers[1], delimeter, unpack(intersperse(slice(numbers,\
    \ 2), delimeter))}\n  end\nend", "    local result = {}\n    for index, number\
    \ in ipairs(numbers) do\n        if index ~= 1 then\n            table.insert(result,\
    \ delimeter)\n        end\n        table.insert(result, number)\n    end\n   \
    \ return result\nend", "  if (#numbers == 0) then\n    return {}\n  elseif (#numbers\
    \ == 1) then\n    return numbers\n  else\n    local output = {}\n    for i = 1,\
    \ #numbers - 1 do\n      table.insert(output, numbers[i])\n      table.insert(output,\
    \ delimeter)\n    end\n    table.insert(output, numbers[#numbers])\n    return\
    \ output\n  end\nend", "    local result = {}\n    for i, v in ipairs(numbers)\
    \ do\n        table.insert(result, v)\n        if i < #numbers then\n        \
    \    table.insert(result, delimeter)\n        end\n    end\n    return result\n\
    end", "    if not numbers or type(numbers) ~= 'table' then\n        return {delimeter}\n\
    \    end\n    local interspersed = {}\n    for i, num in ipairs(numbers) do\n\
    \        if i ~= 1 then\n            table.insert(interspersed, delimeter)\n \
    \       end\n        table.insert(interspersed, num)\n    end\n    return interspersed\n\
    end", "\tlocal result = {}\n\tfor i = 1, #numbers - 1 do\n\t\tresult[i * 2 - 1]\
    \ = numbers[i]\n\t\tresult[i * 2] = delimeter\n\tend\n\tresult[#result] = numbers[#numbers]\n\
    \treturn result\nend", "    local result = {}\n    for i = 1, #numbers - 1 do\n\
    \        table.insert(result, numbers[i])\n        table.insert(result, delimeter)\n\
    \    end\n    table.insert(result, numbers[#numbers])\n    return result\nend",
  "    local result = {}\n    local n = #numbers\n    if n == 0 then\n        return\
    \ result\n    end\n    result[1] = numbers[1]\n    for i = 2, n do\n        result[(i\
    \ - 1) * 2] = delimeter\n        result[(i - 1) * 2 + 1] = numbers[i]\n    end\n\
    \    return result\nend", "    local result = {}\n    for i = 1, #numbers do\n\
    \        result[#result + 1] = numbers[i]\n        if i < #numbers then\n    \
    \        result[#result + 1] = delimeter\n        end\n    end\n    return result\n\
    end", "    if #numbers == 0 then\n        return {}\n    end\n    local result\
    \ = {numbers[1]}\n    for i = 2, #numbers do\n        result[#result + 1] = delimeter\n\
    \        result[#result + 1] = numbers[i]\n    end\n    return result\nend", " \
    \ local result = {}\n  local len = #numbers\n  for i = 1, len do\n    if i > 1\
    \ then\n      table.insert(result, delimeter)\n    end\n    table.insert(result,\
    \ numbers[i])\n  end\n  return result\nend", "    local result = {}\n    local\
    \ previous_element = nil\n    for _, x in ipairs(numbers) do\n        if previous_element\
    \ ~= nil then\n            table.insert(result, delimeter)\n        end\n    \
    \    table.insert(result, x)\n        previous_element = x\n    end\n    return\
    \ result\nend", "    if #numbers == 0 then\n        return {}\n    end\n    if\
    \ #numbers == 1 then\n        return numbers\n    end\n    local output = {}\n\
    \    for i, number in ipairs(numbers) do\n        output[i * 2 - 1] = number\n\
    \        output[i * 2] = delimeter\n    end\n    output[#output] = nil\n    return\
    \ output\nend", "  local result = {}\n  for i, v in ipairs(numbers) do\n    result[#result\
    \ + 1] = v\n    if i < #numbers then\n      result[#result + 1] = delimeter\n\
    \    end\n  end\n  return result\nend", "    local result = {}\n    local index\
    \ = 1\n    for i = 1, #numbers do\n        result[index] = numbers[i]\n      \
    \  if i < #numbers then\n            index = index + 1\n            result[index]\
    \ = delimeter\n        end\n        index = index + 1\n    end\n    return result\n\
    end", "    if #numbers == 0 then\n        return {}\n    end\n    return each_pair(numbers,\
    \ function(number, rest)\n        return table.concat({number, delimeter, rest})\n\
    \    end)\nend", "  if #numbers == 0 then\n    return {}\n  elseif #numbers ==\
    \ 1 then\n    return numbers\n  else\n    local result = {}\n    local current_index\
    \ = 1\n    for i = 1, #numbers - 1 do\n      result[current_index] = numbers[i]\n\
    \      result[current_index + 1] = delimeter\n      current_index = current_index\
    \ + 2\n    end\n    result[current_index] = numbers[#numbers]\n    return result\n\
    \  end\nend", "    local results = {}\n    for i = 1, #numbers do\n        table.insert(results,\
    \ numbers[i])\n        if i < #numbers then\n            table.insert(results,\
    \ delimeter)\n        end\n    end\n    return results\nend", "    local result\
    \ = {}\n    for _, num in ipairs(numbers) do\n        table.insert(result, num)\n\
    \        table.insert(result, delimeter)\n    end\n    table.remove(result)\n\
    \    return result\nend", "    local interspersed = {}\n    for i = 1, #numbers\
    \ do\n        if i > 1 then\n            interspersed[#interspersed + 1] = delimeter\n\
    \        end\n        interspersed[#interspersed + 1] = numbers[i]\n    end\n\
    \    return interspersed\nend", "    if #numbers == 0 then\n        return {}\n\
    \    end\n    local result = { numbers[1] }\n    for i = 2, #numbers do\n    \
    \    table.insert(result, delimeter)\n        table.insert(result, numbers[i])\n\
    \    end\n    return result\nend", "    local result = {}\n    for i, number in\
    \ ipairs(numbers) do\n        table.insert(result, number)\n        if i < #numbers\
    \ then\n            table.insert(result, delimeter)\n        end\n    end\n  \
    \  return result\nend", "  local result = {}\n  for i = 1, #numbers - 1 do\n \
    \   result[#result + 1] = numbers[i]\n    result[#result + 1] = delimeter\n  end\n\
    \  result[#result + 1] = numbers[#numbers]\n  return result\nend", "    if #numbers\
    \ < 2 then\n        return numbers\n    end\n    local result = {}\n    for index,\
    \ number in ipairs(numbers) do\n        table.insert(result, number)\n       \
    \ if index ~= #numbers then\n            table.insert(result, delimeter)\n   \
    \     end\n    end\n    return result\nend", "  local result = {}\n  for i = 1,\
    \ #numbers do\n    result[#result + 1] = numbers[i]\n    if i < #numbers then\n\
    \      result[#result + 1] = delimeter\n    end\n  end\n  return result\nend",
  "    if #numbers == 0 then\n        return {}\n    end\n    local result = {numbers[1]}\n\
    \    for index = 2, #numbers do\n        result[#result + 1] = delimeter\n   \
    \     result[#result + 1] = numbers[index]\n    end\n    return result\nend",
  "    local result = {}\n    local len = #numbers\n    for i = 1, len do\n      \
    \  table.insert(result, numbers[i])\n        if i < len then\n            table.insert(result,\
    \ delimeter)\n        end\n    end\n    return result\nend", "\tif not numbers\
    \ or #numbers == 0 then\n\t\treturn {}\n\tend\n\tlocal result = { numbers[1] }\n\
    \tfor i = 2, #numbers do\n\t\ttable.insert(result, delimeter)\n\t\ttable.insert(result,\
    \ numbers[i])\n\tend\n\treturn result\nend", "  if #numbers == 0 then\n    return\
    \ {}\n  elseif #numbers == 1 then\n    return numbers\n  else\n    local l = {}\n\
    \    for i, n in ipairs(numbers) do\n      if i ~= 1 then\n        table.insert(l,\
    \ delimeter)\n      end\n      table.insert(l, n)\n    end\n    return l\n  end\n\
    end", "  if #numbers == 0 then\n    return {}\n  elseif #numbers == 1 then\n \
    \   return numbers\n  else\n    local res = {}\n    for i = 1, #numbers do\n \
    \     res[i] = numbers[i]\n      if i ~= #numbers then\n        res[i + 1] = delimeter\n\
    \      end\n    end\n    return res\n  end\nend", "    local num = #numbers\n\
    \    if num == 0 then\n        return {}\n    elseif num == 1 then\n        return\
    \ numbers\n    else\n        local result = {}\n        for i = 1, num do\n  \
    \          result[#result + 1] = numbers[i]\n            if i < num then\n   \
    \             result[#result + 1] = delimeter\n            end\n        end\n\
    \        return result\n    end\nend", "  local result = {}\n  for i, v in ipairs(numbers)\
    \ do\n    if i > 1 then\n      table.insert(result, delimeter)\n    end\n    table.insert(result,\
    \ v)\n  end\n  return result\nend", "  local result = {}\n  local index = 1\n\
    \  for i, element in ipairs(numbers) do\n    result[index] = element\n    index\
    \ = index + 1\n    if i < #numbers then\n      result[index] = delimeter\n   \
    \   index = index + 1\n    end\n  end\n  return result\nend", "    if #numbers\
    \ == 0 then\n        return {}\n    end\n    local head = numbers[1]\n    local\
    \ tail = slice(numbers, 2)\n    return cons(head, concat(map(tail, function(n)\
    \ return {delimeter, n} end)))\nend", "    local interspersed = {}\n    for i\
    \ = 1, #numbers do\n        table.insert(interspersed, numbers[i])\n        if\
    \ i < #numbers then\n            table.insert(interspersed, delimeter)\n     \
    \   end\n    end\n    return interspersed\nend", "    local res = {}\n    for\
    \ i, v in ipairs(numbers) do\n        if i ~= 1 then\n            table.insert(res,\
    \ delimeter)\n        end\n        table.insert(res, v)\n    end\n    return res\n\
    end", "\tlocal result = {}\n\tfor i = 1, #numbers - 1 do\n\t\tresult[#result +\
    \ 1] = numbers[i]\n\t\tresult[#result + 1] = delimeter\n\tend\n\tresult[#result\
    \ + 1] = numbers[#numbers]\n\treturn result\nend", "    local result = {}\n  \
    \  for i, value in ipairs(numbers) do\n        table.insert(result, value)\n \
    \       if i < #numbers then\n            table.insert(result, delimeter)\n  \
    \      end\n    end\n    return result\nend", "    local result = {}\n    local\
    \ t = #numbers\n    for i = 1, t do\n        table.insert(result, numbers[i])\n\
    \        if i < t then\n            table.insert(result, delimeter)\n        end\n\
    \    end\n    return result\nend", "    local res = {}\n    for i = 1, #numbers\
    \ do\n        res[#res + 1] = numbers[i]\n        if i < #numbers then\n     \
    \       res[#res + 1] = delimeter\n        end\n    end\n    return res\nend",
  "    if type(numbers) ~= 'table' then\n        error('Argument `numbers` is not\
    \ a table')\n    end\n    if type(delimeter) ~= 'number' then\n        error('Argument\
    \ `delimeter` is not a number')\n    end\n    if (#numbers < 2) then\n       \
    \ return numbers\n    end\n    local new_list = {}\n    for i = 1, #numbers -\
    \ 1 do\n        new_list[#new_list + 1] = numbers[i]\n        new_list[#new_list\
    \ + 1] = delimeter\n    end\n    new_list[#new_list + 1] = numbers[#numbers]\n\
    \    return new_list\nend", "    if #numbers == 0 then\n        return {}\n  \
    \  end\n    if #numbers == 1 then\n        return numbers\n    end\n    local\
    \ result = {}\n    for i = 1, #numbers - 1 do\n        table.insert(result, numbers[i])\n\
    \        table.insert(result, delimeter)\n    end\n    table.insert(result, numbers[#numbers])\n\
    \    return result\nend", "    local list = {}\n    for i, v in ipairs(numbers)\
    \ do\n        table.insert(list, v)\n        if i ~= #numbers then\n         \
    \   table.insert(list, delimeter)\n        end\n    end\n    return list\nend",
  "\tlocal result = {}\n\tfor index, number in ipairs(numbers) do\n\t\tif index >\
    \ 1 then\n\t\t\ttable.insert(result, delimeter)\n\t\tend\n\t\ttable.insert(result,\
    \ number)\n\tend\n\treturn result\nend", "\tlocal result = {}\n\tfor i = 1, #numbers\
    \ - 1 do\n\t\ttable.insert(result, numbers[i])\n\t\ttable.insert(result, delimeter)\n\
    \tend\n\tif #numbers > 0 then\n\t\ttable.insert(result, numbers[#numbers])\n\t\
    end\n\treturn result\nend", "\tlocal result = {}\n\tfor i = 1, #numbers - 1 do\n\
    \t\tresult[#result + 1] = numbers[i]\n\t\tresult[#result + 1] = delimeter\n\t\
    end\n\tresult[#result + 1] = numbers[#numbers]\n\treturn result\nend", "\tlocal\
    \ result = {}\n\tfor i = 1, #numbers do\n\t\tresult[#result + 1] = numbers[i]\n\
    \t\tif i < #numbers then\n\t\t\tresult[#result + 1] = delimeter\n\t\tend\n\tend\n\
    \treturn result\nend", "    local numbers = numbers or {}\n    local result =\
    \ {}\n    for i = 1, #numbers do\n        result[2 * i - 1] = numbers[i]\n   \
    \     result[2 * i] = delimeter\n    end\n    result[#result] = nil\n    return\
    \ result\nend", "    local result = {}\n    for i = 1, #numbers - 1 do\n     \
    \   result[#result + 1] = numbers[i]\n        result[#result + 1] = delimeter\n\
    \    end\n    result[#result + 1] = numbers[#numbers]\n    return result\nend",
  "    local ret = {}\n    for i = 1, #numbers - 1 do\n        ret[#ret + 1] = numbers[i]\n\
    \        ret[#ret + 1] = delimeter\n    end\n    ret[#ret + 1] = numbers[#numbers]\n\
    \    return ret\nend", "\tlocal result = {}\n\tlocal n = #numbers\n\tfor i, number\
    \ in ipairs(numbers) do\n\t\tresult[#result + 1] = number\n\t\tif i < n then\n\
    \t\t\tresult[#result + 1] = delimeter\n\t\tend\n\tend\n\treturn result\nend",
  "  local result = {}\n  for i = 1, #numbers - 1 do\n    result[#result + 1] = numbers[i]\n\
    \    result[#result + 1] = delimeter\n  end\n  result[#result + 1] = numbers[#numbers]\n\
    \  return result\nend", "    local ret = {}\n    for i = 1, #numbers - 1 do\n\
    \        ret[#ret + 1] = numbers[i]\n        ret[#ret + 1] = delimeter\n    end\n\
    \    ret[#ret + 1] = numbers[#numbers]\n    return ret\nend", "    local result\
    \ = {}\n    for i = 1, #numbers - 1 do\n        table.insert(result, numbers[i])\n\
    \        table.insert(result, delimeter)\n    end\n    table.insert(result, numbers[#numbers])\n\
    \    return result\nend", "  if #numbers == 0 then\n    return {}\n  elseif #numbers\
    \ == 1 then\n    return numbers\n  else\n    return {numbers[1], delimeter, intersperse(slice(numbers,\
    \ 2), delimeter)}\n  end\nend", "    local result = {}\n    for i, v in ipairs(numbers)\
    \ do\n        if i ~= 1 then\n            table.insert(result, delimeter)\n  \
    \      end\n        table.insert(result, v)\n    end\n    return result\nend",
  "    local result = {}\n    for i, n in ipairs(numbers) do\n        result[#result\
    \ + 1] = n\n        if i < #numbers then\n            result[#result + 1] = delimeter\n\
    \        end\n    end\n    return result\nend", "    local result = {}\n    local\
    \ i = 1\n    while i <= #numbers do\n        if i == 1 then\n            result[i]\
    \ = numbers[i]\n        else\n            result[#result + 1] = delimeter\n  \
    \          result[#result + 1] = numbers[i]\n        end\n        i = i + 1\n\
    \    end\n    return result\nend", "    local result = {}\n    for i = 1, #numbers\
    \ - 1 do\n        table.insert(result, numbers[i])\n        table.insert(result,\
    \ delimeter)\n    end\n    table.insert(result, numbers[#numbers])\n    return\
    \ result\nend", "    local result = {}\n    local length = #numbers\n    for i,\
    \ v in ipairs(numbers) do\n        result[i * 2 - 1] = v\n        if i ~= length\
    \ then\n            result[i * 2] = delimeter\n        end\n    end\n    return\
    \ result\nend", "    local len = #numbers\n    if len == 0 then\n        return\
    \ {}\n    elseif len == 1 then\n        return numbers\n    else\n        local\
    \ res = {}\n        for i = 1, len - 1 do\n            res[#res + 1] = numbers[i]\n\
    \            res[#res + 1] = delimeter\n        end\n        res[#res + 1] = numbers[len]\n\
    \        return res\n    end\nend", "    if #numbers == 0 then\n        return\
    \ {}\n    end\n    local result = {numbers[1]}\n    for i = 2, #numbers do\n \
    \       table.insert(result, delimeter)\n        table.insert(result, numbers[i])\n\
    \    end\n    return result\nend", "    local result = {}\n    for i = 1, #numbers\
    \ - 1 do\n        result[#result + 1] = numbers[i]\n        result[#result + 1]\
    \ = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n    return\
    \ result\nend", "    local result = {}\n    for i = 1, #numbers - 1 do\n     \
    \   table.insert(result, numbers[i])\n        table.insert(result, delimeter)\n\
    \    end\n    table.insert(result, numbers[#numbers])\n    return result\nend",
  "    local res = {}\n    for i = 1, #numbers - 1 do\n        res[#res + 1] = numbers[i]\n\
    \        res[#res + 1] = delimeter\n    end\n    res[#res + 1] = numbers[#numbers]\n\
    \    return res\nend", "    local ret = {}\n    for i = 1, #numbers - 1 do\n \
    \       ret[#ret + 1] = numbers[i]\n        ret[#ret + 1] = delimeter\n    end\n\
    \    ret[#ret + 1] = numbers[#numbers]\n    return ret\nend", "  local result\
    \ = {}\n  local _list_0 = numbers\n  for _index_0 = 1, #_list_0 do\n    local\
    \ _continue_0 = false\n    repeat\n      local n = _list_0[_index_0]\n      table.insert(result,\
    \ n)\n      table.insert(result, delimeter)\n      _continue_0 = true\n    until\
    \ true\n    if not _continue_0 then\n      break\n    end\n  end\n  return result\n\
    end\nreturn {\n  APPENDIX_ONE = APPENDIX_ONE,\n  APPENDIX_TWO = APPENDIX_TWO,\n\
    \  APPENDIX_THREE = APPENDIX_THREE,\n  APPENDIX_FOUR = APPENDIX_FOUR,\n  APPENDIX_FIVE\
    \ = APPENDIX_FIVE,\n  APPENDIX_SIX = APPENDIX_SIX,\n  APPENDIX_SEVEN = APPENDIX_SEVEN,\n\
    \  APPENDIX_EIGHT = APPENDIX_EIGHT,\n  APPENDIX_NINE = APPENDIX_NINE,\n  APPENDIX_TEN\
    \ = APPENDIX_TEN,\n  APPENDIX_ELEVEN = APPENDIX_ELEVEN,\n  APPENDIX_TWELVE = APPENDIX_TWELVE,\n\
    \  APPENDIX_THIRTEEN = APPENDIX_THIRTEEN,\n  APPENDIX_FOURTEEN = APPENDIX_FOURTEEN,\n\
    \  APPENDIX_FIFTEEN = APPENDIX_FIFTEEN,\n  APPENDIX_SIXTEEN = APPENDIX_SIXTEEN,\n\
    \  APPENDIX_SEVENTEEN = APPENDIX_SEVENTEEN,\n  APPENDIX_EIGHTEEN = APPENDIX_EIGHTEEN,\n\
    \  APPENDIX_NINETEEN = APPENDIX_NINETEEN,\n  APPENDIX_TWENTY = APPENDIX_TWENTY,\n\
    \  APPENDIX_TWENTY_ONE = APPENDIX_TWENTY_ONE,\n  APPENDIX_TWENTY_TWO = APPENDIX_",
  "\tlocal result = {}\n\tfor i = 1, #numbers do\n\t\tif i > 1 then\n\t\t\ttable.insert(result,\
    \ delimeter)\n\t\tend\n\t\ttable.insert(result, numbers[i])\n\tend\n\treturn result\n\
    end", "  local result = {}\n  for i, number in ipairs(numbers) do\n    if i >\
    \ 1 then\n      table.insert(result, delimeter)\n    end\n    table.insert(result,\
    \ number)\n  end\n  return result\nend", "    local result = {}\n    for i, v\
    \ in ipairs(numbers) do\n        result[#result + 1] = v\n        if i < #numbers\
    \ then\n            result[#result + 1] = delimeter\n        end\n    end\n  \
    \  return result\nend", "    local result = {}\n    for i, v in ipairs(numbers)\
    \ do\n        if i ~= 1 then table.insert(result, delimeter) end\n        table.insert(result,\
    \ v)\n    end\n    return result\nend", "  local result = {}\n  for i = 1, #numbers\
    \ - 1 do\n    result[i*2 - 1] = numbers[i]\n    result[i*2] = delimeter\n  end\n\
    \  result[#result] = numbers[#numbers]\n  return result\nend", "    local result\
    \ = {}\n    for i = 1, #numbers - 1 do\n        result[#result + 1] = numbers[i]\n\
    \        result[#result + 1] = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n\
    \    return result\nend", "    if #numbers < 2 then\n        return numbers\n\
    \    end\n    local result = {}\n    for i = 1, #numbers - 1 do\n        table.insert(result,\
    \ numbers[i])\n        table.insert(result, delimeter)\n    end\n    table.insert(result,\
    \ numbers[#numbers])\n    return result\nend", "  if #numbers == 0 then\n    return\
    \ {}\n  elseif #numbers == 1 then\n    return numbers\n  else\n    local result\
    \ = {}\n    for i, number in ipairs(numbers) do\n      if i ~= 1 then\n      \
    \  table.insert(result, delimeter)\n      end\n      table.insert(result, number)\n\
    \    end\n    return result\n  end\nend", "    local sequence = {}\n    for i,\
    \ number in ipairs(numbers) do\n        table.insert(sequence, number)\n     \
    \   if i ~= #numbers then\n            table.insert(sequence, delimeter)\n   \
    \     end\n    end\n    return sequence\nend", "\tlocal result = {}\n\tlocal prev\n\
    \tfor i, number in ipairs(numbers) do\n\t\tif prev then\n\t\t\ttable.insert(result,\
    \ prev)\n\t\t\ttable.insert(result, delimeter)\n\t\tend\n\t\tprev = number\n\t\
    end\n\tif prev then\n\t\ttable.insert(result, prev)\n\tend\n\treturn result\n\
    end", "    local result = {}\n    for i = 1, #numbers do\n        result[i * 2\
    \ - 1] = numbers[i]\n        result[i * 2] = delimeter\n    end\n    result[#result]\
    \ = nil\n    return result\nend", "    local output = {}\n    for i = 1, #numbers\
    \ do\n        table.insert(output, numbers[i])\n        if i < #numbers then\n\
    \            table.insert(output, delimeter)\n        end\n    end\n    return\
    \ output\nend", "    local result = {}\n    for i, v in ipairs(numbers) do\n \
    \       if i > 1 then\n            table.insert(result, delimeter)\n        end\n\
    \        table.insert(result, v)\n    end\n    return result\nend", "  local res\
    \ = {}\n  local len = #numbers\n  for i = 1, len do\n    table.insert(res, numbers[i])\n\
    \    if i < len then\n      table.insert(res, delimeter)\n    end\n  end\n  return\
    \ res\nend", "    local new_list = {}\n    for i, n in ipairs(numbers) do\n  \
    \      if i > 1 then\n            table.insert(new_list, delimeter)\n        end\n\
    \        table.insert(new_list, n)\n    end\n    return new_list\nend", "    local\
    \ result = {}\n    for i = 1, #numbers do\n        table.insert(result, numbers[i])\n\
    \        if i < #numbers then\n            table.insert(result, delimeter)\n \
    \       end\n    end\n    return result\nend", "  local result = {}\n  for i,\
    \ n in ipairs(numbers) do\n    table.insert(result, n)\n    if i < #numbers then\n\
    \      table.insert(result, delimeter)\n    end\n  end\n  return result\nend",
  "    local result = {}\n    for i = 1, #numbers - 1 do\n        local number = numbers[i]\n\
    \        table.insert(result, number)\n        table.insert(result, delimeter)\n\
    \    end\n    if #numbers > 0 then\n        table.insert(result, numbers[#numbers])\n\
    \    end\n    return result\nend", "  return map(function(number, i)\n    if i\
    \ % 2 == 0 then\n      return number\n    else\n      return delimeter\n    end\n\
    \  end, numbers)\nend", "  return (numbers:slice(1, #numbers-1)):zip(numbers:slice(2,\
    \ #numbers)):reduce(function(acc, pair)\n    return acc .. pair[1] .. delimeter\
    \ .. pair[2]\n  end, numbers[1])\nend", "    local result = {}\n    for i, number\
    \ in ipairs(numbers) do\n        table.insert(result, number)\n        if i <\
    \ #numbers then\n            table.insert(result, delimeter)\n        end\n  \
    \  end\n    return result\nend", "\tlocal ret = {}\n\tfor i, n in ipairs(numbers)\
    \ do\n\t\tret[i * 2 - 1] = n\n\t\tret[i * 2] = delimeter\n\tend\n\treturn ret\n\
    end", "  local list = {}\n  for i, number in ipairs(numbers) do\n    if i == 1\
    \ then\n      table.insert(list, number)\n    else\n      table.insert(list, delimeter)\n\
    \      table.insert(list, number)\n    end\n  end\n  return list\nend", "    if\
    \ #numbers < 2 then\n        return numbers\n    end\n    local result = {}\n\
    \    for i = 1, #numbers - 1 do\n        result[#result + 1] = numbers[i]\n  \
    \      result[#result + 1] = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n\
    \    return result\nend", "\tlocal res = {}\n\tlocal last = 0\n\tfor i = 1, #numbers\
    \ do\n\t\tres[last + 1] = numbers[i]\n\t\tres[last + 2] = delimeter\n\t\tlast\
    \ = last + 2\n\tend\n\tres[last] = nil\n\treturn res\nend", "    local result\
    \ = {}\n    for i = 1, #numbers do\n        result[2 * i - 1] = numbers[i]\n \
    \       result[2 * i] = delimeter\n    end\n    result[#result] = nil\n    return\
    \ result\nend", "  if (#numbers == 0) then\n    return numbers\n  end\n  local\
    \ result = {}\n  for i, v in ipairs(numbers) do\n    table.insert(result, v)\n\
    \    if (i < #numbers) then\n      table.insert(result, delimeter)\n    end\n\
    \  end\n  return result\nend", "  local result = {}\n  for i = 1, #numbers do\n\
    \    result[#result + 1] = numbers[i]\n    if i < #numbers then\n      result[#result\
    \ + 1] = delimeter\n    end\n  end\n  return result\nend", "  local result = {}\n\
    \  for index, number in ipairs(numbers) do\n    if index > 1 then\n      table.insert(result,\
    \ delimeter)\n    end\n    table.insert(result, number)\n  end\n  return result\n\
    end", "  local result = {}\n  for _, num in ipairs(numbers) do\n    table.insert(result,\
    \ num)\n    table.insert(result, delimeter)\n  end\n  table.remove(result)\n \
    \ return result\nend", "    if (#numbers < 2) then\n        return numbers\n \
    \   end\n    local result = {}\n    for i, number in ipairs(numbers) do\n    \
    \    table.insert(result, number)\n        if (i < #numbers) then\n          \
    \  table.insert(result, delimeter)\n        end\n    end\n    return result\n\
    end", "\tif next(numbers) == nil then\n\t\treturn {}\n\tend\n\tlocal newNumbers\
    \ = {}\n\tfor i = 1, #numbers do\n\t\tif i ~= 1 then\n\t\t\ttable.insert(newNumbers,\
    \ delimeter)\n\t\tend\n\t\ttable.insert(newNumbers, numbers[i])\n\tend\n\treturn\
    \ newNumbers\nend", "\tlocal result = {}\n\tfor i = 1, #numbers do\n\t\tresult[2\
    \ * i - 1] = numbers[i]\n\t\tresult[2 * i] = delimeter\n\tend\n\tresult[#result]\
    \ = nil -- Remove the last element, so that result list has no trailing delimeter\n\
    \treturn result\nend", "  local output = {}\n  for i = 1, #numbers - 1 do\n  \
    \  output[#output + 1] = numbers[i]\n    output[#output + 1] = delimeter\n  end\n\
    \  output[#output + 1] = numbers[#numbers]\n  return output\nend", "    local\
    \ result = {}\n    for i = 1, #numbers do\n        table.insert(result, numbers[i])\n\
    \        if i < #numbers then\n            table.insert(result, delimeter)\n \
    \       end\n    end\n    return result\nend", "\tlocal result = {}\n\tfor i,\
    \ v in ipairs(numbers) do\n\t\ttable.insert(result, v)\n\t\tif i < #numbers then\n\
    \t\t\ttable.insert(result, delimeter)\n\t\tend\n\tend\n\treturn result\nend",
  "    assert(type(numbers) == 'table', 'The first argument must be a table')\n  \
    \  assert(type(delimeter) == 'number', 'The second argument must be a number')\n\
    \    local res = {}\n    local len = #numbers\n    if len == 0 then\n        return\
    \ res\n    end\n    for i = 1, len - 1 do\n        table.insert(res, numbers[i])\n\
    \        table.insert(res, delimeter)\n    end\n    table.insert(res, numbers[len])\n\
    \    return res\nend", "  if #numbers == 0 then\n    return {}\n  elseif #numbers\
    \ == 1 then\n    return numbers\n  else\n    local result = {}\n    for i, number\
    \ in ipairs(numbers) do\n      if i ~= 1 then\n        table.insert(result, delimeter)\n\
    \      end\n      table.insert(result, number)\n    end\n    return result\n \
    \ end\nend", "    local output = {}\n    local n = #numbers\n    for i = 1, n\
    \ - 1 do\n        output[#output + 1] = numbers[i]\n        output[#output + 1]\
    \ = delimeter\n    end\n    output[#output + 1] = numbers[n]\n    return output\n\
    end", "\tlocal inserted = {}\n\tfor i = 1, #numbers do\n\t\ttable.insert(inserted,\
    \ numbers[i])\n\t\tif i < #numbers then\n\t\t\ttable.insert(inserted, delimeter)\n\
    \t\tend\n\tend\n\treturn inserted\nend", "    local result = {}\n    local i =\
    \ 1\n    for k, number in ipairs(numbers) do\n        result[i] = number\n   \
    \     i = i + 1\n        if k < #numbers then\n            result[i] = delimeter\n\
    \            i = i + 1\n        end\n    end\n    return result\nend", "    local\
    \ res = {}\n    for i, v in ipairs(numbers) do\n        table.insert(res, v)\n\
    \        if i < #numbers then\n            table.insert(res, delimeter)\n    \
    \    end\n    end\n    return res\nend", "    local result = {}\n    for i = 1,\
    \ #numbers do\n        if i == 1 then\n            result[i] = numbers[i]\n  \
    \      else\n            result[i * 2 - 1] = delimeter\n            result[i *\
    \ 2] = numbers[i]\n        end\n    end\n    return result\nend", "    if #numbers\
    \ == 0 then\n        return {}\n    end\n    local result = {numbers[1]}\n   \
    \ for i = 2, #numbers do\n        result[#result + 1] = delimeter\n        result[#result\
    \ + 1] = numbers[i]\n    end\n    return result\nend", "    local result = {}\n\
    \    for i, v in ipairs(numbers) do\n        if i > 1 then\n            result[#result\
    \ + 1] = delimeter\n        end\n        result[#result + 1] = v\n    end\n  \
    \  return result\nend", "    local result = {}\n    for index, number in ipairs(numbers)\
    \ do\n        result[index * 2 - 1] = number\n        result[index * 2] = delimeter\n\
    \    end\n    result[#result] = nil\n    return result\nend", "\tlocal res = {}\n\
    \tlocal len = #numbers\n\tfor i = 1, len do\n\t\tres[#res + 1] = numbers[i]\n\t\
    \tif i < len then\n\t\t\tres[#res + 1] = delimeter\n\t\tend\n\tend\n\treturn res\n\
    end", "    if #numbers < 2 then\n        return numbers\n    end\n    local result\
    \ = {}\n    for i, num in ipairs(numbers) do\n        table.insert(result, num)\n\
    \        if i < #numbers then\n            table.insert(result, delimeter)\n \
    \       end\n    end\n    return result\nend", "    local result = {}\n    for\
    \ i, x in ipairs(numbers) do\n        result[#result + 1] = x\n        if i <\
    \ #numbers then\n            result[#result + 1] = delimeter\n        end\n  \
    \  end\n    return result\nend", "    local result = {}\n    for i = 1, #numbers\
    \ - 1 do\n        result[#result + 1] = numbers[i]\n        result[#result + 1]\
    \ = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n    return\
    \ result\nend", "    if #numbers < 2 then\n        return numbers\n    end\n \
    \   local out = {}\n    for i, e in ipairs(numbers) do\n        out[2 * i - 1]\
    \ = e\n        out[2 * i] = delimeter\n    end\n    out[#out] = nil\n    return\
    \ out\nend", "  local result = {}\n  for i, number in ipairs(numbers) do\n   \
    \ result[2 * i - 1] = number\n    result[2 * i] = delimeter\n  end\n  result[#result]\
    \ = nil\n  return result\nend", "    local result = {}\n    local pos = 0\n  \
    \  for _, v in ipairs(numbers) do\n        pos = pos + 1\n        result[pos]\
    \ = v\n        pos = pos + 1\n        result[pos] = delimeter\n    end\n    table.remove(result)\n\
    \    return result\nend", "  return zipWith(function(number1, number2)\n    return\
    \ number1, delimeter, number2\n  end,\n  numbers, tail(numbers))\nend", "    local\
    \ size = #numbers\n    if size == 0 then\n        return {}\n    elseif size ==\
    \ 1 then\n        return numbers\n    else\n        local result = {}\n      \
    \  for i = 1, size - 1 do\n            result[#result + 1] = numbers[i]\n    \
    \        result[#result + 1] = delimeter\n        end\n        result[#result\
    \ + 1] = numbers[size]\n        return result\n    end\nend", "    local newNumbers\
    \ = {}\n    for k, v in ipairs(numbers) do\n        if (k ~= 1) then\n       \
    \     table.insert(newNumbers, delimeter)\n        end\n        table.insert(newNumbers,\
    \ v)\n    end\n    return newNumbers\nend", "  return zip(numbers, replicate(length(numbers)\
    \ - 1, delimeter))\n    | map(concat)\n    | flatten()\nend", "    if #numbers\
    \ == 0 then\n        return {}\n    end\n    local ans = {numbers[1]}\n    for\
    \ i = 2, #numbers do\n        ans[#ans + 1] = delimeter\n        ans[#ans + 1]\
    \ = numbers[i]\n    end\n    return ans\nend", "    local result = {}\n    for\
    \ i, number in ipairs(numbers) do\n        if i == 1 then\n            result[i]\
    \ = number\n        else\n            result[2 * i - 1] = delimeter\n        \
    \    result[2 * i] = number\n        end\n    end\n    return result\nend", " \
    \   if numbers == nil or #numbers == 0 then\n        return numbers\n    end",
  "    local result = {}\n    for i = 1, #numbers - 1 do\n        result[#result +\
    \ 1] = numbers[i]\n        result[#result + 1] = delimeter\n    end\n    result[#result\
    \ + 1] = numbers[#numbers]\n    return result\nend", "  local result = {}\n  for\
    \ i,v in ipairs(numbers) do\n    table.insert(result, v)\n    if i ~= #numbers\
    \ then\n      table.insert(result, delimeter)\n    end\n  end\n  return result\n\
    end", "\tlocal length = #numbers\n\tlocal result = {}\n\tfor i = 1, length - 1\
    \ do\n\t\ttable.insert(result, numbers[i])\n\t\ttable.insert(result, delimeter)\n\
    \tend\n\ttable.insert(result, numbers[length])\n\treturn result\nend", "\tlocal\
    \ result = {}\n\tlocal index = 0\n\tfor _, num in ipairs(numbers) do\n\t\tindex\
    \ = index + 1\n\t\tresult[index] = num\n\t\tif index < #numbers then\n\t\t\tindex\
    \ = index + 1\n\t\t\tresult[index] = delimeter\n\t\tend\n\tend\n\treturn result\n\
    end", "    return map(function(x, i) return (i % 2 == 0) and x or {delimeter,\
    \ x} end, numbers)\nend", "    local new_numbers = {}\n    local n = #numbers\n\
    \    if n == 0 then\n        return new_numbers\n    end\n    if n == 1 then\n\
    \        return numbers\n    end\n    for i = 1, n - 1 do\n        new_numbers[i\
    \ * 2 - 1] = numbers[i]\n        new_numbers[i * 2] = delimeter\n    end\n   \
    \ new_numbers[n * 2 - 1] = numbers[n]\n    return new_numbers\nend", "    local\
    \ result = {}\n    for i = 1, #numbers do\n        result[#result + 1] = numbers[i]\n\
    \        if i < #numbers then\n            result[#result + 1] = delimeter\n \
    \       end\n    end\n    return result\nend", "    local len = #numbers\n   \
    \ if len == 0 then\n        return {}\n    elseif len == 1 then\n        return\
    \ numbers\n    else\n        local result = {}\n        for i = 1, len, 2 do\n\
    \            local before = numbers[i]\n            local after = numbers[i +\
    \ 1]\n            if after == nil then\n                table.insert(result, before)\n\
    \            else\n                table.insert(result, before)\n            \
    \    table.insert(result, delimeter)\n            end\n        end\n        return\
    \ result\n    end\nend", "    local out = {}\n    for k,v in ipairs(numbers) do\n\
    \        table.insert(out, v)\n        if k ~= #numbers then\n            table.insert(out,\
    \ delimeter)\n        end\n    end\n    return out\nend", "  assert(is_number_list(numbers),\
    \ \"numbers is not a list of numbers\")\n  assert(is_number(delimeter), \"delimeter\
    \ is not a number\")\n  local result = {}\n  for _, number in ipairs(numbers)\
    \ do\n    table.insert(result, number)\n    table.insert(result, delimeter)\n\
    \  end\n  table.remove(result)\n  return result\nend", "    if #numbers < 2 then\n\
    \        return numbers\n    end\n    local result = {}\n    for i = 1, #numbers\
    \ - 1 do\n        result[#result + 1] = numbers[i]\n        result[#result + 1]\
    \ = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n    return\
    \ result\nend", "    return map(function(x, i) return i % 2 == 0 and x or delimeter\
    \ end, numbers)\nend", "\tlocal t = {}\n\tfor i = 1, #numbers do\n\t\tt[2 * i\
    \ - 1] = numbers[i]\n\t\tt[2 * i] = delimeter\n\tend\n\tt[#t] = nil\n\treturn\
    \ t\nend", "\tlocal result = {}\n\tfor i = 1, #numbers - 1 do\n\t\ttable.insert(result,\
    \ numbers[i])\n\t\ttable.insert(result, delimeter)\n\tend\n\ttable.insert(result,\
    \ numbers[#numbers])\n\treturn result\nend", "  local result = {}\n  for i = 1,\
    \ #numbers - 1 do\n    table.insert(result, numbers[i])\n    table.insert(result,\
    \ delimeter)\n  end\n  table.insert(result, numbers[#numbers])\n  return result\n\
    end", "    if #numbers == 0 then\n        return {}\n    end\n    local t = {}\n\
    \    for i = 1, #numbers - 1 do\n        t[#t + 1] = numbers[i]\n        t[#t\
    \ + 1] = delimeter\n    end\n    t[#t + 1] = numbers[#numbers]\n    return t\n\
    end", "    local result = {}\n    local size = #numbers\n    if size == 0 then\n\
    \        return result\n    end\n    result[1] = numbers[1]\n    for i = 2, size\
    \ do\n        result[i * 2 - 1] = delimeter\n        result[i * 2] = numbers[i]\n\
    \    end\n    return result\nend", "\tif #numbers == 0 then\n\t\treturn {}\n\t\
    end\n\tlocal result = { numbers[1] }\n\tfor i = 2, #numbers do\n\t\tresult[#result\
    \ + 1] = delimeter\n\t\tresult[#result + 1] = numbers[i]\n\tend\n\treturn result\n\
    end", "\tlocal result = {}\n\tfor i = 1, #numbers - 1 do\n\t\ttable.insert(result,\
    \ numbers[i])\n\t\ttable.insert(result, delimeter)\n\tend\n\ttable.insert(result,\
    \ numbers[#numbers])\n\treturn result\nend", "  local result = {}\n  local n =\
    \ #numbers\n  if n == 0 then\n    return result\n  end\n  if n == 1 then\n   \
    \ table.insert(result, numbers[1])\n    return result\n  end\n  for i = 1, n -\
    \ 1 do\n    table.insert(result, numbers[i])\n    table.insert(result, delimeter)\n\
    \  end\n  table.insert(result, numbers[n])\n  return result\nend", "    local\
    \ result = {}\n    for i, n in ipairs(numbers) do\n        if i > 1 then\n   \
    \         result[#result + 1] = delimeter\n        end\n        result[#result\
    \ + 1] = n\n    end\n    return result\nend", "  if #numbers == 0 then\n    return\
    \ {}\n  elseif #numbers == 1 then\n    return numbers\n  else\n    local result\
    \ = {}\n    for i = 1, #numbers - 1 do\n      table.insert(result, numbers[i])\n\
    \      table.insert(result, delimeter)\n    end\n    table.insert(result, numbers[#numbers])\n\
    \    return result\n  end\nend", "  assertx.is_table(numbers)\n  assertx.is_number(delimeter)\n\
    \  local out = {}\n  for i = 1, #numbers - 1 do\n    out[#out + 1] = numbers[i]\n\
    \    out[#out + 1] = delimeter\n  end\n  out[#out + 1] = numbers[#numbers]\n \
    \ return out\nend", "  local new_numbers = {}\n  for i = 1, #numbers - 1 do\n\
    \    table.insert(new_numbers, numbers[i])\n    table.insert(new_numbers, delimeter)\n\
    \  end\n  table.insert(new_numbers, numbers[#numbers])\n  return new_numbers\n\
    end", "    local result = {}\n    for i = 1, #numbers - 1 do\n        table.insert(result,\
    \ numbers[i])\n        table.insert(result, delimeter)\n    end\n    table.insert(result,\
    \ numbers[#numbers])\n    return result\nend", "    if not numbers or #numbers\
    \ == 0 then\n        return numbers\n    end", "    local result = {}\n    local\
    \ last = #numbers\n    for i, elem in ipairs(numbers) do\n        result[#result\
    \ + 1] = elem\n        if i ~= last then\n            result[#result + 1] = delimeter\n\
    \        end\n    end\n    return result\nend", "  local result = {}\n  for i,\
    \ v in ipairs(numbers) do\n    result[i] = v\n    if i < #numbers then\n     \
    \ result[i + 1] = delimeter\n    end\n  end\n  return result\nend", "    local\
    \ r = {}\n    for i, v in ipairs(numbers) do\n        r[#r + 1] = v\n        if\
    \ i < #numbers then\n            r[#r + 1] = delimeter\n        end\n    end\n\
    \    return r\nend", "    local res = {}\n    for i, v in ipairs(numbers) do\n\
    \        if i ~= 1 then\n            table.insert(res, delimeter)\n        end\n\
    \        table.insert(res, v)\n    end\n    return res\nend", "  if #numbers ==\
    \ 0 then\n    return {}\n  elseif #numbers == 1 then\n    return numbers\n  else\n\
    \    return { numbers[1], delimeter, intersperse(tail(numbers), delimeter) }\n\
    \  end\nend", "  if #numbers == 0 then\n    return {}\n  elseif #numbers == 1\
    \ then\n    return numbers\n  else\n    local result = {}\n    for i = 1, #numbers\
    \ - 1 do\n      result[i * 2 - 1] = numbers[i]\n      result[i * 2] = delimeter\n\
    \    end\n    result[#result] = numbers[#numbers]\n    return result\n  end\n\
    end", "  local t = {}\n  for i, num in ipairs(numbers) do\n    if i ~= 1 then\n\
    \      table.insert(t, delimeter)\n    end\n    table.insert(t, num)\n  end\n\
    \  return t\nend", "    local result = {}\n    for i = 1, #numbers do\n      \
    \  table.insert(result, numbers[i])\n        if i < #numbers then\n          \
    \  table.insert(result, delimeter)\n        end\n    end\n    return result\n\
    end", "    if #numbers == 0 then\n        return {}\n    end\n    local result\
    \ = {numbers[1]}\n    for i = 2, #numbers do\n        table.insert(result, delimeter)\n\
    \        table.insert(result, numbers[i])\n    end\n    return result\nend", " \
    \   local result = {}\n    for index, number in ipairs(numbers) do\n        if\
    \ index ~= 1 then\n            result[#result + 1] = delimeter\n        end\n\
    \        result[#result + 1] = number\n    end\n    return result\nend", "  local\
    \ result = {}\n  for i = 1, #numbers - 1 do\n    result[#result + 1] = numbers[i]\n\
    \    result[#result + 1] = delimeter\n  end\n  result[#result + 1] = numbers[#numbers]\n\
    \  return result\nend", "    return isEmpty(numbers) and numbers or take(head(numbers))\
    \ .. delimeter .. intersperse(tail(numbers), delimeter)\nend", "    if #numbers\
    \ < 2 then\n        return numbers\n    end\n    local result = {}\n    for i\
    \ = 1, #numbers - 1 do\n        result[#result + 1] = numbers[i]\n        result[#result\
    \ + 1] = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n   \
    \ return result\nend", "  local res = {}\n  for _, num in ipairs(numbers) do\n\
    \    table.insert(res, num)\n    table.insert(res, delimeter)\n  end\n  -- Remove\
    \ last delimeter\n  if #res > 0 then\n    table.remove(res)\n  end\n  return res\n\
    end", "    local result = {}\n    for i,v in ipairs(numbers) do\n        if i\
    \ > 1 then table.insert(result, delimeter) end\n        table.insert(result, v)\n\
    \    end\n    return result\nend", "  local numbers_len = #numbers\n  if numbers_len\
    \ == 0 then\n    return {}\n  elseif numbers_len == 1 then\n    return numbers\n\
    \  else\n    local head = numbers[1]\n    local tail = numbers[2]\n    for i =\
    \ 3, numbers_len do\n      local tmp = tail\n      tail = numbers[i]\n      numbers[i]\
    \ = delimeter\n      numbers[i - 1] = tmp\n    end\n    numbers[2] = tail\n  \
    \  return numbers\n  end\nend", "    if numbers == nil or #numbers == 0 then\n\
    \        return {}\n    end", "  local result = {}\n  for i = 1, #numbers - 1\
    \ do\n    table.insert(result, numbers[i])\n    table.insert(result, delimeter)\n\
    \  end\n  table.insert(result, numbers[#numbers])\n  return result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
