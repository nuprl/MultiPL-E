name: HumanEval_129_minPath
language: lua
prompt: "-- Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n-- each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n-- inclusive appears exactly once on the cells of the grid.\n-- You have\
  \ to find the minimum path of length k in the grid. You can start\n-- from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n-- in other words,\
  \ you can go to cells which share an edge with you current\n-- cell.\n-- Please\
  \ note that a path of length k means visiting exactly k cells (not\n-- necessarily\
  \ distinct).\n-- You CANNOT go off the grid.\n-- A path A (of length k) is considered\
  \ less than a path B (of length k) if\n-- after making the ordered lists of the\
  \ values on the cells that A and B go\n-- through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n-- than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n-- such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n-- lst_A[j] = lst_B[j].\n-- It is guaranteed that the answer\
  \ is unique.\n-- Return an ordered list of the values on the cells that the minimum\
  \ path go through.\n-- Examples:\n-- Input: grid = [ [1,2,3], [4,5,6], [7,8,9]],\
  \ k = 3\n-- Output: [1, 2, 1]\n-- Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k\
  \ = 1\n-- Output: [1]\nlocal function minPath(grid, k)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = minPath\n\
  \    lu.assertEquals(candidate({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3), {1, 2, 1})\n\
  \    lu.assertEquals(candidate({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1), {1})\n   \
  \ lu.assertEquals(candidate({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14,\
  \ 15, 16}}, 4), {1, 2, 1, 2})\n    lu.assertEquals(candidate({{6, 4, 13, 10}, {5,\
  \ 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7), {1, 10, 1, 10, 1, 10, 1})\n  \
  \  lu.assertEquals(candidate({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3,\
  \ 10, 11, 16}}, 5), {1, 7, 1, 7, 1})\n    lu.assertEquals(candidate({{11, 8, 7,\
  \ 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9), {1, 6, 1, 6, 1, 6, 1,\
  \ 6, 1})\n    lu.assertEquals(candidate({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16,\
  \ 14, 4}, {11, 8, 7, 2}}, 12), {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6})\n    lu.assertEquals(candidate({{2,\
  \ 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8), {1, 3, 1, 3, 1, 3, 1, 3})\n    lu.assertEquals(candidate({{6,\
  \ 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8), {1, 5, 1, 5, 1, 5, 1, 5})\n    lu.assertEquals(candidate({{1,\
  \ 2}, {3, 4}}, 10), {1, 2, 1, 2, 1, 2, 1, 2, 1, 2})\n    lu.assertEquals(candidate({{1,\
  \ 3}, {3, 2}}, 10), {1, 3, 1, 3, 1, 3, 1, 3, 1, 3})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- TODO:\nend", "  -- Let N be the number of rows and columns\n \
    \ local N = #grid", "    local n = #grid\n    local h = #grid[1]\n    local heap\
    \ = Heap.new()\n    local visited = {}\n    for i = 1, n do\n        visited[i]\
    \ = {}\n        for j = 1, h do\n            visited[i][j] = false\n        end\n\
    \    end\n    heap:push(1, {grid[1][1], {1, 1}})\n    while not heap:empty() do\n\
    \        local dist, curr = heap:pop()\n        local currVal, currPos = unpack(curr)\n\
    \        if not visited[currPos[1]][currPos[2]] then\n            visited[currPos[1]][currPos[2]]\
    \ = true\n            if dist > k then\n                break\n            end\n\
    \            local nb = {\n                {0, -1},\n                {-1, 0},\n\
    \                {0, 1},\n                {1, 0}\n            }\n            for\
    \ _, v in ipairs(nb) do\n                local x = currPos[1] + v[1]\n       \
    \         local y = currPos[2] + v[2]\n                if x >= 1 and x <= n and\
    \ y >= 1 and y <= h then\n                    heap:push(dist + 1, {grid[x][y],\
    \ {x, y}})\n                end\n            end\n        end\n    end\n    local\
    \ output = {}\n    while not heap:empty() do\n        local _, curr = heap:pop()\n\
    \        table.insert(output, curr[1])\n    end\n    return output\nend", "  \
    \  local rowCount = #grid\n    local colCount = #grid[1]\n    local gridNum =\
    \ rowCount * colCount\n    local sumCount = {}\n    for row=1, rowCount do\n \
    \       for col=1, colCount do\n            local val = grid[row][col]\n     \
    \       if sumCount[val] == nil then\n                sumCount[val] = 1\n    \
    \        else\n                sumCount[val] = sumCount[val] + 1\n           \
    \ end\n        end\n    end\n    local valueCount = 0\n    for i, v in pairs(sumCount)\
    \ do\n        valueCount = valueCount + 1\n    end\n    if valueCount < k then\n\
    \        return nil\n    end\n    local path = {}\n    local pathLen = 0\n   \
    \ while pathLen < k do\n        local minVal = gridNum + 1\n        local indexVal\
    \ = nil\n        for i, v in pairs(sumCount) do\n            if v ~= 0 and i <\
    \ minVal then\n                minVal = i\n                indexVal = i\n    \
    \        end\n        end\n        if indexVal == nil then\n            break\n\
    \        end\n        path[pathLen + 1] = indexVal\n        sumCount[indexVal]\
    \ = sumCount[indexVal] - 1\n        pathLen = pathLen + 1\n    end\n    return\
    \ path\nend", "    -- write your code here\n    return {}\nend", "    local N\
    \ = #grid\n    local memo = {}\n    local function find(i, j, k)\n        if k\
    \ == 0 then\n            return {}\n        end\n        local v = memo[i * N\
    \ + j]\n        if v then\n            return v[k]\n        end\n        v = {}\n\
    \        memo[i * N + j] = v\n        local min_path\n        if i > 1 then\n\
    \            local path = find(i - 1, j, k - 1)\n            table.insert(path,\
    \ 1, grid[i][j])\n            if not min_path or path < min_path then\n      \
    \          min_path = path\n            end\n        end\n        if i < N then\n\
    \            local path = find(i + 1, j, k - 1)\n            table.insert(path,\
    \ 1, grid[i][j])\n            if not min_path or path < min_path then\n      \
    \          min_path = path\n            end\n        end\n        if j > 1 then\n\
    \            local path = find(i, j - 1, k - 1)\n            table.insert(path,\
    \ 1, grid[i][j])\n            if not min_path or path < min_path then\n      \
    \          min_path = path\n            end\n        end\n        if j < N then\n\
    \            local path = find(i, j + 1, k - 1)\n            table.insert(path,\
    \ 1, grid[i][j])\n            if not min_path or path < min_path then\n      \
    \          min_path = path\n            end\n        end\n        v[k] = min_path\n\
    \        return min_path\n    end\n    return find(1, 1, k)\nend", "  local n\
    \ = #grid\n  local queue = {{0, 0, 0, 0}}\n  local level, x, y, z = 1, 0, 0, 0\n\
    \  local visited = {}\n  while true do\n    if #queue == 0 then\n      break\n\
    \    end\n    local node = table.remove(queue, 1)\n    local path_length, i, j,\
    \ current_min = table.unpack(node)\n    if path_length == k then\n      return\
    \ visited[node]\n    end\n    for _, next in ipairs({{i + 1, j}, {i - 1, j}, {i,\
    \ j + 1}, {i, j - 1}}) do\n      local next_i, next_j = table.unpack(next)\n \
    \     if next_i >= 0 and next_i < n and next_j >= 0 and next_j < n then\n    \
    \    local path_values = visited[node] or {}\n        local curr_min = math.min(current_min,\
    \ grid[next_i + 1][next_j + 1])\n        table.insert(path_values, curr_min)\n\
    \        visited[{path_length + 1, next_i, next_j, curr_min}] = path_values\n\
    \        table.insert(queue, {path_length + 1, next_i, next_j, curr_min})\n  \
    \    end\n    end\n  end\nend", "    local function getSibling(p, x, y)\n    \
    \    if x == 1 then\n            if y == 1 then\n                return p[x +\
    \ 1][y], p[x][y + 1]\n            elseif y == #p then\n                return\
    \ p[x + 1][y], p[x][y - 1]\n            else\n                return p[x + 1][y],\
    \ p[x][y - 1], p[x][y + 1]\n            end\n        elseif x == #p then\n   \
    \         if y == 1 then\n                return p[x - 1][y], p[x][y + 1]\n  \
    \          elseif y == #p then\n                return p[x - 1][y], p[x][y - 1]\n\
    \            else\n                return p[x - 1][y], p[x][y - 1], p[x][y + 1]\n\
    \            end\n        else\n            if y == 1 then\n                return\
    \ p[x - 1][y], p[x + 1][y], p[x][y + 1]\n            elseif y == #p then\n   \
    \             return p[x - 1][y], p[x + 1][y], p[x][y - 1]\n            else\n\
    \                return p[x - 1][y], p[x + 1][y], p[x][y - 1], p[x][y + 1]\n \
    \           end\n        end\n    end\n    local t, l, r = {}, {}, {}\n    local\
    \ function dfs(p, x, y, path, left)\n        if left == 0 then\n            local\
    \ str = ''\n            for _, v in ipairs(path) do\n                str = str\
    \ .. tostring(v)\n            end\n            if not t[str] then\n          \
    \      t[str] = true\n                table.insert(l, path)\n                table.insert(r,\
    \ p[x][y])\n            else\n                local i = 1\n                while\
    \ i <= #l do\n                    local flag = false\n                    for\
    \ j = 1, k do\n                        if path[j] < l[i][j] then\n           \
    \                 break\n                        elseif path[j] > l[i][j] then\n\
    \                            flag = true\n                           ", "    local\
    \ n = #grid\n    local f = {}\n    for i = 1, n do\n        f[i] = {}\n      \
    \  for j = 1, n do\n            f[i][j] = {}\n        end\n    end\n    for i\
    \ = 1, n do\n        for j = 1, n do\n            f[i][j][1] = {grid[i][j]}\n\
    \        end\n    end\n    for length = 2, k do\n        for i = 1, n do\n   \
    \         for j = 1, n do\n                local min = nil\n                for\
    \ _, d in ipairs({{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) do\n                    local\
    \ nx, ny = i + d[1], j + d[2]\n                    if nx >= 1 and nx <= n and\
    \ ny >= 1 and ny <= n then\n                        local v = f[nx][ny][length\
    \ - 1]\n                        if not min or compare(v, min) then\n         \
    \                   min = v\n                        end\n                   \
    \ end\n                end\n                f[i][j][length] = {grid[i][j]}\n \
    \               for _, v in ipairs(min) do\n                    table.insert(f[i][j][length],\
    \ v)\n                end\n            end\n        end\n    end\n    local min\
    \ = nil\n    for i = 1, n do\n        for j = 1, n do\n            local v = f[i][j][k]\n\
    \            if not min or compare(v, min) then\n                min = v\n   \
    \         end\n        end\n    end\n    return min\nend", "    local n = #grid\n\
    \    local function getNext(x, y)\n        local ret = {}\n        if x > 1 then\n\
    \            table.insert(ret, { x - 1, y })\n        end\n        if x < n then\n\
    \            table.insert(ret, { x + 1, y })\n        end\n        if y > 1 then\n\
    \            table.insert(ret, { x, y - 1 })\n        end\n        if y < n then\n\
    \            table.insert(ret, { x, y + 1 })\n        end\n        return ret\n\
    \    end\n    local function getValue(x, y)\n        return grid[x][y]\n    end\n\
    \    local function isVisited(s, x, y)\n        for _, p in ipairs(s) do\n   \
    \         if p[1] == x and p[2] == y then\n                return true\n     \
    \       end\n        end\n        return false\n    end\n    local paths = {{getValue(1,\
    \ 1), { {1, 1} }}}\n    for i = 2, k do\n        local newPaths = {}\n       \
    \ for _, path in ipairs(paths) do\n            local x, y = path[#path][1], path[#path][2]\n\
    \            for _, next in ipairs(getNext(x, y)) do\n                if not isVisited(path,\
    \ next[1], next[2]) then\n                    local newPath = {}\n           \
    \         for j = 1, #path do\n                        table.insert(newPath, path[j])\n\
    \                    end\n                    table.insert(newPath, next)\n  \
    \                  table.insert(newPaths, newPath)\n                end\n    \
    \        end\n        end\n        paths = newPaths\n    end\n    local minPath\n\
    \    for _, path in ipairs(paths) do\n        local min = true\n        for j\
    \ = 1, #path do\n            if j > 1 and getValue(path[j][1], path[j][2]) < getValue(path[j\
    \ - 1][1], path[j - 1][2]) then\n                min = false\n               \
    \ break\n            end\n        end\n        if min then\n            minPath\
    \ = path\n            break\n        end\n   ", "    local function getMoves(x,\
    \ y)\n        return {{x - 1, y}, {x + 1, y}, {x, y - 1}, {x, y + 1}}\n    end\n\
    \    local function less(a, b)\n        for i = 1, #a do\n            if a[i]\
    \ < b[i] then\n                return true\n            elseif a[i] > b[i] then\n\
    \                return false\n            end\n        end\n        return false\n\
    \    end\n    local N = #grid\n    local minVal = 1000000000\n    local minPath\n\
    \    local function dfs(x, y, path, used)\n        table.insert(path, grid[x][y])\n\
    \        used[x][y] = true\n        if #path > k then\n            table.remove(path)\n\
    \            used[x][y] = false\n            return\n        end\n        if #path\
    \ == k then\n            local total = 0\n            for i = 1, #path do\n  \
    \              total = total + path[i]\n            end\n            if total\
    \ < minVal then\n                minVal = total\n                minPath = tablex.copy(path)\n\
    \            elseif total == minVal then\n                if less(path, minPath)\
    \ then\n                    minPath = tablex.copy(path)\n                end\n\
    \            end\n            table.remove(path)\n            used[x][y] = false\n\
    \            return\n        end\n        for _, pos in ipairs(getMoves(x, y))\
    \ do\n            local i, j = pos[1], pos[2]\n            if 1 <= i and i <=\
    \ N and 1 <= j and j <= N and not used[i][j] then\n                dfs(i, j, path,\
    \ used)\n            end\n        end\n        table.remove(path)\n        used[x][y]\
    \ = false\n    end\n    local used = {}\n    for i = 1, N do\n        used[i]\
    \ = {}\n    end\n    dfs(1, 1, {}, used)\n    return minPath\nend", "  -- TODO\n\
    end", "    local function pred(a, b)\n        return a.t < b.t or a.t == b.t and\
    \ a.i < b.i\n    end\n    local function sort(t)\n        table.sort(t, pred)\n\
    \    end\n    local function findMinPath(grid, i, j, k)\n        local n = #grid\n\
    \        local heap = {\n            {t = grid[i][j], i = i, j = j}\n        }\n\
    \        local visited = {}\n        for i = 1, n do\n            visited[i] =\
    \ {}\n        end\n        local minPath = {}\n        while #heap > 0 do\n  \
    \          if k == 0 then\n                local path = {}\n                for\
    \ _, e in ipairs(heap) do\n                    table.insert(path, e.t)\n     \
    \           end\n                sort(path)\n                if #minPath == 0\
    \ or path < minPath then\n                    minPath = path\n               \
    \ end\n            else\n                local e = table.remove(heap, 1)\n   \
    \             if not visited[e.i][e.j] then\n                    visited[e.i][e.j]\
    \ = true\n                    if e.i > 1 then\n                        table.insert(heap,\
    \ {t = grid[e.i - 1][e.j], i = e.i - 1, j = e.j})\n                    end\n \
    \                   if e.i < n then\n                        table.insert(heap,\
    \ {t = grid[e.i + 1][e.j], i = e.i + 1, j = e.j})\n                    end\n \
    \                   if e.j > 1 then\n                        table.insert(heap,\
    \ {t = grid[e.i][e.j - 1], i = e.i, j = e.j - 1})\n                    end\n \
    \                   if e.j < n then\n                        table.insert(heap,\
    \ {t = grid[e.i][e.j + 1], i = e.i, j = e.j + 1})\n                    end\n \
    \                   sort(heap)\n                end\n            end\n       \
    \     k = k - 1\n        end\n        return minPath\n    end\n    local n = #grid\n\
    \    local min", "  local function f(n, x, y, k, memo)\n    -- Return if we are\
    \ off the grid.\n    if x < 1 or x > n or y < 1 or y > n then\n      return math.huge\n\
    \    end\n    -- Return if we are at the finish line.\n    if k == 0 then\n  \
    \    return grid[x][y]\n    end\n    -- Return memo[x][y][k] if it exists.\n \
    \   if memo[x][y][k] then\n      return memo[x][y][k]\n    end\n    local path\
    \ = math.min(\n      grid[x][y] + f(n, x + 1, y, k - 1, memo),\n      grid[x][y]\
    \ + f(n, x - 1, y, k - 1, memo),\n      grid[x][y] + f(n, x, y + 1, k - 1, memo),\n\
    \      grid[x][y] + f(n, x, y - 1, k - 1, memo)\n    )\n    memo[x][y][k] = path\n\
    \    return path\n  end\n  local memo = {}\n  for i = 1, #grid do\n    memo[i]\
    \ = {}\n    for j = 1, #grid do\n      memo[i][j] = {}\n    end\n  end\n  local\
    \ n = #grid\n  local x, y = -1, -1\n  for i = 1, n do\n    for j = 1, n do\n \
    \     if f(n, i, j, k, memo) == 1 then\n        x, y = i, j\n        break\n \
    \     end\n    end\n  end\n  local res = {}\n  while k > 0 do\n    if x < 1 or\
    \ x > n or y < 1 or y > n then\n      break\n    end\n    res[#res + 1] = grid[x][y]\n\
    \    if grid[x][y] + f(n, x + 1, y, k - 1, memo) == grid[x][y] then\n      x =\
    \ x + 1\n    elseif grid[x][y] + f(n, x - 1, y, k - 1, memo) == grid[x][", " \
    \ --\nend", "  local n = #grid\n  local function valid(x, y)\n    return x >=\
    \ 1 and x <= n and y >= 1 and y <= n\n  end\n  local function neighbor(x, y)\n\
    \    local res = {}\n    if valid(x - 1, y) then res[#res + 1] = {x - 1, y} end\n\
    \    if valid(x + 1, y) then res[#res + 1] = {x + 1, y} end\n    if valid(x, y\
    \ - 1) then res[#res + 1] = {x, y - 1} end\n    if valid(x, y + 1) then res[#res\
    \ + 1] = {x, y + 1} end\n    return res\n  end\n  local function cmp(a, b)\n \
    \   return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])\n  end\n  local function\
    \ less(a, b)\n    for i = 1, k do\n      if a[i] < b[i] then return true end\n\
    \      if a[i] > b[i] then return false end\n    end\n    return false\n  end\n\
    \  local dp = {}\n  for i = 1, n do\n    dp[i] = {}\n    for j = 1, n do\n   \
    \   dp[i][j] = {}\n    end\n  end\n  local function update(x, y, lst)\n    if\
    \ not valid(x, y) then return end\n    if #lst > k then return end\n    if #lst\
    \ > 0 and lst[#lst] == grid[x][y] then return end\n    lst[#lst + 1] = grid[x][y]\n\
    \    if #lst > #dp[x][y] then\n      dp[x][y] = {}\n      for i = 1, #lst do\n\
    \        dp[x][y][i] = lst[i]\n      end\n    elseif #lst == #dp[x][y] and less(lst,\
    \ dp[x][y]) then\n      for i = 1, #lst do\n       ", "    local N = #grid\n \
    \   local dp = {}\n    for i = 1, N do\n        dp[i] = {}\n        for j = 1,\
    \ N do\n            dp[i][j] = {}\n        end\n    end\n    -- dp[i][j][p] =\
    \ {val, path}\n    -- p is 1-based\n    -- val = min(dp[i - 1][j][p], dp[i][j\
    \ - 1][p], dp[i + 1][j][p], dp[i][j + 1][p])\n    --  + (grid[i][j] - 1) // N\n\
    \    -- path is an ordered list of values\n    local minVal = math.huge\n    local\
    \ minPath\n    for i = 1, N do\n        for j = 1, N do\n            dp[i][j][1]\
    \ = {grid[i][j] - 1, {grid[i][j]}}\n            if i > 1 then\n              \
    \  local prevVal = dp[i - 1][j][1][1]\n                if prevVal < dp[i][j][1][1]\
    \ then\n                    dp[i][j][1] = {prevVal, {grid[i - 1][j]}}\n      \
    \          end\n            end\n            if j > 1 then\n                local\
    \ prevVal = dp[i][j - 1][1][1]\n                if prevVal < dp[i][j][1][1] then\n\
    \                    dp[i][j][1] = {prevVal, {grid[i][j - 1]}}\n             \
    \   end\n            end\n            if i < N then\n                local prevVal\
    \ = dp[i + 1][j][1][1]\n                if prevVal < dp[i][j][1][1] then\n   \
    \                 dp[i][j][1] = {prevVal, {grid[i + 1][j]}}\n                end\n\
    \            end\n            if j < N then\n                local prevVal = dp[i][j\
    \ + 1][1][1]\n                if prevVal < dp[i][j][1][1] then\n             \
    \       dp[i][j][1] = {prevVal, {", "  local n = #grid\n  local A = {}\n  local\
    \ idx = {}\n  for i = 1, n do\n    A[i] = {}\n    idx[i] = {}\n    for j = 1,\
    \ n do\n      A[i][j] = { grid[i][j] }\n      idx[i][j] = { [grid[i][j]] = 1 }\n\
    \    end\n  end\n  local res = { grid[1][1] }\n  for t = 2, k do\n    local a\
    \ = A[1][1][t - 1]\n    if a == grid[1][1] then\n      res[t] = grid[1][2]\n \
    \   elseif a == grid[1][2] then\n      res[t] = grid[2][1]\n    else\n      res[t]\
    \ = grid[1][1]\n    end\n    for i = 1, n do\n      for j = 1, n do\n        local\
    \ d = t - idx[i][j][a]\n        local t1 = math.max(i - 1, 1)\n        local t2\
    \ = math.min(i + 1, n)\n        local t3 = math.max(j - 1, 1)\n        local t4\
    \ = math.min(j + 1, n)\n        if grid[t1][j] ~= a then\n          d = math.min(d,\
    \ t - idx[t1][j][a])\n        end\n        if grid[t2][j] ~= a then\n        \
    \  d = math.min(d, t - idx[t2][j][a])\n        end\n        if grid[i][t3] ~=\
    \ a then\n          d = math.min(d, t - idx[i][t3][a])\n        end\n        if\
    \ grid[i][t4] ~= a then\n          d = math.min(d, t - idx[i][t4][a])\n      \
    \  end\n        local c = math.min(d, t)\n        A[i][j][t] = a\n        idx[i][j][a]\
    \ = t\n        if c > 1 then\n          local b = A[", "  -- calculate N\n  local\
    \ N = #grid\n  -- validate input\n  if N < 2 or k < 1 then\n    return {}\n  end\n\
    \  -- sort each row in the grid, this makes our binary search more efficient\n\
    \  for i = 1, N do\n    table.sort(grid[i])\n  end\n  -- start at the smallest\
    \ element in the entire grid\n  local ans = { grid[1][1] }\n  local ans_cur_value\
    \ = ans[1]\n  -- find the coordinates of the element we're currently traversing\n\
    \  local ans_cur_x, ans_cur_y = 1, 1\n  for _ = 1, k - 1 do\n    -- check current\
    \ element's top, bottom, left, and right neighbors\n    local ans_next_x, ans_next_y\n\
    \    -- top neighbor\n    local can_move_top = ans_cur_x > 1\n    if can_move_top\
    \ then\n      local top_value = grid[ans_cur_x - 1][ans_cur_y]\n      if top_value\
    \ < ans_cur_value then\n        ans_next_x, ans_next_y = ans_cur_x - 1, ans_cur_y\n\
    \        ans_cur_value = top_value\n      end\n    end\n    -- bottom neighbor\n\
    \    local can_move_bottom = ans_cur_x < N\n    if can_move_bottom then\n    \
    \  local bottom_value = grid[ans_cur_x + 1][ans_cur_y]\n      if bottom_value\
    \ < ans_cur_value then\n        ans_next_x, ans_next_y = ans_cur_x + 1, ans_cur_y\n\
    \        ans_cur_value = bottom_value\n      end\n    end\n    -- left neighbor\n\
    \    local can_move_left = ans_cur_y > 1\n    if can_move_left then\n      local\
    \ left_value = grid[ans_cur_x][ans_cur_y - 1]\n      if left_value < ans_cur_value\
    \ then\n        ans_next_x, ans_next_y = ans_cur_x, ans_cur_y - 1\n        ans_cur_value\
    \ = left_value\n      end", "  local n = #grid\n  local dist = {}\n  local q =\
    \ {}\n  for i = 1, n do\n    dist[i] = {}\n    for j = 1, n do\n      dist[i][j]\
    \ = math.huge\n    end\n  end\n  local function push(u, v, d)\n    q[#q + 1] =\
    \ {u, v, d}\n  end\n  local function pop()\n    local u, v, d = unpack(table.remove(q,\
    \ 1))\n    return u, v, d\n  end\n  local function get_grid(u, v)\n    return\
    \ grid[u][v]\n  end\n  local function get_dist(u, v)\n    return dist[u][v]\n\
    \  end\n  local function set_dist(u, v, d)\n    dist[u][v] = d\n  end\n  local\
    \ function min(x, y)\n    return x < y and x or y\n  end\n  local function add(u,\
    \ v, a, b)\n    local d = get_dist(u, v) + get_grid(a, b)\n    if d < get_dist(a,\
    \ b) then\n      set_dist(a, b, d)\n      push(a, b, d)\n    end\n  end\n  local\
    \ function comp(x, y)\n    local u, v, a, b = unpack(x), unpack(y)\n    return\
    \ get_grid(u, v) < get_grid(a, b)\n  end\n  local function solve()\n    local\
    \ lst = {}\n    local u, v, d = pop()\n    while u do\n      lst[#lst + 1] = {u,\
    \ v, d}\n      u, v, d = pop()\n    end\n    table.sort(lst, comp)\n    local\
    \ res = {}\n    for i = 1, k do\n      res[i] = get_grid(lst[i][1], lst[i][2])\n\
    \    end\n    return res\n  end\n  for i = 1, n do\n    for j = 1, n do\n    \
    \  push(i, j, get_", "    local n = #grid\n    if n == 1 then\n        return\
    \ {grid[1][1]}\n    end\n    local function neighbors(x, y)\n        local list\
    \ = {}\n        if x > 1 then\n            list[#list + 1] = {x - 1, y}\n    \
    \    end\n        if x < n then\n            list[#list + 1] = {x + 1, y}\n  \
    \      end\n        if y > 1 then\n            list[#list + 1] = {x, y - 1}\n\
    \        end\n        if y < n then\n            list[#list + 1] = {x, y + 1}\n\
    \        end\n        return list\n    end\n    local memo = {}\n    local function\
    \ go(x, y, k)\n        if k == 0 then\n            return {}\n        end\n  \
    \      local key = string.format('%d,%d,%d', x, y, k)\n        if memo[key] then\n\
    \            return memo[key]\n        end\n        local best = {'z'}\n     \
    \   for _, nx, ny in neighbors(x, y) do\n            local path = go(nx, ny, k\
    \ - 1)\n            if path[1] < best[1] then\n                best = {grid[x][y]}\n\
    \                for _, v in ipairs(path) do\n                    best[#best +\
    \ 1] = v\n                end\n            end\n        end\n        memo[key]\
    \ = best\n        return best\n    end\n    return go(1, 1, k)\nend", "  if not\
    \ grid then return nil end\n  local N = #grid\n  if k < 1 or k > N * N then return\
    \ nil end\n  local M = {}\n  for _ = 1, k do\n    table.insert(M, {})\n  end\n\
    \  for i = 1, N do\n    for j = 1, N do\n      M[1][grid[i][j]] = {i, j}\n   \
    \ end\n  end\n  for l = 2, k do\n    for v = 1, N * N do\n      local i, j = M[l\
    \ - 1][v][1], M[l - 1][v][2]\n      local val = grid[i][j]\n      M[l][val] =\
    \ {i, j}\n      if i - 1 >= 1 and (not M[l][grid[i - 1][j]]) then\n        M[l][grid[i\
    \ - 1][j]] = {i - 1, j}\n      end\n      if i + 1 <= N and (not M[l][grid[i +\
    \ 1][j]]) then\n        M[l][grid[i + 1][j]] = {i + 1, j}\n      end\n      if\
    \ j - 1 >= 1 and (not M[l][grid[i][j - 1]]) then\n        M[l][grid[i][j - 1]]\
    \ = {i, j - 1}\n      end\n      if j + 1 <= N and (not M[l][grid[i][j + 1]])\
    \ then\n        M[l][grid[i][j + 1]] = {i, j + 1}\n      end\n    end\n  end\n\
    \  local min, min_lst = nil, nil\n  for v = 1, N * N do\n    local lst = {}\n\
    \    for l = 1, k do\n      table.insert(lst, v)\n      v = grid[M[l][v][1]][M[l][v][2]]\n\
    \    end\n    if not min or table.concat(lst, '-') < table.concat(min_lst, '-')\
    \ then\n      min, min_lst = v, lst\n    end\n  end\n  return min", "  local function\
    \ to1d(row, col)\n    return (row - 1) * #grid + col\n  end\n  local function\
    \ to2d(i)\n    return math.floor((i - 1) / #grid) + 1, (i - 1) % #grid + 1\n \
    \ end\n  local function getValue(row, col)\n    return grid[row][col]\n  end\n\
    \  local function getValueByIndex(i)\n    local row, col = to2d(i)\n    return\
    \ getValue(row, col)\n  end\n  local function getPositionsByValue(v)\n    local\
    \ ps = {}\n    for i = 1, #grid do\n      for j = 1, #grid do\n        if grid[i][j]\
    \ == v then\n          table.insert(ps, {i, j})\n        end\n      end\n    end\n\
    \    return ps\n  end\n  local function isValid(row, col)\n    return 1 <= row\
    \ and row <= #grid and 1 <= col and col <= #grid\n  end\n  local function canGo(row,\
    \ col, i, j)\n    if isValid(i, j) and (i ~= row or j ~= col) then\n      return\
    \ true\n    end\n    return false\n  end\n  local function getNeighbors(row, col)\n\
    \    local neis = {}\n    if canGo(row, col, row - 1, col) then\n      table.insert(neis,\
    \ to1d(row - 1, col))\n    end\n    if canGo(row, col, row + 1, col) then\n  \
    \    table.insert(neis, to1d(row + 1, col))\n    end\n    if canGo(row, col, row,\
    \ col - 1) then\n      table.insert(neis, to1d(row, col - 1))\n    end\n    if\
    \ canGo(row, col, row, col + 1) then\n      table.insert(neis, to1d(row, col +\
    \ 1))\n    end\n    return neis\n  end\n  local function addToHeap(heap, arr,\
    \ s)\n    local i = #arr\n    while i > 1 and arr[i] >", "  local n = #grid\n\
    \  -- dp[i][j][l] is the minimum path of length l starting from grid[i][j]\n \
    \ local dp = {}\n  for i = 1, n do\n    dp[i] = {}\n    for j = 1, n do\n    \
    \  dp[i][j] = {}\n    end\n  end\n  -- We have to create the dp[][][] array first,\
    \ because we will use it\n  -- (i.e. dp[][][]) as a key in the following tables,\
    \ and arrays are not\n  -- valid keys. So, we need to use this trick.\n  local\
    \ mask = {}\n  for i = 1, n do\n    mask[i] = {}\n    for j = 1, n do\n      mask[i][j]\
    \ = {}\n      for l = 1, k do\n        mask[i][j][l] = true\n      end\n    end\n\
    \  end\n  -- min_val[dp[i][j][l]] is the minimum path starting from grid[i][j]\n\
    \  -- of length l.\n  local min_val = {}\n  min_val[dp[1][1][1]] = { grid[1][1]\
    \ }\n  -- n_of_min_val[dp[i][j][l]] is the number of minimum paths starting from\n\
    \  -- grid[i][j] of length l.\n  local n_of_min_val = {}\n  n_of_min_val[dp[1][1][1]]\
    \ = 1\n  -- The following tables are used to find the neighbors of each cell in\
    \ the\n  -- grid.\n  local left = {}\n  for i = 1, n do\n    left[i] = {}\n  \
    \  for j = 1, n do\n      left[i][j] = j - 1\n    end\n  end\n  local right =\
    \ {}\n  for i = 1, n do\n    right[i] = {}\n    for j = 1, n do\n      right[i][j]\
    \ = j + 1\n    end\n  end\n  local top = {}\n  for i = 1, n do\n    top[i] = {}\n\
    \    for j = 1, n do\n", "\t-- body\nend", end, "    local min\n    local function\
    \ calcMinPath(row, col, path, path_len)\n        if row < 1 or row > #grid or\
    \ col < 1 or col > #grid[1] then\n            return\n        end\n        if\
    \ path_len == k then\n            if not min then\n                min = path\n\
    \            else\n                local len = #path\n                for i =\
    \ 1, len do\n                    if path[i] < min[i] then\n                  \
    \      min = path\n                        break\n                    elseif path[i]\
    \ > min[i] then\n                        break\n                    end\n    \
    \            end\n            end\n            return\n        end\n        path[path_len\
    \ + 1] = grid[row][col]\n        calcMinPath(row - 1, col, path, path_len + 1)\n\
    \        calcMinPath(row + 1, col, path, path_len + 1)\n        calcMinPath(row,\
    \ col - 1, path, path_len + 1)\n        calcMinPath(row, col + 1, path, path_len\
    \ + 1)\n    end\n    local path = {}\n    for row = 1, #grid do\n        for col\
    \ = 1, #grid[1] do\n            calcMinPath(row, col, path, 0)\n        end\n\
    \    end\n    return min\nend", "  local N = #grid\n  local q = { {0, 0, 0, grid[1][1]}\
    \ }\n  local dist = {}\n  local visited = {}\n  local ans = { math.huge }\n  while\
    \ next(q) do\n    local u = table.remove(q, 1)\n    local i, j, dep, res = unpack(u)\n\
    \    if dep > k then\n      break\n    end\n    if dep > 0 and dep < k and res\
    \ < ans[1] then\n      ans = { res }\n    elseif dep == k and res < ans[1] then\n\
    \      ans = { res }\n      break\n    end\n    local d = dist[i][j]\n    local\
    \ v = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} }\n    for _, t in ipairs(v) do\n   \
    \   local ii, jj = i + t[1], j + t[2]\n      if ii > 0 and ii <= N and jj > 0\
    \ and jj <= N and not visited[ii][jj] then\n        visited[ii][jj] = true\n \
    \       local r = res * 10 + grid[ii][jj]\n        dist[ii][jj] = d + 1\n    \
    \    table.insert(q, {ii, jj, dep + 1, r})\n      end\n    end\n  end\n  if ans[1]\
    \ == math.huge then\n    return {}\n  end\n  while ans[1] > 0 do\n    table.insert(ans,\
    \ 1, ans[1] % 10)\n    ans[1] = math.floor(ans[1] / 10)\n  end\n  return ans\n\
    end", "  local n = #grid\n  local cell_to_idx = {}\n  local idx_to_cell = {}\n\
    \  local idx = 1\n  for r = 1, n do\n    for c = 1, n do\n      cell_to_idx[r\
    \ * n + c] = idx\n      idx_to_cell[idx] = r * n + c\n      idx = idx + 1\n  \
    \  end\n  end\n  -- Use Floyd\u2013Warshall algorithm to find the shortest path\
    \ in a weighted graph.\n  local distance = {}\n  for r = 1, n do\n    for c =\
    \ 1, n do\n      local idx = cell_to_idx[r * n + c]\n      if r < n then\n   \
    \     local nxt_idx = cell_to_idx[(r + 1) * n + c]\n        distance[idx] = distance[idx]\
    \ or {}\n        distance[idx][nxt_idx] = grid[r + 1][c]\n        distance[nxt_idx]\
    \ = distance[nxt_idx] or {}\n        distance[nxt_idx][idx] = grid[r + 1][c]\n\
    \      end\n      if c < n then\n        local nxt_idx = cell_to_idx[r * n + c\
    \ + 1]\n        distance[idx] = distance[idx] or {}\n        distance[idx][nxt_idx]\
    \ = grid[r][c + 1]\n        distance[nxt_idx] = distance[nxt_idx] or {}\n    \
    \    distance[nxt_idx][idx] = grid[r][c + 1]\n      end\n    end\n  end\n  for\
    \ k = 1, n * n do\n    for i = 1, n * n do\n      for j = 1, n * n do\n      \
    \  if distance[i] and distance[i][k] and distance[k] and distance[k][j] and \n\
    \          (not distance[i][j] or distance[i][j] > distance[i][k] + distance[k][j])\
    \ then\n          distance[i][j] = distance[i][k]", "    local n = #grid\n   \
    \ local function lessThan(a, b)\n        for i = 1, k do\n            if a[i]\
    \ ~= b[i] then\n                return a[i] < b[i]\n            end\n        end\n\
    \        return false\n    end\n    local pq = {}\n    local vis = {}\n    for\
    \ i = 1, n do\n        vis[i] = {}\n    end\n    table.insert(pq, {path = {grid[1][1]},\
    \ x = 1, y = 1})\n    vis[1][1] = true\n    while #pq > 0 do\n        local p\
    \ = table.remove(pq, 1)\n        if #p.path == k then\n            return p.path\n\
    \        end\n        for _, d in ipairs({{0, 1}, {0, -1}, {1, 0}, {-1, 0}}) do\n\
    \            local nx, ny = p.x + d[1], p.y + d[2]\n            if nx >= 1 and\
    \ nx <= n and ny >= 1 and ny <= n and not vis[nx][ny] then\n                local\
    \ newPath = {unpack(p.path)}\n                table.insert(newPath, grid[nx][ny])\n\
    \                vis[nx][ny] = true\n                table.insert(pq, {path =\
    \ newPath, x = nx, y = ny})\n            end\n        end\n        table.sort(pq,\
    \ lessThan)\n    end\nend\nreturn minPath", "  local n = #grid\n  if k == 1 then\n\
    \    local min = math.huge\n    local min_idx = nil\n    for i = 1, n do\n   \
    \   for j = 1, n do\n        if grid[i][j] < min then\n          min = grid[i][j]\n\
    \          min_idx = {i, j}\n        end\n      end\n    end\n    return {min}\n\
    \  end\n  local dp = {}\n  for i = 1, n do\n    dp[i] = {}\n    for j = 1, n do\n\
    \      dp[i][j] = {}\n    end\n  end\n  for i = 1, n do\n    for j = 1, n do\n\
    \      local nghs = {}\n      if i > 1 then\n        nghs[#nghs + 1] = {dp[i -\
    \ 1][j], grid[i - 1][j]}\n      end\n      if i < n then\n        nghs[#nghs +\
    \ 1] = {dp[i + 1][j], grid[i + 1][j]}\n      end\n      if j > 1 then\n      \
    \  nghs[#nghs + 1] = {dp[i][j - 1], grid[i][j - 1]}\n      end\n      if j < n\
    \ then\n        nghs[#nghs + 1] = {dp[i][j + 1], grid[i][j + 1]}\n      end\n\
    \      table.sort(nghs, function(a, b)\n        if #a[1] < #b[1] then\n      \
    \    return true\n        elseif #a[1] > #b[1] then\n          return false\n\
    \        else\n          for l = 1, #a[1] do\n            if a[1][l] < b[1][l]\
    \ then\n              return true\n            elseif a[1][l] > b[1][l] then\n\
    \              return false\n            end\n          end\n          return\
    \ a[2] < b[2]\n        end\n      end)\n      for l = 1, math.min(k - 1, #nghs)\
    \ do\n        dp[i][j][l", "    local n = #grid\n    local row = {}\n    for i\
    \ = 1, n do\n        row[i] = {}\n        for j = 1, n do\n            row[i][j]\
    \ = grid[i][j]\n        end\n    end\n    for i = 1, n do\n        table.sort(row[i])\n\
    \    end\n    local col = {}\n    for j = 1, n do\n        col[j] = {}\n     \
    \   for i = 1, n do\n            col[j][i] = grid[i][j]\n        end\n    end\n\
    \    for j = 1, n do\n        table.sort(col[j])\n    end\n    local visited =\
    \ {}\n    for i = 1, n do\n        visited[i] = {}\n        for j = 1, n do\n\
    \            visited[i][j] = false\n        end\n    end\n    local function solve(k,\
    \ i, j)\n        local val = grid[i][j]\n        if k == 1 then\n            return\
    \ {val}\n        end\n        visited[i][j] = true\n        local result\n   \
    \     local function update(val, m, n)\n            if visited[m][n] == false\
    \ then\n                local r = solve(k - 1, m, n)\n                if r then\n\
    \                    local t = {}\n                    t[1] = val\n          \
    \          for i = 1, #r do\n                        t[#t + 1] = r[i]\n      \
    \              end\n                    if result == nil then\n              \
    \          result = t\n                    else\n                        local\
    \ lex = 0\n                        for i = 1, #t do\n                        \
    \    if t[i] < result[i] then\n                                lex = -1\n    \
    \                            break\n                            elseif t[i] >\
    \ result[i] then\n                                lex = 1\n                  \
    \              break\n                            end\n                      \
    \  end\n                        if lex == -1 then\n                          \
    \  result = t\n                        end\n                    end\n        \
    \        end\n            end\n        end\n        for x = math.max(1, i - 1),\
    \ math.min(n, i + 1) do\n            for y = math.max(1, j - 1), math.min(n, j\
    \ + 1) do", "  local function move(i, j, val, sofar)\n    sofar[#sofar + 1] =\
    \ val\n    if k == 0 then\n      return sofar\n    end\n    k = k - 1\n    local\
    \ nexts = {}\n    if i - 1 >= 1 then\n      nexts[#nexts + 1] = move(i - 1, j,\
    \ grid[i - 1][j], sofar)\n    end\n    if i + 1 <= #grid then\n      nexts[#nexts\
    \ + 1] = move(i + 1, j, grid[i + 1][j], sofar)\n    end\n    if j - 1 >= 1 then\n\
    \      nexts[#nexts + 1] = move(i, j - 1, grid[i][j - 1], sofar)\n    end\n  \
    \  if j + 1 <= #grid then\n      nexts[#nexts + 1] = move(i, j + 1, grid[i][j\
    \ + 1], sofar)\n    end\n    local min\n    for _, v in ipairs(nexts) do\n   \
    \   if not min or v < min then\n        min = v\n      end\n    end\n    return\
    \ min\n  end\n  local min\n  for i = 1, #grid do\n    for j = 1, #grid do\n  \
    \    local path = move(i, j, grid[i][j], {})\n      if not min or path < min then\n\
    \        min = path\n      end\n    end\n  end\n  return min\nend", "    local\
    \ n = #grid\n    -- cache[i][j][k] means after visiting i-th row and j-th column,\n\
    \    -- the minimum path.\n    local cache = {}\n    for i = 1, n do\n       \
    \ cache[i] = {}\n        for j = 1, n do\n            cache[i][j] = {}\n     \
    \   end\n    end\n    -- aux function to get the minimum path.\n    local function\
    \ findMinPath(i, j, t)\n        -- out of boundary or value greater than or equal\
    \ to k or\n        -- already smaller than the current path, return nil.\n   \
    \     if i < 1 or i > n or j < 1 or j > n or\n           t >= k or cache[i][j][t]\
    \ then\n            return nil\n        end\n        -- already visited and t\
    \ > 0, return empty.\n        if t == 0 then\n            return {}\n        end\n\
    \        -- build the cache if not exist.\n        if not cache[i][j][t] then\n\
    \            local r = {}\n            local min = math.huge\n            -- visit\
    \ the four neighbors.\n            local neighbors = {\n                {i, j\
    \ - 1},\n                {i, j + 1},\n                {i - 1, j},\n          \
    \      {i + 1, j}\n            }\n            for _, cell in ipairs(neighbors)\
    \ do\n                local arr = findMinPath(cell[1], cell[2], t - 1)\n     \
    \           if arr then\n                    -- build the path with current cell\
    \ and the path from neighbors.\n                    table.insert(arr, 1, grid[i][j])\n\
    \                    -- compare the path with the current minimum path.\n    \
    \                local c = 1\n                    for _, v in ipairs(arr) do\n\
    \                        if v ~= r[c] then\n                            if v <\
    \ r[c] then\n                                r = arr\n                       \
    \         min = v\n                                break\n                   \
    \         else\n                                break\n                      \
    \      end\n                        end\n                        c = c + 1\n \
    \                   end\n                end\n            end\n            cache[i][j][t]\
    \ = r\n        end\n        return cache[i][j][t]\n    end\n    local path = nil\n\
    \    for i = 1, n", "  -- write your code here\nend", "  local N = #grid\n  local\
    \ next = {}\n  local val = {}\n  for i = 1, N do\n    for j = 1, N do\n      next[i\
    \ * N + j] = {}\n      for di = -1, 1 do\n        for dj = -1, 1 do\n        \
    \  if not (di == 0 and dj == 0) then\n            local x = i + di\n         \
    \   local y = j + dj\n            if x >= 1 and x <= N and y >= 1 and y <= N then\n\
    \              next[i * N + j][#next[i * N + j] + 1] = x * N + y\n           \
    \ end\n          end\n        end\n      end\n      val[i * N + j] = grid[i][j]\n\
    \    end\n  end\n  local paths = {}\n  local curPath = {}\n  local curLen = 0\n\
    \  local function dfs(i, j)\n    curPath[#curPath + 1] = val[i * N + j]\n    curLen\
    \ = curLen + 1\n    if curLen == k then\n      paths[#paths + 1] = curPath\n \
    \     curPath = {}\n      curLen = 0\n    else\n      for i, v in ipairs(next[i\
    \ * N + j]) do\n        dfs(math.floor(v / N), v % N)\n      end\n    end\n  end\n\
    \  for i = 1, N do\n    for j = 1, N do\n      dfs(i, j)\n    end\n  end\n  table.sort(paths,\
    \ function(a, b)\n    for i = 1, k do\n      if a[i] < b[i] then\n        return\
    \ true\n      elseif a[i] > b[i] then\n        return false\n      end\n    end\n\
    \    return false\n  end)\n  return paths[1]\nend", "  local N = #grid\n  local\
    \ dp = {}\n  for i = 1, N do\n    dp[i] = {}\n    for j = 1, N do\n      dp[i][j]\
    \ = {}\n    end\n  end\n  -- dp[x][y][l] = {min_cost, path}\n  for i = 1, N do\n\
    \    for j = 1, N do\n      local min = dp[i][j][1] or {math.huge, {}}\n     \
    \ local cost = 0\n      local path = {}\n      local parent = {}\n      -- Check\
    \ up.\n      if i > 1 then\n        cost = (dp[i - 1][j][k - 1] or {math.huge,\
    \ {}})[1] + grid[i][j]\n        path = (dp[i - 1][j][k - 1] or {math.huge, {}})[2]\n\
    \        path[#path + 1] = grid[i][j]\n        if cost < min[1] then\n       \
    \   min = {cost, path}\n          parent = {i - 1, j, k - 1}\n        end\n  \
    \    end\n      -- Check down.\n      if i < N then\n        cost = (dp[i + 1][j][k\
    \ - 1] or {math.huge, {}})[1] + grid[i][j]\n        path = (dp[i + 1][j][k - 1]\
    \ or {math.huge, {}})[2]\n        path[#path + 1] = grid[i][j]\n        if cost\
    \ < min[1] then\n          min = {cost, path}\n          parent = {i + 1, j, k\
    \ - 1}\n        end\n      end\n      -- Check left.\n      if j > 1 then\n  \
    \      cost = (dp[i][j - 1][k - 1] or {math.huge, {}})[1] + grid[i][j]\n     \
    \   path = (dp[i][j - 1][k - 1] or {math.huge, {}})[2]\n        path[#path + 1]\
    \ = grid[i][j]\n        if cost < min[1] then\n          min = {cost, path}\n",
  "    local min_path = {}\n    -- write your code here\n    -- n = #grid\n    return\
    \ min_path\nend\nreturn minPath", "    if k < 1 then\n        return {}\n    end\n\
    \    if k == 1 then\n        return {grid[1][1]}\n    end\n    local m, n = #grid,\
    \ #grid[1]\n    local function cmp(a, b)\n        return a < b\n    end\n    local\
    \ function find(lst, val)\n        local l, r = 1, #lst\n        while l <= r\
    \ do\n            local mid = math.floor((l + r) / 2)\n            if cmp(lst[mid],\
    \ val) then\n                l = mid + 1\n            else\n                r\
    \ = mid - 1\n            end\n        end\n        return l\n    end\n    local\
    \ function merge(a, b)\n        local res = {}\n        local i, j = 1, 1\n  \
    \      while i <= #a and j <= #b do\n            if cmp(a[i], b[j]) then\n   \
    \             table.insert(res, a[i])\n                i = i + 1\n           \
    \ else\n                table.insert(res, b[j])\n                j = j + 1\n \
    \           end\n        end\n        while i <= #a do\n            table.insert(res,\
    \ a[i])\n            i = i + 1\n        end\n        while j <= #b do\n      \
    \      table.insert(res, b[j])\n            j = j + 1\n        end\n        return\
    \ res\n    end\n    local function go(x, y, d)\n        local res = {grid[x][y]}\n\
    \        local stk = {}\n        while d > 0 do\n            if x < m and y >\
    \ 1 and (not stk[1] or cmp(grid[x + 1][y - 1], stk[1])) then\n               \
    \ table.insert(stk, 1, grid[x + 1][y - 1])\n            end\n            if x\
    \ < m and (not stk[1] or cmp(grid[x + 1][y], stk[1])) then\n                table.insert(stk,\
    \ 1, grid[x + 1][y])\n            end\n            if x < m and y < n and (not\
    \ stk[1] or cmp(grid[x + 1][y", "\tlocal n = #grid\n\tlocal ok = {}\n\tlocal used\
    \ = {}\n\tfor i = 1, n do\n\t\tok[i] = {}\n\t\tused[i] = {}\n\t\tfor j = 1, n\
    \ do\n\t\t\tok[i][j] = true\n\t\t\tused[i][j] = false\n\t\tend\n\tend\n\tlocal\
    \ function ok_coord(i, j)\n\t\treturn i >= 1 and i <= n and j >= 1 and j <= n\
    \ and ok[i][j]\n\tend\n\tlocal function dfs(i, j, lst, len)\n\t\tif len > k then\n\
    \t\t\treturn false\n\t\tend\n\t\tused[i][j] = true\n\t\tif len == k then\n\t\t\
    \treturn true\n\t\tend\n\t\tif ok_coord(i - 1, j) and not used[i - 1][j] then\n\
    \t\t\tlst[len + 1] = grid[i - 1][j]\n\t\t\tif dfs(i - 1, j, lst, len + 1) then\n\
    \t\t\t\treturn true\n\t\t\tend\n\t\tend\n\t\tif ok_coord(i + 1, j) and not used[i\
    \ + 1][j] then\n\t\t\tlst[len + 1] = grid[i + 1][j]\n\t\t\tif dfs(i + 1, j, lst,\
    \ len + 1) then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\t\tif ok_coord(i, j\
    \ - 1) and not used[i][j - 1] then\n\t\t\tlst[len + 1] = grid[i][j - 1]\n\t\t\t\
    if dfs(i, j - 1, lst, len + 1) then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\
    \t\tif ok_coord(i, j + 1) and not used[i][j + 1] then\n\t\t\tlst[len + 1] = grid[i][j\
    \ + 1]\n\t\t\tif dfs(i, j + 1, lst, len + 1) then\n\t\t\t\t", "  if k == 0 then\n\
    \    return {}\n  end\n  if #grid < 2 then\n    return grid[1]\n  end\n  local\
    \ n = #grid\n  local best\n  local best_path\n  local k_path = {}\n  local path\
    \ = {}\n  local function copy_grid(grid)\n    local res = {}\n    for i = 1, n\
    \ do\n      res[i] = {}\n      for j = 1, n do\n        res[i][j] = grid[i][j]\n\
    \      end\n    end\n    return res\n  end\n  local function visit(g, i, j, k)\n\
    \    if k <= 0 then\n      return\n    end\n    local v = g[i][j]\n    g[i][j]\
    \ = 0\n    path[#path + 1] = v\n    k_path[k] = v\n    local m = 1\n    while\
    \ m <= k do\n      if best == nil or k_path[m] < best[m] then\n        best =\
    \ copy_grid(k_path)\n        break\n      elseif k_path[m] > best[m] then\n  \
    \      break\n      end\n      m = m + 1\n    end\n    if i > 1 and g[i - 1][j]\
    \ > 0 then\n      visit(g, i - 1, j, k - 1)\n    end\n    if i < n and g[i + 1][j]\
    \ > 0 then\n      visit(g, i + 1, j, k - 1)\n    end\n    if j > 1 and g[i][j\
    \ - 1] > 0 then\n      visit(g, i, j - 1, k - 1)\n    end\n    if j < n and g[i][j\
    \ + 1] > 0 then\n      visit(g, i, j + 1, k - 1)\n    end\n    path[#path] = nil\n\
    \    k_path[k] = nil\n    g[i][j] = v\n  end\n  for i = 1, n do\n    for j = 1,\
    \ n do\n      visit(grid, i, j, k)\n    end\n  end\n  return best\nend", "  local\
    \ n = #grid\n  local start = grid[1][1]\n  local getStart = function(grid)\n \
    \   local min, minI, minJ\n    for i = 1, n do\n      for j = 1, n do\n      \
    \  if not min or grid[i][j] < min then\n          min, minI, minJ = grid[i][j],\
    \ i, j\n        end\n      end\n    end\n    return min, minI, minJ\n  end\n \
    \ local getNeighbors = function(grid, i, j)\n    local ans = {}\n    if i > 1\
    \ then\n      ans[#ans + 1] = { grid[i - 1][j], i - 1, j }\n    end\n    if i\
    \ < n then\n      ans[#ans + 1] = { grid[i + 1][j], i + 1, j }\n    end\n    if\
    \ j > 1 then\n      ans[#ans + 1] = { grid[i][j - 1], i, j - 1 }\n    end\n  \
    \  if j < n then\n      ans[#ans + 1] = { grid[i][j + 1], i, j + 1 }\n    end\n\
    \    table.sort(ans, function(a, b) return a[1] < b[1] end)\n    return ans\n\
    \  end\n  local seen = {}\n  local function dfs(i, j, k, grid, path)\n    if k\
    \ == 0 then\n      if not seen[path] then\n        seen[path] = true\n       \
    \ return path\n      end\n    end\n    local ans\n    for _, n in ipairs(getNeighbors(grid,\
    \ i, j)) do\n      local a = dfs(n[2], n[3], k - 1, grid, path .. n[1])\n    \
    \  if a and (not ans or a < ans) then\n        ans = a\n      end\n    end\n \
    \   return ans\n  end\n  local min, minI, minJ = getStart(grid)\n  return dfs(minI,\
    \ minJ, k, grid, tostring(min))\nend", "  local n = #grid\n  local d = {}\n  local\
    \ function get(x, y)\n    if x < 1 or x > n or y < 1 or y > n then\n      return\
    \ math.huge\n    end\n    return d[x * n + y]\n  end\n  local function set(x,\
    \ y, v)\n    if x < 1 or x > n or y < 1 or y > n then\n      return\n    end\n\
    \    d[x * n + y] = v\n  end\n  local function compare(a, b)\n    for i = 1, #a\
    \ do\n      if a[i] < b[i] then\n        return true\n      elseif a[i] > b[i]\
    \ then\n        return false\n      end\n    end\n    return false\n  end\n  local\
    \ function rec(x, y, k, lst)\n    local c = get(x, y)\n    if not c then\n   \
    \   c = {math.huge, lst}\n      set(x, y, c)\n    end\n    if #lst == k then\n\
    \      if compare(lst, c[2]) then\n        c[1] = grid[x][y]\n        c[2] = lst\n\
    \      end\n      return\n    end\n    table.insert(lst, grid[x][y])\n    if get(x\
    \ - 1, y) > get(x, y) then\n      rec(x - 1, y, k, lst)\n    end\n    if get(x\
    \ + 1, y) > get(x, y) then\n      rec(x + 1, y, k, lst)\n    end\n    if get(x,\
    \ y - 1) > get(x, y) then\n      rec(x, y - 1, k, lst)\n    end\n    if get(x,\
    \ y + 1) > get(x, y) then\n      rec(x, y + 1, k, lst)\n    end\n    table.remove(lst)\n\
    \  end\n  for i = 1, n do\n    for j = 1, n do\n      rec(i, j, k, {})\n    end\n\
    \  end\n  return d[n", "  local n = #grid\n  local cmp = function(x, y)\n    return\
    \ x[1] < y[1] or (x[1] == y[1] and x[2] < y[2])\n  end\n  local del = function(t,\
    \ x)\n    for i, v in ipairs(t) do\n      if v[1] == x[1] and v[2] == x[2] then\n\
    \        table.remove(t, i)\n        return\n      end\n    end\n  end\n  local\
    \ x = {}\n  for i = 1, n do\n    for j = 1, n do\n      x[#x + 1] = {grid[i][j],\
    \ i, j}\n    end\n  end\n  table.sort(x, cmp)\n  local head = 1\n  local min =\
    \ nil\n  local minPath = nil\n  local minPath2 = nil\n  local t = {}\n  for i\
    \ = 1, k do\n    t[i] = {x[i][2], x[i][3]}\n  end\n  while head < #x - k + 1 do\n\
    \    local tail = head + k - 1\n    min = min or x[head][1]\n    while tail <\
    \ #x and x[tail + 1][1] == x[tail][1] do\n      tail = tail + 1\n    end\n   \
    \ local q = {}\n    for i = head, tail do\n      q[#q + 1] = {x[i][2], x[i][3]}\n\
    \    end\n    local total = q[#q]\n    if total[1] == total[2] and total[1] ==\
    \ n then\n      break\n    end\n    local r = {}\n    for i = 1, k do\n      r[i]\
    \ = {q[i][1], q[i][2]}\n    end\n    if min < x[head][1] or (min == x[head][1]\
    \ and cmp(t, r)) then\n      min = x[head][1]\n      minPath = t\n      minPath2\
    \ = r\n    end\n    local j = head\n    for i = 1, #q do\n      local step = q",
  "    -- Write your code here\nend", "  local n = #grid\n  local dijkstra = function(i,\
    \ j)\n    local heap = {}\n    local heap_size = 0\n    local dist = {}\n    local\
    \ add = function(dist, path)\n      if heap_size == 0 then\n        heap_size\
    \ = 1\n        heap[heap_size] = path\n        dist[path] = dist\n        return\n\
    \      end\n      local c = heap_size + 1\n      heap[c] = path\n      dist[path]\
    \ = dist\n      while c > 1 do\n        local p = math.floor(c / 2)\n        if\
    \ dist[heap[p]] <= dist[heap[c]] then\n          break\n        end\n        heap[p],\
    \ heap[c] = heap[c], heap[p]\n        c = p\n      end\n    end\n    local remove\
    \ = function()\n      if heap_size == 0 then\n        return nil\n      end\n\
    \      local res = heap[1]\n      heap[1] = heap[heap_size]\n      heap[heap_size]\
    \ = nil\n      heap_size = heap_size - 1\n      local c = 1\n      while c * 2\
    \ <= heap_size do\n        local nc = c * 2\n        if nc + 1 <= heap_size and\
    \ dist[heap[nc + 1]] < dist[heap[nc]] then\n          nc = nc + 1\n        end\n\
    \        if dist[heap[c]] <= dist[heap[nc]] then\n          break\n        end\n\
    \        heap[c], heap[nc] = heap[nc], heap[c]\n        c = nc\n      end\n  \
    \    return res\n    end\n    local visited = {}\n    add({i, j}, 0)\n    while\
    \ true do\n      local p = remove()\n      if not p then\n        break\n    \
    \  end\n      local u = p[1]\n      local v = p[2]\n      local d = dist[p]\n\
    \      if visited[u] and visited[u][v] then\n        break\n      end\n      visited[u]\
    \ = visited[u] or {}\n      visited[u][v] = true\n      if u + 1 <= n then\n \
    \      ", "\tlocal N = #grid\n\tlocal memo = {}\n\tlocal seen = {}\n\tlocal min\n\
    \tlocal min_lst\n\tlocal lst\n\tlocal function go(i, j, k)\n\t\tif k == 0 then\n\
    \t\t\tlocal t = {grid[i][j]}\n\t\t\tif not min or #t < #min_lst then\n\t\t\t\t\
    min_lst = t\n\t\t\t\tmin = t[1]\n\t\t\telseif #t == #min_lst then\n\t\t\t\tlocal\
    \ x = t[1]\n\t\t\t\tif x < min then\n\t\t\t\t\tmin_lst = t\n\t\t\t\t\tmin = x\n\
    \t\t\t\tend\n\t\t\tend\n\t\t\treturn\n\t\tend\n\t\tif seen[i] and seen[i][j] and\
    \ seen[i][j][k] then\n\t\t\treturn\n\t\tend\n\t\tif not seen[i] then\n\t\t\tseen[i]\
    \ = {}\n\t\tend\n\t\tif not seen[i][j] then\n\t\t\tseen[i][j] = {}\n\t\tend\n\t\
    \tseen[i][j][k] = true\n\t\tif i > 1 then\n\t\t\tlocal t = {grid[i][j]}\n\t\t\t\
    if not memo[i - 1] then\n\t\t\t\tmemo[i - 1] = {}\n\t\t\tend\n\t\t\tif not memo[i\
    \ - 1][j] then\n\t\t\t\tmemo[i - 1][j] = {}\n\t\t\tend\n\t\t\tif not memo[i -\
    \ 1][j][k - 1] then\n\t\t\t\tlst = {}\n\t\t\t\tgo(i - 1, j, k - 1)\n\t\t\t\tmemo[i\
    \ - 1][j][k - 1] = lst\n\t\t\telse\n\t\t\t\tlst = memo[i - 1][j][k - 1]\n\t\t\t\
    end\n\t\t\tfor _, v in ipairs(lst) do\n\t\t\t\ttable.insert(t, v)\n\t\t\tend\n\
    \t\t\tif not min", "  local visited = {}\n  local n = #grid\n  local dirs = {{-1,\
    \ 0}, {1, 0}, {0, -1}, {0, 1}}\n  local function dfs(i, j, count, path)\n    table.insert(path,\
    \ grid[i][j])\n    visited[i * n + j] = true\n    count = count + 1\n    if count\
    \ == k then\n      return path\n    end\n    local minPath = nil\n    for _, dir\
    \ in ipairs(dirs) do\n      local x, y = i + dir[1], j + dir[2]\n      if x >=\
    \ 1 and x <= n and y >= 1 and y <= n and not visited[x * n + y] then\n       \
    \ local path = dfs(x, y, count, table.clone(path))\n        if path then\n   \
    \       if not minPath or table.lt(path, minPath) then\n            minPath =\
    \ path\n          end\n        end\n      end\n    end\n    return minPath\n \
    \ end\n  local minPath = nil\n  for i = 1, n do\n    for j = 1, n do\n      if\
    \ not visited[i * n + j] then\n        local path = dfs(i, j, 0, {})\n       \
    \ if path then\n          if not minPath or table.lt(path, minPath) then\n   \
    \         minPath = path\n          end\n        end\n      end\n    end\n  end\n\
    \  return minPath\nend", "    local n = #grid\n    local visited = {}\n    for\
    \ i = 1, n do\n        visited[i] = {}\n        for j = 1, n do\n            visited[i][j]\
    \ = false\n        end\n    end\n    local function helper(i, j, k, path)\n  \
    \      if k == 0 then\n            return path\n        end\n        if visited[i][j]\
    \ == true then\n            return nil\n        end\n        visited[i][j] = true\n\
    \        local result = nil\n        if i > 1 then\n            local t = helper(i\
    \ - 1, j, k - 1, {path, grid[i][j]})\n            if t ~= nil then\n         \
    \       result = t\n            end\n        end\n        if i < n then\n    \
    \        local t = helper(i + 1, j, k - 1, {path, grid[i][j]})\n            if\
    \ t ~= nil then\n                if result == nil or t < result then\n       \
    \             result = t\n                end\n            end\n        end\n\
    \        if j > 1 then\n            local t = helper(i, j - 1, k - 1, {path, grid[i][j]})\n\
    \            if t ~= nil then\n                if result == nil or t < result\
    \ then\n                    result = t\n                end\n            end\n\
    \        end\n        if j < n then\n            local t = helper(i, j + 1, k\
    \ - 1, {path, grid[i][j]})\n            if t ~= nil then\n                if result\
    \ == nil or t < result then\n                    result = t\n                end\n\
    \            end\n        end\n        visited[i][j] = false\n        return result\n\
    \    end\n    for i = 1, n do\n        for j = 1, n do\n            local t =\
    \ helper(i, j, k, {grid[i][j]})\n            if t ~= nil then\n              \
    \  return t\n            end\n        end\n    end\n    return nil\nend", "  \
    \  local function getNeighbors(x, y)\n        local res = {}\n        if x > 1\
    \ then\n            table.insert(res, {x - 1, y})\n        end\n        if x <\
    \ #grid then\n            table.insert(res, {x + 1, y})\n        end\n       \
    \ if y > 1 then\n            table.insert(res, {x, y - 1})\n        end\n    \
    \    if y < #grid then\n            table.insert(res, {x, y + 1})\n        end\n\
    \        return res\n    end\n    local function dfs(x, y, k, path)\n        local\
    \ key = x .. ' ' .. y .. ' ' .. k\n        if cache[key] then\n            if\
    \ path[#path - k + 1] then\n                return cache[key]\n            end\n\
    \            return path\n        end\n        table.insert(path, grid[x][y])\n\
    \        if k == 1 then\n            cache[key] = path\n            return path\n\
    \        end\n        local min = nil\n        for _, v in ipairs(getNeighbors(x,\
    \ y)) do\n            local res = dfs(v[1], v[2], k - 1, {table.unpack(path)})\n\
    \            if not min or res[#res - k + 1] < min[#min - k + 1] then\n      \
    \          min = res\n            end\n        end\n        cache[key] = min\n\
    \        return min\n    end\n    cache = {}\n    local min = nil\n    for i =\
    \ 1, #grid do\n        for j = 1, #grid do\n            local res = dfs(i, j,\
    \ k, {})\n            if not min or res[#res - k + 1] < min[#min - k + 1] then\n\
    \                min = res\n            end\n        end\n    end\n    return\
    \ min\nend", "    local m, n = #grid, #grid[1]\n    local q = { { 0, 0, k, { grid[1][1]\
    \ } } }\n    local mark = {}\n    while q[1] do\n        local t = table.remove(q,\
    \ 1)\n        local x, y, k, path = t[1], t[2], t[3], t[4]\n        if k == 0\
    \ then\n            return path\n        end\n        local z = mark[x]\n    \
    \    if not z then\n            z = {}\n            mark[x] = z\n        end\n\
    \        z[y] = true\n        if x > 0 and not mark[x - 1] or not mark[x - 1][y]\
    \ then\n            table.insert(q, { x - 1, y, k - 1, { grid[x][y], table.unpack(path)\
    \ } })\n        end\n        if x < m - 1 and not mark[x + 1] or not mark[x +\
    \ 1][y] then\n            table.insert(q, { x + 1, y, k - 1, { grid[x][y], table.unpack(path)\
    \ } })\n        end\n        if y > 0 and not mark[x] or not mark[x][y - 1] then\n\
    \            table.insert(q, { x, y - 1, k - 1, { grid[x][y], table.unpack(path)\
    \ } })\n        end\n        if y < n - 1 and not mark[x] or not mark[x][y + 1]\
    \ then\n            table.insert(q, { x, y + 1, k - 1, { grid[x][y], table.unpack(path)\
    \ } })\n        end\n    end\nend", "  local N = #grid\n  if k == 1 then\n   \
    \ local best = grid[1][1]\n    for i = 1, N do\n      for j = 1, N do\n      \
    \  if grid[i][j] < best then\n          best = grid[i][j]\n        end\n     \
    \ end\n    end\n    return {best}\n  end\n  local function dfs(i, j, k, acc)\n\
    \    if k == 0 then\n      return acc\n    end\n    local res = {unpack(acc)}\n\
    \    local best = math.maxinteger\n    if i > 1 then\n      local path = dfs(i\
    \ - 1, j, k - 1, {acc[1], grid[i - 1][j]})\n      if lexicographicCompare(path,\
    \ res) < 0 then\n        res = path\n      end\n    end\n    if i < N then\n \
    \     local path = dfs(i + 1, j, k - 1, {acc[1], grid[i + 1][j]})\n      if lexicographicCompare(path,\
    \ res) < 0 then\n        res = path\n      end\n    end\n    if j > 1 then\n \
    \     local path = dfs(i, j - 1, k - 1, {acc[1], grid[i][j - 1]})\n      if lexicographicCompare(path,\
    \ res) < 0 then\n        res = path\n      end\n    end\n    if j < N then\n \
    \     local path = dfs(i, j + 1, k - 1, {acc[1], grid[i][j + 1]})\n      if lexicographicCompare(path,\
    \ res) < 0 then\n        res = path\n      end\n    end\n    return res\n  end\n\
    \  local res = {math.maxinteger}\n  for i = 1, N do\n    for j = 1, N do\n   \
    \   local path = dfs(i, j, k, {grid[i][j]})\n      if lexicographicCompare(path,\
    \ res) < 0 then\n        res = path\n      end\n    end\n  end\n  return res\n\
    end", "    -- write your code here\n    local n = #grid\n    local m = #grid[1]\n\
    \    local cell = {}\n    for i = 1, n do\n        for j = 1, m do\n         \
    \   local v = grid[i][j]\n            local r = i - 1\n            local c = j\
    \ - 1\n            local pos = r * m + c\n            cell[v] = {\n          \
    \      r = r,\n                c = c,\n                pos = pos,\n          \
    \      list = {v},\n                visited = {[pos] = 1},\n            }\n  \
    \      end\n    end\n    local queue = {{1,1}}\n    while true do\n        local\
    \ cell_list = {}\n        local q = {}\n        for _, pos in ipairs(queue) do\n\
    \            local r = pos[1]\n            local c = pos[2]\n            local\
    \ pos = r * m + c\n            local v = grid[r][c]\n            local c = cell[v]\n\
    \            if not c.list then\n                cell_list[#cell_list + 1] = c\n\
    \            end\n        end\n        if #cell_list == 0 then\n            break\n\
    \        end\n        for _, c in ipairs(cell_list) do\n            if c.list\
    \ then\n                for i = 1, n do\n                    for j = 1, m do\n\
    \                        local v = grid[i][j]\n                        local c2\
    \ = cell[v]\n                        if c ~= c2 and not c2.list then\n       \
    \                     local r = i - 1\n                            local c = j\
    \ - 1\n                            local pos = r * m + c\n                   \
    \         if not c.visited[pos] then\n                                local q1\
    \ = {}\n                                local visited = {}\n                 \
    \               for k, v in pairs(c.visited) do\n                            \
    \        visited[k] = v\n                                end\n               \
    \                 visited[pos] = 1\n                                q1.visited\
    \ = visited\n                                q1.pos = pos\n                  \
    \              q1.list = c.list\n                                q1.list[#q1.list\
    \ + 1] = v\n                                q[#q + 1] = q1\n                 \
    \           end\n                        end", "  local m, n = #grid, #grid[1]\n\
    \  local function bfs(sx, sy)\n    local min = grid[sx][sy]\n    local dp = {\
    \ { {min, {min}} } }\n    local q = {{sx, sy}}\n    local p = {{sx, sy}}\n   \
    \ local dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n    local function valid(x,\
    \ y)\n      return x >= 1 and x <= m and y >= 1 and y <= n\n    end\n    local\
    \ function update(x, y, prex, prey, preMin, path)\n      if not valid(x, y) then\
    \ return end\n      local t = grid[x][y]\n      if t < preMin then\n        path\
    \ = {t}\n        preMin = t\n      elseif t == preMin then\n        table.insert(path,\
    \ t)\n      end\n      local prePath = dp[prex][prey][2]\n      local tmp = table.concat(prePath,\
    \ ',', 1, k - 1)\n      tmp = tmp .. ',' .. table.concat(path, ',')\n      local\
    \ tmpPath = string.split(tmp, ',')\n      local tMin = tonumber(tmpPath[1])\n\
    \      local tPath = {}\n      for i = 1, k do\n        tPath[i] = tonumber(tmpPath[i])\n\
    \      end\n      dp[x][y] = {tMin, tPath}\n      table.insert(q, {x, y})\n  \
    \  end\n    local r = {}\n    for i = 1, k do\n      for j = 1, #p do\n      \
    \  local prex, prey = p[j][1], p[j][2]\n        for _, d in ipairs(dirs) do\n\
    \          update(prex + d[1], prey + d[2], prex, prey, dp[prex][prey][1], dp[prex][prey][2])\n\
    \        end\n      end\n      p = q\n      q = {}\n    end\n    for i = 1, #p\
    \ do\n      r", "    local N = #grid\n    local seen = {}\n    local cost = {}\n\
    \    local min = {}\n    local seenCell = function(r, c)\n        return seen[r]\
    \ and seen[r][c]\n    end\n    local setSeenCell = function(r, c, v)\n       \
    \ if not seen[r] then\n            seen[r] = {}\n        end\n        seen[r][c]\
    \ = v\n    end\n    local setCostCell = function(r, c, v)\n        if not cost[r]\
    \ then\n            cost[r] = {}\n        end\n        cost[r][c] = v\n    end\n\
    \    local addMinPath = function(v)\n        table.insert(min, v)\n    end\n \
    \   local removeMinPathLast = function()\n        table.remove(min)\n    end\n\
    \    local findMinPath = function(r, c, curk)\n        if curk == k then\n   \
    \         return true\n        end\n        setSeenCell(r, c, true)\n        addMinPath(grid[r][c])\n\
    \        local find = false\n        if c > 1 and not seenCell(r, c - 1) then\n\
    \            find = findMinPath(r, c - 1, curk + 1)\n        end\n        if not\
    \ find and c < N and not seenCell(r, c + 1) then\n            find = findMinPath(r,\
    \ c + 1, curk + 1)\n        end\n        if not find and r > 1 and not seenCell(r\
    \ - 1, c) then\n            find = findMinPath(r - 1, c, curk + 1)\n        end\n\
    \        if not find and r < N and not seenCell(r + 1, c) then\n            find\
    \ = findMinPath(r + 1, c, curk + 1)\n        end\n        setSeenCell(r, c, false)\n\
    \        removeMinPathLast()\n        return find\n    end\n    for r = 1, N do\n\
    \        for c = 1, N do\n            setSeenCell(r, c, false)\n            if\
    \ findMinPath(r, c, 1) then\n                return min\n            end\n   \
    \     end\n    end", "    -- Write your code here\nend", "    local n = #grid\n\
    \    local offset = { { 0, -1 }, { -1, 0 }, { 0, 1 }, { 1, 0 } }\n    local root\
    \ = { val = 0, path = {}, status = 1 }\n    local q = { root }\n    local ans\n\
    \    while #q > 0 do\n        local node = table.remove(q, 1)\n        local c1,\
    \ r1 = node.c, node.r\n        local i = node.i + 1\n        while i <= 4 do\n\
    \            local c2, r2 = c1 + offset[i][1], r1 + offset[i][2]\n           \
    \ if c2 >= 1 and c2 <= n and r2 >= 1 and r2 <= n then\n                local visited\
    \ = false\n                for _, coord in ipairs(node.path) do\n            \
    \        if coord[1] == c2 and coord[2] == r2 then\n                        visited\
    \ = true\n                        break\n                    end\n           \
    \     end\n                if not visited then\n                    local child\
    \ = { c = c2, r = r2, path = node.path, i = i, val = grid[c2][r2] }\n        \
    \            if node.i > 0 then\n                        child.path = clone(node.path)\n\
    \                        table.insert(child.path, { c2, r2 })\n              \
    \          child.val = child.val + node.val\n                    end\n       \
    \             if #child.path == k then\n                        if not ans or\
    \ child.val < ans.val then\n                            ans = child\n        \
    \                end\n                    else\n                        table.insert(q,\
    \ child)\n                    end\n                end\n            end\n    \
    \        i = i + 1\n        end\n    end\n    local result = {}\n    for _, coord\
    \ in ipairs(ans.path) do\n        table.insert(result, grid[coord[1]][coord[2]])\n\
    \    end\n    return result\nend", "  local N = #grid\n  local visited = {}\n\
    \  for i = 1, N do\n    visited[i] = {}\n    for j = 1, N do\n      visited[i][j]\
    \ = false\n    end\n  end\n  local ans = {}\n  local function dfs(i, j, path)\n\
    \    if i < 1 or i > N or j < 1 or j > N or visited[i][j] then\n      return\n\
    \    end\n    if #path == k then\n      if #ans == 0 then\n        ans = path\n\
    \      else\n        for idx = 1, k do\n          if path[idx] < ans[idx] then\n\
    \            ans = path\n            break\n          elseif path[idx] > ans[idx]\
    \ then\n            break\n          end\n        end\n      end\n      return\n\
    \    end\n    visited[i][j] = true\n    local nextPath = {path[1], path[2], path[3],\
    \ path[4], path[5], grid[i][j]}\n    dfs(i - 1, j, nextPath)\n    dfs(i + 1, j,\
    \ nextPath)\n    dfs(i, j - 1, nextPath)\n    dfs(i, j + 1, nextPath)\n    visited[i][j]\
    \ = false\n  end\n  for i = 1, N do\n    for j = 1, N do\n      dfs(i, j, {0,\
    \ 0, 0, 0, 0, grid[i][j]})\n    end\n  end\n  return ans\nend", "  local function\
    \ dfs(i, j, visited, k, path)\n    if k < 0 then\n      return path\n    end\n\
    \    local n = #grid\n    local m = #grid[1]\n    local function remove()\n  \
    \    visited[i][j] = nil\n    end\n    if i < 1 or i > n or j < 1 or j > m or\
    \ visited[i][j] then\n      return\n    end\n    visited[i][j] = true\n    table.insert(path,\
    \ grid[i][j])\n    if k == 0 then\n      local min_path = minPath(grid, k)\n \
    \     if min_path == nil or path < min_path then\n        minPath = path\n   \
    \   end\n      return\n    end\n    local min_path = minPath(grid, k)\n    local\
    \ path_ = {}\n    if dfs(i - 1, j, visited, k - 1, path_) then\n      if min_path\
    \ == nil or path_ < min_path then\n        minPath = path_\n      end\n    end\n\
    \    local path_ = {}\n    if dfs(i + 1, j, visited, k - 1, path_) then\n    \
    \  if min_path == nil or path_ < min_path then\n        minPath = path_\n    \
    \  end\n    end\n    local path_ = {}\n    if dfs(i, j - 1, visited, k - 1, path_)\
    \ then\n      if min_path == nil or path_ < min_path then\n        minPath = path_\n\
    \      end\n    end\n    local path_ = {}\n    if dfs(i, j + 1, visited, k - 1,\
    \ path_) then\n      if min_path == nil or path_ < min_path then\n        minPath\
    \ = path_\n      end\n    end\n    remove()\n    return minPath\n  end\n  local\
    \ n = #grid\n  local m = #grid[1]\n  local visited = {}\n  for i = 1, n do\n \
    \   visited[i] = {}\n  end\n  local path = {}\n  for i = 1, n do\n    for j =\
    \ 1, m do\n      local path_ = {}\n      if dfs(", "  local n = #grid\n  local\
    \ max_value = n * n\n  local graph = {}\n  for r = 1, n do\n    graph[r] = {}\n\
    \    for c = 1, n do\n      graph[r][c] = {}\n      if r > 1 then\n        graph[r][c][#graph[r][c]\
    \ + 1] = {r - 1, c}\n      end\n      if r < n then\n        graph[r][c][#graph[r][c]\
    \ + 1] = {r + 1, c}\n      end\n      if c > 1 then\n        graph[r][c][#graph[r][c]\
    \ + 1] = {r, c - 1}\n      end\n      if c < n then\n        graph[r][c][#graph[r][c]\
    \ + 1] = {r, c + 1}\n      end\n    end\n  end\n  local function get_value(r,\
    \ c)\n    return grid[r][c]\n  end\n  local function get_min_path(r, c, count)\n\
    \    if count == k then\n      return {get_value(r, c)}\n    end\n    local ret\
    \ = {}\n    for _, coords in ipairs(graph[r][c]) do\n      local r1, c1 = unpack(coords)\n\
    \      local path = get_min_path(r1, c1, count + 1)\n      if #path > 0 then\n\
    \        for i = 1, #path do\n          path[i] = math.min(max_value, path[i])\n\
    \        end\n        table.insert(path, 1, get_value(r, c))\n        if #ret\
    \ == 0 or less(path, ret) then\n          ret = path\n        end\n      end\n\
    \    end\n    return ret\n  end\n  local function less(a, b)\n    for i = 1, #a\
    \ do\n      if a[i] < b[i] then\n        return true\n      elseif a[i] > b[i]\
    \ then\n        return false\n      end\n    end\n    return false\n  end\n  local\
    \ ret = {}\n  for r = 1, n do\n    for c", "  local function lessThan(a, b)\n\
    \    for i = 1, k do\n      if a[i] < b[i] then\n        return true\n      elseif\
    \ a[i] > b[i] then\n        return false\n      end\n    end\n    return false\n\
    \  end\n  local function add(a, b)\n    for i = 1, k do\n      a[i] = a[i] + b[i]\n\
    \    end\n  end\n  local function sub(a, b)\n    for i = 1, k do\n      a[i] =\
    \ a[i] - b[i]\n    end\n  end\n  local n = #grid\n  local visited = {}\n  for\
    \ i = 1, n do\n    visited[i] = {}\n    for j = 1, n do\n      visited[i][j] =\
    \ {}\n    end\n  end\n  local function solve(cur, path)\n    local x, y = cur[1],\
    \ cur[2]\n    local value = grid[x][y]\n    if visited[x][y][value] then\n   \
    \   return\n    end\n    visited[x][y][value] = true\n    path[#path + 1] = value\n\
    \    local best\n    if #path == k then\n      best = path\n    else\n      local\
    \ nextPath\n      if x > 1 then\n        nextPath = { unpack(path) }\n       \
    \ solve({ x - 1, y }, nextPath)\n        if nextPath[k] and (not best or lessThan(nextPath,\
    \ best)) then\n          best = nextPath\n        end\n      end\n      if x <\
    \ n then\n        nextPath = { unpack(path) }\n        solve({ x + 1, y }, nextPath)\n\
    \        if nextPath[k] and (not best or lessThan(nextPath, best)) then\n    \
    \      best = nextPath\n        end\n      end\n      if y > 1 then\n        nextPath\
    \ = { unpack(path) }\n        solve({ x, y - 1 }, nextPath)\n        if nextPath[k]\
    \ and (not best or lessThan(nextPath, best)) then\n          best = nextPath\n\
    \        end\n      end\n      if", end, "    local function dfs(x, y, k, path)\n\
    \        if x < 1 or x > #grid or y < 1 or y > #grid or k == 0 then\n        \
    \    return\n        end\n        table.insert(path, grid[x][y])\n        k =\
    \ k - 1\n        if k == 0 then\n            print(\"path = \" .. table.concat(path,\
    \ \",\"))\n            return\n        end\n        dfs(x + 1, y, k, path)\n \
    \       dfs(x - 1, y, k, path)\n        dfs(x, y + 1, k, path)\n        dfs(x,\
    \ y - 1, k, path)\n        table.remove(path)\n    end\n    local minPath\n  \
    \  for i = 1, #grid do\n        for j = 1, #grid do\n            local path =\
    \ {}\n            dfs(i, j, k, path)\n            if minPath == nil or minPath\
    \ > path then\n                minPath = path\n            end\n        end\n\
    \    end\n    return minPath\nend", "  -- Write your code here\nend", "  -- TODO:\
    \ Write your code here\n  local rows = #grid\n  local cols = #grid[1]\n  local\
    \ minPath = {grid[1][1]}\n  local visited = {}\n  local function isValid(row,\
    \ col)\n    return row >= 1 and row <= rows and col >= 1 and col <= cols and not\
    \ visited[row][col]\n  end\n  local function dfs(row, col, path, length)\n   \
    \ if row < 1 or row > rows or col < 1 or col > cols or visited[row][col] or length\
    \ > k then\n      return\n    end\n    path[#path + 1] = grid[row][col]\n    if\
    \ length == k then\n      if #path < #minPath then\n        minPath = path\n \
    \     elseif #path == #minPath then\n        for i = 1, k do\n          if path[i]\
    \ < minPath[i] then\n            minPath = path\n            break\n         \
    \ elseif path[i] > minPath[i] then\n            break\n          end\n       \
    \ end\n      end\n      return\n    end\n    visited[row][col] = true\n    dfs(row\
    \ + 1, col, path, length + 1)\n    dfs(row - 1, col, path, length + 1)\n    dfs(row,\
    \ col + 1, path, length + 1)\n    dfs(row, col - 1, path, length + 1)\n    path[#path]\
    \ = nil\n    visited[row][col] = false\n  end\n  for i = 1, rows do\n    visited[i]\
    \ = {}\n  end\n  for i = 1, rows do\n    for j = 1, cols do\n      dfs(i, j, {},\
    \ 1)\n    end\n  end\n  return minPath\nend", "    local minPath = {}\n    for\
    \ _ = 1, k do\n        local minVal = math.huge\n        local minRow, minCol\
    \ = -1, -1\n        for row = 1, #grid do\n            for col = 1, #grid[row]\
    \ do\n                if (grid[row][col] < minVal) then\n                    minVal\
    \ = grid[row][col]\n                    minRow, minCol = row, col\n          \
    \      end\n            end\n        end\n        table.insert(minPath, minVal)\n\
    \        grid[minRow][minCol] = math.huge\n    end\n    return minPath\nend",
  "    -- write your code here\n    local n = #grid\n    local min_path = {}\n   \
    \ local min_seq = {}\n    for i = 1, n do\n        min_path[i] = {}\n        min_seq[i]\
    \ = {}\n        for j = 1, n do\n            min_path[i][j] = -1\n           \
    \ min_seq[i][j] = {}\n        end\n    end\n    local function dfs(i, j, k)\n\
    \        if k < 0 then\n            return {}\n        end\n        if i < 1 or\
    \ i > n or j < 1 or j > n then\n            return {}\n        end\n        if\
    \ min_path[i][j] >= 0 then\n            return min_seq[i][j]\n        end\n  \
    \      if k == 0 then\n            min_path[i][j] = 0\n            min_seq[i][j]\
    \ = {grid[i][j]}\n            return min_seq[i][j]\n        end\n        min_path[i][j]\
    \ = -2\n        min_seq[i][j] = {}\n        local seq = {}\n        for _, dir\
    \ in ipairs({{0, 1}, {0, -1}, {1, 0}, {-1, 0}}) do\n            local ni, nj =\
    \ i + dir[1], j + dir[2]\n            local nseq = dfs(ni, nj, k - 1)\n      \
    \      if min_path[i][j] < 0 or\n                #nseq < #min_seq[i][j] or\n \
    \               (#nseq == #min_seq[i][j] and isSeqLess(nseq, min_seq[i][j])) then\n\
    \                min_path[i][j] = 1 + min_path[ni][nj]\n                min_seq[i][j]\
    \ = nseq\n            end\n        end\n        if min_path[i][j] > 0 then\n \
    \           min_seq[i][j] = {grid[i][j]} .. min_seq[i][j]\n        end\n     \
    \   return min_seq[i][j]\n    end\n    return dfs(1, 1, k)\nend\n", "  local n\
    \ = #grid\n  local mem = {}\n  local go = function(r, c, k)\n    if r < 1 or r\
    \ > n or c < 1 or c > n then\n      return {}\n    end\n    if k == 0 then\n \
    \     return {}\n    end\n    local key = string.format('%d,%d,%d', r, c, k)\n\
    \    if mem[key] then\n      return mem[key]\n    end\n    local res = { grid[r][c]\
    \ }\n    for _,p in ipairs({{-1,0},{1,0},{0,-1},{0,1}}) do\n      local pr, pc\
    \ = r + p[1], c + p[2]\n      local path = go(pr, pc, k - 1)\n      if #path >\
    \ 0 then\n        table.insert(path, 1, grid[r][c])\n        if #res == 0 or is_less(path,\
    \ res) then\n          res = path\n        end\n      end\n    end\n    mem[key]\
    \ = res\n    return res\n  end\n  local res = {}\n  for r = 1, n do\n    for c\
    \ = 1, n do\n      local path = go(r, c, k)\n      if #path > 0 then\n       \
    \ if #res == 0 or is_less(path, res) then\n          res = path\n        end\n\
    \      end\n    end\n  end\n  return res\nend", "  local N = #grid\n  local function\
    \ smaller(lst_A, lst_B)\n    for i = 1, k do\n      if lst_A[i] < lst_B[i] then\n\
    \        return true\n      elseif lst_A[i] > lst_B[i] then\n        return false\n\
    \      end\n    end\n    return false\n  end\n  local function get_smallest_path(i,\
    \ j, k)\n    if k == 0 then\n      return {grid[i][j]}\n    end\n    local paths\
    \ = {}\n    if i > 1 then\n      local path = get_smallest_path(i - 1, j, k -\
    \ 1)\n      table.insert(path, 1, grid[i][j])\n      table.insert(paths, path)\n\
    \    end\n    if i < N then\n      local path = get_smallest_path(i + 1, j, k\
    \ - 1)\n      table.insert(path, 1, grid[i][j])\n      table.insert(paths, path)\n\
    \    end\n    if j > 1 then\n      local path = get_smallest_path(i, j - 1, k\
    \ - 1)\n      table.insert(path, 1, grid[i][j])\n      table.insert(paths, path)\n\
    \    end\n    if j < N then\n      local path = get_smallest_path(i, j + 1, k\
    \ - 1)\n      table.insert(path, 1, grid[i][j])\n      table.insert(paths, path)\n\
    \    end\n    local smallest = paths[1]\n    for i = 2, #paths do\n      if smaller(paths[i],\
    \ smallest) then\n        smallest = paths[i]\n      end\n    end\n    return\
    \ smallest\n  end\n  local answer = nil\n  for i = 1, N do\n    for j = 1, N do\n\
    \      local path = get_smallest_path(i, j, k)\n      if answer == nil or smaller(path,\
    \ answer) then\n        answer = path\n      end\n    end\n  end\n  return answer\n\
    end", "    -- Write your code here\nend", "  local n = #grid\n  local count =\
    \ 0\n  local function a(i, j, path)\n    if i < 1 or i > n or j < 1 or j > n then\n\
    \      return\n    end\n    count = count + 1\n    if count == k then\n      return\
    \ grid[i][j]\n    end\n    local min = {value = -1}\n    local path = path or\
    \ {}\n    table.insert(path, grid[i][j])\n    local function f(i, j)\n      local\
    \ t = a(i, j, path)\n      if not t then\n        return\n      end\n      if\
    \ min.value == -1 or t < min.value then\n        min.value = t\n        min.path\
    \ = path\n      end\n    end\n    f(i - 1, j)\n    f(i + 1, j)\n    f(i, j - 1)\n\
    \    f(i, j + 1)\n    return min.value\n  end\n  for i = 1, n do\n    for j =\
    \ 1, n do\n      local t = a(i, j)\n      if t then\n        return t\n      end\n\
    \    end\n  end\nend", "    local n = #grid\n    local dict = {}\n    for i =\
    \ 1, n do\n        for j = 1, n do\n            dict[grid[i][j]] = {i, j}\n  \
    \      end\n    end\n    local function get_value(path)\n        local res = {}\n\
    \        for _, v in ipairs(path) do\n            res[#res + 1] = grid[v[1]][v[2]]\n\
    \        end\n        return res\n    end\n    local function is_neighbor(p1,\
    \ p2)\n        local i1, j1 = p1[1], p1[2]\n        local i2, j2 = p2[1], p2[2]\n\
    \        if i1 == i2 then\n            return math.abs(j1 - j2) == 1\n       \
    \ elseif j1 == j2 then\n            return math.abs(i1 - i2) == 1\n        end\n\
    \        return false\n    end\n    local function dfs(path, val)\n        if\
    \ #path == k then\n            local v = get_value(path)\n            if not res\
    \ or v < res then\n                res = v\n            end\n            return\n\
    \        end\n        local p = dict[val]\n        for _, v in ipairs(path) do\n\
    \            if is_neighbor(v, p) then\n                dfs(path, val + 1)\n \
    \               return\n            end\n        end\n        path[#path + 1]\
    \ = p\n        dfs(path, val + 1)\n        path[#path] = nil\n    end\n    local\
    \ res\n    for i = 1, n do\n        for j = 1, n do\n            local path =\
    \ {{i, j}}\n            dfs(path, grid[i][j] + 1)\n        end\n    end\n    return\
    \ res\nend", "  local n = #grid\n  local n2 = n * n\n  local dp = {}\n  for i\
    \ = 1, n2 do\n    dp[i] = {}\n    for j = 1, n2 do\n      dp[i][j] = {}\n    end\n\
    \  end\n  for i = 1, n do\n    for j = 1, n do\n      local v = grid[i][j]\n \
    \     dp[v][v][0] = 0\n      dp[v][v][1] = { v }\n    end\n  end\n  for len =\
    \ 2, k do\n    for i = 1, n2 do\n      for j = 1, n2 do\n        local min = nil\n\
    \        for a = 1, n2 do\n          local x = dp[i][a][len - 1]\n          if\
    \ x then\n            local y = dp[a][j][1]\n            if y then\n         \
    \     local z = { unpack(x) }\n              z[#z + 1] = y[1]\n              if\
    \ not min or z < min then\n                min = z\n              end\n      \
    \      end\n          end\n        end\n        dp[i][j][len] = min\n      end\n\
    \    end\n  end\n  local min = nil\n  for i = 1, n2 do\n    local x = dp[i][i][k]\n\
    \    if x and (not min or x < min) then\n      min = x\n    end\n  end\n  return\
    \ min\nend", "  local rows, cols = #grid, #grid[1]\n  local state = {}\n  for\
    \ i = 1, rows do\n    state[i] = {}\n    for j = 1, cols do\n      state[i][j]\
    \ = 0\n    end\n  end\n  local function solve(i, j, k)\n    if i < 1 or i > rows\
    \ or j < 1 or j > cols then\n      return\n    end\n    if state[i][j] == k then\n\
    \      return {{grid[i][j]}}\n    end\n    local ret = {}\n    local up = solve(i\
    \ - 1, j, k - 1)\n    if up then\n      for _, v in ipairs(up) do\n        table.insert(v,\
    \ 1, grid[i][j])\n        table.insert(ret, v)\n      end\n    end\n    local\
    \ left = solve(i, j - 1, k - 1)\n    if left then\n      for _, v in ipairs(left)\
    \ do\n        table.insert(v, 1, grid[i][j])\n        table.insert(ret, v)\n \
    \     end\n    end\n    local down = solve(i + 1, j, k - 1)\n    if down then\n\
    \      for _, v in ipairs(down) do\n        table.insert(v, 1, grid[i][j])\n \
    \       table.insert(ret, v)\n      end\n    end\n    local right = solve(i, j\
    \ + 1, k - 1)\n    if right then\n      for _, v in ipairs(right) do\n       \
    \ table.insert(v, 1, grid[i][j])\n        table.insert(ret, v)\n      end\n  \
    \  end\n    table.sort(ret, function(a, b)\n      for i = 1, #a do\n        if\
    \ a[i] < b[i] then\n          return true\n        elseif a[i] > b[i] then\n \
    \         return false\n        end\n      end\n      return false\n    end)\n\
    \    if #ret > 0 then\n      state[i][j] = k\n      return ret[1]\n    end\n \
    \ end\n  local res =", "    local N = #grid\n    local function getKey(i, j)\n\
    \        return (i - 1) * N + j\n    end\n    local function minPathHelper(i,\
    \ j, k)\n        local key = getKey(i, j)\n        if k == 1 then\n          \
    \  return {grid[i][j]}\n        end\n        local cache = {}\n        for _,\
    \ dir in ipairs({{0, -1}, {-1, 0}, {0, 1}, {1, 0}}) do\n            local ii,\
    \ jj = i + dir[1], j + dir[2]\n            if ii >= 1 and ii <= N and jj >= 1\
    \ and jj <= N then\n                local path = minPathHelper(ii, jj, k - 1)\n\
    \                if path then\n                    local newPath = {grid[i][j]}\n\
    \                    for _, value in ipairs(path) do\n                       \
    \ table.insert(newPath, value)\n                    end\n                    local\
    \ lst = table.concat(newPath, '.')\n                    if not cache[lst] or cache[lst]\
    \ > newPath then\n                        cache[lst] = newPath\n             \
    \       end\n                end\n            end\n        end\n        local\
    \ res\n        for k, v in pairs(cache) do\n            if not res or k < res\
    \ then\n                res = k\n            end\n        end\n        return\
    \ cache[res]\n    end\n    for i = 1, N do\n        for j = 1, N do\n        \
    \    local res = minPathHelper(i, j, k)\n            if res then\n           \
    \     return res\n            end\n        end\n    end\nend", "  local r = #grid\n\
    \  local c = #grid[1]\n  local mp = {}\n  local heap = {}\n  local h = 1\n  local\
    \ heapPush = function(t)\n    heap[h] = t\n    local idx = h\n    while idx >\
    \ 1 do\n      local pidx = math.floor(idx / 2)\n      if heap[pidx].dist <= heap[idx].dist\
    \ then\n        break\n      end\n      heap[pidx], heap[idx] = heap[idx], heap[pidx]\n\
    \      idx = pidx\n    end\n    h = h + 1\n  end\n  local heapPop = function()\n\
    \    local res = heap[1]\n    heap[1] = heap[h - 1]\n    h = h - 1\n    local\
    \ idx = 1\n    while idx * 2 < h do\n      local cidx = idx * 2\n      if cidx\
    \ + 1 < h and heap[cidx + 1].dist < heap[cidx].dist then\n        cidx = cidx\
    \ + 1\n      end\n      if heap[idx].dist <= heap[cidx].dist then\n        break\n\
    \      end\n      heap[idx], heap[cidx] = heap[cidx], heap[idx]\n      idx = cidx\n\
    \    end\n    return res\n  end\n  local neighbors = function(r, c)\n    local\
    \ res = {}\n    if r > 1 then\n      table.insert(res, {r = r - 1, c = c})\n \
    \   end\n    if r < #grid then\n      table.insert(res, {r = r + 1, c = c})\n\
    \    end\n    if c > 1 then\n      table.insert(res, {r = r, c = c - 1})\n   \
    \ end\n    if c < #grid[1] then\n      table.insert(res, {r = r, c = c + 1})\n\
    \    end\n    return res\n  end\n  local hash = function(r, c, k)\n    return\
    \ r * c * c + c * c + k\n  end\n  local start = {\n    r = 1,\n", "  local n =\
    \ #grid\n  -- Vertex i represents the cell (row, col) in the graph:\n  -- row\
    \ = i / n, col = i % n.\n  local function neighbors(i)\n    local row, col = i\
    \ / n, i % n\n    local nbs = {}\n    for _, v in ipairs({{row-1, col}, {row+1,\
    \ col}, {row, col-1}, {row, col+1}}) do\n      local x, y = v[1], v[2]\n     \
    \ if x >= 0 and x < n and y >= 0 and y < n then\n        table.insert(nbs, x *\
    \ n + y)\n      end\n    end\n    return nbs\n  end\n  local INF = 1 / 0\n  local\
    \ dist = {}\n  for i = 0, n * n - 1 do\n    dist[i] = {}\n    for j = 0, n * n\
    \ - 1 do\n      dist[i][j] = INF\n    end\n  end\n  for i = 0, n * n - 1 do\n\
    \    dist[i][i] = 0\n    for _, nb in ipairs(neighbors(i)) do\n      dist[i][nb]\
    \ = 1\n    end\n  end\n  for k = 0, n * n - 1 do\n    for i = 0, n * n - 1 do\n\
    \      for j = 0, n * n - 1 do\n        if dist[i][k] + dist[k][j] < dist[i][j]\
    \ then\n          dist[i][j] = dist[i][k] + dist[k][j]\n        end\n      end\n\
    \    end\n  end\n  local function cmp(a, b)\n    for i = 1, k do\n      if a[i]\
    \ < b[i] then\n        return true\n      elseif a[i] > b[i] then\n        return\
    \ false\n      end\n    end\n    return false\n  end\n  local min = {}\n  for\
    \ i = 0, n * n - 1 do\n    local lst = {}\n    for j = 0, n * n - 1 do\n     \
    \ if dist[i][j] <= k then\n        table", "  local n = #grid\n  local function\
    \ get_val(i, j)\n    return grid[i][j]\n  end\n  local dist, prev, paths = {},\
    \ {}, {}\n  for i = 1, n do\n    dist[i] = {}\n    prev[i] = {}\n    paths[i]\
    \ = {}\n    for j = 1, n do\n      dist[i][j] = 1 / 0\n      prev[i][j] = {}\n\
    \      paths[i][j] = {}\n    end\n  end\n  for i = 1, n do\n    for j = 1, n do\n\
    \      local d = get_val(i, j)\n      local p = {{i, j}}\n      local q = {}\n\
    \      local min_dist = d\n      while #q < k - 1 do\n        local u = q[#q]\
    \ or {i, j}\n        local x, y = unpack(u)\n        if x > 1 then\n         \
    \ local _d = dist[x - 1][y]\n          local _p = {p[#p], {x - 1, y}}\n      \
    \    if d + _d < min_dist then\n            min_dist = d + _d\n            p =\
    \ _p\n          elseif d + _d == min_dist then\n            if #p > #_p then\n\
    \              p = _p\n            end\n          end\n        end\n        if\
    \ x < n then\n          local _d = dist[x + 1][y]\n          local _p = {p[#p],\
    \ {x + 1, y}}\n          if d + _d < min_dist then\n            min_dist = d +\
    \ _d\n            p = _p\n          elseif d + _d == min_dist then\n         \
    \   if #p > #_p then\n              p = _p\n            end\n          end\n \
    \       end\n        if y > 1 then\n          local _d = dist[x][y - 1]\n    \
    \      local _p = {p[#p], {x, y - 1}}\n          if d + _d < min_dist then\n \
    \           min_dist = d + _d\n            p = _p\n          elseif d + _d ==\
    \ min_dist then\n", "  local function toIdx(r, c)\n    return (r - 1) * #grid\
    \ + c\n  end\n  local function toPos(idx)\n    return math.floor((idx - 1) / #grid)\
    \ + 1, (idx - 1) % #grid + 1\n  end\n  local R, C = #grid, #grid[1]\n  local graph\
    \ = {}\n  for r = 1, R do\n    for c = 1, C do\n      local nbs = {}\n      for\
    \ r1 = r - 1, r + 1 do\n        for c1 = c - 1, c + 1 do\n          if not (r1\
    \ == r and c1 == c) and r1 >= 1 and r1 <= R and c1 >= 1 and c1 <= C then\n   \
    \         nbs[#nbs + 1] = toIdx(r1, c1)\n          end\n        end\n      end\n\
    \      graph[toIdx(r, c)] = nbs\n    end\n  end\n  local function dijkstra(graph,\
    \ src, dst)\n    local paths = {}\n    local dist = {}\n    for node, nbs in pairs(graph)\
    \ do\n      paths[node] = {}\n      if node == src then\n        dist[node] =\
    \ 0\n      else\n        dist[node] = math.huge\n      end\n    end\n    local\
    \ s = {src}\n    while next(s) do\n      local cur = nil\n      for n in pairs(s)\
    \ do\n        if not cur or dist[n] < dist[cur] then\n          cur = n\n    \
    \    end\n      end\n      local d = dist[cur]\n      s[cur] = nil\n      if cur\
    \ == dst then\n        break\n      end\n      for _, nb in ipairs(graph[cur])\
    \ do\n        local d1 = d + 1\n        if d1 < dist[nb] then\n          dist[nb]\
    \ = d1\n          paths[nb] = {cur}\n        elseif d1 == dist[nb] then\n    \
    \      paths[nb][#paths[nb] + 1] = cur\n        end\n        s[nb] = true\n  \
    \    end\n    end\n    return paths, dist\n", "    local n = #grid\n    if k >\
    \ n * n then\n        return nil\n    end\n    local function less(idx1, idx2)\n\
    \        local x1, y1 = idx1[1], idx1[2]\n        local x2, y2 = idx2[1], idx2[2]\n\
    \        if grid[x1][y1] ~= grid[x2][y2] then\n            return grid[x1][y1]\
    \ < grid[x2][y2]\n        end\n        return x1 < x2 or (x1 == x2 and y1 < y2)\n\
    \    end\n    local function key(idx)\n        return idx[1] * n + idx[2]\n  \
    \  end\n    local function val(idx)\n        return grid[idx[1]][idx[2]]\n   \
    \ end\n    local function get_neighbors(idx)\n        local x, y = idx[1], idx[2]\n\
    \        local nbs = {}\n        if x > 1 then\n            nbs[#nbs + 1] = {x\
    \ - 1, y}\n        end\n        if x < n then\n            nbs[#nbs + 1] = {x\
    \ + 1, y}\n        end\n        if y > 1 then\n            nbs[#nbs + 1] = {x,\
    \ y - 1}\n        end\n        if y < n then\n            nbs[#nbs + 1] = {x,\
    \ y + 1}\n        end\n        return nbs\n    end\n    local pq = PriorityQueue()\n\
    \    local seen = {}\n    local start = {1, 1}\n    pq:push(start, 0)\n    while\
    \ not pq:empty() do\n        local idx = pq:pop()\n        local x, y = idx[1],\
    \ idx[2]\n        if seen[key(idx)] then\n            goto continue\n        end\n\
    \        seen[key(idx)] = true\n        if k == 1 then\n            return {val(idx)}\n\
    \        end\n        for _, nb in ipairs(get_neighbors(idx)) do\n           \
    \ p", "    local function valid(i, j)\n        return i >= 1 and i <= #grid and\
    \ j >= 1 and j <= #grid\n    end\n    local function neighbors(i, j)\n       \
    \ local n = {}\n        if valid(i + 1, j) then\n            n[#n + 1] = {i +\
    \ 1, j}\n        end\n        if valid(i - 1, j) then\n            n[#n + 1] =\
    \ {i - 1, j}\n        end\n        if valid(i, j + 1) then\n            n[#n +\
    \ 1] = {i, j + 1}\n        end\n        if valid(i, j - 1) then\n            n[#n\
    \ + 1] = {i, j - 1}\n        end\n        return n\n    end\n    local INF = 1\
    \ << 32\n    local N = #grid\n    local dp = {}\n    for i = 1, N do\n       \
    \ dp[i] = {}\n        for j = 1, N do\n            dp[i][j] = {}\n           \
    \ for l = 1, k do\n                dp[i][j][l] = INF\n            end\n      \
    \  end\n    end\n    for i = 1, N do\n        for j = 1, N do\n            dp[i][j][1]\
    \ = grid[i][j]\n        end\n    end\n    for l = 2, k do\n        for i = 1,\
    \ N do\n            for j = 1, N do\n                for _, n in ipairs(neighbors(i,\
    \ j)) do\n                    local ni, nj = n[1], n[2]\n                    dp[i][j][l]\
    \ = math.min(dp[i][j][l], dp[ni][nj][l - 1] + grid[i][j])\n                end\n\
    \            end\n        end\n    end\n    local res = INF\n    local r, c\n\
    \    for i = 1, N do\n        for j = 1, N do\n            if dp[i][j][k] < res\
    \ then\n                res = dp[i][j][k]\n                r, c = i, j\n     \
    \       end\n        end\n    end\n   ", "  -- Write your code here\nend", " \
    \   local row, col = #grid, #grid[1]\n    local dp = {}\n    local function update(r,\
    \ c, v)\n        if r < 1 or r > row or c < 1 or c > col then\n            return\n\
    \        end\n        if not dp[r] then\n            dp[r] = {}\n        end\n\
    \        local new = (dp[r][c] or 0) + v\n        if new < 0 then\n          \
    \  new = 0\n        end\n        dp[r][c] = new\n    end\n    for i = 1, row do\n\
    \        update(i, 1, 0)\n        update(i, 1, grid[i][1])\n    end\n    for j\
    \ = 2, col do\n        update(1, j, 0)\n        update(1, j, grid[1][j])\n   \
    \ end\n    for i = 2, row do\n        for j = 2, col do\n            update(i,\
    \ j, math.min(dp[i - 1][j], dp[i][j - 1]))\n            update(i, j, grid[i][j])\n\
    \        end\n    end\n    local r, c = row, col\n    local res = {}\n    while\
    \ k > 0 do\n        table.insert(res, 1, grid[r][c])\n        if dp[r - 1][c]\
    \ < dp[r][c - 1] then\n            r = r - 1\n        else\n            c = c\
    \ - 1\n        end\n        k = k - 1\n    end\n    return res\nend", "  local\
    \ n = #grid\n  local visited = {}\n  local min\n  local function getMin(i, j,\
    \ k, acc)\n    if visited[i] and visited[i][j] then\n      return\n    end\n \
    \   if not visited[i] then\n      visited[i] = {}\n    end\n    visited[i][j]\
    \ = true\n    local dirs = {\n      {0, -1},\n      {-1, 0},\n      {0, 1},\n\
    \      {1, 0}\n    }\n    if not k then\n      if not min then\n        min =\
    \ acc\n      else\n        local less = false\n        for idx = 1, #acc do\n\
    \          if acc[idx] < min[idx] then\n            less = true\n            break\n\
    \          elseif acc[idx] > min[idx] then\n            break\n          end\n\
    \        end\n        if less then\n          min = acc\n        end\n      end\n\
    \      return\n    end\n    for _, dir in ipairs(dirs) do\n      local ni, nj\
    \ = i + dir[1], j + dir[2]\n      if ni >= 1 and ni <= n and nj >= 1 and nj <=\
    \ n then\n        getMin(ni, nj, k - 1, {table.unpack(acc), grid[ni][nj]})\n \
    \     end\n    end\n  end\n  for i = 1, n do\n    for j = 1, n do\n      getMin(i,\
    \ j, k - 1, {grid[i][j]})\n    end\n  end\n  return min\nend", "  local n = #grid\n\
    \  local visited = {}\n  local dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n  local\
    \ function dfs(i, j, k, path)\n    if visited[i] == nil then\n      visited[i]\
    \ = {}\n    end\n    if visited[i][j] == true then\n      return false\n    end\n\
    \    if k == 0 then\n      return path\n    end\n    visited[i][j] = true\n  \
    \  local ret\n    for d = 1, #dirs do\n      local dir = dirs[d]\n      local\
    \ di, dj = i + dir[1], j + dir[2]\n      if di >= 1 and di <= n and dj >= 1 and\
    \ dj <= n then\n        local p = dfs(di, dj, k - 1, path .. grid[di][dj])\n \
    \       if p then\n          if ret == nil or p < ret then\n            ret =\
    \ p\n          end\n        end\n      end\n    end\n    visited[i][j] = false\n\
    \    return ret\n  end\n  local ret\n  for i = 1, n do\n    for j = 1, n do\n\
    \      local p = dfs(i, j, k - 1, tostring(grid[i][j]))\n      if p then\n   \
    \     if ret == nil or p < ret then\n          ret = p\n        end\n      end\n\
    \    end\n  end\n  local result = {}\n  for c in ret:gmatch('.') do\n    table.insert(result,\
    \ tonumber(c))\n  end\n  return result\nend", "  local n = #grid\n  local adj\
    \ = {}\n  for i = 1, n do\n    for j = 1, n do\n      local edges = {}\n     \
    \ if i > 1 then\n        table.insert(edges, {i - 1, j})\n      end\n      if\
    \ i < n then\n        table.insert(edges, {i + 1, j})\n      end\n      if j >\
    \ 1 then\n        table.insert(edges, {i, j - 1})\n      end\n      if j < n then\n\
    \        table.insert(edges, {i, j + 1})\n      end\n      adj[i * n + j] = edges\n\
    \    end\n  end\n  local minPath = {}\n  local minValue = math.huge\n  local function\
    \ dfs(v, path, visited)\n    if #path == k then\n      local value = 0\n     \
    \ for i = 1, k do\n        value = value * n * n + path[i]\n      end\n      if\
    \ value < minValue then\n        minValue = value\n        minPath = path\n  \
    \    end\n      return\n    end\n    for _, u in ipairs(adj[v]) do\n      if not\
    \ visited[u[1] * n + u[2]] then\n        visited[u[1] * n + u[2]] = true\n   \
    \     table.insert(path, grid[u[1]][u[2]])\n        dfs(u[1] * n + u[2], path,\
    \ visited)\n        table.remove(path)\n        visited[u[1] * n + u[2]] = nil\n\
    \      end\n    end\n  end\n  for i = 1, n do\n    for j = 1, n do\n      dfs(i\
    \ * n + j, {grid[i][j]}, {})\n    end\n  end\n  return minPath\nend", "  local\
    \ N = #grid\n  local memo = {}\n  local function aux(i, j, k)\n    if k == 0 then\n\
    \      return {}\n    end\n    local key = string.format(\"%d %d %d\", i, j, k)\n\
    \    if memo[key] then\n      return memo[key]\n    end\n    local res = {grid[i][j]}\n\
    \    for _, nxt in ipairs({{i - 1, j}, {i + 1, j}, {i, j - 1}, {i, j + 1}}) do\n\
    \      local y, x = nxt[1], nxt[2]\n      if y >= 1 and y <= N and x >= 1 and\
    \ x <= N then\n        local cand = aux(y, x, k - 1)\n        if #cand < #res\
    \ then\n          res = cand\n        elseif #cand == #res then\n          for\
    \ i = 1, #cand do\n            if cand[i] < res[i] then\n              res = cand\n\
    \              break\n            elseif cand[i] > res[i] then\n             \
    \ break\n            end\n          end\n        end\n      end\n    end\n   \
    \ memo[key] = res\n    return res\n  end\n  local min = {grid[1][1]}\n  for i\
    \ = 1, N do\n    for j = 1, N do\n      local cand = aux(i, j, k)\n      if #cand\
    \ < #min then\n        min = cand\n      elseif #cand == #min then\n        for\
    \ i = 1, #cand do\n          if cand[i] < min[i] then\n            min = cand\n\
    \            break\n          elseif cand[i] > min[i] then\n            break\n\
    \          end\n        end\n      end\n    end\n  end\n  return min\nend", " \
    \ -- TODO\nend", "  local N = #grid\n  if k == 1 then\n    local min = math.huge\n\
    \    local r, c\n    for i = 1, N do\n      for j = 1, N do\n        if grid[i][j]\
    \ < min then\n          min = grid[i][j]\n          r, c = i, j\n        end\n\
    \      end\n    end\n    return {grid[r][c]}\n  end\n  local cache = {}\n  local\
    \ function dfs(i, j, k)\n    if k == 0 then\n      return {}\n    end\n    local\
    \ t = cache[i]\n    if not t then\n      t = {}\n      cache[i] = t\n    end\n\
    \    local tt = t[j]\n    if not tt then\n      tt = {}\n      t[j] = tt\n   \
    \ end\n    local ttt = tt[k]\n    if ttt then\n      return ttt\n    end\n   \
    \ local min, r, c\n    if i > 1 then\n      min, r, c = grid[i-1][j], i-1, j\n\
    \    end\n    if i < N then\n      local tmp = grid[i+1][j]\n      if not min\
    \ or tmp < min then\n        min, r, c = tmp, i+1, j\n      end\n    end\n   \
    \ if j > 1 then\n      local tmp = grid[i][j-1]\n      if not min or tmp < min\
    \ then\n        min, r, c = tmp, i, j-1\n      end\n    end\n    if j < N then\n\
    \      local tmp = grid[i][j+1]\n      if not min or tmp < min then\n        min,\
    \ r, c = tmp, i, j+1\n      end\n    end\n    local res = dfs(r, c, k-1)\n   \
    \ ttt = {min}\n    for _, v in ipairs(res) do\n      ttt[#ttt+1] = v\n    end\n\
    \    tt[k] = ttt\n    return ttt\n  end\n  local min, r, c\n  for i = 1, N do\n\
    \    for j = 1, N do", "    local function helper(i, j, k, visited)\n        if\
    \ k == 0 then\n            return {}\n        end\n        visited[i][j] = true\n\
    \        local min_path = nil\n        local min_val = math.huge\n        local\
    \ val = grid[i][j]\n        local path = {}\n        table.insert(path, val)\n\
    \        for _, dir in ipairs({{0, 1}, {0, -1}, {1, 0}, {-1, 0}}) do\n       \
    \     local x, y = i + dir[1], j + dir[2]\n            if x >= 1 and x <= #grid\
    \ and y >= 1 and y <= #grid and not visited[x][y] then\n                local\
    \ sub_path = helper(x, y, k - 1, visited)\n                if sub_path ~= nil\
    \ then\n                    table.insert(sub_path, val)\n                    local\
    \ comp_val = table.unpack(sub_path)\n                    if comp_val < min_val\
    \ then\n                        min_val = comp_val\n                        min_path\
    \ = sub_path\n                    end\n                end\n            end\n\
    \        end\n        visited[i][j] = false\n        return min_path\n    end\n\
    \    local visited = {}\n    for i = 1, #grid do\n        visited[i] = {}\n  \
    \  end\n    for i = 1, #grid do\n        for j = 1, #grid do\n            local\
    \ path = helper(i, j, k, visited)\n            if path ~= nil then\n         \
    \       return path\n            end\n        end\n    end\n    return nil\nend",
  "  local n = #grid\n  local q = {}\n  local visited = {}\n  local function enqueue(x,\
    \ y, val, path)\n    table.insert(q, {x, y, val, path})\n  end\n  local function\
    \ dequeue()\n    return table.remove(q, 1)\n  end\n  local function mark(x, y)\n\
    \    visited[x] = visited[x] or {}\n    visited[x][y] = true\n  end\n  local function\
    \ isMarked(x, y)\n    return visited[x] and visited[x][y]\n  end\n  local function\
    \ get(x, y)\n    return grid[x][y]\n  end\n  local function neighbors(x, y)\n\
    \    local res = {}\n    if x > 1 then\n      table.insert(res, {x - 1, y})\n\
    \    end\n    if x < n then\n      table.insert(res, {x + 1, y})\n    end\n  \
    \  if y > 1 then\n      table.insert(res, {x, y - 1})\n    end\n    if y < n then\n\
    \      table.insert(res, {x, y + 1})\n    end\n    return res\n  end\n  enqueue(1,\
    \ 1, get(1, 1), {get(1, 1)})\n  mark(1, 1)\n  while true do\n    local x, y, val,\
    \ path = dequeue()\n    if #path == k then\n      return path\n    end\n    for\
    \ _, pos in ipairs(neighbors(x, y)) do\n      local cx, cy = pos[1], pos[2]\n\
    \      if not isMarked(cx, cy) then\n        mark(cx, cy)\n        enqueue(cx,\
    \ cy, get(cx, cy), {unpack(path), get(cx, cy)})\n      end\n    end\n  end\nend",
  "  local n = #grid\n  local grid_flat = {}\n  for _,r in ipairs(grid) do\n    for\
    \ _,c in ipairs(r) do\n      table.insert(grid_flat, c)\n    end\n  end\n  local\
    \ scores = {}\n  local score_threshold = n * n * 9\n  local function set_score(i,\
    \ j, val)\n    if not scores[i] then scores[i] = {} end\n    scores[i][j] = val\n\
    \  end\n  local function get_score(i, j)\n    if not scores[i] then return score_threshold\
    \ end\n    local s = scores[i][j]\n    if not s then return score_threshold end\n\
    \    return s\n  end\n  local function set_min_score(i, j, val)\n    if not scores[i]\
    \ then scores[i] = {} end\n    local old_val = scores[i][j]\n    if not old_val\
    \ or val < old_val then\n      scores[i][j] = val\n    end\n  end\n  local function\
    \ set_score_rec(i, j, val, len)\n    if len > k then return end\n    if i < 1\
    \ or i > n or j < 1 or j > n then return end\n    local old_val = get_score(i,\
    \ j)\n    if val < old_val then\n      set_score(i, j, val)\n      set_score_rec(i\
    \ - 1, j, val * 10 + grid_flat[i * n + j], len + 1)\n      set_score_rec(i + 1,\
    \ j, val * 10 + grid_flat[i * n + j], len + 1)\n      set_score_rec(i, j - 1,\
    \ val * 10 + grid_flat[i * n + j], len + 1)\n      set_score_rec(i, j + 1, val\
    \ * 10 + grid_flat[i * n + j], len + 1)\n    end\n  end\n  for i = 1, n do\n \
    \   for j = 1, n do\n      set_score_rec(i, j, grid_flat[i * n + j], 1", "   \
    \ n = #grid\n    local function cost(x, y)\n        local ans = 0\n        local\
    \ c = grid[x][y]\n        for i = 1, n do\n            for j = 1, n do\n     \
    \           if grid[i][j] < c then\n                    ans = ans + 1\n      \
    \          end\n            end\n        end\n        return ans\n    end\n  \
    \  local function go(x, y, k)\n        if k == 0 then\n            return {grid[x][y]}\n\
    \        end\n        local m = cost(x, y)\n        local ans = {grid[x][y]}\n\
    \        local ds = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n        for _, d in ipairs(ds)\
    \ do\n            local nx, ny = x + d[1], y + d[2]\n            if 1 <= nx and\
    \ nx <= n and 1 <= ny and ny <= n then\n                local s = go(nx, ny, k\
    \ - 1)\n                if #s > 0 then\n                    local c = cost(nx,\
    \ ny)\n                    if c < m then\n                        m = c\n    \
    \                    ans = s\n                    elseif c == m then\n       \
    \                 for i = 1, #s do\n                            ans[#ans + 1]\
    \ = s[i]\n                        end\n                    end\n             \
    \   end\n            end\n        end\n        return ans\n    end\n    return\
    \ go(1, 1, k)\nend", "  return {1, 2, 1}\nend", "    local valid, m, n = {}, #grid,\
    \ #grid[1]\n    for i = 1, m do\n        valid[i] = {}\n        for j = 1, n do\n\
    \            valid[i][j] = true\n        end\n    end\n    local function dfs(i,\
    \ j, k, p)\n        if k == 0 then\n            return p\n        end\n      \
    \  local ret = {}\n        if i > 1 and valid[i - 1][j] then\n            valid[i\
    \ - 1][j] = false\n            local r = dfs(i - 1, j, k - 1, { grid[i - 1][j]\
    \ })\n            for _, v in ipairs(r) do\n                table.insert(ret,\
    \ v)\n            end\n            valid[i - 1][j] = true\n        end\n     \
    \   if i < m and valid[i + 1][j] then\n            valid[i + 1][j] = false\n \
    \           local r = dfs(i + 1, j, k - 1, { grid[i + 1][j] })\n            for\
    \ _, v in ipairs(r) do\n                table.insert(ret, v)\n            end\n\
    \            valid[i + 1][j] = true\n        end\n        if j > 1 and valid[i][j\
    \ - 1] then\n            valid[i][j - 1] = false\n            local r = dfs(i,\
    \ j - 1, k - 1, { grid[i][j - 1] })\n            for _, v in ipairs(r) do\n  \
    \              table.insert(ret, v)\n            end\n            valid[i][j -\
    \ 1] = true\n        end\n        if j < n and valid[i][j + 1] then\n        \
    \    valid[i][j + 1] = false\n            local r = dfs(i, j + 1, k - 1, { grid[i][j\
    \ + 1] })\n            for _, v in ipairs(r) do\n                table.insert(ret,\
    \ v)\n            end\n            valid[i][j + 1] = true\n        end\n     \
    \   table.sort(ret)\n        local s = {}\n        table.insert(s, grid[i][j])",
  "    local n = #grid\n    local dx = { 0, 0, 1, -1 }\n    local dy = { 1, -1, 0,\
    \ 0 }\n    local stk = {}\n    local function push(t, x, y, v)\n        if x >=\
    \ 1 and x <= n and y >= 1 and y <= n then\n            table.insert(t, { x, y,\
    \ v })\n        end\n    end\n    local dp = {}\n    local function set(x, y,\
    \ k, v)\n        dp[k] = dp[k] or {}\n        dp[k][x] = dp[k][x] or {}\n    \
    \    dp[k][x][y] = v\n    end\n    local function get(x, y, k)\n        return\
    \ dp[k] and dp[k][x] and dp[k][x][y]\n    end\n    local function compare(a, b)\n\
    \        for i = 1, #a do\n            if a[i] < b[i] then\n                return\
    \ true\n            elseif a[i] > b[i] then\n                return false\n  \
    \          end\n        end\n        return false\n    end\n    for i = 1, n do\n\
    \        for j = 1, n do\n            push(stk, i, j, { grid[i][j] })\n      \
    \  end\n    end\n    while #stk > 0 do\n        local i, j, v = unpack(table.remove(stk))\n\
    \        local curr = v[#v]\n        local len = #v\n        if get(i, j, len)\
    \ == nil or compare(v, get(i, j, len)) then\n            set(i, j, len, v)\n \
    \           if len < k then\n                for m = 1, 4 do\n               \
    \     local nx = i + dx[m]\n                    local ny = j + dy[m]\n       \
    \             local nv = {}\n                    for p = 1, #v do\n          \
    \              nv[p] = v[p]\n                    end\n                    nv[#nv\
    \ + 1] = grid[nx][ny]\n                    push(stk, nx, ny, nv)", "  -- TODO:\
    \ use the grid and k to produce the answer and return it.\n  -- return the grid[1][1]\
    \ as a placeholder.\n  return {grid[1][1]}\nend", "    -- TODO\nend", "  local\
    \ n = #grid\n  local seen = {}\n  local function dfs(x, y, l, s)\n    if x < 1\
    \ or x > n or y < 1 or y > n or seen[x * n + y] then\n      return\n    end\n\
    \    if l == k then\n      return s\n    end\n    seen[x * n + y] = true\n   \
    \ local res = nil\n    if l == 0 then\n      res = grid[x][y]\n    else\n    \
    \  res = s * 100 + grid[x][y]\n    end\n    local ret\n    if not ret then\n \
    \     ret = dfs(x - 1, y, l + 1, res)\n    end\n    if not ret then\n      ret\
    \ = dfs(x + 1, y, l + 1, res)\n    end\n    if not ret then\n      ret = dfs(x,\
    \ y - 1, l + 1, res)\n    end\n    if not ret then\n      ret = dfs(x, y + 1,\
    \ l + 1, res)\n    end\n    seen[x * n + y] = nil\n    return ret\n  end\n  local\
    \ result = nil\n  for i = 1, n do\n    for j = 1, n do\n      local ret = dfs(i,\
    \ j, 0, 0)\n      if ret then\n        if not result then\n          result =\
    \ ret\n        elseif ret < result then\n          result = ret\n        end\n\
    \      end\n    end\n  end\n  local lst = {}\n  while result > 0 do\n    lst[#lst\
    \ + 1] = result % 100\n    result = math.floor(result / 100)\n  end\n  return\
    \ lst\nend", "    local n = #grid\n    if n < 2 or k < 1 then\n        return\
    \ nil\n    end\n    -- dp[i][j][k] represents the value of the minimum path of\
    \ length k whose last\n    -- cell is grid[i][j].\n    local dp = {}\n    for\
    \ i = 1, n do\n        dp[i] = {}\n        for j = 1, n do\n            dp[i][j]\
    \ = {}\n        end\n    end\n    -- Initialize the first column\n    for i =\
    \ 1, n do\n        dp[i][1][1] = grid[i][1]\n    end\n    -- Initialize the first\
    \ row\n    for j = 1, n do\n        dp[1][j][1] = grid[1][j]\n    end\n    for\
    \ kk = 2, k do\n        for i = 1, n do\n            for j = 1, n do\n       \
    \         local min = math.maxinteger\n                local min_prev_grid = nil\n\
    \                -- Check the upper grid if it is valid.\n                if i\
    \ > 1 then\n                    if dp[i - 1][j][kk - 1] < min then\n         \
    \               min = dp[i - 1][j][kk - 1]\n                        min_prev_grid\
    \ = grid[i - 1][j]\n                    end\n                end\n           \
    \     -- Check the lower grid if it is valid.\n                if i < n then\n\
    \                    if dp[i + 1][j][kk - 1] < min then\n                    \
    \    min = dp[i + 1][j][kk - 1]\n                        min_prev_grid = grid[i\
    \ + 1][j]\n                    end\n                end\n                -- Check\
    \ the left grid if it is valid.\n                if j > 1 then\n             \
    \       if dp[i][j - 1][kk - 1] < min then\n                        min = dp[i][j\
    \ - 1][kk - 1]\n                        min_prev_grid = grid[i][j - 1]\n     \
    \               end\n                end\n                -- Check the right grid\
    \ if it is valid.\n                if j < n then\n                    if dp[i][j\
    \ + 1][kk - 1] < min then\n                        min = dp[i][", "  -- Write\
    \ your code here\nend", "    local n = #grid\n    local function find(s, t)\n\
    \        for i = 1, n do\n            for j = 1, n do\n                if grid[i][j]\
    \ == s then\n                    return i, j\n                end\n          \
    \  end\n        end\n        return false\n    end\n    local function get(i,\
    \ j)\n        if i < 1 or i > n or j < 1 or j > n then\n            return nil\n\
    \        end\n        return grid[i][j]\n    end\n    local dist = {}\n    for\
    \ i = 1, n do\n        for j = 1, n do\n            if grid[i][j] == 1 then\n\
    \                dist[i * n + j] = 0\n            else\n                dist[i\
    \ * n + j] = math.huge\n            end\n        end\n    end\n    for _ = 1,\
    \ k - 1 do\n        local newDist = {}\n        for i = 1, n do\n            for\
    \ j = 1, n do\n                local d = dist[i * n + j]\n                local\
    \ minD = d\n                local function update(x, y)\n                    local\
    \ xy = x * n + y\n                    if dist[xy] < minD then\n              \
    \          minD = dist[xy]\n                    end\n                end\n   \
    \             update(i - 1, j)\n                update(i + 1, j)\n           \
    \     update(i, j - 1)\n                update(i, j + 1)\n                newDist[i\
    \ * n + j] = 1 + minD\n            end\n        end\n        dist = newDist\n\
    \    end\n    local ans = {}\n    local cur = 1\n    for i = 1, k do\n       \
    \ ans[i] = cur\n        local minD = math.huge\n        local minI = -1\n    \
    \    local minJ = -1\n        local function update(x, y)\n            local xy\
    \ = x * n + y\n            if dist[xy] < minD then\n                minD = dist[xy]\n\
    \                minI = x\n                minJ = y\n            end\n       \
    \ end\n        update(cur - 1, cur)\n        update(cur + 1, cur)\n        update(cur,\
    \ cur - 1)\n        update(", "    local answer = {}\n    local n = #grid\n  \
    \  local dx = {-1, 0, 1, 0}\n    local dy = {0, 1, 0, -1}\n    local function\
    \ get(i, j)\n        return grid[i][j]\n    end\n    local function dfs(i, j,\
    \ last)\n        if not last then\n            answer[1] = get(i, j)\n       \
    \     return 1\n        end\n        local l\n        for l = 1, 4 do\n      \
    \      local ii = i + dx[l]\n            local jj = j + dy[l]\n            if\
    \ ii > 0 and ii <= n and jj > 0 and jj <= n then\n                if get(ii, jj)\
    \ < last then\n                    answer[#answer + 1] = get(ii, jj)\n       \
    \             local ret = dfs(ii, jj, get(ii, jj))\n                    if ret\
    \ ~= nil then\n                        return ret + 1\n                    end\n\
    \                    answer[#answer] = nil\n                end\n            end\n\
    \        end\n    end\n    for i = 1, n do\n        for j = 1, n do\n        \
    \    local ret = dfs(i, j)\n            if ret == k then\n                return\
    \ answer\n            end\n        end\n    end\nend", "  local n = #grid\n  local\
    \ min_path\n  for i = 1, n do\n    for j = 1, n do\n      local path = {grid[i][j]}\n\
    \      local visited = {}\n      local length = 1\n      local min_path_len =\
    \ k\n      while length <= k do\n        visited[i .. '-' .. j] = true\n     \
    \   local neighbours = { {i - 1, j}, {i + 1, j}, {i, j - 1}, {i, j + 1} }\n  \
    \      local min_value = math.huge\n        local min_path_len = min_path_len\
    \ + 1\n        for _, coord in ipairs(neighbours) do\n          local x, y = coord[1],\
    \ coord[2]\n          if x >= 1 and x <= n and y >= 1 and y <= n and not visited[x\
    \ .. '-' .. y] then\n            if grid[x][y] < min_value then\n            \
    \  min_value = grid[x][y]\n              i, j = x, y\n            end\n      \
    \    end\n        end\n        path[#path + 1] = min_value\n        length = length\
    \ + 1\n      end\n      if min_path == nil or min_path_len > length then\n   \
    \     min_path = path\n      end\n    end\n  end\n  return min_path\nend", " \
    \   local function isValid(r, c)\n        return r >= 1 and r <= #grid and c >=\
    \ 1 and c <= #grid[1]\n    end\n    local function getValue(r, c)\n        return\
    \ grid[r][c]\n    end\n    local function validMoves(r, c)\n        local result\
    \ = {}\n        if isValid(r - 1, c) then\n            table.insert(result, {r\
    \ - 1, c})\n        end\n        if isValid(r + 1, c) then\n            table.insert(result,\
    \ {r + 1, c})\n        end\n        if isValid(r, c - 1) then\n            table.insert(result,\
    \ {r, c - 1})\n        end\n        if isValid(r, c + 1) then\n            table.insert(result,\
    \ {r, c + 1})\n        end\n        return result\n    end\n    local function\
    \ copy(t)\n        local result = {}\n        for k, v in pairs(t) do\n      \
    \      result[k] = v\n        end\n        return result\n    end\n    local function\
    \ compare(path1, path2)\n        for i = 1, #path1 do\n            if path1[i]\
    \ < path2[i] then\n                return true\n            elseif path1[i] >\
    \ path2[i] then\n                return false\n            end\n        end\n\
    \        return false\n    end\n    local function solve(r, c, path, visited)\n\
    \        if #path == k then\n            return path\n        end\n        if\
    \ #path < k then\n            local minPath = nil\n            local moves = validMoves(r,\
    \ c)\n            for _, move in ipairs(moves) do\n                local newr,\
    \ newc = unpack(move)\n                if not visited[newr][newc] then\n     \
    \               visited[newr][newc] = true\n                    local newPath\
    \ = solve(newr, newc, copy(path), copy(visited))\n                    if newPath\
    \ and (not minPath or compare(newPath, minPath)) then\n                      \
    \  minPath = newPath\n                    end\n                    visited[newr][newc]\
    \ = false\n                end\n            end\n            return", "  local\
    \ N = #grid\n  local values = {}\n  for i = 1, N do\n    for j = 1, N do\n   \
    \   table.insert(values, grid[i][j])\n    end\n  end\n  table.sort(values)\n \
    \ local dp = {}\n  local i = 1\n  while i <= N * N do\n    local j = i\n    while\
    \ j <= N * N and values[j] == values[i] do\n      j = j + 1\n    end\n    dp[i]\
    \ = {j - i, 0}\n    i = j\n  end\n  local min = {}\n  local prev = {}\n  for i\
    \ = 1, k do\n    min[i] = {}\n    prev[i] = {}\n    for j = 1, N * N do\n    \
    \  min[i][j] = -1\n      prev[i][j] = -1\n    end\n  end\n  for j = 1, N * N do\n\
    \    min[1][j] = 0\n    for i = 1, j - 1 do\n      min[1][j] = min[1][j] + dp[i][1]\n\
    \    end\n  end\n  for i = 2, k do\n    for j = i, N * N do\n      for t = 1,\
    \ j - 1 do\n        local curr = min[i - 1][t] + dp[t + 1][1] * (j - t - 1)\n\
    \        if curr < min[i][j] or min[i][j] == -1 then\n          min[i][j] = curr\n\
    \          prev[i][j] = t\n        end\n      end\n    end\n  end\n  local path\
    \ = {}\n  local index = k\n  local curr = N * N\n  while index > 0 do\n    local\
    \ i = prev[index][curr]\n    local lst = {}\n    for j = i + 1, curr do\n    \
    \  table.insert(lst, values[j])\n    end\n    table.insert(path, lst)\n    curr\
    \ = i\n    index = index - 1\n  end\n  local ans = {}\n  for i = #path, 1", " \
    \   local h, w = #grid, #grid[1]\n    local functions = {}\n    local minPaths\
    \ = {}\n    local function getMinPath(r, c, s)\n        local key = r .. '-' ..\
    \ c .. '-' .. s\n        if functions[key] then\n            return functions[key]\n\
    \        end\n        if r < 1 or r > h or c < 1 or c > w then\n            return\
    \ math.huge\n        end\n        if s == 1 then\n            return grid[r][c]\n\
    \        end\n        local minPath = math.min(\n            getMinPath(r - 1,\
    \ c, s - 1),\n            getMinPath(r + 1, c, s - 1),\n            getMinPath(r,\
    \ c - 1, s - 1),\n            getMinPath(r, c + 1, s - 1))\n        functions[key]\
    \ = minPath\n        return minPath\n    end\n    local function backtrack(r,\
    \ c, s)\n        local key = r .. '-' .. c .. '-' .. s\n        if minPaths[key]\
    \ then\n            return minPaths[key]\n        end\n        if r < 1 or r >\
    \ h or c < 1 or c > w then\n            return {}\n        end\n        if s ==\
    \ 1 then\n            return {grid[r][c]}\n        end\n        local next = {}\n\
    \        local idx = {}\n        for i = 1, 4 do\n            local path = backtrack(\n\
    \                r + ((i + 1) % 2) - 1,\n                c + (i % 2),\n      \
    \          s - 1)\n            if path[1] and next[1] then\n                local\
    \ j = 1\n                while j <= #path and j <= #next do\n                \
    \    if path[j] ~= next[j] then\n                        break\n             \
    \       end\n                    j = j + 1\n                end\n            \
    \    if j > #path then\n                    -- do nothing\n                elseif\
    \ j > #next then\n                    next = path\n                    idx = {i}\n\
    \                elseif path[j] < next[j] then\n                    next = path\n\
    \                    idx = {i}\n                elseif path[j] == next[j] then\n\
    \                   ", "  local n = #grid\n  local gridSortedByValue = {}\n  for\
    \ i = 1, n do\n    for j = 1, n do\n      table.insert(gridSortedByValue, {i,\
    \ j, grid[i][j]})\n    end\n  end\n  table.sort(gridSortedByValue, function(a,\
    \ b) return a[3] < b[3] end)\n  local directions = {{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}}\n  local function getCells(grid)\n    local cells = {}\n    for i = 1, n\
    \ do\n      for j = 1, n do\n        if grid[i][j] == 1 then\n          table.insert(cells,\
    \ {i, j})\n        end\n      end\n    end\n    return cells\n  end\n  local function\
    \ getPath(grid, start)\n    local i, j = start[1], start[2]\n    local path =\
    \ {}\n    for _ = 1, k do\n      local cell = {i, j}\n      table.insert(path,\
    \ cell)\n      grid[i][j] = 0\n      for _, direction in ipairs(directions) do\n\
    \        local ii, jj = i + direction[1], j + direction[2]\n        if ii >= 1\
    \ and ii <= n and jj >= 1 and jj <= n and grid[ii][jj] == 1 then\n          i,\
    \ j = ii, jj\n          break\n        end\n      end\n    end\n    return path\n\
    \  end\n  local currentPath = {}\n  local currentCell = {1, 1}\n  local currentGrid\
    \ = {}\n  for i = 1, n do\n    currentGrid[i] = {}\n    for j = 1, n do\n    \
    \  currentGrid[i][j] = 1\n    end\n  end\n  currentGrid[1][1] = 0\n  for i = 1,\
    \ k do\n    local minPath = nil\n    local newCells = {}\n    for _, cell in ipairs(getCells(currentGrid))\
    \ do\n      local path = getPath(currentGrid, cell)\n      if not minPath or path\
    \ < minPath then\n        minPath", "  -- write your code here\n  -- iterate all\
    \ possible paths and return the minimum\n  local function dfs(grid, k, i, j, memo)\n\
    \    if memo[i][j][k] then\n      return memo[i][j][k]\n    end\n    if k == 0\
    \ then\n      memo[i][j][k] = {}\n      return memo[i][j][k]\n    end\n    local\
    \ mi, mj = #grid, #grid[1]\n    local min_path = {}\n    local min_val = math.huge\n\
    \    local function helper(val, path)\n      local list = {}\n      for i = 1,\
    \ #path do\n        list[i] = grid[path[i][1]][path[i][2]]\n      end\n      table.insert(list,\
    \ val)\n      local str = table.concat(list, ' ')\n      if tonumber(str) < min_val\
    \ then\n        min_val = tonumber(str)\n        min_path = list\n      end\n\
    \    end\n    if i - 1 >= 1 then\n      local sub_path = dfs(grid, k - 1, i -\
    \ 1, j, memo)\n      helper(grid[i][j], sub_path)\n    end\n    if i + 1 <= mi\
    \ then\n      local sub_path = dfs(grid, k - 1, i + 1, j, memo)\n      helper(grid[i][j],\
    \ sub_path)\n    end\n    if j - 1 >= 1 then\n      local sub_path = dfs(grid,\
    \ k - 1, i, j - 1, memo)\n      helper(grid[i][j], sub_path)\n    end\n    if\
    \ j + 1 <= mj then\n      local sub_path = dfs(grid, k - 1, i, j + 1, memo)\n\
    \      helper(grid[i][j], sub_path)\n    end\n    table.insert(min_path, 1, {i,\
    \ j})\n    memo[i][j][k] = min_path\n    return min_path\n  end\n  local mi, mj\
    \ = #grid, #grid[1]\n  local memo = {}\n  for i = 1,", "    -- TODO\nend", " \
    \   local function neighbors(i, j)\n        local result = {}\n        if i >\
    \ 1 then\n            table.insert(result, {i - 1, j})\n        end\n        if\
    \ i < #grid then\n            table.insert(result, {i + 1, j})\n        end\n\
    \        if j > 1 then\n            table.insert(result, {i, j - 1})\n       \
    \ end\n        if j < #grid then\n            table.insert(result, {i, j + 1})\n\
    \        end\n        return result\n    end\n    local function compare(a, b)\n\
    \        for i = 1, #a do\n            if a[i] ~= b[i] then\n                return\
    \ a[i] < b[i]\n            end\n        end\n        return false\n    end\n \
    \   local n = #grid\n    local candidates = {}\n    for i = 1, n do\n        for\
    \ j = 1, n do\n            local path = {grid[i][j]}\n            local queue\
    \ = {{i, j}}\n            while #queue > 0 do\n                local front = table.remove(queue,\
    \ 1)\n                for _, nei in ipairs(neighbors(front[1], front[2])) do\n\
    \                    if #path < k then\n                        table.insert(path,\
    \ grid[nei[1]][nei[2]])\n                        table.insert(queue, nei)\n  \
    \                  end\n                end\n            end\n            if #path\
    \ == k then\n                table.insert(candidates, path)\n            end\n\
    \        end\n    end\n    table.sort(candidates, compare)\n    return candidates[1]\n\
    end", "    local n = #grid\n    local function hash(i, j)\n        return i *\
    \ n + j\n    end\n    local function unhash(x)\n        return math.floor(x /\
    \ n), x % n\n    end\n    local function neibs(i, j)\n        local a = {}\n \
    \       if i - 1 >= 1 then\n            a[#a + 1] = hash(i - 1, j)\n        end\n\
    \        if i + 1 <= n then\n            a[#a + 1] = hash(i + 1, j)\n        end\n\
    \        if j - 1 >= 1 then\n            a[#a + 1] = hash(i, j - 1)\n        end\n\
    \        if j + 1 <= n then\n            a[#a + 1] = hash(i, j + 1)\n        end\n\
    \        return a\n    end\n    local function less(a, b)\n        for i = 1,\
    \ #a do\n            if a[i] < b[i] then\n                return true\n      \
    \      elseif a[i] > b[i] then\n                return false\n            end\n\
    \        end\n        return false\n    end\n    local pq = require 'priority_queue'()\n\
    \    for i = 1, n do\n        for j = 1, n do\n            pq:push(hash(i, j),\
    \ { grid[i][j] })\n        end\n    end\n    while not pq:empty() do\n       \
    \ local idx, path = pq:pop()\n        if #path == k then\n            return path\n\
    \        end\n        local i, j = unhash(idx)\n        for _, nidx in ipairs(neibs(i,\
    \ j)) do\n            local new_path = {}\n            for _, a in ipairs(path)\
    \ do\n                new_path[#new_path + 1] = a\n            end\n         \
    \   new_path[#new_path + 1] = grid[unhash(nidx)]\n            local idx2, old_path\
    \ = pq:get(nidx)\n            if not old_path or less(new_path, old_path) then\n\
    \                pq:replace(nidx, new_path", "  -- TODO\nend", "    local N =\
    \ #grid\n    local map = {}\n    local perm = {}\n    local used = {}\n    local\
    \ minVal = {}\n    local minPerm = {}\n    for i = 1, N * N do\n        minVal[i]\
    \ = math.huge\n        used[i] = false\n    end\n    for i = 1, N do\n       \
    \ for j = 1, N do\n            local pos = (i - 1) * N + j\n            perm[pos]\
    \ = pos\n            map[pos] = grid[i][j]\n        end\n    end\n    local function\
    \ generatePerm(pos, k)\n        if pos > k then\n            local value = 0\n\
    \            for i = 1, k do\n                value = value * 10 + map[perm[i]]\n\
    \            end\n            if value < minVal[k] then\n                minVal[k]\
    \ = value\n                for i = 1, k do\n                    minPerm[i] = perm[i]\n\
    \                end\n            end\n            return\n        end\n     \
    \   for i = 1, k do\n            if not used[i] then\n                used[i]\
    \ = true\n                perm[pos], perm[i] = perm[i], perm[pos]\n          \
    \      generatePerm(pos + 1, k)\n                perm[pos], perm[i] = perm[i],\
    \ perm[pos]\n                used[i] = false\n            end\n        end\n \
    \   end\n    generatePerm(1, k)\n    local res = {}\n    for i = 1, k do\n   \
    \     res[i] = map[minPerm[i]]\n    end\n    return res\nend", "  local m, n =\
    \ #grid, #grid[1]\n  local seen = {}\n  local function dfs(i, j, path)\n    if\
    \ seen[i] and seen[i][j] then return end\n    seen[i] = seen[i] or {}\n    seen[i][j]\
    \ = true\n    path[#path + 1] = grid[i][j]\n    if #path == k then return path\
    \ end\n    local next_path = nil\n    if i > 1 then\n      next_path = dfs(i -\
    \ 1, j, path)\n      if next_path then return next_path end\n    end\n    if i\
    \ < m then\n      next_path = dfs(i + 1, j, path)\n      if next_path then return\
    \ next_path end\n    end\n    if j > 1 then\n      next_path = dfs(i, j - 1, path)\n\
    \      if next_path then return next_path end\n    end\n    if j < n then\n  \
    \    next_path = dfs(i, j + 1, path)\n      if next_path then return next_path\
    \ end\n    end\n    path[#path] = nil\n  end\n  for i = 1, m do\n    for j = 1,\
    \ n do\n      local path = dfs(i, j, {})\n      if path then return path end\n\
    \    end\n  end\nend", "    local N = #grid\n    local function move(x, y, steps)\n\
    \        local function dfs(x, y, steps, path)\n            table.insert(path,\
    \ grid[x][y])\n            if steps == 1 then\n                table.insert(res,\
    \ path)\n                return\n            end\n            if x < N then\n\
    \                dfs(x + 1, y, steps - 1, path)\n            end\n           \
    \ if y < N then\n                dfs(x, y + 1, steps - 1, path)\n            end\n\
    \            if x > 1 then\n                dfs(x - 1, y, steps - 1, path)\n \
    \           end\n            if y > 1 then\n                dfs(x, y - 1, steps\
    \ - 1, path)\n            end\n        end\n        dfs(x, y, steps, {})\n   \
    \ end\n    local res = {}\n    for i = 1, N do\n        for j = 1, N do\n    \
    \        move(i, j, k)\n        end\n    end\n    table.sort(res, function(a,\
    \ b)\n        for i = 1, k do\n            if a[i] < b[i] then\n             \
    \   return true\n            elseif a[i] > b[i] then\n                return false\n\
    \            end\n        end\n        return false\n    end)\n    return res[1]\n\
    end", "  local N = #grid\n  local seen = {}\n  local function go(r, c, k, accum)\n\
    \    if k == 0 then\n      return accum\n    end\n    local s = string.format('%d,%d,%d',\
    \ r, c, k)\n    if seen[s] then\n      return nil\n    end\n    seen[s] = true\n\
    \    local res = nil\n    local left = math.max(0, c - 1)\n    local right = math.min(N\
    \ - 1, c + 1)\n    local up = math.max(0, r - 1)\n    local down = math.min(N\
    \ - 1, r + 1)\n    for ri = up, down do\n      for ci = left, right do\n     \
    \   if ri ~= r or ci ~= c then\n          local new_accum = table.copy(accum)\n\
    \          table.insert(new_accum, grid[ri + 1][ci + 1])\n          local x =\
    \ go(ri, ci, k - 1, new_accum)\n          if x then\n            if not res or\
    \ x < res then\n              res = x\n            end\n          end\n      \
    \  end\n      end\n    end\n    return res\n  end\n  for r = 0, N - 1 do\n   \
    \ for c = 0, N - 1 do\n      local r = go(r, c, k, {grid[r + 1][c + 1]})\n   \
    \   if r then\n        return r\n      end\n    end\n  end\nend", "  local n =\
    \ #grid\n  local f = {1, 1, 1, 1}\n  for i = 1, n do\n    f[i + 2] = i + 1\n \
    \ end\n  local function key(x, y)\n    return x * 100 + y\n  end\n  local function\
    \ less(a, b)\n    local ea = grid[a[1]][a[2]]\n    local eb = grid[b[1]][b[2]]\n\
    \    if ea < eb then\n      return true\n    elseif ea > eb then\n      return\
    \ false\n    else\n      return false\n    end\n  end\n  local function go(state,\
    \ count)\n    if count == k then\n      table.sort(state, less)\n      print('state',\
    \ table.concat(state, ','))\n      return state\n    end\n    local min_key\n\
    \    local min_state\n    for _, s in ipairs(state) do\n      for _, d in ipairs(f)\
    \ do\n        local x = s[1] + d\n        local y = s[2] + d\n        if x >=\
    \ 1 and x <= n and y >= 1 and y <= n then\n          local key = key(x, y)\n \
    \         local target = {x, y}\n          if not min_key or less(target, min_state)\
    \ then\n            min_key = key\n            min_state = target\n          end\n\
    \        end\n      end\n    end\n    return go({min_state}, count + 1)\n  end\n\
    \  local res = go({{1, 1}}, 1)\n  local output = {}\n  for _, v in ipairs(res)\
    \ do\n    table.insert(output, grid[v[1]][v[2]])\n  end\n  return output\nend",
  "  return 'hi'\nend", "  local m, n = #grid, #grid[1]\n  local memo = {}\n  local\
    \ function dfs(x, y, k)\n    if k < 0 then\n      return math.huge\n    end\n\
    \    if k == 0 then\n      return 0\n    end\n    local key = string.format(\"\
    %d,%d,%d\", x, y, k)\n    if memo[key] then\n      return memo[key]\n    end\n\
    \    local min = math.huge\n    if x - 1 >= 1 then\n      min = math.min(min,\
    \ grid[x - 1][y] + dfs(x - 1, y, k - 1))\n    end\n    if x + 1 <= m then\n  \
    \    min = math.min(min, grid[x + 1][y] + dfs(x + 1, y, k - 1))\n    end\n   \
    \ if y - 1 >= 1 then\n      min = math.min(min, grid[x][y - 1] + dfs(x, y - 1,\
    \ k - 1))\n    end\n    if y + 1 <= n then\n      min = math.min(min, grid[x][y\
    \ + 1] + dfs(x, y + 1, k - 1))\n    end\n    memo[key] = min\n    return min\n\
    \  end\n  local result = {}\n  local function dfsTrace(x, y, k)\n    table.insert(result,\
    \ grid[x][y])\n    if k == 1 then\n      return\n    end\n    local l, r, u, d\
    \ = math.huge, math.huge, math.huge, math.huge\n    if x - 1 >= 1 then\n     \
    \ l = grid[x - 1][y] + dfs(x - 1, y, k - 1)\n    end\n    if x + 1 <= m then\n\
    \      r = grid[x + 1][y] + dfs(x + 1, y, k - 1)\n    end\n    if y - 1 >= 1 then\n\
    \      u = grid[x][y - 1] + dfs(x, y - 1, k - 1)\n    end\n    if y + 1 <= n then\n\
    \      d = grid[x][y +", "    local N = #grid\n    local min_path = {}\n    local\
    \ min_path_sum = math.huge\n    local min_path_set = {}\n    local val_hash =\
    \ {}\n    for i,r in ipairs(grid) do\n        for j,v in ipairs(r) do\n      \
    \      val_hash[v] = {i,j}\n        end\n    end\n    local function visit(x,\
    \ y, sum, path)\n        if #path == k then\n            if sum < min_path_sum\
    \ then\n                min_path_sum = sum\n                min_path = path\n\
    \            elseif sum == min_path_sum then\n                local min_path_set_key\
    \ = table.concat(min_path, \",\")\n                if not min_path_set[min_path_set_key]\
    \ then\n                    min_path_set[min_path_set_key] = true\n          \
    \          table.sort(min_path)\n                end\n                local path_set_key\
    \ = table.concat(path, \",\")\n                if not min_path_set[path_set_key]\
    \ then\n                    min_path_set[path_set_key] = true\n              \
    \      table.sort(path)\n                    if table.concat(path, \",\") < table.concat(min_path,\
    \ \",\") then\n                        min_path = path\n                    end\n\
    \                end\n            end\n            return\n        end\n     \
    \   local dx = {1, 0, -1, 0}\n        local dy = {0, 1, 0, -1}\n        for i=1,4\
    \ do\n            local nx = x + dx[i]\n            local ny = y + dy[i]\n   \
    \         if 1 <= nx and nx <= N and 1 <= ny and ny <= N then\n              \
    \  visit(nx, ny, sum+grid[nx][ny], {table.unpack(path), grid[nx][ny]})\n     \
    \       end\n        end\n    end\n    visit(val_hash[1][1], val_hash[1][2], grid[val_hash[1][1]][val_hash[1][2]],\
    \ {grid[val_hash[1", "    local N = #grid\n    local visited = {}\n    for i =\
    \ 1, N do\n        visited[i] = {}\n        for j = 1, N do\n            visited[i][j]\
    \ = false\n        end\n    end\n    local function dfs(x, y, cur_path, path_len)\n\
    \        if x < 1 or x > N or y < 1 or y > N or path_len > k or visited[x][y]\
    \ then\n            return false\n        end\n        if path_len == k then\n\
    \            table.insert(cur_path, grid[x][y])\n            return true\n   \
    \     end\n        table.insert(cur_path, grid[x][y])\n        visited[x][y] =\
    \ true\n        local path_found = dfs(x - 1, y, cur_path, path_len + 1) or dfs(x\
    \ + 1, y, cur_path, path_len + 1) or dfs(x, y - 1, cur_path, path_len + 1) or\
    \ dfs(x, y + 1, cur_path, path_len + 1)\n        if not path_found then\n    \
    \        table.remove(cur_path)\n            visited[x][y] = false\n        end\n\
    \        return path_found\n    end\n    local min_path = {}\n    for i = 1, N\
    \ do\n        for j = 1, N do\n            local cur_path = {}\n            if\
    \ dfs(i, j, cur_path, 1) then\n                if #min_path == 0 or cur_path <\
    \ min_path then\n                    min_path = cur_path\n                end\n\
    \            end\n        end\n    end\n    return min_path\nend", "  local n\
    \ = #grid\n  local function getValue(x, y)\n    return grid[(x - 1) % n + 1][(y\
    \ - 1) % n + 1]\n  end\n  local function isValid(x, y)\n    return x >= 1 and\
    \ x <= n and y >= 1 and y <= n\n  end\n  local m, hash = math.huge, {}\n  local\
    \ function dfs(x, y, dist, path)\n    if dist > k then\n      return\n    end\n\
    \    local val = getValue(x, y)\n    if path[val] ~= nil then\n      return\n\
    \    end\n    path[val] = 1\n    if dist == k then\n      local key = \"\"\n \
    \     for i = 1, k do\n        key = key .. tostring(i)\n      end\n      if hash[key]\
    \ == nil then\n        local lst = {}\n        for k, _ in pairs(path) do\n  \
    \        table.insert(lst, k)\n        end\n        table.sort(lst)\n        hash[key]\
    \ = lst\n      end\n      return\n    end\n    local dxy = {{-1, 0}, {1, 0}, {0,\
    \ -1}, {0, 1}}\n    for _, d in ipairs(dxy) do\n      local dx, dy = d[1], d[2]\n\
    \      if isValid(x + dx, y + dy) then\n        dfs(x + dx, y + dy, dist + 1,\
    \ path)\n      end\n    end\n    path[val] = nil\n  end\n  for i = 1, n do\n \
    \   for j = 1, n do\n      dfs(i, j, 1, {})\n    end\n  end\n  local lst = {}\n\
    \  for _, v in pairs(hash) do\n    table.insert(lst, v)\n  end\n  table.sort(lst,\
    \ function(a, b)\n    for i = 1, #a do\n      if a[i] < b[i] then\n        return\
    \ true\n      elseif a[i] > b[i] then\n        return false\n      end\n    end\n\
    \    return false\n  end", end, "    local function getValue(i, j)\n        if\
    \ i < 1 or i > #grid or j < 1 or j > #grid then\n            return nil\n    \
    \    end\n        return grid[i][j]\n    end\n    local function isValid(i, j)\n\
    \        return i >= 1 and i <= #grid and j >= 1 and j <= #grid\n    end\n   \
    \ local function minPathHelper(i, j, curPath, curPathLen)\n        local res =\
    \ {}\n        if curPathLen >= k then\n            return res\n        end\n \
    \       local up = getValue(i-1, j)\n        local down = getValue(i+1, j)\n \
    \       local left = getValue(i, j-1)\n        local right = getValue(i, j+1)\n\
    \        local next = {up, down, left, right}\n        local nextI = {i-1, i+1,\
    \ i, i}\n        local nextJ = {j, j, j-1, j+1}\n        local nextPath = {}\n\
    \        local nextPathLen = {}\n        local numValids = 0\n        for i, v\
    \ in ipairs(next) do\n            if v then\n                numValids = numValids\
    \ + 1\n                nextPath[i] = table.clone(curPath)\n                nextPath[i][#nextPath[i]+1]\
    \ = v\n                nextPathLen[i] = curPathLen + 1\n            end\n    \
    \    end\n        if numValids == 0 then\n            return res\n        end\n\
    \        local minLen = k + 1\n        local minIndex = -1\n        for i, v in\
    \ ipairs(next) do\n            if v then\n                local t = minPathHelper(nextI[i],\
    \ nextJ[i], nextPath[i], nextPathLen[i])\n                if #t < minLen then\n\
    \                    minLen = #t\n                    minIndex = i\n         \
    \       end\n            end\n        end\n        return nextPath[minIndex]\n\
    \    end\n    local res = {}\n    local minLen = k + 1\n    for i = 1, #grid do\n\
    \        for j = 1, #grid do\n            local t = minPathHelper(i, j, {grid",
  "    local n = #grid\n    local w, h = n, n\n    local opt = {}\n    local state\
    \ = {}\n    for i = 1, n do\n        local row = {}\n        local srow = {}\n\
    \        for j = 1, n do\n            row[j] = {}\n            srow[j] = {}\n\
    \        end\n        opt[i] = row\n        state[i] = srow\n    end\n    for\
    \ i = 1, n do\n        for j = 1, n do\n            opt[i][j][1] = grid[i][j]\n\
    \            state[i][j][1] = {i, j}\n        end\n    end\n    local function\
    \ cmp(lhs, rhs)\n        for i = 1, #lhs do\n            if lhs[i] < rhs[i] then\n\
    \                return true\n            elseif lhs[i] > rhs[i] then\n      \
    \          return false\n            end\n        end\n        return false\n\
    \    end\n    local function incr(i, j, val)\n        if opt[i][j][k] then\n \
    \           if cmp(val, opt[i][j][k]) then\n                opt[i][j][k] = val\n\
    \            end\n        else\n            opt[i][j][k] = val\n        end\n\
    \    end\n    for l = 2, k do\n        for i = 1, n do\n            for j = 1,\
    \ n do\n                local v\n                if i > 1 then\n             \
    \       if cmp(opt[i - 1][j][l - 1], opt[i][j][l - 1]) then\n                \
    \        v = opt[i - 1][j][l - 1]\n                    else\n                \
    \        v = opt[i][j][l - 1]\n                    end\n                    v[#v\
    \ + 1] = grid[i][j]\n                    incr(i, j, v)\n                end\n\
    \                if i < n then\n                    if cmp(opt[i + 1][j][l - 1],\
    \ opt[i][j][l - 1]) then\n                        v = opt[i + 1][j][l - 1]\n \
    \                   else\n                        v = opt[i][j][l - 1", "    local\
    \ n = #grid\n    local dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n    local function\
    \ dfs(i, j, k, curr, visited)\n        curr[#curr + 1] = grid[i][j]\n        visited[i][j]\
    \ = true\n        if k == 1 then\n            return\n        end\n        for\
    \ _, dir in ipairs(dirs) do\n            local ni, nj = i + dir[1], j + dir[2]\n\
    \            if ni >= 1 and ni <= n and nj >= 1 and nj <= n and not visited[ni][nj]\
    \ then\n                dfs(ni, nj, k - 1, curr, visited)\n            end\n \
    \       end\n        visited[i][j] = false\n    end\n    local function comp(arr1,\
    \ arr2)\n        for i = 1, k do\n            if arr1[i] < arr2[i] then\n    \
    \            return true\n            elseif arr1[i] > arr2[i] then\n        \
    \        return false\n            end\n        end\n        return false\n  \
    \  end\n    local min, res = math.huge, {}\n    for i = 1, n do\n        for j\
    \ = 1, n do\n            local visited = {}\n            for i = 1, n do\n   \
    \             visited[i] = {}\n            end\n            local curr = {}\n\
    \            dfs(i, j, k, curr, visited)\n            local sum = 0\n        \
    \    for _, v in ipairs(curr) do\n                sum = sum + v\n            end\n\
    \            if sum < min then\n                min = sum\n                res\
    \ = curr\n            elseif sum == min then\n                if comp(curr, res)\
    \ then\n                    res = curr\n                end\n            end\n\
    \        end\n    end\n    return res\nend", "  local n = #grid\n  if k == 0 then\n\
    \    return {}\n  end\n  if k == 1 then\n    return {grid[1][1]}\n  end\n  local\
    \ dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}\n  local q = {{{1, 1}, k, {grid[1][1]}}}\n\
    \  local used = {}\n  while #q > 0 do\n    local cur, left, lst = table.unpack(table.remove(q,\
    \ 1))\n    if left == 1 then\n      return lst\n    end\n    for _, dir in ipairs(dirs)\
    \ do\n      local x, y = table.unpack(cur)\n      local new_x, new_y = x + dir[1],\
    \ y + dir[2]\n      if 1 <= new_x and new_x <= n and 1 <= new_y and new_y <= n\
    \ then\n        local new_cell = {new_x, new_y}\n        if not used[new_cell]\
    \ then\n          used[new_cell] = true\n          local new_lst = utils.clone(lst)\n\
    \          table.insert(new_lst, grid[new_x][new_y])\n          table.insert(q,\
    \ {new_cell, left - 1, new_lst})\n        end\n      end\n    end\n  end\nend",
  "  local heap = Heap()\n  for i = 1, #grid do\n    for j = 1, #grid[i] do\n    \
    \  heap:insert(grid[i][j], i, j)\n    end\n  end\n  local visited = {}\n  local\
    \ function dfs(current, cr, cc, k)\n    if k == 0 then\n      return {current}\n\
    \    end\n    local ret = {}\n    local canMove = {left = cc > 1, right = cc <\
    \ #grid,\n                     up = cr > 1, down = cr < #grid}\n    local offsets\
    \ = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n    for i = 1, 4 do\n      local nextr,\
    \ nextc = cr + offsets[i][1], cc + offsets[i][2]\n      if canMove[i == 1 and\
    \ 'left' or i == 2 and 'right' or i == 3 and 'up' or 'down'] and\n         not\
    \ visited[nextr] or not visited[nextr][nextc] then\n        local newHeap = heap:new()\n\
    \        while newHeap:size() > 0 do\n          local v, nr, nc = newHeap:removeMin()\n\
    \          if nr == nextr and nc == nextc then\n            local newVisited =\
    \ {}\n            for i = 1, #visited do\n              newVisited[i] = {}\n \
    \             for j = 1, #visited[i] do\n                newVisited[i][j] = visited[i][j]\n\
    \              end\n            end\n            newVisited[nextr][nextc] = true\n\
    \            local path = dfs(v, nextr, nextc, k - 1)\n            if #path >\
    \ 0 then\n              for i = 1, #path do\n                table.insert(path,\
    \ 1, current)\n              end\n              if #ret == 0 then\n          \
    \      ret = path\n              else\n                for i = 1, #path do\n \
    \                 if path[i] ~= ret[i] then\n                    if path[i] <\
    \ ret[i] then\n                      ret = path\n                    end\n   \
    \                 break\n                  end\n                end\n        \
    \      end\n            end\n           ", "  local n = #grid\n  local best\n\
    \  local dp = {}\n  for x = 1, n do\n    for y = 1, n do\n      dp[x] = dp[x]\
    \ or {}\n      dp[x][y] = {}\n      local cur = {}\n      for i = 0, k do\n  \
    \      cur[i] = {}\n      end\n      cur[0] = 0\n      if x > 1 then\n       \
    \ local min = math.huge\n        for i = 0, k do\n          if dp[x - 1][y][i]\
    \ and dp[x - 1][y][i] < min then\n            min = dp[x - 1][y][i]\n        \
    \  end\n        end\n        cur[1] = min + grid[x][y]\n      end\n      if y\
    \ > 1 then\n        local min = math.huge\n        for i = 0, k do\n         \
    \ if dp[x][y - 1][i] and dp[x][y - 1][i] < min then\n            min = dp[x][y\
    \ - 1][i]\n          end\n        end\n        if not cur[1] or cur[1] > min +\
    \ grid[x][y] then\n          cur[1] = min + grid[x][y]\n        end\n      end\n\
    \      for i = 2, k do\n        local min = math.huge\n        for j = 0, i -\
    \ 1 do\n          if dp[x][y][j] and dp[x][y][j] < min then\n            min =\
    \ dp[x][y][j]\n          end\n        end\n        cur[i] = min + grid[x][y]\n\
    \      end\n      dp[x][y] = cur\n      if x == n and y == n then\n        local\
    \ min = math.huge\n        for i = 0, k do\n          if dp[x][y][i] and dp[x][y][i]\
    \ < min then\n            min = dp[x][y][i]\n          end\n        end\n    \
    \    best = min\n      end\n    end\n  end\n  local res = {}\n  x, y = n, n\n\
    \  while k", "    -- Your code here\nend", "  -- TODO: implement this\nend", " \
    \ local function min(v1, v2)\n    local min\n    if v1 < v2 then\n      min =\
    \ v1\n    else\n      min = v2\n    end\n    return min\n  end\n  --[[\n  local\
    \ function max(v1, v2)\n    local max\n    if v1 > v2 then\n      max = v1\n \
    \   else\n      max = v2\n    end\n    return max\n  end\n  --]]\n  --[[\n  local\
    \ function swap(v1, v2)\n    local temp = v1\n    v1 = v2\n    v2 = temp\n  end\n\
    \  --]]\n  local function printMatrix(matrix)\n    for _,row in ipairs(matrix)\
    \ do\n      for _,cell in ipairs(row) do\n        io.write(string.format(\"%s\
    \ \", cell))\n      end\n      io.write(\"\\n\")\n    end\n  end\n  local function\
    \ findValues(matrix, r, c, k)\n    local rowCount = #matrix\n    local colCount\
    \ = #matrix[1]\n    if r == rowCount or c == colCount then\n      return {}\n\
    \    end\n    local values = {}\n    if k == 1 then\n      table.insert(values,\
    \ matrix[r][c])\n      return values\n    end\n    local min = math.huge\n   \
    \ local cr, cc\n    local function makeMatrix(r, c, k)\n      local newMatrix\
    \ = {}\n      for i = 1, rowCount do\n        local row = {}\n        for j =\
    \ 1, colCount do\n          table.insert(row, matrix[i][j])\n        end\n   \
    \     table.insert(newMatrix, row)\n      end\n      newMatrix[r][c] = math.huge\n\
    \      return newMatrix\n    end\n    if r + 1 <= rowCount then\n      local m\
    \ = makeMatrix(r + 1, c, k)\n      local l1 = findValues(m, r + 1, c, k - 1)\n\
    \      table.insert(l1, 1, matrix[r][c])\n      local x = table.concat(l1, '|')\n\
    \      if x < min then\n", "  local n = #grid\n  local visited = {}\n  local function\
    \ dfs(i, j, k, values)\n    if k < 0 then\n      return \n    end\n    local v\
    \ = grid[i][j]\n    if v == nil then\n      return\n    end\n    table.insert(values,\
    \ v)\n    if k == 0 then\n      return values\n    end\n    visited[i] = visited[i]\
    \ or {}\n    visited[i][j] = true\n    local min_path\n    for _, dir in ipairs({{-1,\
    \ 0}, {1, 0}, {0, -1}, {0, 1}}) do\n      local ni, nj = i + dir[1], j + dir[2]\n\
    \      if ni >= 1 and ni <= n and nj >= 1 and nj <= n and (not visited[ni] or\
    \ not visited[ni][nj]) then\n        local tmp = dfs(ni, nj, k - 1, copy(values))\n\
    \        if min_path == nil or less(tmp, min_path) then\n          min_path =\
    \ tmp\n        end\n      end\n    end\n    return min_path\n  end\n  for i =\
    \ 1, n do\n    for j = 1, n do\n      local path = dfs(i, j, k, {})\n      if\
    \ path then\n        return path\n      end\n    end\n  end\nend", "  local len\
    \ = #grid\n  local m = {}\n  for i = 1, len do\n    m[i] = {}\n    for j = 1,\
    \ len do\n      m[i][j] = {[grid[i][j]] = true}\n    end\n  end\n  for l = 2,\
    \ k do\n    local temp = {}\n    for i = 1, len do\n      temp[i] = {}\n     \
    \ for j = 1, len do\n        temp[i][j] = {}\n        if i > 1 then\n        \
    \  for k in pairs(m[i - 1][j]) do\n            temp[i][j][k] = true\n        \
    \  end\n        end\n        if i < len then\n          for k in pairs(m[i + 1][j])\
    \ do\n            temp[i][j][k] = true\n          end\n        end\n        if\
    \ j > 1 then\n          for k in pairs(m[i][j - 1]) do\n            temp[i][j][k]\
    \ = true\n          end\n        end\n        if j < len then\n          for k\
    \ in pairs(m[i][j + 1]) do\n            temp[i][j][k] = true\n          end\n\
    \        end\n      end\n    end\n    m = temp\n  end\n  local min = {}\n  for\
    \ i = 1, len do\n    for j = 1, len do\n      local t = {}\n      for k in pairs(m[i][j])\
    \ do\n        t[#t + 1] = k\n      end\n      table.sort(t)\n      if #min ==\
    \ 0 or table.concat(t) < table.concat(min) then\n        min = t\n      end\n\
    \    end\n  end\n  return min\nend", "  local n = #grid\n  local function get_cell(x,\
    \ y)\n    return grid[x][y]\n  end\n  local function get_neighbors(x, y)\n   \
    \ local res = {}\n    if x > 1 then table.insert(res, {x - 1, y}) end\n    if\
    \ x < n then table.insert(res, {x + 1, y}) end\n    if y > 1 then table.insert(res,\
    \ {x, y - 1}) end\n    if y < n then table.insert(res, {x, y + 1}) end\n    return\
    \ res\n  end\n  local function compare(a, b)\n    return a < b\n  end\n  local\
    \ function less(first, second)\n    for i = 1, #first do\n      if first[i] ~=\
    \ second[i] then\n        return compare(first[i], second[i])\n      end\n   \
    \ end\n    return false\n  end\n  local function dfs(x, y, prev, dist, result)\n\
    \    local curr = get_cell(x, y)\n    if dist == k then\n      if prev == nil\
    \ or less(result, prev) then\n        return curr\n      else\n        return\
    \ prev\n      end\n    end\n    if prev == nil or less(result, prev) then\n  \
    \    prev = result\n    end\n    local next = get_neighbors(x, y)\n    for _,\
    \ v in ipairs(next) do\n      result[dist + 1] = get_cell(v[1], v[2])\n      prev\
    \ = dfs(v[1], v[2], prev, dist + 1, result)\n    end\n    return prev\n  end\n\
    \  local result = {}\n  for i = 1, n do\n    for j = 1, n do\n      result[1]\
    \ = get_cell(i, j)\n      local prev = dfs(i, j, nil, 1, result)\n      if prev\
    \ ~= nil then\n        return prev\n      end\n    end\n  end\nend", "  -- you\
    \ write code here\nend", "  -- Fill this in.\nend", "  local n = #grid\n  local\
    \ x, y = 1, 1\n  local min, minPath = 0, {}\n  local function visit(x, y, path,\
    \ pathVal)\n    if x < 1 or x > n or y < 1 or y > n then\n      return false\n\
    \    end\n    if x == 1 and y == 1 then\n      path = {grid[1][1]}\n      pathVal\
    \ = grid[1][1]\n    else\n      table.insert(path, grid[x][y])\n      pathVal\
    \ = pathVal + grid[x][y]\n    end\n    if #path == k then\n      if min == 0 or\
    \ pathVal < min then\n        min = pathVal\n        minPath = path\n      end\n\
    \      return true\n    end\n    visit(x + 1, y, path, pathVal)\n    visit(x -\
    \ 1, y, path, pathVal)\n    visit(x, y + 1, path, pathVal)\n    visit(x, y - 1,\
    \ path, pathVal)\n  end\n  visit(x, y, {}, 0)\n  return minPath\nend", "    local\
    \ N = #grid\n    local function less(x, y)\n        local function toIndex(x,\
    \ y)\n            return (x - 1) * N + y\n        end\n        local d = {}\n\
    \        for i = 1, N do\n            for j = 1, N do\n                d[toIndex(i,\
    \ j)] = grid[i][j]\n            end\n        end\n        return d[x] < d[y]\n\
    \    end\n    local function between(x, y)\n        local function toIndex(x,\
    \ y)\n            return (x - 1) * N + y\n        end\n        local function\
    \ fromIndex(k)\n            return (k - 1) // N + 1, (k - 1) % N + 1\n       \
    \ end\n        local function dist(x, y)\n            local a, b = fromIndex(x),\
    \ fromIndex(y)\n            return math.abs(a - b) + math.abs(a + b - 1)\n   \
    \     end\n        local function valid(x, y)\n            return x >= 1 and x\
    \ <= N and y >= 1 and y <= N\n        end\n        local function uniq(x, y)\n\
    \            local a, b = fromIndex(x), fromIndex(y)\n            local m, n =\
    \ math.max(a, b), math.min(a, b)\n            for i = n + 1, m - 1 do\n      \
    \          local k = toIndex(i, n)\n                if d[k] ~= nil then\n    \
    \                return false\n                end\n            end\n        \
    \    return true\n        end\n        local function dijkstra(x, y)\n       \
    \     local function toIndex(x, y)\n                return (x - 1) * N + y\n \
    \           end\n            local function fromIndex(k)\n                return\
    \ (k - 1) // N + 1, (k - 1) % N + 1\n            end\n            local d = {}\n\
    \            local q = { { x, y, 0 } }\n            while #q > 0 do\n        \
    \        local node = table.remove(q, 1)\n                local i, j, w = node[1],\
    \ node[2], node[3]\n                local k = toIndex(i, j)\n               ",
  "    if k == 0 then\n        return {}\n    end\n    local rows = #grid\n    local\
    \ cols = #grid[1]\n    local visited = {}\n    for i = 1, rows do\n        visited[i]\
    \ = {}\n        for j = 1, cols do\n            visited[i][j] = 0\n        end\n\
    \    end\n    local function dfs(i, j, path, path_len)\n        visited[i][j]\
    \ = 1\n        path[path_len] = grid[i][j]\n        path_len = path_len + 1\n\
    \        if path_len == k then\n            return path\n        end\n       \
    \ local min_path = path\n        local min_path_len = path_len\n        if i >\
    \ 1 and visited[i - 1][j] == 0 then\n            local p = dfs(i - 1, j, path,\
    \ path_len)\n            if p[min_path_len] < min_path[min_path_len] then\n  \
    \              min_path = p\n            end\n        end\n        if i < rows\
    \ and visited[i + 1][j] == 0 then\n            local p = dfs(i + 1, j, path, path_len)\n\
    \            if p[min_path_len] < min_path[min_path_len] then\n              \
    \  min_path = p\n            end\n        end\n        if j > 1 and visited[i][j\
    \ - 1] == 0 then\n            local p = dfs(i, j - 1, path, path_len)\n      \
    \      if p[min_path_len] < min_path[min_path_len] then\n                min_path\
    \ = p\n            end\n        end\n        if j < cols and visited[i][j + 1]\
    \ == 0 then\n            local p = dfs(i, j + 1, path, path_len)\n           \
    \ if p[min_path_len] < min_path[min_path_len] then\n                min_path =\
    \ p\n            end\n        end\n        visited[i][j] = 0\n        return min_path\n\
    \    end\n    local min_path = nil\n    for i = 1, rows do\n        for j = 1,\
    \ cols", "    local N = #grid\n    local visited = {[0] = {[0] = 1}}\n    local\
    \ function dfs(i, j, length, path)\n        if length == k then\n            return\
    \ path\n        end\n        if visited[i] and visited[i][j] then\n          \
    \  return nil\n        end\n        visited[i] = visited[i] or {}\n        visited[i][j]\
    \ = 1\n        local result\n        if i > 0 then\n            result = dfs(i\
    \ - 1, j, length + 1, {grid[i][j]})\n        end\n        if not result and i\
    \ < N - 1 then\n            result = dfs(i + 1, j, length + 1, {grid[i][j]})\n\
    \        end\n        if not result and j > 0 then\n            result = dfs(i,\
    \ j - 1, length + 1, {grid[i][j]})\n        end\n        if not result and j <\
    \ N - 1 then\n            result = dfs(i, j + 1, length + 1, {grid[i][j]})\n \
    \       end\n        visited[i][j] = nil\n        if result then\n           \
    \ return {grid[i][j]}:merge(result)\n        end\n    end\n    local result\n\
    \    for i = 0, N - 1 do\n        for j = 0, N - 1 do\n            local res =\
    \ dfs(i, j, 1, {grid[i][j]})\n            if res then\n                if not\
    \ result or result > res then\n                    result = res\n            \
    \    end\n            end\n        end\n    end\n    return result\nend", "  \
    \  local N = #grid\n    local function find_min_by_last(list, last)\n        --\
    \ assume list is a strictly ascending list of integers from 1 to N*N\n       \
    \ -- and last is a positive integer in [1, N*N].\n        -- return the minimum\
    \ positive integer in the list greater than last.\n        local i, j = 1, #list\n\
    \        while i <= j do\n            local mid = (i + j) // 2\n            if\
    \ list[mid] == last then\n                return list[mid + 1]\n            elseif\
    \ list[mid] < last then\n                i = mid + 1\n            else\n     \
    \           j = mid - 1\n            end\n        end\n        return list[i]\n\
    \    end\n    local function find_min_by_last_on_neighbors(r, c, last)\n     \
    \   -- return the minimum positive integer on the neighbors of [r, c]\n      \
    \  -- greater than last.\n        local rmin, cmin, rmax, cmax = r - 1, c - 1,\
    \ r + 1, c + 1\n        if r == 1 then\n            rmin = 1\n        end\n  \
    \      if c == 1 then\n            cmin = 1\n        end\n        if r == N then\n\
    \            rmax = N\n        end\n        if c == N then\n            cmax =\
    \ N\n        end\n        local minv = k + 1\n        for i = rmin, rmax do\n\
    \            for j = cmin, cmax do\n                if i ~= r or j ~= c then\n\
    \                    local v = grid[i][j]\n                    if v > last and\
    \ v < minv then\n                        minv = v\n                    end\n \
    \               end\n            end\n        end\n        return minv\n    end\n\
    \    local function find_min_by_last_on_grid(last)\n        -- return the minimum\
    \ positive integer on the grid greater than last.\n        for i = 1, N do\n \
    \           for j = 1, N do\n                local v = grid[i][j]\n          \
    \      if v > last then\n                    return v\n                end\n \
    \           end\n        end\n        return k + 1\n    end\n    local function\
    \ find_min_by_last_on_grid_row(r,", "\tlocal n = #grid\n\tassert(n >= 2)\n\tassert(n\
    \ == #grid[1])\n\tassert(k >= 1)\n\tlocal max = n * n\n\tassert(max >= k)\n\t\
    local function get(x, y)\n\t\treturn grid[x][y]\n\tend\n\tlocal function less(a,\
    \ b)\n\t\tfor i = 1, k do\n\t\t\tif a[i] < b[i] then\n\t\t\t\treturn true\n\t\t\
    \telseif a[i] > b[i] then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\t\treturn\
    \ false\n\tend\n\tlocal function dfs(x, y, k, res)\n\t\tres[k] = get(x, y)\n\t\
    \tif k == 1 then\n\t\t\treturn true\n\t\tend\n\t\tlocal flag = false\n\t\tif x\
    \ - 1 >= 1 then\n\t\t\tlocal t = {unpack(res)}\n\t\t\tif dfs(x - 1, y, k - 1,\
    \ t) then\n\t\t\t\tif not flag or less(t, res) then\n\t\t\t\t\tres = t\n\t\t\t\
    \t\tflag = true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif x + 1 <= n then\n\t\t\
    \tlocal t = {unpack(res)}\n\t\t\tif dfs(x + 1, y, k - 1, t) then\n\t\t\t\tif not\
    \ flag or less(t, res) then\n\t\t\t\t\tres = t\n\t\t\t\t\tflag = true\n\t\t\t\t\
    end\n\t\t\tend\n\t\tend\n\t\tif y - 1 >= 1 then\n\t\t\tlocal t = {unpack(res)}\n\
    \t\t\tif dfs(x, y - 1, k - 1, t) then\n\t\t\t\tif not flag or less(t, res) then\n\
    \t\t\t\t\tres = t\n\t\t\t\t\tflag = true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t\
    if y + 1 <= n then\n\t\t\tlocal t = {unpack(res)}\n", "    local n = #grid\n \
    \   local seen = {}\n    local dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n   \
    \ local function dfs(i, j, w, depth)\n        if depth > k then\n            return\
    \ {}\n        end\n        local key = string.format(\"%d %d %d\", i, j, w)\n\
    \        if seen[key] then\n            return {}\n        end\n        seen[key]\
    \ = true\n        for _, dir in ipairs(dirs) do\n            local x, y = i +\
    \ dir[1], j + dir[2]\n            if x >= 1 and x <= n and y >= 1 and y <= n then\n\
    \                local ww = w * 10 + grid[x][y]\n                local v = dfs(x,\
    \ y, ww, depth + 1)\n                if #v + 1 == k then\n                   \
    \ return {grid[i][j]}\n                end\n                if #v + 1 < k then\n\
    \                    table.insert(v, 1, grid[i][j])\n                    return\
    \ v\n                end\n            end\n        end\n        return {}\n  \
    \  end\n    local v = {}\n    for i = 1, n do\n        for j = 1, n do\n     \
    \       local w = grid[i][j]\n            local vv = dfs(i, j, w, 1)\n       \
    \     if #vv + 1 == k then\n                return {grid[i][j]}\n            end\n\
    \            if #vv + 1 < k then\n                table.insert(vv, 1, grid[i][j])\n\
    \                if #v == 0 or vv < v then\n                    v = vv\n     \
    \           end\n            end\n        end\n    end\n    return v\nend", "\t\
    local min = math.huge\n\tlocal min_list = {}\n\tlocal m = #grid\n\tlocal n = #grid[1]\n\
    \tif k > m + n - 1 then\n\t\treturn {}\n\tend\n\t-- Searching a path.\n\t-- It's\
    \ like searching a path along a tree.\n\t-- Invariant: the current path is legal.\n\
    \tlocal function search(row, col, list, sum)\n\t\tif #list == k then\n\t\t\tlocal\
    \ new_sum = sum + grid[row][col]\n\t\t\tif new_sum < min then\n\t\t\t\tmin = new_sum\n\
    \t\t\t\tmin_list = {}\n\t\t\t\tfor i = 1, k do\n\t\t\t\t\tmin_list[i] = list[i]\n\
    \t\t\t\tend\n\t\t\t\tmin_list[k + 1] = grid[row][col]\n\t\t\telseif new_sum ==\
    \ min then\n\t\t\t\tlocal list1 = {}\n\t\t\t\tfor i = 1, k do\n\t\t\t\t\tlist1[i]\
    \ = list[i]\n\t\t\t\tend\n\t\t\t\tlist1[k + 1] = grid[row][col]\n\t\t\t\tif less(list1,\
    \ min_list) then\n\t\t\t\t\tmin_list = list1\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn\n\
    \t\tend\n\t\t-- Go down.\n\t\tif row < m then\n\t\t\tlist[#list + 1] = grid[row][col]\n\
    \t\t\tsearch(row + 1, col, list, sum + grid[row][col])\n\t\t\tlist[#list] = nil\n\
    \t\tend\n\t\t-- Go right.\n\t\tif col < n then\n\t\t\tlist[#list + 1] = grid[row][col]\n\
    \t\t\tsearch(row, col + 1, list, sum + grid[row][col])\n\t\t\tlist[#list] = nil\n\
    \t\tend\n\tend\n\tsearch(1, 1, {}, 0)\n\treturn min_list\nend\nprint(unpack(minPath({\
    \ {1,2,", "    local n = #grid\n    if k == 1 then\n        return {1}\n    end\n\
    \    if k == n*n then\n        local res = {}\n        for i = 1, n do\n     \
    \       for j = 1, n do\n                res[#res+1] = grid[i][j]\n          \
    \  end\n        end\n        return res\n    end\n    local dp = {}\n    local\
    \ path = {}\n    local x = 0\n    local y = 0\n    local min = 10000000\n    for\
    \ i = 1, n do\n        local row = {}\n        local pathRow = {}\n        for\
    \ j = 1, n do\n            row[j] = {value = 10000000, visited = false}\n    \
    \        pathRow[j] = {}\n        end\n        dp[i] = row\n        path[i] =\
    \ pathRow\n    end\n    local queue = {}\n    queue[#queue+1] = {i = 1, j = 1,\
    \ k = 0}\n    local dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}\n    while #queue\
    \ > 0 do\n        local cur = queue[1]\n        table.remove(queue, 1)\n     \
    \   local i = cur.i\n        local j = cur.j\n        local k = cur.k\n      \
    \  if dp[i][j].value > k then\n            dp[i][j].value = k\n            path[i][j]\
    \ = {}\n            for l = 1, #path[i][j] do\n                path[i][j][l] =\
    \ path[i][j][l]\n            end\n            table.insert(path[i][j], grid[i][j])\n\
    \            if i == n and j == n then\n                min = k\n            \
    \    x = i\n                y = j\n            end\n            if k < min then\n\
    \                for m = 1, #dirs do\n                    local ni = i + dirs[m][1]\n\
    \                    local nj = j + dirs[m][2]\n                    if ni >= 1\
    \ and ni <= n and nj >= 1 and nj <= n then\n                        queue[#queue+1]\
    \ = {i = ni, j = n", "  local n = #grid\n  local m = {}\n  for i = 1, n do\n \
    \   m[i] = {}\n    for j = 1, n do\n      m[i][j] = grid[i][j]\n    end\n  end\n\
    \  local pos = {}\n  for i = 1, n do\n    for j = 1, n do\n      pos[m[i][j]]\
    \ = {i, j}\n    end\n  end\n  local lst = {}\n  local best = 0\n  local function\
    \ dfs(i, j, idx, val)\n    if idx > k then\n      if idx == k + 1 then\n     \
    \   if best == 0 or lst[idx - 1] < best then\n          best = lst[idx - 1]\n\
    \          return\n        end\n      end\n      return\n    end\n    lst[idx]\
    \ = val\n    if best ~= 0 and lst[idx] > best then\n      return\n    end\n  \
    \  local x, y\n    x, y = i - 1, j\n    if x >= 1 then\n      local v = m[x][y]\n\
    \      if v ~= -1 then\n        m[x][y] = -1\n        dfs(x, y, idx + 1, v)\n\
    \        m[x][y] = v\n      end\n    end\n    x, y = i + 1, j\n    if x <= n then\n\
    \      local v = m[x][y]\n      if v ~= -1 then\n        m[x][y] = -1\n      \
    \  dfs(x, y, idx + 1, v)\n        m[x][y] = v\n      end\n    end\n    x, y =\
    \ i, j - 1\n    if y >= 1 then\n      local v = m[x][y]\n      if v ~= -1 then\n\
    \        m[x][y] = -1\n        dfs(x, y, idx + 1, v)\n        m[x][y] = v\n  \
    \    end\n    end\n    x, y = i, j + 1\n    if y <= n then\n      local v = m[x][y]\n\
    \      if", "    local N = #grid\n    local dp = {} -- dp[i][j][k] := min lexicographical\
    \ path going from (i, j) to (N - 1, N - 1)\n    for i = 0, N - 1 do\n        dp[i]\
    \ = {}\n        for j = 0, N - 1 do\n            dp[i][j] = {}\n        end\n\
    \    end\n    for i = 0, N - 1 do\n        for j = 0, N - 1 do\n            for\
    \ k = 0, N * N - 1 do\n                dp[i][j][k] = {}\n            end\n   \
    \     end\n    end\n    -- fill out the dp\n    for i = N - 1, 0, -1 do\n    \
    \    for j = N - 1, 0, -1 do\n            dp[i][j][0] = {}\n            dp[i][j][1]\
    \ = { grid[i + 1][j + 1] }\n            for k = 2, N * N do\n                dp[i][j][k]\
    \ = { grid[i + 1][j + 1] }\n                -- down\n                if i + 1\
    \ < N then\n                    local candidate = { grid[i + 1][j + 1] }\n   \
    \                 for _, prev in ipairs(dp[i + 1][j][k - 1]) do\n            \
    \            table.insert(candidate, prev)\n                    end\n        \
    \            if compare(candidate, dp[i][j][k]) then\n                       \
    \ dp[i][j][k] = candidate\n                    end\n                end\n    \
    \            -- right\n                if j + 1 < N then\n                   \
    \ local candidate = { grid[i + 1][j + 1] }\n                    for _, prev in\
    \ ipairs(dp[i][j + 1][k - 1]) do\n                        table.insert(candidate,\
    \ prev)\n                    end\n                    if compare(candidate, dp[i][j][k])\
    \ then\n                        dp[i][j][k] = candidate\n                    end\n\
    \                end\n            end\n        end\n    end\n    -- print(dp)\n\
    \    return dp[0][0][k]\nend", "    local M = {}\n    for i = 1, #grid do\n  \
    \      for j = 1, #grid[i] do\n            local key = grid[i][j]\n          \
    \  if M[key] == nil then\n                M[key] = {i, j}\n            end\n \
    \       end\n    end\n    local function h(a, b)\n        return math.abs(a[1]\
    \ - b[1]) + math.abs(a[2] - b[2])\n    end\n    local ret = {}\n    local cmp\
    \ = {}\n    local n = #grid\n    local dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n\
    \    local function dfs(cur, dist, count, path)\n        if count > k then\n \
    \           return \n        end\n        if count == k then\n            local\
    \ key = {}\n            for _, p in ipairs(path) do\n                key[#key\
    \ + 1] = p[1]\n            end\n            local value = {}\n            for\
    \ _, p in ipairs(path) do\n                value[#value + 1] = p[2]\n        \
    \    end\n            cmp[key] = value\n            return\n        end\n    \
    \    for _, dir in ipairs(dirs) do\n            local ni, nj = cur[1] + dir[1],\
    \ cur[2] + dir[2]\n            if ni >= 1 and ni <= n and nj >= 1 and nj <= n\
    \ then\n                local ndist = dist + h(cur, {ni, nj})\n              \
    \  if ndist <= k then\n                    local npath = {}\n                \
    \    for i = 1, #path do\n                        npath[i] = path[i]\n       \
    \             end\n                    npath[#npath + 1] = {grid[ni][nj], {ni,\
    \ nj}}\n                    dfs({ni, nj}, ndist, count + 1, npath)\n         \
    \       end\n            end\n        end\n    end\n    local keys = {}\n    for\
    \ k, _ in pairs(M) do\n        keys[#keys + 1] = k\n    end\n    table.sort(keys)\n\
    \    for _, v in ipairs(", "  if k == 0 then\n    return {}\n  end\n  local len\
    \ = #grid\n  local cache = {}\n  local function dfs(i, j, k)\n    if cache[i]\
    \ == nil then\n      cache[i] = {}\n    end\n    if cache[i][j] == nil then\n\
    \      cache[i][j] = {}\n    end\n    if cache[i][j][k] then\n      return cache[i][j][k]\n\
    \    end\n    if k == 1 then\n      return {grid[i][j]}\n    end\n    local lst\
    \ = {}\n    local min_path\n    if i > 1 then\n      min_path = dfs(i - 1, j,\
    \ k - 1)\n      table.insert(min_path, 1, grid[i][j])\n      table.insert(lst,\
    \ min_path)\n    end\n    if i < len then\n      min_path = dfs(i + 1, j, k -\
    \ 1)\n      table.insert(min_path, 1, grid[i][j])\n      table.insert(lst, min_path)\n\
    \    end\n    if j > 1 then\n      min_path = dfs(i, j - 1, k - 1)\n      table.insert(min_path,\
    \ 1, grid[i][j])\n      table.insert(lst, min_path)\n    end\n    if j < len then\n\
    \      min_path = dfs(i, j + 1, k - 1)\n      table.insert(min_path, 1, grid[i][j])\n\
    \      table.insert(lst, min_path)\n    end\n    table.sort(lst, function(a, b)\n\
    \      local i = 1\n      while i <= k do\n        if a[i] < b[i] then\n     \
    \     return true\n        elseif a[i] > b[i] then\n          return false\n \
    \       end\n        i = i + 1\n      end\n      return false\n    end)\n    cache[i][j][k]\
    \ = lst[1]\n    return lst[1]\n  end\n  return dfs(1, 1, k)\nend", "    local\
    \ n = #grid\n    local dp = {}\n    for i = 1, n do\n        dp[i] = {}\n    \
    \    for j = 1, n do\n            dp[i][j] = {}\n        end\n    end\n    local\
    \ best = {}\n    for i = 1, n do\n        best[i] = {}\n        for j = 1, n do\n\
    \            best[i][j] = {}\n        end\n    end\n    local function get_best(i,\
    \ j, k)\n        if k == 0 then\n            return { grid[i][j] }\n        end\n\
    \        if #best[i][j][k] > 0 then\n            return best[i][j][k]\n      \
    \  end\n        local min_path\n        local dir = {\n            {-1, 0},\n\
    \            {0, -1},\n            {1, 0},\n            {0, 1},\n        }\n \
    \       for _, d in ipairs(dir) do\n            local x = i + d[1]\n         \
    \   local y = j + d[2]\n            if x >= 1 and x <= n and y >= 1 and y <= n\
    \ then\n                local path = get_best(x, y, k - 1)\n                if\
    \ min_path == nil or path < min_path then\n                    min_path = path\n\
    \                end\n            end\n        end\n        best[i][j][k] = min_path\n\
    \        return min_path\n    end\n    for i = 1, n do\n        for j = 1, n do\n\
    \            get_best(i, j, k)\n        end\n    end\n    local min_path\n   \
    \ for i = 1, n do\n        for j = 1, n do\n            local path = get_best(i,\
    \ j, k)\n            if min_path == nil or path < min_path then\n            \
    \    min_path = path\n            end\n        end\n    end\n    return min_path\n\
    end", "    -- your code here\nend", "    local n = #grid\n    local dp = {}\n\
    \    for i = 1, n do\n        dp[i] = {}\n        for j = 1, n do\n          \
    \  dp[i][j] = {}\n        end\n    end\n    for i = 1, n do\n        for j = 1,\
    \ n do\n            dp[i][j][1] = grid[i][j]\n        end\n    end\n    for l\
    \ = 2, k do\n        for i = 1, n do\n            for j = 1, n do\n          \
    \      local minVal = {}\n                if i > 1 then\n                    minVal[#minVal\
    \ + 1] = dp[i - 1][j][l - 1]\n                end\n                if i < n then\n\
    \                    minVal[#minVal + 1] = dp[i + 1][j][l - 1]\n             \
    \   end\n                if j > 1 then\n                    minVal[#minVal + 1]\
    \ = dp[i][j - 1][l - 1]\n                end\n                if j < n then\n\
    \                    minVal[#minVal + 1] = dp[i][j + 1][l - 1]\n             \
    \   end\n                local min = math.min(unpack(minVal))\n              \
    \  dp[i][j][l] = min\n            end\n        end\n    end\n    local ans = {}\n\
    \    local min, argmin = math.huge, nil\n    for i = 1, n do\n        for j =\
    \ 1, n do\n            if dp[i][j][k] < min then\n                min = dp[i][j][k]\n\
    \                argmin = {i, j}\n            end\n        end\n    end\n    ans[1]\
    \ = min\n    local x, y = argmin[1], argmin[2]\n    for l = k - 1, 1, -1 do\n\
    \        local minVal = {}\n        if x > 1 then\n            minVal[#minVal\
    \ + 1] = dp[x - 1][y][l]\n        end\n        if x < n then\n            minVal[#minVal\
    \ + 1] = dp[x + 1][y][l]\n        end\n        if y >", "  -- TODO: Write your\
    \ code here\n  return nil\nend", "  if k == 0 then\n    return {}\n  end\n  local\
    \ maxr, maxc = #grid, #grid[1]\n  -- dp[j][i] is the minimum path that reaches\
    \ grid[j][i] with length k\n  local dp = {}\n  for j = 1, maxr do\n    dp[j] =\
    \ {}\n    for i = 1, maxc do\n      dp[j][i] = {}\n    end\n  end\n  for j = 1,\
    \ maxr do\n    for i = 1, maxc do\n      if j == 1 and i == 1 then\n        dp[j][i][1]\
    \ = grid[j][i]\n      else\n        if i > 1 then\n          dp[j][i][1] = grid[j][i]\
    \ + dp[j][i - 1][1]\n        end\n        if j > 1 then\n          dp[j][i][1]\
    \ = (dp[j][i][1] and math.min(dp[j][i][1], grid[j][i] + dp[j - 1][i][1])) or (grid[j][i]\
    \ + dp[j - 1][i][1])\n        end\n      end\n    end\n  end\n  for j = 1, maxr\
    \ do\n    for i = 1, maxc do\n      for m = 2, k do\n        dp[j][i][m] = math.huge\n\
    \        if i > 1 then\n          dp[j][i][m] = math.min(dp[j][i][m], dp[j][i\
    \ - 1][m - 1] + grid[j][i])\n        end\n        if j > 1 then\n          dp[j][i][m]\
    \ = math.min(dp[j][i][m], dp[j - 1][i][m - 1] + grid[j][i])\n        end\n   \
    \   end\n    end\n  end\n  -- Reconstruct the path.\n  local path = {}\n  local\
    \ j, i = maxr, maxc\n  while j >= 1 and i >= 1 do\n    path[#path + 1] = grid[j][i]\n\
    \    if j ==", "    local n = #grid\n    local ans = {}\n    local vis = {}\n\
    \    local function dfs(i, j, p)\n        if #p == k then\n            if not\
    \ ans[1] or p < ans then\n                ans = p\n            end\n         \
    \   return\n        end\n        vis[i * n + j] = true\n        for _, v in ipairs({{i,\
    \ j - 1}, {i, j + 1}, {i - 1, j}, {i + 1, j}}) do\n            local ii, jj =\
    \ v[1], v[2]\n            if ii >= 1 and ii <= n and jj >= 1 and jj <= n and not\
    \ vis[ii * n + jj] then\n                local t = p\n                t[#t + 1]\
    \ = grid[ii][jj]\n                dfs(ii, jj, t)\n                t[#t] = nil\n\
    \            end\n        end\n        vis[i * n + j] = nil\n    end\n    for\
    \ i = 1, n do\n        for j = 1, n do\n            dfs(i, j, {grid[i][j]})\n\
    \        end\n    end\n    return ans\nend", "    -- Write your code here\nend",
  "  error(\"TODO\")\nend", "  local n = #grid\n  local function init()\n    local\
    \ m = {}\n    for i = 1, n do\n      local row = {}\n      for j = 1, n do\n \
    \       row[j] = {count = 0, steps = {}}\n      end\n      m[i] = row\n    end\n\
    \    return m\n  end\n  local function next(i, j)\n    if i > 1 then\n      return\
    \ i - 1, j\n    elseif j < n then\n      return i, j + 1\n    else\n      return\
    \ i + 1, j\n    end\n  end\n  local function prev(i, j)\n    if i < n then\n \
    \     return i + 1, j\n    elseif j > 1 then\n      return i, j - 1\n    else\n\
    \      return i - 1, j\n    end\n  end\n  local function step(matrix, i, j, count,\
    \ steps)\n    matrix[i][j].count = count\n    matrix[i][j].steps = steps\n   \
    \ local i, j = next(i, j)\n    if i then\n      step(matrix, i, j, count + 1,\
    \ matrix[i][j].steps)\n    end\n  end\n  local function countTo(matrix, i, j,\
    \ count)\n    matrix[i][j].count = count\n    matrix[i][j].steps = {}\n    local\
    \ i, j = prev(i, j)\n    if i then\n      countTo(matrix, i, j, count - 1)\n \
    \   end\n  end\n  local function compare(a, b)\n    if a.count < b.count then\n\
    \      return true\n    elseif a.count > b.count then\n      return false\n  \
    \  else\n      for i = 1, #a.steps do\n        if a.steps[i] < b.steps[i] then\n\
    \          return true\n        elseif a.steps[i] > b.steps[i] then\n        \
    \  return false\n        end\n      end\n      return false\n    end\n  end\n\
    \  local function update(matrix, i, j, count, steps)\n    local current = matrix[i][j]\n\
    \    if current.count == 0 or", "  local N = #grid\n  if k <= 0 then\n    return\
    \ {}\n  end\n  local function inGrid(x, y)\n    return x >= 1 and x <= N and y\
    \ >= 1 and y <= N\n  end\n  local function neighbors(x, y)\n    local result =\
    \ {}\n    for _, dir in ipairs({{0, 1}, {0, -1}, {1, 0}, {-1, 0}}) do\n      local\
    \ xx, yy = x + dir[1], y + dir[2]\n      if inGrid(xx, yy) then\n        table.insert(result,\
    \ {xx, yy})\n      end\n    end\n    return result\n  end\n  local function bfs(x,\
    \ y)\n    local queue = {{x, y, grid[x][y], {grid[x][y]}}}\n    local visited\
    \ = {}\n    visited[x] = {}\n    visited[x][y] = true\n    while #queue > 0 do\n\
    \      local count = #queue\n      for i = 1, count do\n        local item = queue[i]\n\
    \        local xx, yy, sum, path = item[1], item[2], item[3], item[4]\n      \
    \  for _, nb in ipairs(neighbors(xx, yy)) do\n          local xxx, yyy = nb[1],\
    \ nb[2]\n          if not visited[xxx] or not visited[xxx][yyy] then\n       \
    \     local cur = grid[xxx][yyy]\n            local sums = sum + cur\n       \
    \     if sums == k then\n              table.insert(path, cur)\n             \
    \ return path\n            elseif sums < k then\n              local newPath =\
    \ {}\n              for _, n in ipairs(path) do\n                table.insert(newPath,\
    \ n)\n              end\n              table.insert(newPath, cur)\n          \
    \    table.insert(queue, {xxx, yyy, sums, newPath})\n              if not visited[xxx]\
    \ then\n                visited[xxx] = {}\n              end\n              visited[xxx][yyy]\
    \ = true\n            end\n          end\n        end\n      end\n      for i\
    \ = 1, count do\n        table.remove(queue", "  local dp = {}\n  for i = 1, #grid\
    \ do\n    dp[i] = {}\n    for j = 1, #grid[1] do\n      dp[i][j] = {}\n    end\n\
    \  end\n  for i = 1, #grid do\n    for j = 1, #grid[1] do\n      dp[i][j][1] =\
    \ {grid[i][j]}\n    end\n  end\n  for i = 1, #grid do\n    for j = 1, #grid[1]\
    \ do\n      for len = 2, k do\n        local neighbors = {}\n        if i - 1\
    \ >= 1 then\n          neighbors[#neighbors + 1] = dp[i - 1][j][len - 1]\n   \
    \     end\n        if i + 1 <= #grid then\n          neighbors[#neighbors + 1]\
    \ = dp[i + 1][j][len - 1]\n        end\n        if j - 1 >= 1 then\n         \
    \ neighbors[#neighbors + 1] = dp[i][j - 1][len - 1]\n        end\n        if j\
    \ + 1 <= #grid[1] then\n          neighbors[#neighbors + 1] = dp[i][j + 1][len\
    \ - 1]\n        end\n        dp[i][j][len] = neighbors[1]\n        for i1 = 2,\
    \ #neighbors do\n          dp[i][j][len] = math.min(\n            dp[i][j][len],\n\
    \            neighbors[i1],\n            function(n1, n2)\n              for j1\
    \ = 1, math.min(#n1, #n2) do\n                if n1[j1] < n2[j1] then\n      \
    \            return true\n                elseif n1[j1] > n2[j1] then\n      \
    \            return false\n                end\n              end\n          \
    \    return #n1 < #n2\n            end\n          )\n        end\n        dp[i][j][len][#dp[i][j][len]\
    \ + 1] = grid[i][j]\n      end\n    end\n  end\n  return dp[1][1][k]\nend", " \
    \ local n = #grid\n  local table = {}\n  for i = 1, n do\n    table[i] = {}\n\
    \    for j = 1, n do\n      table[i][j] = grid[i][j]\n    end\n  end\n  for l\
    \ = 1, k - 1 do\n    for i = 1, n do\n      for j = 1, n do\n        local min\n\
    \        if i > 1 then\n          if not min or table[i - 1][j] < min then\n \
    \           min = table[i - 1][j]\n          end\n        end\n        if i <\
    \ n then\n          if not min or table[i + 1][j] < min then\n            min\
    \ = table[i + 1][j]\n          end\n        end\n        if j > 1 then\n     \
    \     if not min or table[i][j - 1] < min then\n            min = table[i][j -\
    \ 1]\n          end\n        end\n        if j < n then\n          if not min\
    \ or table[i][j + 1] < min then\n            min = table[i][j + 1]\n         \
    \ end\n        end\n        if min and table[i][j] > min then\n          table[i][j]\
    \ = min\n        end\n      end\n    end\n  end\n  return table\nend", "  local\
    \ x, y = 1, 1\n  local visited = {}\n  local rst = {}\n  local function dfs(x,\
    \ y, k)\n    if k == 0 then\n      return true\n    end\n    visited[x] = visited[x]\
    \ or {}\n    visited[x][y] = true\n    local res = false\n    if x < #grid and\
    \ not visited[x + 1][y] then\n      table.insert(rst, grid[x + 1][y])\n      res\
    \ = dfs(x + 1, y, k - 1)\n      if res then\n        return true\n      end\n\
    \      table.remove(rst)\n    end\n    if y < #grid and not visited[x][y + 1]\
    \ then\n      table.insert(rst, grid[x][y + 1])\n      res = dfs(x, y + 1, k -\
    \ 1)\n      if res then\n        return true\n      end\n      table.remove(rst)\n\
    \    end\n    if x > 1 and not visited[x - 1][y] then\n      table.insert(rst,\
    \ grid[x - 1][y])\n      res = dfs(x - 1, y, k - 1)\n      if res then\n     \
    \   return true\n      end\n      table.remove(rst)\n    end\n    if y > 1 and\
    \ not visited[x][y - 1] then\n      table.insert(rst, grid[x][y - 1])\n      res\
    \ = dfs(x, y - 1, k - 1)\n      if res then\n        return true\n      end\n\
    \      table.remove(rst)\n    end\n    return false\n  end\n  table.insert(rst,\
    \ grid[x][y])\n  dfs(x, y, k)\n  return rst\nend", "  local minPaths = {}\n  local\
    \ function dfs(x, y, pathLen, pathVal)\n    if pathLen == k then\n      table.insert(minPaths,\
    \ pathVal)\n      return\n    end\n    local dirs = {{-1, 0}, {1, 0}, {0, -1},\
    \ {0, 1}}\n    for _, dir in ipairs(dirs) do\n      local nx, ny = x + dir[1],\
    \ y + dir[2]\n      if nx >= 1 and nx <= #grid and ny >= 1 and ny <= #grid then\n\
    \        dfs(nx, ny, pathLen + 1, pathVal * 10 + grid[nx][ny])\n      end\n  \
    \  end\n  end\n  for i = 1, #grid do\n    for j = 1, #grid do\n      dfs(i, j,\
    \ 1, grid[i][j])\n    end\n  end\n  table.sort(minPaths)\n  local ans = {}\n \
    \ for i = 1, k do\n    table.insert(ans, minPaths[1] % 10)\n    minPaths[1] =\
    \ math.floor(minPaths[1] / 10)\n  end\n  return ans\nend", "  local n = #grid\n\
    \  local seen = {}\n  local queue = { { x = 1, y = 1, k = 0, path = { grid[1][1]\
    \ } } }\n  local function ok(x, y)\n    return x >= 1 and x <= n and y >= 1 and\
    \ y <= n\n  end\n  local function visit(x, y, k, path)\n    if seen[x] == nil\
    \ then\n      seen[x] = {}\n    end\n    seen[x][y] = true\n    table.insert(queue,\
    \ { x = x, y = y, k = k, path = path })\n  end\n  local function addPath(t, x,\
    \ y, k, path)\n    if ok(x, y) and (seen[x] == nil or seen[x][y] == nil) then\n\
    \      visit(x, y, k, path)\n    end\n  end\n  while #queue > 0 do\n    local\
    \ v = table.remove(queue, 1)\n    if v.k == k then\n      return v.path\n    end\n\
    \    local path = {}\n    for i = 1, #v.path do\n      path[i] = v.path[i]\n \
    \   end\n    addPath(t, v.x - 1, v.y, v.k + 1, append(path, grid[v.x - 1][v.y]))\n\
    \    addPath(t, v.x + 1, v.y, v.k + 1, append(path, grid[v.x + 1][v.y]))\n   \
    \ addPath(t, v.x, v.y - 1, v.k + 1, append(path, grid[v.x][v.y - 1]))\n    addPath(t,\
    \ v.x, v.y + 1, v.k + 1, append(path, grid[v.x][v.y + 1]))\n  end\nend", "  if\
    \ #grid == 0 or #grid[1] == 0 then\n    return {}\n  end\n  if k < 1 then\n  \
    \  return {}\n  end\n  local m, n = #grid, #grid[1]\n  local vals = {}\n  for\
    \ i = 1, m do\n    vals[i] = {}\n    for j = 1, n do\n      table.insert(vals[i],\
    \ grid[i][j])\n    end\n  end\n  for _ = 1, k - 1 do\n    for i = 1, m do\n  \
    \    for j = 1, n do\n        local minval = math.huge\n        if i > 1 then\n\
    \          minval = math.min(minval, vals[i - 1][j])\n        end\n        if\
    \ i < m then\n          minval = math.min(minval, vals[i + 1][j])\n        end\n\
    \        if j > 1 then\n          minval = math.min(minval, vals[i][j - 1])\n\
    \        end\n        if j < n then\n          minval = math.min(minval, vals[i][j\
    \ + 1])\n        end\n        vals[i][j] = minval\n      end\n    end\n  end\n\
    \  local minval = math.huge\n  local mini, minj\n  for i = 1, m do\n    for j\
    \ = 1, n do\n      if vals[i][j] < minval then\n        minval = vals[i][j]\n\
    \        mini, minj = i, j\n      end\n    end\n  end\n  local path = {}\n  local\
    \ stack = {{grid[mini][minj], mini, minj}}\n  local visited = {}\n  for i = 1,\
    \ m do\n    visited[i] = {}\n    for j = 1, n do\n      visited[i][j] = false\n\
    \    end\n  end\n  visited[mini][minj] = true\n  while #stack > 0 do\n    local\
    \ val, i, j = table.unpack(stack[#stack])\n    table.remove(stack)\n    table.insert(path,\
    \ val)\n    if #path == k then\n      break\n    end", "  local points = { {i\
    \ = 1, j = 1} }\n  local target = {i = #grid, j = #grid[1]}\n  local point = points[1]\n\
    \  local steps = 0\n  local result = {}\n  while #points > 0 do\n    local i,\
    \ j = point.i, point.j\n    if i == target.i and j == target.j then\n      steps\
    \ = steps + 1\n      if steps == k then\n        for _, point in ipairs(points)\
    \ do\n          table.insert(result, grid[point.i][point.j])\n        end\n  \
    \      return result\n      end\n    end\n    local next = {}\n    if i > 1 then\n\
    \      table.insert(next, {i = i - 1, j = j})\n    end\n    if i < #grid then\n\
    \      table.insert(next, {i = i + 1, j = j})\n    end\n    if j > 1 then\n  \
    \    table.insert(next, {i = i, j = j - 1})\n    end\n    if j < #grid[1] then\n\
    \      table.insert(next, {i = i, j = j + 1})\n    end\n    local newPoints =\
    \ {}\n    for _, p in ipairs(next) do\n      local k = 1\n      for _, q in ipairs(points)\
    \ do\n        if p.i == q.i and p.j == q.j then\n          k = 0\n          break\n\
    \        end\n      end\n      if k == 1 then\n        table.insert(newPoints,\
    \ p)\n      end\n    end\n    if #newPoints == 0 then\n      table.remove(points,\
    \ 1)\n      point = points[1]\n    else\n      local m = 1\n      for l = 2, #newPoints\
    \ do\n        if grid[newPoints[l].i][newPoints[l].j] < grid[newPoints[m].i][newPoints[m].j]\
    \ then\n          m = l\n        end\n      end\n      table.insert(points, 1,\
    \ newPoints[m])\n      point = newPoints[m]\n    end\n  end\nend", "  local N\
    \ = #grid\n  local sx, sy = 1, 1\n  local visited = {}\n  local function dfs(x,\
    \ y, steps, curr)\n    if steps < 0 then return false end\n    local val = grid[x][y]\n\
    \    if visited[val] then return false end\n    visited[val] = true\n    table.insert(curr,\
    \ val)\n    if steps == 0 then return true end\n    if x > 1 and dfs(x - 1, y,\
    \ steps - 1, curr) then return true end\n    if x < N and dfs(x + 1, y, steps\
    \ - 1, curr) then return true end\n    if y > 1 and dfs(x, y - 1, steps - 1, curr)\
    \ then return true end\n    if y < N and dfs(x, y + 1, steps - 1, curr) then return\
    \ true end\n    table.remove(curr)\n    visited[val] = nil\n    return false\n\
    \  end\n  local curr = {}\n  dfs(sx, sy, k, curr)\n  return curr\nend", "    --\
    \ Write your code here\nend", "    local N = #grid\n    local path = {}\n    local\
    \ min = nil\n    local minVals = {}\n    local function dfs(path, row, col, k)\n\
    \        table.insert(path, grid[row][col])\n        if k == 1 then\n        \
    \    if min == nil or min > path[#path] then\n                min = path[#path]\n\
    \                minVals = table.copy(path)\n            end\n        else\n \
    \           if row > 1 then\n                dfs(path, row - 1, col, k - 1)\n\
    \            end\n            if row < N then\n                dfs(path, row +\
    \ 1, col, k - 1)\n            end\n            if col > 1 then\n             \
    \   dfs(path, row, col - 1, k - 1)\n            end\n            if col < N then\n\
    \                dfs(path, row, col + 1, k - 1)\n            end\n        end\n\
    \        table.remove(path)\n    end\n    for i = 1, N do\n        for j = 1,\
    \ N do\n            dfs(path, i, j, k)\n        end\n    end\n    return minVals\n\
    end", end, "    local size = #grid\n    local visited = { }\n    local min = {\
    \ }\n    local min_path = { }\n    local function dfs(row, col, k, path)\n   \
    \     if k < 0 then\n            return\n        end\n        path[#path + 1]\
    \ = grid[row][col]\n        if k == 0 then\n            local key = table.concat(path,\
    \ \",\")\n            if not visited[key] then\n                visited[key] =\
    \ true\n                local cur = table.concat(path)\n                if #min\
    \ == 0 or cur < min then\n                    min = cur\n                    min_path\
    \ = copy(path)\n                end\n            end\n            return\n   \
    \     end\n        if row > 1 then\n            dfs(row - 1, col, k - 1, path)\n\
    \        end\n        if row < size then\n            dfs(row + 1, col, k - 1,\
    \ path)\n        end\n        if col > 1 then\n            dfs(row, col - 1, k\
    \ - 1, path)\n        end\n        if col < size then\n            dfs(row, col\
    \ + 1, k - 1, path)\n        end\n        path[#path] = nil\n    end\n    local\
    \ path = { }\n    for row = 1, size do\n        for col = 1, size do\n       \
    \     dfs(row, col, k, path)\n        end\n    end\n    return min_path\nend",
  "    local N = #grid\n    local res = {}\n    local function cmp(v1, v2)\n     \
    \   if v1[1] < v2[1] then\n            return true\n        elseif v1[1] > v2[1]\
    \ then\n            return false\n        else\n            return v1[2] < v2[2]\n\
    \        end\n    end\n    local heap = {{1, 1, grid[1][1]}}\n    local seen =\
    \ {}\n    while #heap > 0 do\n        table.sort(heap, cmp)\n        local n,\
    \ x, y, acc = table.unpack(table.remove(heap, 1))\n        if seen[x] == nil then\n\
    \            seen[x] = {}\n        end\n        if n == k then\n            if\
    \ seen[x][y] == nil or seen[x][y] > acc then\n                seen[x][y] = acc\n\
    \                res = {grid[x][y]}\n            elseif seen[x][y] == acc then\n\
    \                table.insert(res, grid[x][y])\n            end\n        else\n\
    \            if seen[x][y] == nil or seen[x][y] > acc then\n                seen[x][y]\
    \ = acc\n                if x > 1 then\n                    table.insert(heap,\
    \ {n + 1, x - 1, y, acc + grid[x - 1][y]})\n                end\n            \
    \    if x < N then\n                    table.insert(heap, {n + 1, x + 1, y, acc\
    \ + grid[x + 1][y]})\n                end\n                if y > 1 then\n   \
    \                 table.insert(heap, {n + 1, x, y - 1, acc + grid[x][y - 1]})\n\
    \                end\n                if y < N then\n                    table.insert(heap,\
    \ {n + 1, x, y + 1, acc + grid[x][y + 1]})\n                end\n            end\n\
    \        end\n    end\n    return res\nend", "  local ans, m, n = {}, #grid, #grid[1]\n\
    \  local function dfs(r, c, p)\n    if r < 1 or r > m or c < 1 or c > n or k <\
    \ p then return end\n    table.insert(ans, grid[r][c])\n    if p == k then return\
    \ end\n    dfs(r - 1, c, p + 1)\n    dfs(r + 1, c, p + 1)\n    dfs(r, c - 1, p\
    \ + 1)\n    dfs(r, c + 1, p + 1)\n    table.remove(ans)\n  end\n  for i = 1, m\
    \ do\n    for j = 1, n do\n      dfs(i, j, 1)\n    end\n  end\n  return ans\n\
    end", "    -- TODO\nend", "  if not grid then return {} end\n  local r, c = #grid,\
    \ #grid[1]\n  if k == 1 then\n    local v, mv = math.huge, math.huge\n    for\
    \ i = 1, r do\n      for j = 1, c do\n        if grid[i][j] < mv then\n      \
    \    mv = grid[i][j]\n          v = {[1] = mv}\n        end\n      end\n    end\n\
    \    return v\n  end\n  local d, dp = {}, {}\n  for i = 1, r do\n    for j = 1,\
    \ c do\n      local v = grid[i][j]\n      if not d[v] then d[v] = {} end\n   \
    \   d[v][#d[v] + 1] = {i, j}\n    end\n  end\n  local function dfs(n, v, t)\n\
    \    if n == k then\n      local tv = ''\n      for _, p in ipairs(t) do\n   \
    \     tv = tv .. grid[p[1]][p[2]]\n      end\n      if not dp[tv] then dp[tv]\
    \ = t end\n      return\n    end\n    local ps = d[v]\n    for _, p in ipairs(ps)\
    \ do\n      local nt = {}\n      for _, i in ipairs(t) do nt[#nt + 1] = i end\n\
    \      nt[#nt + 1] = p\n      for _, q in ipairs(ps) do\n        if q[1] == p[1]\
    \ and math.abs(q[2] - p[2]) == 1 then\n          dfs(n + 1, grid[q[1]][q[2]],\
    \ nt)\n        elseif q[2] == p[2] and math.abs(q[1] - p[1]) == 1 then\n     \
    \     dfs(n + 1, grid[q[1]][q[2]], nt)\n        end\n      end\n    end\n  end\n\
    \  local t = {}\n  for i = 1, k do\n    t[i] = {math.huge, 1, 1}\n  end", "  if\
    \ k <= 0 then\n    return nil\n  end\n  local m = #grid\n  local n = #grid[1]\n\
    \  local function getKey(row, col)\n    return row * m + col\n  end\n  local function\
    \ getMin(row, col)\n    local key = getKey(row, col)\n    local visited = { [key]\
    \ = true }\n    local function helper(row, col, k, curr)\n      if k == 0 then\n\
    \        return curr\n      end\n      local min = math.huge\n      local list\
    \ = {}\n      local function update(row, col, value)\n        local key = getKey(row,\
    \ col)\n        if not visited[key] then\n          min = math.min(min, value)\n\
    \          list[#list + 1] = { row, col, value }\n        end\n      end\n   \
    \   if row > 1 then\n        update(row - 1, col, grid[row - 1][col])\n      end\n\
    \      if row < m then\n        update(row + 1, col, grid[row + 1][col])\n   \
    \   end\n      if col > 1 then\n        update(row, col - 1, grid[row][col - 1])\n\
    \      end\n      if col < n then\n        update(row, col + 1, grid[row][col\
    \ + 1])\n      end\n      if min ~= math.huge then\n        table.sort(list, function(a,\
    \ b)\n          return a[3] < b[3]\n        end)\n        for _, v in ipairs(list)\
    \ do\n          local key = getKey(v[1], v[2])\n          visited[key] = true\n\
    \          local tmp = helper(v[1], v[2], k - 1, curr .. ',' .. tostring(v[3]))\n\
    \          if tmp ~= math.huge then\n            return tmp\n          end\n \
    \         visited[key] = nil\n        end\n      end\n      return math.huge\n\
    \    end\n    return helper(row, col, k, tostring(grid[row][col]))\n  end\n  local\
    \ min = math.huge\n  local result = nil\n  for i = 1, m do\n    for", "  error(\"\
    Not implemented yet.\")\nend", "    local n = #grid\n    local visited = {}\n\
    \    local function dfs(x, y, K, path)\n        if visited[x] == nil then\n  \
    \          visited[x] = {}\n        end\n        if visited[x][y] then\n     \
    \       return\n        end\n        visited[x][y] = true\n        path[#path\
    \ + 1] = grid[x][y]\n        if K == 1 then\n            return\n        end\n\
    \        if x > 1 then\n            dfs(x - 1, y, K - 1, path)\n        end\n\
    \        if x < n then\n            dfs(x + 1, y, K - 1, path)\n        end\n\
    \        if y > 1 then\n            dfs(x, y - 1, K - 1, path)\n        end\n\
    \        if y < n then\n            dfs(x, y + 1, K - 1, path)\n        end\n\
    \        path[#path] = nil\n        visited[x][y] = false\n    end\n    local\
    \ path = {}\n    for i = 1, n do\n        for j = 1, n do\n            dfs(i,\
    \ j, k, path)\n        end\n    end\n    local p = path\n    local function compare(a,\
    \ b)\n        local n = #a\n        for i = 1, n do\n            if a[i] < b[i]\
    \ then\n                return true\n            elseif a[i] > b[i] then\n   \
    \             return false\n            end\n        end\n        return false\n\
    \    end\n    table.sort(p, compare)\n    return p[1]\nend", "    local visited\
    \ = {}\n    local function dfs(i, j, k, cur, res)\n        if i < 1 or i > #grid\
    \ or j < 1 or j > #grid or k <= 0 or visited[i] and visited[i][j] then\n     \
    \       return\n        end\n        if k == 1 then\n            if not res then\n\
    \                res = {}\n                for _, v in ipairs(cur) do\n      \
    \              table.insert(res, v)\n                end\n            else\n \
    \               for i = 1, #cur do\n                    if cur[i] < res[i] then\n\
    \                        res = cur\n                        break\n          \
    \          elseif cur[i] > res[i] then\n                        break\n      \
    \              end\n                end\n            end\n            return res\n\
    \        end\n        if not visited[i] then\n            visited[i] = {}\n  \
    \      end\n        visited[i][j] = true\n        table.insert(cur, grid[i][j])\n\
    \        dfs(i + 1, j, k - 1, cur, res)\n        dfs(i - 1, j, k - 1, cur, res)\n\
    \        dfs(i, j + 1, k - 1, cur, res)\n        dfs(i, j - 1, k - 1, cur, res)\n\
    \        table.remove(cur)\n        visited[i][j] = false\n        return res\n\
    \    end\n    local res\n    for i = 1, #grid do\n        for j = 1, #grid do\n\
    \            res = dfs(i, j, k, {}, res)\n        end\n    end\n    return res\n\
    end", "  local n = #grid\n  if k < 1 or k > n * n then\n    return nil\n  end\n\
    \  local paths = { { } }\n  local maps = { { grid[1][1] } }\n  for i = 1, k do\n\
    \    local newPaths = { }\n    local newMaps = { }\n    for _, path in ipairs(paths)\
    \ do\n      local last = path[#path]\n      local map = maps[#path]\n      local\
    \ row = math.floor((last - 1) / n) + 1\n      local col = (last - 1) % n + 1\n\
    \      if row > 1 and not map[last - n] then\n        newPaths[#newPaths + 1]\
    \ = { unpack(path) }\n        newPaths[#newPaths][#newPaths[#newPaths] + 1] =\
    \ last - n\n        newMaps[#newMaps + 1] = { unpack(map) }\n        newMaps[#newMaps][last\
    \ - n] = true\n      end\n      if row < n and not map[last + n] then\n      \
    \  newPaths[#newPaths + 1] = { unpack(path) }\n        newPaths[#newPaths][#newPaths[#newPaths]\
    \ + 1] = last + n\n        newMaps[#newMaps + 1] = { unpack(map) }\n        newMaps[#newMaps][last\
    \ + n] = true\n      end\n      if col > 1 and not map[last - 1] then\n      \
    \  newPaths[#newPaths + 1] = { unpack(path) }\n        newPaths[#newPaths][#newPaths[#newPaths]\
    \ + 1] = last - 1\n        newMaps[#newMaps + 1] = { unpack(map) }\n        newMaps[#newMaps][last\
    \ - 1] = true\n      end\n      if col < n and not map[last + 1] then\n      \
    \  newPaths[#newPaths + 1] = { unpack(path) }\n        newPaths[#newPaths][#newPaths[#newPaths]\
    \ + 1] = last + 1\n       ", "  error(\"Not implemented yet\")\nend", "    return\
    \ {}\nend", "    local n = #grid\n    local function isInBound(x, y)\n       \
    \ return (x >= 1 and x <= n and y >= 1 and y <= n)\n    end\n    local function\
    \ getNeighbor(x, y)\n        local res = {}\n        for _, v in ipairs({{-1,\
    \ 0}, {1, 0}, {0, -1}, {0, 1}}) do\n            local next_x, next_y = x + v[1],\
    \ y + v[2]\n            if isInBound(next_x, next_y) then\n                table.insert(res,\
    \ {next_x, next_y})\n            end\n        end\n        return res\n    end\n\
    \    local paths = {{grid[1][1], {{1, 1}}}}\n    local visited = {}\n    for i\
    \ = 1, k - 1 do\n        local new_paths = {}\n        for _, path in ipairs(paths)\
    \ do\n            local nb = getNeighbor(path[2][#path[2]][1], path[2][#path[2]][2])\n\
    \            for _, n in ipairs(nb) do\n                local new_path = {path[1]\
    \ .. grid[n[1]][n[2]], {unpack(path[2])}}\n                table.insert(new_path[2],\
    \ n)\n                table.insert(new_paths, new_path)\n            end\n   \
    \     end\n        paths = new_paths\n    end\n    local min_path = paths[1]\n\
    \    for _, path in ipairs(paths) do\n        if path[1] < min_path[1] then\n\
    \            min_path = path\n        end\n    end\n    local res = {}\n    for\
    \ _, pos in ipairs(min_path[2]) do\n        table.insert(res, grid[pos[1]][pos[2]])\n\
    \    end\n    return res\nend", "  if not grid or #grid == 0 or #grid[1] == 0\
    \ then\n    return nil\n  end\n  local m, n = #grid, #grid[1]\n  local min_path\
    \ = {}\n  for i = 1, m do\n    for j = 1, n do\n      if grid[i][j] == 1 then\n\
    \        local old_path = {1}\n        local new_path = {}\n        for step =\
    \ 2, k do\n          if i > 1 and grid[i - 1][j] == step then\n            new_path\
    \ = {step}\n            for _, val in ipairs(old_path) do\n              table.insert(new_path,\
    \ val)\n            end\n          elseif j > 1 and grid[i][j - 1] == step then\n\
    \            new_path = {step}\n            for _, val in ipairs(old_path) do\n\
    \              table.insert(new_path, val)\n            end\n          elseif\
    \ i < m and grid[i + 1][j] == step then\n            new_path = {step}\n     \
    \       for _, val in ipairs(old_path) do\n              table.insert(new_path,\
    \ val)\n            end\n          elseif j < n and grid[i][j + 1] == step then\n\
    \            new_path = {step}\n            for _, val in ipairs(old_path) do\n\
    \              table.insert(new_path, val)\n            end\n          end\n \
    \         old_path = new_path\n        end\n        if #min_path == 0 or new_path[1]\
    \ < min_path[1] then\n          min_path = new_path\n        end\n      end\n\
    \    end\n  end\n  return min_path\nend", "    local n = #grid\n    local h =\
    \ {}\n    for i = 1, n do\n        for j = 1, n do\n            h[grid[i][j]]\
    \ = {i, j}\n        end\n    end\n    local dp = {}\n    for i = 1, n do\n   \
    \     dp[i] = {}\n        for j = 1, n do\n            dp[i][j] = {[0] = {}}\n\
    \        end\n    end\n    for i = 1, n * n do\n        local ii, jj = h[i][1],\
    \ h[i][2]\n        local paths = dp[ii][jj]\n        local dirs = {{-1, 0}, {1,\
    \ 0}, {0, -1}, {0, 1}}\n        for _, dir in ipairs(dirs) do\n            local\
    \ x, y = ii + dir[1], jj + dir[2]\n            if x >= 1 and x <= n and y >= 1\
    \ and y <= n then\n                local last = dp[x][y][i - 1]\n            \
    \    if last then\n                    for _, path in ipairs(last) do\n      \
    \                  local np = {}\n                        for _, v in ipairs(path)\
    \ do\n                            np[#np + 1] = v\n                        end\n\
    \                        np[#np + 1] = i\n                        if #np == k\
    \ then\n                            return np\n                        end\n \
    \                       paths[#np] = paths[#np] or {}\n                      \
    \  paths[#np][#paths[#np] + 1] = np\n                    end\n               \
    \ end\n            end\n        end\n    end\n    return {}\nend", "    local\
    \ n = #grid\n    local dist = {}\n    for i = 1, n do\n        dist[i] = {}\n\
    \        for j = 1, n do\n            dist[i][j] = 1000000000\n        end\n \
    \   end\n    dist[1][1] = 0\n    local min_cell = {}\n    for i = 1, n do\n  \
    \      min_cell[i] = {}\n        for j = 1, n do\n            min_cell[i][j] =\
    \ { grid[i][j], i, j }\n        end\n    end\n    for i = 1, n do\n        for\
    \ j = 1, n do\n            local x = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1\
    \ } }\n            for _, v in ipairs(x) do\n                local ii = i + v[1]\n\
    \                local jj = j + v[2]\n                if ii >= 1 and ii <= n and\
    \ jj >= 1 and jj <= n then\n                    if min_cell[ii][jj][1] < min_cell[i][j][1]\
    \ then\n                        min_cell[i][j] = min_cell[ii][jj]\n          \
    \          end\n                end\n            end\n        end\n    end\n \
    \   for i = 1, n do\n        for j = 1, n do\n            local x = { { -1, 0\
    \ }, { 1, 0 }, { 0, -1 }, { 0, 1 } }\n            for _, v in ipairs(x) do\n \
    \               local ii = i + v[1]\n                local jj = j + v[2]\n   \
    \             if ii >= 1 and ii <= n and jj >= 1 and jj <= n then\n          \
    \          local cost = 1\n                    if min_cell[ii][jj][1] == min_cell[i][j][1]\
    \ then\n                        cost = 0\n                    end\n          \
    \          dist[ii][jj] = math.min(dist[ii][jj], dist[i][j] + cost)\n        \
    \        end\n            end\n        end\n    end\n    local min_dist = 1000000000\n\
    \    local min_i = 0\n    local min_j = 0\n    for i = 1, n do\n       ", "  \
    \  local n = #grid\n    local function dfs(i, j, cnt, lst)\n        cnt = cnt\
    \ + 1\n        table.insert(lst, grid[i][j])\n        if cnt == k then\n     \
    \       return lst\n        end\n        local next = { {i - 1, j}, {i + 1, j},\
    \ {i, j - 1}, {i, j + 1} }\n        local res = { {-1, -1, -1}, {-1, -1, -1},\
    \ {-1, -1, -1}, {-1, -1, -1} }\n        for m = 1, 4 do\n            local x,\
    \ y = next[m][1], next[m][2]\n            if x >= 1 and x <= n and y >= 1 and\
    \ y <= n then\n                local lst_x = dfs(x, y, cnt, table.clone(lst))\n\
    \                if lst_x then\n                    res[m] = {x, y, lst_x}\n \
    \               end\n            end\n        end\n        local best = {}\n \
    \       for m = 1, 4 do\n            if res[m][1] ~= -1 then\n               \
    \ if #best == 0 then\n                    best = res[m]\n                else\n\
    \                    for q = 1, k do\n                        if res[m][3][q]\
    \ < best[3][q] then\n                            best = res[m]\n             \
    \               break\n                        elseif res[m][3][q] > best[3][q]\
    \ then\n                            break\n                        end\n     \
    \               end\n                end\n            end\n        end\n     \
    \   if #best == 0 then\n            return nil\n        else\n            return\
    \ best[3]\n        end\n    end\n    local res\n    for i = 1, n do\n        for\
    \ j = 1, n do\n            local lst = dfs(i, j, 0, {})\n            if lst then\n\
    \                if not res then\n                    res = lst\n            \
    \    else\n                    for q = 1, k do\n                        if lst[q]\
    \ < res[q] then\n                            res = lst\n                     \
    \       break\n                        elseif lst[q] >", "    if k <= 0 then\n\
    \        return {}\n    end\n    local n = #grid\n    local queue = {}\n    local\
    \ visited = {}\n    local seen = {}\n    local function cmp(list1, list2)\n  \
    \      for i = 1, #list1 do\n            if list1[i] < list2[i] then\n       \
    \         return -1\n            elseif list1[i] > list2[i] then\n           \
    \     return 1\n            end\n        end\n        return 0\n    end\n    local\
    \ function getNeighbors(cell)\n        local x, y = cell[1], cell[2]\n       \
    \ local nbrs = {}\n        if x > 1 then\n            nbrs[#nbrs + 1] = {x - 1,\
    \ y}\n        end\n        if x < n then\n            nbrs[#nbrs + 1] = {x + 1,\
    \ y}\n        end\n        if y > 1 then\n            nbrs[#nbrs + 1] = {x, y\
    \ - 1}\n        end\n        if y < n then\n            nbrs[#nbrs + 1] = {x,\
    \ y + 1}\n        end\n        return nbrs\n    end\n    local function getKey(list)\n\
    \        local str = ''\n        for i = 1, #list do\n            str = str ..\
    \ tostring(list[i])\n        end\n        return str\n    end\n    local function\
    \ bfs(cell)\n        local list = {grid[cell[1]][cell[2]]}\n        queue[#queue\
    \ + 1] = cell\n        seen[#seen + 1] = cell\n        while #queue > 0 do\n \
    \           local curr = queue[1]\n            table.remove(queue, 1)\n      \
    \      local currKey = getKey(list)\n            if not visited[currKey] or cmp(list,\
    \ visited[currKey]) < 0 then\n                visited[currKey] = list\n      \
    \      end\n            if #list == k then\n                break\n          \
    \  end\n            local nbrs = getNeighbors(curr)\n            for i = 1, #nbrs\
    \ do\n                local nbr = nbrs[i]\n                local", "    local\
    \ rows, cols = #grid, #grid[1]\n    local path, map = {}, {}\n    local function\
    \ find(r, c, k)\n        if k == 0 then\n            return true\n        end\n\
    \        if r < 1 or r > rows or c < 1 or c > cols then\n            return false\n\
    \        end\n        if map[r * cols + c] then\n            return false\n  \
    \      end\n        map[r * cols + c] = true\n        table.insert(path, grid[r][c])\n\
    \        if find(r + 1, c, k - 1) then\n            return true\n        end\n\
    \        if find(r - 1, c, k - 1) then\n            return true\n        end\n\
    \        if find(r, c + 1, k - 1) then\n            return true\n        end\n\
    \        if find(r, c - 1, k - 1) then\n            return true\n        end\n\
    \        table.remove(path)\n        map[r * cols + c] = false\n        return\
    \ false\n    end\n    for r = 1, rows do\n        for c = 1, cols do\n       \
    \     if find(r, c, k) then\n                return path\n            end\n  \
    \      end\n    end\nend", "  local n = #grid\n  if k == 1 then\n    return {\
    \ grid[1][1] }\n  end\n  local g = {}\n  for r = 1, n do\n    for c = 1, n do\n\
    \      g[grid[r][c]] = { r = r, c = c }\n    end\n  end\n  local function minDst(a,\
    \ b)\n    local r1, c1 = a.r, a.c\n    local r2, c2 = b.r, b.c\n    return math.abs(r1\
    \ - r2) + math.abs(c1 - c2)\n  end\n  local function dist(p)\n    local d = 0\n\
    \    for i = 1, #p - 1 do\n      d = d + minDst(g[p[i]], g[p[i + 1]])\n    end\n\
    \    return d\n  end\n  local function nextPerm(p)\n    local n = #p\n    local\
    \ i = n - 1\n    while i > 0 and p[i] > p[i + 1] do\n      i = i - 1\n    end\n\
    \    if i == 0 then\n      return nil\n    end\n    local j = n\n    while p[j]\
    \ < p[i] do\n      j = j - 1\n    end\n    p[i], p[j] = p[j], p[i]\n    for l\
    \ = 1, (n - i) / 2 do\n      p[i + l], p[n - l + 1] = p[n - l + 1], p[i + l]\n\
    \    end\n    return p\n  end\n  local function minPath(k)\n    local path = {}\n\
    \    for i = 1, k do\n      path[i] = i\n    end\n    local min = path\n    while\
    \ true do\n      local p = nextPerm(path)\n      if not p then\n        break\n\
    \      end\n      if dist(p) < dist(min) then\n        min = p\n      end\n  \
    \  end\n    return min\n  end\n  return minPath(k)\nend", "  local n = #grid\n\
    \  local function check(x, y, k)\n    if k == 0 then\n      return true\n    end\n\
    \    if x < 1 or x > n or y < 1 or y > n then\n      return false\n    end\n \
    \   return (grid[x - 1][y] > grid[x][y] and check(x - 1, y, k - 1)) or\n     \
    \      (grid[x + 1][y] > grid[x][y] and check(x + 1, y, k - 1)) or\n         \
    \  (grid[x][y - 1] > grid[x][y] and check(x, y - 1, k - 1)) or\n           (grid[x][y\
    \ + 1] > grid[x][y] and check(x, y + 1, k - 1))\n  end\n  local function minPath(x,\
    \ y, k)\n    if k == 0 then\n      return {grid[x][y]}\n    end\n    local result\n\
    \    if grid[x - 1][y] > grid[x][y] and check(x - 1, y, k - 1) then\n      local\
    \ tmp = minPath(x - 1, y, k - 1)\n      tmp[#tmp + 1] = grid[x][y]\n      if not\
    \ result or tmp < result then\n        result = tmp\n      end\n    end\n    if\
    \ grid[x + 1][y] > grid[x][y] and check(x + 1, y, k - 1) then\n      local tmp\
    \ = minPath(x + 1, y, k - 1)\n      tmp[#tmp + 1] = grid[x][y]\n      if not result\
    \ or tmp < result then\n        result = tmp\n      end\n    end\n    if grid[x][y\
    \ - 1] > grid[x][y] and check(x, y - 1, k - 1) then\n      local tmp = minPath(x,\
    \ y - 1, k - 1)\n      tmp[#tmp + 1] = grid[x][y]\n      if not result or tmp\
    \ < result then\n        result = tmp\n      end\n    end\n    if grid[x][y +\
    \ 1] > grid[x][y] and check(x, y", "    local N = #grid\n    local function idx(i,\
    \ j)\n        return (i - 1) * N + j\n    end\n    local function val(i, j)\n\
    \        return grid[i][j]\n    end\n    local spq = priority_queue.new()\n  \
    \  local dp = {}\n    for i = 1, N do\n        for j = 1, N do\n            spq:push(idx(i,\
    \ j), val(i, j))\n            dp[idx(i, j)] = {val(i, j)}\n        end\n    end\n\
    \    while k > 1 do\n        local u = spq:pop()\n        local x, y = ((u - 1)\
    \ % N) + 1, math.floor((u - 1) / N) + 1\n        if x > 1 then\n            local\
    \ v = idx(x - 1, y)\n            if not spq:visited(v) then\n                local\
    \ candidate = {table.unpack(dp[u])}\n                table.insert(candidate, 1,\
    \ val(x - 1, y))\n                if not spq:visited(v) or table.concat(candidate)\
    \ < table.concat(dp[v]) then\n                    dp[v] = candidate\n        \
    \            spq:push(v, val(x - 1, y))\n                end\n            end\n\
    \        end\n        if x < N then\n            local v = idx(x + 1, y)\n   \
    \         if not spq:visited(v) then\n                local candidate = {table.unpack(dp[u])}\n\
    \                table.insert(candidate, 1, val(x + 1, y))\n                if\
    \ not spq:visited(v) or table.concat(candidate) < table.concat(dp[v]) then\n \
    \                   dp[v] = candidate\n                    spq:push(v, val(x +\
    \ 1, y))\n                end\n            end\n        end\n        if y > 1\
    \ then\n            local v = idx(x, y - 1)\n            if not spq:visited(v)\
    \ then\n                local candidate = {table.unpack(dp[u])}\n            \
    \    table.", "  local n = #grid\n  local v = {}\n  for i = 1, n do\n    v[i]\
    \ = {}\n    for j = 1, n do\n      v[i][j] = true\n    end\n  end\n  local function\
    \ dfs(x, y, l, res)\n    if x < 1 or x > n or y < 1 or y > n or not v[x][y] then\n\
    \      return false\n    end\n    v[x][y] = false\n    res[#res + 1] = grid[x][y]\n\
    \    if l == 1 then\n      return true\n    end\n    local ok = dfs(x - 1, y,\
    \ l - 1, res) or dfs(x + 1, y, l - 1, res) or\n               dfs(x, y - 1, l\
    \ - 1, res) or dfs(x, y + 1, l - 1, res)\n    if not ok then\n      table.remove(res)\n\
    \    end\n    v[x][y] = true\n    return ok\n  end\n  local res\n  for i = 1,\
    \ n do\n    for j = 1, n do\n      local tmp = {}\n      if dfs(i, j, k, tmp)\
    \ then\n        if not res or res > tmp then\n          res = tmp\n        end\n\
    \      end\n    end\n  end\n  return res\nend", "    return {}\nend", "  local\
    \ N = #grid\n  local function cmp(a, b)\n    for i = 1, N do\n      for j = 1,\
    \ N do\n        if a[i][j] < b[i][j] then\n          return true\n        elseif\
    \ a[i][j] > b[i][j] then\n          return false\n        end\n      end\n   \
    \ end\n    return false\n  end\n  local function next(s)\n    local ans = {}\n\
    \    for i = 1, N do\n      ans[i] = {}\n      for j = 1, N do\n        ans[i][j]\
    \ = s[i][j]\n      end\n    end\n    local x, y = ans[1][1], ans[1][2]\n    ans[1][1],\
    \ ans[1][2] = ans[1][2], ans[1][1]\n    return ans, x, y\n  end\n  local function\
    \ left(s)\n    local ans = {}\n    for i = 1, N do\n      ans[i] = {}\n      for\
    \ j = 1, N do\n        ans[i][j] = s[i][j]\n      end\n    end\n    local x, y\
    \ = ans[1][1], ans[1][2]\n    for i = 1, N do\n      for j = 1, N - 1 do\n   \
    \     ans[i][j] = ans[i][j + 1]\n      end\n    end\n    ans[1][N] = x\n    return\
    \ ans, x, y\n  end\n  local function right(s)\n    local ans = {}\n    for i =\
    \ 1, N do\n      ans[i] = {}\n      for j = 1, N do\n        ans[i][j] = s[i][j]\n\
    \      end\n    end\n    local x, y = ans[1][N], ans[1][N - 1]\n    for i = 1,\
    \ N do\n      for j = N, 2, -1 do\n        ans[i][j] = ans[i][j - 1]\n      end\n\
    \    end\n    ans[1][1] = x\n    return ans, x, y\n  end\n  local function up(s)",
  "    local n = #grid\n    local path = {}\n    local row = 1\n    local col = 1\n\
    \    local cnt = 0\n    local visited = {}\n    local min = {}\n    for i = 1,\
    \ n do\n        for j = 1, n do\n            visited[i] = visited[i] or {}\n \
    \           visited[i][j] = 0\n        end\n    end\n    local function dfs(row,\
    \ col, cnt)\n        if cnt == k then\n            local str = \"\"\n        \
    \    for i = 1, k do\n                str = str .. path[i]\n            end\n\
    \            min[str] = min[str] or path\n            return\n        end\n  \
    \      if row < 1 or row > n or col < 1 or col > n or visited[row][col] == 1 then\n\
    \            return\n        end\n        path[cnt + 1] = grid[row][col]\n   \
    \     visited[row][col] = 1\n        dfs(row - 1, col, cnt + 1)\n        dfs(row\
    \ + 1, col, cnt + 1)\n        dfs(row, col - 1, cnt + 1)\n        dfs(row, col\
    \ + 1, cnt + 1)\n        visited[row][col] = 0\n    end\n    dfs(row, col, cnt)\n\
    \    local str_min = \"9\"\n    for k, v in pairs(min) do\n        if k < str_min\
    \ then\n            str_min = k\n        end\n    end\n    return min[str_min]\n\
    end", "  local function less(lst_a, lst_b)\n    for i = 1, k do\n      if lst_a[i]\
    \ < lst_b[i] then\n        return true\n      elseif lst_a[i] > lst_b[i] then\n\
    \        return false\n      end\n    end\n    return false\n  end\n  local N\
    \ = #grid\n  local function neighbors(x, y)\n    local res = {}\n    if x > 1\
    \ then\n      res[#res + 1] = {x = x - 1, y = y}\n    end\n    if x < N then\n\
    \      res[#res + 1] = {x = x + 1, y = y}\n    end\n    if y > 1 then\n      res[#res\
    \ + 1] = {x = x, y = y - 1}\n    end\n    if y < N then\n      res[#res + 1] =\
    \ {x = x, y = y + 1}\n    end\n    return res\n  end\n  local function copy(t)\n\
    \    local res = {}\n    for i = 1, #t do\n      res[i] = t[i]\n    end\n    return\
    \ res\n  end\n  local function dfs(x, y, lst, cur_len)\n    if cur_len == k then\n\
    \      if less(lst, res) then\n        res = copy(lst)\n      end\n      return\n\
    \    end\n    local cur_num = grid[x][y]\n    lst[#lst + 1] = cur_num\n    for\
    \ _, p in ipairs(neighbors(x, y)) do\n      dfs(p.x, p.y, lst, cur_len + 1)\n\
    \    end\n    lst[#lst] = nil\n  end\n  local res = {}\n  for i = 1, k do\n  \
    \  res[i] = math.huge\n  end\n  for i = 1, N do\n    for j = 1, N do\n      dfs(i,\
    \ j, {}, 1)\n    end\n  end\n  return res\nend", "    local N = #grid\n    local\
    \ heap = {}\n    local key = {}\n    local value = {}\n    local start = {[1]\
    \ = 1, [2] = 1}\n    local count = 0\n    local dirs = {{-1, 0}, {1, 0}, {0, -1},\
    \ {0, 1}}\n    local function push(p, cnt, val)\n        count = count + 1\n \
    \       value[count] = val\n        local k = count\n        heap[k] = p\n   \
    \     key[p[1] * N + p[2]] = k\n        while k > 1 do\n            local parent\
    \ = math.floor(k / 2)\n            if cnt >= value[parent] then\n            \
    \    break\n            end\n            heap[k] = heap[parent]\n            key[heap[k][1]\
    \ * N + heap[k][2]] = k\n            heap[parent] = p\n            key[p[1] *\
    \ N + p[2]] = parent\n            value[k] = value[parent]\n            value[parent]\
    \ = cnt\n            k = parent\n        end\n    end\n    local function pop()\n\
    \        local p = heap[1]\n        local val = value[1]\n        key[p[1] * N\
    \ + p[2]] = nil\n        heap[1] = heap[count]\n        key[heap[1][1] * N + heap[1][2]]\
    \ = 1\n        heap[count] = nil\n        value[1] = value[count]\n        value[count]\
    \ = nil\n        count = count - 1\n        local k = 1\n        while k * 2 <=\
    \ count do\n            local c = k * 2\n            if c + 1 <= count and value[c\
    \ + 1] < value[c] then\n                c = c + 1\n            end\n         \
    \   if value[k] <= value[c] then\n                break\n            end\n   \
    \         heap[k], heap[c] = heap[c], heap[k]\n            key[heap[k][1] * N\
    \ + heap[k][2]] = k\n            key[heap[c][1] * N + heap[c][2]] = c\n      \
    \      value[k],"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
