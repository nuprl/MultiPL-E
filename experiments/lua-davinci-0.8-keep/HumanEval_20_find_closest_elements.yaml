name: HumanEval_20_find_closest_elements
language: lua
prompt: "-- From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n-- other and return them in order (smaller number,\
  \ larger number).\n-- >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
  -- (2.0, 2.2)\n-- >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n--\
  \ (2.0, 2.0)\nlocal function find_closest_elements(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_closest_elements\n\
  \    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), {3.9, 4.0})\n  \
  \  lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}), {5.0, 5.9})\n    lu.assertEquals(candidate({1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2}), {2.0, 2.2})\n    lu.assertEquals(candidate({1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.0}), {2.0, 2.0})\n    lu.assertEquals(candidate({1.1, 2.2, 3.1,\
  \ 4.1, 5.1}), {2.2, 3.1})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal min = math.huge\n\tlocal one, two = nil, nil\n\tlocal n = #numbers\n\
    \tfor i = 1, n - 1 do\n\t\tfor j = i + 1, n do\n\t\t\tlocal diff = math.abs(numbers[i]\
    \ - numbers[j])\n\t\t\tif diff < min then\n\t\t\t\tmin = diff\n\t\t\t\tone, two\
    \ = numbers[i], numbers[j]\n\t\t\tend\n\t\tend\n\tend\n\tif min == math.huge then\n\
    \t\treturn nil, nil\n\tend\n\treturn one, two\nend", "\tassert(#numbers >= 2,\
    \ \"Length of array must be at least 2.\")\n\tlocal closest = {numbers[1], numbers[2]}\n\
    \tfor i = 1, #numbers - 1 do\n\t\tfor j = i + 1, #numbers do\n\t\t\tif math.abs(numbers[i]\
    \ - numbers[j]) < math.abs(closest[1] - closest[2]) then\n\t\t\t\tclosest = {numbers[i],\
    \ numbers[j]}\n\t\t\tend\n\t\tend\n\tend\n\treturn closest[1], closest[2]\nend",
  "  local prev = numbers[1]\n  local min_delta = math.huge\n  local result = {}\n\
    \  for i = 2, #numbers do\n    local delta = math.abs(numbers[i] - prev)\n   \
    \ if delta < min_delta then\n      min_delta = delta\n      result = {prev, numbers[i]}\n\
    \    end\n    prev = numbers[i]\n  end\n  return result[1], result[2]\nend", " \
    \ local numbers_count = #numbers\n  local number_1, number_2\n  local best_difference\
    \ = math.huge\n  for i = 1, numbers_count do\n    for j = i + 1, numbers_count\
    \ do\n      local difference = math.abs(numbers[i] - numbers[j])\n      if difference\
    \ < best_difference then\n        best_difference = difference\n        number_1\
    \ = numbers[i]\n        number_2 = numbers[j]\n      end\n    end\n  end\n  return\
    \ number_1, number_2\nend", "    local best_values = {numbers[1], numbers[2]}\n\
    \    local best_delta = math.abs(numbers[1] - numbers[2])\n    for i = 1, #numbers\
    \ do\n        for j = i + 1, #numbers do\n            local delta = math.abs(numbers[i]\
    \ - numbers[j])\n            if delta < best_delta then\n                best_delta\
    \ = delta\n                best_values = {numbers[i], numbers[j]}\n          \
    \  end\n        end\n    end\n    return best_values[1], best_values[2]\nend",
  "\tlocal min_dist = math.huge\n\tlocal closest_pairs = {nil, nil}\n\t\n\ttable.sort(numbers)\n\
    \tfor i = 1, #numbers - 1 do\n\t\tlocal dist = numbers[i + 1] - numbers[i]\n\t\
    \tif dist < min_dist then\n\t\t\tmin_dist = dist\n\t\t\tclosest_pairs = {numbers[i],\
    \ numbers[i + 1]}\n\t\tend\n\tend\n\t\n\treturn closest_pairs[1], closest_pairs[2]\n\
    end", "    assert(#numbers >= 2)\n    local min_gap = math.huge\n    local min_gap_elements\
    \ = nil\n    local prev_number = numbers[1]\n    for i = 2, #numbers do\n    \
    \    local gap = numbers[i] - prev_number\n        if gap < min_gap then\n   \
    \         min_gap = gap\n            min_gap_elements = {prev_number, numbers[i]}\n\
    \        end\n        prev_number = numbers[i]\n    end\n    return unpack(min_gap_elements)\n\
    end", "    if #numbers < 2 then\n        return nil\n    end\n    local smallest_difference\
    \ = math.abs(numbers[1] - numbers[2])\n    local smallest_index_1 = 1\n    local\
    \ smallest_index_2 = 2\n    for i = 1, #numbers do\n        for j = i + 1, #numbers\
    \ do\n            local difference = math.abs(numbers[i] - numbers[j])\n     \
    \       if difference < smallest_difference then\n                smallest_difference\
    \ = difference\n                smallest_index_1 = i\n                smallest_index_2\
    \ = j\n            end\n        end\n    end\n    return numbers[smallest_index_1],\
    \ numbers[smallest_index_2]\nend", "    local n = #numbers\n    assert(n > 1,\
    \ 'list must have at least two elements')\n    local a = numbers[1]\n    local\
    \ b = numbers[2]\n    local min_diff = math.abs(a - b)\n    for i = 1, n do\n\
    \        for j = i + 1, n do\n            local diff = math.abs(numbers[i] - numbers[j])\n\
    \            if diff < min_diff then\n                min_diff = diff\n      \
    \          a = numbers[i]\n                b = numbers[j]\n            end\n \
    \       end\n    end\n    return a, b\nend", "    local a, b = nil, nil\n    local\
    \ diff = math.huge\n    local n = #numbers\n    for i = 1, n - 1 do\n        for\
    \ j = i + 1, n do\n            local ai, aj = numbers[i], numbers[j]\n       \
    \     local dist = math.abs(ai - aj)\n            if dist < diff then\n      \
    \          a, b = ai, aj\n                diff = dist\n            end\n     \
    \   end\n    end\n    return a, b\nend", "    local diff = math.huge\n    local\
    \ first_number, second_number\n    for i, num in ipairs(numbers) do\n        for\
    \ j, other_num in ipairs(numbers) do\n            if i ~= j then\n           \
    \     local current_diff = math.abs(num - other_num)\n                if current_diff\
    \ < diff then\n                    diff = current_diff\n                    first_number\
    \ = num\n                    second_number = other_num\n                end\n\
    \            end\n        end\n    end\n    if first_number > second_number then\n\
    \        first_number, second_number = second_number, first_number\n    end\n\
    \    return first_number, second_number\nend", "    if #numbers < 2 then\n   \
    \     return nil\n    end\n    local n1, n2 = numbers[1], numbers[2]\n    local\
    \ diff = math.abs(n1 - n2)\n    local ret = {n1, n2}\n    for i = 1, #numbers\
    \ do\n        for j = i + 1, #numbers do\n            local d = math.abs(numbers[i]\
    \ - numbers[j])\n            if d < diff then\n                diff = d\n    \
    \            ret = {numbers[i], numbers[j]}\n            end\n        end\n  \
    \  end\n    return unpack(ret)\nend", "  local smallest, smallest_difference =\
    \ 0, 99999\n  for i = 1, #numbers do\n    for j = i + 1, #numbers do\n      local\
    \ distance = math.abs(numbers[i] - numbers[j])\n      if distance < smallest_difference\
    \ then\n        smallest, smallest_difference = i, distance\n      end\n    end\n\
    \  end\n  return numbers[smallest], numbers[smallest + 1]\nend", "\tlocal closest_elements\
    \ = {}\n\tlocal min_diff = math.huge\n\tfor i = 1, #numbers do\n\t\tfor j = i\
    \ + 1, #numbers do\n\t\t\tlocal diff = math.abs(numbers[i] - numbers[j])\n\t\t\
    \tif diff < min_diff then\n\t\t\t\tmin_diff = diff\n\t\t\t\tclosest_elements =\
    \ {numbers[i], numbers[j]}\n\t\t\tend\n\t\tend\n\tend\n\treturn closest_elements[1],\
    \ closest_elements[2]\nend", "  table.sort(numbers)\n  local min_distance = math.huge\n\
    \  local result = {numbers[1], numbers[2]}\n  for i = 1, #numbers - 1 do\n   \
    \ local distance = numbers[i + 1] - numbers[i]\n    if distance < min_distance\
    \ then\n      min_distance = distance\n      result = {numbers[i], numbers[i +\
    \ 1]}\n    end\n  end\n  return result[1], result[2]\nend", "  local closest_elements\
    \ = {numbers[1], numbers[2]}\n  local closest_difference = math.abs(numbers[1]\
    \ - numbers[2])\n  for i, first_number in ipairs(numbers) do\n    for _, second_number\
    \ in ipairs(numbers) do\n      if first_number ~= second_number then\n       \
    \ local difference = math.abs(first_number - second_number)\n        if difference\
    \ < closest_difference then\n          closest_elements = {first_number, second_number}\n\
    \          closest_difference = difference\n        end\n      end\n    end\n\
    \  end\n  return closest_elements[1], closest_elements[2]\nend", "    assert(#numbers\
    \ >= 2)\n    local m, n = math.huge, math.huge\n    local i, j = 0, 0\n    for\
    \ p = 1, #numbers - 1 do\n        for q = p + 1, #numbers do\n            local\
    \ d = math.abs(numbers[p] - numbers[q])\n            if d < m then\n         \
    \       m, n = d, m\n                i, j = p, q\n            elseif d < n then\n\
    \                n = d\n                j = q\n            end\n        end\n\
    \    end\n    return numbers[i], numbers[j]\nend", "\tlocal index_smaller = 1\n\
    \tlocal index_larger = 2\n\tfor index, number in ipairs(numbers) do\n\t\tif numbers[index_smaller]\
    \ == numbers[index_larger] then\n\t\t\tindex_larger = index\n\t\telseif numbers[index_smaller]\
    \ > numbers[index_larger] then\n\t\t\tif math.abs(numbers[index_smaller] - numbers[index_larger])\
    \ > math.abs(number - numbers[index_larger]) then\n\t\t\t\tindex_smaller = index\n\
    \t\t\telseif math.abs(numbers[index_smaller] - numbers[index_larger]) > math.abs(number\
    \ - numbers[index_smaller]) then\n\t\t\t\tindex_larger = index\n\t\t\tend\n\t\t\
    else\n\t\t\tif math.abs(numbers[index_smaller] - numbers[index_larger]) > math.abs(number\
    \ - numbers[index_larger]) then\n\t\t\t\tindex_larger = index\n\t\t\telseif math.abs(numbers[index_smaller]\
    \ - numbers[index_larger]) > math.abs(number - numbers[index_smaller]) then\n\t\
    \t\t\tindex_smaller = index\n\t\t\tend\n\t\tend\n\tend\n\treturn numbers[index_smaller],\
    \ numbers[index_larger]\nend", "    -- Get a list of all the pairwise differences\n\
    \    local differences = {}\n    for i = 1, #numbers - 1 do\n        for j = i\
    \ + 1, #numbers do\n            local diff = math.abs(numbers[i] - numbers[j])\n\
    \            table.insert(differences, {diff, numbers[i], numbers[j]})\n     \
    \   end\n    end", "    local sorted = table_sort(numbers)\n    local closest\
    \ = nil\n    local distance = nil\n    for i = 1, #sorted - 1 do\n        local\
    \ a = sorted[i]\n        local b = sorted[i + 1]\n        local dist = math_abs(a\
    \ - b)\n        if distance == nil or dist < distance then\n            closest\
    \ = {a, b}\n            distance = dist\n        end\n    end\n    return closest[1],\
    \ closest[2]\nend", "  local first_element = numbers[1]\n  local second_element\
    \ = numbers[2]\n  local min_distance = math.abs(first_element - second_element)\n\
    \  for index = 1, #numbers do\n    local number = numbers[index]\n    for other_index\
    \ = index + 1, #numbers do\n      local other_number = numbers[other_index]\n\
    \      local other_distance = math.abs(number - other_number)\n      if other_distance\
    \ < min_distance then\n        min_distance = other_distance\n        first_element\
    \ = number\n        second_element = other_number\n      end\n    end\n  end\n\
    \  if first_element > second_element then\n    return second_element, first_element\n\
    \  else\n    return first_element, second_element\n  end\nend", "    local smaller_number,\
    \ larger_number = numbers[1], numbers[2]\n    if smaller_number > larger_number\
    \ then\n        smaller_number, larger_number = larger_number, smaller_number\n\
    \    end\n    local smallest_difference = larger_number - smaller_number\n   \
    \ for i = 2, #numbers - 1 do\n        local local_smaller_number, local_larger_number\
    \ = numbers[i], numbers[i + 1]\n        if local_smaller_number > local_larger_number\
    \ then\n            local_smaller_number, local_larger_number = local_larger_number,\
    \ local_smaller_number\n        end\n        local local_difference = local_larger_number\
    \ - local_smaller_number\n        if local_difference < smallest_difference then\n\
    \            smaller_number, larger_number = local_smaller_number, local_larger_number\n\
    \            smallest_difference = local_difference\n        end\n    end\n  \
    \  return smaller_number, larger_number\nend", "  local minDiff = math.huge\n\
    \  local minNumbers = {numbers[1], numbers[2]}\n  for i = 1, #numbers - 1 do\n\
    \    local diff = math.abs(numbers[i] - numbers[i + 1])\n    if diff < minDiff\
    \ then\n      minDiff = diff\n      minNumbers = {numbers[i], numbers[i + 1]}\n\
    \    end\n  end\n  return minNumbers[1], minNumbers[2]\nend", "    local min_dif\
    \ = math.huge\n    local min_element_pair = nil\n    for i = 1, #numbers - 1 do\n\
    \        local dif = math.abs(numbers[i] - numbers[i + 1])\n        if dif < min_dif\
    \ then\n            min_dif = dif\n            min_element_pair = { numbers[i],\
    \ numbers[i + 1] }\n        end\n    end\n    table.sort(min_element_pair)\n \
    \   return min_element_pair[1], min_element_pair[2]\nend", "\tlocal result = {1.0/0.0,\
    \ 1.0/0.0}\n\tfor i = 1, #numbers do\n\t\tlocal n1 = numbers[i]\n\t\tfor j = i\
    \ + 1, #numbers do\n\t\t\tlocal n2 = numbers[j]\n\t\t\tlocal n1n2_diff = math.abs(n1\
    \ - n2)\n\t\t\tlocal result_diff = math.abs(result[1] - result[2])\n\t\t\tif n1n2_diff\
    \ < result_diff then\n\t\t\t\tresult = {n1, n2}\n\t\t\tend\n\t\tend\n\tend\n\t\
    table.sort(result)\n\treturn result[1], result[2]\nend", "    local min_diff =\
    \ math.huge\n    local min_elem = nil\n    local min_next = nil\n    local prev\
    \ = nil\n    local next = nil\n    for _, v in ipairs(numbers) do\n        if\
    \ prev ~= nil then\n            local diff = math.abs(v - prev)\n            if\
    \ diff < min_diff then\n                min_diff = diff\n                min_elem\
    \ = prev\n                min_next = v\n            end\n        end\n       \
    \ prev = v\n    end\n    return min_elem, min_next\nend", "  local sorted_numbers\
    \ = insertion_sort(numbers)\n  local closest_distance = sorted_numbers[2] - sorted_numbers[1]\n\
    \  local closest_elements = {sorted_numbers[1], sorted_numbers[2]}\n  for i =\
    \ 2, #sorted_numbers - 1 do\n    local distance = sorted_numbers[i + 1] - sorted_numbers[i]\n\
    \    if distance < closest_distance then\n      closest_distance = distance\n\
    \      closest_elements = {sorted_numbers[i], sorted_numbers[i + 1]}\n    end\n\
    \  end\n  return closest_elements[1], closest_elements[2]\nend", "    assert(numbers\
    \ and #numbers >= 2)\n    local lowest = math.huge\n    local a, b = nil, nil\n\
    \    for i = 1, #numbers - 1 do\n        local current = numbers[i]\n        for\
    \ j = i + 1, #numbers do\n            local candidate = numbers[j]\n         \
    \   local distance = math.abs(current - candidate)\n            if distance <\
    \ lowest then\n                lowest = distance\n                a, b = current,\
    \ candidate\n            end\n        end\n    end\n    assert(a)\n    assert(b)\n\
    \    return a, b\nend", "    local closest_distance = math.huge\n    local pair\
    \ = {nil, nil}\n    for i = 1, #numbers - 1 do\n        local dist = math.abs(numbers[i]\
    \ - numbers[i + 1])\n        if dist < closest_distance then\n            closest_distance\
    \ = dist\n            pair = {numbers[i], numbers[i + 1]}\n        end\n    end\n\
    \    return pair[1], pair[2]\nend", "    local smallest_difference = math.huge\n\
    \    local first_number = nil\n    local second_number = nil\n    for i = 1, #numbers\
    \ - 1 do\n        local difference = math.abs(numbers[i] - numbers[i + 1])\n \
    \       if difference < smallest_difference then\n            smallest_difference\
    \ = difference\n            first_number = numbers[i]\n            second_number\
    \ = numbers[i + 1]\n        end\n    end\n    return first_number, second_number\n\
    end", "\tlocal min, minIndex, minIndex2 = math.huge, 0, 0\n\tfor k, v in ipairs(numbers)\
    \ do\n\t\tif v ~= numbers[minIndex] then\n\t\t\tif math.abs(v - numbers[minIndex])\
    \ < min then\n\t\t\t\tmin = math.abs(v - numbers[minIndex])\n\t\t\t\tminIndex2\
    \ = k\n\t\t\tend\n\t\tend\n\tend\n\treturn numbers[minIndex], numbers[minIndex2]\n\
    end", "    assert(#numbers >= 2)\n    local best_difference = math.huge\n    local\
    \ closest_elements = { nil, nil }\n    for i = 1, #numbers - 1 do\n        for\
    \ j = i + 1, #numbers do\n            local difference = math.abs(numbers[i] -\
    \ numbers[j])\n            if difference < best_difference then\n            \
    \    best_difference = difference\n                closest_elements = { numbers[i],\
    \ numbers[j] }\n            end\n        end\n    end\n    return unpack(closest_elements)\n\
    end", "\tlocal closest_distance = math.huge\n\tlocal closest_numbers\n\tfor i\
    \ = 1, #numbers - 1 do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal distance =\
    \ math.abs(numbers[i] - numbers[j])\n\t\t\tif distance < closest_distance then\n\
    \t\t\t\tclosest_distance = distance\n\t\t\t\tclosest_numbers = {numbers[i], numbers[j]}\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn unpack(closest_numbers)\nend", "    local\
    \ min_diff = math.huge\n    local min_val1 = nil\n    local min_val2 = nil\n \
    \   for i,x in ipairs(numbers) do\n        for j=i+1,#numbers do\n           \
    \ local diff = math.abs(x - numbers[j])\n            if diff < min_diff then\n\
    \                min_diff = diff\n                min_val1 = x\n             \
    \   min_val2 = numbers[j]\n            end\n        end\n    end\n    return min_val1,\
    \ min_val2\nend", "    local smallest_distance = numbers[2] - numbers[1]\n   \
    \ local smallest_distance_index = 2\n    for i = 2, #numbers do\n        local\
    \ distance = numbers[i] - numbers[i - 1]\n        if distance < smallest_distance\
    \ then\n            smallest_distance = distance\n            smallest_distance_index\
    \ = i\n        end\n    end\n    return numbers[smallest_distance_index - 1],\
    \ numbers[smallest_distance_index]\nend", "\tlocal a, b = numbers[1], numbers[2]\n\
    \tfor i = 1, #numbers - 1 do\n\t\tfor j = i + 1, #numbers do\n\t\t\tif abs(numbers[i]\
    \ - numbers[j]) < abs(a - b) then\n\t\t\t\ta, b = numbers[i], numbers[j]\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn a, b\nend", "    local min_diff, min_pair = math.huge,\
    \ {0, 0}\n    table.sort(numbers)\n    for i, x in ipairs(numbers) do\n      \
    \  local xn = numbers[i + 1]\n        if xn then\n            local diff = math.abs(x\
    \ - xn)\n            if diff < min_diff then\n                min_diff, min_pair\
    \ = diff, {x, xn}\n            end\n        end\n    end\n    return unpack(min_pair)\n\
    end", "  local smallest_delta = math.huge\n  local result_a = numbers[1]\n  local\
    \ result_b = numbers[2]\n  local n = #numbers\n  for i = 1, n do\n    for j =\
    \ i + 1, n do\n      local delta = math.abs(numbers[i] - numbers[j])\n      if\
    \ delta < smallest_delta then\n        smallest_delta = delta\n        result_a\
    \ = numbers[i]\n        result_b = numbers[j]\n      end\n    end\n  end\n  return\
    \ result_a, result_b\nend", "\tlocal min = nil\n\tlocal min_x = nil\n\tlocal min_y\
    \ = nil\n\tfor i = 1, #numbers - 1 do\n\t\tfor j = i + 1, #numbers do\n\t\t\t\
    local diff = numbers[j] - numbers[i]\n\t\t\tif min == nil or diff < min then\n\
    \t\t\t\tmin = diff\n\t\t\t\tmin_x = numbers[i]\n\t\t\t\tmin_y = numbers[j]\n\t\
    \t\tend\n\t\tend\n\tend\n\treturn min_x, min_y\nend", "    assert(#numbers >=\
    \ 2)\n    local closest = math.abs(numbers[1] - numbers[2])\n    local num1 =\
    \ numbers[1]\n    local num2 = numbers[2]\n    for i = 1, #numbers - 1 do\n  \
    \      for j = i + 1, #numbers do\n            local diff = math.abs(numbers[i]\
    \ - numbers[j])\n            if diff < closest then\n                closest =\
    \ diff\n                num1 = numbers[i]\n                num2 = numbers[j]\n\
    \            end\n        end\n    end\n    return num1, num2\nend", "    local\
    \ last_number = nil\n    local closest_two = nil\n    local closest_distance =\
    \ nil\n    for _, number in ipairs(numbers) do\n        if last_number then\n\
    \            local distance = number - last_number\n            if not closest_distance\
    \ or distance < closest_distance then\n                closest_distance = distance\n\
    \                closest_two = {last_number, number}\n            end\n      \
    \  end\n        last_number = number\n    end\n    return unpack(closest_two)\n\
    end", "  local current_min = math.abs(numbers[1] - numbers[2])\n  local current_min_elements\
    \ = {numbers[1], numbers[2]}\n  for i = 1, #numbers - 1 do\n    for j = i + 1,\
    \ #numbers do\n      local diff = math.abs(numbers[i] - numbers[j])\n      if\
    \ diff < current_min then\n        current_min = diff\n        current_min_elements\
    \ = {numbers[i], numbers[j]}\n      end\n    end\n  end\n  return current_min_elements[1],\
    \ current_min_elements[2]\nend", "  local closest_distance = math.huge\n  local\
    \ result = nil\n  for i = 1, #numbers - 1 do\n    for j = i + 1, #numbers do\n\
    \      local distance = math.abs(numbers[i] - numbers[j])\n      if distance <\
    \ closest_distance then\n        closest_distance = distance\n        result =\
    \ {numbers[i], numbers[j]}\n      end\n    end\n  end\n  return unpack(result)\n\
    end", "  if #numbers < 2 then\n    return nil\n  end\n  local first = numbers[1]\n\
    \  local second = numbers[2]\n  local closest_diff = math.abs(first - second)\n\
    \  for i = 1, #numbers - 1 do\n    for j = i + 1, #numbers do\n      local diff\
    \ = math.abs(numbers[i] - numbers[j])\n      if diff < closest_diff then\n   \
    \     first = numbers[i]\n        second = numbers[j]\n        closest_diff =\
    \ diff\n      end\n    end\n  end\n  if first > second then\n    first, second\
    \ = second, first\n  end\n  return first, second\nend", "\tlocal min_diff = math.huge\n\
    \tlocal smaller_num, larger_num\n\tfor i, num in ipairs(numbers) do\n\t\tfor j\
    \ = 1, #numbers do\n\t\t\tif j > i then\n\t\t\t\tif math.abs(num - numbers[j])\
    \ < min_diff then\n\t\t\t\t\tmin_diff = math.abs(num - numbers[j])\n\t\t\t\t\t\
    smaller_num = num\n\t\t\t\t\tlarger_num = numbers[j]\n\t\t\t\tend\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn smaller_num, larger_num\nend", "    local closest_difference\
    \ = numbers[2] - numbers[1]\n    local closest_numbers = {numbers[1], numbers[2]}\n\
    \    for i = 1, #numbers - 1 do\n        for j = i + 1, #numbers do\n        \
    \    local difference = numbers[j] - numbers[i]\n            if difference < closest_difference\
    \ then\n                closest_difference = difference\n                closest_numbers\
    \ = {numbers[i], numbers[j]}\n            end\n        end\n    end\n    return\
    \ unpack(closest_numbers)\nend", "    local index = 0\n    local smallest = nil\n\
    \    for i = 1, #numbers do\n        local candidate = numbers[i]\n        if\
    \ smallest == nil or candidate < smallest then\n            smallest = candidate\n\
    \            index = i\n        end\n    end\n    local candidates = {numbers[index]}\n\
    \    if index > 1 then\n        candidates[#candidates + 1] = numbers[index -\
    \ 1]\n    end\n    if index < #numbers then\n        candidates[#candidates +\
    \ 1] = numbers[index + 1]\n    end\n    local closest = candidates[1]\n    for\
    \ i = 2, #candidates do\n        local candidate = candidates[i]\n        if math.abs(candidate\
    \ - smallest) < math.abs(closest - smallest) then\n            closest = candidate\n\
    \        end\n    end\n    return smallest, closest\nend", '    local delta, closest,
    x, y, distance', "    local first, second = numbers[1], numbers[2]\n    local\
    \ distance = second - first\n    for i = 1, #numbers do\n        for j = i + 1,\
    \ #numbers do\n            local d = numbers[j] - numbers[i]\n            if d\
    \ < distance then\n                first, second, distance = numbers[i], numbers[j],\
    \ d\n            end\n        end\n    end\n    return first, second\nend", " \
    \   local num_length = table_length(numbers)\n    if num_length < 2 then\n   \
    \     return nil\n    end\n    local min_distance = math.abs(numbers[1] - numbers[2])\n\
    \    local index_low = 1\n    local index_high = 2\n    for i = 1, num_length\
    \ - 1 do\n        local distance = math.abs(numbers[i] - numbers[i + 1])\n   \
    \     if distance < min_distance then\n            min_distance = distance\n \
    \           index_low = i\n            index_high = i + 1\n        end\n    end\n\
    \    return numbers[index_low], numbers[index_high]\nend", "    local max_difference\
    \ = numbers[2] - numbers[1]\n    local index_of_higher_number = 2\n    local index_of_lower_number\
    \ = 1\n    for i = 3, #numbers do\n        local current_difference = numbers[i]\
    \ - numbers[i - 1]\n        if current_difference > max_difference then\n    \
    \        max_difference = current_difference\n            index_of_higher_number\
    \ = i\n            index_of_lower_number = i - 1\n        end\n    end\n    return\
    \ numbers[index_of_lower_number], numbers[index_of_higher_number]\nend", "   \
    \ if #numbers < 2 then\n        return (nil, nil)\n    end\n    local smallest_diff\
    \ = numbers[2] - numbers[1]\n    local smallest_left, smallest_right = numbers[1],\
    \ numbers[2]\n    for i = 1, #numbers - 1 do\n        for j = i + 1, #numbers\
    \ do\n            local diff = numbers[j] - numbers[i]\n            if diff <\
    \ smallest_diff then\n                smallest_diff = diff\n                smallest_left,\
    \ smallest_right = numbers[i], numbers[j]\n            end\n        end\n    end\n\
    \    return smallest_left, smallest_right\nend", "    local result = {numbers[1],\
    \ numbers[2]}\n    local distance = numbers[2] - numbers[1]\n    for i = 1, #numbers\
    \ - 1 do\n        for j = i + 1, #numbers do\n            local abs = math.abs(numbers[i]\
    \ - numbers[j])\n            if abs < distance then\n                distance\
    \ = abs\n                result = {numbers[i], numbers[j]}\n            end\n\
    \        end\n    end\n    return unpack(result)\nend", "    local closest\n \
    \   local res = {0, 0}\n    for i, v in ipairs(numbers) do\n        for j, w in\
    \ ipairs(numbers) do\n            if i ~= j then\n                local d = math.abs(v\
    \ - w)\n                if not closest or d < closest then\n                 \
    \   closest = d\n                    res = {i, j}\n                end\n     \
    \       end\n        end\n    end\n    return {numbers[res[1]], numbers[res[2]]}\n\
    end", "  assert(type(numbers) == \"table\", \"find_closest_elements requires a\
    \ table\")\n  local min_distance = math.huge\n  local min_x1, min_x2\n  for _,\
    \ x1 in ipairs(numbers) do\n    for _, x2 in ipairs(numbers) do\n      if x1 ~=\
    \ x2 then\n        local distance = math.abs(x1 - x2)\n        if distance < min_distance\
    \ then\n          min_distance = distance\n          min_x1 = x1\n          min_x2\
    \ = x2\n        end\n      end\n    end\n  end\n  assert(min_x1 and min_x2, \"\
    find_closest_elements failed to find two numbers in the list\")\n  return min_x1,\
    \ min_x2\nend", "    local n = #numbers\n    local smallest_difference = math.huge\n\
    \    local number_pairs = {}\n    for i = 1, n do\n        for j = 1, n do\n \
    \           if i ~= j then\n                local first_number = numbers[i]\n\
    \                local second_number = numbers[j]\n                local difference\
    \ = math.abs(first_number - second_number)\n                if difference < smallest_difference\
    \ then\n                    number_pairs = {first_number, second_number}\n   \
    \                 smallest_difference = difference\n                end\n    \
    \        end\n        end\n    end\n    return number_pairs[1], number_pairs[2]\n\
    end", "\tlocal closest_pairs = {}\n\tlocal lowest_delta = numbers[2] - numbers[1]\n\
    \tclosest_pairs[1] = numbers[1]\n\tclosest_pairs[2] = numbers[2]\n\tfor i = 1,\
    \ #numbers do\n\t\tfor j = 1, #numbers do\n\t\t\tif i == j then goto continue\
    \ end\n\t\t\tlocal d = numbers[j] - numbers[i]\n\t\t\tif math.abs(d) < math.abs(lowest_delta)\
    \ then\n\t\t\t\tlowest_delta = d\n\t\t\t\tclosest_pairs[1] = numbers[i]\n\t\t\t\
    \tclosest_pairs[2] = numbers[j]\n\t\t\tend\n\t\t\t::continue::\n\t\tend\n\tend\n\
    \treturn closest_pairs[1], closest_pairs[2]\nend", "    if (numbers == nil) or\
    \ (type(numbers) ~= \"table\") or (#numbers < 2) then\n        return nil\n  \
    \  end\n    local number1 = numbers[1]\n    local number2 = numbers[2]\n    local\
    \ difference = math.abs(number1 - number2)\n    local current_difference = 0\n\
    \    for i = 2, #numbers do\n        for j = i + 1, #numbers do\n            current_difference\
    \ = math.abs(numbers[i] - numbers[j])\n            if current_difference < difference\
    \ then\n                difference = current_difference\n                number1\
    \ = numbers[i]\n                number2 = numbers[j]\n            end\n      \
    \  end\n    end\n    return math.min(number1, number2), math.max(number1, number2)\n\
    end", "    local best_distance = math.huge\n    local best_pair = nil\n    for\
    \ i, x in ipairs(numbers) do\n        for j, y in ipairs(numbers) do\n       \
    \     if i ~= j then\n                local distance = math.abs(x - y)\n     \
    \           if distance < best_distance then\n                    best_distance\
    \ = distance\n                    best_pair = { x, y }\n                end\n\
    \            end\n        end\n    end\n    table.sort(best_pair)\n    return\
    \ best_pair[1], best_pair[2]\nend", "    -- local numbers = {1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2}\n    local distance = math.huge\n    local smallest = math.huge\n\
    \    local largest = math.huge\n    for i = 1, #numbers do\n        local x =\
    \ numbers[i]\n        for j = i+1, #numbers do\n            local y = numbers[j]\n\
    \            if math.abs(x-y) < distance then\n                distance = math.abs(x-y)\n\
    \                smallest = math.min(x, y)\n                largest = math.max(x,\
    \ y)\n            end\n        end\n    end\n    return smallest, largest\nend",
  "  local closest_difference = math.huge\n  local closest_numbers = { numbers[1],\
    \ numbers[2] }\n  for i = 1, #numbers - 1 do\n    for j = i + 1, #numbers do\n\
    \      local difference = math.abs(numbers[i] - numbers[j])\n      if difference\
    \ < closest_difference then\n        closest_difference = difference\n       \
    \ closest_numbers = { numbers[i], numbers[j] }\n      end\n    end\n  end\n  return\
    \ unpack(closest_numbers)\nend", "  assert(#numbers >= 2)\n  local closest_pair\
    \ = {numbers[1], numbers[2]}\n  local closest_distance = math.abs(numbers[1] -\
    \ numbers[2])\n  for i = 1, #numbers - 1 do\n    for j = i + 1, #numbers do\n\
    \      local distance = math.abs(numbers[i] - numbers[j])\n      if distance <\
    \ closest_distance then\n        closest_pair = {numbers[i], numbers[j]}\n   \
    \     closest_distance = distance\n      end\n    end\n  end\n  table.sort(closest_pair)\n\
    \  return unpack(closest_pair)\nend", "    assert(#numbers >= 2)\n    local min_difference\
    \ = math.huge\n    local min_index = {}\n    for i = 1, #numbers - 1 do\n    \
    \    local x = numbers[i]\n        local x1 = numbers[i + 1]\n        local difference\
    \ = math.abs(x - x1)\n        if difference < min_difference then\n          \
    \  min_difference = difference\n            min_index = {i, i + 1}\n        end\n\
    \    end\n    return numbers[min_index[1]], numbers[min_index[2]]\nend", "  --\
    \ return numbers[1], numbers[2] -- REPLACE THIS LINE WITH YOUR SOLUTION\n  local\
    \ min = math.abs(numbers[1] - numbers[2])\n  local temp = min\n  local min1 =\
    \ numbers[1]\n  local min2 = numbers[2]\n  for i=1,#numbers-1 do\n    for j=i+1,#numbers\
    \ do\n      if math.abs(numbers[i] - numbers[j]) < min then\n        min = math.abs(numbers[i]\
    \ - numbers[j])\n        min1 = numbers[i]\n        min2 = numbers[j]\n      end\n\
    \    end\n  end\n  return min1, min2\nend", "    local closest_diff = math.huge\n\
    \    local closest_pair = {numbers[1], numbers[2]}\n    for i = 1, #numbers do\n\
    \        for j = i + 1, #numbers do\n            local diff = math.abs(numbers[i]\
    \ - numbers[j])\n            if diff < closest_diff then\n                closest_diff\
    \ = diff\n                closest_pair = {numbers[i], numbers[j]}\n          \
    \  end\n        end\n    end\n    return unpack(closest_pair)\nend", "\tassert(#numbers\
    \ >= 2, \"find_closest_elements needs at least two numbers!\")\n\tlocal current_gap,\
    \ gap, smallest_gap, smallest_gap_position\n\tsmallest_gap = math.huge\n\tfor\
    \ i = 1, #numbers - 1 do\n\t\tgap = numbers[i + 1] - numbers[i]\n\t\tif gap <\
    \ smallest_gap then\n\t\t\tsmallest_gap = gap\n\t\t\tsmallest_gap_position = i\n\
    \t\tend\n\tend\n\treturn numbers[smallest_gap_position], numbers[smallest_gap_position\
    \ + 1]\nend", "  local smallest_difference = math.huge\n  local closest_pair =\
    \ {}\n  local smallest_number = math.huge\n  local largest_number = -math.huge\n\
    \  for _, number in ipairs(numbers) do\n    if number < smallest_number then\n\
    \      smallest_number = number\n    end\n    if number > largest_number then\n\
    \      largest_number = number\n    end\n  end\n  for _, number in ipairs(numbers)\
    \ do\n    if number ~= smallest_number and number ~= largest_number then\n   \
    \   local difference = math.abs(number - smallest_number)\n      if difference\
    \ < smallest_difference then\n        smallest_difference = difference\n     \
    \   closest_pair = { smallest_number, number }\n      end\n      difference =\
    \ math.abs(number - largest_number)\n      if difference < smallest_difference\
    \ then\n        smallest_difference = difference\n        closest_pair = { number,\
    \ largest_number }\n      end\n    end\n  end\n  return closest_pair[1], closest_pair[2]\n\
    end", "  local min_dif, min_index, min_index_2 = nil, 1, 2\n  for i = 1, #numbers\
    \ do\n    for j = i + 1, #numbers do\n      local dif = math.abs(numbers[i] -\
    \ numbers[j])\n      if not min_dif or dif < min_dif then\n        min_dif, min_index,\
    \ min_index_2 = dif, i, j\n      end\n    end\n  end\n  return numbers[min_index],\
    \ numbers[min_index_2]\nend", "  local smallest = numbers[1]\n  local largest\
    \ = numbers[1]\n  local min_diff = math.huge\n  for _,n in ipairs(numbers) do\n\
    \    if smallest > n then smallest = n end\n    if largest < n then largest =\
    \ n end\n    for _,m in ipairs(numbers) do\n      if m ~= n then\n        local\
    \ diff = math.abs(n - m)\n        if diff < min_diff then\n          smallest\
    \ = n\n          largest = m\n          min_diff = diff\n        end\n      end\n\
    \    end\n  end\n  return smallest, largest\nend", "    local i, j, min_distance,\
    \ min_i, min_j = 2, 1, math.huge, 1, 2\n    for i = 2, #numbers do\n        for\
    \ j = 1, i - 1 do\n            local distance = math.abs(numbers[i] - numbers[j])\n\
    \            if distance < min_distance then\n                min_distance = distance\n\
    \                min_i, min_j = i, j\n            end\n        end\n    end\n\
    \    return numbers[min_i], numbers[min_j]\nend", "    local x0, x1, y0, y1\n\
    \    local diff, closest_diff = math.huge, math.huge\n    for i, x in ipairs(numbers)\
    \ do\n        for j, y in ipairs(numbers) do\n            if i ~= j then\n   \
    \             diff = math.abs(x - y)\n                if diff < closest_diff then\n\
    \                    closest_diff = diff\n                    x0, x1, y0, y1 =\
    \ x, y, i, j\n                end\n            end\n        end\n    end\n   \
    \ return math.min(x0, x1), math.max(x0, x1)\nend", "    if not numbers then return\
    \ end\n    if #numbers == 0 then return end\n    if #numbers == 1 then return\
    \ numbers[1], numbers[1] end", "    local closest_pair = {numbers[1], numbers[2]}\n\
    \    local closest_diff = math.abs(numbers[1] - numbers[2])\n    for i = 1, #numbers\
    \ do\n        for j = i + 1, #numbers do\n            local diff = math.abs(numbers[i]\
    \ - numbers[j])\n            if diff < closest_diff then\n                closest_pair\
    \ = {numbers[i], numbers[j]}\n                closest_diff = diff\n          \
    \  end\n        end\n    end\n    table.sort(closest_pair)\n    return unpack(closest_pair)\n\
    end", "  if #numbers < 2 then\n    error(\"invalid parameter\")\n  end\n  local\
    \ best_distance = math.huge\n  local best_pair = {}\n  for i = 1, #numbers do\n\
    \    for j = i + 1, #numbers do\n      local distance = math.abs(numbers[i] -\
    \ numbers[j])\n      if distance < best_distance then\n        best_distance =\
    \ distance\n        best_pair = {numbers[i], numbers[j]}\n      end\n    end\n\
    \  end\n  return unpack(best_pair)\nend", "\tlocal num_length = #numbers\n\tlocal\
    \ min_distance = numbers[2] - numbers[1]\n\tlocal min_distance_element_one = numbers[1]\n\
    \tlocal min_distance_element_two = numbers[2]\n\tfor i = 1, num_length - 1 do\n\
    \t\tlocal current_distance = numbers[i + 1] - numbers[i]\n\t\tif current_distance\
    \ < min_distance then\n\t\t\tmin_distance = current_distance\n\t\t\tmin_distance_element_one\
    \ = numbers[i]\n\t\t\tmin_distance_element_two = numbers[i + 1]\n\t\tend\n\tend\n\
    \treturn min_distance_element_one, min_distance_element_two\nend", "    local\
    \ smallest = numbers[1]\n    local biggest = numbers[1]\n    local smallest_idx\
    \ = 1\n    local biggest_idx = 1\n    for i = 2, #numbers do\n        if numbers[i]\
    \ < smallest then\n            smallest = numbers[i]\n            smallest_idx\
    \ = i\n        end\n        if numbers[i] > biggest then\n            biggest\
    \ = numbers[i]\n            biggest_idx = i\n        end\n    end\n    if biggest_idx\
    \ < smallest_idx then\n        biggest, smallest = smallest, biggest\n    end\n\
    \    local closest_idx = smallest_idx\n    local closest_distance = biggest -\
    \ smallest\n    for i = smallest_idx + 1, biggest_idx - 1 do\n        local distance\
    \ = numbers[i + 1] - numbers[i]\n        if distance < closest_distance then\n\
    \            closest_distance = distance\n            closest_idx = i\n      \
    \  end\n    end\n    return numbers[closest_idx], numbers[closest_idx + 1]\nend",
  "    if #numbers < 2 then return nil end\n    local min = numbers[1]\n    local\
    \ max = numbers[1]\n    for _, n in ipairs(numbers) do\n        if n < min then\
    \ min = n end\n        if n > max then max = n end\n    end\n    local closest_diff\
    \ = max - min\n    local closest_numbers = {min, max}\n    for i = 1, #numbers\
    \ do\n        for j = i + 1, #numbers do\n            local diff = numbers[j]\
    \ - numbers[i]\n            if diff < closest_diff then\n                closest_diff\
    \ = diff\n                closest_numbers = {numbers[i], numbers[j]}\n       \
    \     end\n        end\n    end\n    return unpack(closest_numbers)\nend", " \
    \ local closest_difference = math.huge\n  local first_value = nil\n  local second_value\
    \ = nil\n  for _, value in ipairs(numbers) do\n    local difference = math.abs(value\
    \ - numbers[1])\n    if difference < closest_difference then\n      closest_difference\
    \ = difference\n      first_value = numbers[1]\n      second_value = value\n \
    \   end\n  end\n  return first_value, second_value\nend", "\tlocal smallest_delta\
    \ = math.huge\n\tlocal index1, index2\n\tfor i, x in ipairs(numbers) do\n\t\t\
    for j, y in ipairs(numbers) do\n\t\t\tif j > i then\n\t\t\t\tlocal x_y_delta =\
    \ math.abs(x - y)\n\t\t\t\tif x_y_delta < smallest_delta then\n\t\t\t\t\tsmallest_delta\
    \ = x_y_delta\n\t\t\t\t\tindex1 = i\n\t\t\t\t\tindex2 = j\n\t\t\t\tend\n\t\t\t\
    end\n\t\tend\n\tend\n\tassert(index1)\n\tassert(index2)\n\tlocal x = numbers[index1]\n\
    \tlocal y = numbers[index2]\n\tif x > y then\n\t\treturn y, x\n\telse\n\t\treturn\
    \ x, y\n\tend\nend", "\tlocal sorted = sort(numbers)\n\t-- Need at least two numbers\
    \ in the list\n\tassert(#sorted >= 2)\n\t-- The sorted list\n\tlocal prev = sorted[1]\n\
    \tlocal delta = math.huge\n\tlocal a, b = nil, nil\n\tfor i=2,#sorted do\n\t\t\
    local val = sorted[i]\n\t\tlocal d = math.abs(val - prev)\n\t\tif d < delta then\n\
    \t\t\ta, b = prev, val\n\t\t\tdelta = d\n\t\tend\n\t\tprev = val\n\tend\n\treturn\
    \ a, b\nend", "    local sorted_numbers = table.sort(numbers)\n    local min_difference\
    \ = math.huge\n    local smallest_index\n    local largest_index\n    for i =\
    \ 1, #sorted_numbers - 1 do\n        local difference = sorted_numbers[i + 1]\
    \ - sorted_numbers[i]\n        if difference < min_difference then\n         \
    \   min_difference = difference\n            smallest_index = i\n            largest_index\
    \ = i + 1\n        end\n    end\n    return sorted_numbers[smallest_index], sorted_numbers[largest_index]\n\
    end", "  local min_difference = math.huge\n  local numbers_length = #numbers\n\
    \  local small, large = numbers[1], numbers[2]\n  for i = 1, numbers_length do\n\
    \    for j = i + 1, numbers_length do\n      local difference = math.abs(numbers[i]\
    \ - numbers[j])\n      if difference < min_difference then\n        min_difference\
    \ = difference\n        small, large = numbers[i], numbers[j]\n      end\n   \
    \ end\n  end\n  return small, large\nend", "    assert(numbers:length() >= 2)\n\
    \    local smallest_difference = numbers:get(2) - numbers:get(1)\n    local result_pairs\
    \ = Vector{Vector{numbers:get(1), numbers:get(2)}}\n    for i = 1, numbers:length()\
    \ - 1 do\n        for j = i + 1, numbers:length() do\n            local difference\
    \ = numbers:get(j) - numbers:get(i)\n            if difference < smallest_difference\
    \ then\n                smallest_difference = difference\n                result_pairs\
    \ = Vector{Vector{numbers:get(i), numbers:get(j)}}\n            elseif difference\
    \ == smallest_difference then\n                result_pairs:append(Vector{numbers:get(i),\
    \ numbers:get(j)})\n            end\n        end\n    end\n    return result_pairs:get(math.random(result_pairs:length()))\n\
    end", "    local one = numbers[1]\n    local two = numbers[2]\n    local diff\
    \ = math.abs(one - two)\n    for i = 1, #numbers do\n        for j = i + 1, #numbers\
    \ do\n            local d = math.abs(numbers[i] - numbers[j])\n            if\
    \ d < diff then\n                one = numbers[i]\n                two = numbers[j]\n\
    \                diff = d\n            end\n        end\n    end\n    return one,\
    \ two\nend", "    if #numbers == 0 then\n        error('This function expects\
    \ at least one number in the input!')\n    end\n    local closest_elements = {numbers[1],\
    \ numbers[2]}\n    local closest_distance = math.abs(numbers[1] - numbers[2])\n\
    \    for i = 1, #numbers do\n        for j = i + 1, #numbers do\n            local\
    \ distance = math.abs(numbers[i] - numbers[j])\n            if distance < closest_distance\
    \ then\n                closest_distance = distance\n                closest_elements\
    \ = {numbers[i], numbers[j]}\n            end\n        end\n    end\n    return\
    \ closest_elements[1], closest_elements[2]\nend", "    local i, j = 1, 2\n   \
    \ local min_delta = math.abs(numbers[i] - numbers[j])\n    for a = 1, #numbers\
    \ - 1 do\n        for b = a + 1, #numbers do\n            local delta = math.abs(numbers[a]\
    \ - numbers[b])\n            if delta < min_delta then\n                i, j =\
    \ a, b\n                min_delta = delta\n            end\n        end\n    end\n\
    \    return math.min(numbers[i], numbers[j]), math.max(numbers[i], numbers[j])\n\
    end", "    local c1, c2 = numbers[1], numbers[2]\n    local s1, s2 = math.abs(c1-c2),\
    \ 0\n    for i=3,#numbers do\n        s2 = math.abs(c1-numbers[i])\n        if\
    \ s2<s1 then\n            c2, s1 = numbers[i], s2\n        end\n    end\n    if\
    \ c1<c2 then\n        return c1, c2\n    else\n        return c2, c1\n    end\n\
    end", "  local small, big, distance = numbers[1], numbers[2], numbers[2] - numbers[1]\n\
    \  if numbers[2] < numbers[1] then\n    small, big = big, small\n  end\n  for\
    \ i = 3, #numbers do\n    local d = numbers[i] - numbers[i - 1]\n    if d < distance\
    \ then\n      small, big, distance = numbers[i - 1], numbers[i], d\n    end\n\
    \  end\n  return small, big\nend", "    local lowest_diff = math.huge\n    local\
    \ lower_index = 1\n    local higher_index = 2\n    for i = 1, #numbers - 1 do\n\
    \        local diff = numbers[i + 1] - numbers[i]\n        if diff < lowest_diff\
    \ then\n            lowest_diff = diff\n            lower_index = i\n        \
    \    higher_index = i + 1\n        end\n    end\n    return numbers[lower_index],\
    \ numbers[higher_index]\nend", "  numbers = numbers:sort()\n  local closest_diff\
    \ = math.huge\n  local closest_element_low, closest_element_high\n  for i=1,#numbers-1\
    \ do\n    local diff = numbers[i+1] - numbers[i]\n    if diff < closest_diff then\n\
    \      closest_diff = diff\n      closest_element_low = numbers[i]\n      closest_element_high\
    \ = numbers[i+1]\n    end\n  end\n  return closest_element_low, closest_element_high\n\
    end", "\tassert(type(numbers) == \"table\")\n\tassert(#numbers >= 2)\n\tlocal\
    \ min_difference = math.huge\n\tlocal closest_elements = nil\n\tfor i = 1, #numbers\
    \ - 1 do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal difference = math.abs(numbers[i]\
    \ - numbers[j])\n\t\t\tif difference < min_difference then\n\t\t\t\tmin_difference\
    \ = difference\n\t\t\t\tclosest_elements = {numbers[i], numbers[j]}\n\t\t\tend\n\
    \t\tend\n\tend\n\tassert(closest_elements)\n\tif closest_elements[1] > closest_elements[2]\
    \ then\n\t\tclosest_elements[1], closest_elements[2] = closest_elements[2], closest_elements[1]\n\
    \tend\n\treturn closest_elements[1], closest_elements[2]\nend", "  local min_difference\
    \ = math.huge\n  local min_a, min_b = numbers[1], numbers[2]\n  for i = 1, #numbers\
    \ - 1 do\n    for j = i + 1, #numbers do\n      local d = math.abs(numbers[i]\
    \ - numbers[j])\n      if d < min_difference then\n        min_difference = d\n\
    \        min_a, min_b = numbers[i], numbers[j]\n      end\n    end\n  end\n  return\
    \ min_a, min_b\nend", "\tlocal smallest_diff = math.huge\n\tlocal value1, value2\n\
    \tfor i = 1, #numbers - 1 do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal diff\
    \ = math.abs(numbers[i] - numbers[j])\n\t\t\tif diff < smallest_diff then\n\t\t\
    \t\tsmallest_diff = diff\n\t\t\t\tvalue1 = numbers[i]\n\t\t\t\tvalue2 = numbers[j]\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn value1, value2\nend", "    local closest_gap,\
    \ closest_elements = math.huge, {}\n    for i = 1, #numbers - 1 do\n        local\
    \ gap = numbers[i + 1] - numbers[i]\n        if gap < closest_gap then\n     \
    \       closest_gap, closest_elements = gap, {numbers[i], numbers[i + 1]}\n  \
    \      end\n    end\n    return closest_elements[1], closest_elements[2]\nend",
  "\tlocal gap = math.huge\n\tlocal i = 1\n\tlocal j = 2\n\tfor k = 1, #numbers do\n\
    \t\tfor l = k + 1, #numbers do\n\t\t\tlocal candidate_gap = math.abs(numbers[k]\
    \ - numbers[l])\n\t\t\tif candidate_gap < gap then\n\t\t\t\tgap = candidate_gap\n\
    \t\t\t\ti = k\n\t\t\t\tj = l\n\t\t\tend\n\t\tend\n\tend\n\treturn numbers[i],\
    \ numbers[j]\nend", "    local min_elements = {numbers[1], numbers[2]}\n    local\
    \ min_diff = math.abs(numbers[1] - numbers[2])\n    for i = 1, #numbers do\n \
    \       for j = i + 1, #numbers do\n            local diff = math.abs(numbers[i]\
    \ - numbers[j])\n            if diff < min_diff then\n                min_diff\
    \ = diff\n                min_elements = {numbers[i], numbers[j]}\n          \
    \  end\n        end\n    end\n    return min_elements[1], min_elements[2]\nend",
  "\tlocal current_closest = math.abs(numbers[1] - numbers[2])\n\tlocal current_indices\
    \ = {1, 2}\n\tfor i = 1, #numbers do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal\
    \ distance = math.abs(numbers[i] - numbers[j])\n\t\t\tif distance < current_closest\
    \ then\n\t\t\t\tcurrent_closest = distance\n\t\t\t\tcurrent_indices = {i, j}\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn numbers[current_indices[1]], numbers[current_indices[2]]\n\
    end", "    local diff = math.huge\n    local smaller = nil\n    local larger =\
    \ nil\n    for i = 1, #numbers - 1 do\n        for j = i + 1, #numbers do\n  \
    \          local d = math.abs(numbers[i] - numbers[j])\n            if d < diff\
    \ then\n                diff = d\n                smaller = numbers[i]\n     \
    \           larger = numbers[j]\n            end\n        end\n    end\n    return\
    \ smaller, larger\nend", "\tlocal closest_number_1 = numbers[1]\n\tlocal closest_number_2\
    \ = numbers[2]\n\tlocal closest_separation = math.abs(closest_number_1 - closest_number_2)\n\
    \tlocal number_1 = 0\n\tlocal number_2 = 0\n\tlocal number_1_index = 0\n\tlocal\
    \ number_2_index = 0\n\tlocal separation = 0\n\tfor i = 1, #numbers do\n\t\tnumber_1\
    \ = numbers[i]\n\t\tfor j = i + 1, #numbers do\n\t\t\tnumber_2 = numbers[j]\n\t\
    \t\tseparation = math.abs(number_1 - number_2)\n\t\t\tif separation < closest_separation\
    \ then\n\t\t\t\tclosest_number_1 = number_1\n\t\t\t\tclosest_number_2 = number_2\n\
    \t\t\t\tclosest_separation = separation\n\t\t\t\tnumber_1_index = i\n\t\t\t\t\
    number_2_index = j\n\t\t\tend\n\t\tend\n\tend\n\treturn closest_number_1, closest_number_2\n\
    end", "    local n = #numbers\n    local closest_distance = numbers[2] - numbers[1]\n\
    \    local closest_indices = { 1, 2 }\n    for i = 1, n-1 do\n        for j =\
    \ i+1, n do\n            local d = math.abs(numbers[j] - numbers[i])\n       \
    \     if d < closest_distance then\n                closest_distance = d\n   \
    \             closest_indices = { i, j }\n            end\n        end\n    end\n\
    \    if numbers[closest_indices[1]] > numbers[closest_indices[2]] then\n     \
    \   return numbers[closest_indices[2]], numbers[closest_indices[1]]\n    else\n\
    \        return numbers[closest_indices[1]], numbers[closest_indices[2]]\n   \
    \ end\nend", "  local min_distance = math.huge\n  local result = {0, 0}\n  for\
    \ index, value in ipairs(numbers) do\n    for index2, value2 in ipairs(numbers)\
    \ do\n      if index ~= index2 then\n        local distance = math.abs(value -\
    \ value2)\n        if distance < min_distance then\n          min_distance = distance\n\
    \          result = {value, value2}\n        end\n      end\n    end\n  end\n\
    \  return unpack(result)\nend", "  if #numbers < 2 then\n    return nil\n  end\n\
    \  local closest_pair = {math.huge, math.huge}\n  local current_distance = math.huge\n\
    \  for i = 1, #numbers do\n    for j = i + 1, #numbers do\n      local distance\
    \ = math.abs(numbers[i] - numbers[j])\n      if distance < current_distance then\n\
    \        current_distance = distance\n        closest_pair = {numbers[i], numbers[j]}\n\
    \      end\n    end\n  end\n  return closest_pair[1], closest_pair[2]\nend", " \
    \   local best_distance = math.huge\n    local best_pair = nil\n    for i = 1,\
    \ #numbers - 1 do\n        local a = numbers[i]\n        for j = i + 1, #numbers\
    \ do\n            local b = numbers[j]\n            local distance = math.abs(a\
    \ - b)\n            if distance < best_distance then\n                best_distance\
    \ = distance\n                best_pair = {a, b}\n            end\n        end\n\
    \    end\n    return best_pair[1], best_pair[2]\nend", "  assert(#numbers >= 2)\n\
    \  local min_delta = math.huge\n  local min_i = 0\n  local min_j = 0\n  for i\
    \ = 1, #numbers do\n    for j = i + 1, #numbers do\n      local delta = math.abs(numbers[i]\
    \ - numbers[j])\n      if delta < min_delta then\n        min_delta = delta\n\
    \        min_i = i\n        min_j = j\n      end\n    end\n  end\n  return numbers[min_i],\
    \ numbers[min_j]\nend", "  local smallest_diff = math.huge\n  local smallest_diff_pair\
    \ = {}\n  local sorted_numbers = sort_numbers(numbers)\n  for i = 1, #sorted_numbers\
    \ - 1 do\n    local diff = sorted_numbers[i + 1] - sorted_numbers[i]\n    if diff\
    \ < smallest_diff then\n      smallest_diff = diff\n      smallest_diff_pair =\
    \ {sorted_numbers[i], sorted_numbers[i + 1]}\n    end\n  end\n  return unpack(smallest_diff_pair)\n\
    end", "  local closest = math.huge\n  local a, b\n  for _, n in ipairs(numbers)\
    \ do\n    local n1 = numbers[n]\n    for _, n2 in ipairs(numbers) do\n      if\
    \ n1 ~= n2 then\n        local diff = math.abs(n1 - n2)\n        if diff < closest\
    \ then\n          closest = diff\n          a, b = n1, n2\n        end\n     \
    \ end\n    end\n  end\n  return a, b\nend", "  -- Your code here!\nend", "  local\
    \ size = #numbers\n  if size <= 1 then\n    return nil\n  end\n  local closest\
    \ = {math.abs(numbers[1] - numbers[2]), 1, 2}\n  for i = 1, size - 1 do\n    for\
    \ j = i + 1, size do\n      local distance = math.abs(numbers[i] - numbers[j])\n\
    \      if distance < closest[1] then\n        closest = {distance, i, j}\n   \
    \   end\n    end\n  end\n  return numbers[closest[2]], numbers[closest[3]]\nend",
  "    if #numbers < 2 then return nil end\n    local index_for_smallest = 1\n   \
    \ local index_for_largest = 2\n    local smallest = numbers[index_for_smallest]\n\
    \    local largest = numbers[index_for_largest]\n    for i,v in ipairs(numbers)\
    \ do\n        if v < smallest then\n            index_for_smallest = i\n     \
    \       smallest = v\n        elseif v > largest then\n            index_for_largest\
    \ = i\n            largest = v\n        end\n    end\n    --if the smallest number\
    \ is duplicated, find the last instance and check the smallest numbers\n    --around\
    \ it.\n    if index_for_smallest ~= index_for_largest then\n        for i,v in\
    \ ipairs(numbers) do\n            if v == smallest then\n                index_for_smallest\
    \ = i\n            end\n        end\n        local left = numbers[index_for_smallest\
    \ - 1]\n        local right = numbers[index_for_smallest + 1]\n        if left\
    \ and right then\n            if math.abs(left - smallest) < math.abs(right -\
    \ smallest) then\n                index_for_smallest = index_for_smallest - 1\n\
    \            else\n                index_for_smallest = index_for_smallest + 1\n\
    \            end\n        elseif left then\n            index_for_smallest = index_for_smallest\
    \ - 1\n        elseif right then\n            index_for_smallest = index_for_smallest\
    \ + 1\n        end\n    end\n    return numbers[index_for_smallest], numbers[index_for_largest]\n\
    end", "  local closest_numbers = {numbers[1], numbers[2]}\n  local smallest_difference\
    \ = numbers[2] - numbers[1]\n  local number_count = #numbers\n  for i = 1, number_count\
    \ do\n    for j = i + 1, number_count do\n      local difference = numbers[j]\
    \ - numbers[i]\n      if difference < smallest_difference then\n        smallest_difference\
    \ = difference\n        closest_numbers = {numbers[i], numbers[j]}\n      end\n\
    \    end\n  end\n  return closest_numbers[1], closest_numbers[2]\nend", "    local\
    \ minimum = math.huge\n    local result\n    for i = 1, #numbers - 1 do\n    \
    \    local a = numbers[i]\n        for j = i + 1, #numbers do\n            local\
    \ b = numbers[j]\n            local dist = math.abs(a - b)\n            if dist\
    \ < minimum then\n                minimum = dist\n                result = a <\
    \ b and {a, b} or {b, a}\n            end\n        end\n    end\n    return result[1],\
    \ result[2]\nend", "    -- Track the smallest difference and the element pairs\n\
    \    local min_difference = numbers[2] - numbers[1]\n    local min_elements =\
    \ {numbers[1], numbers[2]}", "    -- if there is only one number in the list,\
    \ we can't find two closest elements\n    if #numbers == 1 then\n        return\
    \ nil\n    end", "  local i = 1\n  local j = 2\n  local smallest_difference =\
    \ 1000000.0\n  local a = numbers[i]\n  local b = numbers[j]\n  while i < #numbers\
    \ do\n    while j <= #numbers do\n      local difference = math.abs(numbers[i]\
    \ - numbers[j])\n      if difference < smallest_difference then\n        smallest_difference\
    \ = difference\n        a = numbers[i]\n        b = numbers[j]\n      end\n  \
    \    j = j + 1\n    end\n    i = i + 1\n    j = i + 1\n  end\n  return a, b\n\
    end", "  local closest = nil\n  for i, number in ipairs(numbers) do\n    for j,\
    \ other in ipairs(numbers) do\n      if j > i then\n        local distance = math.abs(number\
    \ - other)\n        if not closest or distance < closest[3] then\n          closest\
    \ = {number, other, distance}\n        end\n      end\n    end\n  end\n  return\
    \ unpack(closest)\nend", "\tlocal smallest_diff = numbers[2] - numbers[1]\n\t\
    local smallest_diff_index = {1, 2}\n\tfor i = 1, #numbers - 1 do\n\t\tlocal diff\
    \ = numbers[i + 1] - numbers[i]\n\t\tif diff < smallest_diff then\n\t\t\tsmallest_diff\
    \ = diff\n\t\t\tsmallest_diff_index = {i, i + 1}\n\t\tend\n\tend\n\treturn numbers[smallest_diff_index[1]],\
    \ numbers[smallest_diff_index[2]]\nend", "    local smallest_difference = math.huge\n\
    \    local x1, x2\n    for i = 1, #numbers - 1 do\n        local y1 = numbers[i]\n\
    \        for j = i + 1, #numbers do\n            local y2 = numbers[j]\n     \
    \       local difference = math.abs(y1 - y2)\n            if difference < smallest_difference\
    \ then\n                smallest_difference = difference\n                x1,\
    \ x2 = y1, y2\n            end\n        end\n    end\n    return x1, x2\nend",
  "    table.sort(numbers)\n    local smallest_diff = math.huge\n    local last_num\
    \ = nil\n    local current_num = nil\n    local found_numbers = {}\n    for _,num\
    \ in ipairs(numbers) do\n        if last_num then\n            local diff = num\
    \ - last_num\n            if diff < smallest_diff then\n                smallest_diff\
    \ = diff\n                found_numbers = {last_num, num}\n            end\n \
    \       end\n        last_num = num\n    end\n    return unpack(found_numbers)\n\
    end", "  local min_delta = math.huge\n  local closest_elements = {}\n  for i,\
    \ a in ipairs(numbers) do\n    for j, b in ipairs(numbers) do\n      if i ~= j\
    \ then\n        local delta = math.abs(a - b)\n        if delta < min_delta then\n\
    \          closest_elements = {a, b}\n          min_delta = delta\n        end\n\
    \      end\n    end\n  end\n  return closest_elements[1], closest_elements[2]\n\
    end", "\tlocal min_dist = math.huge\n\tlocal min_n1, min_n2\n\tfor i,n1 in ipairs(numbers)\
    \ do\n\t\tfor j,n2 in ipairs(numbers) do\n\t\t\tif i < j then\n\t\t\t\tlocal dist\
    \ = math.abs(n1 - n2)\n\t\t\t\tif dist < min_dist then\n\t\t\t\t\tmin_dist = dist\n\
    \t\t\t\t\tmin_n1 = n1\n\t\t\t\t\tmin_n2 = n2\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn math.min(min_n1, min_n2), math.max(min_n1, min_n2)\nend", "  local\
    \ lowest_difference = math.huge\n  local closest_elements = {}\n  for i = 1, #numbers\
    \ - 1 do\n    for j = i + 1, #numbers do\n      local number_1 = numbers[i]\n\
    \      local number_2 = numbers[j]\n      local difference = math.abs(number_1\
    \ - number_2)\n      if difference < lowest_difference then\n        lowest_difference\
    \ = difference\n        closest_elements = {number_1, number_2}\n      end\n \
    \   end\n  end\n  return unpack(closest_elements)\nend", "  assert(#numbers >=\
    \ 2)\n  table.sort(numbers)\n  local smallest_distance = math.huge\n  local smallest_pair\
    \ = nil\n  for i = 1, #numbers - 1 do\n    local distance = numbers[i + 1] - numbers[i]\n\
    \    if distance < smallest_distance then\n      smallest_distance = distance\n\
    \      smallest_pair = {numbers[i], numbers[i + 1]}\n    end\n  end\n  return\
    \ smallest_pair[1], smallest_pair[2]\nend", "    local closest_elements = {numbers[1],\
    \ numbers[2]}\n    local min_distance = math.abs(numbers[1] - numbers[2])\n  \
    \  for i = 1, #numbers do\n        for j = i + 1, #numbers do\n            local\
    \ distance = math.abs(numbers[i] - numbers[j])\n            if distance < min_distance\
    \ then\n                min_distance = distance\n                closest_elements\
    \ = {numbers[i], numbers[j]}\n            end\n        end\n    end\n    return\
    \ unpack(closest_elements)\nend", "    local candidate1, candidate2 = numbers[1],\
    \ numbers[2]\n    local min_diff = math.abs(candidate1 - candidate2)\n    local\
    \ len = #numbers\n    for i = 1, len - 1 do\n        for j = i + 1, len do\n \
    \           local diff = math.abs(numbers[i] - numbers[j])\n            if diff\
    \ < min_diff then\n                min_diff = diff\n                candidate1,\
    \ candidate2 = numbers[i], numbers[j]\n            end\n        end\n    end\n\
    \    return candidate1, candidate2\nend", "  local smallest_diff = math.huge\n\
    \  local smallest_val = 0\n  local largest_val = 0\n  for i = 1, #numbers do\n\
    \    for j = i + 1, #numbers do\n      local diff = math.abs(numbers[i] - numbers[j])\n\
    \      if diff < smallest_diff then\n        smallest_diff = diff\n        smallest_val\
    \ = numbers[i]\n        largest_val = numbers[j]\n      end\n    end\n  end\n\
    \  return smallest_val, largest_val\nend", "\tassert(#numbers > 1, \"List must\
    \ have at least two numbers!\")\n\tlocal temp_pair = { numbers[1], numbers[2]\
    \ }\n\tlocal min_diff = math.abs(temp_pair[1] - temp_pair[2])\n\tlocal min_pair\
    \ = temp_pair\n\tfor i = 1, #numbers - 1 do\n\t\tfor j = i + 1, #numbers do\n\t\
    \t\ttemp_pair = { numbers[i], numbers[j] }\n\t\t\tif math.abs(temp_pair[1] - temp_pair[2])\
    \ < min_diff then\n\t\t\t\tmin_diff = math.abs(temp_pair[1] - temp_pair[2])\n\t\
    \t\t\tmin_pair = temp_pair\n\t\t\tend\n\t\tend\n\tend\n\treturn min_pair[1], min_pair[2]\n\
    end", "\tassert(type(numbers) == \"table\", \"numbers must be a table\")\n\tassert(#numbers\
    \ >= 2, \"numbers must be at least two\")\n\tlocal function _fc(numbers, index)\n\
    \t\tlocal smaller = numbers[index]\n\t\tlocal greater = numbers[index + 1]\n\t\
    \tlocal diff = greater - smaller\n\t\tfor i = index + 2, #numbers do\n\t\t\tlocal\
    \ g = numbers[i]\n\t\t\tlocal d = g - smaller\n\t\t\tif diff > d then\n\t\t\t\t\
    greater = g\n\t\t\t\tdiff = d\n\t\t\tend\n\t\tend\n\t\treturn smaller, greater\n\
    \tend\n\tlocal smaller, greater = _fc(numbers, 1)\n\tfor i = 2, #numbers - 1 do\n\
    \t\tlocal s, g = _fc(numbers, i)\n\t\tlocal d = g - s\n\t\tif greater - smaller\
    \ > d then\n\t\t\tsmaller = s\n\t\t\tgreater = g\n\t\tend\n\tend\n\treturn smaller,\
    \ greater\nend", "    assert(#numbers >= 2)\n    local distance = math.huge\n\
    \    local idx = -1\n    for i = 1, #numbers - 1 do\n        local diff = math.abs(numbers[i]\
    \ - numbers[i + 1])\n        if diff < distance then\n            distance = diff\n\
    \            idx = i\n        end\n    end\n    return numbers[idx], numbers[idx\
    \ + 1]\nend", "\tlocal smallest_diff = math.huge\n\tlocal smallest_diff_pair =\
    \ { 0, 0 }\n\tfor i, x in ipairs(numbers) do\n\t\tfor j, y in ipairs(numbers)\
    \ do\n\t\t\tif i ~= j then\n\t\t\t\tlocal diff = math.abs(x - y)\n\t\t\t\tif diff\
    \ < smallest_diff then\n\t\t\t\t\tsmallest_diff = diff\n\t\t\t\t\tsmallest_diff_pair\
    \ = { x, y }\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tif smallest_diff_pair[1]\
    \ > smallest_diff_pair[2] then\n\t\treturn smallest_diff_pair[2], smallest_diff_pair[1]\n\
    \telse\n\t\treturn smallest_diff_pair[1], smallest_diff_pair[2]\n\tend\nend",
  "  local min_delta = math.huge\n  local min_prev, min_next\n  local prev, next =\
    \ nil, nil\n  for _, next in ipairs(numbers) do\n    if prev then\n      local\
    \ delta = math.abs(next - prev)\n      if delta < min_delta then\n        min_delta\
    \ = delta\n        min_prev, min_next = prev, next\n      end\n    end\n    prev\
    \ = next\n  end\n  return min_prev, min_next\nend", "  local min, a, b = math.huge\n\
    \  for i = 1, #numbers - 1 do\n    for j = i + 1, #numbers do\n      local diff\
    \ = math.abs(numbers[i] - numbers[j])\n      if diff < min then\n        min,\
    \ a, b = diff, numbers[i], numbers[j]\n      end\n    end\n  end\n  return a,\
    \ b\nend", "\tlocal result = { numbers[1], numbers[2] }\n\tlocal closest_so_far\
    \ = math.abs(numbers[1] - numbers[2])\n\tfor i = 1, #numbers do\n\t\tfor j = i\
    \ + 1, #numbers do\n\t\t\tlocal candidate = math.abs(numbers[i] - numbers[j])\n\
    \t\t\tif candidate < closest_so_far then\n\t\t\t\tclosest_so_far = candidate\n\
    \t\t\t\tresult = { numbers[i], numbers[j] }\n\t\t\tend\n\t\tend\n\tend\n\ttable.sort(result)\n\
    \treturn result[1], result[2]\nend", "    -- You need to complete this function\n\
    \    if #numbers == 2 then\n        return numbers[1], numbers[2]\n    end\n \
    \   --  local test = numbers[1] < numbers[2] and numbers[1] or numbers[2]\n  \
    \  local test = math.min(numbers[1], numbers[2])\n    local min = math.abs(numbers[1]\
    \ - numbers[2])\n    local n = #numbers\n    for i = 1, n - 1 do\n        for\
    \ j = i + 1, n do\n            if math.abs(numbers[i] - numbers[j]) < min then\n\
    \                min = math.abs(numbers[i] - numbers[j])\n                test\
    \ = numbers[i]\n            end\n        end\n    end\n    return test, test +\
    \ min\nend", "    assert(#numbers >= 2)\n    local best = numbers[1] - numbers[2]\n\
    \    local a, b = numbers[1], numbers[2]\n    for i = 1, #numbers do\n       \
    \ for j = i + 1, #numbers do\n            local x = numbers[i] - numbers[j]\n\
    \            if math.abs(x) < math.abs(best) then\n                best = x\n\
    \                a, b = numbers[i], numbers[j]\n            end\n        end\n\
    \    end\n    return a, b\nend", "    local smallest = nil\n    local smallest_diff\
    \ = nil\n    for i = 1, #numbers do\n        for j = i + 1, #numbers do\n    \
    \        local diff = math.abs(numbers[i] - numbers[j])\n            if smallest_diff\
    \ == nil or diff < smallest_diff then\n                smallest = { i, j }\n \
    \               smallest_diff = diff\n            end\n        end\n    end\n\
    \    return numbers[smallest[1]], numbers[smallest[2]]\nend", "\t-- FIXME: Here\
    \ we just sort the numbers, but since the test cases are small\n\t-- numbers we\
    \ can just use a bubble sort.\n\tnumbers = sort(numbers)\n\tlocal best_distance\
    \ = numbers[2] - numbers[1]\n\tlocal best_pair = {numbers[1], numbers[2]}\n\t\
    for i = 3, #numbers do\n\t\tlocal distance = numbers[i] - numbers[i - 1]\n\t\t\
    if distance < best_distance then\n\t\t\tbest_distance = distance\n\t\t\tbest_pair\
    \ = {numbers[i - 1], numbers[i]}\n\t\tend\n\tend\n\treturn best_pair[1], best_pair[2]\n\
    end", "  local final_one = numbers[1]\n  local final_two = numbers[2]\n  local\
    \ closest_pair = math.abs(final_one - final_two)\n  for i, num in ipairs(numbers)\
    \ do\n    for j, num2 in ipairs(numbers) do\n      if math.abs(num - num2) < closest_pair\
    \ and num ~= num2 then\n        closest_pair = math.abs(num - num2)\n        final_one\
    \ = num\n        final_two = num2\n      end\n    end\n  end\n  if final_one <\
    \ final_two then\n    return final_one, final_two\n  else\n    return final_two,\
    \ final_one\n  end\nend", "  local min_dist = math.huge\n  local min_idx = {}\n\
    \  for i = 1, #numbers - 1 do\n    for j = i + 1, #numbers do\n      local dist\
    \ = math.abs(numbers[i] - numbers[j])\n      if dist < min_dist then\n       \
    \ min_dist = dist\n        min_idx = {i, j}\n      end\n    end\n  end\n  return\
    \ numbers[min_idx[1]], numbers[min_idx[2]]\nend", "  -- Insert your code here\n\
    \  if (#numbers<2) then\n      return nil\n  end\n  local min_dist = 100000\n\
    \  local closest1, closest2\n  for i = 1, #numbers-1 do\n      local j = i+1\n\
    \      while j <= #numbers do\n          local dist = math.abs(numbers[i]-numbers[j])\n\
    \          if (dist < min_dist) then\n              min_dist = dist\n        \
    \      closest1 = numbers[i]\n              closest2 = numbers[j]\n          end\n\
    \          j = j+1\n      end\n  end\n  return closest1, closest2\nend", "   \
    \ --[[\n    TODO:\n    - sort the list\n    - go through the list and find the\
    \ minimum difference between any two elements\n    - return the elements\n   \
    \ ]]\nend", "    local last = numbers[1]\n    local closest_pair = {last, nil}\n\
    \    local min_distance = math.huge\n    for i = 2, #numbers do\n        local\
    \ diff = math.abs(last - numbers[i])\n        if diff < min_distance then\n  \
    \          min_distance = diff\n            closest_pair = {last, numbers[i]}\n\
    \        end\n        last = numbers[i]\n    end\n    if closest_pair[1] < closest_pair[2]\
    \ then\n        return closest_pair[1], closest_pair[2]\n    else\n        return\
    \ closest_pair[2], closest_pair[1]\n    end\nend", "\tlocal function abs(num)\n\
    \t\tif num < 0 then\n\t\t\treturn -num\n\t\telse\n\t\t\treturn num\n\t\tend\n\t\
    end\n\tlocal min = nil\n\tlocal min1 = nil\n\tlocal min2 = nil\n\tfor i, num1\
    \ in ipairs(numbers) do\n\t\tfor j, num2 in ipairs(numbers) do\n\t\t\tif i ~=\
    \ j then\n\t\t\t\tlocal diff = abs(num1 - num2)\n\t\t\t\tif not min or diff <\
    \ min then\n\t\t\t\t\tmin = diff\n\t\t\t\t\tmin1 = num1\n\t\t\t\t\tmin2 = num2\n\
    \t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn min1, min2\nend", "    assert(type(numbers)\
    \ == \"table\", \"argument must be a table\")\n    assert(#numbers >= 2, \"argument\
    \ must have at least two elements\")\n    local smallest_distance = math.huge\n\
    \    local first, second = nil, nil\n    local compare_count = 0\n    for i, first_number\
    \ in ipairs(numbers) do\n        for j, second_number in ipairs(numbers) do\n\
    \            if i ~= j then\n                compare_count = compare_count + 1\n\
    \                local distance = math.abs(first_number - second_number)\n   \
    \             if distance < smallest_distance then\n                    smallest_distance\
    \ = distance\n                    first, second = first_number, second_number\n\
    \                end\n            end\n        end\n    end\n    assert(first\
    \ and second, \"could not find any closest elements\")\n    return first, second,\
    \ compare_count\nend", "    -- Sort numbers by value.\n    table.sort(numbers)",
  "    --TODO\n    -- print(\"numbers: \", numbers)\n    -- print(\"len(numbers):\
    \ \", #numbers)\n    local min = numbers[1]\n    local min2 = numbers[2]\n   \
    \ for i=1, #numbers-1 do\n        local d = math.abs(numbers[i] - numbers[i+1])\n\
    \        if d < math.abs(min - min2) then\n            min, min2 = numbers[i],\
    \ numbers[i+1]\n        end\n    end\n    -- print(\"return: \", min, min2)\n\
    \    return min, min2\nend", "    local closest = numbers[1]\n    local closest_next\
    \ = numbers[2]\n    local current = numbers[1]\n    local current_next = numbers[2]\n\
    \    local difference = current_next - current\n    for i = 2, #numbers do\n \
    \       current = numbers[i]\n        current_next = numbers[i + 1]\n        local\
    \ diff = current_next - current\n        if diff < difference then\n         \
    \   closest = current\n            closest_next = current_next\n            difference\
    \ = diff\n        end\n    end\n    return closest, closest_next\nend", "    local\
    \ smallest_difference = math.huge\n    local smaller = math.huge\n    local larger\
    \ = math.huge\n    for i = 1, #numbers do\n        for j = i+1, #numbers do\n\
    \            local diff = math.abs(numbers[i] - numbers[j])\n            if diff\
    \ < smallest_difference then\n                smallest_difference = diff\n   \
    \             smaller = math.min(numbers[i], numbers[j])\n                larger\
    \ = math.max(numbers[i], numbers[j])\n            end\n        end\n    end\n\
    \    return smaller, larger\nend", "\tlocal smallest_distance = abs(numbers[1]\
    \ - numbers[2])\n\tlocal smallest_pair = numbers[1], numbers[2]\n\tfor i = 1,\
    \ #numbers - 1 do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal distance = abs(numbers[i]\
    \ - numbers[j])\n\t\t\tif distance < smallest_distance then\n\t\t\t\tsmallest_distance\
    \ = distance\n\t\t\t\tsmallest_pair = numbers[i], numbers[j]\n\t\t\tend\n\t\t\
    end\n\tend\n\t\n\treturn smallest_pair\nend", "    local element_min, element_max,\
    \ min_diff = numbers[1], numbers[1], math.huge\n    for i = 1, #numbers do\n \
    \       for j = i + 1, #numbers do\n            local diff = math.abs(numbers[i]\
    \ - numbers[j])\n            if diff < min_diff then\n                min_diff\
    \ = diff\n                element_min = numbers[i]\n                element_max\
    \ = numbers[j]\n            end\n        end\n    end\n    return element_min,\
    \ element_max\nend", "    -- TODO: Write code here.\n    -- You can change the\
    \ below line to return a different value.\n    return numbers[1], numbers[2]\n\
    end", "  local closest_elements = numbers[1], numbers[2]\n  local smallest_difference\
    \ = math.abs(numbers[1] - numbers[2])\n  for i = 1, #numbers do\n    for j = i\
    \ + 1, #numbers do\n      local difference = math.abs(numbers[i] - numbers[j])\n\
    \      if difference < smallest_difference then\n        closest_elements = numbers[i],\
    \ numbers[j]\n        smallest_difference = difference\n      end\n    end\n \
    \ end\n  return closest_elements\nend", "  assert(#numbers >= 2)\n  local smallest_value_found\
    \ = math.abs(numbers[1] - numbers[2])\n  local result = {numbers[1], numbers[2]}\n\
    \  for i = 1, #numbers do\n    for j = i + 1, #numbers do\n      local value =\
    \ math.abs(numbers[i] - numbers[j])\n      if value < smallest_value_found then\n\
    \        smallest_value_found = value\n        result = {numbers[i], numbers[j]}\n\
    \      end\n    end\n  end\n  if result[1] > result[2] then\n    result[1], result[2]\
    \ = result[2], result[1]\n  end\n  return unpack(result)\nend", "  local closest_distance\
    \ = math.huge\n  local closest_first, closest_second\n  for i = 1, #numbers -\
    \ 1 do\n    for j = i + 1, #numbers do\n      local distance = math.abs(numbers[i]\
    \ - numbers[j])\n      if distance < closest_distance then\n        closest_distance\
    \ = distance\n        closest_first = numbers[i]\n        closest_second = numbers[j]\n\
    \      end\n    end\n  end\n  return closest_first, closest_second\nend", "  \
    \  if #numbers < 2 then return end\n    table.sort(numbers)\n    -- Check first\
    \ two elements\n    local closest_pair = {numbers[1], numbers[2]}\n    local smallest_difference\
    \ = math.abs(numbers[1] - numbers[2])\n    for i = 2, #numbers - 1 do\n      \
    \  local difference = math.abs(numbers[i] - numbers[i + 1])\n        if difference\
    \ < smallest_difference then\n            closest_pair = {numbers[i], numbers[i\
    \ + 1]}\n            smallest_difference = difference\n        end\n    end\n\
    \    return unpack(closest_pair)\nend", "    local a, b, min_dist = 0, 0, math.huge\n\
    \    for i = 1, #numbers do\n        for j = i+1, #numbers do\n            local\
    \ dist = math.abs(numbers[i] - numbers[j])\n            if dist < min_dist then\n\
    \                a, b, min_dist = numbers[i], numbers[j], dist\n            end\n\
    \        end\n    end\n    return a, b\nend", "  local n = #numbers\n  assert(n\
    \ > 1, \"The supplied list must contain at least two numbers.\")\n  local i, j\
    \ = 1, 2\n  local dist = math.abs(numbers[i] - numbers[j])\n  for i = 1, n - 1\
    \ do\n    for j = i + 1, n do\n      local d = math.abs(numbers[i] - numbers[j])\n\
    \      if d < dist then\n        dist = d\n        i, j = i, j\n      end\n  \
    \  end\n  end\n  return numbers[i], numbers[j]\nend", "  -- We use a table to\
    \ store the minimum distance and the two number that\n  -- gave this distance.\n\
    \  local min_distance = {value = math.huge}\n  for _, a in ipairs(numbers) do\n\
    \    for _, b in ipairs(numbers) do\n      local distance = math.abs(a - b)\n\
    \      if distance < min_distance.value then\n        min_distance.value = distance\n\
    \        min_distance.a = a\n        min_distance.b = b\n      end\n    end\n\
    \  end\n  -- We return the two numbers in the desired order.\n  return math.min(min_distance.a,\
    \ min_distance.b), math.max(min_distance.a, min_distance.b)\nend", "\tlocal min_difference\
    \ = math.huge\n\tlocal closest_pair = nil\n\tfor i = 1, #numbers do\n\t\tfor j\
    \ = i + 1, #numbers do\n\t\t\tlocal difference = math.abs(numbers[i] - numbers[j])\n\
    \t\t\tif difference < min_difference then\n\t\t\t\tmin_difference = difference\n\
    \t\t\t\tclosest_pair = {numbers[i], numbers[j]}\n\t\t\tend\n\t\tend\n\tend\n\t\
    closest_pair[1], closest_pair[2] = math.min(closest_pair[1], closest_pair[2]),\
    \ math.max(closest_pair[1], closest_pair[2])\n\treturn closest_pair[1], closest_pair[2]\n\
    end", "  local result = {}\n  local min_delta = math.huge\n  for i = 1, #numbers\
    \ - 1 do\n    for j = i + 1, #numbers do\n      local delta = math.abs(numbers[i]\
    \ - numbers[j])\n      if delta < min_delta then\n        min_delta = delta\n\
    \        result = {numbers[i], numbers[j]}\n      end\n    end\n  end\n  return\
    \ result[1], result[2]\nend", "  -- You need to code this function!\n  return\
    \ nil, nil\nend", "  local first = numbers[1]\n  local second = numbers[2]\n \
    \ local low = first\n  local high = second\n  if low > high then\n    low = second\n\
    \    high = first\n  end\n  for i = 3, #numbers do\n    local next = numbers[i]\n\
    \    if math.abs(next - low) < math.abs(high - low) then\n      high = next\n\
    \    end\n  end\n  return low, high\nend", '    --Assert the numbe', "\tlocal\
    \ min_distance = math.huge\n\tlocal min_1, min_2\n\tfor i = 1, #numbers - 1 do\n\
    \t\tfor j = i + 1, #numbers do\n\t\t\tlocal distance = math.abs(numbers[i] - numbers[j])\n\
    \t\t\tif distance < min_distance then\n\t\t\t\tmin_distance = distance\n\t\t\t\
    \tmin_1, min_2 = numbers[i], numbers[j]\n\t\t\tend\n\t\tend\n\tend\n\treturn min_1,\
    \ min_2\nend", "  local smallest = numbers[1]\n  local largest = numbers[1]\n\
    \  local smallest_index = 1\n  local largest_index = 1\n  for i = 2, #numbers\
    \ do\n    if numbers[i] < smallest then\n      smallest = numbers[i]\n      smallest_index\
    \ = i\n    end\n    if numbers[i] > largest then\n      largest = numbers[i]\n\
    \      largest_index = i\n    end\n  end\n  if largest_index - smallest_index\
    \ == 1 then\n    return numbers[smallest_index], numbers[largest_index]\n  end\n\
    \  local number_count = #numbers\n  local find_closest_index = function(index)\n\
    \    local next_index = (index + 1) % number_count\n    local previous_index =\
    \ (index - 1) % number_count\n    if index == 0 then\n      previous_index = number_count\n\
    \    end\n    local next_value = numbers[next_index]\n    local previous_value\
    \ = numbers[previous_index]\n    local current_value = numbers[index]\n    local\
    \ distance_to_next = math.abs(next_value - current_value)\n    local distance_to_previous\
    \ = math.abs(previous_value - current_value)\n    if distance_to_next < distance_to_previous\
    \ then\n      return next_index\n    else\n      return previous_index\n    end\n\
    \  end\n  local smallest_closest_index = find_closest_index(smallest_index)\n\
    \  local largest_closest_index = find_closest_index(largest_index)\n  local smallest_closest\
    \ = numbers[smallest_closest_index]\n  local largest_closest = numbers[largest_closest_index]\n\
    \  if smallest_closest_index > largest_closest_index then\n    smallest_closest_index,\
    \ largest_closest_index = largest_closest_index, smallest_closest_index\n    smallest_closest,\
    \ largest_closest = largest_closest, smallest_closest\n  end\n  local smallest_between_index\
    \ = (smallest_clos", "  local closest = math.huge\n  local pair = {}\n  for i\
    \ = 1, #numbers - 1 do\n    for j = i + 1, #numbers do\n      local diff = math.abs(numbers[i]\
    \ - numbers[j])\n      if diff == 0 then\n        return numbers[i], numbers[j]\n\
    \      elseif diff < closest then\n        closest = diff\n        pair = {numbers[i],\
    \ numbers[j]}\n      end\n    end\n  end\n  return pair[1], pair[2]\nend", " \
    \ local num_count = table_length(numbers)\n  local min_diff = math.huge\n  local\
    \ min_num_1, min_num_2\n  for i = 1, num_count - 1 do\n    for j = i + 1, num_count\
    \ do\n      local num_1 = numbers[i]\n      local num_2 = numbers[j]\n      local\
    \ diff = math.abs(num_1 - num_2)\n      if diff < min_diff then\n        min_diff\
    \ = diff\n        min_num_1 = num_1\n        min_num_2 = num_2\n      end\n  \
    \  end\n  end\n  return min_num_1, min_num_2\nend", "    local n1, n2 = nil, nil\n\
    \    local diff = math.huge\n    for i = 1, #numbers do\n        local d1 = numbers[i]\n\
    \        for j = i + 1, #numbers do\n            local d2 = numbers[j]\n     \
    \       local abs_diff = math.abs(d1 - d2)\n            if abs_diff < diff then\n\
    \                n1, n2 = d1, d2\n                diff = abs_diff\n          \
    \  end\n        end\n    end\n    return math.min(n1, n2), math.max(n1, n2)\n\
    end", "  local min_element, min_distance\n  local last = numbers[1]\n  for _,\
    \ element in ipairs(numbers) do\n    if element ~= last then\n      local distance\
    \ = math.abs(element - last)\n      if not min_distance or distance < min_distance\
    \ then\n        min_distance = distance\n        min_element = {last, element}\n\
    \      end\n    end\n    last = element\n  end\n  return min_element[1], min_element[2]\n\
    end", "  local sorted = table.sort(numbers)\n  local closest = numbers[2] - numbers[1]\n\
    \  local close_pair = {numbers[1], numbers[2]}\n  for i=1,#numbers-1 do\n    local\
    \ current = numbers[i+1] - numbers[i]\n    if current < closest then\n      closest\
    \ = current\n      close_pair = {numbers[i], numbers[i+1]}\n    end\n  end\n \
    \ return close_pair[1], close_pair[2]\nend", "\tlocal min_distance = math.huge\n\
    \tlocal closest_elements = nil\n\tfor i, x in ipairs(numbers) do\n\t\tfor j, y\
    \ in ipairs(numbers) do\n\t\t\tif i ~= j then\n\t\t\t\tlocal dist = math.abs(x\
    \ - y)\n\t\t\t\tif dist < min_distance then\n\t\t\t\t\tmin_distance = dist\n\t\
    \t\t\t\tclosest_elements = {x, y}\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\
    table.sort(closest_elements)\n\treturn closest_elements[1], closest_elements[2]\n\
    end", "    local smallest = 1\n    local smallest_diff = numbers[1] - numbers[2]\n\
    \    for i = 2, #numbers - 1 do\n        local diff = numbers[i] - numbers[i +\
    \ 1]\n        if math.abs(diff) < math.abs(smallest_diff) then\n            smallest\
    \ = i\n            smallest_diff = diff\n        end\n    end\n    if smallest_diff\
    \ < 0 then\n        return numbers[smallest + 1], numbers[smallest]\n    else\n\
    \        return numbers[smallest], numbers[smallest + 1]\n    end\nend", "   \
    \ assert(#numbers >= 2)\n    local current_closest = math.abs(numbers[1] - numbers[2])\n\
    \    local current_closest_elements = {numbers[1], numbers[2]}\n    for i = 1,\
    \ #numbers do\n        for j = i + 1, #numbers do\n            local difference\
    \ = math.abs(numbers[i] - numbers[j])\n            if difference < current_closest\
    \ then\n                current_closest = difference\n                current_closest_elements\
    \ = {numbers[i], numbers[j]}\n            end\n        end\n    end\n    return\
    \ current_closest_elements[1], current_closest_elements[2]\nend", "  local difference\
    \ = math.huge\n  local first, second\n  for i, number in ipairs(numbers) do\n\
    \    for j, number2 in ipairs(numbers) do\n      if i ~= j then\n        local\
    \ dist = number - number2\n        if math.abs(dist) < difference then\n     \
    \     difference = math.abs(dist)\n          first = number\n          second\
    \ = number2\n        end\n      end\n    end\n  end\n  return math.min(first,\
    \ second), math.max(first, second)\nend", "\tlocal closest = math.huge\n\tlocal\
    \ closest1 = nil\n\tlocal closest2 = nil\n\tfor _,n1 in ipairs(numbers) do\n\t\
    \tfor _,n2 in ipairs(numbers) do\n\t\t\tif n1 ~= n2 then\n\t\t\t\tlocal dist =\
    \ math.abs(n1 - n2)\n\t\t\t\tif dist < closest then\n\t\t\t\t\tclosest = dist\n\
    \t\t\t\t\tclosest1 = n1\n\t\t\t\t\tclosest2 = n2\n\t\t\t\tend\n\t\t\tend\n\t\t\
    end\n\tend\n\tif closest1 > closest2 then\n\t\treturn closest2, closest1\n\telse\n\
    \t\treturn closest1, closest2\n\tend\nend", "    table.sort(numbers)\n    local\
    \ closest = nil\n    local pair = nil\n    for i = 1, #numbers - 1 do\n      \
    \  local difference = numbers[i + 1] - numbers[i]\n        if not closest or difference\
    \ < closest then\n            closest = difference\n            pair = {numbers[i],\
    \ numbers[i + 1]}\n        end\n    end\n    return pair[1], pair[2]\nend", " \
    \   assert(#numbers >= 2)\n    local smallest_difference = math.huge\n    local\
    \ answer = {numbers[1], numbers[2]}\n    for i = 1, #numbers do\n        for j\
    \ = i + 1, #numbers do\n            local difference = math.abs(numbers[i] - numbers[j])\n\
    \            if difference < smallest_difference then\n                smallest_difference\
    \ = difference\n                answer = {numbers[i], numbers[j]}\n          \
    \  end\n        end\n    end\n    return answer[1], answer[2]\nend", "    local\
    \ l, s = numbers[1], numbers[2]\n    local ds = math.abs(l - s)\n    for i = 1,\
    \ #numbers do\n        for j = i + 1, #numbers do\n            local d = math.abs(numbers[i]\
    \ - numbers[j])\n            if d < ds then\n                l, s = numbers[i],\
    \ numbers[j]\n                ds = d\n            end\n        end\n    end\n\
    \    return l, s\nend", "  -- TODO\n  return nil, nil\nend", "    local smallest_difference\
    \ = numbers[2] - numbers[1]\n    local smaller = numbers[1]\n    local larger\
    \ = numbers[2]\n    for i = 1, #numbers - 1 do\n        local second = numbers[i\
    \ + 1]\n        local difference = second - numbers[i]\n        if difference\
    \ < smallest_difference then\n            smallest_difference = difference\n \
    \           smaller = numbers[i]\n            larger = second\n        end\n \
    \   end\n    return smaller, larger\nend", "    table.sort(numbers)\n    local\
    \ smallest_difference = numbers[2] - numbers[1]\n    local number_1 = numbers[1]\n\
    \    local number_2 = numbers[2]\n    for i = 2,#numbers do\n        local difference\
    \ = numbers[i] - numbers[i-1]\n        if difference < smallest_difference then\n\
    \            smallest_difference = difference\n            number_1 = numbers[i-1]\n\
    \            number_2 = numbers[i]\n        end\n    end\n    return number_1,\
    \ number_2\nend", "    local i = 2\n    local diff = numbers[i] - numbers[i -\
    \ 1]\n    while i <= #numbers do\n        local new_diff = numbers[i] - numbers[i\
    \ - 1]\n        if new_diff < diff then\n            diff = new_diff\n       \
    \ end\n        i = i + 1\n    end\n    local i = 2\n    while i <= #numbers do\n\
    \        local new_diff = numbers[i] - numbers[i - 1]\n        if numbers.round(new_diff,\
    \ 1) == numbers.round(diff, 1) then\n            return numbers[i - 1], numbers[i]\n\
    \        end\n        i = i + 1\n    end\nend", "\tlocal sorted_numbers = {}\n\
    \tfor k, v in pairs(numbers) do\n\t\tsorted_numbers[k] = v\n\tend\n\ttable.sort(sorted_numbers)\n\
    \tlocal min_diff = math.abs(sorted_numbers[1] - sorted_numbers[2])\n\tlocal min_pair\
    \ = {sorted_numbers[1], sorted_numbers[2]}\n\tfor i = 2, #sorted_numbers do\n\t\
    \tif i == #sorted_numbers then\n\t\t\tbreak\n\t\tend\n\t\tlocal diff = math.abs(sorted_numbers[i]\
    \ - sorted_numbers[i + 1])\n\t\tif diff < min_diff then\n\t\t\tmin_diff = diff\n\
    \t\t\tmin_pair = {sorted_numbers[i], sorted_numbers[i + 1]}\n\t\tend\n\tend\n\t\
    return unpack(min_pair)\nend", "    local current_closest_distance = math.huge\n\
    \    local closest_pair = nil\n    for i = 1, #numbers do\n        for j = i +\
    \ 1, #numbers do\n            local distance = math.abs(numbers[i] - numbers[j])\n\
    \            if distance < current_closest_distance then\n                current_closest_distance\
    \ = distance\n                closest_pair = {numbers[i], numbers[j]}\n      \
    \      end\n        end\n    end\n    table.sort(closest_pair)\n    return unpack(closest_pair)\n\
    end", "    local min_difference = math.huge\n    local closest_pair = nil\n  \
    \  local first_element = numbers[1]\n    for i = 2, #numbers do\n        local\
    \ current_difference = math.abs(first_element - numbers[i])\n        if current_difference\
    \ == 0 then\n            return first_element, numbers[i]\n        elseif current_difference\
    \ < min_difference then\n            min_difference = current_difference\n   \
    \         closest_pair = first_element, numbers[i]\n        end\n    end\n   \
    \ return closest_pair\nend", "  -- Sort numbers\n  table.sort(numbers)\n  -- Store\
    \ the smallest difference (first number - second number) in difference.\n  local\
    \ difference = numbers[2] - numbers[1]\n  -- Store the two numbers in closest_numbers\n\
    \  local closest_numbers = {numbers[1], numbers[2]}\n  -- Loop through numbers,\
    \ and at each iteration, compare the difference between two adjacent numbers\n\
    \  -- with the stored difference. If the new difference is smaller than the stored\
    \ difference,\n  -- update difference to the new difference and update closest_numbers\
    \ to the two numbers.\n  for i = 2, #numbers - 1 do\n    local new_difference\
    \ = numbers[i + 1] - numbers[i]\n    if new_difference < difference then\n   \
    \   difference = new_difference\n      closest_numbers = {numbers[i], numbers[i\
    \ + 1]}\n    end\n  end\n  return unpack(closest_numbers)\nend", "    assert(#numbers\
    \ >= 2)\n    local best_distance = math.huge\n    local best_pairs = nil\n   \
    \ local pairs = nil\n    for i, a in ipairs(numbers) do\n        for j, b in ipairs(numbers)\
    \ do\n            if i ~= j then\n                local distance = math.abs(a\
    \ - b)\n                if distance < best_distance then\n                   \
    \ best_distance = distance\n                    if a > b then\n              \
    \          best_pairs = {b, a}\n                    else\n                   \
    \     best_pairs = {a, b}\n                    end\n                end\n    \
    \        end\n        end\n    end\n    return unpack(best_pairs)\nend", "  local\
    \ closest = math.huge\n  local x, y = numbers[1], numbers[2]\n  for i = 1, #numbers\
    \ do\n    for j = i + 1, #numbers do\n      local diff = math.abs(numbers[i] -\
    \ numbers[j])\n      if diff < closest then\n        closest = diff\n        x,\
    \ y = numbers[i], numbers[j]\n      end\n    end\n  end\n  return x, y\nend",
  "\tlocal a, b, dmin = numbers[1], numbers[2], math.abs(numbers[1] - numbers[2])\n\
    \tif dmin == 0 then return a, b end\n\tfor i = 2, #numbers do\n\t\tfor j = i +\
    \ 1, #numbers do\n\t\t\tlocal d = math.abs(numbers[i] - numbers[j])\n\t\t\tif\
    \ d < dmin then\n\t\t\t\ta, b, dmin = numbers[i], numbers[j], d\n\t\t\tend\n\t\
    \tend\n\tend\n\treturn a, b\nend", "    local num_1 = numbers[1]\n    local num_2\
    \ = numbers[2]\n    local closest_diff = math.abs(num_1 - num_2)\n    for i =\
    \ 1, #numbers - 1 do\n        for j = i + 1, #numbers do\n            local diff\
    \ = math.abs(numbers[i] - numbers[j])\n            if diff < closest_diff then\n\
    \                num_1 = numbers[i]\n                num_2 = numbers[j]\n    \
    \            closest_diff = diff\n            end\n        end\n    end\n    if\
    \ num_1 > num_2 then\n        return num_2, num_1\n    else\n        return num_1,\
    \ num_2\n    end\nend", "  -- Find the closest elements and return them.\n  local\
    \ closest_elements = {}\n  local temp = {}\n  local diff = math.huge\n  local\
    \ n = #numbers\n  for i = 1, n do\n    local a = numbers[i]\n    for j = i + 1,\
    \ n do\n      local b = numbers[j]\n      local d = math.abs(a - b)\n      if\
    \ d < diff then\n        diff = d\n        closest_elements = {a, b}\n      end\n\
    \    end\n  end\n  return unpack(closest_elements)\nend", "  local s = math.huge\n\
    \  local small, large\n  for i,x in ipairs(numbers) do\n    for j,y in ipairs(numbers)\
    \ do\n      if j == i then goto continue end\n      local d = math.abs(x-y)\n\
    \      if d < s then\n        s = d\n        small = math.min(x,y)\n        large\
    \ = math.max(x,y)\n      end\n      ::continue::\n    end\n  end\n  return small,\
    \ large\nend", "  local numbers_2, closest_elements = {}, {}\n  local min_distance\
    \ = math.huge\n  local numbers_length = #numbers\n  for i = 1, numbers_length\
    \ - 1 do\n    for j = i + 1, numbers_length do\n      local distance = math.abs(numbers[i]\
    \ - numbers[j])\n      if distance < min_distance then\n        min_distance =\
    \ distance\n        closest_elements = {numbers[i], numbers[j]}\n      end\n \
    \   end\n  end\n  return unpack(closest_elements)\nend", "  -- YOUR SOLUTION HERE\n\
    \tlocal a, b = 0, 0\n\tlocal num_length = #numbers\n\tlocal min_dist = math.abs(numbers[1]\
    \ - numbers[2])\n\tfor i = 1, num_length - 1 do\n\t\tfor j = i + 1, num_length\
    \ do\n\t\t\tif (math.abs(numbers[i] - numbers[j]) < min_dist) then\n\t\t\t\tmin_dist\
    \ = math.abs(numbers[i] - numbers[j])\n\t\t\t\ta = numbers[i]\n\t\t\t\tb = numbers[j]\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn a, b\nend", "  local c = math.huge\n  local\
    \ ci, cj = nil, nil\n  for i = 1, #numbers - 1 do\n    for j = i + 1, #numbers\
    \ do\n      local d = math.abs(numbers[i] - numbers[j])\n      if d < c then\n\
    \        c, ci, cj = d, i, j\n      end\n    end\n  end\n  local ni, nj = numbers[ci],\
    \ numbers[cj]\n  return ni < nj and ni or nj, ni < nj and nj or ni\nend", "  local\
    \ i = 1\n  local min_diff = math.abs(numbers[2] - numbers[1])\n  local min_elements\
    \ = {numbers[1], numbers[2]}\n  while i <= #numbers - 1 do\n    local j = i +\
    \ 1\n    while j <= #numbers do\n      local diff = math.abs(numbers[i] - numbers[j])\n\
    \      if diff < min_diff then\n        min_diff = diff\n        min_elements\
    \ = {numbers[i], numbers[j]}\n      end\n      j = j + 1\n    end\n    i = i +\
    \ 1\n  end\n  return min_elements[1], min_elements[2]\nend", "    local a, b =\
    \ numbers[1], numbers[2]\n    local smallest_diff = math.abs(a - b)\n    for i\
    \ = 1, #numbers do\n        for j = i + 1, #numbers do\n            local diff\
    \ = math.abs(numbers[i] - numbers[j])\n            if diff < smallest_diff then\n\
    \                smallest_diff = diff\n                a, b = numbers[i], numbers[j]\n\
    \            end\n        end\n    end\n    return a, b\nend", "  numbers = util.map(numbers,\
    \ tonumber)\n  table.sort(numbers)\n  local closest = math.huge\n  local closest_pair\
    \ = nil\n  for i=1,#numbers do\n    for j=i+1,#numbers do\n      local distance\
    \ = math.abs(numbers[i] - numbers[j])\n      if distance < closest then\n    \
    \    closest = distance\n        closest_pair = {numbers[i], numbers[j]}\n   \
    \   end\n    end\n  end\n  return closest_pair[1], closest_pair[2]\nend", "  \
    \  -- TODO: Write me\n    local a, b = {}, {}\n    local n = #numbers\n    for\
    \ i=1, n do\n        for j=i+1, n do\n            if math.abs(numbers[i] - numbers[j])\
    \ < math.abs(a[1] - a[2]) or math.abs(a[1] - a[2]) == 0 then\n               \
    \ a[1], a[2] = numbers[i], numbers[j]\n            end\n        end\n    end\n\
    \    return a[1], a[2]\nend", "    table.sort(numbers)\n    local min, min_index\
    \ = numbers[2] - numbers[1], 1\n    for i = 2, #numbers - 1 do\n        local\
    \ d = numbers[i + 1] - numbers[i]\n        if d < min then\n            min, min_index\
    \ = d, i\n        end\n    end\n    return numbers[min_index], numbers[min_index\
    \ + 1]\nend", "\tif #numbers < 2 then\n\t\treturn nil\n\tend\n\t\n\tlocal function\
    \ compare(a, b)\n\t\treturn math.abs(a - b)\n\tend\n\t\n\ttable.sort(numbers,\
    \ compare)\n\t\n\tlocal minimum = numbers[2] - numbers[1]\n\tlocal index = 1\n\
    \t\n\tfor i = 2, #numbers - 1 do\n\t\tlocal diff = numbers[i + 1] - numbers[i]\n\
    \t\tif diff < minimum then\n\t\t\tminimum = diff\n\t\t\tindex = i\n\t\tend\n\t\
    end\n\t\n\treturn numbers[index], numbers[index + 1]\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
