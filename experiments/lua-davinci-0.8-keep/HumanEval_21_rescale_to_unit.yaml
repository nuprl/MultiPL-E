name: HumanEval_21_rescale_to_unit
language: lua
prompt: "-- Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n-- such that the smallest number will become 0 and the largest\
  \ will become 1\n-- >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n-- [0.0, 0.25,\
  \ 0.5, 0.75, 1.0]\nlocal function rescale_to_unit(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rescale_to_unit\n\
  \    lu.assertEquals(candidate({2.0, 49.9}), {0.0, 1.0})\n    lu.assertEquals(candidate({100.0,\
  \ 49.9}), {1.0, 0.0})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}),\
  \ {0.0, 0.25, 0.5, 0.75, 1.0})\n    lu.assertEquals(candidate({2.0, 1.0, 5.0, 3.0,\
  \ 4.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\n    lu.assertEquals(candidate({12.0, 11.0,\
  \ 15.0, 13.0, 14.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local min_val = math.min(unpack(numbers))\n    local max_val =\
    \ math.max(unpack(numbers))\n    local res = {}\n    for i, v in ipairs(numbers)\
    \ do\n        res[i] = (v - min_val) / (max_val - min_val)\n    end\n    return\
    \ res\nend", "    local scale = max(numbers) - min(numbers)\n    local scaled\
    \ = map(function(e) return (e - min(numbers)) / scale end, numbers)\n    return\
    \ scaled\nend", "    local numbers_sorted = table.sort(numbers)\n    local result\
    \ = {}\n    local size = #numbers_sorted\n    local delta = 1.0 / (size - 1)\n\
    \    for i = 1, size do\n        result[i] = (i - 1) * delta\n    end\n    return\
    \ result\nend", "  local max_n = numbers[1]\n  local min_n = numbers[1]\n  for\
    \ _, n in ipairs(numbers) do\n    if n > max_n then\n      max_n = n\n    end\n\
    \    if n < min_n then\n      min_n = n\n    end\n  end\n  local rescaled = {}\n\
    \  for _, n in ipairs(numbers) do\n    table.insert(rescaled, (n - min_n) / (max_n\
    \ - min_n))\n  end\n  return rescaled\nend", "    local n = #numbers\n    local\
    \ min_val = numbers[1]\n    local max_val = numbers[1]\n    for i = 2, n do\n\
    \        min_val = math.min(min_val, numbers[i])\n        max_val = math.max(max_val,\
    \ numbers[i])\n    end\n    local denom = max_val - min_val\n    if denom ~= 0\
    \ then\n        for i = 1, n do\n            numbers[i] = (numbers[i] - min_val)\
    \ / denom\n        end\n    end\n    return numbers\nend", "    local n = #numbers\n\
    \    local min_val = min(numbers)\n    local max_val = max(numbers)\n    local\
    \ delta = max_val - min_val\n    local scaled_numbers = {}\n    for i=1,n do\n\
    \        scaled_numbers[i] = (numbers[i] - min_val) / delta\n    end\n    return\
    \ scaled_numbers\nend", "    local min, max = numbers[1], numbers[1]\n    for\
    \ _, v in ipairs(numbers) do\n        if v < min then min = v end\n        if\
    \ v > max then max = v end\n    end\n    local ranges = {}\n    for _, v in ipairs(numbers)\
    \ do\n        table.insert(ranges, (v - min) / (max - min))\n    end\n    return\
    \ ranges\nend", "    local min_number = min(numbers)\n    local max_number = max(numbers)\n\
    \    local delta = max_number - min_number\n    local result = map(\n        function(number)\n\
    \            return (number - min_number) / delta\n        end,\n        numbers\n\
    \    )\n    return result\nend", "  local min = math.min(unpack(numbers))\n  local\
    \ max = math.max(unpack(numbers))\n  local new = {}\n  for i = 1, #numbers do\n\
    \    new[i] = (numbers[i] - min) / (max - min)\n  end\n  return new\nend", " \
    \ local min = minimum(numbers)\n  local max = maximum(numbers)\n  local range\
    \ = max - min\n  return map(function(n) return (n - min) / range end, numbers)\n\
    end", "    local min_value = min(numbers)\n    local max_value = max(numbers)\n\
    \    return map(numbers, function(x) return (x - min_value) / (max_value - min_value)\
    \ end)\nend", "    assert(type(numbers) == \"table\", \"numbers must be a table\"\
    )\n    assert(#numbers >= 2, \"numbers must have at least two elements\")\n  \
    \  local res = {}\n    local lmin = math.min(unpack(numbers))\n    local lmax\
    \ = math.max(unpack(numbers))\n    for _, n in ipairs(numbers) do\n        table.insert(res,\
    \ (n - lmin) / (lmax - lmin))\n    end\n    return res\nend", "  local max = math.max(unpack(numbers))\n\
    \  local min = math.min(unpack(numbers))\n  return map(function(x) return (x -\
    \ min) / (max - min) end, numbers)\nend", "\tlocal min, max = utils.minmax(numbers)\n\
    \tif min == max then\n\t\treturn numbers\n\tend\n\tlocal zero, one = min, max\n\
    \tlocal scale = one - zero\n\treturn utils.map(numbers, function(x) return (x\
    \ - zero) / scale end)\nend", "\tassert(#numbers >= 2)\n\tlocal min = numbers[1]\n\
    \tlocal max = numbers[1]\n\tfor i = 2, #numbers do\n\t\tmin = math.min(min, numbers[i])\n\
    \t\tmax = math.max(max, numbers[i])\n\tend\n\tlocal diff = max - min\n\tlocal\
    \ result = {}\n\tfor i = 1, #numbers do\n\t\tresult[i] = (numbers[i] - min) /\
    \ diff\n\tend\n\treturn result\nend", "\tlocal max = numbers[1]\n\tlocal min =\
    \ numbers[1]\n\tlocal n = #numbers\n\tfor i = 2, n do\n\t\tif numbers[i] > max\
    \ then\n\t\t\tmax = numbers[i]\n\t\telseif numbers[i] < min then\n\t\t\tmin =\
    \ numbers[i]\n\t\tend\n\tend\n\tfor i = 1, n do\n\t\tnumbers[i] = (numbers[i]\
    \ - min) / (max - min)\n\tend\n\treturn numbers\nend", "    local min_number =\
    \ min(numbers)\n    local max_number = max(numbers)\n    local delta = max_number\
    \ - min_number\n    return map(function(n) return (n - min_number) / delta end,\
    \ numbers)\nend", "    local min_val = numbers[1]\n    local max_val = numbers[1]\n\
    \    for _, v in ipairs(numbers) do\n        if v < min_val then\n           \
    \ min_val = v\n        end\n        if v > max_val then\n            max_val =\
    \ v\n        end\n    end\n    local coeff = 1.0 / (max_val - min_val)\n    local\
    \ res = {}\n    for _, v in ipairs(numbers) do\n        table.insert(res, (v -\
    \ min_val) * coeff)\n    end\n    return res\nend", "    local min_value = min(numbers)\n\
    \    local max_value = max(numbers)\n    local factor = 1 / (max_value - min_value)\n\
    \    local ret = {}\n    for _, number in ipairs(numbers) do\n        ret[#ret\
    \ + 1] = (number - min_value) * factor\n    end\n    return ret\nend", "    local\
    \ min_value = math.min(unpack(numbers))\n    local max_value = math.max(unpack(numbers))\n\
    \    return table.map(numbers, function(value)\n        return (value - min_value)\
    \ / (max_value - min_value)\n    end)\nend", "    local min_num = math.min(unpack(numbers))\n\
    \    local max_num = math.max(unpack(numbers))\n    if (min_num == max_num) then\n\
    \        return {}\n    end\n    local rescaled = {}\n    for _, number in ipairs(numbers)\
    \ do\n        table.insert(rescaled, (number - min_num) / (max_num - min_num))\n\
    \    end\n    return rescaled\nend", "    local n = #numbers\n    local min_val\
    \ = math.min(unpack(numbers))\n    local max_val = math.max(unpack(numbers))\n\
    \    local d = max_val - min_val\n    local res = {}\n    for i = 1, n do\n  \
    \      res[i] = (numbers[i] - min_val) / d\n    end\n    return res\nend", " \
    \   local min_val = numbers[1]\n    local max_val = numbers[1]\n    for i, v in\
    \ ipairs(numbers) do\n        if v < min_val then\n            min_val = v\n \
    \       end\n        if v > max_val then\n            max_val = v\n        end\n\
    \    end\n    local diff = max_val - min_val\n    local scaled = {}\n    for i,\
    \ v in ipairs(numbers) do\n        scaled[i] = (v - min_val) / diff\n    end\n\
    \    return scaled\nend", "    local min_value = math.min(unpack(numbers))\n \
    \   local max_value = math.max(unpack(numbers))\n    local delta = max_value -\
    \ min_value\n    local rescaled = {}\n    for _, v in ipairs(numbers) do\n   \
    \     table.insert(rescaled, (v - min_value) / delta)\n    end\n    return rescaled\n\
    end", "    local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local span = max - min\n    local new_min = 0\n    local new_max = 1\n  \
    \  local new_span = new_max - new_min\n    local numbers_rescaled = {}\n    for\
    \ _, v in ipairs(numbers) do\n        local v_scaled = new_min + (v - min) * new_span\
    \ / span\n        table.insert(numbers_rescaled, v_scaled)\n    end\n    return\
    \ numbers_rescaled\nend", "    local n = #numbers\n    if n < 2 then\n       \
    \ return numbers\n    end\n    local min = numbers[1]\n    local max = numbers[1]\n\
    \    for i = 2, n do\n        if numbers[i] < min then\n            min = numbers[i]\n\
    \        elseif numbers[i] > max then\n            max = numbers[i]\n        end\n\
    \    end\n    local span = max - min\n    local result = {}\n    for i = 1, n\
    \ do\n        result[i] = (numbers[i] - min) / span\n    end\n    return result\n\
    end", "  local min = numbers[1]\n  local max = numbers[1]\n  for _, n in ipairs(numbers)\
    \ do\n    if n < min then min = n end\n    if n > max then max = n end\n  end\n\
    \  local delta = max - min\n  if delta == 0 then return numbers end\n  local rescaled\
    \ = {}\n  for _, n in ipairs(numbers) do\n    table.insert(rescaled, (n - min)\
    \ / delta)\n  end\n  return rescaled\nend", "    local n = #numbers\n    assert(n\
    \ >= 2, \"Input list must have at least two elements\")\n    local min_number\
    \ = math.min(unpack(numbers))\n    local max_number = math.max(unpack(numbers))\n\
    \    local rescaled = {}\n    for i,v in ipairs(numbers) do\n        rescaled[i]\
    \ = (v - min_number) / (max_number - min_number)\n    end\n    return rescaled\n\
    end", "    local max = math.max(unpack(numbers))\n    local min = math.min(unpack(numbers))\n\
    \    local delta = max - min\n    return map(\n        function(n)\n         \
    \   return (n - min) / delta\n        end,\n        numbers\n    )\nend", "  \
    \  local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local diff = max - min\n    local ret = {}\n    for _, v in ipairs(numbers)\
    \ do\n        ret[#ret + 1] = (v - min) / diff\n    end\n    return ret\nend",
  "  -- The input array must be non-empty\n  assert(#numbers > 0)", "    local min\
    \ = numbers[1]\n    local max = numbers[1]\n    for i = 2, #numbers do\n     \
    \   if numbers[i] < min then\n            min = numbers[i]\n        elseif numbers[i]\
    \ > max then\n            max = numbers[i]\n        end\n    end\n    local output\
    \ = {}\n    local n = #numbers\n    for i = 1, n do\n        output[i] = (numbers[i]\
    \ - min) / (max - min)\n    end\n    return output\nend", "    local result =\
    \ {}\n    local min, max = min_max(numbers)\n    for _, v in ipairs(numbers) do\n\
    \        table.insert(result, (v - min) / (max - min))\n    end\n    return result\n\
    end", "    local min = numbers[1]\n    local max = numbers[1]\n    for i = 2,\
    \ #numbers do\n        if numbers[i] < min then\n            min = numbers[i]\n\
    \        elseif numbers[i] > max then\n            max = numbers[i]\n        end\n\
    \    end\n    local result = {}\n    for i = 1, #numbers do\n        result[i]\
    \ = (numbers[i] - min) / (max - min)\n    end\n    return result\nend", "\tlocal\
    \ max = -math.huge\n\tlocal min = math.huge\n\tfor _, x in ipairs(numbers) do\n\
    \t\tmax = math.max(max, x)\n\t\tmin = math.min(min, x)\n\tend\n\tlocal scale =\
    \ 1 / (max - min)\n\tlocal result = {}\n\tfor _, x in ipairs(numbers) do\n\t\t\
    table.insert(result, (x - min) * scale)\n\tend\n\treturn result\nend", "  local\
    \ min, max = math.min(unpack(numbers)), math.max(unpack(numbers))\n  return map(function(v)\
    \ return (v - min) / (max - min) end, numbers)\nend", "    local max = numbers[1]\n\
    \    local min = numbers[1]\n    for i = 2, #numbers do\n        if numbers[i]\
    \ > max then\n            max = numbers[i]\n        end\n        if numbers[i]\
    \ < min then\n            min = numbers[i]\n        end\n    end\n    local result\
    \ = {}\n    for i = 1, #numbers do\n        result[i] = (numbers[i] - min) / (max\
    \ - min)\n    end\n    return result\nend", "    local max = numbers[1]\n    local\
    \ min = numbers[1]\n    for _, n in ipairs(numbers) do\n        if n > max then\n\
    \            max = n\n        end\n        if n < min then\n            min =\
    \ n\n        end\n    end\n    -- Assuming min is != max. If they are equal, then\
    \ all numbers in input list are the same,\n    -- so we can return the same list\
    \ back\n    local result = {}\n    for _, n in ipairs(numbers) do\n        result[#result\
    \ + 1] = (n - min) / (max - min)\n    end\n    return result\nend", "    local\
    \ min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    return rescale(numbers, min, max, 0, 1)\nend", "  local min = numbers[1]\n\
    \  local max = numbers[1]\n  for _, value in ipairs(numbers) do\n    if value\
    \ < min then\n      min = value\n    end\n    if value > max then\n      max =\
    \ value\n    end\n  end\n  local scale = 1 / (max - min)\n  local rescaled = {}\n\
    \  for _, value in ipairs(numbers) do\n    table.insert(rescaled, (value - min)\
    \ * scale)\n  end\n  return rescaled\nend", "    local min_num = numbers[1]\n\
    \    local max_num = numbers[1]\n    for _, num in ipairs(numbers) do\n      \
    \  if num < min_num then\n            min_num = num\n        end\n        if num\
    \ > max_num then\n            max_num = num\n        end\n    end\n    local rescaled\
    \ = {}\n    for _, num in ipairs(numbers) do\n        rescaled[#rescaled + 1]\
    \ = (num - min_num) / (max_num - min_num)\n    end\n    return rescaled\nend",
  "  local m = min(numbers)\n  local M = max(numbers)\n  local d = M - m\n  for i,x\
    \ in ipairs(numbers) do\n    numbers[i] = (x - m) / d\n  end\n  return numbers\n\
    end", "    local minn = min(numbers)\n    local maxx = max(numbers)\n    local\
    \ diff = maxx - minn\n    return map(function(n) return (n - minn) / diff end,\
    \ numbers)\nend", "    local min = math.min(unpack(numbers))\n    local max =\
    \ math.max(unpack(numbers))\n    local rescaled = {}\n    for _, n in ipairs(numbers)\
    \ do\n        table.insert(rescaled, (n - min) / (max - min))\n    end\n    return\
    \ rescaled\nend", "  local min = numbers[1]\n  local max = numbers[1]\n  for i\
    \ = 2, #numbers do\n    if numbers[i] < min then\n      min = numbers[i]\n   \
    \ end\n    if numbers[i] > max then\n      max = numbers[i]\n    end\n  end\n\
    \  local d = max - min\n  local unit = {}\n  for i = 1, #numbers do\n    unit[i]\
    \ = (numbers[i] - min) / d\n  end\n  return unit\nend", "    local minval = math.min(unpack(numbers))\n\
    \    local maxval = math.max(unpack(numbers))\n    local new_numbers = {}\n  \
    \  for _, num in ipairs(numbers) do\n        table.insert(new_numbers, (num -\
    \ minval) / (maxval - minval))\n    end\n    return new_numbers\nend", "    local\
    \ min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local unit = {}\n    for i = 1, #numbers do\n        unit[i] = (numbers[i]\
    \ - min) / (max - min)\n    end\n    return unit\nend", "\tlocal smallest = numbers[1]\n\
    \tlocal largest = numbers[1]\n\tfor i = 2, #numbers do\n\t\tlocal n = numbers[i]\n\
    \t\tif n < smallest then\n\t\t\tsmallest = n\n\t\telseif n > largest then\n\t\t\
    \tlargest = n\n\t\tend\n\tend\n\tlocal unit_distance = largest - smallest\n\t\
    for i = 1, #numbers do\n\t\tnumbers[i] = (numbers[i] - smallest) / unit_distance\n\
    \tend\n\treturn numbers\nend", "\tlocal min, max = min_max(numbers)\n\t\n\treturn\
    \ list.map(function(x)\n\t\treturn (x - min) / (max - min)\n\tend, numbers)\n\
    end", "    local max = math.max(unpack(numbers))\n    local min = math.min(unpack(numbers))\n\
    \    local diff = max - min\n    local ret = {}\n    for i, v in ipairs(numbers)\
    \ do\n        ret[i] = (v - min) / diff\n    end\n    return ret\nend", "    local\
    \ min_value = min(numbers)\n    local max_value = max(numbers)\n    local num_elements\
    \ = #numbers\n    local result = {}\n    for i = 1, num_elements do\n        result[i]\
    \ = (numbers[i] - min_value) / (max_value - min_value)\n    end\n    return result\n\
    end", "    local min, max = math.min(unpack(numbers)), math.max(unpack(numbers))\n\
    \    local range = max - min\n    return utils.map(function(x) return (x - min)\
    \ / range end, numbers)\nend", "    local numbers_min = math.min(unpack(numbers))\n\
    \    local numbers_max = math.max(unpack(numbers))\n    local numbers_range =\
    \ numbers_max - numbers_min\n    local numbers_new = {}\n    for _, n in ipairs(numbers)\
    \ do\n        table.insert(numbers_new, (n - numbers_min) / numbers_range)\n \
    \   end\n    return numbers_new\nend", "  local min = numbers[1]\n  local max\
    \ = numbers[1]\n  for _, number in ipairs(numbers) do\n    if number < min then\n\
    \      min = number\n    end\n    if number > max then\n      max = number\n \
    \   end\n  end\n  local scaled = {}\n  for _, number in ipairs(numbers) do\n \
    \   local new_val = (number - min) / (max - min)\n    table.insert(scaled, new_val)\n\
    \  end\n  return scaled\nend", "  local min_value = numbers[1]\n  local max_value\
    \ = numbers[1]\n  for i = 2, #numbers do\n    if numbers[i] < min_value then\n\
    \      min_value = numbers[i]\n    end\n    if numbers[i] > max_value then\n \
    \     max_value = numbers[i]\n    end\n  end\n  local result = {}\n  for i = 1,\
    \ #numbers do\n    result[i] = (numbers[i] - min_value) / (max_value - min_value)\n\
    \  end\n  return result\nend", "    local min_value = numbers[1]\n    local max_value\
    \ = numbers[1]\n    for i, number in ipairs(numbers) do\n        if number < min_value\
    \ then\n            min_value = number\n        end\n        if number > max_value\
    \ then\n            max_value = number\n        end\n    end\n    local delta\
    \ = max_value - min_value\n    local scaled_numbers = {}\n    for i, number in\
    \ ipairs(numbers) do\n        scaled_numbers[i] = (number - min_value) / delta\n\
    \    end\n    return scaled_numbers\nend", "\tlocal min = numbers[1]\n\tlocal\
    \ max = numbers[1]\n\tfor i = 2, #numbers do\n\t\tmin = math.min(min, numbers[i])\n\
    \t\tmax = math.max(max, numbers[i])\n\tend\n\tlocal denominator = (max - min)\n\
    \tif denominator == 0 then\n\t\treturn map(function (number) return number end,\
    \ numbers)\n\telse\n\t\treturn map(function (number) return (number - min) / denominator\
    \ end, numbers)\n\tend\nend", "    local a = math.min(unpack(numbers))\n    local\
    \ b = math.max(unpack(numbers))\n    local d = b - a\n    return (function()\n\
    \      local _accum_0 = { }\n      local _len_0 = 1\n      for _index_0 = 1, #numbers\
    \ do\n        local n = numbers[_index_0]\n        _accum_0[_len_0] = (n - a)\
    \ / d\n        _len_0 = _len_0 + 1\n      end\n      return _accum_0\n    end)()\n\
    \  end", "    local smallest = numbers[1]\n    local largest = numbers[1]\n  \
    \  for _, v in ipairs(numbers) do\n        if v < smallest then\n            smallest\
    \ = v\n        end\n        if v > largest then\n            largest = v\n   \
    \     end\n    end\n    local spread = largest - smallest\n    local scaled =\
    \ {}\n    for _, v in ipairs(numbers) do\n        table.insert(scaled, (v - smallest)\
    \ / spread)\n    end\n    return scaled\nend", "\tassert(numbers and #numbers\
    \ >= 2, \"at least two numbers are required for rescaling\")\n\tlocal min, max\
    \ = numbers[1], numbers[1]\n\tfor _, number in ipairs(numbers) do\n\t\tif number\
    \ < min then min = number end\n\t\tif number > max then max = number end\n\tend\n\
    \tlocal range = max - min\n\tlocal unit_values = {}\n\tfor _, number in ipairs(numbers)\
    \ do\n\t\ttable.insert(unit_values, (number - min) / range)\n\tend\n\treturn unit_values\n\
    end", "    local min = numbers[1]\n    local max = numbers[1]\n    for _, n in\
    \ ipairs(numbers) do\n        if n < min then\n            min = n\n        end\n\
    \        if n > max then\n            max = n\n        end\n    end\n    local\
    \ delta = max - min\n    local linear_transform = function(n)\n        return\
    \ (n - min) / delta\n    end\n    return List.map(linear_transform, numbers)\n\
    end", "  local result = {}\n  local min = numbers[1]\n  local max = numbers[1]\n\
    \  for _, num in ipairs(numbers) do\n    if min > num then\n      min = num\n\
    \    end\n    if max < num then\n      max = num\n    end\n  end\n  for _, num\
    \ in ipairs(numbers) do\n    local scaled = (num - min) / (max - min)\n    table.insert(result,\
    \ scaled)\n  end\n  return result\nend", "    local min_number = min(numbers)\n\
    \    local max_number = max(numbers)\n    local range = max_number - min_number\n\
    \    local new_numbers = {}\n    for i, number in ipairs(numbers) do\n       \
    \ new_numbers[i] = (number - min_number) / range\n    end\n    return new_numbers\n\
    end", "    local max_number = 0\n    local min_number = numbers[1]\n    for i\
    \ = 1, #numbers do\n        local number = numbers[i]\n        if number > max_number\
    \ then\n            max_number = number\n        end\n        if number < min_number\
    \ then\n            min_number = number\n        end\n    end\n    local scaling_factor\
    \ = 1 / (max_number - min_number)\n    local result = {}\n    for i = 1, #numbers\
    \ do\n        local number = numbers[i]\n        result[i] = (number - min_number)\
    \ * scaling_factor\n    end\n    return result\nend", "  local function rescale(min,\
    \ max, num)\n    return (num - min) / (max - min)\n  end", "    local minval =\
    \ min(numbers)\n    local maxval = max(numbers)\n    local n = #numbers\n    local\
    \ result = {}\n    for i = 1, n do\n        result[i] = (numbers[i] - minval)\
    \ / (maxval - minval)\n    end\n    return result\nend", "    local min_number\
    \ = min(numbers)\n    local max_number = max(numbers)\n    local scale = max_number\
    \ - min_number\n    local numbers_shifted = map(numbers, function(number) return\
    \ number - min_number end)\n    local numbers_rescaled = map(numbers_shifted,\
    \ function(number) return number / scale end)\n    return numbers_rescaled\nend",
  "    local min = min_in_list(numbers)\n    local max = max_in_list(numbers)\n  \
    \  local scale = max - min\n    local scaled_numbers = {}\n    for _, number in\
    \ ipairs(numbers) do\n        local scaled_number = (number - min) / scale\n \
    \       table.insert(scaled_numbers, scaled_number)\n    end\n    return scaled_numbers\n\
    end", "    local min_val = numbers[1]\n    local max_val = numbers[1]\n    for\
    \ i, v in ipairs(numbers) do\n        if v < min_val then\n            min_val\
    \ = v\n        end\n        if v > max_val then\n            max_val = v\n   \
    \     end\n    end\n    local result = {}\n    for i, v in ipairs(numbers) do\n\
    \        table.insert(result, (v - min_val) / (max_val - min_val))\n    end\n\
    \    return result\nend", "    local minimum = math.min(unpack(numbers))\n   \
    \ local maximum = math.max(unpack(numbers))\n    return map(numbers, function(x)\
    \ return (x - minimum) / (maximum - minimum) end)\nend", "    local min_value\
    \ = numbers[1]\n    local max_value = numbers[1]\n    for _, v in ipairs(numbers)\
    \ do\n        if v < min_value then\n            min_value = v\n        end\n\
    \        if v > max_value then\n            max_value = v\n        end\n    end\n\
    \    -- No need to do any rescaling if the min and max are the same\n    if min_value\
    \ == max_value then\n        return numbers\n    end\n    local rescaled = {}\n\
    \    for _, v in ipairs(numbers) do\n        rescaled[#rescaled + 1] = (v - min_value)\
    \ / (max_value - min_value)\n    end\n    return rescaled\nend", "    local n\
    \ = table.getn(numbers)\n    local max = math.max(unpack(numbers))\n    local\
    \ min = math.min(unpack(numbers))\n    local scale = max - min\n    local new_numbers\
    \ = {}\n    for i = 1, n do\n        new_numbers[i] = (numbers[i] - min) / scale\n\
    \    end\n    return new_numbers\nend", "\tlocal smallest = numbers[1]\n\tlocal\
    \ largest = numbers[1]\n\tfor _,number in ipairs(numbers) do\n\t\tif number <\
    \ smallest then\n\t\t\tsmallest = number\n\t\tend\n\t\tif number > largest then\n\
    \t\t\tlargest = number\n\t\tend\n\tend\n\tlocal range = largest - smallest\n\t\
    local normalized = {}\n\tfor _,number in ipairs(numbers) do\n\t\tnormalized[#normalized+1]\
    \ = (number - smallest) / range\n\tend\n\treturn normalized\nend", "    local\
    \ min = min_of_list(numbers)\n    local max = max_of_list(numbers)\n    local\
    \ new_numbers = {}\n    for _, number in ipairs(numbers) do\n        table.insert(new_numbers,\
    \ (number - min) / (max - min))\n    end\n    return new_numbers\nend", "\tlocal\
    \ n_max = numbers[1]\n\tlocal n_min = numbers[1]\n\tfor i,n in ipairs(numbers)\
    \ do\n\t\tif n > n_max then n_max = n end\n\t\tif n < n_min then n_min = n end\n\
    \tend\n\tlocal slope = 1.0 / (n_max - n_min)\n\tlocal y_intercept = -slope * n_min\n\
    \tlocal rescaled = {}\n\tfor i,n in ipairs(numbers) do\n\t\trescaled[i] = slope\
    \ * n + y_intercept\n\tend\n\treturn rescaled\nend", "    assert(#numbers >= 2)\n\
    \    local min_n = numbers[1]\n    local max_n = numbers[1]\n    for _, n in ipairs(numbers)\
    \ do\n        if n < min_n then\n            min_n = n\n        end\n        if\
    \ n > max_n then\n            max_n = n\n        end\n    end\n    local f = 1\
    \ / (max_n - min_n)\n    return array.map(numbers, function(x) return (x - min_n)\
    \ * f end)\nend", "  local min = numbers[1]\n  local max = numbers[1]\n  for i,v\
    \ in ipairs(numbers) do\n    if v > max then max = v end\n    if v < min then\
    \ min = v end\n  end\n  local scale = 1.0 / (max - min)\n  local result = {}\n\
    \  for i,v in ipairs(numbers) do\n    result[i] = (v - min) * scale\n  end\n \
    \ return result\nend", "  local min = numbers[1]\n  local max = numbers[1]\n \
    \ for i, n in ipairs(numbers) do\n    if n < min then min = n end\n    if n >\
    \ max then max = n end\n  end\n  local diff = max - min\n  local normalized =\
    \ {}\n  for i, n in ipairs(numbers) do\n    local norm = (n - min) / diff\n  \
    \  normalized[i] = norm\n  end\n  return normalized\nend", "    local min = numbers[1]\n\
    \    local max = numbers[1]\n    for i = 2, #numbers do\n        if numbers[i]\
    \ < min then\n            min = numbers[i]\n        elseif numbers[i] > max then\n\
    \            max = numbers[i]\n        end\n    end\n    local result = {}\n \
    \   for i = 1, #numbers do\n        result[i] = (numbers[i] - min) / (max - min)\n\
    \    end\n    return result\nend", "    local min = math.min(unpack(numbers))\n\
    \    local max = math.max(unpack(numbers))\n    local range = max - min\n    if\
    \ range == 0 then\n        -- Arbitrary shift to prevent division by zero\n  \
    \      range = 1\n    end\n    local rescaled = {}\n    for i,v in ipairs(numbers)\
    \ do\n        rescaled[i] = (v - min) / range\n    end\n    return rescaled\n\
    end", "  local min = math.min(unpack(numbers))\n  local max = math.max(unpack(numbers))\n\
    \  local scale = max - min\n  local result = {}\n  for _, x in ipairs(numbers)\
    \ do\n    table.insert(result, (x - min) / scale)\n  end\n  return result\nend",
  "    local xmin = min(numbers)\n    local xmax = max(numbers)\n    local xrange\
    \ = xmax - xmin\n    local rescaled = {}\n    for _, x in ipairs(numbers) do\n\
    \        table.insert(rescaled, (x - xmin) / xrange)\n    end\n    return rescaled\n\
    end", "    local max_value = math.max(unpack(numbers))\n    local min_value =\
    \ math.min(unpack(numbers))\n    local range = max_value - min_value\n    if range\
    \ == 0 then\n        return { [1] = 0.5, [2] = 0.5, [3] = 0.5, [4] = 0.5, [5]\
    \ = 0.5 }\n    end\n    local result = {}\n    for _, value in ipairs(numbers)\
    \ do\n        table.insert(result, (value - min_value) / range)\n    end\n   \
    \ return result\nend", "    local min_num = math.min(unpack(numbers))\n    local\
    \ max_num = math.max(unpack(numbers))\n    local range = max_num - min_num\n \
    \   local transformed = {}\n    for _, num in ipairs(numbers) do\n        transformed[#transformed\
    \ + 1] = (num - min_num) / range\n    end\n    return transformed\nend", "   \
    \ local min = min(numbers)\n    local max = max(numbers)\n    if (min == max)\
    \ then\n        return numbers\n    end\n    local scale = 1 / (max - min)\n \
    \   local result = {}\n    for _, n in ipairs(numbers) do\n        table.insert(result,\
    \ (n - min) * scale)\n    end\n    return result\nend", "    local min_number\
    \ = numbers[1]\n    local max_number = numbers[1]\n    for i = 2, #numbers do\n\
    \        min_number = math.min(min_number, numbers[i])\n        max_number = math.max(max_number,\
    \ numbers[i])\n    end\n    local scale = 1 / (max_number - min_number)\n    local\
    \ function f(n)\n        return (n - min_number) * scale\n    end\n    return\
    \ List.map(f, numbers)\nend", "\tlocal max, min = math.max(unpack(numbers)), math.min(unpack(numbers))\n\
    \treturn fmap(function(x) return (x - min) / (max - min) end, numbers)\nend",
  "    local max = math.max(unpack(numbers))\n    local min = math.min(unpack(numbers))\n\
    \    local new_numbers = {}\n    for _, v in ipairs(numbers) do\n        local\
    \ new_number = (v - min) / (max - min)\n        table.insert(new_numbers, new_number)\n\
    \    end\n    return new_numbers\nend", "    local min, max = numbers[1], numbers[1]\n\
    \    for _, n in ipairs(numbers) do\n        if n < min then min = n end\n   \
    \     if n > max then max = n end\n    end\n    local range = max - min\n    if\
    \ range < 0.00001 then\n        return numbers\n    end\n    local rescaled =\
    \ {}\n    for _, n in ipairs(numbers) do\n        table.insert(rescaled, (n -\
    \ min) / range)\n    end\n    return rescaled\nend", "  local min = numbers[1]\n\
    \  local max = numbers[1]\n  for _, number in ipairs(numbers) do\n    if number\
    \ < min then\n      min = number\n    end\n    if number > max then\n      max\
    \ = number\n    end\n  end\n  local scale = max - min\n  local result = {}\n \
    \ for _, number in ipairs(numbers) do\n    table.insert(result, (number - min)\
    \ / scale)\n  end\n  return result\nend", "    local min = min_number(numbers)\n\
    \    local max = max_number(numbers)\n    local range = max - min\n    return\
    \ map(lambda(numbers, function(i, x)\n        return (x - min) / range\n    end))\n\
    end", "  local _, max_in_list = max(numbers)\n  local _, min_in_list = min(numbers)\n\
    \  local range = max_in_list - min_in_list\n  return map(\n    function(number)\n\
    \      return (number - min_in_list) / range\n    end,\n    numbers\n  )\nend",
  "  local min, max = vec.min(numbers), vec.max(numbers)\n  local l, u = 0, 1\n  local\
    \ a = (u - l) / (max - min)\n  local b = l - a * min\n  return vec.map(function(x)\
    \ return a * x + b end, numbers)\nend", "  local min_number = math.min(unpack(numbers))\n\
    \  local max_number = math.max(unpack(numbers))\n  local scale = max_number -\
    \ min_number\n  local rescaled_numbers = {}\n  for i, number in ipairs(numbers)\
    \ do\n    table.insert(rescaled_numbers, (number - min_number) / scale)\n  end\n\
    \  return rescaled_numbers\nend", "    assert(#numbers >= 2)\n    local min =\
    \ math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n    local\
    \ delta = max - min\n    local result = {}\n    for i, v in ipairs(numbers) do\n\
    \        table.insert(result, (v - min) / delta)\n    end\n    return result\n\
    end", "    local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    return numbers:map(function(v) return (v - min) / (max - min) end)\nend",
  "  local min_number = math.min(unpack(numbers))\n  local max_number = math.max(unpack(numbers))\n\
    \  local rescaled_numbers = {}\n  for i, number in ipairs(numbers) do\n    rescaled_numbers[i]\
    \ = (number - min_number) / (max_number - min_number)\n  end\n  return rescaled_numbers\n\
    end", "  local min = min(numbers)\n  local max = max(numbers)\n  local range =\
    \ max - min\n  return map(\n    function(x)\n      return (x - min) / range\n\
    \    end,\n    numbers\n  )\nend", "    assert(#numbers >= 2)\n    local min,\
    \ max = math.min(unpack(numbers)), math.max(unpack(numbers))\n    local scaled\
    \ = {}\n    for _, value in ipairs(numbers) do\n        scaled[#scaled + 1] =\
    \ (value - min) / (max - min)\n    end\n    return scaled\nend", "\tassert(numbers)\n\
    \tassert(#numbers >= 2)\n\tassert(type(numbers) == \"table\")\n\tfor i = 1, #numbers\
    \ do\n\t\tassert(type(numbers[i]) == \"number\")\n\tend\n\tlocal min = numbers[1]\n\
    \tlocal max = numbers[1]\n\tfor i = 2, #numbers do\n\t\tmin = math.min(min, numbers[i])\n\
    \t\tmax = math.max(max, numbers[i])\n\tend\n\tassert(min ~= max)\n\tlocal result\
    \ = {}\n\tfor i = 1, #numbers do\n\t\tresult[i] = (numbers[i] - min) / (max -\
    \ min)\n\tend\n\treturn result\nend", "  local min = math.min(unpack(numbers))\n\
    \  local max = math.max(unpack(numbers))\n  local result = {}\n  for i, n in ipairs(numbers)\
    \ do\n    result[i] = (n - min) / (max - min)\n  end\n  return result\nend", " \
    \ local max_number = _.max(numbers)\n  local min_number = _.min(numbers)\n  return\
    \ _.map(numbers, function(x) return (x - min_number) / (max_number - min_number)\
    \ end)\nend", "  local min = numbers[1]\n  local max = numbers[1]\n  for i, number\
    \ in ipairs(numbers) do\n    if number < min then\n      min = number\n    end\n\
    \    if number > max then\n      max = number\n    end\n  end\n  local diff =\
    \ max - min\n  local result = {}\n  for i, number in ipairs(numbers) do\n    result[i]\
    \ = (number - min) / diff\n  end\n  return result\nend", "  local mn, mx = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n  local n = #numbers\n  local ret = {}\n  for i =\
    \ 1, n do\n    ret[i] = (numbers[i] - mn) / (mx - mn)\n  end\n  return ret\nend",
  "    local min, max = math.min(unpack(numbers)), math.max(unpack(numbers))\n   \
    \ local range = max - min\n    local unit = {}\n    for _, number in ipairs(numbers)\
    \ do\n        unit[#unit + 1] = (number - min) / range\n    end\n    return unit\n\
    end", "\tlocal min = numbers[1]\n\tlocal max = numbers[1]\n\tfor i = 2, #numbers\
    \ do\n\t\tif numbers[i] < min then\n\t\t\tmin = numbers[i]\n\t\telseif numbers[i]\
    \ > max then\n\t\t\tmax = numbers[i]\n\t\tend\n\tend\n\tlocal range = max - min\n\
    \tlocal r = {}\n\tfor i = 1, #numbers do\n\t\tr[i] = (numbers[i] - min) / range\n\
    \tend\n\treturn r\nend", "  local min, max = math.min(unpack(numbers)), math.max(unpack(numbers))\n\
    \  local result = {}\n  for _, v in ipairs(numbers) do\n    table.insert(result,\
    \ (v - min) / (max - min))\n  end\n  return result\nend", "    -- find min and\
    \ max\n    local min = numbers[1]\n    local max = numbers[1]\n    for i = 2,\
    \ #numbers do\n        if numbers[i] < min then\n            min = numbers[i]\n\
    \        end\n        if numbers[i] > max then\n            max = numbers[i]\n\
    \        end\n    end\n    -- linear mapping between [min, max] and [0, 1]\n \
    \   local result = {}\n    for i = 1, #numbers do\n        result[i] = (numbers[i]\
    \ - min) / (max - min)\n    end\n    return result\nend", "    local min = numbers[1]\n\
    \    local max = numbers[1]\n    for _, n in ipairs(numbers) do\n        if n\
    \ < min then\n            min = n\n        end\n        if n > max then\n    \
    \        max = n\n        end\n    end\n    if max - min < epsilon then\n    \
    \    -- degenerate case\n        return { 0.5 }\n    end\n    local a = 1.0 /\
    \ (max - min)\n    local b = -min * a\n    local result = {}\n    for _, n in\
    \ ipairs(numbers) do\n        table.insert(result, a * n + b)\n    end\n    return\
    \ result\nend", "    local max = numbers[1]\n    local min = numbers[1]\n    for\
    \ i = 2, #numbers do\n        max = math.max(max, numbers[i])\n        min = math.min(min,\
    \ numbers[i])\n    end\n    local result = {}\n    for i = 1, #numbers do\n  \
    \      table.insert(result, (numbers[i] - min) / (max - min))\n    end\n    return\
    \ result\nend", "    local min_value = numbers[1]\n    local max_value = numbers[1]\n\
    \    for i = 2, #numbers do\n        min_value = math.min(min_value, numbers[i])\n\
    \        max_value = math.max(max_value, numbers[i])\n    end\n    local range\
    \ = max_value - min_value\n    if range == 0 then\n        return numbers\n  \
    \  end\n    for i = 1, #numbers do\n        numbers[i] = (numbers[i] - min_value)\
    \ / range\n    end\n    return numbers\nend", "    local minv = min(numbers)\n\
    \    local maxv = max(numbers)\n    return map(function(x) return (x - minv) /\
    \ (maxv - minv) end, numbers)\nend", "  assert(#numbers >= 2)\n  local min = min_number(numbers)\n\
    \  local max = max_number(numbers)\n  assert(min < max)\n  local range = max -\
    \ min\n  local result = {}\n  for i, v in ipairs(numbers) do\n    result[i] =\
    \ (v - min) / range\n  end\n  return result\nend", "\tlocal min, max = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n\treturn fp.map(numbers, function(x) return (x -\
    \ min) / (max - min) end)\nend", "    local max_number = _.max(numbers)\n    local\
    \ min_number = _.min(numbers)\n    local ret = {}\n    local range = max_number\
    \ - min_number\n    for _, number in ipairs(numbers) do\n        ret[#ret + 1]\
    \ = (number - min_number) / range\n    end\n    return ret\nend", "    local numbers_min\
    \ = math.min(unpack(numbers))\n    local numbers_max = math.max(unpack(numbers))\n\
    \    local numbers_delta = numbers_max - numbers_min\n    return fun.map(function(number)\n\
    \        return (number - numbers_min) / numbers_delta\n    end, numbers)\nend",
  "    local min_val = math.min(unpack(numbers))\n    local max_val = math.max(unpack(numbers))\n\
    \    local res = {}\n    for _, v in ipairs(numbers) do\n        table.insert(res,\
    \ (v - min_val) / (max_val - min_val))\n    end\n    return res\nend", "    --[[\n\
    \        >>> numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n        >>> numbers = [3.0,\
    \ 4.0, 5.0, 6.0, 7.0]\n        >>> numbers = [2.0, 3.0, 4.0, 5.0, 6.0]\n     \
    \   >>> numbers = [4.0, 3.0, 2.0, 1.0, 0.0]\n        >>> numbers = [3.0, 2.0,\
    \ 1.0, 0.0, -1.0]\n        >>> numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n        >>>\
    \ numbers = [2.0, 3.0, 4.0, 5.0, 6.0]\n        >>> numbers = [0.0, 1.0, 2.0, 3.0,\
    \ 4.0]\n        >>> numbers = [1.0, 0.0, -1.0, -2.0, -3.0]\n        >>> numbers\
    \ = [2.0, 1.0, 0.0, -1.0, -2.0]\n        >>> numbers = [3.0, 2.0, 1.0, 0.0, -1.0]\n\
    \        >>> numbers = [4.0, 3.0, 2.0, 1.0, 0.0]\n        >>> numbers = [5.0,\
    \ 4.0, 3.0, 2.0, 1.0]\n        >>> numbers = [6.0, 5.0, 4.0, 3.0, 2.0]\n     \
    \   >>> numbers = [7.0, 6.0, 5.0, 4.0, 3.0]\n        >>> numbers = [8.0, 7.0,\
    \ 6.0, 5.0, 4.0]\n        >>> numbers = [5.0, 4.0, 3.0, 2.0, 1.0]\n        >>>\
    \ numbers = [4.0, 3.0, 2.0, 1.0, 0.0]\n        >>> numbers = [3.0, 2.0, 1.0, 0.0,\
    \ -1.0]\n        >>> numbers = [", "    local min = min(numbers)\n    local max\
    \ = max(numbers)\n    return map(function(x) return (x - min) / (max - min) end,\
    \ numbers)\nend", "\tlocal min = numbers[1]\n\tlocal max = numbers[1]\n\tfor _,\
    \ n in ipairs(numbers) do\n\t\tif n < min then\n\t\t\tmin = n\n\t\tend\n\t\tif\
    \ n > max then\n\t\t\tmax = n\n\t\tend\n\tend\n\tlocal range = max - min\n\treturn\
    \ ffi.new(\"double[?]\", #numbers, {\n\t\t(numbers[1] - min) / range,\n\t\t(numbers[2]\
    \ - min) / range,\n\t\t(numbers[3] - min) / range,\n\t\t(numbers[4] - min) / range,\n\
    \t\t(numbers[5] - min) / range,\n\t})\nend", "  local min = math.min(unpack(numbers))\n\
    \  local max = math.max(unpack(numbers))\n  local l = {}\n  for i = 1, #numbers\
    \ do\n    l[i] = (numbers[i] - min) / (max - min)\n  end\n  return l\nend", "\t\
    local max = numbers[1]\n\tlocal min = numbers[1]\n\tfor _, num in ipairs(numbers)\
    \ do\n\t\tif num > max then\n\t\t\tmax = num\n\t\tend\n\t\tif num < min then\n\
    \t\t\tmin = num\n\t\tend\n\tend\n\tlocal span = max - min\n\tlocal scale = 1 /\
    \ span\n\tlocal new_numbers = {}\n\tfor _, num in ipairs(numbers) do\n\t\ttable.insert(new_numbers,\
    \ (num - min) * scale)\n\tend\n\treturn new_numbers\nend", "    local min, max\
    \ = numbers[1], numbers[1]\n    for _, n in ipairs(numbers) do\n        if n <\
    \ min then min = n end\n        if n > max then max = n end\n    end\n    local\
    \ l = {}\n    for _, n in ipairs(numbers) do\n        table.insert(l, (n - min)\
    \ / (max - min))\n    end\n    return l\nend", "    local min = numbers[1]\n \
    \   local max = numbers[1]\n    for i = 2, #numbers do\n        if numbers[i]\
    \ < min then\n            min = numbers[i]\n        elseif numbers[i] > max then\n\
    \            max = numbers[i]\n        end\n    end\n    local scale = 1 / (max\
    \ - min)\n    local result = {}\n    for i = 1, #numbers do\n        result[i]\
    \ = (numbers[i] - min) * scale\n    end\n    return result\nend", "    local min\
    \ = min(numbers)\n    local max = max(numbers)\n    return array.map(numbers,\
    \ function(x) return x - min end, function(x) return x / (max - min) end)\nend",
  "    local max_element = math.max(unpack(numbers))\n    local min_element = math.min(unpack(numbers))\n\
    \    for i = 1, #numbers do\n        numbers[i] = (numbers[i] - min_element) /\
    \ (max_element - min_element)\n    end\n    return numbers\nend", "    local min_number\
    \ = numbers[1]\n    local max_number = numbers[1]\n    for _, number in ipairs(numbers)\
    \ do\n        if number < min_number then\n            min_number = number\n \
    \       end\n        if number > max_number then\n            max_number = number\n\
    \        end\n    end\n    local scaled_numbers = {}\n    for _, number in ipairs(numbers)\
    \ do\n        table.insert(scaled_numbers, (number - min_number) / (max_number\
    \ - min_number))\n    end\n    return scaled_numbers\nend", "    local values\
    \ = torch.Tensor(numbers)\n    local max_number = torch.max(values)\n    local\
    \ min_number = torch.min(values)\n    if max_number == min_number then\n     \
    \   return torch.ones(values:size()) * (1 / (#numbers + 1))\n    end\n    return\
    \ (values - min_number) / (max_number - min_number)\nend", "  local mi = numbers[1]\n\
    \  local ma = numbers[1]\n  for i, v in ipairs(numbers) do\n    if v < mi then\
    \ mi = v end\n    if v > ma then ma = v end\n  end\n  for i, v in ipairs(numbers)\
    \ do\n    numbers[i] = (v - mi) / (ma - mi)\n  end\n  return numbers\nend", " \
    \   local n = #numbers\n    local min = numbers[1]\n    local max = numbers[1]\n\
    \    for i = 2, n do\n        min = math.min(min, numbers[i])\n        max = math.max(max,\
    \ numbers[i])\n    end\n    local unit = {}\n    local a = 1 / (max - min)\n \
    \   local b = -min * a\n    for i = 1, n do\n        unit[i] = a * numbers[i]\
    \ + b\n    end\n    return unit\nend", "    local min_number = numbers[1]\n  \
    \  local max_number = numbers[1]\n    for i, num in ipairs(numbers) do\n     \
    \   if num < min_number then\n            min_number = num\n        end\n    \
    \    if num > max_number then\n            max_number = num\n        end\n   \
    \ end\n    local result = {}\n    for i, num in ipairs(numbers) do\n        result[i]\
    \ = (num - min_number) / (max_number - min_number)\n    end\n    return result\n\
    end", "    local min = numbers[1]\n    local max = numbers[1]\n    for i = 2,\
    \ #numbers do\n        if numbers[i] < min then\n            min = numbers[i]\n\
    \        elseif numbers[i] > max then\n            max = numbers[i]\n        end\n\
    \    end\n    local ret = {}\n    for i = 1, #numbers do\n        ret[i] = (numbers[i]\
    \ - min) / (max - min)\n    end\n    return ret\nend", "  local min_value = numbers[1]\n\
    \  local max_value = numbers[1]\n  for i = 2, #numbers do\n    if numbers[i] <\
    \ min_value then\n      min_value = numbers[i]\n    end\n    if numbers[i] > max_value\
    \ then\n      max_value = numbers[i]\n    end\n  end\n  local range = max_value\
    \ - min_value\n  local rescaled = {}\n  for i = 1, #numbers do\n    rescaled[i]\
    \ = (numbers[i] - min_value) / range\n  end\n  return rescaled\nend", "    local\
    \ nmin = math.min(unpack(numbers))\n    local nmax = math.max(unpack(numbers))\n\
    \    local result = {}\n    for _, number in ipairs(numbers) do\n        result[#result\
    \ + 1] = (number - nmin) / (nmax - nmin)\n    end\n    return result\nend", "\t\
    local min_n, max_n = math.min(unpack(numbers)), math.max(unpack(numbers))\n\t\
    local scale_factor = 1.0 / (max_n - min_n)\n\treturn map(function(number) return\
    \ (number - min_n) * scale_factor end, numbers)\nend", "  assert(#numbers >= 2)\n\
    \  local min = math.min(unpack(numbers))\n  local max = math.max(unpack(numbers))\n\
    \  local range = max - min\n  local rescaled = {}\n  for _, n in ipairs(numbers)\
    \ do\n    local rescaled_n = (n - min) / range\n    table.insert(rescaled, rescaled_n)\n\
    \  end\n  return rescaled\nend", "    local minn = math.min(unpack(numbers))\n\
    \    local maxx = math.max(unpack(numbers))\n    local scale = maxx - minn\n \
    \   local result = {}\n    for _, number in ipairs(numbers) do\n        table.insert(result,\
    \ (number - minn) / scale)\n    end\n    return result\nend", "    -- assert(#numbers\
    \ >= 2)\n    local min = numbers[1]\n    local max = numbers[1]\n    for _,v in\
    \ ipairs(numbers) do\n        if v < min then min = v end\n        if v > max\
    \ then max = v end\n    end\n    local scale = 1.0 / (max - min)\n    local res\
    \ = {}\n    for _,v in ipairs(numbers) do\n        table.insert(res, (v - min)\
    \ * scale)\n    end\n    return res\nend", "    local len = #numbers\n    if len\
    \ < 2 then\n        error(\"list of numbers must contain at least two elements\"\
    )\n    end\n    local min, max = numbers[1], numbers[1]\n    for i = 2, len do\n\
    \        if numbers[i] < min then\n            min = numbers[i]\n        elseif\
    \ numbers[i] > max then\n            max = numbers[i]\n        end\n    end\n\
    \    local max_min_dif = max - min\n    if max_min_dif == 0 then\n        error(\"\
    all numbers are the same\")\n    end\n    local rescaled = {}\n    for i = 1,\
    \ len do\n        rescaled[i] = (numbers[i] - min) / max_min_dif\n    end\n  \
    \  return rescaled\nend", "    local max = numbers[1]\n    local min = numbers[1]\n\
    \    for _,num in ipairs(numbers) do\n        if num > max then max = num end\n\
    \        if num < min then min = num end\n    end\n    local scale = 1 / (max\
    \ - min)\n    local res = {}\n    for _,num in ipairs(numbers) do\n        table.insert(res,\
    \ (num - min) * scale)\n    end\n    return res\nend", "    local min, max = numbers[1],\
    \ numbers[1]\n    for _, number in ipairs(numbers) do\n        if number < min\
    \ then\n            min = number\n        elseif number > max then\n         \
    \   max = number\n        end\n    end\n    local difference = max - min\n   \
    \ if difference == 0 then\n        return numbers\n    end\n    local scaled =\
    \ {}\n    for _, number in ipairs(numbers) do\n        scaled[#scaled + 1] = (number\
    \ - min) / difference\n    end\n    return scaled\nend", "  local min = min_number(numbers)\n\
    \  local max = max_number(numbers)\n  local delta = max - min\n  if (delta < 1e-10)\
    \ then\n    return nil\n  end\n  return map(function(v) return (v - min) / delta\
    \ end, numbers)\nend", "  local result = {}\n  local max_val = numbers[1]\n  local\
    \ min_val = numbers[1]\n  for i, val in ipairs(numbers) do\n    if val > max_val\
    \ then\n      max_val = val\n    end\n    if val < min_val then\n      min_val\
    \ = val\n    end\n  end\n  local delta = max_val - min_val\n  for i, val in ipairs(numbers)\
    \ do\n    result[i] = (val - min_val) / delta\n  end\n  return result\nend", " \
    \ local min = min(numbers)\n  local max = max(numbers)\n  local scale = max -\
    \ min\n  local offset = min", "    local mn, mx = math.min(unpack(numbers)), math.max(unpack(numbers))\n\
    \    local diff = mx - mn\n    return diff > 0 and map(function(x) return (x -\
    \ mn) / diff end, numbers) or numbers\nend", "    local min, max = min_max(numbers)\n\
    \    return map(function(x) return (x - min) / (max - min) end, numbers)\nend",
  "    -- We scale the data so that 0 is the minimum and 1 is the maximum\n    local\
    \ min = numbers[1]\n    local max = numbers[1]\n    for _, v in ipairs(numbers)\
    \ do\n        if v < min then\n            min = v\n        end\n        if v\
    \ > max then\n            max = v\n        end\n    end\n    local result = {}\n\
    \    local range = max - min\n    for _, v in ipairs(numbers) do\n        table.insert(result,\
    \ (v - min) / range)\n    end\n    return result\nend", "    local min_value =\
    \ min(numbers)\n    local max_value = max(numbers)\n    local range = max_value\
    \ - min_value\n    local result = {}\n    for i, number in ipairs(numbers) do\n\
    \        result[i] = (number - min_value) / range\n    end\n    return result\n\
    end", "    local max = numbers[1]\n    local min = numbers[1]\n    for _, number\
    \ in ipairs(numbers) do\n        max = math.max(max, number)\n        min = math.min(min,\
    \ number)\n    end\n    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        table.insert(result, (number - min) / (max - min))\n    end\n  \
    \  return result\nend", "    local min, max = math.min(unpack(numbers)), math.max(unpack(numbers))\n\
    \    local scale = 1 / (max - min)\n    return _.map(numbers, function(n) return\
    \ (n - min) * scale end)\nend", "  local min = math.min(unpack(numbers))\n  local\
    \ max = math.max(unpack(numbers))\n  local rescaled = {}\n  for _, value in ipairs(numbers)\
    \ do\n    table.insert(rescaled, (value - min) / (max - min))\n  end\n  return\
    \ rescaled\nend", "    local min, max = math.min(unpack(numbers)), math.max(unpack(numbers))\n\
    \    local result = {}\n    for i = 1, #numbers do\n        result[i] = (numbers[i]\
    \ - min) / (max - min)\n    end\n    return result\nend", "    local max, min\
    \ = -math.huge, math.huge\n    for _, number in ipairs(numbers) do\n        if\
    \ number > max then\n            max = number\n        end\n        if number\
    \ < min then\n            min = number\n        end\n    end\n    local factor\
    \ = 1 / (max - min)\n    local rescaled = {}\n    for _, number in ipairs(numbers)\
    \ do\n        table.insert(rescaled, (number - min) * factor)\n    end\n    return\
    \ rescaled\nend", "  local min = numbers[1]\n  local max = numbers[1]\n  for i\
    \ = 2, #numbers do\n    if numbers[i] < min then\n      min = numbers[i]\n   \
    \ end\n    if numbers[i] > max then\n      max = numbers[i]\n    end\n  end\n\
    \  local rescaled = {}\n  for i = 1, #numbers do\n    rescaled[i] = (numbers[i]\
    \ - min) / (max - min)\n  end\n  return rescaled\nend", "    local m, M = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n    local scale_factor = 1.0 / (M - m)\n    local\
    \ scaled_numbers = {}\n    for i, n in ipairs(numbers) do\n        table.insert(scaled_numbers,\
    \ scale_factor * (n - m))\n    end\n    return scaled_numbers\nend", "  local\
    \ result = {}\n  local offset = math.min(unpack(numbers))\n  local scale = math.max(unpack(numbers))\
    \ - offset\n  for i, v in ipairs(numbers) do\n    result[i] = (v - offset) / scale\n\
    \  end\n  return result\nend", "    local min_number = numbers[1]\n    local max_number\
    \ = numbers[1]\n    for _, n in ipairs(numbers) do\n        if n < min_number\
    \ then\n            min_number = n\n        end\n        if n > max_number then\n\
    \            max_number = n\n        end\n    end\n    if max_number == min_number\
    \ then\n        return numbers\n    end\n    local inverted_number_range = 1.0\
    \ / (max_number - min_number)\n    local result = {}\n    for _, n in ipairs(numbers)\
    \ do\n        result[#result + 1] = (n - min_number) * inverted_number_range\n\
    \    end\n    return result\nend", "    local mn, mx = numbers[1], numbers[1]\n\
    \    for _, v in ipairs(numbers) do\n        mn = math.min(mn, v)\n        mx\
    \ = math.max(mx, v)\n    end\n    local range = mx - mn\n    return dlist.map(numbers,\
    \ function(v) return (v - mn) / range end)\nend", "    local min = numbers[1]\n\
    \    local max = numbers[1]\n    for _, number in ipairs(numbers) do\n       \
    \ if number < min then\n            min = number\n        end\n        if number\
    \ > max then\n            max = number\n        end\n    end\n    local unit =\
    \ {}\n    for _, number in ipairs(numbers) do\n        table.insert(unit, (number\
    \ - min) / (max - min))\n    end\n    return unit\nend", "    local num_list =\
    \ torch.FloatTensor(numbers)\n    local max_number = num_list:max()\n    local\
    \ min_number = num_list:min()\n    local scale = max_number - min_number\n   \
    \ local shift = min_number\n    local unit_numbers = torch.FloatTensor(num_list:size())\n\
    \    local idx = 0\n    for n = 1, num_list:size(1) do\n        idx = idx + 1\n\
    \        unit_numbers[idx] = (num_list[n] - shift) / scale\n    end\n    return\
    \ unit_numbers\nend", "  local max = -math.huge\n  local min = math.huge\n  for\
    \ _, num in ipairs(numbers) do\n    max = math.max(max, num)\n    min = math.min(min,\
    \ num)\n  end\n  local delta = max - min\n  local result = {}\n  for _, num in\
    \ ipairs(numbers) do\n    table.insert(result, (num - min) / delta)\n  end\n \
    \ return result\nend", "    local minv = math.min(unpack(numbers))\n    local\
    \ maxv = math.max(unpack(numbers))\n    if maxv == minv then\n        return {}\n\
    \    end\n    local result = {}\n    for i = 1, #numbers do\n        result[i]\
    \ = (numbers[i] - minv) / (maxv - minv)\n    end\n    return result\nend", " \
    \   local min_number = numbers[1]\n    local max_number = numbers[1]\n    for\
    \ _, number in ipairs(numbers) do\n        if number < min_number then\n     \
    \       min_number = number\n        end\n        if number > max_number then\n\
    \            max_number = number\n        end\n    end\n    local linear_transform\
    \ = function(x)\n        return (x - min_number) / (max_number - min_number)\n\
    \    end\n    return map(linear_transform, numbers)\nend", "  local min, max =\
    \ math.min(unpack(numbers)), math.max(unpack(numbers))\n  local length = max -\
    \ min\n  local rescaled = {}\n  for _, n in ipairs(numbers) do\n    table.insert(rescaled,\
    \ (n - min) / length)\n  end\n  return rescaled\nend", "  assert(numbers ~= nil)\n\
    \  assert(#numbers >= 2)\n  local min = numbers[1]\n  local max = numbers[1]\n\
    \  for i = 2, #numbers do\n    min = math.min(min, numbers[i])\n    max = math.max(max,\
    \ numbers[i])\n  end\n  local ret = {}\n  local scale = max - min\n  for i = 1,\
    \ #numbers do\n    ret[i] = (numbers[i] - min) / scale\n  end\n  return ret\n\
    end", "  local min = min(numbers)\n  local max = max(numbers)\n  return table.map(numbers,\
    \ function(x) return (x - min) / (max - min) end)\nend", "\tlocal max_value =\
    \ max(numbers)\n\tlocal min_value = min(numbers)\n\tlocal span = max_value - min_value\n\
    \tlocal result = {}\n\tfor _,number in ipairs(numbers) do\n\t\ttable.insert(result,\
    \ (number - min_value) / span)\n\tend\n\treturn result\nend", "\tlocal min, max\
    \ = numbers[1], numbers[1]\n\tfor _, n in ipairs(numbers) do\n\t\tif n < min then\
    \ min = n end\n\t\tif n > max then max = n end\n\tend\n\tlocal diff = max - min\n\
    \tlocal result = {}\n\tfor _, n in ipairs(numbers) do\n\t\ttable.insert(result,\
    \ (n - min) / diff)\n\tend\n\treturn result\nend", "    local smallest, largest\
    \ = numbers[1], numbers[1]\n    for _, n in ipairs(numbers) do\n        if n <\
    \ smallest then smallest = n end\n        if n > largest then largest = n end\n\
    \    end\n    local scaled = {}\n    for _, n in ipairs(numbers) do\n        table.insert(scaled,\
    \ (n - smallest) / (largest - smallest))\n    end\n    return scaled\nend", " \
    \   assert(#numbers >= 2)\n    local max_number = -math.huge\n    local min_number\
    \ = math.huge\n    for _,n in ipairs(numbers) do\n        max_number = math.max(max_number,\
    \ n)\n        min_number = math.min(min_number, n)\n    end\n    if max_number\
    \ == min_number then\n        -- Return all zeros if the list is flat.\n     \
    \   return table.create(#numbers, 0)\n    end\n    local new_list = {}\n    for\
    \ _,n in ipairs(numbers) do\n        new_list[#new_list+1] = (n - min_number)\
    \ / (max_number - min_number)\n    end\n    return new_list\nend", "    local\
    \ min_value = numbers[1]\n    local max_value = numbers[1]\n    for i = 2, #numbers\
    \ do\n        min_value = math.min(min_value, numbers[i])\n        max_value =\
    \ math.max(max_value, numbers[i])\n    end\n    if min_value == max_value then\n\
    \        return numbers\n    end\n    local range = max_value - min_value\n  \
    \  local result = {}\n    for i = 1, #numbers do\n        result[i] = (numbers[i]\
    \ - min_value) / range\n    end\n    return result\nend", "  local smallest, largest\
    \ = get_range(numbers)\n  local linear_transform = get_linear_transform(smallest,\
    \ largest)\n  return apply_linear_transform(numbers, linear_transform)\nend",
  "    local smallest = math.min(unpack(numbers))\n    local largest = math.max(unpack(numbers))\n\
    \    return util.zip(\n        numbers,\n        util.range(1, #numbers)\n   \
    \ ):map(function(x)\n        return (x[1] - smallest) / (largest - smallest)\n\
    \    end)\nend", "    local min_number = math.min(unpack(numbers))\n    local\
    \ max_number = math.max(unpack(numbers))\n    local range = max_number - min_number\n\
    \    if range == 0 then return numbers end\n    local rescaled = {}\n    for i,\
    \ number in ipairs(numbers) do\n        rescaled[i] = (number - min_number) /\
    \ range\n    end\n    return rescaled\nend", "  local max_number = math.max(unpack(numbers))\n\
    \  local min_number = math.min(unpack(numbers))\n  local new_numbers = {}\n  for\
    \ i = 1, #numbers do\n    new_numbers[i] = (numbers[i] - min_number) / (max_number\
    \ - min_number)\n  end\n  return new_numbers\nend", "    local min = math.min(unpack(numbers))\n\
    \    local max = math.max(unpack(numbers))\n    if max == min then\n        return\
    \ numbers\n    end\n    local result = {}\n    for i = 1, #numbers do\n      \
    \  result[i] = (numbers[i] - min) / (max - min)\n    end\n    return result\n\
    end", "    -- Check that all numbers are finite, otherwise it's impossible to\
    \ rescale\n    for _, x in ipairs(numbers) do\n        if x ~= x or x == math.huge\
    \ or x == -math.huge then\n            error(\"Non-finite number in the list:\
    \ \" .. tostring(x))\n        end\n    end", "    local smallest = numbers[1]\n\
    \    local largest = numbers[1]\n    for _, number in ipairs(numbers) do\n   \
    \     if number < smallest then\n            smallest = number\n        end\n\
    \        if number > largest then\n            largest = number\n        end\n\
    \    end\n    local output = {}\n    for _, number in ipairs(numbers) do\n   \
    \     table.insert(output, (number - smallest) / (largest - smallest))\n    end\n\
    \    return output\nend", "    local min_number = math.min(unpack(numbers))\n\
    \    local max_number = math.max(unpack(numbers))\n    local scale = 1.0 / (max_number\
    \ - min_number)\n    local rescaled_numbers = {}\n    for _, number in ipairs(numbers)\
    \ do\n        table.insert(rescaled_numbers, (number - min_number) * scale)\n\
    \    end\n    return rescaled_numbers\nend", "\tlocal min, max = math.min(table.unpack(numbers)),\
    \ math.max(table.unpack(numbers))\n\tlocal scale = max - min\n\tlocal output =\
    \ {}\n\tfor _, number in ipairs(numbers) do\n\t\ttable.insert(output, (number\
    \ - min) / scale)\n\tend\n\treturn output\nend", "    assert(#numbers >= 2)\n\
    \    local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    return __.map(numbers, function(num) return (num - min) / (max - min) end)\n\
    end", "    local min = numbers[1]\n    local max = numbers[1]\n    for _, n in\
    \ ipairs(numbers) do\n        if n < min then\n            min = n\n        end\n\
    \        if n > max then\n            max = n\n        end\n    end\n    -- delta\
    \ is a scale factor that will be used to scale all numbers to\n    -- the range\
    \ [0, 1]\n    local delta = max - min\n    local result = {}\n    for _, n in\
    \ ipairs(numbers) do\n        -- min is substracted to make lowest number 0\n\
    \        -- delta is multiplied to scale all numbers to the range [0, 1]\n   \
    \     result[#result + 1] = (n - min) / delta\n    end\n    return result\nend",
  "    local min, max = math.min(unpack(numbers)), math.max(unpack(numbers))\n   \
    \ local diff = max - min\n    local rescaled = {}\n    for _, n in ipairs(numbers)\
    \ do\n        rescaled[#rescaled + 1] = (n - min) / diff\n    end\n    return\
    \ rescaled\nend", "    -- Find the smallest and largest numbers\n    local min_number\
    \ = numbers[1]\n    local max_number = numbers[1]\n    for _, num in ipairs(numbers)\
    \ do\n        if num < min_number then\n            min_number = num\n       \
    \ end\n        if num > max_number then\n            max_number = num\n      \
    \  end\n    end", "    local min_number = 99999999999999999\n    local max_number\
    \ = -99999999999999999\n    for _, number in ipairs(numbers) do\n        if number\
    \ < min_number then\n            min_number = number\n        end\n        if\
    \ number > max_number then\n            max_number = number\n        end\n   \
    \ end\n    local new_numbers = {}\n    for _, number in ipairs(numbers) do\n \
    \       local new_number = (number - min_number) / (max_number - min_number)\n\
    \        table.insert(new_numbers, new_number)\n    end\n    return new_numbers\n\
    end", "    local min, max = numbers[1], numbers[1]\n    for _, n in ipairs(numbers)\
    \ do\n        if n < min then min = n end\n        if n > max then max = n end\n\
    \    end\n    local scale = 1 / (max - min)\n    local res = {}\n    for _, n\
    \ in ipairs(numbers) do\n        table.insert(res, (n - min) * scale)\n    end\n\
    \    return res\nend", "    local n = #numbers\n    local max = numbers[1]\n \
    \   local min = numbers[1]\n    for i = 2, n do\n        if numbers[i] > max then\n\
    \            max = numbers[i]\n        end\n        if numbers[i] < min then\n\
    \            min = numbers[i]\n        end\n    end\n    local result = {}\n \
    \   for i = 1, n do\n        result[i] = (numbers[i] - min) / (max - min)\n  \
    \  end\n    return result\nend", "    local max = maximum(numbers)\n    local\
    \ min = minimum(numbers)\n    local fun = function(x) return (x - min) / (max\
    \ - min) end\n    return map(fun, numbers)\nend", "    local min, max = minmax(numbers)\n\
    \    local scale = 1 / (max - min)\n    local translate = -min\n    return map(lambda(\"\
    x\", \"return x * \" .. scale .. \" + \" .. translate), numbers)\nend", "    local\
    \ max_n = math.max(unpack(numbers))\n    local min_n = math.min(unpack(numbers))\n\
    \    local rng = max_n - min_n\n    local step = 1.0 / rng\n    local res = {}\n\
    \    for _, n in ipairs(numbers) do\n        table.insert(res, (n - min_n) * step)\n\
    \    end\n    return res\nend", "  local minimum = math.min(unpack(numbers))\n\
    \  local maximum = math.max(unpack(numbers))\n  local rescaled = {}\n  for _,\
    \ v in ipairs(numbers) do\n    table.insert(rescaled, (v - minimum) / (maximum\
    \ - minimum))\n  end\n  return rescaled\nend", "    local highest, lowest = math.max(unpack(numbers)),\
    \ math.min(unpack(numbers))\n    local delta = highest - lowest\n    return map(function(v)\
    \ return (v - lowest) / delta end, numbers)\nend", "    assert( #numbers >= 2,\
    \ \"There must be at least two elements\" )\n    local min = numbers[1]\n    local\
    \ max = numbers[1]\n    for _, number in ipairs(numbers) do\n        if number\
    \ < min then\n            min = number\n        end\n        if number > max then\n\
    \            max = number\n        end\n    end\n    local scaled = {}\n    for\
    \ _, number in ipairs(numbers) do\n        table.insert(scaled, (number - min)\
    \ / (max - min))\n    end\n    return scaled\nend", "  local lo, hi = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n  local diff = hi - lo\n  if diff == 0 then\n   \
    \ return {0.5}\n  end\n  return util.map(function(v) return (v - lo) / diff end,\
    \ numbers)\nend", "    local max, min = numbers[1], numbers[1]\n    for i = 2,\
    \ #numbers do\n        local n = numbers[i]\n        if n > max then max = n end\n\
    \        if n < min then min = n end\n    end\n    local span = max - min\n  \
    \  if span == 0 then span = 1 end\n    local ret = {}\n    for i = 1, #numbers\
    \ do\n        ret[i] = (numbers[i] - min) / span\n    end\n    return ret\nend",
  "    -- find the min and max\n    local min_val = math.huge\n    local max_val =\
    \ -math.huge\n    for _, n in ipairs(numbers) do\n        if n < min_val then\n\
    \            min_val = n\n        end\n        if n > max_val then\n         \
    \   max_val = n\n        end\n    end\n    -- compute the factor\n    local factor\
    \ = 1.0 / (max_val - min_val)\n    -- rescale all elements\n    local rescaled\
    \ = {}\n    for _, n in ipairs(numbers) do\n        table.insert(rescaled, (n\
    \ - min_val) * factor)\n    end\n    return rescaled\nend", "    local min = numbers[1]\n\
    \    local max = numbers[1]\n    for i = 2, #numbers do\n        min = math.min(min,\
    \ numbers[i])\n        max = math.max(max, numbers[i])\n    end\n    local result\
    \ = {}\n    for i = 1, #numbers do\n        result[i] = (numbers[i] - min) / (max\
    \ - min)\n    end\n    return result\nend", "    assert(#numbers >= 2)\n    local\
    \ min = numbers[1]\n    local max = numbers[1]\n    for i = 2, #numbers do\n \
    \       if numbers[i] < min then\n            min = numbers[i]\n        elseif\
    \ numbers[i] > max then\n            max = numbers[i]\n        end\n    end\n\
    \    local range = max - min\n    assert(range > 0)\n    local rescaled = {}\n\
    \    for i = 1, #numbers do\n        rescaled[i] = (numbers[i] - min) / range\n\
    \    end\n    return rescaled\nend", "    local minimum = numbers[1]\n    local\
    \ maximum = numbers[1]\n    for _, v in ipairs(numbers) do\n        if v < minimum\
    \ then\n            minimum = v\n        end\n        if v > maximum then\n  \
    \          maximum = v\n        end\n    end\n    local diff = maximum - minimum\n\
    \    local result = {}\n    for _, v in ipairs(numbers) do\n        table.insert(result,\
    \ (v - minimum) / diff)\n    end\n    return result\nend", "    local min = numbers[1]\n\
    \    local max = numbers[1]\n    for _, n in ipairs(numbers) do\n        if n\
    \ < min then\n            min = n\n        end\n        if n > max then\n    \
    \        max = n\n        end\n    end\n    local unit_list = {}\n    for _, n\
    \ in ipairs(numbers) do\n        table.insert(unit_list, (n - min) / (max - min))\n\
    \    end\n    return unit_list\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
