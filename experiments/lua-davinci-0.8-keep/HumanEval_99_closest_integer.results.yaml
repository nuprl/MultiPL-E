name: HumanEval_99_closest_integer
language: lua
results:
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local v\
    \ = tonumber(value)\n  if v == math.floor(v) then\n    return math.floor(v)\n\
    \  else\n    if v > 0 then\n      return math.floor(v + 0.5)\n    else\n     \
    \ return math.ceil(v - 0.5)\n    end\n  end\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprtdbzdn3.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmprtdbzdn3.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local float_value\
    \ = tonumber(value)\n  if float_value > 0 then\n    return math.floor(float_value)\n\
    \  else\n    return math.ceil(float_value)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp46acrp8h.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp46acrp8h.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- TODO:\
    \ Add your solution here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp49s20xel.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp49s20xel.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  local floor_number = math.floor(number)\n  local diff =\
    \ number - floor_number\n  if diff < 0.5 then\n    return floor_number\n  else\n\
    \    return floor_number + 1\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc84crnga.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpc84crnga.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if not(value)\
    \ then return nil end\n  local v = tonumber(value)\n  local rounded = math.floor(v\
    \ + 0.5)\n  return rounded\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8e7vw8fm.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp8e7vw8fm.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\treturn math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2gf_5d4b.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp2gf_5d4b.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local fractional_part\
    \ = value:match(\"%d+%.(%d+)\")\n  if fractional_part and fractional_part ~= \"\
    \" then\n    return math.ceil(value)\n  else\n    return tonumber(value)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj3nhky4o.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpj3nhky4o.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpobc180yn.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpobc180yn.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local n\
    \ = tonumber(value)\n  local m = math.floor(n)\n  if (n > 0) then\n    return\
    \ (n - m < 0.5) and m or (m + 1)\n  else\n    return (n - m > 0.5) and m or (m\
    \ - 1)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwbzl9cxy.lua:29:\
    \ expected: -16, actual: -17\nstack traceback:\n\t/tmp/tmpwbzl9cxy.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ tonumber(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4_t7rmop.lua:22:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmp4_t7rmop.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  local int_num = math.tointeger(num)\n  local rounded_up\
    \ = math.ceil(num)\n  local rounded_down = math.floor(num)\n  if rounded_up ==\
    \ rounded_down then\n    return int_num\n  elseif rounded_up == num then\n   \
    \ return rounded_up\n  elseif rounded_down == num then\n    return rounded_down\n\
    \  elseif rounded_up == rounded_down + 1 then\n    return rounded_up\n  elseif\
    \ rounded_down == rounded_up + 1 then\n    return rounded_down\n  elseif num -\
    \ rounded_down < rounded_up - num then\n    return rounded_down\n  else\n    return\
    \ rounded_up\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpic8ndql8.lua:41:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpic8ndql8.lua:41: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Your\
    \ code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptycgzfqp.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmptycgzfqp.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmps_628om7.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmps_628om7.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ x = tonumber(value)\n    if not x then return nil end\n    return x >= 0 and\
    \ math.floor(x + 0.5) or math.ceil(x - 0.5)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\treturn math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgyy_rq3l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpgyy_rq3l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number < 0 then\n        return math.ceil(number)\n\
    \    else\n        return math.floor(number)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpji4b23q8.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpji4b23q8.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local n\
    \ = tonumber(value)\n  if n == nil then\n    n = 0\n  end\n  return math.floor(n\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz860sba3.lua:27:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpz860sba3.lua:27: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ x = tonumber(value)\n    local x1 = math.floor(x)\n    local x2 = math.ceil(x)\n\
    \    local c1 = math.abs(x - x1)\n    local c2 = math.abs(x - x2)\n    if c1 ==\
    \ c2 then\n        return x1\n    elseif c1 < c2 then\n        return x1\n   \
    \ else\n        return x2\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz_z9f77r.lua:33:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpz_z9f77r.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- parse\
    \ the string into a number\n    local num = tonumber(value)\n    -- if the number\
    \ is not a number then return nil\n    if num == nil then\n        return nil\n\
    \    end\n    -- if the number is an integer then just return the number\n   \
    \ if num == math.floor(num) then\n        return num\n    end\n    -- if the number\
    \ is negative, round down and away from zero\n    if num < 0 then\n        return\
    \ math.floor(num)\n    end\n    -- if the number is positive, round up and away\
    \ from zero\n    return math.ceil(num)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpspjj6afs.lua:39:\
    \ expected: 15, actual: 16\nstack traceback:\n\t/tmp/tmpspjj6afs.lua:39: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number >= 0 then\n    return math.floor(number + 0.5)\n\
    \  else\n    return math.ceil(number - 0.5)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp51f507sv.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp51f507sv.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwkibct9y.lua:20:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpwkibct9y.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd7qopfu7.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpd7qopfu7.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- You\
    \ could use the *math.floor* or *math.ceil*\n    -- functions for the conversion\n\
    \    -- to integer.\n    return math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph631yxye.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmph631yxye.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ sign = value:match(\"^%-\") and -1 or 1\n    local c = tonumber(value) or 0\n\
    \    local f = math.floor(c)\n    local d = math.abs(c-f)\n    if d == 0.5 then\n\
    \        f = f + sign\n    elseif d > 0.5 then\n        f = f + 1 * sign\n   \
    \ end\n    return f\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp83z40ps7.lua:32:\
    \ expected: -16, actual: -17\nstack traceback:\n\t/tmp/tmp83z40ps7.lua:32: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if not num then\n        return nil\n    end\n  \
    \  return math.floor(num + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfuqri539.lua:27:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpfuqri539.lua:27: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return tonumber(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvv1shp89.lua:22:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpvv1shp89.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number then\n        return math.floor(number\
    \ + 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfxh7ise2.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpfxh7ise2.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local f\
    \ = tonumber(value)\n  return f >= 0 and math.floor(f + 0.5) or math.ceil(f -\
    \ 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value)+0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpinm7ue8j.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpinm7ue8j.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number % 1 > 0.5 then\n        return math.ceil(number)\n\
    \    else\n        return math.floor(number)\n    end\nend\nassert(closest_integer(\"\
    10\") == 10)\nassert(closest_integer(\"15.3\") == 15)\nassert(closest_integer(\"\
    -15.3\") == -15)\nassert(closest_integer(\"14.5\") == 15)\nassert(closest_integer(\"\
    -14.5\") == -15)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp8mqibke_.lua:25: assertion failed!\nstack traceback:\n\t[C]:\
    \ in function 'assert'\n\t/tmp/tmp8mqibke_.lua:25: in main chunk\n\t[C]: in ?\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return round(tonumber(value))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpj_gy_iqr.lua:15:\
    \ attempt to call a nil value (global 'round')\nstack traceback:\n\t/tmp/tmpj_gy_iqr.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpj_gy_iqr.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ 0\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy14np_3b.lua:21:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmpy14np_3b.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxia_cm1l.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpxia_cm1l.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    return math.ceil(number)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprzlt3yc6.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmprzlt3yc6.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  local val = math.floor(num)\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpa25vda3j.lua:28: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  assert(number ~= nil, \"value must be a number, not \"\
    \ .. value)\n  return math.floor(number + 0.5)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfyqwi85i.lua:25:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpfyqwi85i.lua:25: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\treturn math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpn_20ujz0.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpn_20ujz0.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3hjv_4gc.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp3hjv_4gc.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\treturn floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpuj3ypc7v.lua:15:\
    \ attempt to call a nil value (global 'floor')\nstack traceback:\n\t/tmp/tmpuj3ypc7v.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpuj3ypc7v.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    if string.find(value,\
    \ \".\", 1, true) then\n        local integer, decimal = string.match(value, \"\
    (%d+).(%d+)\")\n        local part_of_decimal = tonumber(string.sub(decimal, 1,\
    \ 1))\n        local closest_int = tonumber(integer)\n        if part_of_decimal\
    \ >= 5 then\n            closest_int = closest_int + 1\n        end\n        return\
    \ closest_int\n    else\n        return tonumber(value)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpaohg7yh7.lua:33:\
    \ expected: -16, actual: 16\nstack traceback:\n\t/tmp/tmpaohg7yh7.lua:33: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpx7_pk888.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpx7_pk888.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    local i, f = math.modf(num)\n    return num < 0 and\
    \ i - 1 or f >= 0.5 and i + 1 or i\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6a_fefmw.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6a_fefmw.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_1g8q2h7.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp_1g8q2h7.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- your\
    \ code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_du358wg.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp_du358wg.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkbhbk3pl.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpkbhbk3pl.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local n\
    \ = tonumber(value)\n  local decimal = n - math.floor(n)\n  if decimal < 0.5 then\n\
    \    return math.floor(n)\n  else\n    return math.ceil(n)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_yycjl40.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp_yycjl40.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    if type(value)\
    \ ~= \"string\" then\n        return nil\n    end\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp20xlxhyp.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp20xlxhyp.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzp_l08pq.lua:20:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpzp_l08pq.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmmmouza5.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpmmmouza5.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ tonumber(string.format(\"%.0f\", value))\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4p91i2c1.lua:22:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp4p91i2c1.lua:22: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- your\
    \ code here\n    local a, b = math.modf(value)\n    if a < b then\n        return\
    \ a\n    else\n        return b\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpx0wubsy3.lua:27:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmpx0wubsy3.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local n\
    \ = tonumber(value)\n  if n == nil then\n    return n\n  end\n  if n >= 0 then\n\
    \    return math.floor(n + 0.5)\n  else\n    return math.ceil(n - 0.5)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\t-- ...\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8sn7gaot.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp8sn7gaot.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    local x = num % 1\n    local z = num - x\n    if\
    \ num >= 0 then\n        if x > 0.5 then\n            return z + 1\n        else\n\
    \            return z\n        end\n    else\n        if x < -0.5 then\n     \
    \       return z - 1\n        else\n            return z\n        end\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplk5z39mf.lua:37:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmplk5z39mf.lua:37: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\treturn 0\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8zi_dr8e.lua:21:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmp8zi_dr8e.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Put your\
    \ code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa3cc2nh3.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpa3cc2nh3.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.tointeger(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp320kbwko.lua:22:\
    \ expected: 15, actual: nil\nstack traceback:\n\t/tmp/tmp320kbwko.lua:22: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Your\
    \ code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdk6dktcy.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpdk6dktcy.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_sdnf7kh.lua:15:\
    \ attempt to call a nil value (field 'round')\nstack traceback:\n\t/tmp/tmp_sdnf7kh.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmp_sdnf7kh.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local val\
    \ = tonumber(value)\n  return val % 1 >= 0.5 and math.ceil(val) or math.floor(val)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp96j9hs6a.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp96j9hs6a.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local v\
    \ = tonumber(value)\n  return v % 1 >= 0.5 and math.ceil(v) or math.floor(v)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprozt5b0o.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmprozt5b0o.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ x = tonumber(value)\n    local r = math.floor(x + 0.5)\n    if math.abs(x -\
    \ r) == 0.5 then\n        if x < 0 then\n            r = r - 1\n        else\n\
    \            r = r + 1\n        end\n    end\n    return r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphphi5ia7.lua:31:\
    \ expected: 15, actual: 16\nstack traceback:\n\t/tmp/tmphphi5ia7.lua:31: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0j13hu52.lua:15:\
    \ attempt to call a nil value (global 'round')\nstack traceback:\n\t/tmp/tmp0j13hu52.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmp0j13hu52.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp3bwhils.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpp3bwhils.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- your\
    \ code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoast0bgj.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpoast0bgj.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Your\
    \ solution here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4ylm8tuq.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp4ylm8tuq.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    local fraction = number - math.floor(number)\n\
    \    local result = math.floor(number)\n    if fraction > 0.5 then\n        result\
    \ = result + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5ea4ul7z.lua:28:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp5ea4ul7z.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7nlm2av7.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp7nlm2av7.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\treturn math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9oc26iu4.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp9oc26iu4.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ assert(tonumber(value), \"You should pass in a number!\")\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjknhypr0.lua:22:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpjknhypr0.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- TODO:\
    \ Implement this function.\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5y2e1yzd.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp5y2e1yzd.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwgp5dbku.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpwgp5dbku.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.tointeger(tonumber(value))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1eo4qql2.lua:22:\
    \ expected: 15, actual: nil\nstack traceback:\n\t/tmp/tmp1eo4qql2.lua:22: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local x\
    \ = tonumber(value)\n  return x > 0 and math.floor(x + 0.5) or math.ceil(x - 0.5)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tif value\
    \ == \"0\" then\n\t\treturn 0\n\tend\n\tlocal whole, fraction = value:match(\"\
    (%-?%d+)%.(%d+)\")\n\tif not fraction then\n\t\treturn tonumber(value)\n\tend\n\
    \tif fraction >= \"5\" then\n\t\twhole = whole + 1\n\tend\n\treturn tonumber(whole)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdr2_1_kw.lua:33:\
    \ expected: -16, actual: -14\nstack traceback:\n\t/tmp/tmpdr2_1_kw.lua:33: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ round(tonumber(value))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpk25a966j.lua:15:\
    \ attempt to call a nil value (global 'round')\nstack traceback:\n\t/tmp/tmpk25a966j.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpk25a966j.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd7fj698e.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpd7fj698e.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ d = tonumber(value)\n    local n = math.floor(d)\n    local m = math.floor(d\
    \ + 0.5)\n    if d - n >= 0.5 then\n        return m\n    else\n        return\
    \ n\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwwz1vkcd.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpwwz1vkcd.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local c\
    \ = tonumber(value)\n  return (c - c % 1)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcsoytgco.lua:23:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpcsoytgco.lua:23: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- function\
    \ body\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9lylh7e5.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp9lylh7e5.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num - math.floor(num) >= 0.5 then\n        return\
    \ math.ceil(num)\n    else\n        return math.floor(num)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4bcx8h04.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4bcx8h04.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  return math.floor(number + 0.5)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppxbt4uo0.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmppxbt4uo0.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp03n00cuq.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp03n00cuq.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ float = tonumber(value)\n    local int = math.floor(float)\n    if float > int\
    \ then\n        if float - int < 0.5 then\n            return int\n        else\n\
    \            return int + 1\n        end\n    elseif float < int then\n      \
    \  if int - float < 0.5 then\n            return int\n        else\n         \
    \   return int - 1\n        end\n    else\n        return int\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb57lkv06.lua:39:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpb57lkv06.lua:39: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqq78iqii.lua:20:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpqq78iqii.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ tonumber(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpv4wizhjw.lua:22:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpv4wizhjw.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- implement\
    \ here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjweueilh.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpjweueilh.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ v = tonumber(value)\n    local i = math.floor(v)\n    if v - i >= 0.5 then\n\
    \        return i + 1\n    else\n        return i\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsvp364u9.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpsvp364u9.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Write\
    \ your code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprxhhcgge.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmprxhhcgge.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- TODO:\
    \ implement this function body\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvfkt020v.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpvfkt020v.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptq86pzgb.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmptq86pzgb.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7gke9xll.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp7gke9xll.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kr7tiwq.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kr7tiwq.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return 0\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpddx_vbvu.lua:21:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmpddx_vbvu.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)+0.5)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppa2n7oqq.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmppa2n7oqq.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ n = tonumber(value)\n    if n > 0 then\n        return math.floor(n + 0.5)\n\
    \    else\n        return math.ceil(n - 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  local m = math.floor(number)\n  local n = math.ceil(number)\n\
    \  if math.abs(number - m) < math.abs(number - n) then\n    return m\n  else\n\
    \    return n\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp1s2eb3f.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpp1s2eb3f.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    if string.find(value,\
    \ '%.') then\n        value = string.sub(value, 0, string.find(value, '%.') -\
    \ 1)\n    end\n    return tonumber(value)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7ixxii5.lua:25:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpf7ixxii5.lua:25: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- Your\
    \ code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2zppd_yh.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp2zppd_yh.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- local\
    \ res = 0\n    -- local closest = math.abs(value - res)\n    -- for i = 1, math.abs(value)\
    \ do\n    --     local new_closest = math.abs(value - i)\n    --     if new_closest\
    \ < closest then\n    --         closest = new_closest\n    --         res = i\n\
    \    --     end\n    -- end\n    -- if value < 0 then\n    --     res = -res\n\
    \    -- end\n    -- return res\n    local val = tonumber(value)\n    if val >\
    \ 0 then\n        return math.floor(val + 0.5)\n    else\n        return math.ceil(val\
    \ - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.tointeger(math.max(math.floor(value), math.ceil(value)))\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr7ytk6z3.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpr7ytk6z3.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local n\
    \ = tonumber(value)\n  return n < 0 and math.ceil(n) or math.floor(n)\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa2rhqm8n.lua:23:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpa2rhqm8n.lua:23: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local int\
    \ = tonumber(value)\n  return math.floor(int + 0.5)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj6xrov4d.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpj6xrov4d.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local x\
    \ = tonumber(value)\n  local y = math.floor(x)\n  if x == y then\n    return y\n\
    \  elseif x > y then\n    return math.ceil(x)\n  else\n    return math.floor(x)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvc6l5t93.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpvc6l5t93.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return tonumber(value)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplpj31avm.lua:22:\
    \ expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmplpj31avm.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkoin2oob.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpkoin2oob.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- your\
    \ code here\n    return value\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb5zhvota.lua:22:\
    \ expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmpb5zhvota.lua:22: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ x = tonumber(value)\n    local i = math.floor(x)\n    local d = x - i\n    if\
    \ d >= 0.5 then\n        return i + 1\n    else\n        return i\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjxo77y0d.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpjxo77y0d.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- TODO:\
    \ add your code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuvcot3th.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpuvcot3th.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ value = tonumber(value)\n    local integer = math.floor(value)\n    local decimal\
    \ = value - integer\n    if decimal < 0.5 then\n        return integer\n    else\n\
    \        return integer + 1\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1vd4jcaa.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp1vd4jcaa.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\treturn math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_bg7lno1.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp_bg7lno1.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  assert(number, \"no number\")\n  if number < 0 then\n \
    \   return math.ceil(number)\n  else\n    return math.floor(number)\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbhvcj_bi.lua:28:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpbhvcj_bi.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if type(value)\
    \ ~= \"string\" then\n    return nil\n  end\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpydc7acwk.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpydc7acwk.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local v\
    \ = tonumber(value)\n  if v == math.floor(v) then\n    return v\n  else\n    return\
    \ math.floor(v + 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdk6oux44.lua:28:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpdk6oux44.lua:28: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprvqokid6.lua:20:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmprvqokid6.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return 0\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_l9fxrho.lua:21:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmp_l9fxrho.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdy95i88y.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpdy95i88y.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  return math.floor(num + 0.5)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsf3ymdfv.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpsf3ymdfv.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number > 0 then\n    return math.floor(number + 0.5)\n\
    \  else\n    return math.ceil(number - 0.5)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal result\
    \ = math.floor(value)\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpd0q0bwcd.lua:27: 'end' expected (to close 'function' at line\
    \ 14) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\t--[[\n\t\
    \t:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpmy973tur.lua:28: unfinished long comment (starting at line\
    \ 15) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ value\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxajuqdi1.lua:21:\
    \ expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmpxajuqdi1.lua:21: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num < 0 then\n        return math.ceil(num)\n\
    \    else\n        return math.floor(num)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvuua8bpu.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpvuua8bpu.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcu35etyp.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpcu35etyp.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local fractional_part\
    \ = value - math.floor(value)\n  if fractional_part == 0.5 then\n    return value\
    \ >= 0 and math.ceil(value) or math.floor(value)\n  elseif fractional_part > 0.5\
    \ then\n    return math.ceil(value)\n  else\n    return math.floor(value)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0e2qgxxu.lua:17:\
    \ attempt to compare number with string\nstack traceback:\n\t/tmp/tmp0e2qgxxu.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmp0e2qgxxu.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local value_num\
    \ = tonumber(value)\n  if value_num == nil then\n    return nil\n  end\n  if value_num\
    \ < 0 then\n    return math.ceil(value_num)\n  else\n    return math.floor(value_num)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpj1517s7z.lua:30:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpj1517s7z.lua:30: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- write\
    \ your code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyqqpfr3n.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpyqqpfr3n.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local parsed\
    \ = tonumber(value)\n  if parsed > 0 then\n    return math.floor(parsed)\n  else\n\
    \    return math.ceil(parsed)\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoa7a2_jq.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpoa7a2_jq.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.round(tonumber(value))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp19xla1qk.lua:15:\
    \ attempt to call a nil value (field 'round')\nstack traceback:\n\t/tmp/tmp19xla1qk.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmp19xla1qk.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa9mkkxwy.lua:20:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpa9mkkxwy.lua:20: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value+0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp24qpdmzt.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp24qpdmzt.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- TODO:\
    \ implement this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpiqny2t4x.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpiqny2t4x.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ val = tonumber(value)\n    if val < 0 then\n        return math.ceil(val)\n\
    \    else\n        return math.floor(val)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt_u7f7qq.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpt_u7f7qq.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Your\
    \ code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdmfxdfqo.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpdmfxdfqo.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local n\
    \ = math.floor(tonumber(value) + 0.5)\n  return n\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7l43tpr2.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp7l43tpr2.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- your\
    \ code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4hnie4ca.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp4hnie4ca.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Code\
    \ the function here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjanw6laj.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpjanw6laj.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if not num then return nil end\n  if num % 1 == 0 then\
    \ return num end\n  local pos = math.floor(num)\n  local neg = math.ceil(num)\n\
    \  if num < 0 then return neg end\n  return pos\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpv2tmzu5y.lua:28:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpv2tmzu5y.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpv3tjo1ls.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpv3tjo1ls.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ float_value = tonumber(value)\n    local fractional, integer = math.modf(float_value)\n\
    \    if fractional < 0.5 then\n        return integer\n    else\n        return\
    \ integer + 1\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5h1jlb4a.lua:27:\
    \ expected: 10, actual: 1\nstack traceback:\n\t/tmp/tmp5h1jlb4a.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    local int = math.floor(num)\n    if (num == int)\
    \ then\n        return int\n    elseif (math.abs(num - int) < 0.5) then\n    \
    \    return int\n    else\n        return int + 1\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpo5amykrk.lua:31:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpo5amykrk.lua:31: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5y7ks6fv.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp5y7ks6fv.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpat174bha.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpat174bha.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local v\
    \ = tonumber(value)\n  if v >= 0 then\n    return math.floor(v + 0.5)\n  else\n\
    \    return math.ceil(v - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ f = tonumber(value)\n    return f % 1 >= 0.5 and math.ceil(f) or math.floor(f)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkrnef8c_.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpkrnef8c_.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- your\
    \ code here\n    return nil\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzsz92h7n.lua:22:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmpzsz92h7n.lua:22: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tif value\
    \ == nil then return 0 end\n\tif type(value) ~= \"string\" then return 0 end\n\
    \treturn math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp90t2rjuf.lua:25:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp90t2rjuf.lua:25: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return (value\
    \ == nil) and 0 or (round(tonumber(value),0))\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp5pula3bk.lua:15:\
    \ attempt to call a nil value (global 'round')\nstack traceback:\n\t/tmp/tmp5pula3bk.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmp5pula3bk.lua:21: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ r = math.round(value)\n    return r\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpw4v832sx.lua:15:\
    \ attempt to call a nil value (field 'round')\nstack traceback:\n\t/tmp/tmpw4v832sx.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpw4v832sx.lua:22: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ value = tonumber(value)\n    if value >= 0 then\n        return math.floor(value\
    \ + 0.5)\n    else\n        return math.ceil(value - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ n = tonumber(value)\n    if n < 0 then\n        n = n - 0.5\n    else\n    \
    \    n = n + 0.5\n    end\n    return math.floor(n)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    if not\
    \ value then\n        return 0\n    end\n    local num = tonumber(value)\n   \
    \ if not num then\n        return 0\n    end\n    local i, f = math.modf(num)\n\
    \    if f >= 0.5 then\n        return i + 1\n    else\n        return i\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxsiocdfc.lua:35:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpxsiocdfc.lua:35: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4alvt35a.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4alvt35a.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  if not value\
    \ then\n    return nil\n  end\n  local number = tonumber(value)\n  if number then\n\
    \    return math.floor(number + 0.5)\n  end\n  return nil\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqi7v7732.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpqi7v7732.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  value =\
    \ tonumber(value)\n  local floor = math.floor(value)\n  local ceiling = math.ceil(value)\n\
    \  if value - floor < ceiling - value then\n    return floor\n  else\n    return\
    \ ceiling\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp36by7818.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp36by7818.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n\tlocal number\
    \ = tonumber(value)\n\tlocal closest = math.floor(number)\n\tif math.ceil(number)\
    \ - number < number - closest then\n\t\tclosest = math.ceil(number)\n\tend\n\t\
    return closest\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6p8fzrf8.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp6p8fzrf8.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num - math.floor(num) > 0.5 then\n        return\
    \ math.ceil(num)\n    else\n        return math.floor(num)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpakakhzqf.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpakakhzqf.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Implement\
    \ this!\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp13o3aoj6.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp13o3aoj6.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbg011__4.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpbg011__4.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return 0\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9oh2lq_g.lua:21:\
    \ expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmp9oh2lq_g.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7m81rlhc.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp7m81rlhc.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- Some\
    \ people don't like the math library, but I like it!\n    return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjn5wzvka.lua:24:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpjn5wzvka.lua:24: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- Insert\
    \ code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6mkug6r0.lua:21:\
    \ expected: 10, actual: nil\nstack traceback:\n\t/tmp/tmp6mkug6r0.lua:21: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number < 0 then\n        return -math.floor(-number\
    \ + 0.5)\n    else\n        return math.floor(number + 0.5)\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ int, frac = math.modf(tonumber(value))\n    if frac > 0.5 then\n        return\
    \ int + 1\n    elseif frac < -0.5 then\n        return int - 1\n    else\n   \
    \     return int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5lnt8nip.lua:29:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp5lnt8nip.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  local integer = math.floor(number)\n  local remainder =\
    \ number - integer\n  if remainder < 0.5 then\n    return integer\n  else\n  \
    \  return integer + 1\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxlmjr26f.lua:30:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpxlmjr26f.lua:30: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value+0.5)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6kx1rlou.lua:23:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp6kx1rlou.lua:23: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number > 0 then\n    return math.floor(number + 0.5)\n\
    \  else\n    return math.ceil(number - 0.5)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
