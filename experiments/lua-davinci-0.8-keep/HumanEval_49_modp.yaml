name: HumanEval_49_modp
language: lua
prompt: "-- Return 2^n modulo p (be aware of numerics).\n-- >>> modp(3, 5)\n-- 3\n\
  -- >>> modp(1101, 101)\n-- 2\n-- >>> modp(0, 101)\n-- 1\n-- >>> modp(3, 11)\n--\
  \ 8\n-- >>> modp(100, 101)\n-- 1\nlocal function modp(n, p)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
  \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101, 101),\
  \ 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
  \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
  \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  return fmod(n, p)\nend", "    if n < p then\n        return n\n \
    \   end\n    local q = math.floor(n / p)\n    local r = n - q * p\n    return\
    \ modp(q, p) + r\nend", "    if n == 0 then\n        return 1\n    elseif n %\
    \ 2 == 0 then\n        return modp(n/2, p)^2 % p\n    else\n        return (modp(n-1,\
    \ p) * 2) % p\n    end\nend", "    local res = 1\n    while n > 0 do\n       \
    \ if n % 2 == 1 then\n            res = (res * 2) % p\n        end\n        n\
    \ = floor(n / 2)\n    end\n    return res\nend", "    if n == 0 then\n       \
    \ return 1\n    elseif n == 1 then\n        return 2\n    elseif n % 2 == 0 then\n\
    \        local mod = modp(n/2, p)\n        return (mod*mod) % p\n    else\n  \
    \      local mod = modp(n-1, p)\n        return (2*mod) % p\n    end\nend", " \
    \   if n==0 then return 1 end\n    if n%2==0 then\n        return modp(2*n, p)^2\
    \ % p\n    else\n        return 2*modp(n-1, p) % p\n    end\nend", "  local m\
    \ = 1\n  local b = 2\n  while n > 0 do\n    if n % 2 == 1 then\n      m = (m *\
    \ b) % p\n    end\n    n = math.floor(n / 2)\n    b = (b * b) % p\n  end\n  return\
    \ m\nend", "    local r = n % p\n    return r == 0 and p or r\nend", "    if n\
    \ < 0 then\n        error(\"Negative exponent in modp\")\n    end\n    -- We use\
    \ x^n = (x^(n/2))^2\n    -- x^n = (x^((n-1)/2))^2 * x\n    if n == 0 then\n  \
    \      return 1\n    elseif n % 2 == 0 then\n        local x = modp(n/2, p)\n\
    \        return (x * x) % p\n    else\n        local x = modp((n-1)/2, p)\n  \
    \      return (x * x * 2) % p\n    end\nend", "    return n % p\nend", "    local\
    \ result = 1\n    local a = 2 % p\n    while n > 0 do\n        if n % 2 == 1 then\n\
    \            result = (result * a) % p\n        end\n        n = math.floor(n\
    \ / 2)\n        a = (a * a) % p\n    end\n    return result\nend", "    local\
    \ q = math.floor(p/2)\n    local r = n % p\n    if r == 0 then\n        return\
    \ 1\n    elseif r > q then\n        return (2*(r-q)) % p\n    else\n        return\
    \ (2*r) % p\n    end\nend", "  return big.mod(big.pow(2, n), p)\nend", "  -- It\
    \ is faster to take (mod p) after every multiplication, but be aware\n  -- of\
    \ numerics.\n  if n < p then\n    return n\n  end\n  local r = 1\n  local k =\
    \ 1\n  local x = 2\n  while k < n do\n    if k * 2 > n then\n      r = (r * x)\
    \ % p\n      k = k + 1\n    else\n      x = (x * x) % p\n      k = k * 2\n   \
    \ end\n  end\n  return r\nend", "  local res = 1\n  n = n % p\n  if n == 0 then\
    \ return 1 end\n  for i = 1, n do\n    res = (res * 2) % p\n  end\n  return res\n\
    end", "  if n == 0 then return 1 end\n  local x = modp(n/2, p)\n  x = x*x % p\n\
    \  if n % 2 == 1 then\n    x = x*2 % p\n  end\n  return x\nend", "  local res\
    \ = 1\n  local m = n % (p - 1)\n  for i = 1, m do\n    res = (res * 2) % p\n \
    \ end\n  return res\nend", "  local n = n % p\n  if n == 0 then\n    return 1\n\
    \  else\n    return n\n  end\nend", "\tif n == 0 then\n\t\treturn 1\n\telseif\
    \ n == 1 then\n\t\treturn n\n\telseif n == p then\n\t\treturn 0\n\telseif n <\
    \ p then\n\t\treturn n\n\telse\n\t\tlocal t = floor(n / p)\n\t\tlocal r = n -\
    \ t * p\n\t\tif r == 1 then\n\t\t\treturn 1\n\t\telseif r == 0 then\n\t\t\treturn\
    \ 0\n\t\telse\n\t\t\treturn r\n\t\tend\n\tend\nend", "    -- Simple modulus.\n\
    \    if n < p then\n        return n\n    end", "    local r = 1\n    local q\
    \ = 2\n    local b = bit.band(n, 1)\n    if b == 1 then\n        r = q\n    end\n\
    \    n = bit.rshift(n, 1)\n    while n > 0 do\n        b = bit.band(n, 1)\n  \
    \      n = bit.rshift(n, 1)\n        q = (q * q) % p\n        if b == 1 then\n\
    \            r = (r * q) % p\n        end\n    end\n    return r\nend", "\tif\
    \ p == 1 then\n\t\treturn 0\n\tend\n\tlocal res = 1\n\tn = n % p\n\twhile n >\
    \ 0 do\n\t\tif n % 2 == 1 then\n\t\t\tres = (res * 2) % p\n\t\tend\n\t\tn = floor(n\
    \ / 2)\n\tend\n\treturn res\nend", "    local res = 1\n    for i = 1, n do\n \
    \       res = res * 2 % p\n    end\n    return res\nend", "    local sum = 1\n\
    \    for i = 1, n do\n        sum = (sum * 2) % p\n    end\n    return sum\nend",
  "    if n == 0 then\n        return 1\n    elseif n == 1 then\n        return 0\n\
    \    elseif n % 2 == 0 then\n        local res = modp(n / 2, p)\n        return\
    \ (res * res) % p\n    else\n        return (2 * modp(n - 1, p)) % p\n    end\n\
    end", "  local b = 1\n  for i = 1, n do\n    b = b * 2 % p\n  end\n  return b\n\
    end", "  -- TODO: implement an optimised algorithm, e.g. a square-and-multiply\
    \ algorithm\n  return n % p\nend", "  return fmod(fmod(n, 2^53)*p, 1)*p\nend",
  "    local m = 1\n    while n > 0 do\n        if n % 2 == 1 then\n            m\
    \ = (m * 2) % p\n        end\n        n = n // 2\n    end\n    return m\nend",
  "\t-- 32-bit numerics range from 2^31-1 to -2^31.\n\t-- 64-bit numerics range from\
    \ 2^63-1 to -2^63.\n\tlocal big = 2^30-1", "  if n == 0 then return 1 end\n  if\
    \ n % 2 == 0 then\n    return (modp(n/2, p)^2) % p\n  else\n    return (modp(n/2,\
    \ p)^2 * 2) % p\n  end\nend", "  local v = 2^n % p\n  if v == 0 then return p\
    \ else return v end\nend", "\tassert(n >= 0 and p > 0, \"Invalid arguments.\"\
    )\n\treturn modm(2^n, p)\nend", "    local rem = 0\n    for c in string.gmatch(tostring(n),\
    \ \".\") do\n        rem = (rem * 10 + tonumber(c)) % p\n    end\n    return rem\n\
    end", "    if n == 0 then\n        return 1\n    elseif n == 1 then\n        return\
    \ 2\n    elseif p == 2 then\n        return 2\n    elseif p == 3 then\n      \
    \  return 2\n    elseif p == 5 then\n        return 2\n    elseif p == 7 then\n\
    \        return 3\n    elseif p == 11 then\n        return 8\n    elseif p ==\
    \ 13 then\n        return 4\n    elseif p == 17 then\n        return 3\n    elseif\
    \ p == 19 then\n        return 16\n    elseif p == 23 then\n        return 10\n\
    \    elseif p == 29 then\n        return 23\n    elseif p == 31 then\n       \
    \ return 16\n    elseif p == 37 then\n        return 33\n    elseif p == 41 then\n\
    \        return 3\n    elseif p == 43 then\n        return 32\n    elseif p ==\
    \ 47 then\n        return 20\n    elseif p == 53 then\n        return 33\n   \
    \ elseif p == 59 then\n        return 47\n    elseif p == 61 then\n        return\
    \ 5\n    elseif p == 67 then\n        return 18\n    elseif p == 71 then\n   \
    \     return 5\n    elseif p == 73 then\n        return 3\n    elseif p == 79\
    \ then\n        return 39\n    elseif p == 83 then\n        return 1\n    elseif\
    \ p == 89 then\n        return 40\n    elseif p == 97 then\n        return 8\n\
    \    elseif p == 101 then\n        return 2\n    elseif p == 103 then\n      \
    \  return 22\n    elseif p == 107 then\n        return 77\n    elseif p == 109\
    \ then\n        return 17\n    elseif p == 113 then\n        return 38\n    elseif\
    \ p == 127 then\n        return 42\n    elseif p == 131 then\n        return 91\n\
    \    elseif p == 137 then\n        return 36\n    elseif p == 139 then\n     \
    \   return 17\n    elseif p == 149 then\n        return 101\n    elseif p == 151\
    \ then\n        return 2\n    elseif p == 157 then\n        return 9\n    elseif\
    \ p == 163 then\n        return 55\n    elseif p == 167 then\n        return 31\n\
    \    elseif p == 173 then\n        return 35\n    elseif p == 179 then\n", "\t\
    -- assert(n ~= math.huge, \"Division by infinity\")\n\tassert(n ~= math.huge and\
    \ n ~= -math.huge, \"Division by infinity\")\n\tlocal r\n\tif n == 0 then return\
    \ 1 end\n\tif n < 0 then return modp(p - n, p) end\n\t-- n >= 0\n\tif n % 2 ==\
    \ 0 then\n\t\tr = modp(n / 2, p)\n\t\treturn (r * r) % p\n\telse\n\t\tr = modp((n\
    \ - 1) / 2, p)\n\t\treturn (2 * r * r) % p\n\tend\nend", "  local b, c = 0, 1\n\
    \  for i = 0, 31 do\n    if bit.band(n, 1) == 1 then\n      c = c * 2\n      if\
    \ c >= p then\n        c = c - p\n      end\n    end\n    n = bit.rshift(n, 1)\n\
    \    if n == 0 then\n      break\n    end\n  end\n  return c\nend", "    if n\
    \ == 0 then\n        return 1\n    elseif n < 0 then\n        return nil\n   \
    \ end\n    local base = n % p\n    n = n - base\n    while n > 0 do\n        n\
    \ = n / 2\n        base = (base * base) % p\n    end\n    return base\nend", " \
    \ -- assert(n >= 0)\n  -- assert(p >= 2)\n  -- we need some extra space for the\
    \ numerics\n  local k = 1\n  while k < p do\n    k = k * 2\n  end\n  return (n\
    \ % p) % k\nend", "\t-- See:\n\t-- https://en.wikipedia.org/wiki/Exponentiation_by_squaring#Modular_exponentiation\n\
    \tif p <= 0 then return end\n\tn = n % p\n\tif n == 0 then return 1 end\n\tlocal\
    \ c = 1\n\twhile n > 1 do\n\t\tif n % 2 == 1 then\n\t\t\tc = (c * n) % p\n\t\t\
    end\n\t\tn = n * n\n\t\tn = n % p\n\tend\n\treturn c\nend", "    if p == 1 then\n\
    \        return 0\n    end\n    -- TODO: implement the simple \"p mod 2 == 0\"\
    \ case.\n    local a = 1\n    local t = n\n    while t > 0 do\n        if t %\
    \ 2 == 1 then\n            a = (a * n) % p\n        end\n        t = math.floor(t\
    \ / 2)\n        n = (n * n) % p\n    end\n    return a\nend", "\tlocal r = 1\n\
    \tlocal x = n\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tr = (r * x) % p\n\
    \t\tend\n\t\tx = (x * x) % p\n\t\tn = n / 2\n\tend\n\treturn r\nend", "\tif (n\
    \ < 0) then\n\t\tn = n % p + p\n\tend\n\tif (n < p) then\n\t\treturn n\n\tend\n\
    \tlocal r = 1\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tr = (r * 2) % p\n\
    \t\tend\n\t\tn = n // 2\n\tend\n\treturn r\nend", "    assert(n >= 0, 'n is smaller\
    \ than 0!')\n    if p <= n then\n        n = n % p\n    end\n    if n == 0 then\n\
    \        return 1\n    elseif n == 1 then\n        return 2\n    else\n      \
    \  local a = 2\n        local b = 2\n        for i = 2, n do\n            a =\
    \ (a * b) % p\n        end\n        return a\n    end\nend", "    if p <= 0 then\n\
    \        error(\"modp: non-positive modulus: \" .. p)\n    end\n    if n == 0\
    \ then\n        return 1\n    end\n    if n < 0 then\n        return modp(-n,\
    \ p)\n    end\n    if n == 1 then\n        return n\n    end\n    if n > p then\n\
    \        return modp(n % p, p)\n    end\n    -- otherwise n < p and n > 1\n  \
    \  local n2 = bit32.band(n, 1)\n    local x2 = bit32.band(p, 1)\n    if n2 ==\
    \ 0 then\n        return modp(n / 2, p)\n    end\n    if x2 == 0 then\n      \
    \  return modp(n, p / 2) * 2\n    end\n    -- otherwise n2, x2 = 1\n    return\
    \ (modp(n - 1, p) + p - modp(p - 1, n)) / 2\nend", "    assert(type(n) == \"number\"\
    , \"n has to be a number\")\n    assert(type(p) == \"number\", \"p has to be a\
    \ number\")\n    assert(n == math.floor(n), \"n has to be an integer\")\n    assert(p\
    \ == math.floor(p), \"p has to be an integer\")\n    assert(p > 1, \"p has to\
    \ be > 1\")\n    assert(n >= 0, \"n has to be >= 0\")\n    assert(p >= 2, \"p\
    \ has to be >= 2\")\n    local result = 1\n    local z = n\n    local x = 2\n\
    \    while z > 0 do\n        while z % 2 == 0 do\n            z = z / 2\n    \
    \        local y = x * x % p\n            if y == 1 and x ~= 1 and x ~= p - 1\
    \ then\n                return 0\n            end\n            x = y\n       \
    \ end\n        z = z - 1\n        result = (result * x) % p\n    end\n    return\
    \ result\nend", "  if p < 0 then\n    return modp(n, -p)\n  end\n  local a = 1\n\
    \  local b = 0\n  local c = 0\n  local d = 1\n  local x = math.floor(p / 2)\n\
    \  local y = n % p\n  while y ~= 0 do\n    q = math.floor(x / y)\n    r = x -\
    \ q * y\n    x = y\n    y = r\n    s = a - q * c\n    t = b - q * d\n    a = c\n\
    \    b = d\n    c = s\n    d = t\n  end\n  if x ~= 1 then\n    print(\"assertion\
    \ failed\")\n  end\n  if a < 0 then\n    a = a + p\n  end\n  return a\nend", " \
    \ assert(type(n) == \"number\", \"n is not a number\")\n  assert(type(p) == \"\
    number\", \"p is not a number\")\n  assert(p > 1, \"p is not a prime\")\n  if\
    \ n < 0 then n = n + p end\n  if n == 0 then return 1 end\n  local rslt = 2\n\
    \  while (n ~= 1) do\n    if n % 2 == 1 then\n      rslt = (rslt * 2) % p\n  \
    \  end\n    n = n / 2\n  end\n  return rslt\nend", "  local d = 1\n  for i = 1,\
    \ n do\n    d = d * 2 % p\n  end\n  return d\nend", "    local result = 1\n  \
    \  for i = 1, n do\n        result = (result * 2) % p\n    end\n    return result\n\
    end", "\tassert(n >= 0, \"n must be non-negative\")\n\tassert(p > 1, \"p must\
    \ be greater than 1\")\n\tlocal x = n\n\twhile x >= p do\n\t\tx = (x * n) % p\n\
    \tend\n\treturn x\nend", "  local res = 1\n  while n > 0 do\n    if n % 2 == 1\
    \ then\n      res = (res * n) % p\n    end\n    n = (n - n % 2) / 2\n    n = n\
    \ % p\n  end\n  return res\nend", "  if n == 0 then return 1 end\n  local t =\
    \ modp(n // 2, p)\n  t = (t * t) % p\n  if n % 2 == 1 then\n    t = (t * 2) %\
    \ p\n  end\n  return t\nend", "    -- Calculate and return 2^n modulo p.\n   \
    \ if n < 0 then\n        -- Negative exponent, use modular exponentiation.\n \
    \       return exp(n, p-2, p)\n    else\n        -- Non-negative exponent.\n \
    \       -- Initialize.\n        local s = 1\n        local f = 2\n        local\
    \ t = n\n        while t > 0 do\n            -- Calculate f^2 and then the next\
    \ value of s.\n            f = (f * f) % p\n            if t % 2 == 1 then\n \
    \               s = (s * f) % p\n            end\n            -- Next iteration.\n\
    \            t = math.floor(t / 2)\n        end\n        return s\n    end\nend",
  "    return n % p\nend", "  local m = 1\n  while n ~= 0 do\n    if n % 2 == 1 then\n\
    \      m = (m * 2) % p\n    end\n    n = math.floor(n / 2)\n  end\n  return m\n\
    end", "\tlocal result = 1\n\twhile n ~= 0 do\n\t\tif n % 2 == 1 then\n\t\t\tresult\
    \ = result * 2 % p\n\t\tend\n\t\tn = n // 2\n\tend\n\treturn result\nend", " \
    \   local r = 1\n    local a = n\n    local b = p\n    while b ~= 0 do\n     \
    \   if b % 2 == 1 then\n            r = (r * a) % p\n        end\n        a =\
    \ (a * a) % p\n        b = math.floor(b / 2)\n    end\n    return r\nend", " \
    \ local k = 1\n  local d = 2\n  while n > 0 do\n    if n % 2 == 1 then\n     \
    \ k = (k * d) % p\n    end\n    n = math.floor(n / 2)\n    d = (d * d) % p\n \
    \ end\n  return k\nend", "  local res = 1\n  local b = n\n  while b > 0 do\n \
    \   if b % 2 == 1 then\n      res = res * n % p\n    end\n    n = n * n % p\n\
    \    b = math.floor(b / 2)\n  end\n  return res\nend", "\tlocal m = 1;\n\twhile\
    \ (n > 0) do\n\t\tif (n % 2 == 1) then\n\t\t\tm = (m * 2) % p;\n\t\tend\n\t\t\
    n = math.floor(n / 2);\n\tend\n\treturn m;\nend", "    if n < 0 then\n       \
    \ return p - modp(-n, p)\n    end\n    local res = 1\n    for i = 1, n do\n  \
    \      res = res * 2 % p\n    end\n    return res\nend", "\t-- use a somewhat\
    \ optimized version of the obvious variant:\n\t-- local r = 1\n\t-- for i = 1,\
    \ n do\n\t-- \tr = (r * 2) % p\n\t-- end\n\t-- return r\n\tlocal r = 1\n\twhile\
    \ n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tr = (r * 2) % p\n\t\tend\n\t\tn = math.floor(n\
    \ / 2)\n\tend\n\treturn r\nend", "  if n == 0 then return 1 end\n  if n % 2 ==\
    \ 0 then\n    return modp(n / 2, p)^2 % p\n  else\n    return (2 * modp(n - 1,\
    \ p)) % p\n  end\nend", "    local n1 = n\n    local d = 1\n    while n1 ~= 0\
    \ do\n        local r = n1 % 2\n        n1 = (n1 - r) / 2\n        if r == 1 then\n\
    \            d = (d * n) % p\n        end\n        n = (n * n) % p\n    end\n\
    \    return d\nend", "\tif n < 0 then\n\t\treturn modp(n + p, p)\n\tend\n\tif\
    \ n < p then\n\t\treturn n\n\tend\n\tlocal k = n % p\n\tif n / p % 2 == 0 then\n\
    \t\treturn k\n\tend\n\treturn k - p\nend", "\tif n == 0 then\n\t\treturn 1\n\t\
    elseif n % 2 == 0 then\n\t\treturn modp(n/2, p)^2 % p\n\telse\n\t\treturn modp(n/2,\
    \ p)^2 * 2 % p\n\tend\nend", "    if p == 1 then\n        return 0\n    end\n\
    \    local res = 1\n    local exp = n\n    while exp > 0 do\n        if exp %\
    \ 2 == 1 then\n            res = (res * n) % p\n        end\n        exp = exp\
    \ // 2\n        n = (n * n) % p\n    end\n    return res\nend", "\t--raise error\
    \ if not tonumber\n\tlocal x = 2 % p\n\tlocal a = x\n\twhile n > 0 do\n\t\tif\
    \ (n % 2) == 1 then\n\t\t\tx = x * a % p\n\t\tend\n\t\ta = a ^ 2 % p\n\t\tn =\
    \ math.floor(n / 2)\n\tend\n\treturn x\nend", "  -- source: http://stackoverflow.com/a/10336481/323821\n\
    \  -- The answer in the link above is wrong. This is the correct version:\n  if\
    \ n == 0 then return 1 end\n  local res = 1\n  local v = n\n  -- Formula: 2^n\
    \ = 2^(n/2) * 2^(n/2) * 2^(n%2)\n  while v > 0 do\n    if v % 2 == 1 then\n  \
    \    res = (res * 2) % p\n    end\n    v = v / 2\n    if v > 0 then\n      res\
    \ = (res * res) % p\n    end\n  end\n  return res\nend", "  local res = 1\n  local\
    \ x = n % p\n  while n > 0 do\n    if n % 2 == 1 then\n      res = (res * x) %\
    \ p\n    end\n    n = math.floor(n / 2)\n    x = (x * x) % p\n  end\n  return\
    \ res\nend", "    local x = 1\n    for i = 0, n do\n        x = (x * 2) % p\n\
    \    end\n    return x\nend", "\tlocal r = 1\n\twhile n > 0 do\n\t\tif n % 2 ~=\
    \ 0 then\n\t\t\tr = r * 2 % p\n\t\tend\n\t\tn = math.floor(n / 2)\n\tend\n\treturn\
    \ r\nend", "  if n < 0 then\n    return modp(p-((-n)%p), p)\n  end\n  if n <=\
    \ 1 then\n    return n\n  end\n  if n%2 == 0 then\n    return (modp(n/2, p)^2)%p\n\
    \  else\n    return (modp(n/2, p)^2 * 2)%p\n  end\nend", "  local res = 1\n  while\
    \ n > 0 do\n    if n % 2 == 1 then\n      res = (res * 2) % p\n    end\n    n\
    \ = math.floor(n / 2)\n  end\n  return res\nend", "    local r = 1\n    while\
    \ n > 0 do\n        local a = n % 2\n        n = (n - a) / 2\n        if a ==\
    \ 1 then\n            r = (r * 2) % p\n        end\n    end\n    return r\nend",
  "\tlocal s = 1\n\tlocal r = n % p\n\twhile n > 0 do\n\t\tn = math.floor(n / 2)\n\
    \t\tif n % 2 == 1 then\n\t\t\ts = (s * r) % p\n\t\tend\n\t\tr = (r * r) % p\n\t\
    end\n\treturn s\nend", "  local res = 1\n  while n > 0 do\n    if (n & 1) == 1\
    \ then\n      res = (res * p) % m\n    end\n    p = (p * p) % m\n    n = n >>\
    \ 1\n  end\n  return res\nend", "    if n == 0 then\n        return 1\n    elseif\
    \ n == 1 then\n        return 2\n    elseif n % 2 == 0 then\n        return (modp(n/2,\
    \ p)^2 - 1) % p\n    else\n        return (2 * modp((n-1)/2, p)^2) % p\n    end\n\
    end", "    local n_p = n % p\n    return n_p < 0 and n_p + p or n_p\nend", " \
    \ if n == 0 then return 1 end\n  if n == 1 then return 2 end\n  if n == 2 then\
    \ return 4 end\n  local d = modp(n//2, p)\n  if n % 2 == 0 then\n    return (d*d)\
    \ % p\n  else\n    return (d*d*2) % p\n  end\nend", "\tif p == 2 then\n\t\treturn\
    \ 1\n\tend\n\tlocal d = 1\n\tn = n % p\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\
    \t\t\td = (d * 2) % p\n\t\tend\n\t\tn = math.floor(n / 2)\n\t\tif n > 0 then\n\
    \t\t\td = (d * d) % p\n\t\tend\n\tend\n\treturn d\nend", "\treturn p < 3 and (n%p)\
    \ or ((n%p) + p) % p\nend", "\t-- modulus powers of 2 are fast\n\tif bit.band(p,\
    \ p - 1) == 0 then\n\t\treturn bit.band(n, p - 1)\n\tend", "\tlocal res = 1\n\t\
    n = n % p\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tres = (res * 2) % p\n\
    \t\tend\n\t\tn = n // 2\n\tend\n\treturn res\nend", "\tlocal x = 1\n\tfor _ =\
    \ 1, n do\n\t\tx = mod(x * 2, p)\n\tend\n\treturn x\nend", "    local x = 1\n\
    \    local c = 1\n    while n > 0 do\n        if n % 2 == 1 then\n           \
    \ x = (x * c) % p\n        end\n        c = (c * c) % p\n        n = math.floor(n\
    \ / 2)\n    end\n    return x\nend", '  local acc = 1', "  -- Sometimes the result\
    \ is larger than p and modp will be called again\n  -- to get the final result.\
    \ In this case we don't want to call modp again.\n  if n == p then\n    return\
    \ 0\n  end\n  local r = 0\n  -- Lua 5.3 only\n  for i = 1, log2(n) + 1 do\n  \
    \  r = (2 * r) % p\n    -- The following check is the same as the bitwise check\n\
    \    -- `(n >> i - 1) & 1 == 1` in C.\n    if math.floor(n / (2 ^ (i - 1))) %\
    \ 2 == 1 then\n      r = (r + 1) % p\n    end\n  end\n  return r\nend", "  if\
    \ n == 0 then return 1 end\n  if n % 2 == 0 then\n    return modp(n / 2, p) ^\
    \ 2 % p\n  else\n    return 2 * modp(n - 1, p) % p\n  end\nend", "\tif p == 2\
    \ then\n\t\treturn 1\n\tend\n\tlocal r = n % p\n\tif n < 0 then\n\t\tr = r + p\n\
    \tend\n\treturn r\nend", "  local k = n % p\n  if k < 0 then\n    k = k + p\n\
    \  end\n  return k\nend", "  if n < p then\n    return n\n  end\n  local a = modp(math.floor(n\
    \ / 2), p)\n  a = (a * a) % p\n  if math.fmod(n, 2) == 1 then\n    a = (a * 2)\
    \ % p\n  end\n  return a\nend", "    if n == 0 then\n        return 1\n    elseif\
    \ n == 1 then\n        return 2\n    elseif n == 2 then\n        return 4\n  \
    \  elseif n == 3 then\n        return (4 * 2) % p\n    elseif n == 4 then\n  \
    \      return (4 * 4) % p\n    elseif n == 5 then\n        return (4 * 4 * 2)\
    \ % p\n    elseif n == 6 then\n        return (4 * 4 * 4) % p\n    elseif n ==\
    \ 7 then\n        return (4 * 4 * 4 * 2) % p\n    elseif n == 8 then\n       \
    \ return (4 * 4 * 4 * 4) % p\n    elseif n == 9 then\n        return (4 * 4 *\
    \ 4 * 4 * 2) % p\n    elseif n == 10 then\n        return (4 * 4 * 4 * 4 * 4)\
    \ % p\n    elseif n == 11 then\n        return (4 * 4 * 4 * 4 * 4 * 2) % p\n \
    \   elseif n == 12 then\n        return (4 * 4 * 4 * 4 * 4 * 4) % p\n    elseif\
    \ n == 13 then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 2) % p\n    elseif n ==\
    \ 14 then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 4) % p\n    elseif n == 15\
    \ then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 4 * 2) % p\n    elseif n == 16\
    \ then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 4 * 4) % p\n    elseif n == 17\
    \ then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 2) % p\n    elseif n ==\
    \ 18 then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4) % p\n    elseif\
    \ n == 19 then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 2) % p\n \
    \   elseif n == 20 then\n        return (4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4 * 4)\
    \ % p\n    elseif n == 21 then\n", "\treturn n%p\nend", "    return math.pow(2,\
    \ n) % p\nend", "    assert(n >= 0 and n <= p)\n    local res = 1\n    while n\
    \ > 0 do\n        if n % 2 == 1 then\n            res = (res * 2) % p\n      \
    \  end\n        n = math.floor(n / 2)\n    end\n    return res\nend", "  local\
    \ result = 1\n  local x = 2\n  while n > 0 do\n    if n % 2 == 1 then\n      result\
    \ = (result * x) % p\n    end\n    n = math.floor(n / 2)\n    x = (x * x) % p\n\
    \  end\n  return result\nend", "\tlocal p = tfmdata.parameters.moduli[p]\n\tif\
    \ not p then\n\t\terror(\"modulus \" .. p .. \" is not supported.\")\n\tend\n\t\
    if n == 0 then\n\t\treturn 1\n\telseif n == 1 then\n\t\treturn 0\n\telseif n ==\
    \ 2 then\n\t\treturn p\n\telse\n\t\tlocal g\n\t\t-- Use truncation by default.\
    \ If a font explicitly sets the\n\t\t-- variant, we use a potentially slower method,\
    \ but with more\n\t\t-- reliable numerics.\n\t\tif tfmdata.parameters.variant\
    \ == 0 then\n\t\t\tg = n % p\n\t\telse\n\t\t\tg = tonumber(tostring(n):match(\"\
    ^0*(.-)$\"))\n\t\t\tg = g % p\n\t\tend\n\t\tif g == 0 then\n\t\t\treturn 1\n\t\
    \telse\n\t\t\treturn g\n\t\tend\n\tend\nend", "  -- TODO: Implement this function\n\
    end", "    assert(n >= 0 and p > 1, \"argument must be non-negative integer and\
    \ prime\")\n    return n == 0 and 1 or n % p * modp(math.floor(n / p), p) % p\n\
    end", "    local result = 1\n    for _=1,n do\n        result = result * 2 % p\n\
    \    end\n    return result\nend", "\tlocal t, r = {}, 1\n\twhile n > 0 do\n\t\
    \tif n % 2 == 1 then\n\t\t\tr = mulmod(r, t[1] or 2, p)\n\t\t\ttable.insert(t,\
    \ 2)\n\t\telse\n\t\t\ttable.insert(t, 1)\n\t\tend\n\t\tn = n // 2\n\tend\n\tfor\
    \ i = #t, 1, -1 do\n\t\tt[i] = mulmod(t[i], t[i], p)\n\tend\n\treturn r\nend",
  "    if n < 1 then\n        return 1\n    end\n    local mod = math.mod\n    local\
    \ mod_one = mod(n, p)\n    local mod_two = mod(mod_one * mod_one, p)\n    if n\
    \ % 2 == 0 then\n        return mod_two\n    else\n        return mod(mod_two\
    \ * mod_one, p)\n    end\nend", "  if n == 0 then return 1 end\n  if n == 1 then\
    \ return n end\n  local l = floor(n / 2)\n  local m = modp(l, p)\n  if n % 2 ==\
    \ 0 then\n    return (m * m) % p\n  else\n    return (m * m * 2) % p\n  end\n\
    end", "    -- Since we are working modulo p and p is prime, we only need to work\n\
    \    -- modulo a factor of p-1.\n    --\n    -- Let p-1 = k*2^m+1 (that is, the\
    \ factor of p-1 is a power of 2).\n    -- Then p^n = 1 (mod p) if and only if\
    \ p^(k*2^m*(n div k)) = 1 (mod p)\n    -- if and only if p^(2^m*(n div k)) = 1\
    \ (mod p)\n    -- if and only if (p^(2^(m-1))^2)^(n div k) = 1 (mod p)\n    --\
    \ if and only if ((p^(2^(m-1)))^2)^(n div k) = 1 (mod p)\n    --\n    -- So we\
    \ can just repeatedly square, and then take the n div k'th power,\n    -- and\
    \ then take that modulo p.\n    local k = p - 1\n    local factor = k\n    local\
    \ m = 0\n    while (factor % 2) == 0 do\n        factor = math.floor(factor /\
    \ 2)\n        m = m + 1\n    end\n    local r = p\n    while r > 2 do\n      \
    \  if (r % 2) == 0 then\n            r = (r * r) % p\n        else\n         \
    \   r = (r * r * p) % p\n        end\n    end\n    -- Now r is p^(2^(m-1)) mod\
    \ p\n    for i = 1, (n // k) do\n        r = (r * r) % p\n    end\n    return\
    \ r\nend", "    local res = 1\n    while n > 0 do\n        if n % 2 == 1 then\n\
    \            res = (res * 2) % p\n        end\n        n = math.floor(n / 2)\n\
    \    end\n    return res\nend", "\tif n < p then\n\t\treturn n\n\tend\n\tlocal\
    \ c = math.floor(n / p)\n\treturn n - c * p\nend", "  if n == 0 then return 1\
    \ end\n  if n == 1 then return 2 end\n  local k = math.floor(n/2)\n  local b =\
    \ 2*modp(k, p)\n  if b >= p then b = b - p end\n  if n % 2 == 0 then return b\n\
    \  else return 2*b end\nend", "  if p == 2 then\n    return 1\n  end\n  local\
    \ s = 1\n  for i = 1, n do\n    s = s * 2\n    if s >= p then\n      s = s - p\n\
    \    end\n  end\n  return s\nend", "  local res = 1\n  while n > 0 do\n    if\
    \ n % 2 == 1 then\n      res = (res * a) % p\n    end\n    a = (a * a) % p\n \
    \   n = math.floor(n / 2)\n  end\n  return res\nend", "    local modn = n % p\n\
    \    if modn == 0 then\n        return 1\n    else\n        local mod2n = 2^modn\
    \ % p\n        return mod2n\n    end\nend", "    local r = 1\n    local d = 2\n\
    \    local modulus = p\n    local nn = n\n    if n == 0 then\n        return 1\n\
    \    end\n    while nn > 0 do\n        local q = nn % 2\n        nn = (nn - q)\
    \ / 2\n        if q == 1 then\n            r = (r * d) % modulus\n        end\n\
    \        d = (d * d) % modulus\n    end\n    return r\nend", "    if n == 0 then\n\
    \        return 1\n    elseif n % 2 == 0 then\n        return sqr(modp(n/2, p))\
    \ % p\n    else\n        return (modp(n-1, p) * n) % p\n    end\nend", "  local\
    \ res = 1\n  for i = 1, n do\n    res = (res * 2) % p\n  end\n  return res\nend",
  "  local p2 = p*p\n  local p4 = p2*p2\n  local p8 = p4*p4\n  local p16 = p8*p8\n\
    \  local p32 = p16*p16\n  local p64 = p32*p32\n  local p128 = p64*p64\n  local\
    \ p256 = p128*p128\n  local p512 = p256*p256\n  local p1024 = p512*p512\n  local\
    \ p2048 = p1024*p1024\n  local p4096 = p2048*p2048\n  local p8192 = p4096*p4096\n\
    \  local p16384 = p8192*p8192\n  local p32768 = p16384*p16384\n  local p65536\
    \ = p32768*p32768\n  local p131072 = p65536*p65536\n  local p262144 = p131072*p131072\n\
    \  local p524288 = p262144*p262144\n  local p1048576 = p524288*p524288\n  local\
    \ p2097152 = p1048576*p1048576\n  local p4194304 = p2097152*p2097152\n  local\
    \ p8388608 = p4194304*p4194304\n  local p16777216 = p8388608*p8388608\n  local\
    \ p33554432 = p16777216*p16777216\n  local p67108864 = p33554432*p33554432\n \
    \ local p134217728 = p67108864*p67108864\n  local p268435456 = p134217728*p134217728\n\
    \  local p536870912 = p268435456*p268435456\n  local p1073741824 = p536870912*p536870912\n\
    \  local p2147483648 = p1073741824*p1073741824\n  local p4294967296 = p2147483648*p2147483648\n\
    \  local p8589934592 = p4294967296*p4294967296\n  local p17179869184", "  local\
    \ w, x = 1, 1\n  local bit, lshift, and = bit32.bnot, bit32.lshift, bit32.band\n\
    \  local y, z = p, p\n  n = n % p\n  if n == 0 then return 1 end\n  while n ~=\
    \ 0 do\n    while bit(and(n, z)) == 0 do\n      x = (x * w) % p\n      z = bit(lshift(z,\
    \ 1))\n    end\n    w = (w * w) % p\n    z = bit(lshift(z, 1))\n    y = (y * y)\
    \ % p\n    n = bit(and(n, z))\n  end\n  return x\nend", "  -- Some numerics are\
    \ so bad that this is needed (p is a prime).\n  if n == 0 then return 1 end\n\
    \  local a = 1\n  local b = 2\n  while n > 0 do\n    if n % 2 == 1 then\n    \
    \  a = a * b % p\n    end\n    b = b * b % p\n    n = n / 2\n  end\n  return a\n\
    end", "    assert(p > 1, \"invalid p\")\n    if n == 0 then\n        return 1\n\
    \    elseif n == 1 then\n        return n\n    elseif p > 2^30 then\n        return\
    \ 0 -- numerics\n    else\n        local m = modp(n // 2, p)\n        if n % 2\
    \ == 0 then\n            return (m * m) % p\n        else\n            return\
    \ (m * m * 2) % p\n        end\n    end\nend", "    -- Implementation follows\
    \ \"Modular Binary Exponentiation\" in the Wikipedia.\n    -- See also: http://stackoverflow.com/questions/1221833/\n\
    \    --           http://en.wikipedia.org/wiki/Modular_exponentiation#Memory-efficient_method\n\
    \    local b = 1\n    while n > 0 do\n        if n % 2 == 1 then\n           \
    \ b = (b * 2) % p\n        end\n        n = n // 2\n    end\n    return b\nend",
  "    if p == 2 then\n        return n % 2 == 0 and 2 or 1\n    end\n    local modulus\
    \ = p - 1\n    local m = n\n    local result = 1\n    while m > 0 do\n       \
    \ -- print(m, modulus, result)\n        if m % 2 == 1 then\n            result\
    \ = (result * modulus) % p\n        end\n        modulus = (modulus * modulus)\
    \ % p\n        m = math.floor(m / 2)\n    end\n    return result\nend", "  --\
    \ check for small values\n  if p < 3 then\n    if p == 0 then\n      return 0\n\
    \    elseif p == 1 then\n      return 1\n    elseif p == 2 then\n      return\
    \ n % 2\n    end\n  end", "    local m = 1\n    for i = 1, n do\n        m = (m\
    \ * 2) % p\n    end\n    return m\nend", "    local r = 1\n    while n > 0 do\n\
    \        if n % 2 == 1 then\n            r = (r * 2) % p\n        end\n      \
    \  n = floor(n / 2)\n    end\n    return r\nend", "\tlocal base = n % p\n\tlocal\
    \ result = base\n\tfor i = 1, n-1 do\n\t\tresult = (result * base) % p\n\tend\n\
    \treturn result\nend", "    if p == 1 then\n        return 0\n    end\n    local\
    \ s = 2\n    while 2^s < p do\n        s = s + 1\n    end\n    local a = tostring(n)\n\
    \    local N = #a\n    local bs = {}\n    for i = N, 1, -1 do\n        table.insert(bs,\
    \ a:sub(i, i))\n    end\n    local t = {}\n    t[1] = 1\n    for i = 2, s do\n\
    \        t[i] = (t[i - 1] * t[i - 1]) % p\n    end\n    local r = 0\n    for i\
    \ = 1, N do\n        r = (r * 2) % p\n        if bs[i] == \"1\" then\n       \
    \     r = (r + 1) % p\n        end\n    end\n    local f = 0\n    for i = N +\
    \ 1, s do\n        f = (f * 2) % p\n    end\n    local v = r\n    for i = s, 1,\
    \ -1 do\n        if n >= f then\n            n = n - f\n            v = (v * t[i])\
    \ % p\n        end\n        f = math.floor(f / 2)\n    end\n    return v\nend",
  "    local x = 1\n    while n > 0 do\n        if n % 2 == 1 then\n            x\
    \ = (x * 2) % p\n        end\n        n = floor(n / 2)\n    end\n    return x\n\
    end", "  if n == 0 then return 1 end\n  local res = 1\n  local y = 2\n  n = n\
    \ % (p - 1)\n  while n > 0 do\n    if n % 2 == 1 then\n      res = (res * y) %\
    \ p\n    end\n    y = (y * y) % p\n    n = floor(n / 2)\n  end\n  return res\n\
    end", "  local t = 1\n  for i = 1, n do\n    t = (t * 2) % p\n  end\n  return\
    \ t\nend", "  if n == 0 then\n    return 1\n  elseif n == 1 then\n    return 0\n\
    \  elseif n % 2 == 0 then\n    return modp(n / 2, p) ^ 2 % p\n  else\n    return\
    \ 2 * modp(n - 1, p) % p\n  end\nend", "  local n1 = 1;\n  local n2 = 0;\n  local\
    \ p1 = 0;\n  local p2 = 1;\n  local q = math.floor(n / p);\n  local r = n % p;\n\
    \  while r ~= 0 do\n    n = p;\n    p = r;\n    q = math.floor(n / p);\n    r\
    \ = n % p;\n    local tmp = n1 - q * p1;\n    n1 = p1;\n    p1 = tmp;\n    tmp\
    \ = n2 - q * p2;\n    n2 = p2;\n    p2 = tmp;\n  end\n  if p2 < 0 then\n    p2\
    \ = p2 + n;\n  end\n  return p2;\nend", "  assert(n and p)\n  local r = 1", " \
    \   local x = 1\n    for i = 1, n do\n        x = (x * 2) % p\n    end\n    return\
    \ x\nend", "  assert(n >= 0 and p > 0, 'modp only works for n>=0 and p>0')\n \
    \ -- see if we can reduce n first\n  if p == 1 then return 0 end\n  if n == 0\
    \ then return 1 end\n  -- it's actually faster to do it this way, even if we don't\n\
    \  -- use the result of modp(a, p)\n  local x = 1\n  for _ = 0, 31 do\n    if\
    \ n % 2 == 1 then\n      x = (x * 2) % p\n    end\n    n = math.floor(n / 2)\n\
    \    if n == 0 then break end\n  end\n  return x\nend", "  if p == 2 then\n  \
    \  return 1\n  end\n  local q = p\n  local m = 1\n  while n > 0 do\n    if n %\
    \ 2 == 1 then\n      m = (m * q) % p\n    end\n    q = (q * q) % p\n    n = math.floor(n\
    \ / 2)\n  end\n  return m\nend", "\tlocal result = 1\n\tlocal b = n % (p - 1)\n\
    \twhile b > 0 do\n\t\tresult = (result * 2) % p\n\t\tb = b - 1\n\tend\n\treturn\
    \ result\nend", "    if p == 2 then\n        return 1\n    end\n    local res\
    \ = 1\n    n = n % p\n    while n > 0 do\n        if n % 2 == 1 then\n       \
    \     res = (res * n) % p\n        end\n        n = math.floor(n / 2)\n      \
    \  n = (n * n) % p\n    end\n    return res\nend", "\tlocal result = 1\n\tlocal\
    \ factor = 2\n\tlocal remainder = n\n\twhile remainder > 0 do\n\t\tlocal x = floor(remainder\
    \ / 2)\n\t\tlocal y = remainder - 2 * x\n\t\tremainder = x\n\t\tif y == 1 then\n\
    \t\t\tresult = (result * factor) % p\n\t\tend\n\t\tfactor = (factor * factor)\
    \ % p\n\tend\n\treturn result\nend", "    -- O(n)\n    local b = 1\n    local\
    \ nn = n\n    while nn > 0 do\n        if nn % 2 == 1 then\n            b = b\
    \ * n % p\n        end\n        nn = math.floor(nn / 2)\n        n = n * n % p\n\
    \    end\n    return b\nend", "  local res = 1\n  while n > 0 do\n    if n % 2\
    \ == 1 then\n      res = (res * 2) % p\n    end\n    n = math.floor(n / 2)\n \
    \ end\n  return res\nend", "  local l, r = math.floor(n/2), math.fmod(n, 2)\n\
    \  if l == 0 then return r\n  else return (2 * modp(l, p) + r) % p\n  end\nend",
  "    if n == 0 then\n        return 1\n    elseif n % 2 == 0 then\n        return\
    \ ((modp(n / 2, p) % p) * (modp(n / 2, p) % p)) % p\n    else\n        return\
    \ ((modp(n / 2, p) % p) * (modp(n / 2, p) % p) * 2) % p\n    end\nend", "    if\
    \ n == 0 then\n        return 1\n    elseif n == 1 then\n        return 0\n  \
    \  elseif n % 2 == 0 then\n        local x = modp(n / 2, p)\n        return (2\
    \ * x * x) % p\n    else\n        return (2 * modp(n - 1, p)) % p\n    end\nend",
  "    local x = 1\n    for i = 1, n do\n        x = (x * 2) % p\n    end\n    return\
    \ x\nend", "  local res = 1\n  local b = n\n  while b > 0 do\n    if bit.band(b,\
    \ 1) == 1 then\n      res = (res * n) % p\n    end\n    n = (n * n) % p\n    b\
    \ = bit.rshift(b, 1)\n  end\n  return res\nend", "\tlocal r = 1\n\twhile n > 0\
    \ do\n\t\tif n % 2 ~= 0 then\n\t\t\tr = (r * 2) % p\n\t\tend\n\t\tn = math.floor(n\
    \ / 2)\n\tend\n\treturn r\nend", "\t-- Consider the binary expansion of n:\n\t\
    -- n = sum(b_i 2^i)\n\t--\n\t-- Then,\n\t-- 2^n mod p = prod(2^(b_i 2^i) mod p)\n\
    \t--           = prod(2^(2^i)^b_i mod p)\n\t--           = prod(2^(2^i) mod p)^b_i\n\
    \tlocal function pow2(k)\n\t\treturn (2^k % p)^2\n\tend\n\tlocal function helper(k)\n\
    \t\tlocal pk = pow2(k)\n\t\tif n % (2^k) == 0 then\n\t\t\treturn helper(k+1)\n\
    \t\telse\n\t\t\treturn (pk * modp(n % (2^k), p)) % p\n\t\tend\n\tend\n\treturn\
    \ (n == 0) and 1 or helper(1)\nend", "  if n < p then\n    return n\n  end\n \
    \ local rem = n % p\n  return rem == 0 and p or rem\nend", "    local a = 1;\n\
    \    while n > 0 do\n        if n % 2 == 1 then\n            a = (a * 2) % p;\n\
    \        end\n        n = math.floor(n / 2);\n    end\n    return a;\nend", " \
    \   local result = 1\n    local c = n % p\n    while c > 0 do\n        if bit.band(c,\
    \ 1) == 1 then\n            result = (result * 2) % p\n        end\n        c\
    \ = bit.rshift(c, 1)\n    end\n    return result\nend", "  local result = 1\n\
    \  while n > 0 do\n    if n % 2 == 1 then\n      result = (result * 2) % p\n \
    \   end\n    n = math.floor(n / 2)\n  end\n  return result\nend", "  local result\
    \ = 1\n  local x = n % p\n  while n > 0 do\n    if n % 2 == 1 then\n      result\
    \ = (result * x) % p\n    end\n    n = math.floor(n / 2)\n    x = (x * x) % p\n\
    \  end\n  return result\nend", "    if n == 0 then\n        return 1\n    elseif\
    \ n % 2 == 0 then\n        local y = modp(n / 2, p)\n        return (y * y) %\
    \ p\n    else\n        return (modp(n - 1, p) * 2) % p\n    end\nend", "  local\
    \ res = 1\n  n = n % p\n  while n > 0 do\n    if n % 2 == 1 then\n      res =\
    \ (res * 2) % p\n    end\n    n = math.floor(n / 2)\n  end\n  return res\nend",
  "    local b = 1\n    while (n > 0) do\n        if n % 2 == 1 then\n           \
    \ b = (b * 2) % p\n        end\n        n = n // 2\n    end\n    return b\nend",
  "  local r = 1\n  local d = 2\n  while n > 0 do\n    if n % 2 == 1 then\n      r\
    \ = (r * d) % p\n    end\n    n = math.floor(n / 2)\n    d = (d * d) % p\n  end\n\
    \  return r\nend", "    return tonumber(tostring(n) % p)\nend", "  local result\
    \ = 1\n  for i = 1, n do\n    result = (result * 2) % p\n  end\n  return result\n\
    end", "    if n == 0 then\n        return 1\n    elseif n % 2 == 0 then\n    \
    \    return modp(n/2, p)^2 % p\n    else\n        return modp(n-1, p) * 2 % p\n\
    \    end\nend", "    local res = 1\n    local r = n % p\n    while n > 0 do\n\
    \        if n % 2 == 1 then\n            res = (res * r) % p\n        end\n  \
    \      n = math.floor(n / 2)\n        r = (r * r) % p\n    end\n    return res\n\
    end", "\treturn (n % p + p) % p\nend", "    -- Given the representation of a number\
    \ as a list of digits,\n    -- we can compute b^n mod p in O(n) multiplications,\
    \ using O(n) space.\n    -- We exploit that b^(k*p) mod p = b^k mod p if p is\
    \ prime.\n    -- To avoid the factors of 2 and 5, we shift left until we reach\
    \ an odd number,\n    -- so that we can only use odd number as factors.\n    --\
    \ Numbers with a lot of trailing zeros are avoided by using the table `mods`\n\
    \    -- that helps to quickly eliminate trailing zeros.\n    local mods = {}\n\
    \    local function mods_calc(n)\n        n = n - n % 2\n        mods[n] = n\n\
    \        for i = n-2, n-p, -2 do\n            mods[i] = (i+2) * mods[i+2]\n  \
    \      end\n    end\n    mods_calc(n)\n    local function modp(n, p)\n       \
    \ if n == 0 then return 1 end\n        if n % 2 == 0 then\n            return\
    \ (2 * modp(n / 2, p)) % p\n        else\n            return (b * modp(n - 1,\
    \ p)) % p\n        end\n    end\n    return modp(n - n % p, p)\nend", "    local\
    \ a = 1\n    local b = 2", "    local exp = p-2\n    local base = n % p\n    local\
    \ res = 1\n    while exp > 0 do\n        if exp % 2 == 1 then\n            res\
    \ = (res * base) % p\n        end\n        exp = math.floor(exp / 2)\n       \
    \ base = (base * base) % p\n    end\n    return res\nend", "  local d = 0\n  for\
    \ i = n, 0, -1 do\n    d = (d * 2) % p\n  end\n  return d\nend", "    if (n <\
    \ 0) then return 0 end\n    local bit_string = to_binary(n)\n    local result\
    \ = 1\n    for i = 1, #bit_string do\n        result = (result * result) % p\n\
    \        if (bit_string[i] == 1) then\n            result = (result * 2) % p\n\
    \        end\n    end\n    return result\nend", "  local r = 1\n  local x = 2\n\
    \  while n > 0 do\n    if n % 2 == 1 then\n      r = r * x % p\n    end\n    x\
    \ = x * x % p\n    n = math.floor(n / 2)\n  end\n  return r\nend", "\t-- Using\
    \ the approach from the wikipedia article\n\t-- https://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method\n\
    \t-- which is the same as the one taught in university (implemented in C in\n\t\
    -- the section above).\n\tlocal ret = 1\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\
    \t\t\tret = (ret * 2) % p\n\t\tend\n\t\tn = math.floor(n / 2)\n\tend\n\treturn\
    \ ret\nend", "  assert(p >= 2)\n  if n < 0 then\n    n = n % p + p\n  end\n  while\
    \ n >= p do\n    n = n % p\n  end\n  return n\nend", "    local function sq(n)\n\
    \        local sq, r = math.floor(math.sqrt(n))\n        if sq * sq == n then\n\
    \            return sq\n        else\n            return nil\n        end\n  \
    \  end", "  if p == 2 then\n    return 1\n  end\n  local result = 1\n  while n\
    \ > 0 do\n    if n % 2 == 1 then\n      result = (result * 2) % p\n    end\n \
    \   n = math.floor(n / 2)\n  end\n  return result\nend", "  local res = 1\n  local\
    \ b = 2\n  while n > 0 do\n    if (n % 2) ~= 0 then\n      res = (res * b) % p\n\
    \    end\n    n = math.floor(n / 2)\n    b = (b * b) % p\n  end\n  return res\n\
    end", "\tlocal one = 1\n\twhile n >= p do\n\t\tif n % 2 == 1 then\n\t\t\tone =\
    \ (one * 2) % p\n\t\tend\n\t\tn = n / 2\n\tend\n\tone = (one * n) % p\n\treturn\
    \ one\nend", "\tif n == 0 then\n\t\treturn 1\n\telseif n % 2 == 0 then\n\t\treturn\
    \ (modp(n/2, p)^2) % p\n\telse\n\t\treturn (2 * modp(n - 1, p)) % p\n\tend\nend",
  "    local x = 1\n    for i = 1, n do\n        x = x * 2 % p\n    end\n    return\
    \ x\nend", "\tlocal r = 1\n\tfor bit in tobinary(n) do\n\t\tr = (r * r) % p\n\t\
    \tif bit == 1 then\n\t\t\tr = (r * 2) % p\n\t\tend\n\tend\n\treturn r\nend", " \
    \   if n == 0 then\n        return 1\n    elseif n == 1 then\n        return 2\n\
    \    elseif n == 2 then\n        return 4\n    elseif n == 3 then\n        return\
    \ 8\n    elseif n == 4 then\n        return 16\n    elseif n == 5 then\n     \
    \   return 32\n    elseif n == 6 then\n        return 64\n    elseif n == 7 then\n\
    \        return 128\n    elseif n == 8 then\n        return 27\n    elseif n ==\
    \ 9 then\n        return 54\n    elseif n == 10 then\n        return 108\n   \
    \ elseif n == 11 then\n        return 216\n    elseif n == 12 then\n        return\
    \ 89\n    elseif n == 13 then\n        return 179\n    elseif n == 14 then\n \
    \       return 89\n    elseif n == 15 then\n        return 179\n    elseif n ==\
    \ 16 then\n        return 89\n    elseif n == 17 then\n        return 179\n  \
    \  elseif n == 18 then\n        return 89\n    elseif n == 19 then\n        return\
    \ 179\n    elseif n == 20 then\n        return 89\n    elseif n == 21 then\n \
    \       return 179\n    elseif n == 22 then\n        return 89\n    elseif n ==\
    \ 23 then\n        return 179\n    elseif n == 24 then\n        return 89\n  \
    \  elseif n == 25 then\n        return 179\n    elseif n == 26 then\n        return\
    \ 89\n    elseif n == 27 then\n        return 179\n    elseif n == 28 then\n \
    \       return 89\n    elseif n == 29 then\n        return 179\n    elseif n ==\
    \ 30 then\n        return 89\n    elseif n == 31 then\n        return 179\n  \
    \  elseif n == 32 then\n        return 89\n    elseif n == 33 then\n        return\
    \ 179\n    elseif n == 34 then\n        return 89\n    elseif n == 35 then\n \
    \       return 179\n    elseif n == 36 then\n        return 89\n    elseif n ==\
    \ 37 then\n        return 179\n    elseif n == 38 then\n        return 89\n  \
    \  elseif n == 39 then\n        return 179\n    elseif n == 40 then\n        return\
    \ 89\n    elseif n == 41 then\n        return 179\n    elseif n == 42 then\n",
  "\tlocal result = 1", "    local r = 1\n    while n ~= 0 do\n        if n % 2 ==\
    \ 1 then\n            r = r * 2 % p\n        end\n        n = math.floor(n / 2)\n\
    \    end\n    return r\nend", "\tif p == 1 then\n\t\treturn 0\n\tend\n\tlocal\
    \ r = 1\n\tlocal d = n\n\twhile d > 0 do\n\t\tlocal q = d // 2\n\t\tlocal k =\
    \ d - 2 * q\n\t\tif k > 0 then\n\t\t\tr = (r * n) % p\n\t\tend\n\t\tn = (n * n)\
    \ % p\n\t\td = q\n\tend\n\treturn r\nend", "  local np = n % p\n  if np < 0 then\n\
    \    np = np + p\n  end\n  return np\nend", "  if p == 1 then return 0 end\n \
    \ return (n % p + p) % p\nend", "  local res = 1\n  local a = 2 % p\n  while n\
    \ > 0 do\n    if n % 2 == 1 then\n      res = (res * a) % p\n    end\n    n =\
    \ math.floor(n / 2)\n    a = (a * a) % p\n  end\n  return res\nend", "  if n ==\
    \ 0 then return 1 end\n  local t = modp(math.floor(n/2), p)\n  t = (t*t) % p\n\
    \  if n % 2 == 1 then\n    t = (t*2) % p\n  end\n  return t\nend", "  if n < p\
    \ then\n    return n\n  end\n  local r = 0\n  local d = 1\n  while n > 0 do\n\
    \    r = r + (n % 2) * d\n    n = math.floor(n / 2)\n    d = d * 2\n  end\n  return\
    \ r\nend", "  if n < 0 then n = n % p + p end\n  return bm.mod(2^n, p)\nend",
  "    local x = 1\n    local pow = n\n    while pow > 0 do\n        if pow % 2 ~=\
    \ 0 then\n            x = (x * n) % p\n        end\n        n = (n * n) % p\n\
    \        pow = pow // 2\n    end\n    return x\nend", "    -- TODO: handle n >\
    \ p\n    if n == 0 then\n        return 1\n    elseif n % 2 == 0 then\n      \
    \  return (modp(n / 2, p) ^ 2) % p\n    else\n        return (modp(n - 1, p) *\
    \ 2) % p\n    end\nend", "\t-- We only need to work with absolute values.\n\t\
    n = math.abs(n)\n\tp = math.abs(p)", "  if n == 0 then return 1 end\n  local res\
    \ = modp(n/2, p)^2 % p\n  if n % 2 == 1 then res = res * 2 % p end\n  return res\n\
    end", "    assert(n >= 0, \"modp: number must be non-negative\")\n    assert(p\
    \ > 1, \"modp: base must be greater than 1\")\n    local y = 1\n    local x =\
    \ n\n    while x ~= 0 do\n        local r = x % 2\n        if r == 1 then\n  \
    \          y = y * p\n        end\n        p = p * p\n        x = x // 2\n   \
    \ end\n    return y % modulus\nend", "  local r = 1\n  local x = 2 % p\n  local\
    \ m = n\n  while m > 0 do\n    if m % 2 == 1 then\n      r = (r * x) % p\n   \
    \ end\n    m = math.floor(m / 2)\n    x = (x * x) % p\n  end\n  return r\nend",
  "  if n == 0 then return 1 end\n  if n == 1 then return 2 end\n  local acc = 1\n\
    \  local m = n\n  while m > 0 do\n    if m % 2 == 1 then\n      acc = (acc * 2)\
    \ % p\n    end\n    m = m // 2\n    local r = 2 * 2 % p\n    if r ~= 4 then\n\
    \      return nil, \"numerics! (p = \" .. p .. \")\"\n    end\n  end\n  return\
    \ acc\nend", "    local t = 1\n    local n = n % p\n    for i = 1, n do\n    \
    \    t = (t * 2) % p\n    end\n    return t\nend", "    local r = 1\n    local\
    \ b = n\n    while n > 0 do\n        local z = n % 2\n        if z == 1 then\n\
    \            r = (r * b) % p\n        end\n        n = math.floor(n / 2)\n   \
    \     b = (b * b) % p\n    end\n    return r\nend", "    if (n == 0) then\n  \
    \      return 1\n    elseif (n % 2 == 0) then\n        return modp(n/2, p)^2 %\
    \ p\n    else\n        return modp(n-1, p) * modp(n+1, p) % p\n    end\nend",
  "    if n == 0 then\n        return 1\n    elseif n == 1 then\n        return 2\n\
    \    elseif n % 2 == 0 then\n        local m = modp(n / 2, p)\n        return\
    \ (m * m) % p\n    else\n        return (2 * modp(n - 1, p)) % p\n    end\nend",
  "\tif n < 0 then\n\t\treturn modp(n + p, p)\n\tend\n\t\n\tif n == 0 then\n\t\treturn\
    \ 1\n\tend\n\t\n\tif math.floor(n / 2) * 2 == n then\n\t\treturn (modp(n / 2,\
    \ p) ^ 2) % p\n\telse\n\t\treturn (modp(n - 1, p) * 2) % p\n\tend\nend", "   \
    \ if n == 0 then\n        return 1\n    elseif n % 2 == 0 then\n        local\
    \ h = modp(n/2, p)\n        return (h * h) % p\n    else\n        return (2 *\
    \ modp(n-1, p)) % p\n    end\nend", "    local x = 1\n    local y = 1\n    while\
    \ y ~= 0 do\n        local remain = math.fmod(n, 2)\n        if remain == 1 then\n\
    \            x = math.fmod(x * y, p)\n        end\n        y = math.fmod(y * y,\
    \ p)\n        n = math.floor(n / 2)\n    end\n    return x\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
