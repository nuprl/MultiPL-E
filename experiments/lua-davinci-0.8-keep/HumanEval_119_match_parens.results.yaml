name: HumanEval_119_match_parens
language: lua
results:
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local count = 0\n  for _, s in ipairs(lst) do\n    for i = 1, #s do\n     \
    \ if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return 'No'\n     \
    \ end\n    end\n  end\n  return 'Yes'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppmnjzx13.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmppmnjzx13.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local cnt = 0\n  for _, s in ipairs(lst) do\n    cnt = cnt + count_parens(s)\n\
    \  end\n  return cnt == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpx_5vpu7l.lua:15:\
    \ attempt to call a nil value (global 'count_parens')\nstack traceback:\n\t/tmp/tmpx_5vpu7l.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpx_5vpu7l.lua:23: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s = table.concat(lst)\n  local count = 0\n  for i = 1, #s do\n    if\
    \ s:sub(i, i) == '(' then\n      count = count + 1\n    else\n      count = count\
    \ - 1\n    end\n    if count < 0 then\n      return 'No'\n    end\n  end\n  return\
    \ count == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyawf0h7h.lua:34:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpyawf0h7h.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = table.unpack(lst)\n  local ok = false\n  local function helper(s1,\
    \ s2)\n    if s1 == '' and s2 == '' then\n      ok = true\n      return\n    end\n\
    \    if s1 == '' and s2 ~= '' then\n      return\n    end\n    if s1 ~= '' and\
    \ s2 == '' then\n      local t = {}\n      for c in s1:gmatch('.') do\n      \
    \  table.insert(t, c)\n      end\n      local l, r = 0, 0\n      for _, v in ipairs(t)\
    \ do\n        if v == '(' then\n          l = l + 1\n        else\n          r\
    \ = r + 1\n        end\n        if r > l then\n          return\n        end\n\
    \      end\n      if l == r then\n        ok = true\n        return\n      end\n\
    \    end\n    helper(s1, s2:sub(2))\n    helper(s1:sub(2), s2)\n  end\n  helper(s1,\
    \ s2)\n  return ok and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpudr9v7uv.lua:25:\
    \ stack overflow\nstack traceback:\n\t/tmp/tmpudr9v7uv.lua:25: in upvalue 'helper'\n\
    \t/tmp/tmpudr9v7uv.lua:44: in upvalue 'helper'\n\t/tmp/tmpudr9v7uv.lua:44: in\
    \ upvalue 'helper'\n\t/tmp/tmpudr9v7uv.lua:44: in upvalue 'helper'\n\t/tmp/tmpudr9v7uv.lua:44:\
    \ in upvalue 'helper'\n\t/tmp/tmpudr9v7uv.lua:44: in upvalue 'helper'\n\t/tmp/tmpudr9v7uv.lua:44:\
    \ in upvalue 'helper'\n\t/tmp/tmpudr9v7uv.lua:44: in upvalue 'helper'\n\t/tmp/tmpudr9v7uv.lua:44:\
    \ in upvalue 'helper'\n\t...\n\t/tmp/tmpudr9v7uv.lua:47: in local 'candidate'\n\
    \t/tmp/tmpudr9v7uv.lua:54: in function 'test_humaneval'\n\nRan 1 tests in 1.220\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function recur(cnt, str)\n        if #str == 0 then\n            return\
    \ cnt == 0\n        end\n        if cnt < 0 then\n            return false\n \
    \       end\n        if str:sub(1, 1) == '(' then\n            return recur(cnt\
    \ + 1, str:sub(2))\n        else\n            return recur(cnt - 1, str:sub(2))\n\
    \        end\n    end\n    if recur(0, lst[1] .. lst[2]) then\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp06myna0r.lua:39:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp06myna0r.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local stack = {}\n  local wrong = 0\n  for i = 1, #lst do\n    for c in lst[i]:gmatch\"\
    .\" do\n      if c == '(' then\n        table.insert(stack, c)\n      else\n \
    \       if #stack == 0 then\n          wrong = 1\n        else\n          table.remove(stack)\n\
    \        end\n      end\n    end\n  end\n  return (wrong == 0 and #stack == 0)\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqazqx2r5.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpqazqx2r5.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local count = 0\n  for _, s in ipairs(lst) do\n    for _, c in ipairs(s:gmatch('.'))\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return 'No'\n     \
    \ end\n    end\n  end\n  return count == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\nattempt to\
    \ index a function value\nstack traceback:\n\nRan 1 tests in 0.000 seconds, 0\
    \ successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  if #s1 == 0 and #s2 == 0 then\n    return\
    \ 'Yes'\n  end\n  if #s1 == 0 then\n    local unclosed_count = 0\n    for i =\
    \ 1, #s2 do\n      if s2:sub(i, i) == ')' then\n        unclosed_count = unclosed_count\
    \ - 1\n      else\n        unclosed_count = unclosed_count + 1\n      end\n  \
    \    if unclosed_count < 0 then\n        return 'No'\n      end\n    end\n   \
    \ return 'Yes'\n  end\n  if #s2 == 0 then\n    local unclosed_count = 0\n    for\
    \ i = 1, #s1 do\n      if s1:sub(i, i) == ')' then\n        unclosed_count = unclosed_count\
    \ - 1\n      else\n        unclosed_count = unclosed_count + 1\n      end\n  \
    \    if unclosed_count < 0 then\n        return 'No'\n      end\n    end\n   \
    \ return 'Yes'\n  end\n  local s_concat = s1 .. s2\n  local unclosed_count = 0\n\
    \  for i = 1, #s_concat do\n    if s_concat:sub(i, i) == ')' then\n      unclosed_count\
    \ = unclosed_count - 1\n    else\n      unclosed_count = unclosed_count + 1\n\
    \    end\n    if unclosed_count < 0 then\n      return 'No'\n    end\n  end\n\
    \  return 'Yes'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyvqezr_c.lua:66:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpyvqezr_c.lua:66:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \tlocal open, close = 0, 0\n\tfor _, s in ipairs(lst) do\n\t\tlocal inc = 0\n\t\
    \tfor i = 1, #s do\n\t\t\tif s:sub(i, i) == '(' then\n\t\t\t\tinc = inc + 1\n\t\
    \t\telse\n\t\t\t\tinc = inc - 1\n\t\t\tend\n\t\tend\n\t\tif inc > 0 then\n\t\t\
    \topen = open + inc\n\t\telse\n\t\t\tclose = close - inc\n\t\tend\n\tend\n\treturn\
    \ open >= close and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7ucomgsm.lua:42:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp7ucomgsm.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    if #lst ~= 2 then\n        return nil\n    end\n    local brackets = {'(',\
    \ ')'}\n    local balance = 0\n    for _, item in ipairs(lst) do\n        for\
    \ _, bracket in ipairs(brackets) do\n            if bracket == '(' then\n    \
    \            balance = balance + 1\n            else\n                balance\
    \ = balance - 1\n            end\n            if balance < 0 then\n          \
    \      return 'No'\n            end\n        end\n    end\n    if balance == 0\
    \ then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7zz9pgnq.lua:41:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp7zz9pgnq.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local left, right = 0, 0\n  for i = 1, #lst[1] do\n    if lst[1]:sub(i, i)\
    \ == '(' then\n      left = left + 1\n    else\n      right = right + 1\n    end\n\
    \  end\n  for i = 1, #lst[2] do\n    if lst[2]:sub(i, i) == '(' then\n      left\
    \ = left + 1\n    else\n      right = right + 1\n    end\n  end\n  if left ==\
    \ right then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpygs1_tig.lua:47:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpygs1_tig.lua:47:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local S = lst[1] .. lst[2]\n  local cnt = 0\n  for i = 1, #S do\n    if S:sub(i,\
    \ i) == '(' then\n      cnt = cnt + 1\n    else\n      cnt = cnt - 1\n    end\n\
    \    if cnt < 0 then\n      return 'No'\n    end\n  end\n  return cnt == 0 and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1795n9wq.lua:34:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp1795n9wq.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local open, close = lst[1], lst[2]\n    local balance = #open - #close\n\
    \    if balance < 0 then\n        return 'No'\n    end\n    if balance == 0 then\n\
    \        return 'Yes'\n    end\n    if open[1] == '(' then\n        return match_parens({open:sub(2),\
    \ close})\n    end\n    if close[#close] == ')' then\n        return match_parens({open,\
    \ close:sub(1, #close - 1)})\n    end\n    return 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2fzzub3p.lua:33:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp2fzzub3p.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function aux(l, r)\n        if l == 0 and r == 0 then\n           \
    \ return true\n        elseif l == 0 and r > 0 then\n            return false\n\
    \        elseif l > 0 and r == 0 then\n            return aux(l - 1, r + 1)\n\
    \        else\n            return aux(l - 1, r + 1) or aux(l, r - 1)\n       \
    \ end\n    end\n    local l, r = 0, 0\n    for i = 1, #lst[1] do\n        if lst[1]:sub(i,\
    \ i) == '(' then\n            l = l + 1\n        else\n            r = r + 1\n\
    \        end\n    end\n    for i = 1, #lst[2] do\n        if lst[2]:sub(i, i)\
    \ == '(' then\n            l = l + 1\n        else\n            r = r + 1\n  \
    \      end\n    end\n    return aux(l, r) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnukpftnr.lua:45:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpnukpftnr.lua:45:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local l, r = lst[1], lst[2]\n    local x = 0\n    for i = 1, #l do\n    \
    \    if l:sub(i, i) == '(' then\n            x = x + 1\n        else\n       \
    \     x = x - 1\n        end\n    end\n    for i = 1, #r do\n        if r:sub(i,\
    \ i) == '(' then\n            x = x + 1\n        else\n            x = x - 1\n\
    \        end\n    end\n    return x == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8nqg7bwq.lua:44:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp8nqg7bwq.lua:44:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \tlocal closing = 0\n\tlocal opening = 0\n\tfor i, x in ipairs(lst) do\n\t\tfor\
    \ _, c in utf8.codes(x) do\n\t\t\tif c == 40 then\n\t\t\t\topening = opening +\
    \ 1\n\t\t\telseif c == 41 then\n\t\t\t\tclosing = closing + 1\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn opening == closing and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp770vbieb.lua:39:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp770vbieb.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function count_open(s)\n        return s:gsub('%(', ''):len()\n   \
    \ end\n    local function count_close(s)\n        return s:gsub('%)', ''):len()\n\
    \    end\n    if lst[1] == '' and lst[2] == '' then\n        return 'Yes'\n  \
    \  elseif count_open(lst[1]) > count_close(lst[2]) then\n        return 'No'\n\
    \    elseif count_open(lst[2]) > count_close(lst[1]) then\n        return 'No'\n\
    \    else\n        return 'Yes'\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoxqnkanc.lua:33:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpoxqnkanc.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local topen, tclose = 0, 0\n    for _, s in ipairs(lst) do\n        topen,\
    \ tclose = topen + s:gsub('%(', ''), tclose + s:gsub('%)', '')\n    end\n    return\
    \ topen == tclose and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmppprz50rq.lua:15:\
    \ attempt to perform arithmetic on a string value\nstack traceback:\n\t/tmp/tmppprz50rq.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmppprz50rq.lua:23: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            local ch = s:sub(i, i)\n            if ch == '(' then\n         \
    \       cnt = cnt + 1\n            else\n                cnt = cnt - 1\n     \
    \           if cnt < 0 then\n                    return false\n              \
    \  end\n            end\n        end\n        return cnt == 0\n    end\n    local\
    \ s1, s2 = table.unpack(lst)\n    return (is_good(s1 .. s2) or is_good(s2 .. s1))\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    -- your code goes here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy9p1gmiv.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmpy9p1gmiv.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local open, close = 0, 0\n    for _, s in ipairs(lst) do\n        for c in\
    \ s:gmatch('%(') do open = open + 1 end\n        for c in s:gmatch('%)') do close\
    \ = close + 1 end\n    end\n    return open == close and 'Yes' or 'No'\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9_ne18mu.lua:33:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp9_ne18mu.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local left_parens = 0\n  local right_parens = 0\n  for i = 1, #lst do\n   \
    \ for j = 1, #lst[i] do\n      if lst[i]:sub(j, j) == '(' then\n        left_parens\
    \ = left_parens + 1\n      else\n        right_parens = right_parens + 1\n   \
    \   end\n    end\n  end\n  return left_parens == right_parens and 'Yes' or 'No'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsmkjyb9s.lua:39:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpsmkjyb9s.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s = table.concat(lst)\n  local function check_balance(s)\n    local bal\
    \ = 0\n    for i = 1, #s do\n      if s:sub(i, i) == '(' then\n        bal = bal\
    \ + 1\n      else\n        bal = bal - 1\n      end\n      if bal < 0 then\n \
    \       return false\n      end\n    end\n    return bal == 0\n  end\n  return\
    \ (check_balance(s) and 'Yes') or 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp63_5_dy0.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp63_5_dy0.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local str1, str2 = lst[1], lst[2]\n  local func = function(str)\n    local\
    \ bal = 0\n    for i = 1, #str do\n      local ch = str:sub(i, i)\n      if ch\
    \ == '(' then\n        bal = bal + 1\n      else\n        bal = bal - 1\n    \
    \  end\n      if bal < 0 then\n        return false\n      end\n    end\n    return\
    \ bal == 0\n  end\n  return func(str1) and func(str2) and 'Yes' or 'No'\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4x4qdhsg.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp4x4qdhsg.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    for i, _ in ipairs(lst) do\n        if string.match(lst[i], '%(%(%))') then\n\
    \            return 'Yes'\n        end\n    end\n    return 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgqwmr08a.lua:24:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpgqwmr08a.lua:24:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local count = 0\n  for _, v in ipairs(lst) do\n    for ch in v:gmatch('%(')\
    \ do\n      count = count + 1\n    end\n    for ch in v:gmatch('%)') do\n    \
    \  count = count - 1\n    end\n    if count < 0 then\n      return 'No'\n    end\n\
    \  end\n  return count == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpstlil7rj.lua:34:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpstlil7rj.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function count_open(s)\n    return #s:gsub('%(', '')\n  end\n  local\
    \ function count_close(s)\n    return #s:gsub('%)', '')\n  end\n  local function\
    \ is_good(s)\n    local c = count_open(s) - count_close(s)\n    if c < 0 then\
    \ return false end\n    if c == 0 then return true end\n    return is_good(s:sub(c\
    \ + 1))\n  end\n  return (count_open(lst[1]) - count_close(lst[1]) ==\n    count_open(lst[2])\
    \ - count_close(lst[2])) and\n    is_good(lst[1] .. lst[2]) and 'Yes' or 'No'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4k0ppp4p.lua:33:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp4k0ppp4p.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local seq = ''\n  local dict = {\n    ['('] = ')',\n    [')'] = '('\n  }\n\
    \  for i = 1, #lst do\n    seq = seq .. lst[i]\n  end\n  while #seq > 0 do\n \
    \   local seq0 = seq\n    seq = seq:gsub('%(%)', '')\n    if seq == seq0 then\n\
    \      return 'No'\n    end\n  end\n  return 'Yes'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8l3x5vd9.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp8l3x5vd9.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local left = 0\n    local right = 0\n    for i = 1, #lst[1] do\n        if\
    \ lst[1]:sub(i, i) == '(' then\n            left = left + 1\n        else\n  \
    \          right = right + 1\n        end\n    end\n    for i = 1, #lst[2] do\n\
    \        if lst[2]:sub(i, i) == '(' then\n            left = left + 1\n      \
    \  else\n            right = right + 1\n        end\n    end\n    if left == right\
    \ then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpi4feflh7.lua:48:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpi4feflh7.lua:48:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local parens = {}\n    for _, str in ipairs(lst) do\n        for c in str:gmatch('%(')\
    \ do\n            table.insert(parens, c)\n        end\n        for c in str:gmatch('%)')\
    \ do\n            if table.remove(parens) ~= '(' then\n                return\
    \ 'No'\n            end\n        end\n    end\n    return 'Yes'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6_pu4uph.lua:33:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp6_pu4uph.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local unmatched = 0\n  for i = 1, #lst do\n    for j = 1, #lst[i] do\n    \
    \  local c = lst[i]:sub(j, j)\n      if c == '(' then\n        unmatched = unmatched\
    \ + 1\n      else\n        unmatched = unmatched - 1\n      end\n      if unmatched\
    \ < 0 then\n        return 'No'\n      end\n    end\n  end\n  return unmatched\
    \ == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpef86_qte.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpef86_qte.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    if #lst ~= 2 then\n        return 'Yes'\n    end\n    local str1, str2 =\
    \ lst[1], lst[2]\n    local balance1, balance2 = 0, 0\n    for i = 1, #str1 do\n\
    \        if str1:sub(i, i) == '(' then\n            balance1 = balance1 + 1\n\
    \        else\n            balance1 = balance1 - 1\n        end\n    end\n   \
    \ for i = 1, #str2 do\n        if str2:sub(i, i) == '(' then\n            balance2\
    \ = balance2 + 1\n        else\n            balance2 = balance2 - 1\n        end\n\
    \    end\n    return (balance1 + balance2 == 0) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpad5rhh9h.lua:47:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpad5rhh9h.lua:47:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \   -- Your code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpo2t0hhls.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmpo2t0hhls.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  -- Construct a regular expression that matches strings with balanced parentheses.\n\
    \  local left, right = string.match(table.concat(lst), \"^(.*%))(.*)$\")\n  return\
    \ (left or right) and\n    (left and left:match\"^()$\" or right and right:match\"\
    ^()$\") and\n    \"Yes\" or \"No\"\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvj9qqe_y.lua:24:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpvj9qqe_y.lua:24:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  -- your code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbakvj23i.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmpbakvj23i.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    -- TODO: implement\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0okw2zaj.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmp0okw2zaj.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local f = {}\n  for _, p in ipairs(lst) do\n    for c in p:gmatch('.') do\n\
    \      f[c] = (f[c] or 0) + (c == '(' and 1 or -1)\n    end\n  end\n  return (f['(']\
    \ or 0) == (f[')'] or 0) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjkk68t78.lua:25:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpjkk68t78.lua:25:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local opp = lst[1]\n  local clp = lst[2]\n  local open, closed = 0, 0\n  for\
    \ i = 1, #opp do\n    if opp:sub(i, i) == '(' then\n      open = open + 1\n  \
    \  else\n      closed = closed + 1\n    end\n  end\n  for i = 1, #clp do\n   \
    \ if clp:sub(i, i) == '(' then\n      open = open + 1\n    else\n      closed\
    \ = closed + 1\n    end\n  end\n  if open == closed then\n    return 'Yes'\n \
    \ else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcxt9arvm.lua:49:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpcxt9arvm.lua:49:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    -- get the directions\n    local lhs = {}\n    local rhs = {}\n    for i,\
    \ v in ipairs(lst) do\n        if i == 1 then\n            for _, vv in ipairs(v)\
    \ do\n                if vv == '(' then\n                    table.insert(lhs,\
    \ 'L')\n                else\n                    table.insert(lhs, 'R')\n   \
    \             end\n            end\n        else\n            for _, vv in ipairs(v)\
    \ do\n                if vv == '(' then\n                    table.insert(rhs,\
    \ 'L')\n                else\n                    table.insert(rhs, 'R')\n   \
    \             end\n            end\n        end\n    end\n    -- print(unpack(lhs))\n\
    \    -- print(unpack(rhs))\n    -- build a graph, a parenthesis is a node with\
    \ two edges,\n    -- one for every direction\n    local graph = {}\n    for i,v\
    \ in ipairs(lhs) do\n        graph[i] = {}\n        if v == 'L' then\n       \
    \     graph[i]['L'] = i + 1\n        else\n            graph[i]['R'] = i - 1\n\
    \        end\n    end\n    local start = #lhs + 1\n    for i,v in ipairs(rhs)\
    \ do\n        graph[start + i] = {}\n        if v == 'L' then\n            graph[start\
    \ + i]['L'] = start + i + 1\n        else\n            graph[start + i]['R'] =\
    \ start + i - 1\n        end\n    end\n    -- print_graph(graph)\n    -- merge\
    \ the graphs\n    for i = #lhs, 1, -1 do\n        if lhs[i] == 'R' then\n    \
    \        graph[i]['R'] = start\n            graph[start]['L'] = i\n          \
    \  break\n        end\n    end\n    for i = 1, #rhs do\n        if rhs[i] == 'L'\
    \ then\n            graph[start + i]['L'] = 1\n            graph[1]['R'] = start\
    \ + i\n            break\n        end\n    end\n    -- print_graph(graph)\n  \
    \  -- the trick\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpj2c6do_7.lua:93: 'end' expected (to close 'function' at line\
    \ 12) near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function count_parens(s)\n        local cnt = 0\n        for c in s:gmatch('.')\
    \ do\n            if c == '(' then\n                cnt = cnt + 1\n          \
    \  else\n                cnt = cnt - 1\n            end\n        end\n       \
    \ return cnt\n    end\n    local cnt0 = count_parens(lst[1])\n    local cnt1 =\
    \ count_parens(lst[2])\n    return cnt0 == cnt1 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsdaer_ij.lua:32:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpsdaer_ij.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s = table.concat(lst)\n  local a, b = 0, 0\n  for i = 1, #s do\n    local\
    \ c = s:sub(i, i)\n    if c == '(' then\n      a = a + 1\n    else\n      b =\
    \ b + 1\n    end\n    if b > a then\n      return 'No'\n    end\n  end\n  return\
    \ a == b and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwzrga9yr.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpwzrga9yr.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local a, b = lst[1], lst[2]\n    -- check for empty string\n    if a == ''\
    \ and b == '' then\n        return 'Yes'\n    end\n    -- check for only one non-empty\
    \ string\n    if a == '' or b == '' then\n        if a == '' then\n          \
    \  return check_parens(b)\n        else\n            return check_parens(a)\n\
    \        end\n    end\n    -- more than one character\n    -- generate all possible\
    \ concatenations\n    local lst = gen_combinations(a, b)\n    -- check them all\n\
    \    for _, s in ipairs(lst) do\n        if check_parens(s) then\n           \
    \ return 'Yes'\n        end\n    end\n    return 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpa4v4w1eg.lua:28:\
    \ attempt to call a nil value (global 'gen_combinations')\nstack traceback:\n\t\
    /tmp/tmpa4v4w1eg.lua:28: in local 'candidate'\n\t/tmp/tmpa4v4w1eg.lua:41: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local open, close = 0, 0\n  for _, s in ipairs(lst) do\n    for _, c in ipairs(s:split(\"\
    \")) do\n      if c == \"(\" then\n        open = open + 1\n      else\n     \
    \   close = close + 1\n      end\n    end\n  end\n  return close <= open and \"\
    Yes\" or \"No\"\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpzvx680eu.lua:15:\
    \ attempt to call a nil value (method 'split')\nstack traceback:\n\t/tmp/tmpzvx680eu.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpzvx680eu.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local count = 0\n    for _, str in ipairs(lst) do\n        for _, c in utf8.codes(str)\
    \ do\n            if c == 40 then\n                count = count + 1\n       \
    \     else\n                count = count - 1\n            end\n            if\
    \ count < 0 then\n                return 'No'\n            end\n        end\n\
    \    end\n    return count == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2x8xbiud.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp2x8xbiud.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local match = {\n        ['('] = ')',\n        [')'] = '('\n    }\n    local\
    \ check = {}\n    for _, s in ipairs(lst) do\n        for c in s:gmatch '.' do\n\
    \            if #check == 0 then\n                table.insert(check, c)\n   \
    \         elseif match[check[#check]] == c then\n                table.remove(check)\n\
    \            else\n                table.insert(check, c)\n            end\n \
    \       end\n    end\n    return #check == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcsk8agb_.lua:44:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpcsk8agb_.lua:44:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \   local lst1, lst2 = lst[1], lst[2]\n   for i = 1, #lst1 do\n      for j = 1,\
    \ #lst2 do\n         if lst1:sub(i, i) == '(' and lst2:sub(j, j) == ')' then\n\
    \            return 'Yes'\n         end\n      end\n   end\n   return 'No'\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgi_9kb0d.lua:29:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpgi_9kb0d.lua:29:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local str1, str2 = table.unpack(lst)\n    if str1:match('%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpvnp43604.lua:14: unfinished string near ''%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%'\n"
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local left_num = 0\n  local right_num = 0\n  for k, v in ipairs(lst) do\n \
    \   for i=1, #v do\n      if v:sub(i, i) == '(' then\n        left_num = left_num\
    \ + 1\n      else\n        right_num = right_num + 1\n      end\n    end\n  end\n\
    \  if left_num == right_num then\n    return 'Yes'\n  else\n    return 'No'\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjjlvicug.lua:43:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpjjlvicug.lua:43:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    -- YOUR CODE HERE\n    if lst[1] == \")\" or lst[2] == \"(\" then\n     \
    \   return \"No\"\n    end\n    local a = lst[1] .. lst[2]\n    local b = lst[2]\
    \ .. lst[1]\n    -- print(a)\n    -- print(b)\n    if (isGood(a) or isGood(b))\
    \ then\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpr8fbue3k.lua:21:\
    \ attempt to call a nil value (global 'isGood')\nstack traceback:\n\t/tmp/tmpr8fbue3k.lua:21:\
    \ in local 'candidate'\n\t/tmp/tmpr8fbue3k.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \   -- your code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptlfvvree.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmptlfvvree.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  for i = 1, #lst do\n    lst[i] = lst[i]:gsub('[^%(%)]', '')\n  end\n  local\
    \ function is_good(s)\n    local cnt = 0\n    for c in s:gmatch('[%(%)]') do\n\
    \      if c == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local function join(lst)\n    return table.concat(lst)\n\
    \  end\n  return is_good(join(lst)) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprwabbprn.lua:42:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmprwabbprn.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  -- your code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbdqd35a_.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmpbdqd35a_.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function index(p)\n        for i, x in ipairs(lst) do\n           \
    \ if x == p then\n                return i\n            end\n        end\n   \
    \     return nil\n    end\n    local function sublists(lst)\n        local function\
    \ sublist(i, j)\n            local res = {}\n            for k = i, j do\n   \
    \             res[#res + 1] = lst[k]\n            end\n            return res\n\
    \        end\n        local res = {}\n        for i = 1, #lst do\n           \
    \ for j = i, #lst do\n                res[#res + 1] = sublist(i, j)\n        \
    \    end\n        end\n        return res\n    end\n    local function good(lst)\n\
    \        local n = 0\n        for _, x in ipairs(lst) do\n            if x ==\
    \ '(' then\n                n = n + 1\n            else\n                n = n\
    \ - 1\n            end\n            if n < 0 then\n                return false\n\
    \            end\n        end\n        return n == 0\n    end\n    local i = index(')')\n\
    \    if i == nil then\n        return good(lst) and 'Yes' or 'No'\n    end\n \
    \   local res = 'No'\n    for _, sub in ipairs(sublists(lst)) do\n        if good(sub)\
    \ then\n            res = 'Yes'\n            break\n        end\n    end\n   \
    \ return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6348qr1f.lua:68:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp6348qr1f.lua:68:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  -- your code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpro0ttb80.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmpro0ttb80.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local left, right = 0, 0\n  for _, s in ipairs(lst) do\n    for i = 1, #s do\n\
    \      if s:sub(i, i) == '(' then\n        left = left + 1\n      else\n     \
    \   right = right + 1\n      end\n    end\n  end\n  return (left == right) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvbl3qr6f.lua:38:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpvbl3qr6f.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function count_parens(s)\n    local open, close = 0, 0\n    for _, c\
    \ in ipairs(s) do\n      if c == '(' then\n        open = open + 1\n      else\n\
    \        close = close + 1\n      end\n    end\n    return open, close\n  end\n\
    \  local open_1, close_1 = count_parens(lst[1])\n  local open_2, close_2 = count_parens(lst[2])\n\
    \  if open_1 == close_1 and open_2 == close_2 then\n    return 'Yes'\n  elseif\
    \ open_1 > close_1 and open_2 == close_2 then\n    return 'Yes'\n  elseif open_1\
    \ == close_1 and open_2 < close_2 then\n    return 'Yes'\n  else\n    return 'No'\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc01cl2qf.lua:41:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpc01cl2qf.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s = table.concat(lst)\n    local score = 0\n    for i = 1, #s do\n\
    \        if s:sub(i, i) == '(' then\n            score = score + 1\n        else\n\
    \            score = score - 1\n        end\n        if score < 0 then\n     \
    \       return 'No'\n        end\n    end\n    return score == 0 and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpazjla7g9.lua:34:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpazjla7g9.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \   local n = 0\n   for _, s in ipairs(lst) do\n      for i = 1, #s do\n     \
    \    if s:sub(i, i) == '(' then\n            n = n + 1\n         else\n      \
    \      n = n - 1\n         end\n         if n < 0 then\n            return 'No'\n\
    \         end\n      end\n   end\n   return n == 0 and 'Yes' or 'No'\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp83uox1n9.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp83uox1n9.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local balance = 0\n  for _, s in ipairs(lst) do\n    for c in s:gmatch('%(')\
    \ do balance = balance + 1 end\n    for c in s:gmatch('%)') do balance = balance\
    \ - 1 end\n    if balance < 0 then return 'No' end\n  end\n  return balance ==\
    \ 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1o2b15jy.lua:28:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp1o2b15jy.lua:28:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s = lst[1] .. lst[2]\n    local c = 0\n    for i = 1, #s do\n     \
    \   local ch = s:sub(i, i)\n        if ch == '(' then\n            c = c + 1\n\
    \        else\n            c = c - 1\n        end\n        if c < 0 then\n   \
    \         return 'No'\n        end\n    end\n    return c == 0 and 'Yes' or 'No'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb3kautv4.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpb3kautv4.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local m = {\n        ['('] = ')',\n        [')'] = '('\n    }\n    local\
    \ result = 0\n    for _, v in ipairs(lst) do\n        for _, c in ipairs(v) do\n\
    \            if result < 0 then return 'No' end\n            result = result +\
    \ (m[c] == '(' and 1 or -1)\n        end\n    end\n    return result == 0 and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8bqq2c22.lua:31:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp8bqq2c22.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s = table.concat(lst)\n  local bal = 0\n  for i = 1, #s do\n    if s:sub(i,\
    \ i) == '(' then\n      bal = bal + 1\n    else\n      bal = bal - 1\n    end\n\
    \    if bal < 0 then\n      return 'No'\n    end\n  end\n  return bal == 0 and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw41v3705.lua:34:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpw41v3705.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local result = {}\n  for _, string in ipairs(lst) do\n    for i = 1, #string\
    \ do\n      local c = string:sub(i, i)\n      if c == '(' then\n        table.insert(result,\
    \ '(')\n      else\n        if #result == 0 then\n          return 'No'\n    \
    \    end\n        table.remove(result)\n      end\n    end\n  end\n  return #result\
    \ == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpx4qdlzqi.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpx4qdlzqi.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s = table.concat(lst)\n    local counter = 0\n    for i = 1, #s do\n\
    \        local c = s:sub(i, i)\n        if c == '(' then\n            counter\
    \ = counter + 1\n        else\n            counter = counter - 1\n        end\n\
    \        if counter < 0 then\n            return 'No'\n        end\n    end\n\
    \    return counter == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy209rhnc.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpy209rhnc.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local f, s = lst[1], lst[2]\n    local t = f:gsub('%(', '')\n    if t ==\
    \ '' then\n        if #f < #s then\n            return 'Yes'\n        else\n \
    \           return 'No'\n        end\n    end\n    t = s:gsub('%)', '')\n    if\
    \ t == '' then\n        if #s < #f then\n            return 'Yes'\n        else\n\
    \            return 'No'\n        end\n    end\n    if #s < #f then\n        f,\
    \ s = s, f\n    end\n    local start = f:sub(1, 1)\n    local last = s:sub(-1)\n\
    \    if start == '(' and last == ')' then\n        return 'Yes'\n    end\n   \
    \ return 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_9_7eejt.lua:46:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp_9_7eejt.lua:46:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function aux(l, r)\n        if l > r then\n            return true\n\
    \        elseif l < 0 or r < 0 then\n            return false\n        else\n\
    \            return aux(l - 1, r) or aux(l, r - 1)\n        end\n    end\n   \
    \ local open, close = 0, 0\n    for i = 1, #lst[1] do\n        if lst[1]:sub(i,\
    \ i) == '(' then\n            open = open + 1\n        else\n            close\
    \ = close + 1\n        end\n    end\n    for i = 1, #lst[2] do\n        if lst[2]:sub(i,\
    \ i) == '(' then\n            open = open + 1\n        else\n            close\
    \ = close + 1\n        end\n    end\n    return aux(open, close) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf5e3zf74.lua:44:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpf5e3zf74.lua:44:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local count = 0\n  for _, str in ipairs(lst) do\n    for p in str:gmatch('%(')\
    \ do count = count + 1 end\n    for p in str:gmatch('%)') do count = count - 1\
    \ end\n    if count < 0 then return 'No' end\n  end\n  return count == 0 and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp62b893p8.lua:28:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp62b893p8.lua:28:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  return 'Yes'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9w4999vk.lua:20:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp9w4999vk.lua:20:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local open_stack = 0\n  local closed_stack = 0\n  for _, v in ipairs(lst) do\n\
    \    for _, c in ipairs(v:split('')) do\n      if c == '(' then\n        open_stack\
    \ = open_stack + 1\n      else\n        if open_stack == 0 then\n          closed_stack\
    \ = closed_stack + 1\n        else\n          open_stack = open_stack - 1\n  \
    \      end\n      end\n    end\n  end\n  if open_stack == 0 and closed_stack ==\
    \ 0 then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpali1w6hj.lua:16:\
    \ attempt to call a nil value (method 'split')\nstack traceback:\n\t/tmp/tmpali1w6hj.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpali1w6hj.lua:38: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \tlocal s = lst[1] .. lst[2]\n\tlocal stack = {}\n\tfor i = 1, #s do\n\t\tlocal\
    \ c = s:sub(i, i)\n\t\tif c == '(' then\n\t\t\ttable.insert(stack, c)\n\t\telse\n\
    \t\t\tif #stack == 0 then\n\t\t\t\treturn 'No'\n\t\t\tend\n\t\t\ttable.remove(stack)\n\
    \t\tend\n\tend\n\treturn #stack == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsfxge7es.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpsfxge7es.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_balanced(s)\n        local function count(s, c)\n     \
    \       local i = 0\n            for ch in s:gmatch(c) do\n                i =\
    \ i + 1\n            end\n            return i\n        end\n        local cnt_open\
    \ = count(s, '%(')\n        local cnt_close = count(s, '%)')\n        return cnt_open\
    \ == cnt_close\n    end\n    return is_balanced(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb3d8ns9u.lua:40:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpb3d8ns9u.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local x, y = lst[1], lst[2]\n  local good = function(p)\n    local count =\
    \ 0\n    for i = 1, #p do\n      if p:sub(i, i) == '(' then\n        count = count\
    \ + 1\n      else\n        count = count - 1\n      end\n      if count < 0 then\n\
    \        return false\n      end\n    end\n    return count == 0\n  end\n  return\
    \ good(x .. y) or good(y .. x) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbfrx5t4m.lua:34:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmpbfrx5t4m.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function check(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    if check(lst[1]) then\n        return 'Yes'\n\
    \    end\n    local res = { 'Yes', 'No' }\n    for i = 1, #lst[1] do\n       \
    \ for j = 1, #lst[2] do\n            if check(lst[1]:sub(1, i) .. lst[2]:sub(1,\
    \ j)) or\n               check(lst[2]:sub(1, j) .. lst[1]:sub(1, i)) then\n  \
    \              return res[1]\n            end\n        end\n    end\n    return\
    \ res[2]\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgw8atqtl.lua:47:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpgw8atqtl.lua:47:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local c = 0\n  for _, s in ipairs(lst) do\n    for _, b in ipairs(s:gmatch('.'))\
    \ do\n      if b == '(' then\n        c = c + 1\n      else\n        c = c - 1\n\
    \      end\n      if c < 0 then\n        return 'No'\n      end\n    end\n  end\n\
    \  return c == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\nattempt to\
    \ index a function value\nstack traceback:\n\nRan 1 tests in 0.000 seconds, 0\
    \ successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function to_set(s)\n    local set = {}\n    for i = 1, #s do\n      set[s:sub(i,\
    \ i)] = true\n    end\n    return set\n  end\n  local function is_good(s)\n  \
    \  local open = 0\n    for i = 1, #s do\n      if s:sub(i, i) == '(' then\n  \
    \      open = open + 1\n      else\n        open = open - 1\n      end\n     \
    \ if open < 0 then\n        return false\n      end\n    end\n    return open\
    \ == 0\n  end\n  local set1, set2 = to_set(lst[1]), to_set(lst[2])\n  for _, s\
    \ in ipairs{lst[1] .. lst[2], lst[2] .. lst[1]} do\n    if is_good(s) then\n \
    \     return 'Yes'\n    end\n  end\n  if set1['('] and set2[')'] or set1[')']\
    \ and set2['('] then\n    return 'Yes'\n  end\n  return 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9azzu5qn.lua:51:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp9azzu5qn.lua:51:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \tlocal def = 1\n\tfor _,v in ipairs(lst) do\n\t\tdef = def + (v == '(' and 1\
    \ or -1)\n\t\tif def < 0 then return 'No' end\n\tend\n\treturn def == 0 and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyrmm7hjp.lua:24:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpyrmm7hjp.lua:24:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local cnt1, cnt2 = 0, 0\n    for i = 1,\
    \ #s1 do\n        cnt1 = cnt1 + (s1:sub(i, i) == '(' and 1 or -1)\n    end\n \
    \   for i = 1, #s2 do\n        cnt2 = cnt2 + (s2:sub(i, i) == '(' and 1 or -1)\n\
    \    end\n    return cnt1 + cnt2 == 0 and 'Yes' or 'No'\nend\nassert(match_parens({'()(',\
    \ ')'}) == 'Yes')\nassert(match_parens({')', ')'}) == 'No')\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp54rav1tu.lua:38:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp54rav1tu.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \   local src = table.concat(lst)\n   for i = 1, #src - 1 do\n      for j = i\
    \ + 1, #src do\n         local s = src:sub(1, i - 1) .. src:sub(j, j) .. src:sub(i,\
    \ i) .. src:sub(j + 1)\n         if parens_balanced(s) then\n            return\
    \ 'Yes'\n         end\n      end\n   end\n   return 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpmds741wb.lua:17:\
    \ attempt to call a nil value (global 'parens_balanced')\nstack traceback:\n\t\
    /tmp/tmpmds741wb.lua:17: in local 'candidate'\n\t/tmp/tmpmds741wb.lua:28: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s = lst[1] .. lst[2]\n    local cnt = 0\n    for c in s:gmatch\".\"\
    \ do\n        if c == '(' then\n            cnt = cnt + 1\n        else\n    \
    \        cnt = cnt - 1\n            if cnt < 0 then\n                return 'No'\n\
    \            end\n        end\n    end\n    return cnt == 0 and 'Yes' or 'No'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpub4ji899.lua:34:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpub4ji899.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local open_cnt = 0\n    local close_cnt = 0\n    for _, str in ipairs(lst)\
    \ do\n        for ch in str:gmatch('%(') do\n            open_cnt = open_cnt +\
    \ 1\n        end\n        for ch in str:gmatch('%)') do\n            close_cnt\
    \ = close_cnt + 1\n        end\n    end\n    if open_cnt == close_cnt then\n \
    \       return 'Yes'\n    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_4g5j3pw.lua:42:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp_4g5j3pw.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s = table.concat(lst)\n    local a, b = '', ''\n    local function\
    \ is_paren(c)\n        return c == '(' or c == ')'\n    end\n    for i = 1, #s\
    \ do\n        local c = s:sub(i, i)\n        if is_paren(c) then\n           \
    \ if c == '(' then\n                a = a .. c\n            else\n           \
    \     if a:sub(-1) == '(' then\n                    a = a:sub(1, -2)\n       \
    \         else\n                    b = b .. c\n                end\n        \
    \    end\n        end\n    end\n    if #a == 0 and #b == 0 then\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbqfwahts.lua:45:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpbqfwahts.lua:45:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function count_open(s)\n    return select(2, s:gsub('%(', ''))\n  end\n\
    \  local function count_close(s)\n    return select(2, s:gsub('%)', ''))\n  end\n\
    \  local s1, s2 = lst[1], lst[2]\n  local sum_open = count_open(s1) + count_open(s2)\n\
    \  local sum_close = count_close(s1) + count_close(s2)\n  return (sum_open ==\
    \ sum_close) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcfl5g5bi.lua:37:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpcfl5g5bi.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local _match_parens = function(s1, s2)\n        if s1 == '' then\n      \
    \      if s2 == '' then\n                return true\n            else\n     \
    \           return _match_parens('', s2:sub(2))\n            end\n        elseif\
    \ s2 == '' then\n            if s1 == '' then\n                return true\n \
    \           else\n                return _match_parens(s1:sub(2), '')\n      \
    \      end\n        elseif s1:sub(1, 1) == '(' then\n            if s2:sub(1,\
    \ 1) == ')' then\n                return _match_parens(s1:sub(2), s2:sub(2))\n\
    \            else\n                return _match_parens(s1:sub(2), s2)\n     \
    \       end\n        elseif s1:sub(1, 1) == ')' then\n            if s2:sub(1,\
    \ 1) == '(' then\n                return _match_parens(s1:sub(2), s2:sub(2))\n\
    \            else\n                return _match_parens(s1:sub(2), s2)\n     \
    \       end\n        end\n    end\n    if _match_parens(lst[1], lst[2]) then\n\
    \        return 'Yes'\n    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp61_sa98l.lua:28:\
    \ attempt to call a nil value (global '_match_parens')\nstack traceback:\n\t/tmp/tmp61_sa98l.lua:28:\
    \ in local '_match_parens'\n\t/tmp/tmp61_sa98l.lua:40: in local 'candidate'\n\t\
    /tmp/tmp61_sa98l.lua:50: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return (is_good(lst[1]) and is_good(lst[2]))\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpokrgkzq6.lua:33:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpokrgkzq6.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function count_parens(s)\n    local t = 0\n    for i=1,#s do\n      if\
    \ s:sub(i,i) == '(' then\n        t = t + 1\n      else\n        t = t - 1\n \
    \     end\n      if t < 0 then\n        return nil\n      end\n    end\n    return\
    \ t\n  end\n  return (count_parens(lst[1]) == count_parens(lst[2])) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzinait1l.lua:33:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpzinait1l.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local l, r = 0, 0\n  for i = 1, #lst[1] do\n    l = l + lst[1]:sub(i, i) ==\
    \ '(' and 1 or -1\n  end\n  for i = 1, #lst[2] do\n    r = r + lst[2]:sub(i, i)\
    \ == '(' and 1 or -1\n  end\n  return (l == 0 and r == 0) or (l * r >= 0) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmps6c9mjlo.lua:15:\
    \ attempt to perform arithmetic on a string value\nstack traceback:\n\t/tmp/tmps6c9mjlo.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmps6c9mjlo.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local cnt = 0\n  for _, s in ipairs(lst) do\n    for _, c in utf8.codes(s)\
    \ do\n      if c == utf8.byte('(') then\n        cnt = cnt + 1\n      elseif c\
    \ == utf8.byte(')') then\n        cnt = cnt - 1\n      end\n      if cnt < 0 then\n\
    \        return 'No'\n      end\n    end\n  end\n  return (cnt == 0) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmps4j4bjav.lua:16:\
    \ attempt to call a nil value (field 'byte')\nstack traceback:\n\t/tmp/tmps4j4bjav.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmps4j4bjav.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for c in s:gmatch('%b()')\
    \ do\n            count = count + 1\n        end\n        return count % 2 ==\
    \ 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    if is_good(s1) and is_good(s2)\
    \ then\n        return 'Yes'\n    end\n    local index = #s1\n    for i = 1, index\
    \ - 1 do\n        local t1, t2 = s1:sub(1, i), s1:sub(i + 1)\n        if is_good(t1)\
    \ and is_good(t2) then\n            return 'Yes'\n        end\n    end\n    return\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp855enjlc.lua:38:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp855enjlc.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local left, right = unpack(lst)\n  local left_count, right_count = 0, 0\n \
    \ for _, char in ipairs(left) do\n    if char == '(' then\n      left_count =\
    \ left_count + 1\n    else\n      left_count = left_count - 1\n    end\n  end\n\
    \  for _, char in ipairs(right) do\n    if char == '(' then\n      right_count\
    \ = right_count + 1\n    else\n      right_count = right_count - 1\n    end\n\
    \  end\n  if left_count == 0 and right_count == 0 then\n    return 'Yes'\n  elseif\
    \ left_count == 0 or right_count == 0 then\n    return 'No'\n  elseif left_count\
    \ == -right_count then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpng8enaq0.lua:13:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpng8enaq0.lua:13:\
    \ in local 'candidate'\n\t/tmp/tmpng8enaq0.lua:43: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local open = 0\n  local close = 0\n  for i = 1, #lst do\n    for j = 1, #lst[i]\
    \ do\n      if lst[i]:sub(j, j) == '(' then\n        open = open + 1\n      else\n\
    \        close = close + 1\n      end\n    end\n  end\n  return (open == close)\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf7b9u80g.lua:39:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpf7b9u80g.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptez5nvz5.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmptez5nvz5.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local yes_no = {\n        [0] = 'Yes',\n        [1] = 'No',\n    }\n    local\
    \ balance = 0\n    for _, s in ipairs(lst) do\n        for _, c in ipairs{s:byte(1,\
    \ -1)} do\n            if c == 40 then\n                balance = balance + 1\n\
    \            else\n                balance = balance - 1\n            end\n  \
    \          if balance < 0 then\n                return yes_no[1]\n           \
    \ end\n        end\n    end\n    return yes_no[balance % 2]\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbyab2op5.lua:39:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpbyab2op5.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local n1, n2 = #lst[1], #lst[2]\n    local p1, p2 = 0, 0\n    for i = 1,\
    \ n1 do\n        if lst[1]:sub(i, i) == '(' then\n            p1 = p1 + 1\n  \
    \      else\n            p1 = p1 - 1\n        end\n    end\n    for i = 1, n2\
    \ do\n        if lst[2]:sub(i, i) == '(' then\n            p2 = p2 + 1\n     \
    \   else\n            p2 = p2 - 1\n        end\n    end\n    if p1 < 0 or p2 <\
    \ 0 then\n        return 'No'\n    end\n    if p1 == 0 then\n        if p2 % 2\
    \ == 0 then\n            return 'Yes'\n        else\n            return 'No'\n\
    \        end\n    end\n    if p2 == 0 then\n        if p1 % 2 == 0 then\n    \
    \        return 'Yes'\n        else\n            return 'No'\n        end\n  \
    \  end\n    return 'Yes'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0z9xzy23.lua:52:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp0z9xzy23.lua:52:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local count = 0\n    for _, v in ipairs(lst) do\n        for c in v:gmatch('%(')\
    \ do\n            count = count + 1\n        end\n        for c in v:gmatch('%)')\
    \ do\n            count = count - 1\n        end\n        if count < 0 then\n\
    \            return 'No'\n        end\n    end\n    return 'Yes'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8cu5wcfx.lua:34:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp8cu5wcfx.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local left = 0\n    local right = 0\n    for _, s in ipairs(lst) do\n   \
    \     for c in s:gmatch('.') do\n            if c == '(' then\n              \
    \  left = left + 1\n            else\n                right = right + 1\n    \
    \        end\n        end\n    end\n    if left == right then\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr658wxf9.lua:43:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpr658wxf9.lua:43:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s = lst[1] .. lst[2]\n  local c = 0\n  for i = 1, #s do\n    if s:sub(i,\
    \ i) == '(' then\n      c = c + 1\n    else\n      c = c - 1\n    end\n    if\
    \ c < 0 then\n      return 'No'\n    end\n  end\n  return 'Yes'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5h_s7q0d.lua:34:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp5h_s7q0d.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local bal = 0\n    for i = 1, #lst do\n        local a = lst[i]\n       \
    \ for j = 1, #a do\n            local b = a:sub(j, j)\n            if b == '('\
    \ then\n                bal = bal + 1\n            else\n                bal =\
    \ bal - 1\n            end\n            if bal < 0 then\n                return\
    \ 'No'\n            end\n        end\n    end\n    return bal == 0 and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdu8s8jm1.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpdu8s8jm1.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local upar = 0\n    local dpar = 0\n    for i = 1, #lst[1] do\n        if\
    \ lst[1]:sub(i, i) == '(' then\n            upar = upar + 1\n        else\n  \
    \          dpar = dpar + 1\n        end\n    end\n    for i = 1, #lst[2] do\n\
    \        if lst[2]:sub(i, i) == '(' then\n            upar = upar + 1\n      \
    \  else\n            dpar = dpar + 1\n        end\n    end\n    if upar == dpar\
    \ then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_9kaghxi.lua:48:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp_9kaghxi.lua:48:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local stack = {}\n    for _, s in ipairs(lst) do\n        for i = 1, #s do\n\
    \            local p = s:sub(i, i)\n            if p == '(' then\n           \
    \     table.insert(stack, p)\n            else\n                if #stack == 0\
    \ then\n                    return 'No'\n                end\n               \
    \ table.remove(stack)\n            end\n        end\n    end\n    return #stack\
    \ == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmsdvmy1y.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpmsdvmy1y.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \tlocal s0, s1 = lst[1], lst[2]\n\tif #s0 == 0 then\n\t\tif s1:find('%(') then\n\
    \t\t\treturn 'No'\n\t\telse\n\t\t\treturn 'Yes'\n\t\tend\n\tend\n\tlocal p = s0:find('%(')\n\
    \tif not p then\n\t\treturn 'No'\n\tend\n\ts0 = s0:sub(p)\n\ts1 = s1:sub(p)\n\t\
    local stack = {}\n\tfor i = 1, #s0 do\n\t\tlocal c = s0:sub(i, i)\n\t\tif c ==\
    \ '(' then\n\t\t\ttable.insert(stack, c)\n\t\telse\n\t\t\tif #stack == 0 then\n\
    \t\t\t\treturn 'No'\n\t\t\tend\n\t\t\ttable.remove(stack)\n\t\tend\n\tend\n\t\
    for i = 1, #s1 do\n\t\tlocal c = s1:sub(i, i)\n\t\tif c == '(' then\n\t\t\ttable.insert(stack,\
    \ c)\n\t\telse\n\t\t\tif #stack == 0 then\n\t\t\t\treturn 'No'\n\t\t\tend\n\t\t\
    \ttable.remove(stack)\n\t\tend\n\tend\n\tif #stack == 0 then\n\t\treturn 'Yes'\n\
    \telse\n\t\treturn 'No'\n\tend\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpierckuub.lua:63:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpierckuub.lua:63:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \   local bad = false\n   local stack = 0\n   for _, str in ipairs(lst) do\n \
    \     for i = 1, #str do\n         if str:sub(i, i) == '(' then\n            stack\
    \ = stack + 1\n         else\n            stack = stack - 1\n            if stack\
    \ < 0 then\n               bad = true\n               break\n            end\n\
    \         end\n      end\n   end\n   if bad or stack ~= 0 then\n      return 'No'\n\
    \   else\n      return 'Yes'\n   end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpja_d86y_.lua:41:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpja_d86y_.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    -- check the number of open and close parentheses\n    -- if it's possible\
    \ to make a good string, return 'Yes'\n    -- otherwise, return 'No'\n    local\
    \ function count_parens(parens)\n        local open, close = 0, 0\n        for\
    \ i=1,#parens do\n            if parens:sub(i,i) == '(' then\n               \
    \ open = open + 1\n            else\n                close = close + 1\n     \
    \       end\n        end\n        return open, close\n    end\n    local parens1,\
    \ parens2 = lst[1], lst[2]\n    local op1, cl1 = count_parens(parens1)\n    local\
    \ op2, cl2 = count_parens(parens2)\n    if op1 > cl1 and op2 > cl2 then\n    \
    \    return 'Yes'\n    elseif op1 > cl1 then\n        local op, cl = count_parens(parens1\
    \ .. parens2)\n        if op > cl then\n            return 'Yes'\n        end\n\
    \    elseif op2 > cl2 then\n        local op, cl = count_parens(parens2 .. parens1)\n\
    \        if op > cl then\n            return 'Yes'\n        end\n    end\n   \
    \ return 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgwt3c39p.lua:49:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpgwt3c39p.lua:49:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local lst1, lst2 = lst[1], lst[2]\n  local cnt1, cnt2 = 0, 0\n  for i = 1,\
    \ #lst1 do\n    if lst1:sub(i, i) == '(' then\n      cnt1 = cnt1 + 1\n    else\n\
    \      cnt1 = cnt1 - 1\n    end\n  end\n  for i = 1, #lst2 do\n    if lst2:sub(i,\
    \ i) == '(' then\n      cnt2 = cnt2 + 1\n    else\n      cnt2 = cnt2 - 1\n   \
    \ end\n  end\n  if cnt1 == cnt2 and cnt1 >= 0 then\n    return 'Yes'\n  else\n\
    \    return 'No'\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppei64svk.lua:39:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmppei64svk.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \   local n = (#lst[1] + #lst[2])\n   local o = 0\n   local c = 0\n   for i =\
    \ 1, n do\n      local c = lst[1]:sub(i, i) or lst[2]:sub(i, i)\n      if c ==\
    \ '(' then\n         o = o + 1\n      else\n         if o == 0 then\n        \
    \    return 'No'\n         end\n         o = o - 1\n      end\n   end\n   return\
    \ 'Yes'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpg9rqo2he.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpg9rqo2he.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s = table.concat(lst)\n  local i = 0\n  for c in s:gmatch('.') do\n \
    \   if c == '(' then\n      i = i + 1\n    else\n      i = i - 1\n    end\n  \
    \  if i < 0 then\n      return 'No'\n    end\n  end\n  return i == 0 and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt96an7yk.lua:34:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpt96an7yk.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function helper(str)\n    local open, close = 0, 0\n    for c in str:gmatch\"\
    .\" do\n      if c == '(' then\n        open = open + 1\n      else\n        if\
    \ open == 0 then\n          return false\n        end\n        open = open - 1\n\
    \      end\n    end\n    return open == 0\n  end\n  local s = table.concat(lst)\n\
    \  local a, b = helper(s), helper(s:reverse())\n  return a and b and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmzu5vl80.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpmzu5vl80.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_open(c)\n        return c == '('\n    end\n    local function\
    \ is_close(c)\n        return c == ')'\n    end\n    local left = lst[1]\n   \
    \ local right = lst[2]\n    local opens = 0\n    local closes = 0\n    for i =\
    \ 1, #left do\n        if is_open(left:sub(i, i)) then\n            opens = opens\
    \ + 1\n        else\n            closes = closes + 1\n        end\n    end\n \
    \   for i = 1, #right do\n        if is_open(right:sub(i, i)) then\n         \
    \   opens = opens + 1\n        else\n            closes = closes + 1\n       \
    \ end\n    end\n    if closes > opens then\n        return 'No'\n    end\n   \
    \ if opens % 2 == 0 and closes % 2 == 0 then\n        return 'Yes'\n    end\n\
    \    return 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqi3oetyr.lua:52:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpqi3oetyr.lua:52:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local open, close = 0, 0\n    for i, v in ipairs(lst) do\n        for _,\
    \ c in ipairs(v) do\n            if c == '(' then\n                open = open\
    \ + 1\n            else\n                close = close + 1\n            end\n\
    \        end\n    end\n    return (open > close) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1pmgi1hq.lua:29:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp1pmgi1hq.lua:29:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local balance = #s1 - #s2\n  if balance %\
    \ 2 ~= 0 then\n    return 'No'\n  end\n  local s = s1 .. s2\n  for _, s in ipairs({s1,\
    \ s2, s}) do\n    local cnt = 0\n    for i = 1, #s do\n      local c = s:sub(i,\
    \ i)\n      if c == '(' then\n        cnt = cnt + 1\n      else\n        cnt =\
    \ cnt - 1\n      end\n      if cnt < 0 then\n        return 'No'\n      end\n\
    \    end\n  end\n  return 'Yes'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp25rt8emd.lua:39:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp25rt8emd.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local left_cnt = 0\n    local right_cnt = 0\n    for i = 1, #lst[1] do\n\
    \        if lst[1]:sub(i, i) == '(' then\n            left_cnt = left_cnt + 1\n\
    \        else\n            right_cnt = right_cnt + 1\n        end\n    end\n \
    \   for i = 1, #lst[2] do\n        if lst[2]:sub(i, i) == '(' then\n         \
    \   left_cnt = left_cnt + 1\n        else\n            right_cnt = right_cnt +\
    \ 1\n        end\n    end\n    if left_cnt == right_cnt then\n        return 'Yes'\n\
    \    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcyi0vu_g.lua:48:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpcyi0vu_g.lua:48:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    if #lst ~= 2 then\n        return nil\n    end\n    local s = table.concat(lst)\n\
    \    local cnt = 0\n    for i = 1, #s do\n        if s:sub(i, i) == '(' then\n\
    \            cnt = cnt + 1\n        else\n            cnt = cnt - 1\n        end\n\
    \        if cnt < 0 then\n            return 'No'\n        end\n    end\n    return\
    \ cnt == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfaoqm7u_.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpfaoqm7u_.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  -- your code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprn4_9t4c.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmprn4_9t4c.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local t = { [0] = 0 }\n  for _, str in ipairs(lst) do\n    for c in str:gmatch\"\
    .\" do\n      t[#t] = t[#t] + (c == '(' and 1 or -1)\n      if t[#t] < 0 then\
    \ return 'No' end\n    end\n  end\n  if t[#t] == 0 then return 'Yes' end\n  return\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4cbl9t4m.lua:30:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp4cbl9t4m.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  for _, s in ipairs(lst) do\n    local cnt = 0\n    for _, c in s:gmatch'.'\
    \ do\n      if c == '(' then\n        cnt = cnt + 1\n      else\n        cnt =\
    \ cnt - 1\n      end\n      if cnt < 0 then\n        return 'No'\n      end\n\
    \    end\n  end\n  return 'Yes'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp08rzv_nu.lua:32:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp08rzv_nu.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    -- your code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp27wae2a6.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmp27wae2a6.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s = table.concat(lst)\n  local open, close = s:match'^%(+()%)+$'\n  return\
    \ open == nil and 'No' or 'Yes'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptcjtbxbc.lua:21:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmptcjtbxbc.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function go(s1, s2, n)\n        if n == 0 then\n            return\
    \ s1 .. s2\n        elseif s1:sub(1, 1) == '(' then\n            return go(s1:sub(2),\
    \ s2, n - 1)\n        elseif s2:sub(-1) == ')' then\n            return go(s1,\
    \ s2:sub(1, -2), n - 1)\n        else\n            return false\n        end\n\
    \    end\n    local s1, s2 = lst[1], lst[2]\n    local s = go(s1, s2, #s1 + #s2)\n\
    \    if s then\n        local i = 1\n        for c in s:gmatch('()') do\n    \
    \        if s:sub(c, c) == '(' then\n                i = i + 1\n            else\n\
    \                i = i - 1\n            end\n            if i < 0 then\n     \
    \           return 'No'\n            end\n        end\n        return 'Yes'\n\
    \    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbvc_0ty8.lua:47:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpbvc_0ty8.lua:47:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local sum = 0\n    for i = 1, #str do\n  \
    \    if str:sub(i, i) == '(' then\n        sum = sum + 1\n      else\n       \
    \ sum = sum - 1\n      end\n      if sum < 0 then\n        return false\n    \
    \  end\n    end\n    return sum == 0\n  end\n  return is_good(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpozn_7soz.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpozn_7soz.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local open = lst[1]:gsub('%(', 'O')\n  local close = lst[2]:gsub('%)', 'C')\n\
    \  return open:match('O+') and close:match('C+') and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9ur9uiau.lua:23:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp9ur9uiau.lua:23:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    -- \"lst\" is a list of two strings, both strings\n    -- consist of open\
    \ parentheses '(' or close parentheses ')' only.\n    local s1, s2 = lst[1], lst[2]\n\
    \    local l1, l2 = s1:len(), s2:len()\n    local s3 = s1 .. s2\n    local s4\
    \ = s2 .. s1\n    if parent_ok(s3) then\n        return 'Yes'\n    elseif parent_ok(s4)\
    \ then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpumfyxr39.lua:19:\
    \ attempt to call a nil value (global 'parent_ok')\nstack traceback:\n\t/tmp/tmpumfyxr39.lua:19:\
    \ in local 'candidate'\n\t/tmp/tmpumfyxr39.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local left_count = 0\n    local right_count = 0\n    for i, v in ipairs(lst)\
    \ do\n        for _, p in ipairs(v) do\n            if p == '(' then\n       \
    \         left_count = left_count + 1\n            else\n                right_count\
    \ = right_count + 1\n            end\n        end\n    end\n    if left_count\
    \ == right_count then\n        return 'Yes'\n    else\n        return 'No'\n \
    \   end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2xvzcnbv.lua:35:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp2xvzcnbv.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s = lst[1] .. lst[2]\n  local balance = 0\n  for i = 1, #s do\n    if\
    \ s:sub(i, i) == '(' then\n      balance = balance + 1\n    else\n      balance\
    \ = balance - 1\n    end\n    if balance < 0 then\n      return 'No'\n    end\n\
    \  end\n  return balance == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9tn_1xbp.lua:34:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp9tn_1xbp.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local bracket_stack = {}\n    for _, s in ipairs(lst) do\n        for i =\
    \ 1, #s do\n            local b = s:sub(i, i)\n            if b == '(' then\n\
    \                table.insert(bracket_stack, b)\n            else\n          \
    \      if #bracket_stack == 0 then\n                    return 'No'\n        \
    \        end\n                table.remove(bracket_stack)\n            end\n \
    \       end\n    end\n    return (#bracket_stack == 0) and 'Yes' or 'No'\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfeifzujc.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpfeifzujc.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \   local counts = {0, 0}\n   for i = 1, 2 do\n      local s = lst[i]\n      for\
    \ j = 1, #s do\n         local c = s:sub(j, j)\n         if c == '(' then\n  \
    \          counts[i] = counts[i] + 1\n         else\n            counts[i] = counts[i]\
    \ - 1\n         end\n         if counts[i] < 0 then\n            return 'No'\n\
    \         end\n      end\n   end\n   if counts[1] == counts[2] then\n      return\
    \ 'Yes'\n   else\n      return 'No'\n   end\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr7_2plto.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpr7_2plto.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    for _, s in ipairs(lst) do\n        if s:find('%(%)') then\n            return\
    \ 'Yes'\n        end\n    end\n    return 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2wzgbr9m.lua:26:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp2wzgbr9m.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local parens_stack = {};\n    local opening_parens = {'(', '{', '['};\n \
    \   local closing_parens = {')', '}', ']'};\n    local matches = {\n        ['(']\
    \ = ')',\n        ['{'] = '}',\n        ['['] = ']'\n    };\n    local function\
    \ is_empty()\n        return not parens_stack[1];\n    end\n    local function\
    \ top()\n        return parens_stack[#parens_stack];\n    end\n    local function\
    \ pop()\n        table.remove(parens_stack, #parens_stack);\n    end\n    local\
    \ function push(char)\n        table.insert(parens_stack, char);\n    end\n  \
    \  local function is_pair(c)\n        return matches[top()] == c;\n    end\n \
    \   local function is_opening(c)\n        for _, p in ipairs(opening_parens) do\n\
    \            if p == c then\n                return true;\n            end\n \
    \       end\n        return false;\n    end\n    local function is_closing(c)\n\
    \        for _, p in ipairs(closing_parens) do\n            if p == c then\n \
    \               return true;\n            end\n        end\n        return false;\n\
    \    end\n    for _, word in ipairs(lst) do\n        for i = 1, #word do\n   \
    \         local c = word:sub(i, i);\n            if is_opening(c) then\n     \
    \           push(c);\n            elseif is_closing(c) then\n                if\
    \ is_empty() or not is_pair(c) then\n                    return 'No';\n      \
    \          else\n                    pop();\n                end\n           \
    \ end\n        end\n    end\n    return is_empty() and 'Yes' or 'No';\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprtqk2v89.lua:75:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmprtqk2v89.lua:75:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local str1, str2 = lst[1], lst[2]\n    -- <YOUR CODE HERE>\n    -- key idea:\
    \ make the strings into valid parens\n    -- then a valid parens just need to\
    \ be checked\n    local temp = str1..str2\n    local sum = 0\n    for i = 1, #temp\
    \ do\n        if temp:sub(i, i) == '(' then\n            sum = sum + 1\n     \
    \   else\n            sum = sum - 1\n        end\n        if sum < 0 then\n  \
    \          return 'No'\n        end\n    end\n    if sum == 0 then\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwge79bj4.lua:42:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpwge79bj4.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local n = 0\n    for _, s in ipairs(lst) do\n        for _ in s:gmatch'()'\
    \ do\n            n = n + 1\n        end\n    end\n    return n % 2 == 0 and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp21qiphnx.lua:26:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp21qiphnx.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local n = 0\n        for c in s:gmatch('%(%)')\
    \ do\n            if c == '(' then\n                n = n + 1\n            else\n\
    \                n = n - 1\n            end\n            if n < 0 then\n     \
    \           return false\n            end\n        end\n        return n == 0\n\
    \    end\n    return (is_good(lst[1]) and is_good(lst[2])) and 'Yes' or 'No'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf18_3azm.lua:33:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpf18_3azm.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    -- TODO\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmmoxtt_v.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmpmmoxtt_v.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local str = ''\n    for i = 1, #lst do\n        str = str .. lst[i]\n   \
    \ end\n    local count = 0\n    for i = 1, #str do\n        if str:sub(i, i) ==\
    \ '(' then\n            count = count + 1\n        else\n            count = count\
    \ - 1\n        end\n        if count < 0 then\n            return 'No'\n     \
    \   end\n    end\n    if count == 0 then\n        return 'Yes'\n    else\n   \
    \     return 'No'\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpac9gm92t.lua:41:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpac9gm92t.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \   local function split(s)\n      local res = {}\n      for c in s:gmatch(\"\
    .\") do\n         table.insert(res, c)\n      end\n      return res\n   end\n\
    \   local function index_first_close(lst)\n      for i = 1, #lst do\n        \
    \ if lst[i] == ')' then\n            return i\n         end\n      end\n     \
    \ return -1\n   end\n   local function split_parens(lst)\n      local first_close\
    \ = index_first_close(lst)\n      if first_close == -1 then\n         return {}\n\
    \      end\n      local res = {}\n      local curr = {}\n      for i = 1, #lst\
    \ do\n         if i < first_close then\n            table.insert(curr, lst[i])\n\
    \         elseif i == first_close then\n            table.insert(res, curr)\n\
    \            curr = {}\n         else\n            table.insert(curr, lst[i])\n\
    \         end\n      end\n      if #curr > 0 then\n         table.insert(res,\
    \ curr)\n      end\n      return res\n   end\n   local function str_find(sub,\
    \ s)\n      for i = 1, #s - #sub + 1 do\n         local ok = true\n         for\
    \ j = 1, #sub do\n            if sub[j] ~= s[i + j - 1] then\n               ok\
    \ = false\n               break\n            end\n         end\n         if ok\
    \ then\n            return i\n         end\n      end\n      return -1\n   end\n\
    \   local function join(lst)\n      local res = {}\n      for _, v in ipairs(lst)\
    \ do\n         for _, c in ipairs(v) do\n            table.insert(res, c)\n  \
    \       end\n      end\n      return res\n   end\n   local function pop_parens(lst)\n\
    \      local res = {}\n      local curr = {}\n      for i = 1, #lst do\n     \
    \    if lst[i] == '(' then\n            table.insert(curr, lst[i])\n         else\n\
    \            table.insert(res, curr)\n\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6bwpu5rd.lua:101: 'end' expected (to close 'if' at line 78)\
    \ near <eof>\n"
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  -- your code here\n  return nil\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnpfl3zxb.lua:20:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmpnpfl3zxb.lua:20:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local open, close = lst[1], lst[2]\n  if open == close then\n    return 'Yes'\n\
    \  end\n  return 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4hf3hsby.lua:23:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp4hf3hsby.lua:23:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function process(open, closed)\n    if open > closed then\n      return\
    \ 'No'\n    elseif open == closed then\n      return 'Yes'\n    else\n      return\
    \ process(open + 1, closed - 1)\n    end\n  end\n  local open = 0\n  local closed\
    \ = 0\n  for i = 1, #lst do\n    local str = lst[i]\n    for j = 1, #str do\n\
    \      local c = str:sub(j, j)\n      if c == '(' then\n        open = open +\
    \ 1\n      else\n        closed = closed + 1\n      end\n    end\n  end\n  return\
    \ process(open, closed)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkjy8pbwj.lua:42:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpkjy8pbwj.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \tlocal stack = {}\n\tfor _, str in ipairs(lst) do\n\t\tfor ch in str:gmatch('.')\
    \ do\n\t\t\tif ch == '(' then\n\t\t\t\ttable.insert(stack, ch)\n\t\t\telse\n\t\
    \t\t\tif #stack > 0 then\n\t\t\t\t\ttable.remove(stack)\n\t\t\t\telse\n\t\t\t\t\
    \treturn 'No'\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn #stack == 0 and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpg0twb3ar.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpg0twb3ar.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  -- your code goes here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpiuq07oy1.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmpiuq07oy1.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  -- your code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3ihvw8_t.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmp3ihvw8_t.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local cnt1, cnt2 = 0, 0\n  for i = 1, #lst[1] do\n    cnt1 = cnt1 + (lst[1]:sub(i,\
    \ i) == '(' and 1 or -1)\n  end\n  for i = 1, #lst[2] do\n    cnt2 = cnt2 + (lst[2]:sub(i,\
    \ i) == '(' and 1 or -1)\n  end\n  return (cnt1 + cnt2) >= 0 and 'Yes' or 'No'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp75jaetcp.lua:33:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp75jaetcp.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local cnt = 0\n  for _, p in ipairs(lst) do\n    for char in p:gmatch('%(')\
    \ do\n      cnt = cnt + 1\n    end\n    for char in p:gmatch('%)') do\n      cnt\
    \ = cnt - 1\n    end\n    if cnt < 0 then\n      return 'No'\n    end\n  end\n\
    \  return cnt == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc5qyjxrx.lua:34:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpc5qyjxrx.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s = table.concat(lst)\n    local tmp = {}\n    for i = 1, #s do\n \
    \       local char = s:sub(i, i)\n        if char == '(' then\n            table.insert(tmp,\
    \ char)\n        else\n            if #tmp > 0 then\n                table.remove(tmp)\n\
    \            else\n                return 'No'\n            end\n        end\n\
    \    end\n    return #tmp == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpdt27yyji.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpdt27yyji.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local ok = true\n  local cnt = 0\n  for i = 1, #lst do\n    local s = lst[i]\n\
    \    for j = 1, #s do\n      if s:sub(j, j) == '(' then\n        cnt = cnt + 1\n\
    \      else\n        cnt = cnt - 1\n      end\n      if cnt < 0 then\n       \
    \ ok = false\n        break\n      end\n    end\n  end\n  return ok and cnt ==\
    \ 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppwv3l64z.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmppwv3l64z.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local left, right = 0, 0\n  for _, s in ipairs(lst) do\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        left = left + 1\n      else\n        right\
    \ = right + 1\n      end\n    end\n  end\n  return left == right and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5ew8tayf.lua:38:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp5ew8tayf.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function balance(str)\n    local bal = 0\n    for i = 1, #str do\n  \
    \    if str:sub(i, i) == '(' then\n        bal = bal + 1\n      else\n       \
    \ bal = bal - 1\n      end\n      if bal < 0 then\n        return false\n    \
    \  end\n    end\n    return bal == 0\n  end\n  local s1, s2 = table.unpack(lst)\n\
    \  return balance(s1 .. s2) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkc0lwx24.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpkc0lwx24.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local stack = {}\n  local function push(x)\n    stack[#stack + 1] = x\n  end\n\
    \  local function pop()\n    stack[#stack] = nil\n  end\n  local function top()\n\
    \    return stack[#stack]\n  end\n  local function parenthesis_balance(s)\n  \
    \  for i = 1, #s do\n      local c = s:sub(i, i)\n      if c == '(' then\n   \
    \     push(c)\n      elseif c == ')' then\n        if top() == '(' then\n    \
    \      pop()\n        else\n          return false\n        end\n      end\n \
    \   end\n    return #stack == 0\n  end\n  local function next_combination(lst)\n\
    \    local n = #lst\n    local i = n\n    while i > 0 and lst[i] == ')' do\n \
    \     i = i - 1\n    end\n    if i <= 0 then\n      return nil\n    end\n    lst[i]\
    \ = ')'\n    for j = i + 1, n do\n      lst[j] = '('\n    end\n    return lst\n\
    \  end\n  local function next_permutation(lst)\n    local n = #lst\n    local\
    \ i = n - 1\n    while i > 0 and lst[i] >= lst[i + 1] do\n      i = i - 1\n  \
    \  end\n    if i <= 0 then\n      return nil\n    end\n    local j = n\n    while\
    \ lst[j] <= lst[i] do\n      j = j - 1\n    end\n    lst[i], lst[j] = lst[j],\
    \ lst[i]\n    local k = i + 1\n    local l = n\n    while k < l do\n      lst[k],\
    \ lst[l] = lst[l], lst[k]\n      k = k + 1\n      l = l - 1\n    end\n    return\
    \ lst\n  end\n  while true do\n    if parenthesis_balance(table.concat(lst)) then\n\
    \      return 'Yes'\n    end\n    lst = next_permutation(lst)\n    if not l\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpd4b1omj4.lua:82: 'then' expected near 'lu'\n"
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  -- Get the two strings\n  local a, b = lst[1], lst[2]\n  -- Check if both strings\
    \ are good.\n  local function check(a, b)\n    local function count(str)\n   \
    \   local n = 0\n      for c in str:gmatch'()' do\n        if c == '(' then n\
    \ = n + 1 else n = n - 1 end\n        if n < 0 then return false end\n      end\n\
    \      return n == 0\n    end\n    return count(a) and count(b)\n  end\n  -- Recursively\
    \ check the possible combinations\n  local function go(a, b)\n    if a == '' then\
    \ return check(b, '') end\n    if b == '' then return check(a, '') end\n    return\
    \ go(a:sub(2), b) or go(a, b:sub(2))\n  end\n  -- Return the result as 'Yes' or\
    \ 'No'\n  return (go(a, b) and 'Yes' or 'No')\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppd3n5wok.lua:40:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmppd3n5wok.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s = table.concat(lst)\n  if s:match\"^%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpgsoi5_6p.lua:14: unfinished string near '\"^%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%(%'\n"
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \   local function check(s)\n      local bal = 0\n      for c in s:gmatch(\".\"\
    ) do\n         if c == \"(\" then\n            bal = bal + 1\n         else\n\
    \            bal = bal - 1\n         end\n         if bal < 0 then\n         \
    \   return false\n         end\n      end\n      return bal == 0\n   end\n   if\
    \ #lst[1] == 0 then\n      return check(lst[2]) and \"Yes\" or \"No\"\n   elseif\
    \ #lst[2] == 0 then\n      return check(lst[1]) and \"Yes\" or \"No\"\n   else\n\
    \      return (check(lst[1] .. lst[2]) or check(lst[2] .. lst[1])) and \"Yes\"\
    \ or \"No\"\n   end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \tlocal a, b = lst[1], lst[2]\n\tlocal pa, pb = 0, 0\n\tfor i = 1, #a do\n\t\t\
    if a:sub(i, i) == '(' then\n\t\t\tpa = pa + 1\n\t\telse\n\t\t\tpa = pa - 1\n\t\
    \tend\n\tend\n\tfor i = 1, #b do\n\t\tif b:sub(i, i) == '(' then\n\t\t\tpb = pb\
    \ + 1\n\t\telse\n\t\t\tpb = pb - 1\n\t\tend\n\tend\n\tif pa < 0 or pb < 0 then\n\
    \t\treturn 'No'\n\tend\n\treturn 'Yes'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1uu0paas.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp1uu0paas.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local str1, str2 = lst[1], lst[2]\n  local cnt1, cnt2 = 0, 0\n  for i = 1,\
    \ #str1 do\n    if str1:sub(i, i) == '(' then\n      cnt1 = cnt1 + 1\n    else\n\
    \      cnt1 = cnt1 - 1\n    end\n  end\n  for i = 1, #str2 do\n    if str2:sub(i,\
    \ i) == '(' then\n      cnt2 = cnt2 + 1\n    else\n      cnt2 = cnt2 - 1\n   \
    \ end\n  end\n  if (cnt1 + cnt2) % 2 == 0 then\n    return 'Yes'\n  else\n   \
    \ return 'No'\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpef2mkl46.lua:40:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpef2mkl46.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function balanced(s)\n        local level = 0\n        for c in s:gmatch\"\
    .\" do\n            if c == \"(\" then\n                level = level + 1\n  \
    \          else\n                level = level - 1\n            end\n        \
    \    if level < 0 then\n                return false\n            end\n      \
    \  end\n        return level == 0\n    end\n    return balanced(lst[1] .. lst[2])\
    \ and \"Yes\" or \"No\"\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp70gmoqkz.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp70gmoqkz.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s = table.concat(lst)\n    if s:match(\"^()$\") or s:match(\"^()%(.*%)$\"\
    ) or s:match(\"^.*%(.*%)()$\") or s:match(\"^%(.*%)()%(.*%)$\") then\n       \
    \ return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp26b10ea0.lua:26:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp26b10ea0.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local extra = 0\n  for _, s in ipairs(lst) do\n    for c in s:gmatch(\".\"\
    ) do\n      if c == '(' then\n        extra = extra + 1\n      else\n        extra\
    \ = extra - 1\n      end\n      if extra < 0 then\n        return 'No'\n     \
    \ end\n    end\n  end\n  return extra == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7g4swx_7.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp7g4swx_7.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s = 'Yes'\n  local c = 0\n  for i = 1, #lst do\n    c = c + (lst[i]:sub(1,\
    \ 1) == '(' and 1 or -1)\n    if c < 0 then\n      s = 'No'\n      break\n   \
    \ end\n  end\n  return s\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpaucazhed.lua:30:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpaucazhed.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function count_parens(str)\n    local _, cnt = str:gsub('%(', '%(')\n\
    \    local _, cnt_ = str:gsub('%)', '%)')\n    return cnt, cnt_\n  end\n  local\
    \ function concat_parens(lst)\n    local str = ''\n    for _, val in ipairs(lst)\
    \ do\n      str = str .. val\n    end\n    return str\n  end\n  local counts =\
    \ {}\n  for _, str in ipairs(lst) do\n    local cnt, cnt_ = count_parens(str)\n\
    \    if cnt == cnt_ then\n      table.insert(counts, 0)\n    else\n      table.insert(counts,\
    \ cnt - cnt_)\n    end\n  end\n  local strs = {}\n  for _, cnt in ipairs(counts)\
    \ do\n    if cnt > 0 then\n      strs[1] = strs[1] or '('\n      if cnt == 1 then\n\
    \        strs[1] = strs[1] .. ')'\n      else\n        strs[1] = strs[1] .. ('('):rep(cnt\
    \ - 1) .. ')'\n      end\n    elseif cnt < 0 then\n      strs[2] = strs[2] or\
    \ ')'\n      if cnt == -1 then\n        strs[2] = strs[2] .. '('\n      else\n\
    \        strs[2] = strs[2] .. (')'):rep(-cnt - 1) .. '('\n      end\n    end\n\
    \  end\n  local str = concat_parens(strs)\n  local _, cnt = str:gsub('%(%(', '%(')\n\
    \  local _, cnt_ = str:gsub('%)%)', '%)')\n  if cnt == cnt_ then\n    return 'Yes'\n\
    \  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8174zvxg.lua:14:\
    \ invalid use of '%' in replacement string\nstack traceback:\n\t/tmp/tmp8174zvxg.lua:14:\
    \ in local 'count_parens'\n\t/tmp/tmp8174zvxg.lua:27: in local 'candidate'\n\t\
    /tmp/tmp8174zvxg.lua:65: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function balance(str)\n    local counter = 0\n    for c in str:gmatch(\"\
    .\") do\n      if c == '(' then\n        counter = counter + 1\n      else\n \
    \       counter = counter - 1\n      end\n      if counter < 0 then\n        return\
    \ false\n      end\n    end\n    return counter == 0\n  end\n  local str = table.concat(lst)\n\
    \  return balance(str) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptxcn_el6.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmptxcn_el6.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local x, y = lst[1], lst[2]\n    local xm, ym = 0, 0\n    for i = 1, #x do\n\
    \        xm = xm + (x:sub(i, i) == '(' and 1 or -1)\n    end\n    for i = 1, #y\
    \ do\n        ym = ym + (y:sub(i, i) == '(' and 1 or -1)\n    end\n    if xm ==\
    \ 0 and ym == 0 then\n        return 'Yes'\n    elseif xm < 0 and ym < 0 then\n\
    \        return 'No'\n    elseif xm > 0 and ym > 0 then\n        return 'No'\n\
    \    elseif xm + ym > 0 then\n        return 'Yes'\n    else\n        return 'No'\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp5l_q1l5.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpp5l_q1l5.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function good(s)\n    local c = 0\n    for i = 1, #s do\n      if s:sub(i,\
    \ i) == '(' then\n        c = c + 1\n      else\n        c = c - 1\n      end\n\
    \      if c < 0 then\n        return false\n      end\n    end\n    return c ==\
    \ 0\n  end\n  return (good(lst[1]) and good(lst[2])) and 'Yes' or 'No'\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjex7vwjg.lua:33:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpjex7vwjg.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local left, right = 0, 0\n  for _, s in ipairs(lst) do\n    for c in s:gmatch(\"\
    %(\") do left = left + 1 end\n    for c in s:gmatch(\"%)\") do right = right +\
    \ 1 end\n  end\n  return left == right and \"Yes\" or \"No\"\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpk5dhrxsf.lua:33:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpk5dhrxsf.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local a = lst[1]\n  local b = lst[2]\n  local open = 0\n  local close = 0\n\
    \  for _, c in ipairs(a) do\n    if c == '(' then\n      open = open + 1\n   \
    \ else\n      close = close + 1\n    end\n  end\n  for _, c in ipairs(b) do\n\
    \    if c == '(' then\n      open = open + 1\n    else\n      close = close +\
    \ 1\n    end\n  end\n  if open ~= close then\n    return 'No'\n  end\n  local\
    \ s = ''\n  while #a > 0 or #b > 0 do\n    local ca = a:sub(1, 1)\n    local cb\
    \ = b:sub(1, 1)\n    if ca == '(' then\n      s = s .. ca\n      a = a:sub(2)\n\
    \    elseif cb == '(' then\n      s = s .. cb\n      b = b:sub(2)\n    elseif\
    \ ca == ')' then\n      s = s .. ca\n      a = a:sub(2)\n    elseif cb == ')'\
    \ then\n      s = s .. cb\n      b = b:sub(2)\n    end\n  end\n  open = 0\n  close\
    \ = 0\n  for _, c in ipairs(s) do\n    if c == '(' then\n      open = open + 1\n\
    \    else\n      close = close + 1\n    end\n    if close > open then\n      return\
    \ 'No'\n    end\n  end\n  return 'Yes'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz0wjj41j.lua:71:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpz0wjj41j.lua:71:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local good, bad = 0, 0\n  for _, s in ipairs(lst) do\n    for _, c in ipairs(s:gmatch('.'))\
    \ do\n      if c == '(' then\n        good = good + 1\n      else\n        if\
    \ good == 0 then\n          bad = bad + 1\n        else\n          good = good\
    \ - 1\n        end\n      end\n    end\n  end\n  return good == 0 and bad == 0\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\nattempt to\
    \ index a function value\nstack traceback:\n\nRan 1 tests in 0.000 seconds, 0\
    \ successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local a, b = lst[1], lst[2]\n    local c = {\n        ['()'] = true,\n  \
    \      [')('] = true,\n        ['(('] = true,\n        ['))'] = true,\n    }\n\
    \    return (c[a .. b] and 'Yes') or 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0nmhkcv3.lua:26:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp0nmhkcv3.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local balance = 0\n  for _, paren in ipairs(lst) do\n    for c in paren:gmatch(\"\
    .\") do\n      if c == '(' then\n        balance = balance + 1\n      else\n \
    \       balance = balance - 1\n      end\n      if balance < 0 then\n        return\
    \ 'No'\n      end\n    end\n  end\n  return balance == 0 and 'Yes' or 'No'\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0vburb0m.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp0vburb0m.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local open = 0\n    local close = 0\n    for i = 1, #lst[1] do\n        if\
    \ lst[1]:sub(i, i) == '(' then\n            open = open + 1\n        else\n  \
    \          close = close + 1\n        end\n    end\n    for i = 1, #lst[2] do\n\
    \        if lst[2]:sub(i, i) == '(' then\n            open = open + 1\n      \
    \  else\n            close = close + 1\n        end\n    end\n    if open > close\
    \ then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpienk4kuz.lua:39:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpienk4kuz.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  if not lst[1] then return 'Yes' end\n  local l, r = lst[1]:gsub('%(', ''),\
    \ lst[2]:gsub('%)', '')\n  if l == '' and r == '' then return 'Yes' end\n  if\
    \ l ~= '' and r ~= '' then return 'No' end\n  if l == '' then return match_parens{'',\
    \ lst[2]:gsub('%)', '', 1)} end\n  return match_parens{lst[1]:gsub('%(', '', 1),\
    \ ''}\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function helper(s)\n    local cnt = 0\n    for i = 1, #s do\n      local\
    \ ch = s:sub(i, i)\n      if ch == '(' then\n        cnt = cnt + 1\n      else\n\
    \        cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n\
    \      end\n    end\n    return cnt == 0\n  end\n  local s1, s2 = table.unpack(lst)\n\
    \  return helper(s1) and helper(s2) and (helper(s1 .. s2) or helper(s2 .. s1))\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3c018buk.lua:35:\
    \ expected: \"Yes\"\nactual: false\nstack traceback:\n\t/tmp/tmp3c018buk.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local r = {\"Yes\"}\n    for i = 1, #lst do\n        for c in lst[i]:gmatch(\"\
    %S\") do\n            if c == \"(\" then\n                r[#r + 1] = c\n    \
    \        else\n                r[#r] = nil\n                if #r == 0 then\n\
    \                    return \"No\"\n                end\n            end\n   \
    \     end\n    end\n    return table.concat(r)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph5f4_xt1.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmph5f4_xt1.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \   local function count_parens(str)\n      local cnt, bal = 0, 0\n      for _,\
    \ c in ipairs(str) do\n         if c == '(' then\n            bal = bal + 1\n\
    \         else\n            bal = bal - 1\n         end\n         if bal < 0 then\n\
    \            cnt = cnt + 1\n         end\n      end\n      return cnt, bal\n \
    \  end\n   local cnt1, bal1 = count_parens(lst[1])\n   local cnt2, bal2 = count_parens(lst[2])\n\
    \   if cnt1 > cnt2 then\n      return 'No'\n   end\n   if bal1 < 0 and bal2 >\
    \ 0 then\n      return 'No'\n   end\n   return 'Yes'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp_fu41el.lua:42:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpp_fu41el.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local is_good = function(s)\n        local stack = {}\n        for c in s:gmatch('.')\
    \ do\n            if c == '(' then\n                table.insert(stack, c)\n \
    \           else\n                if #stack == 0 then\n                    return\
    \ false\n                end\n                table.remove(stack)\n          \
    \  end\n        end\n        return #stack == 0\n    end\n    if is_good(lst[1])\
    \ and is_good(lst[2]) then\n        return 'Yes'\n    end\n    if is_good(lst[1]\
    \ .. lst[2]) then\n        return 'Yes'\n    end\n    if is_good(lst[2] .. lst[1])\
    \ then\n        return 'Yes'\n    end\n    return 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local open = {}\n  local close = {}\n  for _, s in ipairs(lst) do\n    if s\
    \ == '(' then\n      table.insert(open, s)\n    else\n      table.insert(close,\
    \ s)\n    end\n  end\n  local good = true\n  for _, c in ipairs(close) do\n  \
    \  if #open == 0 then\n      good = false\n      break\n    end\n    table.remove(open)\n\
    \  end\n  if #open == 0 and good then\n    return 'Yes'\n  else\n    return 'No'\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuxcuy5ac.lua:40:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpuxcuy5ac.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function extract_parens(s)\n        local parens = {}\n        for\
    \ i = 1, #s do\n            local c = s:sub(i, i)\n            if c == '(' then\n\
    \                table.insert(parens, 1, c)\n            else\n              \
    \  if #parens > 0 then\n                    table.remove(parens, 1)\n        \
    \        else\n                    return false\n                end\n       \
    \     end\n        end\n        return true\n    end\n    local s1, s2 = lst[1],\
    \ lst[2]\n    local s1_good = extract_parens(s1)\n    local s2_good = extract_parens(s2)\n\
    \    if s1_good then\n        return s2_good and 'Yes' or 'No'\n    else\n   \
    \     return s2_good and 'No' or 'Yes'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjl163rc6.lua:42:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpjl163rc6.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local t = { ['('] = 1, [')'] = -1 }\n  local s = 0\n  for _,v in ipairs(lst)\
    \ do\n    for i = 1, #v do\n      s = s + t[v:sub(i,i)]\n      if s < 0 then return\
    \ 'No' end\n    end\n  end\n  return (s == 0) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb22c0bm9.lua:30:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpb22c0bm9.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local num_open = 0\n  local num_close = 0\n  for i = 1, #lst do\n    local\
    \ str = lst[i]\n    for j = 1, #str do\n      local c = str:sub(j, j)\n      if\
    \ c == '(' then\n        num_open = num_open + 1\n      else\n        num_close\
    \ = num_close + 1\n      end\n    end\n  end\n  if num_open == num_close then\n\
    \    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvriterb4.lua:45:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpvriterb4.lua:45:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  -- your code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphce9aeqd.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmphce9aeqd.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  -- your code here\n  local function parens_str(str)\n    local t = {}\n   \
    \ for i=1, #str do\n      if str:sub(i,i) == '(' then table.insert(t, '(') end\n\
    \      if str:sub(i,i) == ')' then table.insert(t, ')') end\n    end\n    return\
    \ t\n  end\n  if not lst[1] then return 'Yes' end\n  if not lst[2] then return\
    \ 'Yes' end\n  if #lst[1] == 1 and #lst[2] == 1 then\n    return 'No'\n  end\n\
    \  local str1 = parens_str(lst[1])\n  local str2 = parens_str(lst[2])\n  if #str1\
    \ == 0 and #str2 == 0 then return 'Yes' end\n  if #str1 == 0 and #str2 > 0 then\
    \ return 'No' end\n  if #str1 > 0 and #str2 == 0 then return 'No' end\n  if #str1\
    \ == #str2 then return 'Yes' end\n  local t = {}\n  for i=1, #str1 do\n    table.insert(t,\
    \ str1[i])\n  end\n  for i=1, #str2 do\n    table.insert(t, str2[i])\n  end\n\
    \  local stack = {}\n  for i=1, #t do\n    if t[i] == '(' then\n      table.insert(stack,\
    \ t[i])\n    else\n      if #stack == 0 then return 'No' end\n      if stack[#stack]\
    \ == '(' then\n        table.remove(stack)\n      else\n        return 'No'\n\
    \      end\n    end\n  end\n  if #stack == 0 then return 'Yes' end\n  return 'No'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_if4cztb.lua:63:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp_if4cztb.lua:63:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    -- your code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkkwlyndb.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmpkkwlyndb.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local l1, l2 = lst[1], lst[2]\n  local s1, s2 = string.match(l1, \"^(%(*)()\"\
    ), string.match(l2, \"^(%(*)()\")\n  if s1 and s2 then\n    return s1 == s2 and\
    \ \"Yes\" or \"No\"\n  elseif (s1 and not s2) or (not s1 and s2) then\n    return\
    \ \"No\"\n  else\n    return match_parens({string.sub(l1, 2), string.sub(l2, 2)})\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzk7atjhu.lua:27:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpzk7atjhu.lua:27:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s = {}\n    for _, v in ipairs(lst) do\n        for i = 1, #v do\n\
    \            local c = v:sub(i, i)\n            if c == '(' then\n           \
    \     table.insert(s, c)\n            else\n                if #s == 0 then\n\
    \                    return 'No'\n                end\n                table.remove(s)\n\
    \            end\n        end\n    end\n    return #s == 0 and 'Yes' or 'No'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppshyagn4.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmppshyagn4.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local counter = 0\n    for _, v in ipairs(lst) do\n        for i = 1, #v\
    \ do\n            if v:sub(i, i) == '(' then\n                counter = counter\
    \ + 1\n            else\n                counter = counter - 1\n            end\n\
    \            if counter < 0 then\n                return 'No'\n            end\n\
    \        end\n    end\n    return counter == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpaciukdk9.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpaciukdk9.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local a = lst[1]\n  local b = lst[2]\n  local function count(s)\n    local\
    \ c = 0\n    for i = 1, #s do\n      local ch = s:sub(i, i)\n      if ch == '('\
    \ then\n        c = c + 1\n      else\n        c = c - 1\n      end\n      if\
    \ c < 0 then\n        return -1\n      end\n    end\n    return c\n  end\n  local\
    \ ca = count(a)\n  local cb = count(b)\n  if ca == 0 and cb == 0 then\n    return\
    \ 'Yes'\n  elseif ca == -1 or cb == -1 then\n    return 'No'\n  elseif (ca > 0\
    \ and cb > 0) or (ca < 0 and cb < 0) then\n    return 'No'\n  else\n    local\
    \ s = a .. b\n    if count(s) == 0 then\n      return 'Yes'\n    else\n      return\
    \ 'No'\n    end\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0z49rdvp.lua:51:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp0z49rdvp.lua:51:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function helper(lst, cnt)\n        for _, v in ipairs(lst) do\n   \
    \         if cnt < 0 then return false end\n            if v == '(' then cnt =\
    \ cnt + 1\n            else cnt = cnt - 1 end\n        end\n        return cnt\
    \ == 0\n    end\n    return helper(lst[1], 0) and helper(lst[2], 0) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_sz_j9sh.lua:28:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp_sz_j9sh.lua:28:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local open = 0\n    local close = 0\n    for i = 1, #lst[1] do\n        if\
    \ lst[1]:sub(i, i) == '(' then\n            open = open + 1\n        else\n  \
    \          close = close + 1\n        end\n    end\n    for i = 1, #lst[2] do\n\
    \        if lst[2]:sub(i, i) == '(' then\n            open = open + 1\n      \
    \  else\n            close = close + 1\n        end\n    end\n    if open == close\
    \ then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5zsa2cn9.lua:48:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp5zsa2cn9.lua:48:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local good_count, bad_count = 0, 0\n  for _, s in ipairs(lst) do\n    for p\
    \ in s:gmatch('%(') do good_count = good_count + 1 end\n    for p in s:gmatch('%)')\
    \ do\n      if good_count == 0 then bad_count = bad_count + 1\n      else good_count\
    \ = good_count - 1 end\n    end\n  end\n  return (good_count == 0 and bad_count\
    \ == 0) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_nrxphdm.lua:30:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp_nrxphdm.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local count = 0\n    for i, s in ipairs(lst) do\n        for c in s:gmatch('[()]')\
    \ do\n            if c == '(' then\n                count = count + 1\n      \
    \      else\n                count = count - 1\n            end\n            if\
    \ count < 0 then\n                return 'No'\n            end\n        end\n\
    \    end\n    return count == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpatcm63d2.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpatcm63d2.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local left_parens, right_parens = 0, 0\n    for _, c in ipairs(lst[1]) do\n\
    \        if c == '(' then\n            left_parens = left_parens + 1\n       \
    \ else\n            left_parens = left_parens - 1\n        end\n    end\n    for\
    \ _, c in ipairs(lst[2]) do\n        if c == ')' then\n            right_parens\
    \ = right_parens + 1\n        else\n            right_parens = right_parens -\
    \ 1\n        end\n    end\n    if left_parens >= 0 and right_parens >= 0 then\n\
    \        return 'Yes'\n    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmwevinev.lua:39:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpmwevinev.lua:39:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local str = table.concat(lst)\n    local level = 0\n    for i = 1, #str do\n\
    \        if str:sub(i, i) == '(' then\n            level = level + 1\n       \
    \ else\n            level = level - 1\n        end\n        if level < 0 then\n\
    \            return 'No'\n        end\n    end\n    return level == 0 and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpade55znk.lua:34:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpade55znk.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local u, v = lst[1], lst[2]\n    local s = 0\n    for i = 1, #u do\n    \
    \    if u:sub(i, i) == '(' then\n            s = s + 1\n        else\n       \
    \     s = s - 1\n        end\n    end\n    for i = 1, #v do\n        if v:sub(i,\
    \ i) == '(' then\n            s = s + 1\n        else\n            s = s - 1\n\
    \        end\n    end\n    if s == 0 then\n        return 'Yes'\n    else\n  \
    \      return 'No'\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3q1wj_3k.lua:48:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp3q1wj_3k.lua:48:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local cnt = 0\n  for _,s in ipairs(lst) do\n    for i=1,#s do\n      local\
    \ c = s:sub(i,i)\n      if c == '(' then\n        cnt = cnt + 1\n      else\n\
    \        cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return 'No'\n\
    \      end\n    end\n  end\n  return cnt == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq6vfghqp.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpq6vfghqp.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \   -- your code goes here\n   local function balance(str)\n      local count\
    \ = 0\n      for i=1,#str do\n         if str:sub(i,i) == '(' then\n         \
    \   count = count + 1\n         else\n            count = count - 1\n        \
    \ end\n         if count < 0 then\n            return false\n         end\n  \
    \    end\n      return count == 0\n   end\n   return balance(lst[1]..lst[2]) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpen4pkpzx.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpen4pkpzx.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  -- your code here!\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphvyovmnz.lua:19:\
    \ expected: \"Yes\"\nactual: nil\nstack traceback:\n\t/tmp/tmphvyovmnz.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s = lst[1] .. lst[2]\n  local tmp = 0\n  for i = 1, #s do\n    local\
    \ c = s:sub(i, i)\n    if c == '(' then\n      tmp = tmp + 1\n    else\n     \
    \ tmp = tmp - 1\n    end\n    if tmp < 0 then\n      return 'No'\n    end\n  end\n\
    \  return tmp == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoc4q8i5x.lua:35:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpoc4q8i5x.lua:35:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local balance = 0\n    for _, s in ipairs(lst) do\n        for i = 1, #s\
    \ do\n            local c = s:sub(i, i)\n            if c == '(' then\n      \
    \          balance = balance + 1\n            else\n                balance =\
    \ balance - 1\n            end\n            if balance < 0 then\n            \
    \    return 'No'\n            end\n        end\n    end\n    return balance ==\
    \ 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3w2m9eqr.lua:36:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp3w2m9eqr.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function balance(parens)\n        local len = #parens\n        local\
    \ sum = 0\n        for i = 1, len do\n            if parens:sub(i, i) == '(' then\n\
    \                sum = sum + 1\n            else\n                sum = sum -\
    \ 1\n            end\n            if sum < 0 then\n                return false\n\
    \            end\n        end\n        return sum == 0\n    end\n    local s1,\
    \ s2 = lst[1], lst[2]\n    return balance(s1 .. s2) or balance(s2 .. s1) and 'Yes'\
    \ or 'No'\nend\n_G.match_parens = match_parens\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0cdxlzp1.lua:36:\
    \ expected: \"Yes\"\nactual: true\nstack traceback:\n\t/tmp/tmp0cdxlzp1.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local d = {[0] = 1}\n    for i, v in ipairs(lst) do\n        for c in v:gmatch'.'\
    \ do\n            d[i] = (d[i - 1] or 0) + (c == '(' and 1 or -1)\n          \
    \  if d[i] < 0 then return 'No' end\n        end\n    end\n    return (d[#lst]\
    \ or 0) == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4_c6ikc3.lua:26:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmp4_c6ikc3.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \tlocal function helper(s1, s2)\n\t\tlocal function is_good(str)\n\t\t\tlocal\
    \ s = 0\n\t\t\tfor i = 1, #str do\n\t\t\t\tif str:sub(i, i) == '(' then\n\t\t\t\
    \t\ts = s + 1\n\t\t\t\telse\n\t\t\t\t\ts = s - 1\n\t\t\t\tend\n\t\t\t\tif s <\
    \ 0 then\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn s == 0\n\
    \t\tend\n\t\treturn is_good(s1 .. s2) or is_good(s2 .. s1)\n\tend\n\treturn helper(lst[1],\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function count_parens(str)\n        return str:gsub('%(', ''):len()\
    \ - str:gsub('%)', ''):len()\n    end\n    local function is_good(str)\n     \
    \   local cnt = count_parens(str)\n        return cnt == 0\n    end\n    local\
    \ s0, s1 = lst[1], lst[2]\n    if is_good(s0) then\n        return 'Yes'\n   \
    \ elseif is_good(s1) then\n        return 'Yes'\n    elseif is_good(s0 .. s1)\
    \ then\n        return 'Yes'\n    elseif is_good(s1 .. s0) then\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0_nvf1vi.lua:42:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmp0_nvf1vi.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function eval(str)\n    local x = 0\n    for i = 1, str:len() do\n  \
    \    if str:sub(i, i) == '(' then\n        x = x + 1\n      else\n        x =\
    \ x - 1\n      end\n      if x < 0 then\n        return false\n      end\n   \
    \ end\n    return x == 0\n  end\n  if lst[1] == ')' or lst[2] == ')' then\n  \
    \  return 'No'\n  end\n  local str = lst[1] .. lst[2]\n  return eval(str) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmps_jxlazt.lua:37:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmps_jxlazt.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s = ''\n    for _,s1 in ipairs(lst) do\n        s = s .. s1\n    end\n\
    \    s = s:gsub('%(%s*%)', '')\n    while s:find('%(%)') do\n        s = s:gsub('%(%)',\
    \ '')\n    end\n    return (s == '') and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsfg761li.lua:30:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmpsfg761li.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local closed, opened = 0, 0\n  for _, s in ipairs(lst) do\n    for i = 1, #s\
    \ do\n      if s:sub(i, i) == '(' then\n        opened = opened + 1\n      else\n\
    \        closed = closed + 1\n      end\n    end\n  end\n  return opened >= closed\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpenqzv_z_.lua:36:\
    \ expected: \"No\"\nactual: \"Yes\"\nstack traceback:\n\t/tmp/tmpenqzv_z_.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s = lst[1] .. lst[2]\n  local count = 0\n  for i = 1, #s do\n    if s:sub(i,\
    \ i) == '(' then\n      count = count + 1\n    else\n      count = count - 1\n\
    \    end\n    if count < 0 then\n      return 'No'\n    end\n  end\n  if count\
    \ == 0 then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppkdnbdit.lua:38:\
    \ expected: \"Yes\"\nactual: \"No\"\nstack traceback:\n\t/tmp/tmppkdnbdit.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
