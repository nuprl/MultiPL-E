name: HumanEval_83_starts_one_ends
language: lua
prompt: "-- Given a positive integer n, return the count of the numbers of n-digit\n\
  -- positive integers that start or end with 1.\nlocal function starts_one_ends(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = starts_one_ends\n\
  \    lu.assertEquals(candidate(1), 1)\n    lu.assertEquals(candidate(2), 18)\n \
  \   lu.assertEquals(candidate(3), 180)\n    lu.assertEquals(candidate(4), 1800)\n\
  \    lu.assertEquals(candidate(5), 18000)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    if n == 1 then\n        return 2\n    end\n    local d = starts_one_ends(n\
    \ - 1)\n    return d * 9 + 10 ^ (n - 1)\nend", "    local result = 1\n    while\
    \ n ~= 1 do\n        n = n - 1\n        result = result * 10\n    end\n    return\
    \ result\nend", "  if n == 1 then\n    return 2\n  end\n  if n == 2 then\n   \
    \ return 3\n  end\n  local count = 2\n  local factor = 10\n  local digits = n\
    \ - 2\n  while digits > 0 do\n    count = count * 9\n    digits = digits - 1\n\
    \  end\n  count = count * 2\n  return count\nend", "    if n == 1 then\n     \
    \   return 2\n    end\n    if n == 2 then\n        return 3\n    end\n    if n\
    \ == 3 then\n        return 4\n    end\n    local count = 4\n    for i = 1, n-3\
    \ do\n        count = count * 3\n    end\n    return count\nend", "  if n == 1\
    \ then\n    return 2\n  end\n  return starts_one_ends(n - 1) + 9 * count_nines(n\
    \ - 1)\nend", "  local results = {1, 1}\n  for i = 2, n do\n    results[i] = results[i\
    \ - 1] + results[i - 2]\n  end\n  return results[n]\nend", "    local B = 2 *\
    \ 10^(n-1)\n    local S = 10^(n-1)\n    return B-S+1\nend", "    if n == 1 then\n\
    \        return 2\n    end\n    return 2 * starts_one_ends(n - 1) + (10 ^ (n -\
    \ 1) - 1)\nend", "  if n == 1 then\n    return 2\n  end\n  local dp = {0, 10,\
    \ 9 * 9, 9 * 9 * 8, 9 * 9 * 8 * 7, 9 * 9 * 8 * 7 * 6,\n      9 * 9 * 8 * 7 * 6\
    \ * 5, 9 * 9 * 8 * 7 * 6 * 5 * 4,\n      9 * 9 * 8 * 7 * 6 * 5 * 4 * 3, 9 * 9\
    \ * 8 * 7 * 6 * 5 * 4 * 3 * 2}\n  return dp[n]\nend", "    if n == 1 then\n  \
    \      return 2\n    end\n    local r = 9\n    for i = 2, n do\n        r = r\
    \ * 10 - 2\n    end\n    return r\nend", "    -- base case\n    if n == 1 then\n\
    \        return 2\n    end", "  local start, end = 1, 0\n  local total = 2\n \
    \ while start > 0 and end > 0 do\n    start, end = next_start_one(start, n)\n\
    \    total = total + (start or 0) + (end or 0)\n  end\n  return total\nend", " \
    \   if n == 1 then\n        return 2\n    end\n    return starts_one_ends(n -\
    \ 1) + number_at_digits(n - 1)\nend", "    -- The easy case:\n    if n == 1 then\n\
    \        return 1\n    end", "   if n == 1 then\n      return 2\n   else\n   \
    \   return 3 * starts_one_ends(n - 1) - 2\n   end\nend", "    -- Return the count\
    \ of positive integers of n-digits that start or end with 1.\n    -- If n is less\
    \ than 2, return 0.\n    -- Else return the count of a positive integer of n-digits\
    \ that begins with 1 plus\n    -- 9 times the count of positive integers of n-1\
    \ digits that start or end with 1.\n    if n < 2 then\n        return 0\n    else\n\
    \        return 10 * starts_one_ends(n - 1)\n    end\nend", "    if n == 1 then\n\
    \        return 2\n    end\n    local f = { { { 0, 1 }, 1 }, { { 1, 0 }, 1 } }\n\
    \    local _ = nil\n    for i = 3, n do\n        _ = f[1]\n        f[1] = f[2]\n\
    \        f[2] = _\n        f[2][1][1] = f[1][1][1] + f[1][1][2]\n        f[2][1][2]\
    \ = f[1][1][1]\n        f[2][2] = f[2][1][1] + f[2][1][2]\n    end\n    return\
    \ f[2][2]\nend", "  local dp = {}\n  dp[0] = 1\n  dp[1] = 10\n  for i = 2, n do\n\
    \    dp[i] = dp[i - 1] + (dp[i - 2] * 9)\n  end\n  return dp[n]\nend", "  if n\
    \ == 1 then\n    return 1\n  end\n  return 9 * (10 ^ (n - 2)) + starts_one_ends(n\
    \ - 1)\nend", "  if n == 1 then\n    return 1\n  end\n  if n == 2 then\n    return\
    \ 3\n  end\n  local n_minus_2 = starts_one_ends(n - 2)\n  local n_minus_1 = starts_one_ends(n\
    \ - 1)\n  return n_minus_2 + 2 * n_minus_1 + 2\nend", "  local end_at_one = function(k)\n\
    \    if k == 0 then return 1 end\n    if k == 1 then return 3 end\n    return\
    \ 9 * math.pow(10, k - 1)\n  end\n  local start_at_one = function(k)\n    if k\
    \ == 0 then return 1 end\n    if k == 1 then return 1 end\n    return 9 * math.pow(10,\
    \ k - 1)\n  end\n  local r = 0\n  for i = 0, n - 1 do\n    r = r + end_at_one(i)\
    \ + start_at_one(n - i - 1)\n  end\n  return r\nend", "  local f = function(k)\n\
    \    if n == k then\n      return 1\n    elseif n == 1 then\n      return 10\n\
    \    else\n      return 10 * starts_one_ends(k - 1)\n    end\n  end\n  return\
    \ f(n) + starts_one_ends(n - 1)\nend", "    -- Count of positive integers that\
    \ start with 1 given a digit count.\n    local function first_one(n)\n       \
    \ -- Count of positive integers that end with 1 given a digit count.\n       \
    \ local function last_one(n)\n            if n == 1 then\n                return\
    \ 1\n            else\n                return last_one(n - 1) + 9 * first_one(n\
    \ - 1)\n            end\n        end", "    -- n-digit positive integers that\
    \ start with 1: 1 followed by n-1 digits\n    -- which can be any digit, i.e.\
    \ 10^(n-1) - 1.\n    --\n    -- n-digit positive integers that end with 1: n-1\
    \ digits which can be any\n    -- digit, i.e. 10^(n-1) - 1, followed by a 1.\n\
    \    return 2 * (10^(n-1) - 1)\nend", "    local function starts_one(count)\n\
    \        if count == 1 then\n            return 2\n        else\n            return\
    \ 1 + 9 * count\n        end\n    end\n    return starts_one(n) + starts_one(n\
    \ - 1)\nend", "    if n == 1 then\n        return 2\n    end\n    local nums =\
    \ {1, 1}\n    for _ = 1, n - 1 do\n        local k = #nums\n        for i = k,\
    \ 2, -1 do\n            nums[i] = nums[i] + nums[i - 1]\n        end\n       \
    \ nums[1] = nums[1] * 2\n    end\n    return nums[#nums]\nend", "  if n == 1 then\n\
    \    return 2\n  end\n  return (n - 1) * 9 * starts_one_ends(n - 1) + 9 * starts_one_ends(n\
    \ - 1)\nend", "  if n == 1 then\n    return 1\n  end\n  local result = 0\n  local\
    \ x = 10^(n-1)\n  local y = 10^(n-2)\n  for i = 1, 10 do\n    if i == 1 then\n\
    \      result = result + (y + x)\n    else\n      result = result + 2*y\n    end\n\
    \  end\n  return result\nend", "  if n == 1 then\n    return 2\n  end\n  if n\
    \ == 2 then\n    return 5\n  end\n  if n == 3 then\n    return 7\n  end\n  return\
    \ math.floor(10^(n-2)) + 2*math.floor(10^(n-1)) + 1\nend", "  if n == 1 then\n\
    \    return 2\n  end\n  return starts_one_ends(n - 1) + ends_one_ends(n - 1)\n\
    end", "   return (10^(n-1) - 10^(n-2)) * 2\nend", "  if n == 1 then\n    return\
    \ 2\n  end\n  local sum = starts_one_ends(n - 1)\n  if n > 2 then\n    sum = sum\
    \ + starts_one_ends(n - 2)\n  end\n  return sum\nend", "  if n == 1 then\n   \
    \ return 2\n  end\n  local res = 4\n  for _ = 1, n - 2 do\n    res = res * 5\n\
    \  end\n  return res\nend", "  local count = 0\n  for i = 1, n do\n    count =\
    \ count + math.pow(9, i - 1)\n  end\n  return 2 * count\nend", "   local prefixes\
    \ = { '' }\n   for k = 1, n do\n      local np = {}\n      for _, p in ipairs(prefixes)\
    \ do\n         np[#np+1] = '0' .. p\n         np[#np+1] = '1' .. p\n      end\n\
    \      prefixes = np\n   end\n   local suffixes = { '' }\n   for k = 1, n do\n\
    \      local ns = {}\n      for _, s in ipairs(suffixes) do\n         ns[#ns+1]\
    \ = s .. '0'\n         ns[#ns+1] = s .. '1'\n      end\n      suffixes = ns\n\
    \   end\n   local prefixes_sum = 0\n   for _, p in ipairs(prefixes) do\n     \
    \ prefixes_sum = prefixes_sum + tonumber(p)\n   end\n   local suffixes_sum = 0\n\
    \   for _, s in ipairs(suffixes) do\n      suffixes_sum = suffixes_sum + tonumber(s)\n\
    \   end\n   return prefixes_sum + suffixes_sum - 1\nend", "    if n < 1 then\n\
    \        return 0\n    end\n    if n == 1 then\n        return 1\n    end\n  \
    \  local r = 0\n    for i = 1, 9 do\n        r = r + starts_one_ends(n - 1)\n\
    \    end\n    r = r + starts_one_ends(n - 2)\n    return r\nend", "  if n < 1\
    \ then\n    return 0\n  end\n  local sum = 0\n  for i = 1, n do\n    sum = sum\
    \ + 9 * fib(i - 1) * fib(n - i)\n  end\n  return sum\nend", "    -- start with\
    \ 1\n    -- end with 1\n    return nil\nend", "    local count = 0\n    for k,\
    \ v in pairs(all_numbers_with_ones(n)) do\n        count = count + 1\n    end\n\
    \    return count\nend", "    if n == 1 then\n        return 2\n    end\n    if\
    \ n == 2 then\n        return 4\n    end\n    return 4 * (10^(n-2))\nend", " \
    \ local f_i, f_i1, f_i2 = 1, 0, 0\n  local start_f_i, start_f_i1, start_f_i2 =\
    \ 1, 0, 0\n  local end_f_i, end_f_i1, end_f_i2 = 1, 0, 0\n  for i = 3, n do\n\
    \    f_i = f_i1 + f_i2\n    start_f_i = start_f_i1 + start_f_i2\n    end_f_i =\
    \ end_f_i1 + end_f_i2\n    f_i2 = f_i1\n    f_i1 = f_i\n    start_f_i2 = start_f_i1\n\
    \    start_f_i1 = start_f_i\n    end_f_i2 = end_f_i1\n    end_f_i1 = end_f_i\n\
    \  end\n  return f_i + start_f_i + end_f_i - 3\nend", "    -- n = 1\n    -- 1",
  "  -- state: number of integers of length i (starting with 1, ending with 1).\n\
    \  local a, b = 1, 1\n  for i = 1, n - 1 do\n    a, b = (a + b) * 9, a\n  end\n\
    \  return a + b\nend", "    if n == 1 then\n        return 2\n    end\n    return\
    \ starts_one_ends(n - 1) + starts_one_ends(n - 2)\nend", "    if n == 1 then\n\
    \        return 2\n    end\n    if n == 2 then\n        return 4\n    end\n  \
    \  return starts_one_ends(n - 1) + starts_one_ends(n - 2)\nend", "  local count\
    \ = 0\n  for i = 10 ^ (n - 1), 10 ^ n - 1 do\n    if tostring(i):sub(1, 1) ==\
    \ '1' or tostring(i):sub(-1) == '1' then\n      count = count + 1\n    end\n \
    \ end\n  return count\nend", "  if n == 1 then\n    return 2\n  end\n  local count\
    \ = 0\n  for i = 1, n - 1 do\n    count = count + starts_one_ends(i) * starts_one_ends(n\
    \ - i)\n  end\n  return count\nend", "  if n == 1 then\n    return 10\n  end\n\
    \  return 9 * (math.pow(10, n - 1) - math.pow(9, n - 1))\nend", "    local a =\
    \ math.ceil(n / 2)\n    local b = math.floor(n / 2)\n    return (math.pow(10,\
    \ a) - math.pow(10, a - 1)) * math.pow(9, b)\nend", "   assert(n > 0)\n   local\
    \ function is_valid(s)\n      if #s == 1 then\n         return s == \"1\"\n  \
    \    end\n      return s:sub(1, 1) == \"1\" or s:sub(#s) == \"1\"\n   end\n  \
    \ return count_in_str(n, is_valid)\nend", "  if n == 1 then\n    return 1\n  end\n\
    \  if n % 2 == 0 then\n    return n * n * n * n * n * n * n * n / 8\n  end\n \
    \ return n * n * n * n * n * n * n * n / 4\nend", "  local counts = {0,1,1,1,1,1,1,1,1,1}\n\
    \  for i = 2, n do\n    local count = 0\n    for j = 0, 9 do\n      count = count\
    \ + counts[j+1]\n    end\n    counts[1] = count\n    for j = 2, 9 do\n      counts[j]\
    \ = counts[j] + counts[j-1]\n    end\n  end\n  return counts[1] + counts[#counts]\n\
    end", "   if n == 1 then\n      return 2\n   else\n      local count = starts_one_ends(n\
    \ - 1)\n      count = count + (10 - 1) * 9 * count\n      return count\n   end\n\
    end", "  local d = n - 1\n  local ends = 1\n  for _ = 1, d do\n    ends = ends\
    \ * 10\n  end\n  local starts = ends\n  if n > 1 then\n    starts = starts + 1\n\
    \  end\n  return starts + ends\nend", "  if n == 1 then\n    return 2\n  end\n\
    \  if n == 2 then\n    return 3\n  end\n  return starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2)\nend", "  if n == 1 then\n    return 2\n  end\n  local counts = {1, 1}\n\
    \  for _ = 3, n do\n    table.insert(counts, counts[#counts] + counts[#counts\
    \ - 1])\n  end\n  return counts[#counts] + counts[#counts - 1]\nend", "    if\
    \ n < 1 then\n        return 0\n    end\n    if n == 1 then\n        return 1\n\
    \    end\n    return 9*((10^(n-1)) - 1) + starts_one_ends(n-1)\nend", "   if n\
    \ == 1 then\n      return 2\n   else\n      return starts_one_ends(n-1) + number_of_base_10_n_digit_numbers(n-1)\n\
    \   end\nend", "   if n == 1 then\n      return 2\n   else\n      return 9 + starts_one_ends(n\
    \ - 1)\n   end\nend", "  local n = n - 1\n  return n * math.pow(9, n)\nend", " \
    \ local start, end = 1, 1\n  for i = 2, n do\n    local mid = start + end\n  \
    \  start, end = mid, start\n  end\n  return start + end\nend", "    local dp =\
    \ {}\n    for i = 1, n do\n        if i == 1 then\n            dp[i] = 2\n   \
    \     elseif i == 2 then\n            dp[i] = 3\n        else\n            dp[i]\
    \ = dp[i - 1] + dp[i - 2]\n        end\n    end\n    return dp[n]\nend", "  --\
    \ F(n) = 10 * F(n-1) + 2\n  local t = {0, 10, 100}\n  for i = 4, n do\n    t[i]\
    \ = 10 * t[i-1] + 2\n  end\n  return t[n]\nend", "    if n == 1 then\n       \
    \ return 2\n    end\n    return 3 * starts_one_ends(n - 1)\nend", "  if n == 1\
    \ then\n    return 10\n  end\n  return starts_one_ends(n - 1) + (10 ^ (n - 1))\n\
    end", "  -- Make a table of tables of numbers.\n  local tab = {}\n  for i = 1,\
    \ n do\n    tab[i] = {}\n  end\n  -- For each digit, the first row is 0, the second\
    \ is 1, the third is 2, and\n  -- the next is the sum of the previous two.\n \
    \ --\n  -- There are no 0 digit numbers that start or end with 1.\n  tab[1][1]\
    \ = 0\n  tab[1][2] = 0\n  -- There is 1 1 digit number that starts or ends with\
    \ 1.\n  tab[2][1] = 1\n  tab[2][2] = 1\n  -- There are 2 2 digit numbers that\
    \ start or end with 1.\n  tab[3][1] = 2\n  tab[3][2] = 2\n  -- Fill in the table.\n\
    \  for i = 3, n do\n    tab[i][1] = tab[i - 1][1] + tab[i - 1][2]\n    tab[i][2]\
    \ = tab[i - 1][1]\n  end\n  -- Return the sum of the last row, 1 less than the\
    \ number of digits.\n  return tab[n][1] + tab[n][2] - 1\nend", "    if n == 1\
    \ then\n        return 1\n    end\n    if n == 2 then\n        return 3\n    end\n\
    \    local a, b = 1, 1\n    for _ = 3, n do\n        local t = a + b\n       \
    \ a, b = b, t\n    end\n    return b * 2 + a\nend", "    local function ends_one_ends(n)\n\
    \        if n == 1 then\n            return 2\n        else\n            return\
    \ 9 * sum(10^(i-1) for i=1,n-1)\n        end\n    end\n    return 10^(n-1) + ends_one_ends(n)\n\
    end", "    -- Note: I don't know how to get this value to just be a single\n \
    \   -- integer, so I have to convert the bignum to a string, then back\n    --\
    \ to an integer. Meh.\n    return tostring(9 * (10 ^ (n - 1) - 10 ^ (n - 2))):to_int()\n\
    end", "    if n == 1 then\n        return 2\n    end\n    return starts_one_ends(n\
    \ - 1) + (9 * (math.floor(n / 2) - 1))\nend", "    local cnt = {10, 100, 1000,\
    \ 10000, 100000, 1000000, 10000000, 100000000, 1000000000}\n    return cnt[n]\n\
    end", "    local ending_1s = (10 ^ (n - 1))\n    local not_ending_1s = 45 * (9\
    \ ^ (n - 1))\n    return ending_1s + not_ending_1s\nend", "  -- n == 1: 1\n  --\
    \ n == 2: 10\n  -- n == 3: 100 + 20\n  -- n == 4: 1000 + 200 + 100\n  -- n ==\
    \ 5: 10000 + 2000 + 200 + 100\n  -- n == 6: 100000 + 20000 + 2000 + 200 + 100\n\
    \  --\n  -- n == 1: 1\n  -- n == 2: 10\n  -- n == 3: 100 + 20 = 10*(n-1) + (n-1)\n\
    \  -- n == 4: 1000 + 200 + 100 = 10*(n-1) + (n-1)^2\n  -- n == 5: 10000 + 2000\
    \ + 200 + 100 = 10*(n-1) + (n-1)^2 + (n-1)\n  -- n == 6: 100000 + 20000 + 2000\
    \ + 200 + 100 = 10*(n-1) + (n-1)^2 + 2*(n-1)\n  --\n  -- starts_one_ends(n) =\
    \ 10*(n-1) + (n-1)^2 + (n-1) + ... + (n-1)\n  -- starts_one_ends(n) = 10*(n-1)\
    \ + (n-1)^2 + (n-1) + ... + (n-1) + (n-1)\n  -- starts_one_ends(n) = 10*(n-1)\
    \ + (n-1)^2 + (n-1) + ... + (n-1) + (n-1)\n  -- starts_one_ends(n) = 10*(n-1)\
    \ + (n-1)^2 + (n-1) + ... + (n-1) + (n-1)\n  -- starts_one_ends(n) = 10*(n-1)\
    \ + (n-1)^2 + (n-1) + ... + (n-1) + (n-1)\n  -- starts_one_ends(n) = 10*(n-1)\
    \ + (n-1)^2 + (n-1) + ... + (n-1) + (n-1)\n  -- starts_one_ends(n) = 10*", " \
    \ -- The set of all n-digit positive integers is {0, 1, ..., 10^n - 1}.\n  --\
    \ The set of all n-digit positive integers that start with 1 is\n  -- {10, 11,\
    \ ..., 10^{n-1} + 1}.\n  -- The set of all n-digit positive integers that end\
    \ with 1 is\n  -- {1, 11, 21, ..., (10^n - 1) - 9, 10^n - 1}.\n  -- Therefore,\
    \ the set of all n-digit positive integers that start or end\n  -- with 1 is the\
    \ union of the two sets above.\n  return math.floor(math.pow(10, n - 1)) + 1 +\
    \ math.floor(math.pow(10, n)) - 10\nend", "    local digits = math.floor(n / 2)\n\
    \    local bigs = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n    for i = 2, digits do\n \
    \       local nexts = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n        for d = 1, 10 do\n\
    \            for d2 = 0, 9 do\n                nexts[d] = nexts[d] + bigs[d2]\n\
    \            end\n        end\n        bigs = nexts\n    end\n    if n % 2 ==\
    \ 0 then\n        return bigs[1]\n    else\n        local ans = 0\n        for\
    \ i = 1, 10 do\n            ans = ans + bigs[i]\n        end\n        return ans\n\
    \    end\nend", "    local f = 0\n    local g = 0\n    local h = 0\n    local\
    \ temp = 0\n    local p = 0\n    local q = 0\n    local r = 0\n    local count\
    \ = 0\n    local i = 1\n    while i <= n do\n        temp = temp + 9 * f\n   \
    \     f = f + g\n        g = g + h\n        h = i == 1 and 1 or 0\n        p =\
    \ 2 * q + r\n        q = q + r\n        r = p\n        count = count + temp +\
    \ h + p\n        i = i + 1\n    end\n    return count\nend", "  if n == 1 then\n\
    \    return 1\n  end\n  return starts_one_ends(n - 1) + n - 1\nend", "  -- Counts\
    \ the number of n-digit positive integers that start with 1.\n  local function\
    \ starts_one(n)\n    if n == 1 then\n      return 10\n    else\n      return 9\
    \ * 9^(n - 1)\n    end\n  end", "  if n == 1 then\n    return 1\n  end\n  local\
    \ p = 1 -- 10^n - 1\n  for i = 1, n - 1 do\n    p = p * 10\n  end\n  p = p - 1\n\
    \  return 2 * p - 2 + starts_one_ends(n - 1)\nend", "  local count = 0\n  local\
    \ beg, _, m = 0, 1, 10\n  while beg < n do\n    local m = 10^beg\n    local end_\
    \ = n - beg\n    if end_ == 1 then\n      count = count + m\n    elseif end_ >\
    \ 1 then\n      count = count + m * (end_ - 1)\n    end\n    beg = beg + 1\n \
    \ end\n  return count\nend", "   local d = digits(n)\n   local c = power10(d -\
    \ 1)\n   if c > 0 then\n      return c - n + 1\n   else\n      return 0\n   end\n\
    end", "    if n == 1 then\n        return 2\n    end\n    return starts_one_ends(n\
    \ - 1) + starts_one_ends(n - 2)\nend", "  local counts = {1, 1}\n  for k = 2,\
    \ n do\n    table.insert(counts, counts[k - 1] + (counts[k - 2] * 8))\n  end\n\
    \  return counts[n]\nend", "    if n == 1 then\n        return 2\n    end\n  \
    \  return starts_one_ends(n - 1) + starts_one_ends(n - 2)\nend", "   local length\
    \ = 10 ^ (n - 1)\n   local sum = 0\n   for i = 0, n - 1 do\n      sum = sum +\
    \ math.floor(length / 10)\n   end\n   return sum\nend", "  -- Base case.\n  if\
    \ n == 1 then\n    return 2\n  end", "   if n == 1 then\n      return 2\n   else\n\
    \      local total = 0\n      for i = 2, n do\n         total = total + digit_choices(i\
    \ - 1) * digit_choices(n - i)\n      end\n      return total + starts_one_ends(n\
    \ - 1) + (digit_choices(n - 1) - 1)\n   end\nend", "   if n == 1 then\n      return\
    \ 2\n   else\n      return 11*starts_one_ends(n-1)\n   end\nend", "    if n ==\
    \ 1 then\n        return 2\n    end\n    if n == 2 then\n        return 3\n  \
    \  end\n    return starts_one_ends(n - 1) + starts_one_ends(n - 2)\nend", "  local\
    \ digits = math.ceil(n/2)\n  local lst = {}\n  for i = 1, 9 do\n    lst[i] = math.pow(10,\
    \ digits - 1)\n  end\n  if n % 2 == 1 then\n    for i = 1, 9 do\n      lst[i]\
    \ = lst[i] * 10\n    end\n  end\n  return sum(lst)\nend", "    if n < 0 then\n\
    \        return 0\n    elseif n == 0 then\n        return 1\n    else\n      \
    \  return starts_one_ends(n - 1) + starts_one_ends(n - 2)\n    end\nend", "  \
    \  local c = 0\n    for i = 1, n do\n        c = c + 9 * (10 ^ (i - 1))\n    end\n\
    \    return c\nend", "  local count = 1\n  local rest = n - 1\n  while rest >\
    \ 0 do\n    count = count * 10\n    rest = rest - 1\n  end\n  return count\nend",
  "  local count = 0\n  for i = math.pow(10, n - 1), math.pow(10, n) - 1 do\n    if\
    \ tostring(i):sub(1, 1) == '1' or tostring(i):sub(-1) == '1' then\n      count\
    \ = count + 1\n    end\n  end\n  return count\nend", "    return n + 9 * n - 1\n\
    end", "    local total = 1\n    local current = 1\n    local previous = 1\n  \
    \  for d = 2, n do\n        previous = current\n        current = total\n    \
    \    total = previous + current + 9*current\n    end\n    return total\nend",
  "    if n == 1 then\n        return 2\n    end\n    local counts = { [1] = 2 }\n\
    \    for i = 2, n do\n        counts[i] = counts[i - 1] * 5 + 1\n    end\n   \
    \ return counts[n]\nend", "  local ending_one = {\n    {1, 10},\n    {10, 100},\n\
    \    {55, 1000},\n    {220, 10000},\n    {715, 100000},\n    {2002, 1000000},\n\
    \    {5005, 10000000},\n    {11440, 100000000},\n    {24310, 1000000000},\n  \
    \  {48620, 10000000000},\n    {92378, 100000000000},\n    {167960, 1000000000000},\n\
    \    {293930, 10000000000000},\n    {497420, 100000000000000},\n    {817190, 1000000000000000},\n\
    \    {1307504, 10000000000000000},\n    {2042975, 100000000000000000},\n    {3178100,\
    \ 1000000000000000000},\n    {5142290, 10000000000000000000},\n    {8320400, 100000000000000000000},\n\
    \    {13462730, 1000000000000000000000},\n    {21783020, 10000000000000000000000},\n\
    \    {35245180, 100000000000000000000000},\n    {57028900, 1000000000000000000000000},\n\
    \    {92274665, 10000000000000000000000000},\n    {14930350, 100000000000000000000000000},\n\
    \    {24157820, 1000000000000000000000000000},\n    {39088170, 10000000000000000000000000000},\n\
    \    {63245986, 100000000000000000000000000000},\n    {102334160, 1000000000000000000000000000000},\n\
    \    {165580141, 10000000000000000000000000000000},\n    {267914296, 100000000000000000000000000000000},\n\
    \    {433494436, 1000000000000000000000000000000000},\n    {701408731, 10000000000000000000000000000000000},\n\
    \    {1134903171, 100000000000000000000000000000000000},\n    {1836311904, 1000000000000000000000000000000000000},\n\
    \    {2971215074, 10000000000000000000000000000000000000},\n    {4807526970, 100000000000000000000000000000000000000},\n\
    \    {7778742050, 1000000000000000000000000000000000000000},\n    {12586269020,\
    \ 10000000000000000000000000000000000000000},\n    {20365011075, 100000000000000000000000000000000000000000},\n\
    \    {32951280099, 1000000000000000000000000000000000000000000},\n    {53316291171,\
    \ 10000000000000000000000000000000000000000000},\n    {86267571273, 100000000000000000000000000000000000000000000},\n\
    \   ", "    return -- TODO\nend", "    -- Although this problem was marked as\
    \ \"easy\", it is very tricky.\n    --\n    -- Let's start with f(n) as a function\
    \ defined as the count of the numbers\n    -- of n-digit positive integers that\
    \ start or end with 1.\n    --\n    -- * f(1) = 1\n    -- * f(2) = 2\n    -- *\
    \ f(3) = 4\n    -- * f(4) = 7\n    -- * f(5) = 12\n    -- * f(6) = 20\n    --\
    \ * f(7) = 33\n    -- * f(8) = 54\n    -- * f(9) = 88\n    -- * f(10) = 143\n\
    \    --\n    -- Observe that as n increases, f(n) grows exponentially.\n    --\n\
    \    -- But that's not all.\n    --\n    -- Let's break down f(n) into two functions\
    \ f_starts(n) and f_ends(n).\n    -- * f_starts(n) is the count of the numbers\
    \ of n-digit positive integers\n    --   that start with 1.\n    -- * f_ends(n)\
    \ is the count of the numbers of n-digit positive integers\n    --   that end\
    \ with 1.\n    --\n    -- We know that\n    -- * f_starts(1) = 1\n    -- * f_ends(1)\
    \ = 1\n    --\n    -- Let's start with f_starts(n).\n    --\n    -- Consider the\
    \ following set of equations:\n    -- * f_starts(n + 1) = 9 * f_starts(n) + 10\
    \ ^ (n - 1)\n    --\n    -- It should be relatively easy to verify this.\n   \
    \ --\n    -- For example,\n    -- * f_starts(1) = 1\n    -- * f_starts(2) = 2\n\
    \    -- * f_starts(3) = 11\n    -- * f_starts(4) = 111\n    -- * f_starts(5) =\
    \ 1111\n    -- * f_starts(6) = 11111\n    -- * f_starts(7) = 111111\n    -- *\
    \ f_starts(8) = 111", "   local min = 10^(n-1) + 1\n   local max = 10^n - 1\n\
    \   local total = 0\n   while min <= max do\n      if min % 10 == 1 then\n   \
    \      total = total + 1\n      end\n      min = min + 1\n   end\n   return total\n\
    end", "  local count = 0\n  -- We can end in 1 for any number of digits.\n  count\
    \ = count + 9^(n-1)\n  -- We can start in 1 for any number of digits up to n-1.\n\
    \  count = count + 9^(n-1)\n  -- We can start and end in 1 for any number of digits\
    \ up to n-2.\n  count = count + 9^(n-2)\n  return count\nend", "   if n == 1 then\n\
    \      return 2\n   else\n      return starts_one_ends(n-1) + starts_one_ends(n-2)\n\
    \   end\nend", "    if n < 0 then\n        return 0\n    elseif n == 0 then\n\
    \        return 1\n    else\n        return n * 9 ^ n\n    end\nend", "  local\
    \ s = 10 ^ (n - 1)\n  local e = 10 ^ n - 1\n  local m = 10 ^ (n - 1) - 1\n  return\
    \ s + e - 2 * m\nend", "    local x = 0\n    local y = 0\n    local pow2 = math.floor(math.pow(2,\
    \ n - 1))\n    x = 2 * math.floor(pow2 / 2)\n    y = 2 * math.floor(pow2 / 2)\n\
    \    if n % 2 == 1 then\n        y = math.floor(pow2 / 2)\n    end\n    return\
    \ x + y\nend", "  local total, powers = 0, {}\n  for k = 1, n do\n    powers[k]\
    \ = 10 ^ (k - 1)\n  end\n  for i = 1, #powers do\n    total = total + 9 * powers[i]\n\
    \  end\n  return total\nend", "    local count = 0\n    for i = 0, n do\n    \
    \    count = count + math.pow(10, i)\n    end\n    return count\nend", "  local\
    \ str = \"1\" .. \"0\"^(n-1)\n  local count = 0\n  repeat\n    count = count +\
    \ 1\n    str = next_with_zero(str)\n  until str == \"1\"..\"0\"^(n-1)\n  return\
    \ count\nend", "  -- this is the number of n-digit positive integers that start\
    \ with 1\n  local digits_start_one = 0\n  if n == 1 then\n    return 2\n  else\n\
    \    -- add to digits_start_one the number of n-digit positive integers that start\
    \ with 1\n    digits_start_one = digits_start_one + math.pow(10, n - 1) - 1\n\
    \    -- add to digits_start_one the number of n-digit positive integers that start\
    \ with 2\n    digits_start_one = digits_start_one + math.pow(10, n - 1) - 1\n\
    \    -- add to digits_start_one the number of n-digit positive integers that start\
    \ with 3\n    digits_start_one = digits_start_one + math.pow(10, n - 1) - 1\n\
    \    -- add to digits_start_one the number of n-digit positive integers that start\
    \ with 4\n    digits_start_one = digits_start_one + math.pow(10, n - 1) - 1\n\
    \    -- add to digits_start_one the number of n-digit positive integers that start\
    \ with 5\n    digits_start_one = digits_start_one + math.pow(10, n - 1) - 1\n\
    \    -- add to digits_start_one the number of n-digit positive integers that start\
    \ with 6\n    digits_start_one = digits_start_one + math.pow(10, n - 1) - 1\n\
    \    -- add to digits_start_one the number of n-digit positive integers that start\
    \ with 7\n    digits_start_one = digits_start_one + math.pow(10, n - 1) - 1\n\
    \    -- add to digits_start_one the number of n-digit positive integers that start\
    \ with 8\n    digits_start_one = digits_start_one + math.pow(10, n - 1) - 1\n\
    \    -- add to digits_start_one the number of n-digit positive integers that start\
    \ with 9\n    digits_start_one = digits_start_one + math.pow(10, n - 1) - 1\n\
    \    -- add to digits_start_one the number of n-digit positive integers that start\
    \ with 1\n    digits_start_one =", "  return math.pow(10, n-1)\nend", "   if n\
    \ == 1 then\n      return 2\n   else\n      return 9 * starts_one_ends(n - 1)\n\
    \   end\nend", "    -- This is the worst line in the program, I'm sorry.\n   \
    \ -- The sum of the finite geometric series 0 + 10 + 100 + ... + 10^(n-1) is\n\
    \    -- 0 + 10^n - 1, where the -1 comes from the fact that 1 is included in the\n\
    \    -- series. The rest of the logic is straightforward.\n    local digits =\
    \ (10^n) - 1\n    return digits - starts_one_ends(n - 1)\nend", "  -- Base case.\n\
    \  if n == 1 then\n    return 2\n  end", "    if n == 1 then\n        return 2\n\
    \    end\n    if n == 2 then\n        return 4\n    end\n    local f_start, f_end\
    \ = 4, 4\n    for i = 3, n do\n        f_start, f_end = f_start + f_end, f_start\
    \ + 3 * f_end\n    end\n    return f_start + f_end\nend", "    -- For every number\
    \ that starts with 1, there are 10^(n-1) numbers of\n    -- length n that can\
    \ end with it. So the count of numbers starting with 1\n    -- is 10^(n-1)\n \
    \   local count = 10^(n-1)\n    -- Now, to count the number of numbers ending\
    \ with 1, we consider the\n    -- number of numbers of length i that end with\
    \ 1, for i = 1 to n-1.\n    -- For i = 1, there are 9*10^0 numbers of length 1\
    \ that end with 1,\n    -- and there are 9*10^(n-2) numbers of length n that end\
    \ with a number\n    -- of length 1 that ends with 1. So for each i = 1 to n-1,\
    \ there are\n    -- 9*10^(n-i-1) numbers of length n that end with a number of\
    \ length i\n    -- that ends with 1.\n    for i = 1, n-1 do\n        count = count\
    \ + 9*10^(n-i-1)\n    end\n    return count\nend", "  return count_start_one(n)\
    \ + count_end_one(n)\nend", "    -- If n is odd then the number of n-digit positive\
    \ integers that start\n    -- with 1 is equal to the number of n-digit positive\
    \ integers that end\n    -- with 1.\n    if n % 2 == 1 then\n        return 10^(n-1)\n\
    \    end", "    -- First let's find the number of n-digit numbers that start with\
    \ 1:\n    -- the number of the n-1-digit numbers that have all digits different\
    \ from 1\n    -- (because the first digit has to be 1).\n    -- And now let's\
    \ find the number of n-digit numbers that end with 1:\n    -- the number of the\
    \ n-1-digit numbers that have all digits different from 1\n    -- (because the\
    \ last digit has to be 1).\n    -- We can use `compositions` or `subsets` to find\
    \ the number of numbers.\n    return compositions(n - 1, 9) + subsets(n - 1, 9)\n\
    end", "    local digits = {}\n    for i = 1, n do\n        digits[i] = i ~= 1\
    \ and 1 or 2\n    end\n    return mathx.product(digits)\nend", "    local start\
    \ = 10 ^ (n - 1)\n    local end_  = start", "    if n == 1 then\n        return\
    \ 2\n    end\n    local prev = starts_one_ends(n - 1)\n    return 10 * prev -\
    \ prev / 9\nend", "    return {[0] = 1, [1] = 1, [2] = 101, [3] = 111, [4] = 1111,\
    \ [5] = 11111,\n            [6] = 111111, [7] = 1111111, [8] = 11111111, [9] =\
    \ 111111111,\n            [10] = 1111111111, [11] = 11111111111, [12] = 111111111111,\n\
    \            [13] = 1111111111111, [14] = 11111111111111, [15] = 111111111111111,\n\
    \            [16] = 1111111111111111, [17] = 11111111111111111,\n            [18]\
    \ = 111111111111111111, [19] = 1111111111111111111,\n            [20] = 11111111111111111111,\
    \ [21] = 111111111111111111111,\n            [22] = 1111111111111111111111, [23]\
    \ = 11111111111111111111111,\n            [24] = 111111111111111111111111, [25]\
    \ = 1111111111111111111111111,\n            [26] = 11111111111111111111111111,\n\
    \            [27] = 111111111111111111111111111,\n            [28] = 1111111111111111111111111111,\n\
    \            [29] = 11111111111111111111111111111,\n            [30] = 111111111111111111111111111111,\n\
    \            [31] = 1111111111111111111111111111111,\n            [32] = 11111111111111111111111111111111,\n\
    \            [33] = 111111111111111111111111111111111,\n            [34] = 1111111111111111111111111111111111,\n\
    \            [35] = 11111111111111111111111111111111111,\n            [36] = 111111111111111111111111111111111111,\n\
    \            [37] = 1111111111111111111111111111111111111,\n            [38] =\
    \ 11111111111111111111111111111111111111,\n            [39] = 111111111111111111111111111111111111111,\n\
    \            [40] = 1111111111111111111111111111111111111111,\n            [41]\
    \ = 11111111111111111111111111111111111111111,\n            [42] = 1111111", " \
    \  if n == 1 then\n      return 10\n   elseif n == 2 then\n      return 100\n\
    \   else\n      local count = starts_one_ends(n - 1) + 9 * starts_one_ends(n -\
    \ 2)\n      for i = 3, n do\n         count = count + 9 * starts_one_ends(n -\
    \ i)\n      end\n      return count\n   end\nend", "    if n == 1 then\n     \
    \   return 2\n    end\n    local t = {}\n    for i = 1, 9 do\n        t[i] = 2\
    \ * power(10, i - 1)\n    end\n    for i = 10, n do\n        local p = power(10,\
    \ i - 1)\n        local sum = 0\n        for j = 1, 9 do\n            sum = sum\
    \ + t[j]\n        end\n        t[i] = 9 * p - sum\n    end\n    return t[n]\n\
    end", "   assert(is_natural(n))\n   local x = 1\n   for i = 1, n - 1 do\n    \
    \  x = x * 10\n   end\n   return x * 9\nend", "    local count = 0\n    for i\
    \ = 0, 9 do\n        count = count + pow10[n - 1]\n    end\n    return count\n\
    end", "  if n == 1 then\n    return 1\n  end\n  local a, b = 2, 1\n  for i = 2,\
    \ n do\n    local ai, bi = a, b\n    a = a + 8 * b\n    b = ai + b\n  end\n  return\
    \ a + b\nend", "    if n == 1 then\n        return 2\n    end\n    if n == 2 then\n\
    \        return 10\n    end\n    local before = starts_one_ends(n - 1)\n    local\
    \ after = starts_one_ends(n - 2)\n    return before + 9 * after\nend", "    local\
    \ f =  factorial(n - 1)\n    local p = 10 ^ (n - 1)\n    return p + 9 * f\nend",
  "  if n == 1 then\n    return 2\n  end\n  if n == 2 then\n    return 11\n  end\n\
    \  local count = 10\n  for i = 1, n - 2 do\n    count = count + 10 ^ i\n  end\n\
    \  return count + 2\nend", "    if n == 1 then\n        return 2\n    end\n  \
    \  local sub_len = n - 1\n    local function count_sub(sub_len)\n        local\
    \ c1 = starts_one_ends(sub_len)\n        local c2 = starts_one_ends(sub_len -\
    \ 1)\n        return c1 * 10 - c2 * 9\n    end\n    local c1 = count_sub(sub_len)\n\
    \    local c2 = count_sub(sub_len - 1)\n    return c1 * 10 - c2 * 9\nend", " \
    \  if n == 1 then\n      return 2\n   else\n      return 9 * (10 ^ (n - 2)) +\
    \ starts_one_ends(n - 1)\n   end\nend", "  local sn = string.rep('1', n)\n  local\
    \ sum = tonumber(sn)", "  local function ends_one(l)\n    local result = 0\n \
    \   for i = 0, 9 do\n      result = result + l[i]\n    end\n    return result\n\
    \  end", "  -- The number of n-digit positive integers that start with 1 is the\
    \ same as\n  -- the number of (n-1)-digit positive integers that do not start\
    \ with 1.\n  -- The result is now a bit simpler to compute.\n  if n == 1 then\n\
    \    return 2\n  else\n    return 10 * starts_one_ends(n - 1) - starts_one_ends(n\
    \ - 2)\n  end\nend", "  if n == 1 then\n    return 2\n  end\n  local fn = starts_one_ends(n\
    \ - 1)\n  return fn + 9 * (10 ^ (n - 2))\nend", "  if n == 1 then\n    return\
    \ 2\n  end\n  local x = 1\n  local y = 9\n  local sum = 10\n  for i = 2, n do\n\
    \    x = x * 10\n    y = y * 10\n    sum = sum + x + y\n  end\n  return sum\n\
    end", "   assert(n > 0, \"Invalid number of digits: \" .. n)\n   if n == 1 then\n\
    \      return 2\n   end\n   if n == 2 then\n      return 9\n   end\n   return\
    \ math.pow(10, n - 1) + 9 * A(n - 1)\nend", "  local digits = {}\n  for i = 1,\
    \ n do\n    digits[i] = 1\n  end\n  local count = 0\n  local i = 1\n  repeat\n\
    \    digits[i] = digits[i] + 1\n    i = i + 1\n    while digits[i] > 9 do\n  \
    \    digits[i] = 1\n      i = i + 1\n    end\n    if i == n then\n      count\
    \ = count + 1\n    end\n  until i > n\n  return count\nend", "  if n == 1 then\n\
    \    return 1\n  end\n  local ones_cnt = (n - 1) * 10\n  local new_ones_cnt =\
    \ ones_cnt\n  if n == 2 then\n    new_ones_cnt = 10\n  end\n  return ones_cnt\
    \ + starts_one_ends(n - 1) + new_ones_cnt\nend", "   if n == 1 then\n      return\
    \ 2\n   else\n      return 9 * 10 ^ (n - 2) + starts_one_ends(n - 1)\n   end\n\
    end", '  local a, b, t, d = 1, 1, 2, 1', "    if n == 1 then\n        return 2\n\
    \    end\n    local nums = 0\n    for m = 1, n do\n        local lhs = 0\n   \
    \     for k = 1, m - 1 do\n            lhs = lhs + starts_one_ends(k)\n      \
    \  end\n        local rhs = 0\n        for k = 1, n - m do\n            rhs =\
    \ rhs + starts_one_ends(k)\n        end\n        nums = nums + lhs * rhs\n   \
    \ end\n    return nums\nend", "    -- We are essentially counting the number of\
    \ numbers starting with 1 and\n    -- ending with 2 or 3 plus the number of numbers\
    \ starting with 2 and ending\n    -- with 1 plus the number of numbers starting\
    \ with 3 and ending with 1. So\n    -- let's find the total number of numbers\
    \ for each scenario.\n    local ns12 = n_start_ends(n, 1, 2)\n    local ns13 =\
    \ n_start_ends(n, 1, 3)\n    local ns21 = n_start_ends(n, 2, 1)\n    local ns31\
    \ = n_start_ends(n, 3, 1)\n    return ns12 + ns13 + ns21 + ns31\nend", "    if\
    \ n == 1 then\n        return 2\n    end\n    return starts_one_ends(n - 1) +\
    \ num_one_ends(n - 1)\nend", "  if n == 1 then\n    return 2\n  end\n  return\
    \ 9 * starts_one_ends(n - 1) + 10 ^ (n - 1)\nend", "  if n == 1 then\n    return\
    \ 2\n  end\n  return 9 * starts_one_ends(n - 1)\nend", "    if n == 1 then\n \
    \       return 2\n    end\n    if n == 2 then\n        return 10\n    end\n  \
    \  local xs = {}\n    local ys = {}\n    for i = 1, n - 1 do\n        xs[i] =\
    \ i == 1 and 1 or 0\n        ys[i] = 0\n    end\n    xs[n] = xs[n-1]\n    ys[n]\
    \ = 1\n    for i = 1, n - 1 do\n        xs[i] = xs[i+1]\n        ys[i] = xs[i+1]\
    \ + ys[i+1]\n    end\n    return xs[1] + ys[1]\nend", "  -- Count the n-digit\
    \ numbers ending in 1.\n  local count = 10 ^ (n - 1)", "    return dp_cache[n\
    \ - 1] + dp_cache[n - 2]\nend", "    if n == 1 then\n        return 2\n    end\n\
    \    local start = {1, 1}\n    local ends = {1, 1}\n    for i = 3, n do\n    \
    \    local s_1 = start[1]\n        local s_2 = start[2]\n        local e_1 = ends[1]\n\
    \        local e_2 = ends[2]\n        start[1] = s_1 + s_2\n        start[2] =\
    \ s_1\n        ends[1] = e_1 + e_2\n        ends[2] = e_1\n    end\n    return\
    \ start[1] + start[2] + ends[1] + ends[2]\nend", "  local count = n == 1 and 2\
    \ or 10\n  local prev = 2\n  for i = 2, n - 1 do\n    count = count + (prev *\
    \ 10)\n    prev = prev * 10\n  end\n  return count\nend", "  local digits = {}\n\
    \  for k = 1,n do\n    digits[k] = 1\n  end\n  local s = 0\n  repeat\n    s =\
    \ s + 1\n    for k = n,2,-1 do\n      if digits[k] < 9 then\n        digits[k]\
    \ = digits[k] + 1\n        break\n      else\n        digits[k] = 1\n      end\n\
    \    end\n  until digits[1] == 1\n  return s\nend", "   if n < 1 then\n      return\
    \ 0\n   elseif n == 1 then\n      return 2\n   else\n      return 10*n - 3\n \
    \  end\nend", "  local total = 0\n  local tens = math.pow(10, n - 1)\n  local\
    \ ones = math.pow(10, n)\n  local i = 1\n  while i < tens do\n    total = total\
    \ + 1\n    i = i * 10\n  end\n  i = 1\n  while i < ones do\n    total = total\
    \ + 1\n    i = i * 10\n  end\n  return total\nend", "   if n < 2 then\n      return\
    \ 1\n   end\n   if n == 2 then\n      return 11\n   end\n   local e1 = starts_one_ends(n-1)\
    \ -- ends with 1\n   local s1 = starts_one_ends(n-2) -- starts with 1\n   local\
    \ e2 = starts_one_ends(n-2) -- ends with 2\n   local s2 = starts_one_ends(n-3)\
    \ -- starts with 2\n   local ends_ones = e1 + e2 -- ends with one, total\n   local\
    \ starts_ones = s1 + s2 -- starts with one, total\n   local ends_twos = (n-1)\
    \ * e1 -- ends with two, total\n   local starts_twos = (n-2) * s1 -- starts with\
    \ two, total\n   local total = 9 * (ends_ones + ends_twos + starts_ones + starts_twos)\n\
    \   -- 9 is the number of digits that can't be 1 or 2\n   return total\nend",
  "    -- starts_one_ends(n) = starts_one_ends(n-1) + ends_one_ends(n-1)\n    -- ends_one_ends(n)\
    \ = 9 * starts_one_ends(n-1)\n    -- solves to starts_one_ends(n) = 9 * starts_one_ends(n-1)\
    \ + starts_one_ends(n-1)\n    -- = (10 * starts_one_ends(n-1)) = 10 * starts_one_ends(n-1)\n\
    \    -- = 9 * starts_one_ends(n-1) + 1 * starts_one_ends(n-1)\n    -- = 10 * starts_one_ends(n-1)\n\
    \    -- starts_one_ends(n) = 10 * starts_one_ends(n-1)\n    -- starts_one_ends(1)\
    \ = 2\n    local total = 2\n    for i = 1, n-1 do\n        total = total * 10\n\
    \    end\n    return total\nend", "  local a, b = 0, 1\n  for i = 1, n - 1 do\n\
    \    a, b = b, a + b\n  end\n  return a + b\nend", "   local ten = 10^(n-1)\n\
    \   local c = 1\n   for i = 1, n-1 do\n      c = c * 9\n   end\n   return c *\
    \ 10\nend", "  local M = 3\n  for _ = 2, n - 1 do\n    M = 2 * M\n  end\n  return\
    \ M\nend", "   local res = 1\n   for i = 1, n-1 do\n      res = res * 9\n   end\n\
    \   return res\nend", "  if n == 1 then\n    return 1\n  end\n  local cnt = 0\n\
    \  for k = 1, n - 1 do\n    cnt = cnt + starts_one_ends(k) * starts_one_ends(n\
    \ - k)\n  end\n  return cnt + starts_one_ends(n - 1)\nend", "  if n < 1 then\n\
    \    return nil\n  end\n  if n == 1 then\n    return 1\n  end\n  local a = 1\n\
    \  local b = 10\n  local j = 10\n  for i = 1, n - 2 do\n    a = a + j\n    j =\
    \ j * 10\n  end\n  return a + b\nend", "    if n < 2 then\n        return 0\n\
    \    end\n    local result = n - 1\n    for _ = 1, n - 2 do\n        result =\
    \ result * (10 - 1)\n    end\n    return result\nend", "   if n == 1 then\n  \
    \    return 2\n   else\n      return 9*10^(n-2)\n   end\nend", "    if n < 1 then\n\
    \        return 0\n    end\n    local sum = 1\n    local prev_sum = 1\n    for\
    \ i = 2, n do\n        sum = prev_sum + sum\n        prev_sum = sum\n    end\n\
    \    return sum\nend", "    local ok = function(s)\n        return s:sub(1, 1)\
    \ == '1' or s:sub(-1) == '1'\n    end\n    return count_up_to(n, ok)\nend", " \
    \ local cache = {}\n  local function _starts_one_ends(n)\n    if n < 0 then\n\
    \      return 0\n    elseif n == 0 then\n      return 1\n    elseif cache[n] then\n\
    \      return cache[n]\n    else\n      cache[n] = starts_one_ends(n - 1) + starts_one_ends(n\
    \ - 2)\n      return cache[n]\n    end\n  end\n  return _starts_one_ends(n)\n\
    end", "  if n == 1 then\n    return 2\n  end\n  if n == 2 then\n    return 3\n\
    \  end\n  local start_n = 1\n  local end_n = 1\n  local start_n_1 = 1\n  local\
    \ end_n_1 = 1\n  for i = 3, n do\n    start_n = start_n + end_n_1\n    end_n =\
    \ start_n_1 + end_n_1\n    start_n_1 = start_n\n    end_n_1 = end_n\n  end\n \
    \ return start_n + end_n\nend", "  local res = 0\n  local t = {1}\n  for i = 1,\
    \ n - 1 do\n    local tmp = {}\n    for k, v in ipairs(t) do\n      if v ~= 0\
    \ then\n        if v > 0 then\n          tmp[k] = v * 10 + 1\n        else\n \
    \         tmp[k] = v * 10 - 1\n        end\n      end\n    end\n    res = res\
    \ + #t\n    for _, v in ipairs(t) do\n      if v > 0 then\n        tmp[#tmp +\
    \ 1] = v * 10\n      else\n        tmp[#tmp + 1] = v * 10 + 1\n      end\n   \
    \ end\n    t = tmp\n  end\n  return res + #t\nend", "   assert(n > 0)\n   return\
    \ 2 * starts_one_ends(n - 1) + math.pow(10, n - 1)\nend", "   if n == 1 then\n\
    \      return 2\n   else\n      return starts_one_ends(n-1) + 9*starts_one_ends(n-2)\n\
    \   end\nend", "    if n == 1 then\n        return 2\n    end\n    local memo\
    \ = {}\n    local function count(n)\n        if n == 1 then\n            return\
    \ 2\n        end\n        if n == 2 then\n            return 3\n        end\n\
    \        if memo[n] then\n            return memo[n]\n        end\n        local\
    \ result = count(n - 1) + count(n - 2)\n        memo[n] = result\n        return\
    \ result\n    end\n    return count(n)\nend", "    local n_digit_ones = n\n  \
    \  local n_digit_ends_with_one = 1", "  -- Base case:\n  if n == 1 then\n    return\
    \ 2\n  end", "    if n == 1 then\n        return 3\n    end\n    return starts_one_ends(n\
    \ - 1) + tens_ends(n - 1)\nend", "  local c = 0\n  for i = 1, 9 do\n    c = c\
    \ + f(n - 1)\n  end\n  c = c + math.pow(10, n - 1)\n  return c\nend", "    if\
    \ n == 1 then\n        return 2\n    end\n    local d, k = 0, n - 1\n    local\
    \ x = 1\n    while k > 0 do\n        d = d + x\n        x = x * 9\n        k =\
    \ k - 1\n    end\n    return d + x\nend", "  return 10^(n-1)\nend", "  return\
    \ starts_one(n) + ends_one(n)\nend", "  if n == 1 then\n    return 1\n  end\n\
    \  local first_digits = 1\n  local last_digits = 1\n  local r = (n - 1) * 9\n\
    \  local i = 1\n  while i < n - 1 do\n    first_digits = first_digits * 10\n \
    \   last_digits = last_digits * 10\n    r = r + first_digits + last_digits\n \
    \   i = i + 1\n  end\n  return r\nend", "    if n == 1 then\n        return 2\n\
    \    end\n    local counts = {\n        [1] = 10\n    }\n    for i = 2, n do\n\
    \        counts[i] = (counts[i - 1] * 9) + counts[i - 1]\n    end\n    return\
    \ counts[n]\nend", "  -- subtraction of n=1 to n=2 cases\n  if n == 1 then\n \
    \   return 2\n  elseif n == 2 then\n    return 12\n  end\n  -- all other cases\n\
    \  return math.pow(10, n-1) + starts_one_ends(n-1)\nend", "    local function\
    \ starts_ends(n)\n        if n == 1 then\n            return 1\n        else\n\
    \            return 2 * starts_ends(n - 1)\n        end\n    end\n    if n ==\
    \ 1 then\n        return 1\n    else\n        return starts_ends(n - 1) + starts_one_ends(n\
    \ - 1)\n    end\nend", "   if n == 1 then\n      return 10\n   elseif n == 2 then\n\
    \      return 20\n   else\n      local result = 18\n      local start_one = 9\n\
    \      local end_one = 9\n      for i = 3, n do\n         result = result + start_one\
    \ + end_one\n         start_one = start_one + 9\n         end_one = end_one +\
    \ 9\n      end\n      return result\n   end\nend", "  if n == 1 then\n    return\
    \ 2\n  end\n  local dp = {0, 9, 0}\n  for i = 3, n + 1 do\n    dp[i] = 10 * dp[i\
    \ - 1] - dp[i - 2]\n  end\n  return dp[n + 1]\nend", "  local min = math.pow(10,\
    \ n - 1) + 1\n  local max = math.pow(10, n) - 1\n  return math.floor(max / 10)\
    \ - math.floor(min / 10) + 1\nend", "  local f = {[0] = 1, [1] = 1}\n  local t\
    \ = {[0] = 1, [1] = 1}\n  for i = 2, n do\n    f[i] = f[i - 1] + t[i - 1]\n  \
    \  t[i] = f[i - 1]\n  end\n  return f[n] + t[n]\nend", "   if n == 1 then\n  \
    \    return 2\n   else\n      local two_n_1 = 2^(n-1)\n      return two_n_1 +\
    \ two_n_1 - 2\n   end\nend", "   if n == 1 then\n      return 1\n   elseif n ==\
    \ 2 then\n      return 21\n   else\n      return 20 * n - 10\n   end\nend", " \
    \   if n == 1 then\n        return 2\n    end\n    if n == 2 then\n        return\
    \ 4\n    end\n    return starts_one_ends(n - 1) + starts_one_ends(n - 2)\nend",
  "  if n == 1 then\n    return 2\n  end\n  if n == 2 then\n    return 3\n  end\n\
    \  return starts_one_ends(n - 1) + starts_one_ends(n - 2)\nend", "    if n ==\
    \ 1 then\n        return 2\n    end\n    local function count(n, top, bottom)\n\
    \        if n == 1 then\n            return 2\n        end\n        if n == 2\
    \ then\n            return bottom + top\n        end\n        return count(n -\
    \ 1, top, bottom) + count(n - 2, top, bottom) * (9 - bottom)\n    end\n    return\
    \ count(n, 1, 1)\nend", "  if n == 1 then\n    return 2\n  end\n  local r = 9\
    \ * starts_one_ends(n - 1)\n  return r\nend", "    if n == 1 then\n        return\
    \ 2\n    end\n    if n == 2 then\n        return 4\n    end\n    local t = {1,\
    \ 2, 4}\n    for i = 3, n do\n        t[i] = t[i - 1] + t[i - 2] + t[i - 3]\n\
    \    end\n    return t[n]\nend", "  if n == 1 then\n    return 1\n  end\n  return\
    \ 2 * (10 ^ (n - 1)) - 1\nend", "  local ends_one = 0\n  for i = 1, n do\n   \
    \ ends_one = ends_one + math.pow(10, i - 1)\n  end\n  local starts_one = math.pow(10,\
    \ n - 1)\n  return starts_one + ends_one\nend", "  if n == 1 then\n    return\
    \ 2\n  end\n  local count = 1\n  -- The first digit can only be 1.\n  -- If the\
    \ first digit is 1, then the last digit can be 1 or 9.\n  -- If the first digit\
    \ is 1, then the last digit is 9, then there are\n  -- 9 other digits that can\
    \ be any of 0-9.\n  -- If the first digit is 1, then the last digit is 1, then\
    \ there are\n  -- 9 other digits that can be any of 0-9 except 1.\n  -- Otherwise,\
    \ the first digit can be 0-9 and the last digit can be 1 or 9.\n  -- If the last\
    \ digit is 9, then there are n-2 other digits that can be any\n  -- of 0-9.\n\
    \  -- If the last digit is 1, then there are n-2 other digits that can be any\n\
    \  -- of 0-9 except 1.\n  count = count + 9*starts_one_ends(n-1)\n  count = count\
    \ + 9*(starts_one_ends(n-2))\n  return count\nend", "  if n == 1 then\n    return\
    \ 1\n  end\n  return starts_one_ends(n - 1) + 9 * fb_starts_ends(n - 1)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
