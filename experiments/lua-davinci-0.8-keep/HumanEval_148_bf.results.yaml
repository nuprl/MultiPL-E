name: HumanEval_148_bf
language: lua
results:
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  a = {}\n  for k,v in pairs(planets)\
    \ do\n    if v == planet1 then\n      b = k\n    end\n    if v == planet2 then\n\
    \      c = k\n    end\n  end\n  if b == nil or c == nil then\n    return {}\n\
    \  end\n  if b > c then\n    return {}\n  end\n  if b == c then\n    return {planet1}\n\
    \  end\n  if b < c then\n    for i = b+1, c do\n      table.insert(a, planets[i])\n\
    \    end\n    return a\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuxzg893m.lua:45:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Saturn\", \"Uranus\", \"Neptune\"\
    }\nstack traceback:\n\t/tmp/tmpuxzg893m.lua:45: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local r = {}\n\
    \  local i1, i2 = 0,0\n  for i = 1, #planets do\n    if planets[i] == planet1\
    \ then i1 = i end\n    if planets[i] == planet2 then i2 = i end\n  end\n  if i1\
    \ == 0 or i2 == 0 then return {} end\n  if i1 > i2 then\n    for i = i2+1, i1-1\
    \ do r[#r+1] = planets[i] end\n  else\n    for i = i1+1, i2-1 do r[#r+1] = planets[i]\
    \ end\n  end\n  return r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planet_idx = {\n    Mercury = 1,\n    Venus =\
    \ 2,\n    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  if planet_idx[planet1]\
    \ == nil or planet_idx[planet2] == nil then return {} end\n  local start, stop\
    \ = planet_idx[planet1], planet_idx[planet2]\n  if start > stop then start, stop\
    \ = stop, start end\n  local arr = {}\n  for i = start + 1, stop - 1 do\n    table.insert(arr,\
    \ planets[i])\n  end\n  return arr\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal t = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal planets = {}\n\t\
    local p1, p2 = nil, nil\n\tlocal j = 0\n\tfor i, v in ipairs(t) do\n\t\tif v ==\
    \ planet1 then\n\t\t\tp1 = i\n\t\tend\n\t\tif v == planet2 then\n\t\t\tp2 = i\n\
    \t\tend\n\tend\n\tif p1 == nil or p2 == nil then\n\t\treturn {}\n\tend\n\tif p1\
    \ < p2 then\n\t\tfor i = p1 + 1, p2 do\n\t\t\tj = j + 1\n\t\t\tplanets[j] = t[i]\n\
    \t\tend\n\tend\n\tif p1 > p2 then\n\t\tfor i = p2 + 1, p1 do\n\t\t\tj = j + 1\n\
    \t\t\tplanets[j] = t[i]\n\t\tend\n\tend\n\treturn planets\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpuwbs1dyk.lua:48:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Saturn\", \"Uranus\", \"Neptune\"\
    }\nstack traceback:\n\t/tmp/tmpuwbs1dyk.lua:48: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local t = {}\n\
    \  local p1 = planets:indexOf(planet1)\n  local p2 = planets:indexOf(planet2)\n\
    \  if p1 then\n    for i = p1, p2 do\n      if i ~= p1 and i ~= p2 then\n    \
    \    t:append(planets[i])\n      end\n    end\n  end\n  return t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6g_lgnnj.lua:17:\
    \ attempt to call a nil value (method 'indexOf')\nstack traceback:\n\t/tmp/tmp6g_lgnnj.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmp6g_lgnnj.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local sol = { Mercury = 1, Venus = 2, Earth = 3, Mars\
    \ = 4, Jupiter = 5, Saturn = 6, Uranus = 7, Neptune = 8 }\n  local planet1, planet2\
    \ = sol[planet1], sol[planet2]\n  if not planet1 or not planet2 then return {}\
    \ end\n  local planets = {}\n  for k, v in pairs(sol) do\n    if v >= planet1\
    \ and v <= planet2 then table.insert(planets, k) end\n  end\n  return planets\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1kilqspj.lua:28:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\nstack traceback:\n\t/tmp/tmp1kilqspj.lua:28: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local orbit = {'Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n    local planets = {}\n    local\
    \ first = 0\n    local second = 0\n    for i, v in ipairs(orbit) do\n        if\
    \ planet1 == v then\n            first = i\n        end\n        if planet2 ==\
    \ v then\n            second = i\n        end\n    end\n    if first == 0 or second\
    \ == 0 then\n        return {}\n    end\n    if first < second then\n        for\
    \ i = first + 1, second - 1 do\n            table.insert(planets, orbit[i])\n\
    \        end\n    else\n        for i = second + 1, first - 1 do\n           \
    \ table.insert(planets, orbit[i])\n        end\n    end\n    return planets\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local res =\
    \ {}\n    for i, v in ipairs(planets) do\n        if v == planet1 then \n    \
    \        for j = i, #planets do\n                if planets[j] == planet2 then\n\
    \                    for k = i, j do\n                        table.insert(res,\
    \ planets[k])\n                    end\n                    return res\n     \
    \           end\n            end\n        end\n    end\n    return {}\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n  \
    \  lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n  \
    \  lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfs6w6lce.lua:35:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\nstack traceback:\n\t/tmp/tmpfs6w6lce.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  \n  -- Your code here\n  if planet1 == \"Mercury\" then\
    \ planet1 = 1\n  elseif planet1 == \"Venus\" then planet1 = 2\n  elseif planet1\
    \ == \"Earth\" then planet1 = 3\n  elseif planet1 == \"Mars\" then planet1 = 4\n\
    \  elseif planet1 == \"Jupiter\" then planet1 = 5\n  elseif planet1 == \"Saturn\"\
    \ then planet1 = 6\n  elseif planet1 == \"Uranus\" then planet1 = 7\n  elseif\
    \ planet1 == \"Neptune\" then planet1 = 8\n  else planet1 = nil end\n  \n  if\
    \ planet2 == \"Mercury\" then planet2 = 1\n  elseif planet2 == \"Venus\" then\
    \ planet2 = 2\n  elseif planet2 == \"Earth\" then planet2 = 3\n  elseif planet2\
    \ == \"Mars\" then planet2 = 4\n  elseif planet2 == \"Jupiter\" then planet2 =\
    \ 5\n  elseif planet2 == \"Saturn\" then planet2 = 6\n  elseif planet2 == \"Uranus\"\
    \ then planet2 = 7\n  elseif planet2 == \"Neptune\" then planet2 = 8\n  else planet2\
    \ = nil end\n  \n  if planet1 == nil or planet2 == nil then return {} end\n  \n\
    \  local array = {}\n  if planet1 > planet2 then \n    for i = planet2, planet1\
    \ - 1 do\n      if i == 1 then array[#array + 1] = \"Mercury\"\n      elseif i\
    \ == 2 then array[#array + 1] = \"Venus\"\n      elseif i == 3 then array[#array\
    \ + 1] = \"Earth\"\n      elseif i == 4 then array[#array + 1] = \"Mars\"\n  \
    \    elseif i == 5 then array[#array + 1] = \"Jupiter\"\n      elseif i == 6 then\
    \ array[#array + 1] = \"Saturn\"\n      elseif i == 7 then array[#array + 1] =\
    \ \"Uranus\"\n      elseif i == 8 then array[#array + 1] = \"Neptune\" end\n \
    \   end\n  else\n    for i = planet1, planet2 - 1 do\n      if i\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpiwkgkp_r.lua:54: 'then' expected near 'lu'\n"
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local idx1, idx2\
    \ = 0, 0\n  for i = 1, #planets do\n    if planets[i] == planet1 then idx1 = i\
    \ end\n    if planets[i] == planet2 then idx2 = i end\n  end\n  if idx1 == 0 or\
    \ idx2 == 0 then return {} end\n  local t = {}\n  for i = math.min(idx1, idx2)\
    \ + 1, math.max(idx1, idx2) - 1 do\n    table.insert(t, planets[i])\n  end\n \
    \ return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local order = {\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local start, stop\
    \ = 1, #order\n  for i = 1, #order do\n    if order[i] == planet1 then\n     \
    \ start = i\n    end\n    if order[i] == planet2 then\n      stop = i\n    end\n\
    \  end\n  if start == 1 or stop == #order then\n    return {}\n  end\n  local\
    \ t = {}\n  for i = start + 1, stop - 1 do\n    t[#t + 1] = order[i]\n  end\n\
    \  return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsxwpk48w.lua:38:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpsxwpk48w.lua:38:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\n        \"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    }\n\
    \    local index1, index2\n    for i, p in ipairs(planets) do\n        if p ==\
    \ planet1 then\n            index1 = i\n        end\n        if p == planet2 then\n\
    \            index2 = i\n        end\n    end\n    if not index1 or not index2\
    \ then\n        return {}\n    end\n    if index1 < index2 then\n        return\
    \ {unpack(planets, index1 + 1, index2 - 1)}\n    else\n        return {unpack(planets,\
    \ index2 + 1, index1 - 1)}\n    end\nend\nassert_eq({unpack(bf(\"Jupiter\", \"\
    Neptune\"))}, {\"Saturn\", \"Uranus\"})\nassert_eq({unpack(bf(\"Earth\", \"Mercury\"\
    ))}, {\"Venus\"})\nassert_eq({unpack(bf(\"Mercury\", \"Uranus\"))}, {\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"})\nassert_eq({unpack(bf(\"Venus\"\
    , \"Saturn\"))}, {\"Earth\", \"Mars\", \"Jupiter\"})\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmplvw76sjb.lua:31: attempt to call a nil value (global 'unpack')\n\
    stack traceback:\n\t/tmp/tmplvw76sjb.lua:31: in local 'bf'\n\t/tmp/tmplvw76sjb.lua:36:\
    \ in main chunk\n\t[C]: in ?\n"
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local solarsystem\
    \ = {}\n  local start = nil\n  local ending = nil\n  for i = 1, #planets do\n\
    \    if planets[i] == planet1 then start = i end\n    if planets[i] == planet2\
    \ then ending = i end\n  end\n  if start == nil or ending == nil then return {}\
    \ end\n  local i = start\n  while i ~= ending do\n    i = i + (start > ending\
    \ and -1 or 1)\n    table.insert(solarsystem, planets[i])\n  end\n  return solarsystem\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8h96x77c.lua:35:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Saturn\", \"Uranus\", \"Neptune\"\
    }\nstack traceback:\n\t/tmp/tmp8h96x77c.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- your code here\n  local planets={Mercury=1,Venus=2,Earth=3,Mars=4,Jupiter=5,Saturn=6,Uranus=7,Neptune=8}\n\
    \  local ret_val={}\n  local p1,p2\n  if planets[planet1] and planets[planet2]\
    \ then\n    p1=planets[planet1]\n    p2=planets[planet2]\n    if p1>p2 then\n\
    \      p1,p2=p2,p1\n    end\n    for k,v in pairs(planets) do\n      if v>p1 and\
    \ v<p2 then\n        table.insert(ret_val,k)\n      end\n    end\n  end\n  return\
    \ table.unpack(ret_val)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp9voj8dg.lua:37:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: \"Uranus\"\nstack traceback:\n\t\
    /tmp/tmpp9voj8dg.lua:37: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local start,\
    \ stop = 0, 0\n    for i, planet in ipairs(planets) do\n        if planet == planet1\
    \ then\n            start = i\n        end\n        if planet == planet2 then\n\
    \            stop = i\n        end\n    end\n    local res = {}\n    for i = start\
    \ + 1, stop - 1 do\n        table.insert(res, planets[i])\n    end\n    return\
    \ unpack(res)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpu9ua9fgj.lua:29:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpu9ua9fgj.lua:29:\
    \ in local 'candidate'\n\t/tmp/tmpu9ua9fgj.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local orbits = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local result\
    \ = {}\n    for i = 1, #orbits do\n        if orbits[i] == planet1 then\n    \
    \        for j = i, #orbits do\n                if orbits[j] == planet2 then\n\
    \                    for k = i, j do\n                        table.insert(result,\
    \ orbits[k])\n                    end\n                    return result\n   \
    \             end\n            end\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyn4ua1dc.lua:35:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\nstack traceback:\n\t/tmp/tmpyn4ua1dc.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local min =\
    \ 0\n    local max = 0\n    local result = {}\n    for i = 1, #planets do\n  \
    \      if planet1 == planets[i] then\n            min = i\n        end\n     \
    \   if planet2 == planets[i] then\n            max = i\n        end\n    end\n\
    \    if min > max then\n        for i = max + 1, min - 1 do\n            table.insert(result,\
    \ planets[i])\n        end\n    else\n        for i = min + 1, max - 1 do\n  \
    \          table.insert(result, planets[i])\n        end\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7_zhtqh8.lua:48:\
    \ expected: {}\nactual: {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"}\nstack traceback:\n\
    \t/tmp/tmp7_zhtqh8.lua:48: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n   local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n   local pos1,\
    \ pos2 = planets[planet1], planets[planet2]\n   if not pos1 or not pos2 then return\
    \ {} end\n   pos1, pos2 = math.min(pos1, pos2), math.max(pos1, pos2)\n   local\
    \ res = {}\n   for i = pos1 + 1, pos2 - 1 do\n      table.insert(res, planets[i])\n\
    \   end\n   return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsttr2nmi.lua:29:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpsttr2nmi.lua:29:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planet_table = {'Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n\tlocal start, finish = -1, -1\n\t\
    for i, planet in ipairs(planet_table) do\n\t\tif planet == planet1 then\n\t\t\t\
    start = i\n\t\tend\n\t\tif planet == planet2 then\n\t\t\tfinish = i\n\t\tend\n\
    \tend\n\tif start ~= -1 and finish ~= -1 then\n\t\tlocal ret_table = {}\n\t\t\
    for i = start + 1, finish - 1 do\n\t\t\ttable.insert(ret_table, planet_table[i])\n\
    \t\tend\n\t\treturn unpack(ret_table)\n\telse\n\t\treturn nil\n\tend\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n  \
    \  lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n  \
    \  lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpy5v5mp45.lua:30:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpy5v5mp45.lua:30:\
    \ in local 'candidate'\n\t/tmp/tmpy5v5mp45.lua:39: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal solar_system = {\n\t\t[\"Mercury\"] = 1,\n\t\t\
    [\"Venus\"] = 2,\n\t\t[\"Earth\"] = 3,\n\t\t[\"Mars\"] = 4,\n\t\t[\"Jupiter\"\
    ] = 5,\n\t\t[\"Saturn\"] = 6,\n\t\t[\"Uranus\"] = 7,\n\t\t[\"Neptune\"] = 8\n\t\
    }\n\tif solar_system[planet1] == nil or solar_system[planet2] == nil then\n\t\t\
    return {}\n\tend\n\tlocal result = {}\n\tlocal i\n\tif solar_system[planet1] <\
    \ solar_system[planet2] then\n\t\tfor i = solar_system[planet1] + 1, solar_system[planet2]\
    \ - 1 do\n\t\t\ttable.insert(result, get_key(solar_system, i))\n\t\tend\n\telse\n\
    \t\tfor i = solar_system[planet2] + 1, solar_system[planet1] - 1 do\n\t\t\ttable.insert(result,\
    \ get_key(solar_system, i))\n\t\tend\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpssc91poz.lua:32:\
    \ attempt to call a nil value (global 'get_key')\nstack traceback:\n\t/tmp/tmpssc91poz.lua:32:\
    \ in local 'candidate'\n\t/tmp/tmpssc91poz.lua:45: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n   if planet1 and planet2 then\n      local planets =\
    \ {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n      local position1 = 0\n      local position2 = 0\n      for\
    \ i = 1, #planets do\n         if planets[i] == planet1 then\n            position1\
    \ = i\n         end\n         if planets[i] == planet2 then\n            position2\
    \ = i\n         end\n      end\n      if position1 ~= 0 and position2 ~= 0 then\n\
    \         local min = math.min(position1, position2)\n         local max = math.max(position1,\
    \ position2)\n         local result = {}\n         for i = min + 1, max - 1 do\n\
    \            table.insert(result, planets[i])\n         end\n         return unpack(result)\n\
    \      end\n   end\n   return\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmphhruy5ft.lua:34:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmphhruy5ft.lua:34:\
    \ in local 'candidate'\n\t/tmp/tmphhruy5ft.lua:43: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {'Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n\tlocal r = {}\n\tlocal p1, p2 =\
    \ table.find(planets, planet1), table.find(planets, planet2)\n\tif not p1 or not\
    \ p2 then return {} end\n\tfor i=p1, p2 do\n\t\ttable.insert(r, planets[i])\n\t\
    end\n\treturn r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpzh8k8_wa.lua:17:\
    \ attempt to call a nil value (field 'find')\nstack traceback:\n\t/tmp/tmpzh8k8_wa.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmpzh8k8_wa.lua:28: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal f = function(a,\
    \ b)\n\t\treturn planets[a] == planet1 and planets[b] == planet2\n\tend\n\tif\
    \ (planet1 == planet2) then\n\t\treturn {}\n\telseif (not(f(1, 4) or f(1, 7) or\
    \ f(2, 3) or f(2, 4) or f(3, 2) or f(3, 4) or f(4, 1) or f(4, 2) or f(4, 3) or\
    \ f(5, 7) or f(6, 6) or f(7, 1) or f(7, 5))) then\n\t\treturn {}\n\telse\n\t\t\
    local s = false\n\t\tlocal p = {}\n\t\tfor i = 1, #planets do\n\t\t\tif (planets[i]\
    \ == planet1) then\n\t\t\t\ts = true\n\t\t\tend\n\t\t\tif (s and planets[i] ~=\
    \ planet2) then\n\t\t\t\ttable.insert(p, planets[i])\n\t\t\tend\n\t\t\tif (planets[i]\
    \ == planet2) then\n\t\t\t\ts = false\n\t\t\tend\n\t\tend\n\t\treturn p\n\tend\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw7k2wnwa.lua:44:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpw7k2wnwa.lua:44:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local order = {'Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n    local left, right = 0, 0\n  \
    \  for i = 1, #order do\n        if order[i] == planet1 then\n            left\
    \ = i\n        end\n        if order[i] == planet2 then\n            right = i\n\
    \        end\n    end\n    if left == 0 or right == 0 then\n        return {}\n\
    \    end\n    local res = {}\n    if left < right then\n        for i = left +\
    \ 1, right - 1 do\n            table.insert(res, order[i])\n        end\n    else\n\
    \        for i = right + 1, left - 1 do\n            table.insert(res, order[i])\n\
    \        end\n    end\n    return res\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal solarSystem = {\n\t\t\"Mercury\", \"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n\t}\n\tlocal\
    \ index1, index2\n\tfor i, v in ipairs(solarSystem) do\n\t\tif v == planet1 then\n\
    \t\t\tindex1 = i\n\t\telseif v == planet2 then\n\t\t\tindex2 = i\n\t\tend\n\t\
    end\n\tif not index1 or not index2 then\n\t\treturn {}\n\tend\n\tif index1 > index2\
    \ then\n\t\tindex1, index2 = index2, index1\n\tend\n\tlocal toReturn = {}\n\t\
    for i = index1 + 1, index2 - 1 do\n\t\ttable.insert(toReturn, solarSystem[i])\n\
    \tend\n\treturn table.unpack(toReturn)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpar79ovnx.lua:42:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: \"Saturn\"\nstack traceback:\n\t\
    /tmp/tmpar79ovnx.lua:42: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local orb_planets = { Mercury = 0, Venus = 1, Earth\
    \ = 2, Mars = 3, \n                          Jupiter = 4, Saturn = 5, Uranus =\
    \ 6, Neptune = 7 }\n    local planet1_orb = orb_planets[planet1]\n    local planet2_orb\
    \ = orb_planets[planet2]\n    if planet1_orb and planet2_orb then\n        if\
    \ planet1_orb < planet2_orb then\n            local t = {}\n            for k,\
    \ v in pairs(orb_planets) do\n                if v > planet1_orb and v < planet2_orb\
    \ then\n                    table.insert(t, k)\n                end\n        \
    \    end\n            return unpack(t)\n        else\n            local t = {}\n\
    \            for k, v in pairs(orb_planets) do\n                if v < planet1_orb\
    \ and v > planet2_orb then\n                    table.insert(t, k)\n         \
    \       end\n            end\n            return unpack(t)\n        end\n    else\n\
    \        return unpack{}\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp9e58xz6w.lua:27:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmp9e58xz6w.lua:27:\
    \ in local 'candidate'\n\t/tmp/tmp9e58xz6w.lua:45: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local find =\
    \ function(planet)\n    for i, v in ipairs(planets) do\n      if v == planet then\n\
    \        return i\n      end\n    end\n    return 0\n  end\n  local p1 = find(planet1)\n\
    \  local p2 = find(planet2)\n  if p1 == 0 or p2 == 0 then\n    return {}\n  end\n\
    \  if p1 > p2 then\n    p1, p2 = p2, p1\n  end\n  local result = {}\n  for i =\
    \ p1 + 1, p2 - 1 do\n    table.insert(result, planets[i])\n  end\n  return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\n        \"Mercury\",\n        \"\
    Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n      \
    \  \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\n    }\n    if planet1\
    \ == planet2 then\n        return {planet1}\n    end\n    local l1, l2 = table.find(planets,\
    \ planet1), table.find(planets, planet2)\n    if not l1 or not l2 then\n     \
    \   return {}\n    end\n    if l1 < l2 then\n        return table.slice(planets,\
    \ l1 + 1, l2)\n    else\n        return table.slice(planets, l2 + 1, l1)\n   \
    \ end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpmqqrhtnl.lua:28:\
    \ attempt to call a nil value (field 'find')\nstack traceback:\n\t/tmp/tmpmqqrhtnl.lua:28:\
    \ in local 'candidate'\n\t/tmp/tmpmqqrhtnl.lua:42: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal istart,\
    \ iend\n\tfor i, p in ipairs(planets) do\n\t\tif p == planet1 then istart = i\
    \ end\n\t\tif p == planet2 then iend = i end\n\tend\n\tif istart == nil or iend\
    \ == nil then return {} end\n\tlocal res = {}\n\tfor i = math.min(istart, iend)\
    \ + 1, math.max(istart, iend) - 1 do\n\t\ttable.insert(res, planets[i])\n\tend\n\
    \treturn res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- your code here\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8r240etr.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmp8r240etr.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal p1 = table.indexof(planets,\
    \ planet1)\n\tlocal p2 = table.indexof(planets, planet2)\n\tif not p1 or not p2\
    \ then return {} end\n\tif p1 < p2 then\n\t\tlocal r = {}\n\t\tfor i = p1+1, p2-1\
    \ do\n\t\t\ttable.insert(r, planets[i])\n\t\tend\n\t\treturn r\n\telse\n\t\tlocal\
    \ r = {}\n\t\tfor i = p2+1, p1-1 do\n\t\t\ttable.insert(r, planets[i])\n\t\tend\n\
    \t\treturn r\n\tend\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpaarp2fux.lua:16:\
    \ attempt to call a nil value (field 'indexof')\nstack traceback:\n\t/tmp/tmpaarp2fux.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpaarp2fux.lua:37: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = { \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" }\n\tlocal i1, i2,\
    \ res = 0, 0, {}\n\tfor i, v in ipairs(planets) do\n\t\tif planet1 == v then i1\
    \ = i end\n\t\tif planet2 == v then i2 = i end\n\tend\n\tif i1 == 0 or i2 == 0\
    \ then return {} end\n\tif i1 > i2 then\n\t\tfor i = i2, i1 do\n\t\t\ttable.insert(res,\
    \ planets[i])\n\t\tend\n\telse\n\t\tfor i = i1, i2 do\n\t\t\ttable.insert(res,\
    \ planets[i])\n\t\tend\n\tend\n\treturn res\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0vc75qlv.lua:37:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\nstack traceback:\n\t/tmp/tmp0vc75qlv.lua:37: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprxairwnl.lua:20:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmprxairwnl.lua:20:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    'Mercury',\n    'Venus',\n  \
    \  'Earth',\n    'Mars',\n    'Jupiter',\n    'Saturn',\n    'Uranus',\n    'Neptune'\n\
    \  }\n  local p1, p2 = -1, -1\n  for i = 1, 8 do\n    if planets[i] == planet1\
    \ then\n      p1 = i\n    end\n    if planets[i] == planet2 then\n      p2 = i\n\
    \    end\n  end\n  if p1 == -1 or p2 == -1 then\n    return {}\n  end\n  local\
    \ p = {}\n  for i = p1, p2 do\n    table.insert(p, planets[i])\n  end\n  for i\
    \ = p2, p1 do\n    table.insert(p, planets[i])\n  end\n  return p\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6ayvvabg.lua:50:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\nstack traceback:\n\t/tmp/tmp6ayvvabg.lua:50: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local planet1_index\
    \ = planets:indexOf(planet1)\n    local planet2_index = planets:indexOf(planet2)\n\
    \    if planet1_index < 1 or planet2_index < 1 then\n        return {}\n    end\n\
    \    if planet1_index > planet2_index then\n        planet1_index, planet2_index\
    \ = planet2_index, planet1_index\n    end\n    return planets:slice(planet1_index\
    \ + 1, planet2_index)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6t0asdal.lua:16:\
    \ attempt to call a nil value (method 'indexOf')\nstack traceback:\n\t/tmp/tmp6t0asdal.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmp6t0asdal.lua:30: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local t = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local f, s\n  for i, v\
    \ in ipairs(t) do\n    if v == planet1 then\n      f = i\n    end\n    if v ==\
    \ planet2 then\n      s = i\n    end\n  end\n  if not f or not s then\n    return\
    \ ()\n  end\n  if f > s then\n    local tmp = f\n    f = s\n    s = tmp\n  end\n\
    \  local ret = {}\n  for i = f + 1, s - 1 do\n    table.insert(ret, t[i])\n  end\n\
    \  return table.unpack(ret)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp4sf_epl1.lua:26: unexpected symbol near ')'\n"
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local first\n    local last\n    local planets = {\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n\
    \            first = i\n        end\n        if v == planet2 then\n          \
    \  last = i\n        end\n    end\n    if first == nil or last == nil then\n \
    \       return {}\n    end\n    local result = {}\n    for i = first + 1, last\
    \ - 1 do\n        table.insert(result, planets[i])\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxfm1vox7.lua:40:\
    \ expected: {\"Venus\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpxfm1vox7.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\t-- your code here\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvtn5epql.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmpvtn5epql.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local index1,\
    \ index2\n  for i, planet in ipairs(planets) do\n    if planet == planet1 then\n\
    \      index1 = i\n    end\n    if planet == planet2 then\n      index2 = i\n\
    \    end\n  end\n  if not index1 or not index2 then\n    return {}\n  end\n  if\
    \ index1 > index2 then\n    index1, index2 = index2, index1\n  end\n  local result\
    \ = {}\n  for i = index1 + 1, index2 - 1 do\n    table.insert(result, planets[i])\n\
    \  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1, Venus = 2, Earth\
    \ = 3, Mars = 4, Jupiter = 5, Saturn = 6,\n    Uranus = 7, Neptune = 8, Pluto\
    \ = 9\n  }\n  if not planets[planet1] or not planets[planet2] then return {} end\n\
    \  local count, p1, p2, res = 0, planets[planet1], planets[planet2], {}\n  for\
    \ i = 1, 8 do\n    local dist = math.abs(i - p1)\n    if (dist >= count and dist\
    \ <= math.abs(i - p2)) then\n      res[#res + 1] = i\n      count = dist\n   \
    \ end\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmtml65e5.lua:34:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {1}\nstack traceback:\n\t/tmp/tmpmtml65e5.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {'Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n\tlocal p1, p2\n\tfor i, v in ipairs(planets)\
    \ do\n\t\tif v == planet1 then\n\t\t\tp1 = i\n\t\tend\n\t\tif v == planet2 then\n\
    \t\t\tp2 = i\n\t\tend\n\tend\n\tif p1 == nil or p2 == nil then\n\t\treturn {}\n\
    \tend\n\tif p1 < p2 then\n\t\ttable.remove(planets, p1)\n\t\ttable.remove(planets,\
    \ p2 - 1)\n\telse\n\t\ttable.remove(planets, p2)\n\t\ttable.remove(planets, p1\
    \ - 1)\n\tend\n\treturn planets\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsu160xwh.lua:41:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Saturn\", \"Uranus\"}\nstack traceback:\n\t/tmp/tmpsu160xwh.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  \n  local function indexof(table, item)\n    for k,\
    \ v in pairs(table) do\n      if v == item then\n        return k\n      end\n\
    \    end\n  end\n  \n  local planets = {\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local i1 = indexof(planets,\
    \ planet1)\n  local i2 = indexof(planets, planet2)\n  if i1 == nil or i2 == nil\
    \ then\n    return {}\n  end\n  local reverse = i1 > i2\n  if reverse then\n \
    \   i1, i2 = i2, i1\n  end\n  local result = {}\n  for i = i1 + 1, i2 - 1 do\n\
    \    table.insert(result, planets[i])\n  end\n  if reverse then\n    result =\
    \ reverse(result)\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_4ljl356.lua:39:\
    \ attempt to call a boolean value (local 'reverse')\nstack traceback:\n\t/tmp/tmp_4ljl356.lua:39:\
    \ in local 'candidate'\n\t/tmp/tmp_4ljl356.lua:48: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal start,\
    \ finish = 0, 0\n\tfor i, v in ipairs(planets) do\n\t\tif v == planet1 then\n\t\
    \t\tstart = i\n\t\tend\n\t\tif v == planet2 then\n\t\t\tfinish = i\n\t\tend\n\t\
    end\n\tif start == 0 or finish == 0 then\n\t\treturn {}\n\tend\n\tif start > finish\
    \ then\n\t\tlocal t = start\n\t\tstart = finish\n\t\tfinish = t\n\tend\n\tlocal\
    \ res = {}\n\tfor i = start + 1, finish - 1 do\n\t\ttable.insert(res, planets[i])\n\
    \tend\n\treturn res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local list = {\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local res = {}\n\
    \  local st, nd\n  for k, v in ipairs(list) do\n    if planet1 == v then\n   \
    \   st = k\n    end\n    if planet2 == v then\n      nd = k\n    end\n  end\n\
    \  if st == nil or nd == nil then\n    return {}\n  end\n  if st > nd then\n \
    \   st, nd = nd, st\n  end\n  for i = st, nd do\n    if list[i] ~= planet1 and\
    \ list[i] ~= planet2 then\n      table.insert(res, list[i])\n    end\n  end\n\
    \  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  \n  local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local start =\
    \ -1\n  local ending = -1\n  local retVal = {}\n  \n  for i,name in ipairs(planets)\
    \ do\n    if(name == planet1) then\n      start = i\n    end\n    if(name == planet2)\
    \ then\n      ending = i\n    end\n  end\n  \n  if(start == -1 or ending == -1)\
    \ then\n    return retVal\n  end\n  \n  if(start > ending) then\n    start, ending\
    \ = ending, start\n  end\n  \n  for i = start + 1, ending - 1 do\n    table.insert(retVal,\
    \ planets[i])\n  end\n  \n  return retVal\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    -- put your code here\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4acrvewq.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmp4acrvewq.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    -- Insert your code here\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpeac7lgcf.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmpeac7lgcf.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local i, j\
    \ = 0, 0\n    for k, v in ipairs(planets) do\n        if planet1 == v then\n \
    \           i = k\n        end\n        if planet2 == v then\n            j =\
    \ k\n        end\n    end\n    if i == 0 or j == 0 then\n        return {}\n \
    \   end\n    if i > j then\n        i, j = j, i\n    end\n    local result = {}\n\
    \    for n = i + 1, j - 1 do\n        table.insert(result, planets[n])\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local orbits = {0, 0.467, 1, 1.524, 5.2, 9.58, 19.2,\
    \ 30.1}\n  local planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"}\n  local o1, o2\n  for i = 1, #planets\
    \ do\n    if planets[i] == planet1 then\n      o1 = orbits[i]\n    end\n    if\
    \ planets[i] == planet2 then\n      o2 = orbits[i]\n    end\n  end\n  if not o1\
    \ or not o2 then\n    return {}\n  end\n  local min, max = math.min(o1, o2), math.max(o1,\
    \ o2)\n  local x = {}\n  for i = 1, #planets do\n    if orbits[i] > min and orbits[i]\
    \ < max then\n      x[#x + 1] = planets[i]\n    end\n  end\n  return x\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\n        Earth = 1,\n        Mars\
    \ = 2,\n        Jupiter = 3,\n        Saturn = 4,\n        Uranus = 5,\n     \
    \   Neptune = 6,\n        Venus = 7,\n        Mercury = 8\n    }\n    local first\
    \ = planets[planet1]\n    local second = planets[planet2]\n    if not first or\
    \ not second then\n        return {}\n    end\n    local result = {}\n    if first\
    \ < second then\n        for i = first + 1, second - 1 do\n            table.insert(result,\
    \ next(planets, planets[i - 1]))\n        end\n    else\n        for i = second\
    \ + 1, first - 1 do\n            table.insert(result, next(planets, planets[i\
    \ - 1]))\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpcfvgvduw.lua:33:\
    \ bad argument #2 to 'insert' (number expected, got string)\nstack traceback:\n\
    \t/tmp/tmpcfvgvduw.lua:33: in local 'candidate'\n\t/tmp/tmpcfvgvduw.lua:46: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local planet1_idx\
    \ = 0\n    local planet2_idx = 0\n    for k, v in ipairs(planets) do\n       \
    \ if v == planet1 then\n            planet1_idx = k\n        end\n        if v\
    \ == planet2 then\n            planet2_idx = k\n        end\n    end\n    local\
    \ t = {}\n    if planet1_idx < planet2_idx then\n        for i = planet1_idx +\
    \ 1, planet2_idx - 1 do\n            table.insert(t, planets[i])\n        end\n\
    \    else\n        for i = planet2_idx + 1, planet1_idx - 1 do\n            table.insert(t,\
    \ planets[i])\n        end\n    end\n    return unpack(t)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpos5zqb3o.lua:36:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpos5zqb3o.lua:36:\
    \ in local 'candidate'\n\t/tmp/tmpos5zqb3o.lua:42: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local orb = {'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter',\
    \ 'Saturn', 'Uranus', 'Neptune'}\n  local i1, i2 = orb[planet1], orb[planet2]\n\
    \  if i1 and i2 then\n    local t = {}\n    for k,v in ipairs(orb) do\n      if\
    \ ((i1 < i2 and i1 < k and k < i2) or (i1 > i2 and i1 > k and k > i2)) then\n\
    \        t[#t+1] = v\n      end\n    end\n    return table.unpack(t)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp0w4_g39.lua:31:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmpp0w4_g39.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal l1, l2,\
    \ p1, p2, l\n\tlocal t = {}\n\tif planet1 == planet2 then return {} end\n\tfor\
    \ i,v in ipairs(planets) do\n\t\tif v == planet1 then l1 = i end\n\t\tif v ==\
    \ planet2 then l2 = i end\n\tend\n\tif not l1 or not l2 then return {} end\n\t\
    if l1 < l2 then \n\t\tp1 = planet1\n\t\tp2 = planet2\n\telse \n\t\tp1 = planet2\n\
    \t\tp2 = planet1\n\tend\n\tfor i = l1 + 1, l2 - 1 do\n\t\ttable.insert(t, planets[i])\n\
    \tend\n\treturn t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxlek8s9u.lua:41:\
    \ expected: {\"Venus\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpxlek8s9u.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\n\t\tMercury = 1,\n\t\tVenus = 2,\n\
    \t\tEarth = 3,\n\t\tMars = 4,\n\t\tJupiter = 5,\n\t\tSaturn = 6,\n\t\tUranus =\
    \ 7,\n\t\tNeptune = 8\n\t}\n\tif planets[planet1] == nil or planets[planet2] ==\
    \ nil then\n\t\treturn {}\n\tend\n\tlocal n1, n2 = planets[planet1], planets[planet2]\n\
    \tif n1 > n2 then\n\t\tn1, n2 = n2, n1\n\tend\n\tlocal res = {}\n\tfor i = n1\
    \ + 1, n2 - 1 do\n\t\ttable.insert(res, planets[i])\n\tend\n\treturn res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcbv9y40a.lua:42:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpcbv9y40a.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\treturn nil\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6u6ciz43.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmp6u6ciz43.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local idx1,\
    \ idx2\n    for i, v in ipairs(planets) do\n        if v == planet1 then idx1\
    \ = i end\n        if v == planet2 then idx2 = i end\n    end\n    if not idx1\
    \ or not idx2 then return {} end\n    local planets_found = {}\n    for i = math.min(idx1,\
    \ idx2), math.max(idx1, idx2) do\n        table.insert(planets_found, planets[i])\n\
    \    end\n    return planets_found\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl0i3_n00.lua:32:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\nstack traceback:\n\t/tmp/tmpl0i3_n00.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  \n  -- create table of planets\n  local planets = {\
    \ \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\" }\n  \n  -- validate inputs\n  if not table.contains(planets, planet1)\
    \ or not table.contains(planets, planet2) then\n    return {}\n  end\n  \n  --\
    \ find indices of planet1 and planet2\n  local index1 = table.indexOf(planets,\
    \ planet1)\n  local index2 = table.indexOf(planets, planet2)\n  \n  -- create\
    \ table to hold results\n  local results = {}\n  \n  -- add planets to results\
    \ based on indices\n  if index1 > index2 then\n    for i = index2 + 1, index1\
    \ - 1 do\n      table.insert(results, planets[i])\n    end\n  else\n    for i\
    \ = index1 + 1, index2 - 1 do\n      table.insert(results, planets[i])\n    end\n\
    \  end\n  \n  -- return results\n  return results\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpxpw7fb1l.lua:20:\
    \ attempt to call a nil value (field 'contains')\nstack traceback:\n\t/tmp/tmpxpw7fb1l.lua:20:\
    \ in local 'candidate'\n\t/tmp/tmpxpw7fb1l.lua:49: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    planets = {\n        {\"Mercury\", 88},\n        {\"\
    Venus\", 225},\n        {\"Earth\", 365},\n        {\"Mars\", 687},\n        {\"\
    Jupiter\", 4333},\n        {\"Saturn\", 10756},\n        {\"Uranus\", 30687},\n\
    \        {\"Neptune\", 60190}\n    }\n    planet1_index = -1\n    planet2_index\
    \ = -1\n    for i, v in ipairs(planets) do\n        if planet1 == v[1] then\n\
    \            planet1_index = i\n        end\n        if planet2 == v[1] then\n\
    \            planet2_index = i\n        end\n    end\n    if planet1_index ==\
    \ -1 or planet2_index == -1 then\n        return {}\n    end\n    new_list = {}\n\
    \    if planet1_index < planet2_index then\n        for i = planet1_index+1, planet2_index-1\
    \ do\n            table.insert(new_list, planets[i][1])\n        end\n    else\n\
    \        for i = planet2_index+1, planet1_index-1 do\n            table.insert(new_list,\
    \ planets[i][1])\n        end\n    end\n    return new_list\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal names = {\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal first = 0\n\
    \tlocal second = 0\n\tlocal result = {}\n\tfor i = 1, #names do\n\t\tif names[i]\
    \ == planet1 then\n\t\t\tfirst = i\n\t\tend\n\t\tif names[i] == planet2 then\n\
    \t\t\tsecond = i\n\t\tend\n\tend\n\tif first == 0 or second == 0 then\n\t\treturn\
    \ {}\n\tend\n\tif first < second then\n\t\tfor i = first + 1, second - 1 do\n\t\
    \t\ttable.insert(result, names[i])\n\t\tend\n\telse\n\t\tfor i = second + 1, first\
    \ - 1 do\n\t\t\ttable.insert(result, names[i])\n\t\tend\n\tend\n\treturn result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local i, j\
    \ = 0, 0\n    for k, v in ipairs(planets) do\n        if v == planet1 then\n \
    \           i = k\n        end\n        if v == planet2 then\n            j =\
    \ k\n        end\n    end\n    if i == 0 or j == 0 then\n        return {}\n \
    \   end\n    local result = {}\n    if i > j then\n        local k = i\n     \
    \   i = j\n        j = k\n    end\n    for k = i + 1, j - 1 do\n        table.insert(result,\
    \ planets[k])\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local orbits\
    \ = {1, 2, 3, 4, 5, 6, 7, 8}\n    local o1, o2\n    for i, planet in ipairs(planets)\
    \ do\n        if planet == planet1 then\n            o1 = orbits[i]\n        end\n\
    \        if planet == planet2 then\n            o2 = orbits[i]\n        end\n\
    \    end\n    local res = {}\n    if o1 == nil or o2 == nil then\n        return\
    \ res\n    end\n    for i, orbit in ipairs(orbits) do\n        if orbit > o1 and\
    \ orbit < o2 then\n            table.insert(res, planets[i])\n        end\n  \
    \  end\n    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmponwlovjq.lua:42:\
    \ expected: {\"Venus\"}\nactual: {}\nstack traceback:\n\t/tmp/tmponwlovjq.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {'Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n  local p = {}\n  for i = 1, #planets\
    \ do\n    if planets[i] == planet1 then\n      for j = i + 1, #planets do\n  \
    \      if planets[j] == planet2 then\n          for k = i + 1, j - 1 do\n    \
    \        table.insert(p, planets[k])\n          end\n          return unpack(p)\n\
    \        end\n      end\n    end\n  end\n  return p\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpksgsqo0g.lua:24:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpksgsqo0g.lua:24:\
    \ in local 'candidate'\n\t/tmp/tmpksgsqo0g.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planet_pos = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local result\
    \ = {}\n    local first_pos, second_pos\n    for i,v in ipairs(planet_pos) do\n\
    \        if v == planet1 then first_pos = i end\n        if v == planet2 then\
    \ second_pos = i end\n    end\n    if not first_pos or not second_pos then return\
    \ {} end\n    if first_pos > second_pos then\n        for i = second_pos, first_pos\
    \ do\n            table.insert(result, planet_pos[i])\n        end\n    else\n\
    \        for i = first_pos, second_pos do\n            table.insert(result, planet_pos[i])\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpee80_5bw.lua:38:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\nstack traceback:\n\t/tmp/tmpee80_5bw.lua:38: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local t = {Mercury = 0, Venus = 1, Earth = 2, Mars =\
    \ 3, Jupiter = 4, Saturn = 5, Uranus = 6, Neptune = 7}\n  local ps = {Mercury,\
    \ Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune}\n  local p1 = t[planet1]\n\
    \  local p2 = t[planet2]\n  if not p1 or not p2 then return {} end\n  if p1 >\
    \ p2 then p1, p2 = p2, p1 end\n  local r = {}\n  for i = p1 + 1, p2 do\n    table.insert(r,\
    \ ps[i])\n  end\n  return r\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpljbz8skg.lua:31:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpljbz8skg.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local list = {\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local k, j = 0, 0\n\
    \  for i, v in ipairs(list) do\n    if v == planet1 then k = i end\n    if v ==\
    \ planet2 then j = i end\n  end\n  if k == 0 or j == 0 then return {} end\n  if\
    \ k > j then local t = k; k = j; j = t end\n  local t = {}\n  for i = k + 1, j\
    \ - 1 do t[#t + 1] = list[i] end\n  return table.unpack(t)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpi853d5xp.lua:31:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: \"Saturn\"\nstack traceback:\n\t\
    /tmp/tmpi853d5xp.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  return nil\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp6lktq42.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmpp6lktq42.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local idx =\
    \ {Mercury = 1, Venus = 2, Earth = 3, Mars = 4, Jupiter = 5, Saturn = 6, Uranus\
    \ = 7, Neptune = 8}\n    local j = {}\n    if (not idx[planet1]) or (not idx[planet2])\
    \ then return {} end\n    if idx[planet1] < idx[planet2] then\n        for i =\
    \ idx[planet1] + 1, idx[planet2] - 1 do\n            table.insert(j, planets[i])\n\
    \        end\n    elseif idx[planet1] > idx[planet2] then\n        for i = idx[planet2]\
    \ + 1, idx[planet1] - 1 do\n            table.insert(j, planets[i])\n        end\n\
    \    end\n    return table.unpack(j)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp98pve4qm.lua:34:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: \"Saturn\"\nstack traceback:\n\t\
    /tmp/tmp98pve4qm.lua:34: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n   local function getIndex(planet)\n      local planets\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"}\n      for i = 1, #planets do\n         if planets[i] ==\
    \ planet then\n            return i\n         end\n      end\n      return 0\n\
    \   end\n   local start, finish = getIndex(planet1), getIndex(planet2)\n   if\
    \ start == 0 or finish == 0 then\n      return {}\n   end\n   if start > finish\
    \ then\n      start, finish = finish, start\n   end\n   local planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n   local res = {}\n   for i = start + 1, finish - 1 do\n      res[#res + 1]\
    \ = planets[i]\n   end\n   return res\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local function\
    \ pos(p)\n    for i,v in ipairs(planets) do\n      if v == p then return i end\n\
    \    end\n  end\n  local p1 = pos(planet1)\n  local p2 = pos(planet2)\n  if not\
    \ p1 or not p2 then return {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  return\
    \ table.pack(table.unpack(planets, p1+1, p2-1))\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq7uxt92j.lua:31:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Saturn\", \"Uranus\", n=2}\n\
    stack traceback:\n\t/tmp/tmpq7uxt92j.lua:31: in function 'test_humaneval'\n\n\
    Ran 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local p = {\n      Mercury = 1,\n      Venus = 2,\n\
    \      Earth = 3,\n      Mars = 4,\n      Jupiter = 5,\n      Saturn = 6,\n  \
    \    Uranus = 7,\n      Neptune = 8\n  }\n  if p[planet1] == nil or p[planet2]\
    \ == nil then return {} end\n  local planets = {}\n  local i, j = p[planet1],\
    \ p[planet2]\n  if i > j then i, j = j, i end\n  for k, v in pairs(p) do\n   \
    \ if v >= i and v <= j then\n      table.insert(planets, k)\n    end\n  end\n\
    \  return planets\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyypp5s19.lua:40:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Neptune\", \"Saturn\", \"Jupiter\"\
    , \"Uranus\"}\nstack traceback:\n\t/tmp/tmpyypp5s19.lua:40: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tif planet1 == planet2 then return {planet1} end\n\t\
    local planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal p1 = table.indexOf(planets, planet1)\n\
    \tlocal p2 = table.indexOf(planets, planet2)\n\tif not p1 or not p2 then return\
    \ {} end\n\tlocal res = {}\n\tlocal low = math.min(p1, p2)\n\tlocal high = math.max(p1,\
    \ p2)\n\tfor i = low + 1, high do\n\t\ttable.insert(res, planets[i])\n\tend\n\t\
    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmprwxikgje.lua:17:\
    \ attempt to call a nil value (field 'indexOf')\nstack traceback:\n\t/tmp/tmprwxikgje.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmprwxikgje.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local solar_system = {\n    \"Mercury\", \"Venus\",\
    \ \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n  }\n\
    \  local planet1_index, planet2_index = nil, nil\n  for i, planet in ipairs(solar_system)\
    \ do\n    if planet == planet1 then\n      planet1_index = i\n    end\n    if\
    \ planet == planet2 then\n      planet2_index = i\n    end\n  end\n  if planet1_index\
    \ == nil or planet2_index == nil then\n    return {}\n  end\n  local planets =\
    \ {}\n  if planet1_index > planet2_index then\n    for i = planet2_index + 1,\
    \ planet1_index - 1 do\n      table.insert(planets, solar_system[i])\n    end\n\
    \  else\n    for i = planet1_index + 1, planet2_index - 1 do\n      table.insert(planets,\
    \ solar_system[i])\n    end\n  end\n  return planets\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local tbl = {'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter',\
    \ 'Saturn', 'Uranus', 'Neptune'}\n  local first\n  local last\n  local arr = {}\n\
    \  for i, v in ipairs(tbl) do\n    if v == planet1 then first = i end\n    if\
    \ v == planet2 then last = i end\n  end\n  if first and last then\n    for i =\
    \ first, last do\n      if i ~= first and i ~= last then table.insert(arr, tbl[i])\
    \ end\n    end\n  end\n  return table.unpack(arr)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgl9bltx6.lua:34:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: \"Saturn\"\nstack traceback:\n\t\
    /tmp/tmpgl9bltx6.lua:34: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planet_names = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local order\
    \ = 1\n    local p1, p2 = 0, 0\n    for i, planet in ipairs(planet_names) do\n\
    \        if planet == planet1 then\n            p1 = i\n        end\n        if\
    \ planet == planet2 then\n            p2 = i\n        end\n    end\n    if p1\
    \ == 0 or p2 == 0 then\n        return {}\n    end\n    if p1 > p2 then\n    \
    \    order = -1\n        p1, p2 = p2, p1\n    end\n    local result = {}\n   \
    \ for i = p1 + 1, p2 - 1 do\n        table.insert(result, planet_names[i])\n \
    \   end\n    if order == -1 then\n        for i = 1, math.floor(#result / 2) do\n\
    \            result[i], result[#result - i + 1] = result[#result - i + 1], result[i]\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppnkp26mr.lua:51:\
    \ expected: {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}\nactual:\
    \ {\"Uranus\", \"Saturn\", \"Jupiter\", \"Mars\", \"Earth\"}\nstack traceback:\n\
    \t/tmp/tmppnkp26mr.lua:51: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  if not (isIn(planet1, {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}) and\n         \
    \ isIn(planet2, {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"})) then\n    return {}\n  end\n  local p1, p2\
    \ = get_index(planet1), get_index(planet2)\n  local planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n  local res = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 do\n      res[#res\
    \ + 1] = planets[i]\n    end\n  else\n    for i = p1 - 1, p2, -1 do\n      res[#res\
    \ + 1] = planets[i]\n    end\n  end\n  return tuple.new(unpack(res))\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n  \
    \  lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n  \
    \  lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp5g49_068.lua:15:\
    \ attempt to call a nil value (global 'isIn')\nstack traceback:\n\t/tmp/tmp5g49_068.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmp5g49_068.lua:37: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- your code here\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7o6a1aao.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmp7o6a1aao.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local t = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local i, j = table.find(t,\
    \ planet1), table.find(t, planet2)\n    if not i or not j then return {} end\n\
    \    if i > j then\n        i, j = j, i\n    end\n    return table.sub(t, i +\
    \ 1, j - 1)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0tisntrj.lua:16:\
    \ attempt to call a nil value (field 'find')\nstack traceback:\n\t/tmp/tmp0tisntrj.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmp0tisntrj.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tif planet1 == nil or planet2 == nil then return {} end\n\
    \t\n\tlocal planets = {'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn',\
    \ 'Uranus', 'Neptune'}\n\tlocal planets_values = {}\n\tfor i, v in ipairs(planets)\
    \ do\n\t\tplanets_values[v] = i\n\tend\n\tlocal min = planets_values[planet1]\
    \ or 0\n\tlocal max = planets_values[planet2] or 0\n\t\n\tif min > max then\n\t\
    \tmin, max = max, min\n\tend\n\t\n\tlocal result = {}\n\tfor i = min+1, max-1\
    \ do\n\t\ttable.insert(result, planets[i])\n\tend\n\t\n\treturn result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpiy2jzda7.lua:46:\
    \ expected: {}\nactual: {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"}\nstack traceback:\n\
    \t/tmp/tmpiy2jzda7.lua:46: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local planet1_orbit\
    \ = 0\n  local planet2_orbit = 0\n  local result = {}\n  if planet1 == planet2\
    \ then\n    return result\n  end\n  for i = 1,#planets do\n    if planets[i] ==\
    \ planet1 then\n      planet1_orbit = i\n    end\n    if planets[i] == planet2\
    \ then\n      planet2_orbit = i\n    end\n  end\n  if planet1_orbit == 0 or planet2_orbit\
    \ == 0 then\n    return result\n  end\n  local min = math.min(planet1_orbit, planet2_orbit)\n\
    \  local max = math.max(planet1_orbit, planet2_orbit)\n  for i = min + 1, max\
    \ - 1 do\n    table.insert(result, planets[i])\n  end\n  return result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- your code here\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa9gsruf9.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmpa9gsruf9.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local idx1, idx2\n\
    \  for i, planet in ipairs(planets) do\n    if planet == planet1 then idx1 = i\
    \ end\n    if planet == planet2 then idx2 = i end\n  end\n  if not idx1 or not\
    \ idx2 then return {} end\n  if idx1 < idx2 then\n    return {unpack(planets,\
    \ idx1 + 1, idx2 - 1)}\n  else\n    return {unpack(planets, idx2 + 1, idx1 - 1)}\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpqul0no4y.lua:23:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpqul0no4y.lua:23:\
    \ in local 'candidate'\n\t/tmp/tmpqul0no4y.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\t-- body\n\tif(planet1 == \"Mercury\" and planet2 ==\
    \ \"Venus\") or \n\t\t(planet1 == \"Venus\" and planet2 == \"Mercury\") then\n\
    \t\treturn \"Mercury\", \"Venus\"\n\telseif(planet1 == \"Mercury\" and planet2\
    \ == \"Earth\") or \n\t\t(planet1 == \"Earth\" and planet2 == \"Mercury\") then\n\
    \t\treturn \"Mercury\", \"Venus\", \"Earth\"\n\telseif(planet1 == \"Mercury\"\
    \ and planet2 == \"Mars\") or \n\t\t(planet1 == \"Mars\" and planet2 == \"Mercury\"\
    ) then\n\t\treturn \"Mercury\", \"Venus\", \"Earth\", \"Mars\"\n\telseif(planet1\
    \ == \"Mercury\" and planet2 == \"Jupiter\") or \n\t\t(planet1 == \"Jupiter\"\
    \ and planet2 == \"Mercury\") then\n\t\treturn \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\"\n\telseif(planet1 == \"Mercury\" and planet2 == \"Saturn\"\
    ) or \n\t\t(planet1 == \"Saturn\" and planet2 == \"Mercury\") then\n\t\treturn\
    \ \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\n\telseif(planet1\
    \ == \"Mercury\" and planet2 == \"Uranus\") or \n\t\t(planet1 == \"Uranus\" and\
    \ planet2 == \"Mercury\") then\n\t\treturn \"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\n\telseif(planet1 == \"Mercury\"\
    \ and planet2 == \"Neptune\") or \n\t\t(planet1 == \"Neptune\" and planet2 ==\
    \ \"Mercury\") then\n\t\treturn \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n\telseif(planet1 == \"Venus\"\
    \ and planet2 == \"Earth\") or \n\t\t(planet1 == \"Earth\" and planet2 == \"Venus\"\
    ) then\n\t\treturn \"Venus\", \"Earth\"\n\telseif\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpukzz7avu.lua:41: 'then' expected near '='\n"
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n  }\n  local p1,\
    \ p2 = planets:find(planet1), planets:find(planet2)\n  if not p1 or not p2 then\
    \ return {} end\n  if p1 < p2 then\n    return planets:sub(p1 + 1, p2 - 1)\n \
    \ else\n    return planets:sub(p2 + 1, p1 - 1)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpxb8512eo.lua:18:\
    \ attempt to call a nil value (method 'find')\nstack traceback:\n\t/tmp/tmpxb8512eo.lua:18:\
    \ in local 'candidate'\n\t/tmp/tmpxb8512eo.lua:30: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- your code here\n  return nil\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbn5zmrxg.lua:22:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmpbn5zmrxg.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\n        Mercury = 1, Venus = 2,\
    \ Earth = 3, Mars = 4, Jupiter = 5,\n        Saturn = 6, Uranus = 7, Neptune =\
    \ 8, Pluto = 9\n    }\n    if planets[planet1] == nil or planets[planet2] == nil\
    \ then\n        return {}\n    end\n    local smaller\n    local bigger\n    if\
    \ planets[planet1] < planets[planet2] then\n        smaller = planets[planet1]\n\
    \        bigger = planets[planet2]\n    else\n        smaller = planets[planet2]\n\
    \        bigger = planets[planet1]\n    end\n    local res = {}\n    for k, v\
    \ in pairs(planets) do\n        if v > smaller and v < bigger then\n         \
    \   table.insert(res, k)\n        end\n    end\n    return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvidke0xr.lua:43:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Uranus\", \"Saturn\"}\nstack\
    \ traceback:\n\t/tmp/tmpvidke0xr.lua:43: in function 'test_humaneval'\n\nRan 1\
    \ tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {'Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n\tlocal index1, index2 = table.find(planets,\
    \ planet1), table.find(planets, planet2)\n\tif index1 and index2 then\n\t\tlocal\
    \ bf = {}\n\t\tfor _, planet in ipairs(planets) do\n\t\t\tif planets[index1] <\
    \ planets[index2] then\n\t\t\t\tif planets[index1] < planet and planet < planets[index2]\
    \ then\n\t\t\t\t\ttable.insert(bf, planet)\n\t\t\t\tend\n\t\t\telse\n\t\t\t\t\
    if planets[index1] > planet and planet > planets[index2] then\n\t\t\t\t\ttable.insert(bf,\
    \ planet)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\treturn unpack(bf)\n\tend\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmplzi3lhh2.lua:16:\
    \ attempt to call a nil value (field 'find')\nstack traceback:\n\t/tmp/tmplzi3lhh2.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmplzi3lhh2.lua:37: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    [\"Mercury\"] = 1,\n    [\"Venus\"\
    ] = 2,\n    [\"Earth\"] = 3,\n    [\"Mars\"] = 4,\n    [\"Jupiter\"] = 5,\n  \
    \  [\"Saturn\"] = 6,\n    [\"Uranus\"] = 7,\n    [\"Neptune\"] = 8\n  }\n  local\
    \ result = {}\n  if planets[planet1] and planets[planet2] then\n    local first\
    \ = planets[planet1]\n    local last = planets[planet2]\n    if first > last then\n\
    \      first, last = last, first\n    end\n    for k, v in pairs(planets) do\n\
    \      if v > first and v < last then\n        table.insert(result, k)\n     \
    \ end\n    end\n  end\n  return table.unpack(result)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy02zf3jn.lua:44:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: \"Saturn\"\nstack traceback:\n\t\
    /tmp/tmpy02zf3jn.lua:44: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local solarSystem = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\n\
    \  for i, v in ipairs(solarSystem) do\n    if v == planet1 then\n      p1 = i\n\
    \    end\n    if v == planet2 then\n      p2 = i\n    end\n  end\n  local r =\
    \ {}\n  if not p1 or not p2 then\n    return r\n  end\n  if p1 > p2 then\n   \
    \ p1, p2 = p2, p1\n  end\n  for i = p1 + 1, p2 - 1 do\n    table.insert(r, solarSystem[i])\n\
    \  end\n  return unpack(r)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpp__tzhty.lua:35:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpp__tzhty.lua:35:\
    \ in local 'candidate'\n\t/tmp/tmpp__tzhty.lua:41: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local is_planet = {\n    Mercury = true,\n    Venus\
    \ = true,\n    Earth = true,\n    Mars = true,\n    Jupiter = true,\n    Saturn\
    \ = true,\n    Uranus = true,\n    Neptune = true\n  }\n  if not is_planet[planet1]\
    \ or not is_planet[planet2] then return {} end\n  local planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n  local p1_idx, p2_idx = 1, #planets\n  for i = 1, #planets do\n    if planets[i]\
    \ == planet1 then p1_idx = i end\n    if planets[i] == planet2 then p2_idx = i\
    \ end\n  end\n  local res = {}\n  for i = math.min(p1_idx, p2_idx) + 1, math.max(p1_idx,\
    \ p2_idx) - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal res = {}\n\
    \tlocal i1, i2\n\tfor i, v in ipairs(planets) do\n\t\tif v == planet1 then\n\t\
    \t\ti1 = i\n\t\telseif v == planet2 then\n\t\t\ti2 = i\n\t\tend\n\tend\n\tif i1\
    \ and i2 then\n\t\tif i1 > i2 then\n\t\t\ti1, i2 = i2, i1\n\t\tend\n\t\tfor i\
    \ = i1+1, i2-1 do\n\t\t\ttable.insert(res, planets[i])\n\t\tend\n\tend\n\treturn\
    \ unpack(res)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmphmthwely.lua:33:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmphmthwely.lua:33:\
    \ in local 'candidate'\n\t/tmp/tmphmthwely.lua:39: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\n        \"Mercury\",\n        \"\
    Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n      \
    \  \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\n    }\n    local start\
    \ = nil\n    local finish = nil\n    for i, v in ipairs(planets) do\n        if\
    \ planet1 == v then\n            start = i\n        end\n        if planet2 ==\
    \ v then\n            finish = i\n        end\n    end\n    if start == nil or\
    \ finish == nil then\n        return {}\n    end\n    if start > finish then\n\
    \        start, finish = finish, start\n    end\n    local res = {}\n    for i\
    \ = start + 1, finish - 1 do\n        table.insert(res, planets[i])\n    end\n\
    \    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local g = function(x) return {x, \"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"} end\n\
    \  local h = function(t)\n    local min = g(planet1)\n    local max = g(planet2)\n\
    \    local r = {}\n    for i = 2, #min do\n      if i >= max[1] and i <= min[1]\
    \ then\n        table.insert(r, min[i])\n      end\n    end\n    return r\n  end\n\
    \  local a = {\n    Mercury = 1,\n    Venus = 2,\n    Earth = 3,\n    Mars = 4,\n\
    \    Jupiter = 5,\n    Saturn = 6,\n    Uranus = 7,\n    Neptune = 8\n  }\n  local\
    \ b = {\n    Mercury = 8,\n    Venus = 7,\n    Earth = 6,\n    Mars = 5,\n   \
    \ Jupiter = 4,\n    Saturn = 3,\n    Uranus = 2,\n    Neptune = 1\n  }\n  if a[planet1]\
    \ and a[planet2] then\n    return h(a)\n  elseif b[planet1] and b[planet2] then\n\
    \    return h(b)\n  else\n    return {}\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0maukphc.lua:21:\
    \ attempt to compare string with number\nstack traceback:\n\t/tmp/tmp0maukphc.lua:21:\
    \ in function </tmp/tmp0maukphc.lua:16>\n\t(...tail calls...)\n\t/tmp/tmp0maukphc.lua:59:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local orbit_dict = {\n    Mercury = 1,\n    Venus =\
    \ 2,\n    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local order = { planet1, planet2 }\n  table.sort(order,\
    \ function(a, b)\n    return orbit_dict[a] < orbit_dict[b]\n  end)\n  local t\
    \ = {}\n  for k,v in pairs(orbit_dict) do\n    if v > orbit_dict[order[1]] and\
    \ v < orbit_dict[order[2]] then\n      table.insert(t, k)\n    end\n  end\n  return\
    \ unpack(t)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpujvlrvw6.lua:35:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpujvlrvw6.lua:35:\
    \ in local 'candidate'\n\t/tmp/tmpujvlrvw6.lua:41: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- your code here\n  local planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n  local x = 1\n  local y = 1\n  local c = {}\n  for i = 1, #planets do\n  \
    \  if planets[i] == planet1 then\n      x = i\n    end\n    if planets[i] == planet2\
    \ then\n      y = i\n    end\n  end\n  if x >= y then\n    return {}\n  end\n\
    \  for i = x + 1, y - 1 do\n    table.insert(c, planets[i])\n  end\n  return c\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfw1v4cen.lua:41:\
    \ expected: {\"Venus\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpfw1v4cen.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local num =\
    \ {1, 2, 3, 4, 5, 6, 7, 8}\n    local i1, i2\n    for k, v in ipairs(planets)\
    \ do\n        if v == planet1 then\n            i1 = k\n        end\n        if\
    \ v == planet2 then\n            i2 = k\n        end\n    end\n    if i1 == nil\
    \ or i2 == nil then\n        return {}\n    end\n    if i1 > i2 then\n       \
    \ i1, i2 = i2, i1\n    end\n    local res = {}\n    for i = i1 + 1, i2 - 1 do\n\
    \        table.insert(res, planets[i])\n    end\n    return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- use the word filter to find the planet index\n  local\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"}\n  local start = filter(planets, function(x)\n    return\
    \ x == planet1\n  end)\n  local finish = filter(planets, function(x)\n    return\
    \ x == planet2\n  end)\n  -- filter out the results\n  return map(planets, function(planet,\
    \ i)\n    if i >= start and i <= finish then\n      return planet\n    end\n \
    \ end)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_awrdy6a.lua:17:\
    \ attempt to call a nil value (global 'filter')\nstack traceback:\n\t/tmp/tmp_awrdy6a.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmp_awrdy6a.lua:34: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = { \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" }\n  local function\
    \ find_orbit(name)\n    for orbit, planet in ipairs(planets) do\n      if planet\
    \ == name then\n        return orbit\n      end\n    end\n    return -1\n  end\n\
    \  local orbit1 = find_orbit(planet1)\n  local orbit2 = find_orbit(planet2)\n\
    \  if orbit1 == -1 or orbit2 == -1 then\n    return {}\n  end\n  local function\
    \ cmp(a, b)\n    if a < b then\n      return -1\n    elseif a > b then\n     \
    \ return 1\n    else\n      return 0\n    end\n  end\n  local function find_planets(orbit1,\
    \ orbit2)\n    local ret = {}\n    local min, max = cmp(orbit1, orbit2)\n    if\
    \ min < 0 then\n      min, max = max, min\n    end\n    for i = min + 1, max -\
    \ 1 do\n      table.insert(ret, planets[i])\n    end\n    return ret\n  end\n\
    \  return find_planets(orbit1, orbit2)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmph8r44l6s.lua:44:\
    \ attempt to perform arithmetic on a nil value (local 'min')\nstack traceback:\n\
    \t/tmp/tmph8r44l6s.lua:44: in function </tmp/tmph8r44l6s.lua:38>\n\t(...tail calls...)\n\
    \t/tmp/tmph8r44l6s.lua:55: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n   local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n   local i, j =\
    \ 0, 0\n   for k, v in ipairs(planets) do\n      if v == planet1 then i = k end\n\
    \      if v == planet2 then j = k end\n   end\n   if i == 0 or j == 0 then return\
    \ {} end\n   if i > j then i, j = j, i end\n   return table.move(planets, i +\
    \ 1, j, 1, {})\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpijsya12e.lua:29:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Saturn\", \"Uranus\", \"Neptune\"\
    }\nstack traceback:\n\t/tmp/tmpijsya12e.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- Return the tuple of planets.\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpb9gr46sn.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmpb9gr46sn.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n      \"Mercury\",\n      \"Venus\"\
    ,\n      \"Earth\",\n      \"Mars\",\n      \"Jupiter\",\n      \"Saturn\",\n\
    \      \"Uranus\",\n      \"Neptune\"\n  }\n  local start, finish = table.find(planets,\
    \ planet1), table.find(planets, planet2)\n  if not start or not finish then\n\
    \    return {}\n  end\n  local result = {}\n  if start < finish then\n    for\
    \ i = start + 1, finish - 1 do\n      table.insert(result, planets[i])\n    end\n\
    \  else\n    for i = start - 1, finish + 1, -1 do\n      table.insert(result,\
    \ planets[i])\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp7h8rep_c.lua:25:\
    \ attempt to call a nil value (field 'find')\nstack traceback:\n\t/tmp/tmp7h8rep_c.lua:25:\
    \ in local 'candidate'\n\t/tmp/tmp7h8rep_c.lua:45: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local out = {}\n    local start, fin, ctr = false,\
    \ false, 0\n    local planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\",\
    \ \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local len = #planets\n\
    \    for i=1, len do\n        if planets[i] == planet1 then\n            start\
    \ = true\n        end\n        if planets[i] == planet2 then\n            fin\
    \ = true\n        end\n        if start and not fin then\n            ctr = ctr\
    \ + 1\n            out[ctr] = planets[i]\n        end\n    end\n    return unpack(out)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpklafg7q3.lua:31:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpklafg7q3.lua:31:\
    \ in local 'candidate'\n\t/tmp/tmpklafg7q3.lua:37: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local t = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local start, stop = 0,\
    \ 0\n  for i, v in ipairs(t) do\n    if v == planet1 then\n      start = i\n \
    \   end\n    if v == planet2 then\n      stop = i\n    end\n  end\n  if start\
    \ == 0 or stop == 0 then\n    return {}\n  end\n  if start < stop then\n    local\
    \ ret = {}\n    for i = start + 1, stop - 1 do\n      table.insert(ret, t[i])\n\
    \    end\n    return ret\n  else\n    local ret = {}\n    for i = stop + 1, start\
    \ - 1 do\n      table.insert(ret, t[i])\n    end\n    return ret\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local t = {}\n\
    \  for i, v in ipairs(planets) do\n    if v == planet1 then break end\n    table.insert(t,\
    \ v)\n  end\n  local t2 = {}\n  for i, v in ipairs(planets) do\n    if v == planet2\
    \ then break end\n    table.insert(t2, v)\n  end\n  return t, t2\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2qkh8wbf.lua:32:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\"}\nstack traceback:\n\t/tmp/tmp2qkh8wbf.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local table = {\n    Earth = 4,\n    Jupiter = 5,\n\
    \    Mars = 3,\n    Mercury = 1,\n    Neptune = 8,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Venus = 2\n  }\n  local p1 = table[planet1]\n  local p2 = table[planet2]\n\
    \  if not p1 or not p2 then\n    return {}\n  end\n  local planets = { planet1,\
    \ planet2 }\n  local function lower(a, b)\n    return table[a] < table[b]\n  end\n\
    \  table.sort(planets, lower)\n  local plan = {}\n  for i = planets[1], planets[2]\
    \ do\n    if i ~= planets[1] and i ~= planets[2] then\n      plan[#plan + 1] =\
    \ i\n    end\n  end\n  return plan\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpin2xiboc.lua:34:\
    \ attempt to call a nil value (field 'sort')\nstack traceback:\n\t/tmp/tmpin2xiboc.lua:34:\
    \ in local 'candidate'\n\t/tmp/tmpin2xiboc.lua:47: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal start,\
    \ fin = planets[planet1], planets[planet2]\n\tif start == nil or fin == nil then\n\
    \t\treturn {}\n\tend\n\tlocal order = false\n\tif start > fin then\n\t\tstart,\
    \ fin = fin, start\n\t\torder = true\n\tend\n\tlocal r = {}\n\tfor i = start +\
    \ 1, fin - 1 do\n\t\ttable.insert(r, planets[i])\n\tend\n\tif order then\n\t\t\
    return r\n\telse\n\t\tlocal t = {}\n\t\tfor i = #r, 1, -1 do\n\t\t\ttable.insert(t,\
    \ r[i])\n\t\tend\n\t\treturn t\n\tend\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpeiadiv14.lua:43:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpeiadiv14.lua:43:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  \nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpswp4gyi7.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmpswp4gyi7.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  return \"\"\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmaayw4hs.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: \"\"\nstack traceback:\n\t/tmp/tmpmaayw4hs.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local i1, i2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  local res =\
    \ {}\n  if i1 and i2 then\n    if i1 < i2 then\n      for i = i1+1, i2-1 do\n\
    \        table.insert(res, planets[i])\n      end\n    else\n      for i = i2+1,\
    \ i1-1 do\n        table.insert(res, planets[i])\n      end\n    end\n  end\n\
    \  return unpack(res)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpnmjlehdg.lua:16:\
    \ attempt to call a nil value (field 'find')\nstack traceback:\n\t/tmp/tmpnmjlehdg.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpnmjlehdg.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- your code here\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxgz4v973.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmpxgz4v973.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local orbit = {\n    \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n  }\n  local function\
    \ orbit_number(planet)\n    for index, body in ipairs(orbit) do\n      if body\
    \ == planet then\n        return index\n      end\n    end\n  end\n  local function\
    \ orbit_range(planet1, planet2)\n    local range = {}\n    local lower = math.min(orbit_number(planet1),\
    \ orbit_number(planet2))\n    local upper = math.max(orbit_number(planet1), orbit_number(planet2))\n\
    \    for index = lower, upper do\n      table.insert(range, orbit[index])\n  \
    \  end\n    return range\n  end\n  if orbit_number(planet1) == nil or orbit_number(planet2)\
    \ == nil then\n    return {}\n  else\n    return orbit_range(planet1, planet2)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppwbseml_.lua:44:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\nstack traceback:\n\t/tmp/tmppwbseml_.lua:44: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- your code here\nend\n```\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp7zyx3gsp.lua:17: unexpected symbol near '`'\n"
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local planet1index,\
    \ planet2index\n  local between = {}\n  for i, name in ipairs(planets) do\n  \
    \  if name == planet1 then\n      planet1index = i\n    end\n    if name == planet2\
    \ then\n      planet2index = i\n    end\n  end\n  if planet1index == nil or planet2index\
    \ == nil then\n    return {}\n  end\n  for i = math.min(planet1index, planet2index)\
    \ + 1, math.max(planet1index, planet2index) - 1 do\n    table.insert(between,\
    \ planets[i])\n  end\n  return between\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local p, pos1, pos2 = {\"Mercury\", \"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}, 0, 0\n \
    \   for i, v in ipairs(p) do\n        if v == planet1 then pos1 = i end\n    \
    \    if v == planet2 then pos2 = i end\n    end\n    if pos1 == 0 or pos2 == 0\
    \ then return {} end\n    if pos1 > pos2 then pos1, pos2 = pos2, pos1 end\n  \
    \  return table.pack(table.unpack(p, pos1 + 1, pos2 - 1))\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjtrezsbo.lua:28:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Saturn\", \"Uranus\", n=2}\n\
    stack traceback:\n\t/tmp/tmpjtrezsbo.lua:28: in function 'test_humaneval'\n\n\
    Ran 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal solarSystem = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal planets\
    \ = {}\n\tlocal n1, n2 = 0, 0\n\tfor i, v in ipairs(solarSystem) do\n\t\tif v\
    \ == planet1 then\n\t\t\tn1 = i\n\t\telseif v == planet2 then\n\t\t\tn2 = i\n\t\
    \tend\n\tend\n\tif n1 == 0 or n2 == 0 then\n\t\treturn {}\n\tend\n\tfor i = math.min(n1,\
    \ n2) + 1, math.max(n1, n2) - 1 do\n\t\ttable.insert(planets, solarSystem[i])\n\
    \tend\n\treturn planets\nend\nprint(unpack(bf(\"Mars\", \"Earth\")))\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6uluuu4g.lua:33: attempt to call a nil value (global 'unpack')\n\
    stack traceback:\n\t/tmp/tmp6uluuu4g.lua:33: in main chunk\n\t[C]: in ?\n"
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  --[[\n  local planets = {\"Mercury\", \"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local\
    \ p1, p2 = nil, nil\n  for i = 1, #planets do\n    if planet1 == planets[i] then\n\
    \      p1 = i\n    end\n    if planet2 == planets[i] then\n      p2 = i\n    end\n\
    \  end\n  if p1 and p2 then\n    local p3 = nil\n    if p1 > p2 then\n      p3\
    \ = p1\n      p1 = p2\n      p2 = p3\n    end\n    local res = {}\n    for i =\
    \ p1 + 1, p2 - 1 do\n      res[#res + 1] = planets[i]\n    end\n    return unpack(res)\n\
    \  end\n  return nil\n  --]]\n  local planets = {\n    Mercury = 1, Venus = 2,\
    \ Earth = 3, Mars = 4, Jupiter = 5, Saturn = 6, Uranus = 7, Neptune = 8\n  }\n\
    \  local res = {}\n  if planets[planet1] and planets[planet2] then\n    for i\
    \ = planets[planet1] + 1, planets[planet2] - 1 do\n      for k, v in pairs(planets)\
    \ do\n        if v == i then\n          res[#res + 1] = k\n        end\n     \
    \ end\n    end\n  end\n  return unpack(res)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpuye9d3qb.lua:54:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpuye9d3qb.lua:54:\
    \ in local 'candidate'\n\t/tmp/tmpuye9d3qb.lua:60: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3o_wyj62.lua:20:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmp3o_wyj62.lua:20:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local idx = {\n\
    \    Mercury = 1, Venus = 2, Earth = 3, Mars = 4, Jupiter = 5, Saturn = 6, Uranus\
    \ = 7, Neptune = 8\n  }\n  local left = idx[planet1]\n  local right = idx[planet2]\n\
    \  if not left or not right then return {} end\n  if left > right then\n    local\
    \ tmp = left\n    left = right\n    right = tmp\n  end\n  return table.unpack(table.slice(planets,\
    \ left+1, right-1))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpj15lo9xo.lua:27:\
    \ attempt to call a nil value (field 'slice')\nstack traceback:\n\t/tmp/tmpj15lo9xo.lua:27:\
    \ in local 'candidate'\n\t/tmp/tmpj15lo9xo.lua:33: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local _, index1\
    \ = table.find(planets, planet1)\n  local _, index2 = table.find(planets, planet2)\n\
    \  return index1 > index2 and {} or table.slice(planets, index1 + 1, index2)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpla93zn32.lua:16:\
    \ attempt to call a nil value (field 'find')\nstack traceback:\n\t/tmp/tmpla93zn32.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpla93zn32.lua:24: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = { 'Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune' }\n  local index1, index2 = table.find(planets,\
    \ planet1), table.find(planets, planet2)\n  if index1 == nil or index2 == nil\
    \ then\n    return {}\n  end\n  if index1 > index2 then\n    index1, index2 =\
    \ index2, index1\n  end\n  local tuple = {}\n  for i = index1 + 1, index2 - 1\
    \ do\n    table.insert(tuple, planets[i])\n  end\n  return tuple\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmplmwb_1m7.lua:16:\
    \ attempt to call a nil value (field 'find')\nstack traceback:\n\t/tmp/tmplmwb_1m7.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmplmwb_1m7.lua:33: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  if not g[planet1] or not g[planet2] then return end\n\
    \  local res = {}\n  local min, max = math.min(g[planet1], g[planet2]), math.max(g[planet1],\
    \ g[planet2])\n  for i = min + 1, max - 1 do\n    for k, v in pairs(g) do\n  \
    \    if v == i then\n        table.insert(res, k)\n      end\n    end\n  end\n\
    \  return table.unpack(res)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4mt_pdtp.lua:15:\
    \ attempt to index a nil value (global 'g')\nstack traceback:\n\t/tmp/tmp4mt_pdtp.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmp4mt_pdtp.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local function getIndex(planet)\n    local index\
    \ = planets[planet]\n    if not index then\n      return nil\n    end\n    return\
    \ index\n  end\n  local index1 = getIndex(planet1)\n  local index2 = getIndex(planet2)\n\
    \  if not index1 or not index2 then\n    return {}\n  end\n  local result = {}\n\
    \  local start = math.min(index1, index2)\n  local finish = math.max(index1, index2)\n\
    \  for planet, index in pairs(planets) do\n    if index > start and index < finish\
    \ then\n      table.insert(result, planet)\n    end\n  end\n  return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpn6y5mrns.lua:51:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Uranus\", \"Saturn\"}\nstack\
    \ traceback:\n\t/tmp/tmpn6y5mrns.lua:51: in function 'test_humaneval'\n\nRan 1\
    \ tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- your code here\n  local planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n  local p1, p2\n  for i, v in ipairs(planets) do\n    if planet1 == v then\
    \ p1 = i end\n    if planet2 == v then p2 = i end\n  end\n  if not p1 or not p2\
    \ then return {} end\n  local t = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2\
    \ - 1 do\n      table.insert(t, planets[i])\n    end\n  else\n    for i = p2 +\
    \ 1, p1 - 1 do\n      table.insert(t, planets[i])\n    end\n  end\n  return t\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local solarSystem = {'Mercury', 'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n    local distanceFromSun1,\
    \ distanceFromSun2\n    local result = {}\n    for k,v in pairs(solarSystem) do\n\
    \        if v == planet1 then distanceFromSun1 = k end\n        if v == planet2\
    \ then distanceFromSun2 = k end\n    end\n    if distanceFromSun1 == nil or distanceFromSun2\
    \ == nil then return {} end\n    if distanceFromSun1 < distanceFromSun2 then\n\
    \        for i = distanceFromSun1 + 1, distanceFromSun2 - 1 do\n            table.insert(result,\
    \ solarSystem[i])\n        end\n    else\n        for i = distanceFromSun2 + 1,\
    \ distanceFromSun1 - 1 do\n            table.insert(result, solarSystem[i])\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal names = {\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal idx1, idx2\n\
    \tlocal t = {}\n\tfor i, v in ipairs(names) do\n\t\tif v == planet1 then idx1\
    \ = i end\n\t\tif v == planet2 then idx2 = i end\n\tend\n\tif idx1 == nil or idx2\
    \ == nil then return t end\n\tif idx1 > idx2 then\n\t\tlocal tmp = idx1\n\t\t\
    idx1 = idx2\n\t\tidx2 = tmp\n\tend\n\tfor i = idx1 + 1, idx2 - 1 do\n\t\ttable.insert(t,\
    \ names[i])\n\tend\n\treturn t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local from\
    \ = 0\n    local to = 0\n    for i = 1, #planets do\n        if planets[i] ==\
    \ planet1 then\n            from = i\n        end\n        if planets[i] == planet2\
    \ then\n            to = i\n        end\n    end\n    if from == 0 or to == 0\
    \ then\n        return {}\n    end\n    local res = {}\n    if from < to then\n\
    \        for i = from + 1, to - 1 do\n            table.insert(res, planets[i])\n\
    \        end\n    else\n        for i = to + 1, from - 1 do\n            table.insert(res,\
    \ planets[i])\n        end\n    end\n    return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {'Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n\tlocal p1 = table.indexOf(planets,\
    \ planet1)\n\tlocal p2 = table.indexOf(planets, planet2)\n\tlocal c = p1<p2 and\
    \ 1 or -1\n\tlocal a = {}\n\tfor i=p1+c,p2-c,c do\n\t\ttable.insert(a, planets[i])\n\
    \tend\n\treturn unpack(a)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmprsxwqegn.lua:16:\
    \ attempt to call a nil value (field 'indexOf')\nstack traceback:\n\t/tmp/tmprsxwqegn.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmprsxwqegn.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\t-- check if planet1 and planet2 are valid planet names\n\
    \tlocal valid1 = false\n\tlocal valid2 = false\n\tfor i,v in ipairs(planets) do\n\
    \t\tif v == planet1 then\n\t\t\tvalid1 = true\n\t\tend\n\t\tif v == planet2 then\n\
    \t\t\tvalid2 = true\n\t\tend\n\tend\n\tif valid1 and valid2 then\n\t\tlocal ans\
    \ = {}\n\t\tlocal first = 1\n\t\tlocal last = 8\n\t\tfor i,v in ipairs(planets)\
    \ do\n\t\t\tif v == planet1 then\n\t\t\t\tfirst = i\n\t\t\tend\n\t\t\tif v ==\
    \ planet2 then\n\t\t\t\tlast = i\n\t\t\tend\n\t\tend\n\t\tif first > last then\n\
    \t\t\t-- swap\n\t\t\tlocal t = first\n\t\t\tfirst = last\n\t\t\tlast = t\n\t\t\
    end\n\t\tfor i = first + 1, last - 1 do\n\t\t\ttable.insert(ans, planets[i])\n\
    \t\tend\n\t\treturn unpack(ans)\n\telse\n\t\treturn {}\n\tend\nend\nprint(table.concat(bf(\"\
    Jupiter\", \"Neptune\"), \",\"))\nprint(table.concat(bf(\"Earth\", \"Mercury\"\
    ), \",\"))\nprint(table.concat(bf(\"Mercury\", \"Uranus\"), \",\"))\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: attempt to index a nil value\nstack traceback:\n\t[C]: in for iterator\
    \ 'for iterator'\n\t/tmp/tmpc251pel0.lua:18: in local 'bf'\n\t/tmp/tmpc251pel0.lua:52:\
    \ in main chunk\n\t[C]: in ?\n"
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local index1,\
    \ index2\n    for k, v in ipairs(planets) do\n        if v == planet1 then index1\
    \ = k end\n        if v == planet2 then index2 = k end\n    end\n    if not index1\
    \ or not index2 then return {} end\n    local a, b\n    if index1 < index2 then\
    \ a, b = index1, index2 end\n    if index1 > index2 then a, b = index2, index1\
    \ end\n    local t = {}\n    for i = a + 1, b - 1 do table.insert(t, planets[i])\
    \ end\n    return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmprzyb5wd3.lua:26:\
    \ attempt to perform arithmetic on a nil value (local 'a')\nstack traceback:\n\
    \t/tmp/tmprzyb5wd3.lua:26: in local 'candidate'\n\t/tmp/tmprzyb5wd3.lua:37: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- your code here\n  local planet_list = {'Mercury',\
    \ 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n  local\
    \ bf_list = {}\n  local planet1_idx, planet2_idx = 0, 0\n  for k, v in ipairs(planet_list)\
    \ do\n    if v == planet1 then\n      planet1_idx = k\n    end\n    if v == planet2\
    \ then\n      planet2_idx = k\n    end\n  end\n  if planet1_idx == 0 or planet2_idx\
    \ == 0 then\n    return {}\n  end\n  local idx1, idx2 = 0, 0\n  if planet1_idx\
    \ > planet2_idx then\n    idx1 = planet2_idx\n    idx2 = planet1_idx\n  else\n\
    \    idx1 = planet1_idx\n    idx2 = planet2_idx\n  end\n  for i = idx1, idx2 do\n\
    \    table.insert(bf_list, planet_list[i])\n  end\n  return bf_list\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpwbj_2vux.lua:47:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\nstack traceback:\n\t/tmp/tmpwbj_2vux.lua:47: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local orbit = {\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local planet1orbit\
    \ = 0\n  local planet2orbit = 0\n  local result = {}\n  for i, planet in ipairs(orbit)\
    \ do\n    if planet == planet1 then\n      planet1orbit = i\n    end\n    if planet\
    \ == planet2 then\n      planet2orbit = i\n    end\n  end\n  if planet1orbit ==\
    \ 0 or planet2orbit == 0 then\n    return {}\n  end\n  for i = planet1orbit, planet2orbit\
    \ do\n    table.insert(result, orbit[i])\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt6nt61ge.lua:39:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\nstack traceback:\n\t/tmp/tmpt6nt61ge.lua:39: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local p = {\n    \"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n  }\n  local s,\
    \ e = 1, 8\n  for i = 1, 8 do\n    if p[i] == planet1 then\n      s = i\n    end\n\
    \    if p[i] == planet2 then\n      e = i\n    end\n  end\n  if e > s then\n \
    \   return p[s+1], p[s+2], p[s+3], p[s+4], p[s+5], p[s+6], p[s+7]\n  else\n  \
    \  return p[e+1], p[e+2], p[e+3], p[e+4], p[e+5], p[e+6], p[e+7]\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpod4i_x5r.lua:37:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: \"Saturn\"\nstack traceback:\n\t\
    /tmp/tmpod4i_x5r.lua:37: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local plan = {\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local a, b\n  \
    \  local res = {}\n    for i, v in ipairs(plan) do\n        if v == planet1 then\n\
    \            a = i\n        end\n        if v == planet2 then\n            b =\
    \ i\n        end\n    end\n    if a and b then\n        if a < b then\n      \
    \      return tuple.fromTable(plan, a + 1, b - 1)\n        else\n            return\
    \ tuple.fromTable(plan, b + 1, a - 1)\n        end\n    else\n        return {}\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpvbvxxtgy.lua:28:\
    \ attempt to index a nil value (global 'tuple')\nstack traceback:\n\t/tmp/tmpvbvxxtgy.lua:28:\
    \ in local 'candidate'\n\t/tmp/tmpvbvxxtgy.lua:40: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- body\n  local sun = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local index1\
    \ = nil\n  local index2 = nil\n  local res = {}\n  for i,v in ipairs(sun) do\n\
    \    if v == planet1 then\n      index1 = i\n    end\n    if v == planet2 then\n\
    \      index2 = i\n    end\n  end\n  if index1 == nil or index2 == nil then\n\
    \    return {}\n  end\n  if index1 > index2 then\n    local tmp = index1\n   \
    \ index1 = index2\n    index2 = tmp\n  end\n  for i = index1 + 1, index2 - 1 do\n\
    \    table.insert(res, sun[i])\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n  }\n  local planet_orbit\
    \ = {}\n  for i,p in ipairs(planets) do\n    planet_orbit[p] = i\n  end\n  local\
    \ orbit1 = planet_orbit[planet1]\n  local orbit2 = planet_orbit[planet2]\n  if\
    \ orbit1 == nil or orbit2 == nil then\n    return {}\n  end\n  local result =\
    \ {}\n  for i,p in ipairs(planets) do\n    if math.min(orbit1, orbit2) < i and\
    \ i < math.max(orbit1, orbit2) then\n      table.insert(result, p)\n    end\n\
    \  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\t\n\tlocal function index(planet)\n\t\tlocal p_index\
    \ = {\n\t\t\tMercury = 1,\n\t\t\tVenus = 2,\n\t\t\tEarth = 3,\n\t\t\tMars = 4,\n\
    \t\t\tJupiter = 5,\n\t\t\tSaturn = 6,\n\t\t\tUranus = 7,\n\t\t\tNeptune = 8\n\t\
    \t}\n\t\treturn p_index[planet]\n\tend\n\t\n\tlocal ret = {}\n\tlocal i1 = index(planet1)\n\
    \tlocal i2 = index(planet2)\n\t\n\tif i1 and i2 then\n\t\tlocal start = math.min(i1,\
    \ i2)\n\t\tlocal finish = math.max(i1, i2)\n\t\tfor i = start + 1, finish - 1\
    \ do\n\t\t\tret[#ret + 1] = {Mercury = 1, Venus = 2, Earth = 3, Mars = 4, Jupiter\
    \ = 5, Saturn = 6, Uranus = 7, Neptune = 8}[i]\n\t\tend\n\tend\n\t\n\treturn unpack(ret)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp1gao28pp.lua:38: unexpected symbol near '['\n"
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local ret = {}\n\
    \  local len1, len2 = 0, 0\n  for k, v in ipairs(planets) do\n    if planet1 ==\
    \ v then\n      len1 = k\n    end\n    if planet2 == v then\n      len2 = k\n\
    \    end\n  end\n  for i = math.min(len1, len2) + 1, math.max(len1, len2) - 1\
    \ do\n    table.insert(ret, planets[i])\n  end\n  return unpack(ret)\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n  \
    \  lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n  \
    \  lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpm42e6h1x.lua:29:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpm42e6h1x.lua:29:\
    \ in local 'candidate'\n\t/tmp/tmpm42e6h1x.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n   local o = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n   local r = {}\n   local\
    \ i1, i2\n   for i, p in ipairs(o) do\n      if p == planet1 then i1 = i end\n\
    \      if p == planet2 then i2 = i end\n   end\n   if not i1 or not i2 then return\
    \ {} end\n   local i1, i2 = math.min(i1, i2), math.max(i1, i2)\n   for i = i1+1,\
    \ i2-1 do\n      table.insert(r, o[i])\n   end\n   return r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {'Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n\tlocal p1, p2 = table.index_of(planets,\
    \ planet1), table.index_of(planets, planet2)\n\tif p1 == nil or p2 == nil then\n\
    \t\treturn {}\n\tend\n\tif p1 > p2 then\n\t\tp1, p2 = p2, p1\n\tend\n\treturn\
    \ table.slice(planets, p1 + 1, p2)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpyevpqypi.lua:16:\
    \ attempt to call a nil value (field 'index_of')\nstack traceback:\n\t/tmp/tmpyevpqypi.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpyevpqypi.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local start =\
    \ table.indexOf(planets, planet1)\n  local stop = table.indexOf(planets, planet2)\n\
    \  if start == nil or stop == nil then return {} end\n  if start > stop then start,\
    \ stop = stop, start end\n  return table.slice(planets, start + 1, stop)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0dxa8vuf.lua:16:\
    \ attempt to call a nil value (field 'indexOf')\nstack traceback:\n\t/tmp/tmp0dxa8vuf.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmp0dxa8vuf.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local planet1Index\
    \ = 0\n  local planet2Index = 0\n  for i = 1, 8 do\n    if planets[i] == planet1\
    \ then\n      planet1Index = i\n    end\n    if planets[i] == planet2 then\n \
    \     planet2Index = i\n    end\n  end\n  local result = {}\n  if planet1Index\
    \ == 0 or planet2Index == 0 then\n    return result\n  end\n  local minIndex =\
    \ math.min(planet1Index, planet2Index)\n  local maxIndex = math.max(planet1Index,\
    \ planet2Index)\n  for i = minIndex + 1, maxIndex - 1 do\n    table.insert(result,\
    \ planets[i])\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local t = {}\n\
    \    for i = 1, #planets do\n        if planets[i] == planet1 then\n         \
    \   local j = i\n            while j < #planets do\n                if planets[j\
    \ + 1] == planet2 then\n                    return table.unpack(t)\n         \
    \       end\n                table.insert(t, planets[j + 1])\n               \
    \ j = j + 1\n            end\n        end\n    end\n    return nil\nend\nprint(bf(\"\
    Mercury\", \"Uranus\"))\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "Venus\tEarth\tMars\tJupiter\tSaturn\nF\nFailed tests:\n-------------\n\
    1) test_humaneval\n/tmp/tmpwnba172e.lua:36: expected: {\"Saturn\", \"Uranus\"\
    }\nactual: \"Saturn\"\nstack traceback:\n\t/tmp/tmpwnba172e.lua:36: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- body\n  local planets = {\"Mercury\", \"Venus\",\
    \ \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local\
    \ first_p_index, second_p_index, result = nil, nil, {}\n  for i,v in ipairs(planets)\
    \ do\n    if v == planet1 then\n      first_p_index = i\n    end\n    if v ==\
    \ planet2 then\n      second_p_index = i\n    end\n  end\n  if first_p_index ==\
    \ nil or second_p_index == nil then\n    return result\n  end\n  local start,\
    \ limit = nil, nil\n  if first_p_index < second_p_index then\n    start = first_p_index\
    \ + 1\n    limit = second_p_index - 1\n  else\n    start = second_p_index + 1\n\
    \    limit = first_p_index - 1\n  end\n  if start == 8 then\n    return result\n\
    \  end\n  for i = start, limit do\n    table.insert(result, planets[i])\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local solar_system = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local start_idx,\
    \ end_idx\n    for i, planet in ipairs(solar_system) do\n        if planet ==\
    \ planet1 then\n            start_idx = i\n        end\n        if planet == planet2\
    \ then\n            end_idx = i\n        end\n    end\n    if start_idx and end_idx\
    \ then\n        local planets = {}\n        if start_idx > end_idx then\n    \
    \        local tmp = start_idx\n            start_idx = end_idx\n            end_idx\
    \ = tmp\n        end\n        for i = start_idx, end_idx do\n            if i\
    \ ~= start_idx and i ~= end_idx then\n                table.insert(planets, solar_system[i])\n\
    \            end\n        end\n        return planets\n    else\n        return\
    \ {}\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local list = {\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local j = 0\n  local\
    \ k = 0\n  local res = {}\n  for i = 1, #list do\n    if list[i] == planet1 then\n\
    \      j = i\n    end\n    if list[i] == planet2 then\n      k = i\n    end\n\
    \  end\n  if j ~= 0 and k ~= 0 then\n    for i = j + 1, k - 1 do\n      table.insert(res,\
    \ list[i])\n    end\n  end\n  return unpack(res)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp756nv5zu.lua:32:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmp756nv5zu.lua:32:\
    \ in local 'candidate'\n\t/tmp/tmp756nv5zu.lua:38: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local orbits = {Mercury = 1, Venus = 2, Earth = 3, Mars\
    \ = 4, Jupiter = 5, Saturn = 6, Uranus = 7, Neptune = 8}\n  if (orbits[planet1]\
    \ == nil or orbits[planet2] == nil) then return {} end\n  if (orbits[planet1]\
    \ == orbits[planet2]) then return {} end\n  local planets = {}\n  for k, v in\
    \ pairs(orbits) do\n    if (orbits[planet1] < orbits[planet2]) then\n      if\
    \ (v > orbits[planet1] and v < orbits[planet2]) then\n        table.insert(planets,\
    \ k)\n      end\n    else\n      if (v < orbits[planet1] and v > orbits[planet2])\
    \ then\n        table.insert(planets, k)\n      end\n    end\n  end\n  return\
    \ planets\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpjm4zgyk8.lua:36:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Uranus\", \"Saturn\"}\nstack\
    \ traceback:\n\t/tmp/tmpjm4zgyk8.lua:36: in function 'test_humaneval'\n\nRan 1\
    \ tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local solarsystem = { \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" }\n  local orbit1\
    \ = table.indexOf(solarsystem, planet1)\n  local orbit2 = table.indexOf(solarsystem,\
    \ planet2)\n  if orbit1 == nil or orbit2 == nil then return {} end\n  if orbit1\
    \ > orbit2 then orbit1, orbit2 = orbit2, orbit1 end\n  return solarsystem:slice(orbit1\
    \ + 1, orbit2)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpiyhamdun.lua:16:\
    \ attempt to call a nil value (field 'indexOf')\nstack traceback:\n\t/tmp/tmpiyhamdun.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpiyhamdun.lua:26: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {Mercury = 1, Venus = 2, Earth = 3,\
    \ Mars = 4, Jupiter = 5, Saturn = 6, Uranus = 7, Neptune = 8}\n  local result\
    \ = {}\n  if planets[planet1] and planets[planet2] then\n    local start = math.min(planets[planet1],\
    \ planets[planet2])\n    local stop = math.max(planets[planet1], planets[planet2])\n\
    \    for planet, pos in pairs(planets) do\n      if pos > start and pos < stop\
    \ then\n        table.insert(result, planet)\n      end\n    end\n  end\n  return\
    \ unpack(result)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpzbqy1req.lua:26:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpzbqy1req.lua:26:\
    \ in local 'candidate'\n\t/tmp/tmpzbqy1req.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal solarSystem = {\n\t\t\"Mercury\",\n\t\t\"Venus\"\
    ,\n\t\t\"Earth\",\n\t\t\"Mars\",\n\t\t\"Jupiter\",\n\t\t\"Saturn\",\n\t\t\"Uranus\"\
    ,\n\t\t\"Neptune\"\n\t}\n\tlocal orbit1 = 0\n\tlocal orbit2 = 0\n\tfor i, v in\
    \ ipairs(solarSystem) do\n\t\tif v == planet1 then\n\t\t\torbit1 = i\n\t\tend\n\
    \t\tif v == planet2 then\n\t\t\torbit2 = i\n\t\tend\n\tend\n\tif orbit1 == 0 or\
    \ orbit2 == 0 then\n\t\treturn {}\n\tend\n\tlocal ret = {}\n\tif orbit1 < orbit2\
    \ then\n\t\tfor i = orbit1 + 1, orbit2 - 1 do\n\t\t\ttable.insert(ret, solarSystem[i])\n\
    \t\tend\n\telse\n\t\tfor i = orbit2 + 1, orbit1 - 1 do\n\t\t\ttable.insert(ret,\
    \ solarSystem[i])\n\t\tend\n\tend\n\treturn ret\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  return {}\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsfagggu5.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpsfagggu5.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {[\"Mercury\"] = 1, [\"Venus\"] =\
    \ 2, [\"Earth\"] = 3, [\"Mars\"] = 4, [\"Jupiter\"] = 5, [\"Saturn\"] = 6, [\"\
    Uranus\"] = 7, [\"Neptune\"] = 8}\n    local sort_planets = {}\n    local bf_planets\
    \ = {}\n    local min, max = math.min(planets[planet1], planets[planet2]), math.max(planets[planet1],\
    \ planets[planet2])\n    if (planets[planet1] == nil or planets[planet2] == nil)\
    \ then\n        return {}\n    end\n    for i = min, max do\n        for k, v\
    \ in pairs(planets) do\n            if (v == i) then\n                table.insert(sort_planets,\
    \ k)\n            end\n        end\n    end\n    for i = 1, #sort_planets do\n\
    \        table.insert(bf_planets, sort_planets[i])\n    end\n    return bf_planets\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc52syd6k.lua:38:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\nstack traceback:\n\t/tmp/tmpc52syd6k.lua:38: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local o = {\n        Mercury = 1,\n        Venus =\
    \ 2,\n        Earth = 3,\n        Mars = 4,\n        Jupiter = 5,\n        Saturn\
    \ = 6,\n        Uranus = 7,\n        Neptune = 8\n    }\n    if o[planet1] and\
    \ o[planet2] then\n        if o[planet1] < o[planet2] then\n            local\
    \ t = {}\n            for k, v in pairs(o) do\n                if v > o[planet1]\
    \ and v < o[planet2] then\n                    table.insert(t, k)\n          \
    \      end\n            end\n            return unpack(t)\n        else\n    \
    \        local t = {}\n            for k, v in pairs(o) do\n                if\
    \ v > o[planet2] and v < o[planet1] then\n                    table.insert(t,\
    \ k)\n                end\n            end\n            return unpack(t)\n   \
    \     end\n    else\n        return ()\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp1ar_4y76.lua:44: unexpected symbol near ')'\n"
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local t = {'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter',\
    \ 'Saturn', 'Uranus', 'Neptune'}\n    local index_p1 = table.indexof(t, planet1)\n\
    \    local index_p2 = table.indexof(t, planet2)\n    local slice\n    if index_p1\
    \ and index_p2 then\n        slice = table.slice(t, index_p1, index_p2)\n    end\n\
    \    return slice\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpezhu8vxt.lua:16:\
    \ attempt to call a nil value (field 'indexof')\nstack traceback:\n\t/tmp/tmpezhu8vxt.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpezhu8vxt.lua:28: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = { \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" }\n    local planets_rev\
    \ = table.reverse(planets)\n    local found1, found2\n    for i,v in ipairs(planets)\
    \ do\n        if planet1 == v then\n            found1 = i\n        end\n    \
    \    if planet2 == v then\n            found2 = i\n        end\n    end\n    if\
    \ not found1 or not found2 then\n        return {}\n    end\n    local s\n   \
    \ if found1 < found2 then\n        s = planets\n    else\n        s = planets_rev\n\
    \    end\n    local ret = {}\n    for i = found1, found2 do\n        table.insert(ret,\
    \ s[i])\n    end\n    return table.unpack(ret)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpscpkt2fv.lua:16:\
    \ attempt to call a nil value (field 'reverse')\nstack traceback:\n\t/tmp/tmpscpkt2fv.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpscpkt2fv.lua:45: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local between = {}\n    local order = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n    local min = 0\n    local max = 0\n    for i = 1, 8 do\n        if order[i]\
    \ == planet1 then\n            min = i\n        end\n        if order[i] == planet2\
    \ then\n            max = i\n        end\n    end\n    if min == 0 or max == 0\
    \ then\n        return between\n    end\n    if min > max then\n        local\
    \ temp = min\n        min = max\n        max = temp\n    end\n    for i = min\
    \ + 1, max - 1 do\n        table.insert(between, order[i])\n    end\n    return\
    \ between\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\n\t\tMercury = 1,\n\t\tVenus = 2,\n\
    \t\tEarth = 3,\n\t\tMars = 4,\n\t\tJupiter = 5,\n\t\tSaturn = 6,\n\t\tUranus =\
    \ 7,\n\t\tNeptune = 8\n\t}\n\tlocal planets = {\n\t\tMercury = 1,\n\t\tVenus =\
    \ 2,\n\t\tEarth = 3,\n\t\tMars = 4,\n\t\tJupiter = 5,\n\t\tSaturn = 6,\n\t\tUranus\
    \ = 7,\n\t\tNeptune = 8\n\t}\n\tlocal planets = {\n\t\tMercury = 1,\n\t\tVenus\
    \ = 2,\n\t\tEarth = 3,\n\t\tMars = 4,\n\t\tJupiter = 5,\n\t\tSaturn = 6,\n\t\t\
    Uranus = 7,\n\t\tNeptune = 8\n\t}\n\tif planets[planet1] == nil or planets[planet2]\
    \ == nil then\n\t\treturn {}\n\tend\n\tlocal result = {}\n\tlocal first = math.min(planets[planet1],\
    \ planets[planet2])\n\tlocal last = math.max(planets[planet1], planets[planet2])\n\
    \tfor k, v in pairs(planets) do\n\t\tif v >= first and v <= last then\n\t\t\t\
    table.insert(result, k)\n\t\tend\n\tend\n\treturn result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnqllz6xu.lua:62:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Neptune\", \"Uranus\", \"Saturn\"\
    , \"Jupiter\"}\nstack traceback:\n\t/tmp/tmpnqllz6xu.lua:62: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local tbl = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local pos_planet1 = table.index_of(tbl,\
    \ planet1)\n  local pos_planet2 = table.index_of(tbl, planet2)\n  if pos_planet1\
    \ == -1 or pos_planet2 == -1 then\n    return {}\n  end\n  local result = {}\n\
    \  if pos_planet1 < pos_planet2 then\n    for i = pos_planet1 + 1, pos_planet2\
    \ - 1 do\n      table.insert(result, tbl[i])\n    end\n  else\n    for i = pos_planet2\
    \ + 1, pos_planet1 - 1 do\n      table.insert(result, tbl[i])\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpmo3607n8.lua:16:\
    \ attempt to call a nil value (field 'index_of')\nstack traceback:\n\t/tmp/tmpmo3607n8.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpmo3607n8.lua:37: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\n\t\t\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n\t}\n\tlocal function\
    \ get_index(planet)\n\t\tfor i,v in ipairs(planets) do\n\t\t\tif v == planet then\n\
    \t\t\t\treturn i\n\t\t\tend\n\t\tend\n\t\treturn -1\n\tend\n\tlocal start_index\
    \ = get_index(planet1)\n\tlocal end_index = get_index(planet2)\n\tlocal i_min\
    \ = math.min(start_index, end_index)\n\tlocal i_max = math.max(start_index, end_index)\n\
    \tlocal result = {}\n\tfor i = i_min + 1, i_max - 1 do\n\t\ttable.insert(result,\
    \ planets[i])\n\tend\n\treturn unpack(result)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpr9q1qrz7.lua:34:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpr9q1qrz7.lua:34:\
    \ in local 'candidate'\n\t/tmp/tmpr9q1qrz7.lua:40: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_agtt784.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmp_agtt784.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- your code here\n  local planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n  local res = {}\n  local p1, p2\n  for i, planet in ipairs(planets) do\n \
    \   if planet == planet1 then\n      p1 = i\n    end\n    if planet == planet2\
    \ then\n      p2 = i\n    end\n  end\n  if p1 == nil or p2 == nil then\n    return\
    \ {}\n  end\n  for i, planet in ipairs(planets) do\n    if (p1<p2 and i > p1 and\
    \ i < p2) or (p1>p2 and i < p1 and i > p2) then\n      table.insert(res, planet)\n\
    \    end\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal p1, p2,\
    \ r\n\tlocal i, j\n\tp1 = table.getIndex(planets, planet1)\n\tp2 = table.getIndex(planets,\
    \ planet2)\n\tif p1 == nil or p2 == nil then\n\t\treturn {}\n\tend\n\tif p1 >\
    \ p2 then\n\t\tp1, p2 = p2, p1\n\tend\n\tr = {}\n\tfor i = p1+1, p2-1 do\n\t\t\
    table.insert(r, planets[i])\n\tend\n\treturn r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpk5ajunb3.lua:18:\
    \ attempt to call a nil value (field 'getIndex')\nstack traceback:\n\t/tmp/tmpk5ajunb3.lua:18:\
    \ in local 'candidate'\n\t/tmp/tmpk5ajunb3.lua:36: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n   local planets = {\n      [\"Mercury\"] = 1,\n     \
    \ [\"Venus\"] = 2,\n      [\"Earth\"] = 3,\n      [\"Mars\"] = 4,\n      [\"Jupiter\"\
    ] = 5,\n      [\"Saturn\"] = 6,\n      [\"Uranus\"] = 7,\n      [\"Neptune\"]\
    \ = 8\n   }\n   local p1 = planets[planet1]\n   local p2 = planets[planet2]\n\
    \   if p1 and p2 then\n      if p1 > p2 then\n         p1, p2 = p2, p1\n     \
    \ end\n      local result = {}\n      for k, v in pairs(planets) do\n        \
    \ if v > p1 and v < p2 then\n            table.insert(result, k)\n         end\n\
    \      end\n      return unpack(result)\n   end\n   return ()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpadjw3kb5.lua:39: unexpected symbol near ')'\n"
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local orbit = {\n        Mercury = 1, Venus = 2, Earth\
    \ = 3, Mars = 4, Jupiter = 5, Saturn = 6,\n        Uranus = 7, Neptune = 8\n \
    \   }\n    if not orbit[planet1] or not orbit[planet2] then return {} end\n  \
    \  local rst = {}\n    local p1, p2 = orbit[planet1], orbit[planet2]\n    if p1\
    \ > p2 then\n        p1, p2 = p2, p1\n    end\n    for k, v in pairs(orbit) do\n\
    \        if v > p1 and v < p2 then\n            table.insert(rst, k)\n       \
    \ end\n    end\n    return rst\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpqsuqwiwh.lua:36:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Uranus\", \"Saturn\"}\nstack\
    \ traceback:\n\t/tmp/tmpqsuqwiwh.lua:36: in function 'test_humaneval'\n\nRan 1\
    \ tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal function getIndex(planet)\n\t\tlocal planets =\
    \ {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n\t\tfor i, v in ipairs(planets) do\n\t\t\tif v == planet then\n\
    \t\t\t\treturn i\n\t\t\tend\n\t\tend\n\t\treturn nil\n\tend\n\tlocal index1 =\
    \ getIndex(planet1)\n\tlocal index2 = getIndex(planet2)\n\tif index1 == nil or\
    \ index2 == nil then\n\t\treturn {}\n\tend\n\tlocal planets = {\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n\tlocal first = math.min(index1, index2)\n\tlocal last = math.max(index1, index2)\n\
    \tlocal ret = {}\n\tfor i = first + 1, last - 1 do\n\t\ttable.insert(ret, planets[i])\n\
    \tend\n\treturn ret\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local planet1Number = planets[planet1]\n  local\
    \ planet2Number = planets[planet2]\n  if planet1Number == nil or planet2Number\
    \ == nil then\n    return {}\n  end\n  local result = {}\n  for k, v in pairs(planets)\
    \ do\n    if (planet1Number < planet2Number and v > planet1Number and v < planet2Number)\
    \ or (planet1Number > planet2Number and v < planet1Number and v > planet2Number)\
    \ then\n      table.insert(result, k)\n    end\n  end\n  return result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplhl8mwf9.lua:44:\
    \ expected: {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nactual:\
    \ {\"Jupiter\", \"Mars\", \"Saturn\", \"Earth\", \"Venus\"}\nstack traceback:\n\
    \t/tmp/tmplhl8mwf9.lua:44: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local idx1, idx2 = nil, nil\n  local arr = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n  for i, v in ipairs(arr) do\n    if v == planet1 then\n      idx1 = i\n  \
    \  end\n    if v == planet2 then\n      idx2 = i\n    end\n  end\n  if idx1 ==\
    \ nil or idx2 == nil then\n    return {}\n  end\n  local start = idx1\n  local\
    \ stop = idx2\n  if idx1 > idx2 then\n    start = idx2\n    stop = idx1\n  end\n\
    \  local ret = {}\n  for i = start + 1, stop - 1 do\n    table.insert(ret, arr[i])\n\
    \  end\n  return ret\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local orbit_start\
    \ = -1\n  local orbit_end = -1\n  for i = 1, #planets do\n    if planets[i] ==\
    \ planet1 then\n      orbit_start = i\n    end\n    if planets[i] == planet2 then\n\
    \      orbit_end = i\n    end\n  end\n  if orbit_start == -1 or orbit_end == -1\
    \ then\n    return {}\n  end\n  local out = {}\n  for i = orbit_start + 1, orbit_end\
    \ - 1 do\n    table.insert(out, planets[i])\n  end\n  return out\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpookr_z6x.lua:40:\
    \ expected: {\"Venus\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpookr_z6x.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpf3jku4o9.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmpf3jku4o9.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\treturn nil\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcbefo491.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmpcbefo491.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local pos1, pos2\n\
    \  for i, v in ipairs(planets) do\n    if v == planet1 then pos1 = i\n    elseif\
    \ v == planet2 then pos2 = i end\n  end\n  if pos1 == nil or pos2 == nil then\
    \ return {} end\n  if pos1 > pos2 then pos1, pos2 = pos2, pos1 end\n  return {unpack(planets,\
    \ pos1+1, pos2-1)}\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmphzoonsla.lua:23:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmphzoonsla.lua:23:\
    \ in local 'candidate'\n\t/tmp/tmphzoonsla.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  if planets[planet1] and planets[planet2] then\n    local\
    \ between = {}\n    local sorted = {}\n    local start = planets[planet1] < planets[planet2]\
    \ and planet1 or planet2\n    local stop = planets[planet1] < planets[planet2]\
    \ and planet2 or planet1\n    for i = planets[start], planets[stop] do\n     \
    \ between[#between + 1] = planetsByDistance[i]\n    end\n    for i = #between,\
    \ 1, -1 do\n      sorted[#sorted + 1] = between[i]\n    end\n    return unpack(sorted)\n\
    \  end\n  return nil\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpfmm4dmyy.lua:15:\
    \ attempt to index a nil value (global 'planets')\nstack traceback:\n\t/tmp/tmpfmm4dmyy.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpfmm4dmyy.lua:34: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local order = {\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local first, last\
    \ = 0, 0\n  for i, p in ipairs(order) do\n    if p == planet1 then first = i end\n\
    \    if p == planet2 then last = i end\n  end\n  if first == 0 or last == 0 then\
    \ return {} end\n  if first < last then\n    return {unpack(order, first+1, last-1)}\n\
    \  else\n    return {unpack(order, last+1, first-1)}\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpsdewgk3m.lua:23:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpsdewgk3m.lua:23:\
    \ in local 'candidate'\n\t/tmp/tmpsdewgk3m.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local rev = false\n    local systems = {\n       \
    \ Mercury = 1, Venus = 2, Earth = 3, Mars = 4, Jupiter = 5, Saturn = 6, Uranus\
    \ = 7, Neptune = 8\n    }\n    if not systems[planet1] or not systems[planet2]\
    \ then\n        return {}\n    end\n    if systems[planet1] > systems[planet2]\
    \ then\n        rev = true\n        planet1, planet2 = planet2, planet1\n    end\n\
    \    local t = {}\n    for k, v in pairs(systems) do\n        if v > systems[planet1]\
    \ and v < systems[planet2] then\n            table.insert(t, k)\n        end\n\
    \    end\n    if rev then\n        return t\n    else\n        return table.reverse(t)\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp0ofuq5qr.lua:35:\
    \ attempt to call a nil value (field 'reverse')\nstack traceback:\n\t/tmp/tmp0ofuq5qr.lua:35:\
    \ in local 'candidate'\n\t/tmp/tmp0ofuq5qr.lua:42: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local result = {}\n  if planets[planet1] and planets[planet2]\
    \ then\n    local min_planet, max_planet = planet1, planet2\n    if planets[planet1]\
    \ > planets[planet2] then\n      min_planet, max_planet = planet2, planet1\n \
    \   end\n    for planet, pos in pairs(planets) do\n      if pos > planets[min_planet]\
    \ and pos < planets[max_planet] then\n        table.insert(result, planet)\n \
    \     end\n    end\n  end\n  return unpack(result)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgq0sjxpk.lua:16:\
    \ attempt to index a nil value (global 'planets')\nstack traceback:\n\t/tmp/tmpgq0sjxpk.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpgq0sjxpk.lua:33: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    table.sort(planets)\n\
    \    p1 = table.index_of(planets, planet1)\n    p2 = table.index_of(planets, planet2)\n\
    \    if p1 < 0 or p2 < 0 then\n        return {}\n    end\n    if p1 > p2 then\n\
    \        p1, p2 = p2, p1\n    end\n    return table.sub(planets, p1 + 1, p2 -\
    \ 1)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4emld5dk.lua:17:\
    \ attempt to call a nil value (field 'index_of')\nstack traceback:\n\t/tmp/tmp4emld5dk.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmp4emld5dk.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    -- write the body of the function here\n    local\
    \ planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"}\n    local pos1, pos2, result = 0, 0, {}\n    for i\
    \ = 1, 8 do\n        if planet1 == planets[i] then\n            pos1 = i\n   \
    \     end\n        if planet2 == planets[i] then\n            pos2 = i\n     \
    \   end\n    end\n    if pos1 == 0 or pos2 == 0 then\n        return {}\n    end\n\
    \    if pos1 < pos2 then\n        for i = pos1 + 1, pos2 do\n            table.insert(result,\
    \ planets[i])\n        end\n    else\n        for i = pos1 - 1, pos2, -1 do\n\
    \            table.insert(result, planets[i])\n        end\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpn_qv165_.lua:44:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Saturn\", \"Uranus\", \"Neptune\"\
    }\nstack traceback:\n\t/tmp/tmpn_qv165_.lua:44: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal n1, n2 = 0, 0\n\tlocal pl = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tfor\
    \ i, v in ipairs(pl) do\n\t\tif v == planet1 then n1 = i end\n\t\tif v == planet2\
    \ then n2 = i end\n\tend\n\tif (n1 > n2) then return \"The orbit of planet2 must\
    \ be closer to the sun than the orbit of planet1\" end\n\tif (n1 == 0 or n2 ==\
    \ 0) then return \"One of the planets is not in our solar system\" end\n\treturn\
    \ table.unpack(pl, n1+1, n2-1)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpggpzxgmg.lua:29:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: \"Saturn\"\nstack traceback:\n\t\
    /tmp/tmpggpzxgmg.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tif planet1=='Mercury' then\n\t\tif planet2=='Venus'\
    \ then return ('Mercury')\n\t\telseif planet2=='Earth' then return ('Mercury',\
    \ 'Venus')\n\t\telseif planet2=='Mars' then return ('Mercury', 'Venus', 'Earth')\n\
    \t\telseif planet2=='Jupiter' then return ('Mercury', 'Venus', 'Earth', 'Mars')\n\
    \t\telseif planet2=='Saturn' then return ('Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter')\n\t\telseif planet2=='Uranus' then return ('Mercury', 'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn')\n\t\telseif planet2=='Neptune' then return ('Mercury',\
    \ 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus')\n\t\telse return ()\n\
    \t\tend\n\telseif planet1=='Venus' then\n\t\tif planet2=='Earth' then return ('Venus')\n\
    \t\telseif planet2=='Mars' then return ('Venus', 'Earth')\n\t\telseif planet2=='Jupiter'\
    \ then return ('Venus', 'Earth', 'Mars')\n\t\telseif planet2=='Saturn' then return\
    \ ('Venus', 'Earth', 'Mars', 'Jupiter')\n\t\telseif planet2=='Uranus' then return\
    \ ('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')\n\t\telseif planet2=='Neptune'\
    \ then return ('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus')\n\t\t\
    else return ()\n\t\tend\n\telseif planet1=='Earth' then\n\t\tif planet2=='Mars'\
    \ then return ('Earth')\n\t\telseif planet2=='Jupiter' then return ('Earth', 'Mars')\n\
    \t\telseif planet2=='Saturn' then return ('Earth', 'Mars', 'Jupiter')\n\t\telseif\
    \ planet2=='Uranus' then return ('Earth', 'Mars', 'Jupiter', 'Saturn')\n\t\telseif\
    \ planet2=='Ne\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpkfp0begx.lua:17: ')' expected near ','\n"
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt4fcjc9i.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmpt4fcjc9i.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    -- Write your code here ...\n    local solar = {'Mercury',\
    \ 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n    local\
    \ result = {}\n    local i1, i2 = 0, 0\n    local min, max = 0, 0\n    for i,v\
    \ in ipairs(solar) do\n        if planet1 == v then\n            i1 = i\n    \
    \    end\n        if planet2 == v then\n            i2 = i\n        end\n    end\n\
    \    if i1 == 0 or i2 == 0 then\n        return {}\n    end\n    min = i1\n  \
    \  max = i2\n    if i1 > i2 then\n        min = i2\n        max = i1\n    end\n\
    \    for i=min+1, max-1 do\n        table.insert(result, solar[i])\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal p1, p2\
    \ = 0, 0\n\tlocal i = 1\n\tlocal res = {}\n\twhile i <= #planets do\n\t\tif planets[i]\
    \ == planet1 then\n\t\t\tp1 = i\n\t\tend\n\t\tif planets[i] == planet2 then\n\t\
    \t\tp2 = i\n\t\tend\n\t\ti = i + 1\n\tend\n\tif p1 == 0 or p2 == 0 then\n\t\t\
    return {}\n\tend\n\tif p1 < p2 then\n\t\ti = p1 + 1\n\t\twhile i < p2 do\n\t\t\
    \ttable.insert(res, planets[i])\n\t\t\ti = i + 1\n\t\tend\n\telse\n\t\ti = p2\
    \ + 1\n\t\twhile i < p1 do\n\t\t\ttable.insert(res, planets[i])\n\t\t\ti = i +\
    \ 1\n\t\tend\n\tend\n\treturn unpack(res)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpqm0kuny4.lua:44:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpqm0kuny4.lua:44:\
    \ in local 'candidate'\n\t/tmp/tmpqm0kuny4.lua:50: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local orbitals = {[\"Mercury\"] = 1, [\"Venus\"] =\
    \ 2, [\"Earth\"] = 3, [\"Mars\"] = 4, [\"Jupiter\"] = 5, [\"Saturn\"] = 6, [\"\
    Uranus\"] = 7, [\"Neptune\"] = 8}\n    local planet1i = orbitals[planet1]\n  \
    \  local planet2i = orbitals[planet2]\n    local planets_list = {}\n    if planet1i\
    \ and planet2i then\n        if planet1i < planet2i then\n            for i =\
    \ planet1i + 1, planet2i - 1 do\n                table.insert(planets_list, (function(i)\
    \ for planet, orbital in pairs(orbitals) do if orbital == i then return planet\
    \ end end end)(i))\n            end\n        else\n            for i = planet2i\
    \ + 1, planet1i - 1 do\n                table.insert(planets_list, (function(i)\
    \ for planet, orbital in pairs(orbitals) do if orbital == i then return planet\
    \ end end end)(i))\n            end\n        end\n    end\n    return planets_list\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1, Venus = 2, Earth\
    \ = 3, Mars = 4, Jupiter = 5, \n    Saturn = 6, Uranus = 7, Neptune = 8}\n  local\
    \ t = {}\n  if planets[planet1] and planets[planet2] then\n    for p in pairs(planets)\
    \ do\n      if planets[p] >= planets[planet1] and planets[p] <= planets[planet2]\
    \ then\n        table.insert(t, p)\n      end\n    end\n  end\n  return unpack(t)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpf2cta8mu.lua:26:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpf2cta8mu.lua:26:\
    \ in local 'candidate'\n\t/tmp/tmpf2cta8mu.lua:32: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local solarSystem = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local i = 0\n\
    \  local j = 0\n  local planets = {}\n  for k, v in ipairs(solarSystem) do\n \
    \   if planet1 == v then\n      i = k\n    end\n    if planet2 == v then\n   \
    \   j = k\n    end\n  end\n  if i == 0 or j == 0 then\n    return ()\n  end\n\
    \  if i > j then\n    for k = j, i do\n      planets[#planets + 1] = solarSystem[k]\n\
    \    end\n  else\n    for k = i, j do\n      planets[#planets + 1] = solarSystem[k]\n\
    \    end\n  end\n  return unpack(planets)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp0o8ry1sd.lua:28: unexpected symbol near ')'\n"
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i = 1, #planets do\n    if planets[i] == planet1 then p1 = i end\n\
    \    if planets[i] == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0\
    \ then return {} end\n  if p1 > p2 then return bf(planet2, planet1) end\n  return\
    \ {unpack(planets, p1 + 1, p2 - 1)}\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgyufvsfq.lua:23:\
    \ attempt to call a nil value (global 'unpack')\nstack traceback:\n\t/tmp/tmpgyufvsfq.lua:23:\
    \ in local 'candidate'\n\t/tmp/tmpgyufvsfq.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    -- your code here\n    local planets = {\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n    local p1, p2\n    for i, v in ipairs(planets) do\n        if v == planet1\
    \ then\n            p1 = i\n        end\n        if v == planet2 then\n      \
    \      p2 = i\n        end\n    end\n    if not p1 or not p2 then\n        return\
    \ {}\n    end\n    local res = {}\n    for i = p1, p2 do\n        table.insert(res,\
    \ planets[i])\n    end\n    return res\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxg6sxid1.lua:39:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\nstack traceback:\n\t/tmp/tmpxg6sxid1.lua:39: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal function getPlanet(planet)\n\t\tlocal planets\
    \ = {\n\t\t\t[\"Mercury\"] = 1,\n\t\t\t[\"Venus\"] = 2,\n\t\t\t[\"Earth\"] = 3,\n\
    \t\t\t[\"Mars\"] = 4,\n\t\t\t[\"Jupiter\"] = 5,\n\t\t\t[\"Saturn\"] = 6,\n\t\t\
    \t[\"Uranus\"] = 7,\n\t\t\t[\"Neptune\"] = 8\n\t\t}\n\t\tif planets[planet] ==\
    \ nil then return false end\n\t\treturn planets[planet]\n\tend\n\tlocal planet1\
    \ = getPlanet(planet1)\n\tlocal planet2 = getPlanet(planet2)\n\tif planet1 ==\
    \ false or planet2 == false then return {} end\n\tlocal r = {}\n\tif planet1 >\
    \ planet2 then\n\t\tfor i = planet2, planet1 do\n\t\t\tfor planet, num in pairs(getPlanet)\
    \ do\n\t\t\t\tif num == i then\n\t\t\t\t\ttable.insert(r, planet)\n\t\t\t\tend\n\
    \t\t\tend\n\t\tend\n\telse\n\t\tfor i = planet1, planet2 do\n\t\t\tfor planet,\
    \ num in pairs(getPlanet) do\n\t\t\t\tif num == i then\n\t\t\t\t\ttable.insert(r,\
    \ planet)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn r\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp3m6drffx.lua:43:\
    \ bad argument #1 to 'for iterator' (table expected, got function)\nstack traceback:\n\
    \t/tmp/tmp3m6drffx.lua:43: in local 'candidate'\n\t/tmp/tmp3m6drffx.lua:56: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i,v in ipairs(planets) do\n    if planet1 == v then p1 = i end\n\
    \    if planet2 == v then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ end\n  local t = {}\n  for i = p1, p2 do\n    if i == p1 then i = i + 1 end\n\
    \    if i == p2 then break end\n    table.insert(t, planets[i])\n  end\n  return\
    \ table.unpack(t)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpav_qyuet.lua:34:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: \"Saturn\"\nstack traceback:\n\t\
    /tmp/tmpav_qyuet.lua:34: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal order = {\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal p1, p2 = order[planet1],\
    \ order[planet2]\n\tif p1 == nil or p2 == nil then return {} end\n\tlocal planets\
    \ = {}\n\tfor i = p1, p2 do \n\t\ttable.insert(planets, i)\n\tend\n\treturn planets\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsl0goo_r.lua:28:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpsl0goo_r.lua:28:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  -- your code here\n  local list = {\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local\
    \ ind1 = 0\n  local ind2 = 0\n  local res = {}\n  for k,v in pairs(list) do\n\
    \    if v == planet1 then\n      ind1 = k\n    end\n    if v == planet2 then\n\
    \      ind2 = k\n    end\n  end\n  if ind1 == 0 or ind2 == 0 then\n    return\
    \ {}\n  end\n  if ind1 > ind2 then\n    ind1, ind2 = ind2, ind1\n  end\n  for\
    \ i = ind1 + 1, ind2 - 1 do\n    table.insert(res, list[i])\n  end\n  return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  return \"Not implemented\"\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpakreytsj.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: \"Not implemented\"\nstack traceback:\n\
    \t/tmp/tmpakreytsj.lua:21: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {'Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n  local p1 = table.find(planets,\
    \ planet1)\n  local p2 = table.find(planets, planet2)\n  if not p1 or not p2 then\
    \ return {} end\n  local t = {}\n  local start, finish = p1, p2\n  if p1 > p2\
    \ then start, finish = p2, p1 end\n  for i = start+1, finish-1 do\n    table.insert(t,\
    \ planets[i])\n  end\n  return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp7xy3w5_o.lua:16:\
    \ attempt to call a nil value (field 'find')\nstack traceback:\n\t/tmp/tmp7xy3w5_o.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmp7xy3w5_o.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = { \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" }\n  local x, y =\
    \ table.indexof(planets, planet1), table.indexof(planets, planet2)\n  if x < y\
    \ then return table.sub(planets, x + 1, y - 1)\n  elseif x > y then return table.sub(planets,\
    \ y + 1, x - 1)\n  else return {} end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6oqpbyl8.lua:16:\
    \ attempt to call a nil value (field 'indexof')\nstack traceback:\n\t/tmp/tmp6oqpbyl8.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmp6oqpbyl8.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local function getIndex(name)\n    local planets = {\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    for i, v in ipairs(planets) do\n      if v == name then\n\
    \        return i\n      end\n    end\n    return 0\n  end\n  local x, y = getIndex(planet1),\
    \ getIndex(planet2)\n  if x == 0 or y == 0 then\n    return {}\n  end\n  local\
    \ min, max = math.min(x, y), math.max(x, y)\n  local res = {}\n  for i = min +\
    \ 1, max - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp6ax3pw98.lua:31:\
    \ attempt to index a nil value (global 'planets')\nstack traceback:\n\t/tmp/tmp6ax3pw98.lua:31:\
    \ in local 'candidate'\n\t/tmp/tmp6ax3pw98.lua:39: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1index,\
    \ p2index = 0, 0\n  for index, value in ipairs(planets) do\n    if value == planet1\
    \ then\n      p1index = index\n    end\n    if value == planet2 then\n      p2index\
    \ = index\n    end\n  end\n  if p1index == 0 or p2index == 0 then\n    return\
    \ {}\n  end\n  local res = {}\n  for i = p1index, p2index do\n    if i ~= p1index\
    \ and i ~= p2index then\n      table.insert(res, planets[i])\n    end\n  end\n\
    \  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt34fykls.lua:41:\
    \ expected: {\"Venus\"}\nactual: {}\nstack traceback:\n\t/tmp/tmpt34fykls.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1, Venus = 2, Earth\
    \ = 3, Mars = 4, Jupiter = 5, Saturn = 6,\n    Uranus = 7, Neptune = 8\n  }\n\
    \  if not planets[planet1] or not planets[planet2] then return {} end\n  local\
    \ p1, p2 = planets[planet1], planets[planet2]\n  if p1 > p2 then p1, p2 = p2,\
    \ p1 end\n  local res = {}\n  for k, v in pairs(planets) do\n    if v > p1 and\
    \ v < p2 then table.insert(res, k) end\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph4jj04sf.lua:32:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: {\"Uranus\", \"Saturn\"}\nstack\
    \ traceback:\n\t/tmp/tmph4jj04sf.lua:32: in function 'test_humaneval'\n\nRan 1\
    \ tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local tbl = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local i, j\n  for k,v in\
    \ ipairs(tbl) do\n    if planet1 == v then i = k end\n    if planet2 == v then\
    \ j = k end\n  end\n  if not i or not j then return {} end\n  local res = {}\n\
    \  for k = math.min(i, j) + 1, math.max(i, j) - 1 do res[#res + 1] = tbl[k] end\n\
    \  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  if not (type(planet1) == \"string\" and type(planet2)\
    \ == \"string\") then\n    return {}\n  end\n  local p1, p2 = table.index_of(planets,\
    \ planet1), table.index_of(planets, planet2)\n  if not (p1 and p2) then\n    return\
    \ {}\n  end\n  local minp, maxp = math.min(p1, p2), math.max(p1, p2)\n  local\
    \ res = {}\n  for i = minp + 1, maxp - 1 do\n    table.insert(res, planets[i])\n\
    \  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpwo9wi5wc.lua:18:\
    \ attempt to call a nil value (field 'index_of')\nstack traceback:\n\t/tmp/tmpwo9wi5wc.lua:18:\
    \ in local 'candidate'\n\t/tmp/tmpwo9wi5wc.lua:33: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local function get_index(planet)\n    local planets\
    \ = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"}\n    for i, p in ipairs(planets) do\n      if p == planet\
    \ then\n        return i\n      end\n    end\n    return nil\n  end\n  local function\
    \ get_planets(from, to)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local result\
    \ = {}\n    for i = from, to do\n      table.insert(result, planets[i])\n    end\n\
    \    return result\n  end\n  local planet1_index = get_index(planet1)\n  local\
    \ planet2_index = get_index(planet2)\n  if planet1_index == nil or planet2_index\
    \ == nil then\n    return {}\n  end\n  local min = math.min(planet1_index, planet2_index)\n\
    \  local max = math.max(planet1_index, planet2_index)\n  return get_planets(min\
    \ + 1, max - 1)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ".\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n"
  stderr: ''
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9aaio4nd.lua:21:\
    \ expected: {\"Saturn\", \"Uranus\"}\nactual: nil\nstack traceback:\n\t/tmp/tmp9aaio4nd.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local function position(p)\n    return planets[p]\n\
    \  end\n  if position(planet1) and position(planet2) then\n    local big, small\
    \ = position(planet1), position(planet2)\n    if big < small then\n      big,\
    \ small = small, big\n    end\n    local bt = {}\n    for k, v in pairs(planets)\
    \ do\n      if v > small and v < big then\n        table.insert(bt, k)\n     \
    \ end\n    end\n    return unpack(bt)\n  end\n  return ()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmphs7e9xb4.lua:41: unexpected symbol near ')'\n"
  exit_code: 1
  status: Exception
