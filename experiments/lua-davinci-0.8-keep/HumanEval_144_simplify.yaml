name: HumanEval_144_simplify
language: lua
prompt: "-- Your task is to implement a function that will simplify the expression\n\
  -- x * n. The function returns True if x * n evaluates to a whole number and False\n\
  -- otherwise. Both x and n, are string representation of a fraction, and have the\
  \ following format,\n-- <numerator>/<denominator> where both numerator and denominator\
  \ are positive whole numbers.\n-- You can assume that x, and n are valid fractions,\
  \ and do not have zero as denominator.\n-- simplify(\"1/5\", \"5/1\") = True\n--\
  \ simplify(\"1/6\", \"2/1\") = False\n-- simplify(\"7/10\", \"10/2\") = False\n\
  local function simplify(x, n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = simplify\n\
  \    lu.assertEquals(candidate('1/5', '5/1'), true)\n    lu.assertEquals(candidate('1/6',\
  \ '2/1'), false)\n    lu.assertEquals(candidate('5/1', '3/1'), true)\n    lu.assertEquals(candidate('7/10',\
  \ '10/2'), false)\n    lu.assertEquals(candidate('2/10', '50/10'), true)\n    lu.assertEquals(candidate('7/2',\
  \ '4/2'), true)\n    lu.assertEquals(candidate('11/6', '6/1'), true)\n    lu.assertEquals(candidate('2/3',\
  \ '5/2'), false)\n    lu.assertEquals(candidate('5/2', '3/5'), false)\n    lu.assertEquals(candidate('2/4',\
  \ '8/4'), true)\n    lu.assertEquals(candidate('2/4', '4/2'), true)\n    lu.assertEquals(candidate('1/5',\
  \ '5/1'), true)\n    lu.assertEquals(candidate('1/5', '1/5'), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local x_numerator, x_denominator = string.match(x, \"(%d+)/(%d+)\"\
    )\n  local n_numerator, n_denominator = string.match(n, \"(%d+)/(%d+)\")\n  return\
    \ (x_numerator * n_denominator * n_numerator * x_denominator) %\n    (x_denominator\
    \ * n_denominator) == 0\nend", "  -- TODO: implement me\nend", "    local x1,\
    \ x2 = x:match(\"(%d+)/(%d+)\")\n    local n1, n2 = n:match(\"(%d+)/(%d+)\")\n\
    \    return (x1 * n2) % (x2 * n1) == 0\nend", "    local num_x, den_x = x:match(\"\
    (%d+)/(%d+)\")\n    local num_n, den_n = n:match(\"(%d+)/(%d+)\")\n    num_x,\
    \ den_x = tonumber(num_x), tonumber(den_x)\n    num_n, den_n = tonumber(num_n),\
    \ tonumber(den_n)\n    return (num_x * den_n) % (num_n * den_x) == 0\nend", "\t\
    local x_num, x_den = x:match(\"^(%d+)/(%d+)$\")\n\tlocal n_num, n_den = n:match(\"\
    ^(%d+)/(%d+)$\")\n\tx_num, x_den = tonumber(x_num), tonumber(x_den)\n\tn_num,\
    \ n_den = tonumber(n_num), tonumber(n_den)\n\tlocal result = x_num * n_num / (x_den\
    \ * n_den)\n\treturn math.floor(result) == result\nend", "  x = tonumber(x)\n\
    \  n = tonumber(n)\n  x = (x / n) * 100\n  return math.floor(x) == x\nend", " \
    \   local xn = x:match(\"(%d+)/(%d+)\")\n    local nn = n:match(\"(%d+)/(%d+)\"\
    )\n    local result = (xn * nn) % 1\n    if result == 0 then\n        return true\n\
    \    else\n        return false\n    end\nend", "    local _, _, num, den = x:find(\"\
    (%d+)/(%d+)\")\n    num, den = tonumber(num), tonumber(den)\n    _, _, n_num,\
    \ n_den = n:find(\"(%d+)/(%d+)\")\n    n_num, n_den = tonumber(n_num), tonumber(n_den)\n\
    \    -- assert(den ~= 0)\n    -- assert(n_den ~= 0)\n    return (num * n_den *\
    \ n_num) % (den * n_den) == 0\nend", "  -- your code here\nend", "    local xs\
    \ = x:split(\"/\")\n    local ns = n:split(\"/\")\n    local x1, x2 = tonumber(xs[1]),\
    \ tonumber(xs[2])\n    local n1, n2 = tonumber(ns[1]), tonumber(ns[2])\n    return\
    \ math.ceil(x1 * n2) == math.ceil(n1 * x2)\nend", "    local x1, x2 = getFrac(x)\n\
    \    local n1, n2 = getFrac(n)\n    if x1 * n2 == x2 * n1 then\n        return\
    \ true\n    else\n        return false\n    end\nend", "    local xx = x:split(\"\
    /\")\n    local nn = n:split(\"/\")\n    local a = tonumber(xx[1]) / tonumber(xx[2])\n\
    \    local b = tonumber(nn[1]) / tonumber(nn[2])\n    local c = a * b\n    if\
    \ math.floor(c) == c then\n        return true\n    else\n        return false\n\
    \    end\nend", "    local numerator_x, denominator_x = string.match(x, \"(%d+)/(%d+)\"\
    )\n    local numerator_n, denominator_n = string.match(n, \"(%d+)/(%d+)\")\n \
    \   return (numerator_x * denominator_n) % (denominator_x * numerator_n) == 0\n\
    end", "    return false\nend", "    local x_n, x_d = string.match(x, \"(%d+)/(%d+)\"\
    )\n    local n_n, n_d = string.match(n, \"(%d+)/(%d+)\")\n    x_n, x_d, n_n, n_d\
    \ = tonumber(x_n), tonumber(x_d), tonumber(n_n), tonumber(n_d)\n    local numerator\
    \ = x_n * n_n\n    local denominator = x_d * n_d\n    local gcd = function(a,\
    \ b)\n        if (b == 0) then\n            return a\n        else\n         \
    \   return gcd(b, a % b)\n        end\n    end\n    local tmp = gcd(numerator,\
    \ denominator)\n    numerator = numerator / tmp\n    denominator = denominator\
    \ / tmp\n    return numerator % denominator == 0\nend", "    x = x:split(\"/\"\
    )\n    n = n:split(\"/\")\n    local num = tonumber(x[1]) * tonumber(n[2])\n \
    \   local den = tonumber(x[2]) * tonumber(n[1])\n    if num % den == 0 then\n\
    \        return true\n    else\n        return false\n    end\nend", "  local\
    \ function gcd(a, b)\n    while b ~= 0 do\n      a, b = b, a % b\n    end\n  \
    \  return a\n  end\n  local function lcm(a, b)\n    return a / gcd(a, b) * b\n\
    \  end\n  local function norm(x)\n    local g = gcd(x[1], x[2])\n    x[1], x[2]\
    \ = x[1] / g, x[2] / g\n    return x\n  end\n  local function mul(x, y)\n    x[1],\
    \ x[2] = x[1] * y[1], x[2] * y[2]\n    return x\n  end\n  local function div(x,\
    \ y)\n    x[1], x[2] = x[1] * y[2], x[2] * y[1]\n    return x\n  end\n  local\
    \ function ipow(x, p)\n    local r = 1\n    while p > 0 do\n      if p % 2 ==\
    \ 1 then\n        r = r * x\n      end\n      x = x * x\n      p = p / 2\n   \
    \ end\n    return r\n  end\n  x = {tonumber(x:match(\"(%d+)/(%d+)\"))}\n  n =\
    \ {tonumber(n:match(\"(%d+)/(%d+)\"))}\n  if #x ~= 2 or #n ~= 2 then\n    return\
    \ false\n  end\n  local l = lcm(x[2], n[2])\n  x, n = norm(mul(x, {l / x[2], 1})),\
    \ norm(mul(n, {l / n[2], 1}))\n  local q = div(n, x)\n  q = norm(mul(q, {ipow(10,\
    \ tostring(q[2]):len()), 1}))\n  return q[1] % q[2] == 0\nend", "    -- for each\
    \ fraction multiply the x's numerator and denominator\n    -- by the n's denominator\
    \ and numerator\n    -- if the numerator is a whole number it is a whole number\n\
    \    -- else it is not a whole number\n    -- check if the first numerator is\
    \ a whole number\n    local function isWholeNumber(x, n)\n        local numeratorX\
    \ = tonumber(string.sub(x, 1, string.find(x, \"/\") - 1))\n        local denominatorX\
    \ = tonumber(string.sub(x, string.find(x, \"/\") + 1))\n        local numeratorN\
    \ = tonumber(string.sub(n, 1, string.find(n, \"/\") - 1))\n        local denominatorN\
    \ = tonumber(string.sub(n, string.find(n, \"/\") + 1))\n        return (numeratorX\
    \ * denominatorN) % (denominatorX * numeratorN) == 0\n    end\n    return isWholeNumber(x,\
    \ n)\nend", "  local function gcd(a, b)\n    while b ~= 0 do\n      a, b = b,\
    \ a % b\n    end\n    return a\n  end\n  local function reduce(x)\n    local i\
    \ = gcd(x[1], x[2])\n    x[1] = x[1] / i\n    x[2] = x[2] / i\n  end\n  local\
    \ function sub(x, y)\n    local x, y = {x[1], x[2]}, {y[1], y[2]}\n    if x[2]\
    \ ~= y[2] then\n      x[1] = x[1] * y[2]\n      y[1] = y[1] * x[2]\n      x[2]\
    \ = x[2] * y[2]\n      y[2] = y[2] * y[2]\n    end\n    reduce(x)\n    reduce(y)\n\
    \    return x[1] - y[1]\n  end\n  local function mul(x, y)\n    return {x[1] *\
    \ y[1], x[2] * y[2]}\n  end\n  local function is_int(x)\n    return x[1] % x[2]\
    \ == 0\n  end\n  local x = {tonumber(x:match(\"(%d+)/(%d+)\")),\n            \
    \ tonumber(x:match(\"(%d+)/(%d+)\", 2))}\n  local n = {tonumber(n:match(\"(%d+)/(%d+)\"\
    )),\n             tonumber(n:match(\"(%d+)/(%d+)\", 2))}\n  reduce(x)\n  reduce(n)\n\
    \  return is_int(mul(x, n))\nend", "\tlocal numerator1, denominator1 = x:match(\"\
    (%d+)/(%d+)\")\n\tlocal numerator2, denominator2 = n:match(\"(%d+)/(%d+)\")\n\t\
    return numerator1*denominator2 % (numerator2*denominator1) == 0\nend", "  x =\
    \ tonumber(x)\n  n = tonumber(n)\n  if (x * n) % 1 == 0 then\n    return true\n\
    \  else\n    return false\n  end\nend", "\tlocal function gcd(a, b)\n\t\twhile\
    \ b ~= 0 do\n\t\t\ta, b = b, a % b\n\t\tend\n\t\treturn a\n\tend\n\tlocal function\
    \ to_num(str)\n\t\tlocal num = str:match(\"^(%d+)/(%d+)$\")\n\t\treturn num and\
    \ tonumber(num)\n\tend\n\tlocal x_num, x_den = to_num(x)\n\tlocal n_num, n_den\
    \ = to_num(n)\n\treturn x_num and n_num and x_den and n_den and (x_num * n_den)\
    \ % (x_den * n_num) == 0\nend", "    local function gcd(a, b)\n        while b\
    \ ~= 0 do\n            a, b = b, a % b\n        end\n        return a\n    end\n\
    \    local function cmp(x, n)\n        local x_n, x_d = x:match(\"(%d+)/(%d+)\"\
    )\n        local n_n, n_d = n:match(\"(%d+)/(%d+)\")\n        x_n, x_d, n_n, n_d\
    \ = tonumber(x_n), tonumber(x_d), tonumber(n_n), tonumber(n_d)\n        local\
    \ common_divisor = gcd(x_d, n_d)\n        local lcm = x_d * n_d / common_divisor\n\
    \        local x_value = x_n * lcm / x_d\n        local n_value = n_n * lcm /\
    \ n_d\n        return x_value == n_value\n    end\n    return cmp(x, n)\nend",
  "    local function gcd(a, b)\n        if b == 0 then\n            return a\n  \
    \      else\n            return gcd(b, a % b)\n        end\n    end", "    local\
    \ function gcd(a, b)\n        if b == 0 then\n            return a\n        else\n\
    \            return gcd(b, a % b)\n        end\n    end", "  -- \u8BA1\u7B97\u9700\
    \u8981\u7684\u516C\u7EA6\u6570\n  local function gcd(a, b)\n    local t\n    if\
    \ a < b then\n      t = a\n      a = b\n      b = t\n    end\n    if a == b then\n\
    \      return a\n    end\n    if b == 0 then\n      return a\n    end\n    return\
    \ gcd(b, a % b)\n  end\n  -- \u5C06\u5206\u6570\u8F6C\u6362\u4E3A\u771F\u5B9E\u6570\
    \u503C\n  local function convert(fraction)\n    local numerator, denominator =\
    \ fraction:match(\"(%d+)/(%d+)\")\n    return tonumber(numerator) / tonumber(denominator)\n\
    \  end\n  -- \u6574\u6570\u8F6C\u6362\u4E3A\u5206\u6570\n  local function toFraction(x)\n\
    \    local n = math.modf(x)\n    if n == x then\n      return tostring(n) .. \"\
    /1\"\n    end\n    local i = 1\n    while true do\n      local d = x * i\n   \
    \   local n = math.modf(d)\n      if n == d then\n        local g = gcd(i, d)\n\
    \        return tostring(d / g) .. \"/\" .. tostring(i / g)\n      end\n     \
    \ i = i + 1\n    end\n  end\n  -- \u5224\u65AD\u6570\u503C\u662F\u5426\u662F\u6574\
    \u6570\n  local function isInteger(x)\n    local n = math.modf(x)\n    return\
    \ n == x\n  end\n  -- \u5224\u65AD\u5B57\u7B26\u4E32\u662F\u5426\u662F\u6574\u6570\
    \n  local function isIntegerString(x)\n    return x:match(\"^%d+$\")\n  end\n\
    \  local f1 = convert(x)\n  local f2 = convert(n)\n  local f3 = f1 * f2\n  local\
    \ f4 = toFraction(f3)\n  if isInteger(f3) then\n    return true\n  end\n  if isIntegerString(f4)\
    \ then\n    return true", "    local function gcd(a, b)\n        if a == 0 then\n\
    \            return b\n        end\n        return gcd(b % a, a)\n    end\n  \
    \  local function simplify_fraction(a, b)\n        local d = gcd(a, b)\n     \
    \   return a / d, b / d\n    end\n    local function compare_fractions(a, b, c,\
    \ d)\n        return a * d == b * c\n    end\n    local xn, xd = x:match(\"(%d+)/(%d+)\"\
    )\n    local nn, nd = n:match(\"(%d+)/(%d+)\")\n    xn, xd = tonumber(xn), tonumber(xd)\n\
    \    nn, nd = tonumber(nn), tonumber(nd)\n    local rxn, rxd = simplify_fraction(xn,\
    \ xd)\n    local rnn, rnd = simplify_fraction(nn, nd)\n    return compare_fractions(rxn,\
    \ rxd, rnn, rnd)\nend", "  -- TODO\nend", "    local xnum, xdenom = x:match(\"\
    (%d+)/(%d+)\")\n    local nnum, ndenom = n:match(\"(%d+)/(%d+)\")\n    local resultnum\
    \ = (xnum * nnum)\n    local resultdenom = (xdenom * ndenom)\n    local result\
    \ = resultnum/resultdenom\n    if result % 1 == 0 then\n        return true\n\
    \    else\n        return false\n    end\nend", "  -- Your code here.\nend\n```",
  "  local x_num, x_denom = x:match(\"(%d+)/(%d+)\")\n  local n_num, n_denom = n:match(\"\
    (%d+)/(%d+)\")\n  x_num, x_denom = tonumber(x_num), tonumber(x_denom)\n  n_num,\
    \ n_denom = tonumber(n_num), tonumber(n_denom)\n  local quotient = (x_num * n_denom)\
    \ / (x_denom * n_num)\n  return quotient % 1 == 0\nend", "    local function gcd(a,\
    \ b)\n        if b == 0 then\n            return a\n        else\n           \
    \ return gcd(b, a % b)\n        end\n    end", "    local function GCD(a, b)\n\
    \        while b ~= 0 do\n            a, b = b, a % b\n        end\n        return\
    \ a\n    end\n    local function simplifyFraction(x)\n        local numerator,\
    \ denominator = x:match('(.*)/(.*)')\n        numerator, denominator = tonumber(numerator),\
    \ tonumber(denominator)\n        local gcd = GCD(numerator, denominator)\n   \
    \     return numerator / gcd, denominator / gcd\n    end\n    local x_numerator,\
    \ x_denominator = simplifyFraction(x)\n    local n_numerator, n_denominator =\
    \ simplifyFraction(n)\n    local result_numerator, result_denominator = x_numerator\
    \ * n_numerator, x_denominator * n_denominator\n    local gcd = GCD(result_numerator,\
    \ result_denominator)\n    return result_numerator / gcd % 1 == 0\nend", "  x\
    \ = {}\n  x.numerator, x.denominator = x:match(\"(%d+)/(%d+)\")\n  x.numerator\
    \ = tonumber(x.numerator)\n  x.denominator = tonumber(x.denominator)\n  n = {}\n\
    \  n.numerator, n.denominator = n:match(\"(%d+)/(%d+)\")\n  n.numerator = tonumber(n.numerator)\n\
    \  n.denominator = tonumber(n.denominator)\n  local p = x.numerator * n.denominator\n\
    \  local q = x.denominator * n.numerator\n  if p == q then\n    return true\n\
    \  else\n    return false\n  end\nend", "  local f1, f2 = Fraction(x), Fraction(n)\n\
    \  if f1.denominator == f2.denominator then\n    return f1.numerator % f2.numerator\
    \ == 0\n  else\n    local sum = f1.numerator * f2.denominator + f2.numerator *\
    \ f1.denominator\n    return sum % f1.denominator == 0\n  end\nend", "    local\
    \ _, _, num1, den1 = x:find(\"(%d+)/(%d+)\")\n    local _, _, num2, den2 = n:find(\"\
    (%d+)/(%d+)\")\n    return num1 * den2 % num2 == 0\nend", "  local x_numerator,\
    \ x_denominator = x:match(\"(%d+)/(%d+)\")\n  local n_numerator, n_denominator\
    \ = n:match(\"(%d+)/(%d+)\")\n  return x_numerator * n_denominator == x_denominator\
    \ * n_numerator\nend", "  -- return x.numerator == n.numerator and x.denominator\
    \ == n.denominator\n  return x * n == math.floor(x * n)\nend", "    local split\
    \ = string.split\n    local tonumber = tonumber\n    local gcd = math.gcd\n  \
    \  local numerator, denominator = 0, 0\n    local x, n = split(x, \"/\"), split(n,\
    \ \"/\")\n    local xnumerator, xdenominator = tonumber(x[1]), tonumber(x[2])\n\
    \    local nnumerator, ndenominator = tonumber(n[1]), tonumber(n[2])\n    numerator\
    \ = xnumerator * nnumerator\n    denominator = xdenominator * ndenominator\n \
    \   return (gcd(numerator, denominator) == denominator)\nend\nreturn simplify",
  "  local xnum, xden = x:match(\"(%d+)/(%d+)\")\n  local nnum, nden = n:match(\"\
    (%d+)/(%d+)\")\n  xnum, xden = tonumber(xnum), tonumber(xden)\n  nnum, nden =\
    \ tonumber(nnum), tonumber(nden)\n  local resnum = xnum * nnum\n  local resden\
    \ = xden * nden\n  if resnum % resden == 0 then\n    return true\n  else\n   \
    \ return false\n  end\nend", "  local x_num, x_denom = x:match(\"(%d+)/(%d+)\"\
    )\n  local n_num, n_denom = n:match(\"(%d+)/(%d+)\")\n  x_num, x_denom = tonumber(x_num),\
    \ tonumber(x_denom)\n  n_num, n_denom = tonumber(n_num), tonumber(n_denom)\n \
    \ return (x_num * n_num) % (x_denom * n_denom) == 0\nend", "  local function gcd(a,\
    \ b)\n    local t\n    while b ~= 0 do\n      t = b\n      b = a % b\n      a\
    \ = t\n    end\n    return a\n  end", "    local xn, xd = table.unpack(utils.split(x,\
    \ \"/\"))\n    local nn, nd = table.unpack(utils.split(n, \"/\"))\n    return\
    \ xn * nd % (xd * nn) == 0\nend", "    local numerator = tonumber(string.split(x,\
    \ \"/\")[1])\n    local denominator = tonumber(string.split(x, \"/\")[2])\n  \
    \  local factor = tonumber(string.split(n, \"/\")[1]) / tonumber(string.split(n,\
    \ \"/\")[2])\n    local result = numerator * factor\n    return math.mod(result,\
    \ 1) == 0\nend", "  local xNum, xDen = string.match(x, \"(%d+)/(%d+)\")\n  local\
    \ nNum, nDen = string.match(n, \"(%d+)/(%d+)\")\n  local num = xNum * nDen\n \
    \ local den = xDen * nNum\n  return den == num\nend", "  local xn = tonumber(x:match(\"\
    (%d+)/(%d+)\")) * tonumber(n:match(\"(%d+)/(%d+)\"))\n  local xn_frac = math.fmod(xn,\
    \ 1)\n  return xn_frac == 0\nend", "    local function parse(s)\n        local\
    \ num, den = s:match(\"(%d+)/(%d+)\")\n        return tonumber(num), tonumber(den)\n\
    \    end\n    local function gcd(a, b)\n        local t\n        while b ~= 0\
    \ do\n            t = b\n            b = a % b\n            a = t\n        end\n\
    \        return a\n    end\n    local x_num, x_den = parse(x)\n    local n_num,\
    \ n_den = parse(n)\n    local factor = gcd(x_den, n_den)\n    x_den = x_den /\
    \ factor\n    n_den = n_den / factor\n    return x_num * n_den == n_num * x_den\n\
    end", "    x = x:split(\"/\")\n    x = tonumber(x[1]) / tonumber(x[2])\n    n\
    \ = n:split(\"/\")\n    n = tonumber(n[1]) / tonumber(n[2])\n    if x * n % 1\
    \ == 0 then\n        return true\n    else\n        return false\n    end\nend",
  "  local num, den = parse(x)\n  local m, d = parse(n)\n  local r = num * m / den\
    \ / d\n  local i = math.floor(r)\n  return r == i\nend", "  local xnum, xden =\
    \ x:match('(%d+)/(%d+)')\n  local nnum, nden = n:match('(%d+)/(%d+)')\n  return\
    \ xnum * nden == xden * nnum\nend", end, "  local x_numerator, x_denominator =\
    \ x:match(\"(%d+)/(%d+)\")\n  local n_numerator, n_denominator = n:match(\"(%d+)/(%d+)\"\
    )\n  if not x_numerator or not x_denominator or not n_numerator or not n_denominator\
    \ then\n    return false\n  end\n  local result_numerator = tonumber(x_numerator)\
    \ * tonumber(n_numerator)\n  local result_denominator = tonumber(x_denominator)\
    \ * tonumber(n_denominator)\n  local result = result_numerator / result_denominator\n\
    \  local simplified_result = math.floor(result)\n  return simplified_result ==\
    \ result\nend", "  -- this is the common divisor\n  local divisor = math.gcd(tonumber(x:match(\"\
    (%d+)/\")), tonumber(n:match(\"(%d+)/\")))\n  -- the second value should be a\
    \ multiple of the first\n  return tonumber(n:match(\"(%d+)/\")) % tonumber(x:match(\"\
    (%d+)/\")) == 0\nend", "  x = tonumber(x)\n  n = tonumber(n)\n  local result =\
    \ x * n\n  return math.mod(result, 1) == 0\nend", "    local x_den = tonumber(string.match(x,\
    \ \"%d+$\"))\n    local x_num = tonumber(string.match(x, \"^%d+\"))\n    local\
    \ n_den = tonumber(string.match(n, \"%d+$\"))\n    local n_num = tonumber(string.match(n,\
    \ \"^%d+\"))\n    local res_den = x_den * n_den\n    local res_num = x_num * n_num\n\
    \    local res = res_num / res_den\n    local str_res = tostring(res)\n    if\
    \ string.match(str_res, \"%d+%.%d+\") then\n        return false\n    else\n \
    \       return true\n    end\nend", "  --\nend", "  local function gcd(a, b)\n\
    \    if (b == 0) then\n      return a\n    else\n      return gcd(b, a % b)\n\
    \    end\n  end", end, "  local function gcd(a, b)\n    local m = math.min(a,\
    \ b)\n    local g = 1\n    for i = 2, m do\n      if a % i == 0 and b % i == 0\
    \ then\n        g = i\n      end\n    end\n    return g\n  end\n  local function\
    \ cancel(x)\n    local a, b = unpack(x)\n    local g = gcd(a, b)\n    a = a /\
    \ g\n    b = b / g\n    return {a, b}\n  end\n  local function mul(x, n)\n   \
    \ local xa, xb = unpack(x)\n    local na, nb = unpack(n)\n    return {xa * na,\
    \ xb * nb}\n  end\n  local function parse(f)\n    local a, b = unpack(f:split(\"\
    /\"))\n    return {tonumber(a), tonumber(b)}\n  end\n  x = parse(x)\n  n = parse(n)\n\
    \  local r = mul(x, n)\n  local r = cancel(r)\n  return r[1] % r[2] == 0\nend",
  "  local a = tonumber(x:sub(1, x:find(\"/\")))\n  local b = tonumber(x:sub(x:find(\"\
    /\") + 1))\n  local c = tonumber(n:sub(1, n:find(\"/\")))\n  local d = tonumber(n:sub(n:find(\"\
    /\") + 1))\n  if a * d == b * c then\n    return true\n  else\n    return false\n\
    \  end\nend", "  x = x:split('/')\n  n = n:split('/')\n  local numerator = tonumber(x[1])\
    \ * tonumber(n[2])\n  local denominator = tonumber(x[2]) * tonumber(n[1])\n  return\
    \ numerator % denominator == 0\nend", "    local GCD = function(x, n)\n      \
    \  while n ~= 0 do\n            n, x = x % n, n\n        end\n        return x\n\
    \    end\n    local gcd = GCD(tonumber(x:match('^(%d+)/')), tonumber(x:match('/(%d+)$')))\n\
    \    if gcd ~= 1 then\n        x = tonumber(x:match('^(%d+)/')) / gcd .. '/' ..\
    \ tonumber(x:match('/(%d+)$')) / gcd\n    end\n    gcd = GCD(tonumber(n:match('^(%d+)/')),\
    \ tonumber(n:match('/(%d+)$')))\n    if gcd ~= 1 then\n        n = tonumber(n:match('^(%d+)/'))\
    \ / gcd .. '/' .. tonumber(n:match('/(%d+)$')) / gcd\n    end\n    return tonumber(x:match('^(%d+)/'))\
    \ * tonumber(n:match('/(%d+)$'))\n        % tonumber(x:match('/(%d+)$')) == 0\n\
    end", "  local _, _, a,b = x:find(\"^(%d+)/(%d+)$\")\n  local c,d = tonumber(a),\
    \ tonumber(b)\n  if not c or not d then return false end\n  local _, _, a,b =\
    \ n:find(\"^(%d+)/(%d+)$\")\n  local e,f = tonumber(a), tonumber(b)\n  if not\
    \ e or not f then return false end\n  return ((c*f)%(d*e)) == 0\nend", "  local\
    \ numerator1, denominator1 = x:match(\"(%d+)/(%d+)\")\n  local numerator2, denominator2\
    \ = n:match(\"(%d+)/(%d+)\")\n  return tonumber(numerator1) * tonumber(denominator2)\
    \ % tonumber(denominator1) == 0\nend", "  local function gcd(a, b)\n    while\
    \ b ~= 0 do\n      a, b = b, a % b\n    end\n    return a\n  end\n  local s =\
    \ {tonumber(x:match(\"^(%d+)/%d+$\")), tonumber(x:match(\"^%d+/(%d+)$\"))}\n \
    \ local n = {tonumber(n:match(\"^(%d+)/%d+$\")), tonumber(n:match(\"^%d+/(%d+)$\"\
    ))}\n  local g = gcd(s[1] * n[2], s[2] * n[1])\n  return (s[1] * n[2] / g) % (s[2]\
    \ * n[1] / g) == 0\nend", "  -- Write your code here\n  local numX, denX = string.match(x,\
    \ \"(%d+)/(%d+)\")\n  local numN, denN = string.match(n, \"(%d+)/(%d+)\")\n  numX\
    \ = tonumber(numX)\n  denX = tonumber(denX)\n  numN = tonumber(numN)\n  denN =\
    \ tonumber(denN)\n  local result = numX * numN / denX / denN\n  local intResult\
    \ = math.floor(result)\n  return result == intResult\nend", "    return tonumber(assert(loadstring('return\
    \ ' .. x .. ' * ' .. n))()) % 1 == 0\nend", "  local numeratorX, denominatorX\
    \ = x:match(\"(%d+)/(%d+)\")\n  local numeratorN, denominatorN = n:match(\"(%d+)/(%d+)\"\
    )\n  numeratorX = tonumber(numeratorX)\n  denominatorX = tonumber(denominatorX)\n\
    \  numeratorN = tonumber(numeratorN)\n  denominatorN = tonumber(denominatorN)\n\
    \  local product = numeratorX * numeratorN / (denominatorX * denominatorN)\n \
    \ return product % 1 == 0\nend", "    local denumx, denumn = x:match(\"/(%d+)\"\
    ), n:match(\"/(%d+)\")\n    local numerx, numern = x:match(\"(%d+)/\"), n:match(\"\
    (%d+)/\")\n    if tonumber(denumx) == nil or tonumber(denumn) == nil or\n    \
    \        tonumber(numerx) == nil or tonumber(numern) == nil then\n        return\
    \ false\n    end\n    local greatest_common_divisor = math.gcd(tonumber(denumx),\
    \ tonumber(denumn))\n    if (denumx / greatest_common_divisor == denumn / greatest_common_divisor)\
    \ and\n            (denumx % greatest_common_divisor == 0) and\n            (denumn\
    \ % greatest_common_divisor == 0) then\n        return true\n    end\n    return\
    \ false\nend", "  local xn = x * n\n  return math.floor(xn) == xn\nend", "  local\
    \ function gcd(a, b)\n    while b ~= 0 do\n      a, b = b, a % b\n    end\n  \
    \  return a\n  end\n  local function lcm(a, b)\n    return a / gcd(a, b) * b\n\
    \  end\n  local xnum, xden = string.match(x, \"(%d+)/(%d+)\")\n  local num, den\
    \ = string.match(n, \"(%d+)/(%d+)\")\n  xnum, xden, num, den = tonumber(xnum),\
    \ tonumber(xden), tonumber(num), tonumber(den)\n  return (xnum * num) % (xden\
    \ * den) == 0\nend", "    x_numerator, x_denominator = split(x, \"/\")\n    n_numerator,\
    \ n_denominator = split(n, \"/\")\n    -- Notice that if a fraction is a whole\
    \ number, then the numerator and denominator must\n    -- have no common factors.\n\
    \    return gcd(x_numerator, x_denominator) == 1 and gcd(n_numerator, n_denominator)\
    \ == 1\nend", "  local xn = x:split(\"/\")\n  local nn = n:split(\"/\")\n  local\
    \ xn = tonumber(xn[1]) / tonumber(xn[2])\n  local nn = tonumber(nn[1]) / tonumber(nn[2])\n\
    \  local result = xn * nn\n  return result % 1 == 0\nend", "  local t1 = get_frac(x)\n\
    \  local t2 = get_frac(n)\n  local d1 = t1[1] * t2[2]\n  local d2 = t1[2] * t2[1]\n\
    \  if (d1 % d2 == 0) then\n    return true\n  else\n    return false\n  end\n\
    end", "  local function gcd(a, b)\n    if a < b then\n      return gcd(b, a)\n\
    \    end\n    local r = a % b\n    if r == 0 then\n      return b\n    else\n\
    \      return gcd(b, r)\n    end\n  end\n  local function mul(a, b)\n    local\
    \ n = gcd(a[1], b[2])\n    local d = gcd(a[2], b[1])\n    return (a[1] / n) *\
    \ (b[1] / d), (a[2] / d) * (b[2] / n)\n  end\n  local function div(a, b)\n   \
    \ return mul(a, {b[2], b[1]})\n  end\n  local function add(a, b)\n    local n\
    \ = gcd(a[1], b[1])\n    local d = gcd(a[2], b[2])\n    return {(a[1] / n) * (b[2]\
    \ / d) + (b[1] / n) * (a[2] / d), (a[2] / d) * (b[2] / d)}\n  end\n  local function\
    \ to_integer(a)\n    return add(a, {0, 1})\n  end\n  local function eval(f)\n\
    \    local s, e = f:find(\"/\")\n    return {tonumber(f:sub(1, s - 1)), tonumber(f:sub(e\
    \ + 1))}\n  end\n  local a, b = eval(x), eval(n)\n  return to_integer(mul(a, b))[1]\
    \ % to_integer(b)[1] == 0\nend", "  -- ... TODO ...\nend", "  local x_num, x_den\
    \ = parse(x)\n  local n_num, n_den = parse(n)\n  local num = x_num * n_num\n \
    \ local den = x_den * n_den\n  local gcd = get_gcd(num, den)\n  return num / gcd\
    \ == den / gcd\nend", "    local function gcd(a, b)\n        local function mn(x,\
    \ y)\n            if x < y then\n                return x\n            else\n\
    \                return y\n            end\n        end\n        local m = mn(a,\
    \ b)\n        for i = m, 1, -1 do\n            if a % i == 0 and b % i == 0 then\n\
    \                return i\n            end\n        end\n    end\n    x = x:split(\"\
    /\")\n    n = n:split(\"/\")\n    local xn = tonumber(x[1]) * tonumber(n[2])\n\
    \    local nn = tonumber(n[1]) * tonumber(x[2])\n    local gd = gcd(xn, nn)\n\
    \    if gd == 1 then\n        return true\n    else\n        return false\n  \
    \  end\nend", "    local function gcd(x, y)\n        while y ~= 0 do\n       \
    \     local x1 = x % y\n            x = y\n            y = x1\n        end\n \
    \       return x\n    end\n    local function lcm(x, y)\n        return x * y\
    \ / gcd(x, y)\n    end\n    local function normalize(x)\n        local m = x:match(\"\
    (%d+)/(%d+)\")\n        local numerator = tonumber(m[1])\n        local denominator\
    \ = tonumber(m[2])\n        local factor = gcd(numerator, denominator)\n     \
    \   return string.format(\"%d/%d\", numerator / factor, denominator / factor)\n\
    \    end\n    local function str2fraction(x)\n        local m = x:match(\"(%d+)/(%d+)\"\
    )\n        local numerator = tonumber(m[1])\n        local denominator = tonumber(m[2])\n\
    \        return numerator, denominator\n    end\n    local function fraction2str(x,\
    \ y)\n        return string.format(\"%d/%d\", x, y)\n    end\n    local function\
    \ multiply_str(x, y)\n        local x_num, x_den = str2fraction(x)\n        local\
    \ y_num, y_den = str2fraction(y)\n        local den = lcm(x_den, y_den)\n    \
    \    local num = x_num * (den / x_den) + y_num * (den / y_den)\n        return\
    \ fraction2str(num, den)\n    end\n    local function is_integer(x)\n        return\
    \ x % 1 == 0\n    end\n    local x1 = normalize(x)\n    local n1 = normalize(n)\n\
    \    local m = multiply_str(x1, n1)\n    local num, den = str2fraction(m)\n  \
    \  return is_integer(num / den)\nend", "  local _x, _n = x:gsub(\"([^/]+)/([^/]+)\"\
    , function(numerator, denominator)\n    local num = tonumber(numerator)\n    local\
    \ den = tonumber(denominator)\n    if num == den then\n      return 1\n    elseif\
    \ num > den then\n      for i = den, 1, -1 do\n        if num % i == 0 and den\
    \ % i == 0 then\n          num = num / i\n          den = den / i\n        end\n\
    \      end\n      return num, den\n    else\n      for i = num, 1, -1 do\n   \
    \     if num % i == 0 and den % i == 0 then\n          num = num / i\n       \
    \   den = den / i\n        end\n      end\n      return num, den\n    end\n  end)\n\
    \  if _x == n then\n    return true\n  else\n    return false\n  end\nend", " \
    \ local x_num, x_den = x:match(\"(%d+)/(%d+)\")\n  local n_num, n_den = n:match(\"\
    (%d+)/(%d+)\")\n  local num = x_num * n_num\n  local den = x_den * n_den\n  local\
    \ integral, frac = tostring(num / den):match(\"(%d+)%.(%d+)\")\n  if frac and\
    \ frac ~= \"0\" then\n    return false\n  end\n  return true\nend", "    local\
    \ function tofloat(s)\n        local s1, s2 = s:match(\"(%d+)/(%d+)\")\n     \
    \   return tonumber(s1) / tonumber(s2)\n    end\n    local xv, nv = tofloat(x),\
    \ tofloat(n)\n    local result = xv * nv\n    return result == math.floor(result)\n\
    end", "    local f1, f2 = assert(x:match'^(%d+)/(%d+)$'), assert(n:match'^(%d+)/(%d+)$')\n\
    \    local den = tonumber(f1) / tonumber(f2)\n    local num = den % 1\n    return\
    \ num == 0\nend", "    local numerator1, denominator1 = string.match(x, \"(%d+)/(%d+)\"\
    )\n    local numerator2, denominator2 = string.match(n, \"(%d+)/(%d+)\")\n   \
    \ numerator1 = tonumber(numerator1)\n    denominator1 = tonumber(denominator1)\n\
    \    numerator2 = tonumber(numerator2)\n    denominator2 = tonumber(denominator2)\n\
    \    local result = numerator1 * numerator2 / denominator1 / denominator2\n  \
    \  if result == math.floor(result) then\n        return true\n    else\n     \
    \   return false\n    end\nend", "\tlocal x_num, x_den = tonumber(x:match(\"(%d+)/(%d+)\"\
    )), tonumber(x:match(\"(%d+)/(%d+)\"))\n\tlocal n_num, n_den = tonumber(n:match(\"\
    (%d+)/(%d+)\")), tonumber(n:match(\"(%d+)/(%d+)\"))\n\tlocal out_num = x_num *\
    \ n_num\n\tlocal out_den = x_den * n_den\n\tlocal g = math.gcd(out_num, out_den)\n\
    \tout_num = out_num / g\n\tout_den = out_den / g\n\tif out_den == 1 then\n\t\t\
    return true\n\telse\n\t\treturn false\n\tend\nend", "    local function reduce(x)\n\
    \        local num, den = tonumber(x:match('^(%d+)/(%d+)$'))\n        while num\
    \ ~= 1 do\n            local y = 2\n            while num % y == 0 and den % y\
    \ == 0 do\n                num = num / y\n                den = den / y\n    \
    \        end\n            y = y + 1\n        end\n        return den\n    end\n\
    \    return reduce(x) == reduce(n)\nend", "    local function gcd(a, b)\n    \
    \    local aux\n        while b ~= 0 do\n            aux = b\n            b =\
    \ a % b\n            a = aux\n        end\n        return a\n    end", "    local\
    \ _, _, num1, den1 = x:find(\"(%d+)/(%d+)\")\n    local _, _, num2, den2 = n:find(\"\
    (%d+)/(%d+)\")\n    num1, den1, num2, den2 = tonumber(num1), tonumber(den1), tonumber(num2),\
    \ tonumber(den2)\n    return num1 * den2 * den1 == num2 * den1 * den2\nend", " \
    \   local numerator = tonumber(x:sub(1, x:find(\"/\"))) * tonumber(n:sub(1, n:find(\"\
    /\")))\n    local denominator = tonumber(x:sub(x:find(\"/\") + 1)) * tonumber(n:sub(n:find(\"\
    /\") + 1))\n    local whole = numerator / denominator\n    local real = math.floor(whole)\n\
    \    if whole == real then\n        return true\n    else\n        return false\n\
    \    end\nend", "    x = gcd(x[1], x[2])\n    n = gcd(n[1], n[2])\n    if (x[1]\
    \ / x[2]) % (n[1] / n[2]) == 0 then\n        return true\n    else\n        return\
    \ false\n    end\nend", "\tlocal x_num, x_denom = x:match(\"(%d+)/(%d+)\")\n\t\
    local n_num, n_denom = n:match(\"(%d+)/(%d+)\")\n\treturn (x_num * n_denom * n_num\
    \ * x_denom) % (x_denom * n_denom) == 0\nend", "    local x_numerator, x_denominator\
    \ = x:match(\"^(%d+)/(%d+)$\")\n    local n_numerator, n_denominator = n:match(\"\
    ^(%d+)/(%d+)$\")\n    return (x_numerator * n_denominator) % (x_denominator *\
    \ n_numerator) == 0\nend", "    local xnum, xden = x:match('(%d+)/(%d+)')\n  \
    \  local nnum, nden = n:match('(%d+)/(%d+)')\n    return (nnum * xden) % (xnum\
    \ * nden) == 0\nend", "    -- TODO: implement function here\n    local xNum, xDen\
    \ = x:match(\"(%d+)/(%d+)\")\n    local nNum, nDen = n:match(\"(%d+)/(%d+)\")\n\
    \    xNum, xDen = tonumber(xNum), tonumber(xDen)\n    nNum, nDen = tonumber(nNum),\
    \ tonumber(nDen)\n    -- x =  xNum / xDen\n    -- n =  nNum / nDen\n    -- x *\
    \ n =  xNum * nNum / xDen * nDen\n    -- x * n =  xNum * nNum / xDen * nDen\n\
    \    -- x * n =  xNum * nNum / xDen * nDen\n    -- x * n =  xNum * nNum / xDen\
    \ * nDen\n    -- x * n =  xNum * nNum / xDen * nDen\n    local num, den = xNum\
    \ * nNum, xDen * nDen\n    return num / den == math.floor(num / den)\nend", " \
    \   local u, v = x:match('^(%d+)/(%d+)$')\n    local p, q = n:match('^(%d+)/(%d+)$')\n\
    \    u, v, p, q = tonumber(u), tonumber(v), tonumber(p), tonumber(q)\n    local\
    \ A, B = v, v * p\n    local C, D = v * q, u * q\n    return math.gcd(A, B) ==\
    \ 1 and math.gcd(C, D) == 1\nend", "  local num1, den1 = x:match(\"(%d+)/(%d+)\"\
    )\n  local num2, den2 = n:match(\"(%d+)/(%d+)\")\n  local res = tonumber(num1)\
    \ * tonumber(num2) .. \"/\" .. tonumber(den1) * tonumber(den2)\n  local res_num,\
    \ res_den = res:match(\"(%d+)/(%d+)\")\n  if tonumber(res_num) % tonumber(res_den)\
    \ == 0 then\n    return true\n  else\n    return false\n  end\nend", "  return\
    \ false\nend", "    -- Write your code here\n    x = tonumber(x)\n    n = tonumber(n)\n\
    \    local result = x * n\n    if math.floor(result) == result then\n        return\
    \ true\n    else\n        return false\n    end\nend", "  local gcd_x = gcd(tonumber(x:match('([^/]+)')),\
    \ tonumber(x:match('/([^/]+)')))\n  local gcd_n = gcd(tonumber(n:match('([^/]+)')),\
    \ tonumber(n:match('/([^/]+)')))\n  return gcd_x == gcd_n\nend", "  local function\
    \ gcd(a, b)\n    while b ~= 0 do\n      a, b = b, a % b\n    end\n    return a\n\
    \  end\n  x = string.match(x, \"(%d+)/(%d+)\")\n  n = string.match(n, \"(%d+)/(%d+)\"\
    )\n  return tonumber(x) * tonumber(n) % gcd(tonumber(x), tonumber(n)) == 0\nend",
  "    local function gcd(a, b)\n        while b ~= 0 do\n            a, b = b, a\
    \ % b\n        end\n        return a\n    end\n    local function reduce(a, b)\n\
    \        local d = gcd(a, b)\n        a = a / d\n        b = b / d\n        return\
    \ a, b\n    end\n    local f = {}\n    for i in x:gmatch(\"%d+\") do\n       \
    \ f[#f + 1] = tonumber(i)\n    end\n    local s = {}\n    for i in n:gmatch(\"\
    %d+\") do\n        s[#s + 1] = tonumber(i)\n    end\n    f[1], f[2] = reduce(f[1],\
    \ f[2])\n    s[1], s[2] = reduce(s[1], s[2])\n    return s[1] * f[2] == f[1] *\
    \ s[2]\nend", "  local x_num, x_denom = x:match('(%d+)/(%d+)')\n  local n_num,\
    \ n_denom = n:match('(%d+)/(%d+)')\n  local product_num = x_num * n_num\n  local\
    \ product_denom = x_denom * n_denom\n  local product = product_num .. '/' .. product_denom\n\
    \  local gcd = math.gcd(product_num, product_denom)\n  if gcd ~= 1 then\n    product_num\
    \ = product_num / gcd\n    product_denom = product_denom / gcd\n  end\n  return\
    \ product_num == product_denom\nend", "  local function gcd(a, b)\n    local r\
    \ = a % b\n    if r == 0 then\n      return b\n    else\n      return gcd(b, r)\n\
    \    end\n  end", "    local xNum, xDenom = string.match(x, \"(%d+)/(%d+)\")\n\
    \    local nNum, nDenom = string.match(n, \"(%d+)/(%d+)\")\n    local xNum, xDenom,\
    \ nNum, nDenom = tonumber(xNum), tonumber(xDenom), tonumber(nNum), tonumber(nDenom)\n\
    \    if xNum and xDenom and nNum and nDenom then\n        local x = math.floor(xNum/xDenom)\n\
    \        local n = math.floor(nNum/nDenom)\n        local result = math.floor(x\
    \ * n)\n        return result == (x * n)\n    end\n    return false\nend", " \
    \   local x_n, x_d = x:match(\"^(%d+)/(%d+)$\")\n    local n_n, n_d = n:match(\"\
    ^(%d+)/(%d+)$\")\n    x_n, x_d = tonumber(x_n), tonumber(x_d)\n    n_n, n_d =\
    \ tonumber(n_n), tonumber(n_d)\n    local expected = x_n * n_n / (x_d * n_d)\n\
    \    return expected % 1 == 0\nend", "  return (x * n) % 1 == 0\nend", "    local\
    \ x_num, x_denom = string.match(x, \"(%d+)/(%d+)\")\n    local n_num, n_denom\
    \ = string.match(n, \"(%d+)/(%d+)\")\n    local result_num = x_num * n_num\n \
    \   local result_denom = x_denom * n_denom\n    local result = result_num / result_denom\n\
    \    return result % 1 == 0\nend", "  return true\nend", "    -- Write your code\
    \ here\nend", "  local xn = x .. \"*\" .. n\n  local x_n = simplifyFraction(xn)\n\
    \  local x_n_str = x_n[1] .. \"/\" .. x_n[2]\n  return x_n[1] % x_n[2] == 0\n\
    end", "  local xn = tostring(tonumber(x:match(\"^(.*)/\")) / tonumber(x:match(\"\
    /(.*)$\")))\n  local nn = tostring(tonumber(n:match(\"^(.*)/\")) / tonumber(n:match(\"\
    /(.*)$\")))\n  return xn == nn\nend", "  -- TODO: Implement the function here\n\
    end", "    local x_num, x_denom = x:match(\"(%d+)/(%d+)\")\n    local n_num, n_denom\
    \ = n:match(\"(%d+)/(%d+)\")\n    local numerator = x_num * n_num\n    local denominator\
    \ = x_denom * n_denom\n    local r = math.floor(numerator/denominator)\n    return\
    \ numerator%denominator == 0 and r or false\nend", "  -- TODO: implement this\
    \ function\nend", "    local numerator1, denominator1 = x:match(\"(%d+)/(%d+)\"\
    )\n    local numerator2, denominator2 = n:match(\"(%d+)/(%d+)\")\n    numerator1,\
    \ denominator1 = tonumber(numerator1), tonumber(denominator1)\n    numerator2,\
    \ denominator2 = tonumber(numerator2), tonumber(denominator2)\n    local prod1\
    \ = numerator1 * denominator2\n    local prod2 = numerator2 * denominator1\n \
    \   return prod1 % denominator2 == 0 and prod2 % denominator1 == 0 and prod1/denominator2\
    \ == prod2/denominator1\nend", "  -- TODO: implement this function\nend", "  \
    \  local x1, x2 = tonumber(x:sub(1, x:find(\"/\"))), tonumber(x:sub(x:find(\"\
    /\") + 1))\n    local n1, n2 = tonumber(n:sub(1, n:find(\"/\"))), tonumber(n:sub(n:find(\"\
    /\") + 1))\n    return (x1 * n2) % (x2 * n1) == 0\nend", "    local numx, denx\
    \ = string.match(x, '(%d+)/(%d+)')\n    local numn, denn = string.match(n, '(%d+)/(%d+)')\n\
    \    local m = math.gcd(denx, denn)\n    return (tonumber(numx) * tonumber(denn)\
    \ * m) % (tonumber(numn) * tonumber(denx) * m) == 0\nend", "    local a = string.split(x,\
    \ \"/\")\n    local b = string.split(n, \"/\")\n    return (a[1] * b[2]) % (a[2]\
    \ * b[1]) == 0\nend", "\tlocal function gcd(a, b)\n\t\tif b == 0 then\n\t\t\t\
    return a\n\t\telse\n\t\t\treturn gcd(b, a % b)\n\t\tend\n\tend\n\tlocal function\
    \ reduce(x)\n\t\tlocal numerator, denominator = x:match(\"(%d+)/(%d+)\")\n\t\t\
    numerator, denominator = tonumber(numerator), tonumber(denominator)\n\t\tlocal\
    \ divisor = gcd(numerator, denominator)\n\t\treturn string.format(\"%d/%d\", numerator\
    \ / divisor, denominator / divisor)\n\tend\n\tx, n = reduce(x), reduce(n)\n\t\
    local numerator, denominator = x:match(\"(%d+)/(%d+)\")\n\tlocal numerator2, denominator2\
    \ = n:match(\"(%d+)/(%d+)\")\n\tnumerator, denominator = tonumber(numerator),\
    \ tonumber(denominator)\n\tnumerator2, denominator2 = tonumber(numerator2), tonumber(denominator2)\n\
    \treturn numerator * denominator2 == numerator2 * denominator\nend", "  -- your\
    \ code here\nend", "  x = x:split(\"/\")\n  n = n:split(\"/\")\n  local n1 = tonumber(x[1])\
    \ * tonumber(n[2])\n  local n2 = tonumber(x[2]) * tonumber(n[1])\n  return (n1\
    \ % n2 == 0)\nend", "  local xNum, xDen = x:match(\"(%d+)/(%d+)\")\n  local nNum,\
    \ nDen = n:match(\"(%d+)/(%d+)\")\n  return ((xNum * nDen) % (xDen * nNum)) ==\
    \ 0\nend", "    local x_num, x_den = x:match(\"(%d+)/(%d+)\")\n    local n_num,\
    \ n_den = n:match(\"(%d+)/(%d+)\")\n    x_num, x_den = tonumber(x_num), tonumber(x_den)\n\
    \    n_num, n_den = tonumber(n_num), tonumber(n_den)\n    local result = (x_num\
    \ * n_num) / (x_den * n_den)\n    if result % 1 == 0 then\n        return true\n\
    \    else\n        return false\n    end\nend", "    local function multiply(x,\
    \ n)\n        local function fracToDec(frac)\n            local numerator, denominator\
    \ = frac:match(\"(%d+)/(%d+)\")\n            return tonumber(numerator) / tonumber(denominator)\n\
    \        end\n        local xNumerator, xDenominator = x:match(\"(%d+)/(%d+)\"\
    )\n        local nNumerator, nDenominator = n:match(\"(%d+)/(%d+)\")\n       \
    \ return fracToDec(x) * fracToDec(n)\n    end\n    local xn = multiply(x, n)\n\
    \    return math.floor(xn) == xn\nend", "    local xNum, xDenom = x:match(\"(%d+)/(%d+)\"\
    )\n    local nNum, nDenom = n:match(\"(%d+)/(%d+)\")\n    local xRes = tonumber(xNum)\
    \ * tonumber(nDenom)\n    local nRes = tonumber(nNum) * tonumber(xDenom)\n   \
    \ if xRes % nRes == 0 then\n        return true\n    else\n        return false\n\
    \    end\nend", "  local function lcm(a, b)\n    return a * b / gcd(a, b)\n  end\n\
    \  local function gcd(a, b)\n    if a % b == 0 then\n      return b\n    else\n\
    \      return gcd(b, a % b)\n    end\n  end\n  local function parse(s)\n    local\
    \ a, b = s:match('(%d+)/(%d+)')\n    return tonumber(a), tonumber(b)\n  end\n\
    \  local xn, xd = parse(x)\n  local nn, nd = parse(n)\n  local l = lcm(xd, nd)\n\
    \  return (l / xd * xn) % (l / nd) == 0\nend", "  --\nend", "\t-- using base for\
    \ simple division on fractions\n\tlocal xNum, xDen = x:match(\"(%d+)/(%d+)\")\n\
    \tlocal nNum, nDen = n:match(\"(%d+)/(%d+)\")\n\tlocal base = math.min(xDen, nDen)\n\
    \txNum, xDen = tonumber(xNum), tonumber(xDen)\n\tnNum, nDen = tonumber(nNum),\
    \ tonumber(nDen)\n\t-- division on fractions\n\tlocal function division(num, den)\n\
    \t\tlocal i = den\n\t\twhile i > 0 do\n\t\t\tif num % i == 0 and den % i == 0\
    \ then\n\t\t\t\tnum = num / i\n\t\t\t\tden = den / i\n\t\t\tend\n\t\t\ti = i -\
    \ 1\n\t\tend\n\t\treturn tostring(num) .. \"/\" .. tostring(den)\n\tend\n\t--\
    \ division on whole numbers\n\tlocal function divisionForInt(num, den)\n\t\tlocal\
    \ i = den\n\t\twhile i > 0 do\n\t\t\tif num % i == 0 and den % i == 0 then\n\t\
    \t\t\tnum = num / i\n\t\t\t\tden = den / i\n\t\t\tend\n\t\t\ti = i - 1\n\t\tend\n\
    \t\treturn num\n\tend\n\t-- x and n converted to lowest common denominator\n\t\
    x = division(xNum * base, xDen * base)\n\tn = division(nNum * base, nDen * base)\n\
    \tlocal xNum, xDen = x:match(\"(%d+)/(%d+)\")\n\tlocal nNum, nDen = n:match(\"\
    (%d+)/(%d+)\")\n\txNum, xDen = tonumber(xNum), tonumber(xDen)\n\tnNum, nDen =\
    \ tonumber(nNum), tonumber(nDen)\n\t-- check if product of x and n is a whole\
    \ number\n\tlocal check = divisionForInt(xNum * nNum, xDen * nDen)\n\tif check\
    \ % 1 == 0 then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend", "  local\
    \ function multiply(x, n)\n    local function simplify_numerator(x, n)\n     \
    \ local function _match(x, n)\n        return x % n == 0\n      end\n      return\
    \ _match(x, n) and x / n or nil\n    end\n    local function simplify_denominator(x,\
    \ n)\n      local function _match(x, n)\n        return n % x == 0\n      end\n\
    \      return _match(x, n) and n / x or nil\n    end\n    local function _match(x,\
    \ n)\n      local function _lambda(x, n)\n        return {x, n}\n      end\n \
    \     return _lambda(x, n)\n    end\n    local function _lambda(x, n)\n      local\
    \ function _lambda(x, n)\n        return {x, n}\n      end\n      return _lambda(x,\
    \ n)\n    end\n    local function _lambda(x, n)\n      local function _lambda(x,\
    \ n)\n        return {x, n}\n      end\n      return _lambda(x, n)\n    end\n\
    \    local function _lambda(x, n)\n      local function _lambda(x, n)\n      \
    \  return {x, n}\n      end\n      return _lambda(x, n)\n    end\n    local function\
    \ _lambda(x, n)\n      local function _lambda(x, n)\n        return {x, n}\n \
    \     end\n      return _lambda(x, n)\n    end\n    local function _lambda(x,\
    \ n)\n      local function _lambda(x, n)\n        return {x, n}\n      end\n \
    \     return _lambda(x, n)\n    end\n    local function _lambda(x, n)\n      local\
    \ function _lambda(x, n)\n        return {x, n}\n      end\n      return _lambda(x,\
    \ n)\n    end\n    local function _lambda(x, n)\n      local function _lambda(x,\
    \ n)\n        return {x, n}\n      end\n      return _lambda(x, n)\n    end\n\
    \    local function _lambda(x, n)\n      local function _lambda(x, n)\n       ",
  "\tlocal xn, xd = x:match(\"(%d+)/(%d+)\")\n\tlocal nn, nd = n:match(\"(%d+)/(%d+)\"\
    )\n\tlocal num = xn * nd\n\tlocal den = xd * nn\n\treturn num % den == 0\nend",
  "    return tonumber(x) * tonumber(n) % 1 == 0\nend", "  -- TODO: Implement this\
    \ function.\n  -- Consider using the Rational data type to help you implement\
    \ this function.\n  local x_numerator, x_denominator = x:match(\"(%d+)/(%d+)\"\
    )\n  local n_numerator, n_denominator = n:match(\"(%d+)/(%d+)\")\n  local temp\
    \ = Rational(tonumber(x_numerator), tonumber(x_denominator)) * Rational(tonumber(n_numerator),\
    \ tonumber(n_denominator))\n  if tonumber(temp.denominator) == 1 then\n    return\
    \ true\n  else\n    return false\n  end\nend", "  local x_num, x_den = x:match\
    \ \"(%d+)/(%d+)\"\n  local n_num, n_den = n:match \"(%d+)/(%d+)\"\n  local num\
    \ = tonumber(x_num) * tonumber(n_den)\n  local den = tonumber(x_den) * tonumber(n_num)\n\
    \  return num % den == 0\nend", "    local function commonFactor(x, n)\n     \
    \   local i = 2\n        while i <= x and i <= n do\n            if x % i == 0\
    \ and n % i == 0 then\n                return i\n            end\n           \
    \ i = i + 1\n        end\n        return 1\n    end", "    local x_num, x_den\
    \ = x:match('(%d+)/(%d+)')\n    local n_num, n_den = n:match('(%d+)/(%d+)')\n\
    \    local divisor = math.gcd(x_num, n_den)\n    if math.gcd(x_den, n_num) % divisor\
    \ == 0 then\n        return true\n    else\n        return false\n    end\nend",
  "  local x_num, x_den = x:match('^(%d+)/(%d+)$')\n  local n_num, n_den = n:match('^(%d+)/(%d+)$')\n\
    \  return (x_num * n_den) % (x_den * n_num) == 0\nend", "    local function gcd(a,\
    \ b)\n        if b == 0 then\n            return a\n        else\n           \
    \ return gcd(b, a % b)\n        end\n    end", "    local function gcd(m, n)\n\
    \        if n == 0 then\n            return m\n        else\n            return\
    \ gcd(n, m % n)\n        end\n    end", "    local x_numerator, x_denominator\
    \ = x:match(\"(%d+)/(%d+)\")\n    local n_numerator, n_denominator = n:match(\"\
    (%d+)/(%d+)\")\n    return (x_numerator * n_denominator * n_numerator * x_denominator)\
    \ % (x_denominator * n_denominator) == 0\nend", "  local function gcd(a, b)\n\
    \    if a < b then a, b = b, a end\n    if b == 0 then return a end\n    return\
    \ gcd(b, a % b)\n  end\n  local function lcm(a, b)\n    return a * b / gcd(a,\
    \ b)\n  end\n  local x_l, x_r = x:match(\"(%d+)/(%d+)\")\n  local n_l, n_r = n:match(\"\
    (%d+)/(%d+)\")\n  local m = lcm(x_r, n_r)\n  return m / x_r % 1 == 0 and m / n_r\
    \ % 1 == 0\nend", "\tlocal x_n, x_d = x:match(\"(%d+)/(%d+)\")\n\tlocal n_n, n_d\
    \ = n:match(\"(%d+)/(%d+)\")\n\tlocal x_number = tonumber(x_n) / tonumber(x_d)\n\
    \tlocal n_number = tonumber(n_n) / tonumber(n_d)\n\tlocal res = x_number * n_number\n\
    \treturn res % 1 == 0\nend", "    local cx, cy = x:match(\"(%d+)/(%d+)\")\n  \
    \  local nx, ny = n:match(\"(%d+)/(%d+)\")\n    local d = cy * ny\n    return\
    \ d % (cx * nx) == 0\nend", "    local x_num, x_den = x:match(\"(%d+)/(%d+)\"\
    )\n    local n_num, n_den = n:match(\"(%d+)/(%d+)\")\n    x_num, x_den = tonumber(x_num),\
    \ tonumber(x_den)\n    n_num, n_den = tonumber(n_num), tonumber(n_den)\n    return\
    \ (x_num * n_den) % (x_den * n_num) == 0\nend", "    -- Write your code here\n\
    \    local function gcd(a, b)\n        while b ~= 0 do\n            a, b = b,\
    \ a % b\n        end\n        return a\n    end", "  -- check if both numbers\
    \ are valid\n  local xn, xd = string.match(x, '(%d+)/(%d+)')\n  local nn, nd =\
    \ string.match(n, '(%d+)/(%d+)')\n  assert(tonumber(xn) and tonumber(xd) and tonumber(nn)\
    \ and tonumber(nd))\n  local r = tonumber(xn) * tonumber(nd) / tonumber(xd) /\
    \ tonumber(nn)\n  return r % 1 == 0\nend", "    if not x or not n then\n     \
    \   return false\n    end\n    local x_num, x_den = string.match(x, \"(%d+)/(%d+)\"\
    )\n    local n_num, n_den = string.match(n, \"(%d+)/(%d+)\")\n    if not x_num\
    \ or not x_den or not n_num or not n_den then\n        return false\n    end\n\
    \    return tonumber(x_num) * tonumber(n_den) % tonumber(x_den) == 0\nend", " \
    \ local xn = Fraction(x):multiply(Fraction(n))\n  return xn:is_integer()\nend",
  "  local xNumerator, xDenominator = x:match(\"(%d+)/(%d+)\")\n  local nNumerator,\
    \ nDenominator = n:match(\"(%d+)/(%d+)\")\n  local xProductNumerator = (xNumerator\
    \ * nNumerator)\n  local xProductDenominator = (xDenominator * nDenominator)\n\
    \  local gcd = math.gcd(xProductNumerator, xProductDenominator)\n  local productNumerator\
    \ = xProductNumerator / gcd\n  local productDenominator = xProductDenominator\
    \ / gcd\n  if (productDenominator % productNumerator == 0) then\n    return true\n\
    \  else\n    return false\n  end\nend", "  local function lcm(m, n)\n    return\
    \ m * n / math.gcd(m, n)\n  end\n  local function tonum(s)\n    local num, den\
    \ = s:match(\"(%d+)/(%d+)\")\n    return tonumber(num), tonumber(den)\n  end\n\
    \  local xn, xd = tonum(x)\n  local nn, nd = tonum(n)\n  local lcd = lcm(xd, nd)\n\
    \  local newn = lcd / xd * xn\n  local newd = lcd / nd * nn\n  return math.mod(newn,\
    \ newd) == 0\nend", "  local x1, x2 = x:match(\"^(%d+)/(%d+)$\")\n  local n1,\
    \ n2 = n:match(\"^(%d+)/(%d+)$\")\n  local s = x1 * n2\n  local t = x2 * n1\n\
    \  return s == t\nend", "    local function gcd(a, b)\n        if b == 0 then\n\
    \            return a\n        else\n            return gcd(b, a % b)\n      \
    \  end\n    end", "    local x_numerator, x_denominator = string.match(x, \"(%d+)/(%d+)\"\
    )\n    local n_numerator, n_denominator = string.match(n, \"(%d+)/(%d+)\")\n \
    \   local r_numerator = x_numerator * n_numerator\n    local r_denominator = x_denominator\
    \ * n_denominator\n    return r_numerator % r_denominator == 0\nend", "    local\
    \ numer, denom = split('/', x)\n    local numer2, denom2 = split('/', n)\n   \
    \ local f = lcm(denom, denom2)\n    local mult1 = f / denom\n    local mult2 =\
    \ f / denom2\n    if (numer * mult1 * numer2 * mult2) % f == 0 then\n        return\
    \ true\n    else\n        return false\n    end\nend", "    local nums = split(x,\
    \ \"/\")\n    local num = tonumber(nums[1])\n    local denom = tonumber(nums[2])\n\
    \    nums = split(n, \"/\")\n    local num2 = tonumber(nums[1])\n    local denom2\
    \ = tonumber(nums[2])\n    local num3 = num * num2\n    local denom3 = denom *\
    \ denom2\n    if num3 / denom3 % 1 == 0 then\n        return true\n    else\n\
    \        return false\n    end\nend", "    local x, y = parse_fraction(x)\n  \
    \  local a, b = parse_fraction(n)\n    return (a*y) % (b*x) == 0\nend", "    local\
    \ function simplify_fraction(x)\n        local numerator, denominator = x:match(\"\
    (%d+)/(%d+)\")\n        local factor = 2\n        while numerator >= factor and\
    \ denominator >= factor do\n            if numerator % factor == 0 and denominator\
    \ % factor == 0 then\n                numerator = numerator / factor\n       \
    \         denominator = denominator / factor\n            else\n             \
    \   factor = factor + 1\n            end\n        end\n        return numerator\
    \ .. \"/\" .. denominator\n    end\n    x = simplify_fraction(x)\n    n = simplify_fraction(n)\n\
    \    local numerator_x, denominator_x = x:match(\"(%d+)/(%d+)\")\n    local numerator_n,\
    \ denominator_n = n:match(\"(%d+)/(%d+)\")\n    local numerator_product = tonumber(numerator_x)\
    \ * tonumber(numerator_n)\n    local denominator_product = tonumber(denominator_x)\
    \ * tonumber(denominator_n)\n    return numerator_product % denominator_product\
    \ == 0\nend", "    local x_n, x_d = x:match(\"(%d+)/(%d+)\")\n    local n_n, n_d\
    \ = n:match(\"(%d+)/(%d+)\")\n    x_n, x_d, n_n, n_d = tonumber(x_n), tonumber(x_d),\
    \ tonumber(n_n), tonumber(n_d)\n    return ((x_n * n_d) % (x_d * n_n)) == 0\n\
    end", "    -- Convert string to numbers\n    local x_numerator, x_denominator\
    \ = x:match(\"(%d+)/(%d+)\")\n    local n_numerator, n_denominator = n:match(\"\
    (%d+)/(%d+)\")\n    -- Multiply\n    local numerator = x_numerator * n_numerator\n\
    \    local denominator = x_denominator * n_denominator\n    -- Get the greatest\
    \ common divisor\n    while denominator ~= 0 do\n        local t = denominator\n\
    \        denominator = numerator % denominator\n        numerator = t\n    end\n\
    \    -- If the numerator is a whole number, then the number is whole\n    return\
    \ numerator == 1\nend", "    local px, pn = parse(x), parse(n)\n    return (px[1]\
    \ * pn[2]) % (px[2] * pn[1]) == 0\nend", "    local xn = tonumber(x) * tonumber(n)\n\
    \    return xn % 1 == 0\nend", "    -- Write your code here\n    local x_num,\
    \ x_den = string.match(x, \"(%d+)/(%d+)\")\n    local n_num, n_den = string.match(n,\
    \ \"(%d+)/(%d+)\")\n    return (x_num * n_den) % (x_den * n_num) == 0\nend", " \
    \ local _, _, numerator1, denominator1 = x:find(\"^(%d+)/(%d+)$\")\n  local _,\
    \ _, numerator2, denominator2 = n:find(\"^(%d+)/(%d+)$\")\n  if numerator1 and\
    \ denominator1 and numerator2 and denominator2 then\n    numerator1 = tonumber(numerator1)\n\
    \    denominator1 = tonumber(denominator1)\n    numerator2 = tonumber(numerator2)\n\
    \    denominator2 = tonumber(denominator2)\n    if numerator1 % denominator2 ==\
    \ 0 and numerator2 % denominator1 == 0 then\n      return true\n    end\n  end\n\
    \  return false\nend", "\tlocal xn = split(x, \"/\")\n\tlocal xx = split(n, \"\
    /\")\n\tlocal wynik = (xn[1]*xx[2])/(xn[2]*xx[1])\n\treturn wynik % 1 == 0\nend",
  "    local function gcd(a, b)\n        while b ~= 0 do\n            a, b = b, a\
    \ % b\n        end\n        return a\n    end\n    local xNumerator, xDenominator\
    \ = x:match(\"(%d+)/(%d+)\")\n    local nNumerator, nDenominator = n:match(\"\
    (%d+)/(%d+)\")\n    if xNumerator == nil or xDenominator == nil or nNumerator\
    \ == nil or nDenominator == nil then\n        return false\n    end\n    local\
    \ denom = xDenominator * nDenominator\n    local numer = xNumerator * nDenominator\
    \ + nNumerator * xDenominator\n    local g = gcd(denom, numer)\n    return denom/g\
    \ == numer/g\nend", "    local x_num, x_denom = x:match(\"(%d+)/(%d+)\")\n   \
    \ local n_num, n_denom = n:match(\"(%d+)/(%d+)\")\n    x_num, x_denom = tonumber(x_num),\
    \ tonumber(x_denom)\n    n_num, n_denom = tonumber(n_num), tonumber(n_denom)\n\
    \    if x_num * n_denom % x_denom == 0 and x_num * n_denom / x_denom == n_num\
    \ * x_denom / x_denom then\n        return true\n    else\n        return false\n\
    \    end\nend", "\tx_num, x_den = string.match(x, \"(%d+)/(%d+)\")\n\tn_num, n_den\
    \ = string.match(n, \"(%d+)/(%d+)\")\n\ty_num = x_num * n_num\n\ty_den = x_den\
    \ * n_den\n\treturn y_num % y_den == 0\nend", "    local xNum, xDenom = unpack(split(x,\
    \ \"/\"))\n    local nNum, nDenom = unpack(split(n, \"/\"))\n    return tonumber(xNum)\
    \ * tonumber(nDenom) % tonumber(nNum) == 0\nend", "\t-- If a fraction has a whole\
    \ number as its numerator, then the fraction evaluates to\n\t-- the numerator.\n\
    \tif tonumber(x) then\n\t\treturn tonumber(x) == tonumber(n)\n\tend\n\t-- The\
    \ fraction evaluates to a whole number if its denominator is 1.\n\tif n == \"\
    1/1\" then\n\t\treturn true\n\tend\n\t-- To make sure a fraction evaluates to\
    \ a whole number, its denominator must be\n\t-- divisible by the fraction's numerator.\n\
    \tlocal nNumerator = tonumber(string.match(n, \"^(%d+)\"))\n\tlocal nDenominator\
    \ = tonumber(string.match(n, \"(%d+)$\"))\n\tlocal xNumerator = tonumber(string.match(x,\
    \ \"^(%d+)\"))\n\tlocal xDenominator = tonumber(string.match(x, \"(%d+)$\"))\n\
    \treturn nDenominator % xNumerator == 0\nend", "    local function gcd(a, b)\n\
    \        if a < b then\n            a, b = b, a\n        end\n        while b\
    \ ~= 0 do\n            local r = a % b\n            a = b\n            b = r\n\
    \        end\n        return a\n    end\n    local function lcm(a, b)\n      \
    \  local prod = a * b\n        local hcf = gcd(a, b)\n        return prod / hcf\n\
    \    end\n    local function simplify(x)\n        local function numden(x)\n \
    \           local num, den = x:match(\"^(%d+)/(%d+)$\")\n            num, den\
    \ = tonumber(num), tonumber(den)\n            return num, den\n        end\n \
    \       local num, den = numden(x)\n        local hcf = gcd(num, den)\n      \
    \  num, den = num / hcf, den / hcf\n        return num, den\n    end\n    local\
    \ function mul(x, n)\n        local function numden(x)\n            local num,\
    \ den = x:match(\"^(%d+)/(%d+)$\")\n            num, den = tonumber(num), tonumber(den)\n\
    \            return num, den\n        end\n        local xn, xd = numden(x)\n\
    \        local nn, nd = numden(n)\n        local hcf = lcm(xd, nd)\n        xn,\
    \ xd = xn * (hcf / xd), hcf\n        nn, nd = nn * (hcf / nd), hcf\n        return\
    \ xn * nn, xd\n    end\n    local xn, xd = simplify(x)\n    local nn, nd = simplify(n)\n\
    \    local hcf = lcm(xd, nd)\n    xn, xd = xn * (hcf / xd), hcf\n    nn, nd =\
    \ nn * (hcf / nd), hcf\n    local num, den = mul(x, n)\n    local hcf = gcd(num,\
    \ den)\n    num, den = num / hcf, den / hcf\n    if den ~=", "\tx = tonumber(x)\n\
    \tn = tonumber(n)\n\treturn x * n % 1 == 0\nend", "    -- Write your code here\n\
    \    local function reduce(s)\n        local x, y = (s:match '^%d+/%d+$') or (s:match\
    \ '^(%d+)$'), (s:match '^%d+/(%d+)$') or (s:match '^(%d+)$')\n        if not x\
    \ or not y then\n            return nil\n        end\n        x, y = tonumber(x),\
    \ tonumber(y)\n        local gcd = math.gcd(x, y)\n        return tostring(x/gcd)\
    \ .. '/' .. tostring(y/gcd)\n    end\n    local function multiply(x, n)\n    \
    \    local x_n, x_d, n_n, n_d = x:match '^(%d+)/(%d+)$', n:match '^(%d+)/(%d+)$'\n\
    \        if not x_n or not x_d or not n_n or not n_d then\n            return\
    \ nil\n        end\n        x_n, x_d, n_n, n_d = tonumber(x_n), tonumber(x_d),\
    \ tonumber(n_n), tonumber(n_d)\n        local s_n, s_d = x_n * n_n, x_d * n_d\n\
    \        return tostring(s_n) .. '/' .. tostring(s_d)\n    end\n    x, n = reduce(x),\
    \ reduce(n)\n    if not x or not n then\n        return nil\n    end\n    local\
    \ result = reduce(multiply(x, n))\n    local result_n, result_d = result:match\
    \ '^(%d+)/(%d+)$'\n    if not result_n or not result_d then\n        return nil\n\
    \    end\n    result_n, result_d = tonumber(result_n), tonumber(result_d)\n  \
    \  return result_d == 1\nend", "    local function reduce(x)\n        local frac\
    \ = x:split(\"/\")\n        local numerator = tonumber(frac[1])\n        local\
    \ denominator = tonumber(frac[2])\n        local divisor = 2\n        while divisor\
    \ <= numerator do\n            if numerator % divisor == 0 and denominator % divisor\
    \ == 0 then\n                numerator = numerator / divisor\n               \
    \ denominator = denominator / divisor\n            else\n                divisor\
    \ = divisor + 1\n            end\n        end\n        return numerator .. \"\
    /\" .. denominator\n    end\n    local y = reduce(x)\n    return y == n\nend",
  "  return math.modf(tonumber(x) * tonumber(n)) == tonumber(x) * tonumber(n)\nend",
  "    local xp = parse_fraction(x)\n    local np = parse_fraction(n)\n    return\
    \ xp.numerator * np.denominator * np.numerator * xp.denominator % (xp.denominator\
    \ * np.denominator) == 0\nend", "    local function gcd(a, b)\n        if b ==\
    \ 0 then\n            return a\n        else\n            return gcd(b, a % b)\n\
    \        end\n    end", "  local x_numerator, x_denominator = x:match('(%d+)/(%d+)')\n\
    \  local n_numerator, n_denominator = n:match('(%d+)/(%d+)')\n  x_numerator, x_denominator\
    \ = tonumber(x_numerator), tonumber(x_denominator)\n  n_numerator, n_denominator\
    \ = tonumber(n_numerator), tonumber(n_denominator)\n  local result = (x_numerator\
    \ * n_denominator) / (x_denominator * n_numerator)\n  return not (result % 1 >\
    \ 0)\nend", "    local function gcd(a, b)\n        if b == 0 then\n          \
    \  return a\n        else\n            return gcd(b, a % b)\n        end\n   \
    \ end", "    local fx = tonumber(x:match(\"(%d+)/(%d+)\"))\n    local fn = tonumber(n:match(\"\
    (%d+)/(%d+)\"))\n    return fx * fn % 1 == 0\nend", '  local xn = x .. n', " \
    \ -- your code here\n  local xnum, xden = x:match(\"(%d+)/(%d+)\")\n  local nnum,\
    \ nden = n:match(\"(%d+)/(%d+)\")\n  xnum, xden = tonumber(xnum), tonumber(xden)\n\
    \  nnum, nden = tonumber(nnum), tonumber(nden)\n  local pxnum, pxden = xnum *\
    \ nden, xden * nnum\n  return pxnum % pxden == 0\nend", "  local num1, den1 =\
    \ string.match(x, \"(%d+)/(%d+)\")\n  local num2, den2 = string.match(n, \"(%d+)/(%d+)\"\
    )\n  num1, den1, num2, den2 = tonumber(num1), tonumber(den1), tonumber(num2),\
    \ tonumber(den2)\n  local num = num1 * num2\n  local den = den1 * den2\n  local\
    \ factor = math.gcd(num, den)\n  if factor > 1 then\n    num = num / factor\n\
    \    den = den / factor\n  end\n  return num % den == 0\nend", "    local num,\
    \ den = x:match(\"(%d+)/(%d+)\")\n    num, den = tonumber(num), tonumber(den)\n\
    \    local num1, den1 = n:match(\"(%d+)/(%d+)\")\n    num1, den1 = tonumber(num1),\
    \ tonumber(den1)\n    local result = num * den1\n    return result % num1 == 0\n\
    end", "    local function gcd(a, b)\n        if b == 0 then\n            return\
    \ a\n        else\n            return gcd(b, a % b)\n        end\n    end", " \
    \ -- Get the LHS and RHS numerators and denominators.\n  local xNum, xDen = x:match(\"\
    (%d+)/(%d+)\")\n  local nNum, nDen = n:match(\"(%d+)/(%d+)\")\n  -- Multiply the\
    \ numerators together, and the denominators together.\n  local resultNum = tonumber(xNum)\
    \ * tonumber(nNum)\n  local resultDen = tonumber(xDen) * tonumber(nDen)\n  --\
    \ Result is only a whole number if num and den are the same.\n  return resultNum\
    \ == resultDen\nend", "\t-- get numerator and denominator\n\tlocal x_numerator,\
    \ x_denominator = x:match(\"(%d+)/(%d+)\")\n\tlocal n_numerator, n_denominator\
    \ = n:match(\"(%d+)/(%d+)\")\n\tlocal result = ((x_numerator * n_denominator)\
    \ / (x_denominator * n_numerator))\n\t-- check if it's a whole number\n\tif result\
    \ % 1 == 0 then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend", "   \
    \ local xNum, xDen = x:match(\"(%d+)/(%d+)\")\n    local nNum, nDen = n:match(\"\
    (%d+)/(%d+)\")\n    local productNum = tonumber(xNum) * tonumber(nNum)\n    local\
    \ productDen = tonumber(xDen) * tonumber(nDen)\n    if productNum % productDen\
    \ == 0 then\n        return true\n    else\n        return false\n    end\nend",
  "  local function is_integer(x)\n    return x % 1 == 0\n  end\n  local numerator1,\
    \ denominator1 = x:match(\"^(%d+)/(%d+)$\")\n  local numerator2, denominator2\
    \ = n:match(\"^(%d+)/(%d+)$\")\n  numerator1, denominator1 = tonumber(numerator1),\
    \ tonumber(denominator1)\n  numerator2, denominator2 = tonumber(numerator2), tonumber(denominator2)\n\
    \  return is_integer(numerator1 * denominator2 / denominator1 * numerator2)\n\
    end", "    local x_numerator, x_denominator = x:match(\"^(%d+)/(%d+)$\")\n   \
    \ local n_numerator, n_denominator = n:match(\"^(%d+)/(%d+)$\")\n    local function\
    \ gcd(a, b)\n        return b == 0 and a or gcd(b, a % b)\n    end\n    local\
    \ c = x_numerator * n_denominator\n    local d = x_denominator * n_numerator\n\
    \    local g = gcd(c, d)\n    local e = c / g\n    local f = d / g\n    return\
    \ e == f\nend", "  --your code here\n  local a = x:split('/')\n  local b = n:split('/')\n\
    \  -- print(\"(\"..a[1]..\"*\"..b[2]..\")/(\"..a[2]..\"*\"..b[1]..\")\")\n  local\
    \ i = (tonumber(a[1])*tonumber(b[2]))/(tonumber(a[2])*tonumber(b[1]))\n  -- print(tostring(i))\n\
    \  if i%1==0 then\n    return true\n  else\n    return false\n  end\nend", "\t\
    local x_numerator, x_denominator = split(x, \"/\")\n\tlocal n_numerator, n_denominator\
    \ = split(n, \"/\")\n\tlocal result_numerator = x_numerator * n_numerator\n\t\
    local result_denominator = x_denominator * n_denominator\n\treturn result_numerator\
    \ % result_denominator == 0\nend", "    local function convertToNumber(x)\n  \
    \      local num, den = x:match(\"(%d+)/(%d+)\")\n        return tonumber(num)\
    \ / tonumber(den)\n    end\n    local x = convertToNumber(x)\n    local n = convertToNumber(n)\n\
    \    local result = x * n\n    return math.floor(result) == result\nend", "  x\
    \ = x:split('/')\n  n = n:split('/')\n  local lcm = math.lcm(x[2], n[2])\n  local\
    \ xm = lcm/x[2]\n  local nm = lcm/n[2]\n  return lcm == xm*nm*n[1]\nend", "  --\
    \ your code here\nend", "  local function gcd(a, b)\n    if a == 0 then return\
    \ b end\n    return gcd(b % a, a)\n  end\n  local function lcm(a, b)\n    return\
    \ a * b / gcd(a, b)\n  end\n  local function simplify_fraction(a, b)\n    local\
    \ g = gcd(a, b)\n    if g == 1 then return a, b end\n    return a / g, b / g\n\
    \  end\n  local xn, xd = x:match('^(%d+)/(%d+)$')\n  local nn, nd = n:match('^(%d+)/(%d+)$')\n\
    \  local l = lcm(xd, nd)\n  return l / xd * xn == l / nd * nn\nend", "    local\
    \ x1, x2 = unpack(split(x, \"/\"))\n    local n1, n2 = unpack(split(n, \"/\"))\n\
    \    return (x1 * n2) % (x2 * n1) == 0\nend", "  local function gcd(a, b)\n  \
    \  while b ~= 0 do\n      a, b = b, a % b\n    end\n    return a\n  end\n  local\
    \ den1, num1 = x:match(\"(%d+)/(%d+)\")\n  local den2, num2 = n:match(\"(%d+)/(%d+)\"\
    )\n  den1, num1, den2, num2 = tonumber(den1), tonumber(num1), tonumber(den2),\
    \ tonumber(num2)\n  local den3 = den1 * den2\n  local num3 = num1 * num2\n  local\
    \ d = gcd(den3, num3)\n  den3, num3 = den3 / d, num3 / d\n  return den3 == num3\n\
    end", "  -- write your code here\nend", "    local x_numerator, x_denominator\
    \ = tonumber(x:match(\"^(%d+)/\")), tonumber(x:match(\"/(%d+)$\"))\n    local\
    \ n_numerator, n_denominator = tonumber(n:match(\"^(%d+)/\")), tonumber(n:match(\"\
    /(%d+)$\"))\n    if x_numerator * n_denominator == n_numerator * x_denominator\
    \ then\n        return true\n    else\n        return false\n    end\nend", " \
    \ local xn = x .. \" * \" .. n\n  local answer = math.floor(tonumber(x) * tonumber(n))\n\
    \  local answer = (answer == tonumber(answer))\n  return answer\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
