name: HumanEval_6_parse_nested_parens
language: ts
prompt: "//Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\"\
  )\n// [2, 3, 1, 3]\nfunction parse_nested_parens(paren_string: string): number[]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = parse_nested_parens;\n  assert.deepEqual(candidate(\"\
  (()()) ((())) () ((())()())\"),[2, 3, 1, 3]);\n  assert.deepEqual(candidate(\"()\
  \ (()) ((())) (((())))\"),[1, 2, 3, 4]);\n  assert.deepEqual(candidate(\"(()(())((())))\"\
  ),[4]);\n}\n\ntest();"
completions: ["  const paren_groups = paren_string.split(\" \");\n  const result:\
    \ number[] = [];\n  for (const paren_group of paren_groups) {\n    let max_level\
    \ = 0;\n    let level = 0;\n    for (const paren of paren_group) {\n      if (paren\
    \ === \"(\") {\n        level++;\n        max_level = Math.max(max_level, level);\n\
    \      } else if (paren === \")\") {\n        level--;\n      }\n    }\n    result.push(max_level);\n\
    \  }\n  return result;\n}\n", "    let result: number[] = [];\n    let paren_groups:\
    \ string[] = paren_string.split(\" \");\n    for (let i = 0; i < paren_groups.length;\
    \ i++) {\n        let paren_group: string = paren_groups[i];\n        let paren_stack:\
    \ string[] = [];\n        let max_depth: number = 0;\n        for (let j = 0;\
    \ j < paren_group.length; j++) {\n            let paren: string = paren_group[j];\n\
    \            if (paren === \"(\") {\n                paren_stack.push(paren);\n\
    \                max_depth = Math.max(max_depth, paren_stack.length);\n      \
    \      } else if (paren === \")\") {\n                paren_stack.pop();\n   \
    \         }\n        }\n        result.push(max_depth);\n    }\n    return result;\n\
    }\n", "    let paren_array = paren_string.split(\" \");\n    let result = [];\n\
    \    for (let paren_group of paren_array) {\n        let max_nesting = 0;\n  \
    \      let current_nesting = 0;\n        for (let paren of paren_group) {\n  \
    \          if (paren === \"(\") {\n                current_nesting++;\n      \
    \          if (current_nesting > max_nesting) {\n                    max_nesting\
    \ = current_nesting;\n                }\n            } else if (paren === \")\"\
    ) {\n                current_nesting--;\n            }\n        }\n        result.push(max_nesting);\n\
    \    }\n    return result;\n}\n", "  let paren_array = paren_string.split(\" \"\
    );\n  let result: number[] = [];\n  for (let i = 0; i < paren_array.length; i++)\
    \ {\n    let paren_count = 0;\n    let max_paren_count = 0;\n    for (let j =\
    \ 0; j < paren_array[i].length; j++) {\n      if (paren_array[i][j] === \"(\"\
    ) {\n        paren_count++;\n      } else if (paren_array[i][j] === \")\") {\n\
    \        paren_count--;\n      }\n      if (paren_count > max_paren_count) {\n\
    \        max_paren_count = paren_count;\n      }\n    }\n    result.push(max_paren_count);\n\
    \  }\n  return result;\n}\n", "    let result: number[] = [];\n    let paren_groups:\
    \ string[] = paren_string.split(\" \");\n    for (let i = 0; i < paren_groups.length;\
    \ i++) {\n        let paren_group: string = paren_groups[i];\n        let max_nesting:\
    \ number = 0;\n        let current_nesting: number = 0;\n        for (let j =\
    \ 0; j < paren_group.length; j++) {\n            if (paren_group[j] === \"(\"\
    ) {\n                current_nesting++;\n                if (current_nesting >\
    \ max_nesting) {\n                    max_nesting = current_nesting;\n       \
    \         }\n            } else if (paren_group[j] === \")\") {\n            \
    \    current_nesting--;\n            }\n        }\n        result.push(max_nesting);\n\
    \    }\n    return result;\n}\n", "    const paren_groups = paren_string.split(\"\
    \ \");\n    const result: number[] = [];\n    for (const paren_group of paren_groups)\
    \ {\n        let max_depth = 0;\n        let depth = 0;\n        for (const paren\
    \ of paren_group) {\n            if (paren === \"(\") {\n                depth++;\n\
    \            } else if (paren === \")\") {\n                depth--;\n       \
    \     }\n            if (depth > max_depth) {\n                max_depth = depth;\n\
    \            }\n        }\n        result.push(max_depth);\n    }\n    return\
    \ result;\n}\n", "  const paren_groups = paren_string.split(\" \");\n  const result:\
    \ number[] = [];\n  for (const paren_group of paren_groups) {\n    let max_nesting\
    \ = 0;\n    let current_nesting = 0;\n    for (const paren of paren_group) {\n\
    \      if (paren === \"(\") {\n        current_nesting++;\n        max_nesting\
    \ = Math.max(max_nesting, current_nesting);\n      } else if (paren === \")\"\
    ) {\n        current_nesting--;\n      }\n    }\n    result.push(max_nesting);\n\
    \  }\n  return result;\n}\n", "    let paren_groups = paren_string.split(\" \"\
    );\n    let paren_levels = [];\n    for (let i = 0; i < paren_groups.length; i++)\
    \ {\n        let paren_group = paren_groups[i];\n        let paren_level = 0;\n\
    \        let max_paren_level = 0;\n        for (let j = 0; j < paren_group.length;\
    \ j++) {\n            if (paren_group[j] === \"(\") {\n                paren_level++;\n\
    \                if (paren_level > max_paren_level) {\n                    max_paren_level\
    \ = paren_level;\n                }\n            } else if (paren_group[j] ===\
    \ \")\") {\n                paren_level--;\n            }\n        }\n       \
    \ paren_levels.push(max_paren_level);\n    }\n    return paren_levels;\n}\n",
  "    let result: number[] = [];\n    let paren_groups: string[] = paren_string.split(\"\
    \ \");\n    for (let paren_group of paren_groups) {\n        let max_depth: number\
    \ = 0;\n        let current_depth: number = 0;\n        for (let paren of paren_group)\
    \ {\n            if (paren === \"(\") {\n                current_depth++;\n  \
    \              if (current_depth > max_depth) {\n                    max_depth\
    \ = current_depth;\n                }\n            } else if (paren === \")\"\
    ) {\n                current_depth--;\n            }\n        }\n        result.push(max_depth);\n\
    \    }\n    return result;\n}\n", "    let paren_groups = paren_string.split(\"\
    \ \");\n    let max_nesting_levels = [];\n    for (let i = 0; i < paren_groups.length;\
    \ i++) {\n        let paren_group = paren_groups[i];\n        let max_nesting_level\
    \ = 0;\n        let current_nesting_level = 0;\n        for (let j = 0; j < paren_group.length;\
    \ j++) {\n            let char = paren_group[j];\n            if (char === \"\
    (\") {\n                current_nesting_level++;\n            } else if (char\
    \ === \")\") {\n                current_nesting_level--;\n            }\n    \
    \        if (current_nesting_level > max_nesting_level) {\n                max_nesting_level\
    \ = current_nesting_level;\n            }\n        }\n        max_nesting_levels.push(max_nesting_level);\n\
    \    }\n    return max_nesting_levels;\n}\n", "    const result: number[] = [];\n\
    \    const paren_groups = paren_string.split(\" \");\n    for (const paren_group\
    \ of paren_groups) {\n        let max_nesting = 0;\n        let current_nesting\
    \ = 0;\n        for (const paren of paren_group) {\n            if (paren ===\
    \ \"(\") {\n                current_nesting++;\n            } else if (paren ===\
    \ \")\") {\n                current_nesting--;\n            }\n            if\
    \ (current_nesting > max_nesting) {\n                max_nesting = current_nesting;\n\
    \            }\n        }\n        result.push(max_nesting);\n    }\n    return\
    \ result;\n}\n", "    let paren_groups = paren_string.split(\" \");\n    let paren_levels\
    \ = [];\n    for (let paren_group of paren_groups) {\n        paren_levels.push(get_paren_level(paren_group));\n\
    \    }\n    return paren_levels;\n}\n", "  const paren_groups = paren_string.split(\"\
    \ \");\n  const result: number[] = [];\n  for (const paren_group of paren_groups)\
    \ {\n    const stack: string[] = [];\n    let max_depth = 0;\n    for (const char\
    \ of paren_group) {\n      if (char === \"(\") {\n        stack.push(char);\n\
    \        max_depth = Math.max(max_depth, stack.length);\n      } else if (char\
    \ === \")\") {\n        stack.pop();\n      }\n    }\n    result.push(max_depth);\n\
    \  }\n  return result;\n}\n", "  let result: number[] = [];\n  let paren_groups:\
    \ string[] = paren_string.split(\" \");\n  for (let i = 0; i < paren_groups.length;\
    \ i++) {\n    let paren_group: string = paren_groups[i];\n    let paren_stack:\
    \ string[] = [];\n    let max_level: number = 0;\n    let level: number = 0;\n\
    \    for (let j = 0; j < paren_group.length; j++) {\n      let paren: string =\
    \ paren_group[j];\n      if (paren === \"(\") {\n        paren_stack.push(paren);\n\
    \        level++;\n        if (level > max_level) {\n          max_level = level;\n\
    \        }\n      } else if (paren === \")\") {\n        paren_stack.pop();\n\
    \        level--;\n      }\n    }\n    result.push(max_level);\n  }\n  return\
    \ result;\n}\n", "    let result: number[] = [];\n    let paren_array: string[]\
    \ = paren_string.split(\" \");\n    for (let i = 0; i < paren_array.length; i++)\
    \ {\n        let paren_group: string = paren_array[i];\n        let paren_stack:\
    \ string[] = [];\n        let max_nesting: number = 0;\n        for (let j = 0;\
    \ j < paren_group.length; j++) {\n            let paren: string = paren_group[j];\n\
    \            if (paren === \"(\") {\n                paren_stack.push(paren);\n\
    \                max_nesting = Math.max(max_nesting, paren_stack.length);\n  \
    \          } else if (paren === \")\") {\n                paren_stack.pop();\n\
    \            }\n        }\n        result.push(max_nesting);\n    }\n    return\
    \ result;\n}\n", "    let paren_groups = paren_string.split(\" \");\n    let paren_levels\
    \ = [];\n    for (let i = 0; i < paren_groups.length; i++) {\n        let paren_group\
    \ = paren_groups[i];\n        let paren_level = 0;\n        let max_paren_level\
    \ = 0;\n        for (let j = 0; j < paren_group.length; j++) {\n            if\
    \ (paren_group[j] === \"(\") {\n                paren_level++;\n             \
    \   if (paren_level > max_paren_level) {\n                    max_paren_level\
    \ = paren_level;\n                }\n            } else if (paren_group[j] ===\
    \ \")\") {\n                paren_level--;\n            }\n        }\n       \
    \ paren_levels.push(max_paren_level);\n    }\n    return paren_levels;\n}\n",
  "  const paren_groups = paren_string.split(\" \");\n  const result: number[] = [];\n\
    \  for (const group of paren_groups) {\n    let max_level = 0;\n    let current_level\
    \ = 0;\n    for (const char of group) {\n      if (char === \"(\") {\n       \
    \ current_level++;\n        max_level = Math.max(max_level, current_level);\n\
    \      } else if (char === \")\") {\n        current_level--;\n      }\n    }\n\
    \    result.push(max_level);\n  }\n  return result;\n}\n", "  const paren_groups\
    \ = paren_string.split(\" \");\n  const max_nesting_levels = paren_groups.map(paren_group\
    \ => {\n    let max_level = 0;\n    let current_level = 0;\n    for (let i = 0;\
    \ i < paren_group.length; i++) {\n      if (paren_group[i] === \"(\") {\n    \
    \    current_level++;\n        if (current_level > max_level) {\n          max_level\
    \ = current_level;\n        }\n      } else if (paren_group[i] === \")\") {\n\
    \        current_level--;\n      }\n    }\n    return max_level;\n  });\n  return\
    \ max_nesting_levels;\n}\n", "    let result: number[] = [];\n    let paren_array:\
    \ string[] = paren_string.split(\" \");\n    for (let i = 0; i < paren_array.length;\
    \ i++) {\n        let paren_group: string = paren_array[i];\n        let max_depth:\
    \ number = 0;\n        let current_depth: number = 0;\n        for (let j = 0;\
    \ j < paren_group.length; j++) {\n            if (paren_group[j] === \"(\") {\n\
    \                current_depth++;\n                if (current_depth > max_depth)\
    \ {\n                    max_depth = current_depth;\n                }\n     \
    \       } else if (paren_group[j] === \")\") {\n                current_depth--;\n\
    \            }\n        }\n        result.push(max_depth);\n    }\n    return\
    \ result;\n}\n", "  const paren_groups = paren_string.split(\" \");\n  const result:\
    \ number[] = [];\n  for (const group of paren_groups) {\n    result.push(parse_nested_parens_helper(group));\n\
    \  }\n  return result;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
