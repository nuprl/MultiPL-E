name: HumanEval_129_minPath
language: ts
prompt: "//Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have\
  \ to find the minimum path of length k in the grid. You can start\n// from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n// in other words,\
  \ you can go to cells which share an edge with you current\n// cell.\n// Please\
  \ note that a path of length k means visiting exactly k cells (not\n// necessarily\
  \ distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered\
  \ less than a path B (of length k) if\n// after making the ordered lists of the\
  \ values on the cells that A and B go\n// through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n// than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer\
  \ is unique.\n// Return an ordered list of the values on the cells that the minimum\
  \ path go through.\n// Examples:    \n// >>> minPath([[1, 2, 3], [4, 5, 6], [7,\
  \ 8, 9]], 3)\n// [1, 2, 1]\n// >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n\
  // [1]\nfunction minPath(grid: number[][], k: number): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = minPath;\n  assert.deepEqual(candidate([[1, 2, 3],\
  \ [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);\n  assert.deepEqual(candidate([[5, 9, 3],\
  \ [4, 1, 6], [7, 8, 2]], 1),[1]);\n  assert.deepEqual(candidate([[1, 2, 3, 4], [5,\
  \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);\n  assert.deepEqual(candidate([[6,\
  \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10,\
  \ 1, 10, 1]);\n  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5,\
  \ 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);\n  assert.deepEqual(candidate([[11,\
  \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1,\
  \ 6, 1, 6, 1]);\n  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5,\
  \ 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n  assert.deepEqual(candidate([[2,\
  \ 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);\n  assert.deepEqual(candidate([[6,\
  \ 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);\n  assert.deepEqual(candidate([[1,\
  \ 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n  assert.deepEqual(candidate([[1,\
  \ 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n\ntest();"
completions: ["    const n = grid.length;\n    const m = grid[0].length;\n    const\
    \ dp = new Array(n).fill(0).map(() => new Array(m).fill(0).map(() => new Array(k\
    \ + 1).fill(Infinity)));\n    const prev = new Array(n).fill(0).map(() => new\
    \ Array(m).fill(0).map(() => new Array(k + 1).fill(null)));\n    for (let i =\
    \ 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n        }\n    }\n    for (let i = 0; i < n; i++) {\n       \
    \ for (let j = 0; j < m; j++) {\n            for (let l = 2; l <= k; l++) {\n\
    \                for (let di = -1; di <= 1; di++) {\n                    for (let\
    \ dj = -1; dj <= 1; dj++) {\n                        if (Math.abs(di) + Math.abs(dj)\
    \ !== 1) {\n                            continue;\n                        }\n\
    \                        const ni = i + di;\n                        const nj\
    \ = j + dj;\n                        if (ni < 0 || ni >= n || nj < 0 || nj >=\
    \ m) {\n                            continue;\n                        }\n   \
    \                     const cur = dp[ni][nj][l - 1] + grid[i][j];\n          \
    \              if (cur < dp[i][j][l]) {\n                            dp[i][j][l]\
    \ = cur;\n                            prev[i][j][l] = [ni, nj, l - 1];\n     \
    \                   }\n                    }\n                }\n            }\n\
    \        }\n    }\n    let min = Infinity;\n    let minI = -1;\n    let minJ =\
    \ -1;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            if (dp[i][j][k] < min) {\n                min = dp[i][j][k];\n\
    \                minI =", "    const n = grid.length;\n    const dp: number[][][]\
    \ = [];\n    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n        for (let\
    \ j = 0; j < n; j++) {\n            dp[i][j] = [];\n        }\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n         \
    \   if (i === 0 && j === 0) {\n                dp[i][j][0] = grid[i][j];\n   \
    \         } else if (i === 0) {\n                dp[i][j][0] = dp[i][j - 1][0]\
    \ + grid[i][j];\n            } else if (j === 0) {\n                dp[i][j][0]\
    \ = dp[i - 1][j][0] + grid[i][j];\n            } else {\n                dp[i][j][0]\
    \ = Math.min(dp[i - 1][j][0], dp[i][j - 1][0]) + grid[i][j];\n            }\n\
    \        }\n    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < n; j++) {\n            for (let l = 1; l < k; l++) {\n                if\
    \ (i === 0 && j === 0) {\n                    dp[i][j][l] = grid[i][j];\n    \
    \            } else if (i === 0) {\n                    dp[i][j][l] = dp[i][j\
    \ - 1][l] + grid[i][j];\n                } else if (j === 0) {\n             \
    \       dp[i][j][l] = dp[i - 1][j][l] + grid[i][j];\n                } else {\n\
    \                    dp[i][j][l] = Math.min(dp[i - 1][j][l], dp[i][j - 1][l])\
    \ + grid[i][j];\n                }\n            }\n        }\n    }\n    const\
    \ path: number[]", "    const n = grid.length;\n    const m = grid[0].length;\n\
    \    const visited = new Set<string>();\n    const queue = new PriorityQueue<[number[],\
    \ number[]]>((a, b) => {\n        for (let i = 0; i < k; i++) {\n            if\
    \ (a[0][i] < b[0][i]) {\n                return -1;\n            } else if (a[0][i]\
    \ > b[0][i]) {\n                return 1;\n            }\n        }\n        return\
    \ 0;\n    });\n    const start = [0, 0];\n    const startPath = [grid[0][0]];\n\
    \    queue.enqueue([startPath, start]);\n    while (!queue.isEmpty()) {\n    \
    \    const [path, [i, j]] = queue.dequeue();\n        if (path.length === k) {\n\
    \            return path;\n        }\n        if (i > 0 && !visited.has(`${i -\
    \ 1},${j}`)) {\n            const newPath = [...path, grid[i - 1][j]];\n     \
    \       queue.enqueue([newPath, [i - 1, j]]);\n            visited.add(`${i -\
    \ 1},${j}`);\n        }\n        if (i < n - 1 && !visited.has(`${i + 1},${j}`))\
    \ {\n            const newPath = [...path, grid[i + 1][j]];\n            queue.enqueue([newPath,\
    \ [i + 1, j]]);\n            visited.add(`${i + 1},${j}`);\n        }\n      \
    \  if (j > 0 && !visited.has(`${i},${j - 1}`)) {\n            const newPath =\
    \ [...path, grid[i][j - 1]];\n            queue.enqueue([newPath, [i, j - 1]]);\n\
    \            visited.add(`${i},${j - 1}`);\n        }\n        if (j < m - 1 &&\
    \ !visited.has(`${i},${j + 1}`)) {\n            const newPath = [...path, grid[i][j\
    \ + 1", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i] = new\
    \ Array(m).fill(false);\n    }\n    let result = [];\n    let min = Number.MAX_SAFE_INTEGER;\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          let path = [];\n            dfs(grid, i, j, k, path, visited);\n  \
    \          if (path.length === k) {\n                if (path.join('') < min)\
    \ {\n                    min = path.join('');\n                    result = path;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\n",
  "    // your code goes here\n    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let minSum2 = Infinity;\n\
    \    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n  \
    \          let path = [];\n            let sum = 0;\n            let pathSum =\
    \ 0;\n            let pathSum2 = 0;\n            let path2 = [];\n           \
    \ let sum2 = 0;\n            for (let l = 0; l < k; l++) {\n                let\
    \ min = Infinity;\n                let min2 = Infinity;\n                let minI\
    \ = 0;\n                let minJ = 0;\n                let minI2 = 0;\n      \
    \          let minJ2 = 0;\n                for (let ii = Math.max(0, i - 1); ii\
    \ <= Math.min(n - 1, i + 1); ii++) {\n                    for (let jj = Math.max(0,\
    \ j - 1); jj <= Math.min(m - 1, j + 1); jj++) {\n                        if (grid[ii][jj]\
    \ < min) {\n                            min = grid[ii][jj];\n                \
    \            minI = ii;\n                            minJ = jj;\n            \
    \            }\n                        if (grid[ii][jj] < min2 && grid[ii][jj]\
    \ > grid[i][j]) {\n                            min2 = grid[ii][jj];\n        \
    \                    minI2 = ii;\n                            minJ2 = jj;\n  \
    \                      }\n                    }\n                }\n         \
    \       if (min2 == Infinity) {\n                    min2 = min;\n           \
    \         minI2 = minI;\n                    minJ2 = minJ;\n                }\n\
    \                path.push(min);\n                sum += min;\n              \
    \  pathSum += min * (l + 1);\n                path2.push(min2);\n            \
    \    sum2 += min2;\n                pathSum2 += min2 * (l + 1);\n            \
    \    i = minI;\n                j = min", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let minPaths: number[][][] = [];\n    for (let i = 0;\
    \ i < n; i++) {\n        minPaths[i] = [];\n        for (let j = 0; j < m; j++)\
    \ {\n            minPaths[i][j] = [];\n        }\n    }\n    for (let i = 0; i\
    \ < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (i > 0) {\n\
    \                if (grid[i][j] < grid[i - 1][j]) {\n                    minPaths[i][j]\
    \ = minPaths[i - 1][j].slice();\n                    minPaths[i][j].push(grid[i][j]);\n\
    \                } else if (grid[i][j] > grid[i - 1][j]) {\n                 \
    \   minPaths[i][j] = minPaths[i - 1][j].slice();\n                    minPaths[i][j].push(grid[i\
    \ - 1][j]);\n                } else {\n                    minPaths[i][j] = minPaths[i\
    \ - 1][j].slice();\n                    minPaths[i][j].push(grid[i][j]);\n   \
    \             }\n            } else if (j > 0) {\n                if (grid[i][j]\
    \ < grid[i][j - 1]) {\n                    minPaths[i][j] = minPaths[i][j - 1].slice();\n\
    \                    minPaths[i][j].push(grid[i][j]);\n                } else\
    \ if (grid[i][j] > grid[i][j - 1]) {\n                    minPaths[i][j] = minPaths[i][j\
    \ - 1].slice();\n                    minPaths[i][j].push(grid[i][j - 1]);\n  \
    \              } else {\n                    minPaths[i][j] = minPaths[i][j -\
    \ 1].slice();\n                    minPaths[i][j].push(grid[i][j]);\n        \
    \        }\n            } else {\n                minPaths[i][j] =", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n    let minPath = new Array(k).fill(Infinity);\n\
    \    let minPaths = [];\n    let dfs = (i: number, j: number, path: number[])\
    \ => {\n        if (path.length === k) {\n            if (path.join('') < minPath.join(''))\
    \ {\n                minPath = path;\n                minPaths = [];\n       \
    \     }\n            if (path.join('') === minPath.join('')) {\n             \
    \   minPaths.push(path);\n            }\n            return;\n        }\n    \
    \    if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n            return;\n\
    \        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n  \
    \      dfs(i - 1, j, path.slice());\n        dfs(i + 1, j, path.slice());\n  \
    \      dfs(i, j - 1, path.slice());\n        dfs(i, j + 1, path.slice());\n  \
    \      visited[i][j] = false;\n    };\n    for (let i = 0; i < n; i++) {\n   \
    \     for (let j = 0; j < m; j++) {\n            dfs(i, j, []);\n        }\n \
    \   }\n    return minPath;\n}\n", "    const n = grid.length;\n    const m = grid[0].length;\n\
    \    const visited = new Array(n);\n    for (let i = 0; i < n; i++) {\n      \
    \  visited[i] = new Array(m).fill(false);\n    }\n    const queue = [];\n    queue.push({\n\
    \        x: 0,\n        y: 0,\n        path: [grid[0][0]],\n        length: 1\n\
    \    });\n    visited[0][0] = true;\n    let minPath = null;\n    while (queue.length\
    \ > 0) {\n        const { x, y, path, length } = queue.shift();\n        if (length\
    \ === k) {\n            if (minPath === null || path < minPath) {\n          \
    \      minPath = path;\n            }\n            continue;\n        }\n    \
    \    if (minPath !== null && path >= minPath) {\n            continue;\n     \
    \   }\n        for (const [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {\n\
    \            const nx = x + dx;\n            const ny = y + dy;\n            if\
    \ (nx < 0 || nx >= n || ny < 0 || ny >= m || visited[nx][ny]) {\n            \
    \    continue;\n            }\n            visited[nx][ny] = true;\n         \
    \   queue.push({\n                x: nx,\n                y: ny,\n           \
    \     path: [...path, grid[nx][ny]],\n                length: length + 1\n   \
    \         });\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let dp = new Array(n).fill(0).map(() => new\
    \ Array(m).fill(0).map(() => new Array(k + 1).fill(Infinity)));\n    let path\
    \ = new Array(n).fill(0).map(() => new Array(m).fill(0).map(() => new Array(k\
    \ + 1).fill(0)));\n    for (let i = 0; i < n; i++) {\n        for (let j = 0;\
    \ j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n            path[i][j][1]\
    \ = grid[i][j];\n        }\n    }\n    for (let l = 2; l <= k; l++) {\n      \
    \  for (let i = 0; i < n; i++) {\n            for (let j = 0; j < m; j++) {\n\
    \                for (let di = -1; di <= 1; di++) {\n                    for (let\
    \ dj = -1; dj <= 1; dj++) {\n                        if (di * di + dj * dj ==\
    \ 1) {\n                            let ni = i + di;\n                       \
    \     let nj = j + dj;\n                            if (ni >= 0 && ni < n && nj\
    \ >= 0 && nj < m) {\n                                if (dp[ni][nj][l - 1] < dp[i][j][l])\
    \ {\n                                    dp[i][j][l] = dp[ni][nj][l - 1];\n  \
    \                                  path[i][j][l] = path[ni][nj][l - 1];\n    \
    \                            }\n                            }\n              \
    \          }\n                    }\n                }\n                if (dp[i][j][l]\
    \ != Infinity) {\n                    path[i][j][l] = [...path[i][j][l], grid[i][j]];\n\
    \                }\n            }\n        }\n    }\n    let ans = Infinity;\n\
    \    let ansPath = [];\n    for (let i = 0; i < n; i++) {\n        for (let j\
    \ = 0; j <", "    let N = grid.length;\n    let minPath = [];\n    let minPathSum\
    \ = Infinity;\n    let minPathSumGrid = [];\n    for (let i = 0; i < N; i++) {\n\
    \        minPathSumGrid.push([]);\n        for (let j = 0; j < N; j++) {\n   \
    \         minPathSumGrid[i].push(Infinity);\n        }\n    }\n    let minPathSumGridQueue\
    \ = [];\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++)\
    \ {\n            minPathSumGridQueue.push([i, j]);\n        }\n    }\n    while\
    \ (minPathSumGridQueue.length > 0) {\n        let [i, j] = minPathSumGridQueue.shift();\n\
    \        let minPathSumNeighbors = [];\n        if (i > 0) {\n            minPathSumNeighbors.push(minPathSumGrid[i\
    \ - 1][j]);\n        }\n        if (i < N - 1) {\n            minPathSumNeighbors.push(minPathSumGrid[i\
    \ + 1][j]);\n        }\n        if (j > 0) {\n            minPathSumNeighbors.push(minPathSumGrid[i][j\
    \ - 1]);\n        }\n        if (j < N - 1) {\n            minPathSumNeighbors.push(minPathSumGrid[i][j\
    \ + 1]);\n        }\n        let minPathSumNeighbor = Math.min(...minPathSumNeighbors);\n\
    \        if (minPathSumNeighbor < minPathSumGrid[i][j]) {\n            minPathSumGrid[i][j]\
    \ = minPathSumNeighbor;\n            minPathSumGridQueue.push([i, j]);\n     \
    \   }\n    }\n    let minPathSumGridQueue2 = [];\n    for (let i = 0; i < N; i++)\
    \ {\n        for (let j = 0; j < N; j++) {\n            minPathSumGridQueue2.push([i,\
    \ j]);\n        }\n    }\n    while (minPathSumGridQueue2.length > 0) {\n    \
    \    let [i, j] = minPathSumGridQueue2.shift", "    let minPath: number[] = [];\n\
    \    let minPathSum: number = Infinity;\n    let minPathSum2: number = Infinity;\n\
    \    let pathSum: number = 0;\n    let path: number[] = [];\n    let path2: number[]\
    \ = [];\n    let visited: boolean[][] = [];\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        visited.push([]);\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            visited[i].push(false);\n        }\n    }\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            pathSum = 0;\n            path = [];\n            path2\
    \ = [];\n            visited[i][j] = true;\n            path.push(grid[i][j]);\n\
    \            pathSum += grid[i][j];\n            path2.push(grid[i][j]);\n   \
    \         dfs(grid, i, j, k - 1, pathSum, path, path2, visited);\n           \
    \ visited[i][j] = false;\n        }\n    }\n    return minPath;\n}\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let path = [];\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let minSumPath = [];\n    let sum = 0;\n\
    \    let sumPath = [];\n    let min = Infinity;\n    let minPath = [];\n    let\
    \ minSum = Infinity;\n    let minSumPath = [];\n    let sum = 0;\n    let sumPath\
    \ = [];\n    let min = Infinity;\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minSumPath = [];\n    let sum = 0;\n    let sumPath = [];\n    let min\
    \ = Infinity;\n    let minPath = [];\n    let minSum = Infinity;\n    let minSumPath\
    \ = [];\n    let sum = 0;\n    let sumPath = [];\n    let min = Infinity;\n  \
    \  let minPath = [];\n    let minSum = Infinity;\n    let minSumPath = [];\n \
    \   let sum = 0;\n    let sumPath = [];\n    let min = Infinity;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let minSumPath = [];\n    let sum = 0;\n\
    \    let sumPath = [];\n    let min = Infinity;\n    let minPath = [];\n    let\
    \ minSum = Infinity;\n    let minSumPath = [];\n    let sum = 0;\n    let sumPath\
    \ = [];\n    let min = Infinity;\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minSumPath = [];\n    let sum = 0;\n    let sumPath = [];\n    let min\
    \ = Infinity;\n    let minPath = [];\n    let minSum = Infinity;\n    let minSumPath\
    \ = [];\n    let sum = 0;\n    let sumPath = [];\n    let min = Infinity;\n  \
    \  let minPath = [];\n    let minSum = Infinity;\n    let minSumPath = [];\n \
    \   let sum = 0;\n    let sumPath = [];\n    let min = Infinity;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let minSumPath = [];\n    let sum = 0;\n\
    \    let sumPath = [];\n    let min = Infinity;\n   ", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let minPath: number[] = [];\n    let minPathSum\
    \ = Infinity;\n    let visited: boolean[][] = [];\n    for (let i = 0; i < n;\
    \ i++) {\n        visited[i] = [];\n        for (let j = 0; j < m; j++) {\n  \
    \          visited[i][j] = false;\n        }\n    }\n    let dfs = (i: number,\
    \ j: number, path: number[], pathSum: number) => {\n        if (i < 0 || i >=\
    \ n || j < 0 || j >= m || visited[i][j]) {\n            return;\n        }\n \
    \       path.push(grid[i][j]);\n        pathSum += grid[i][j];\n        if (path.length\
    \ === k) {\n            if (pathSum < minPathSum) {\n                minPathSum\
    \ = pathSum;\n                minPath = path.slice();\n            }\n       \
    \     path.pop();\n            return;\n        }\n        visited[i][j] = true;\n\
    \        dfs(i - 1, j, path, pathSum);\n        dfs(i + 1, j, path, pathSum);\n\
    \        dfs(i, j - 1, path, pathSum);\n        dfs(i, j + 1, path, pathSum);\n\
    \        visited[i][j] = false;\n        path.pop();\n    }\n    for (let i =\
    \ 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for (let i\
    \ = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n    }\n\
    \    let minPath = [];\n    let minPathSum = Infinity;\n    for (let i = 0; i\
    \ < n; i++) {\n        for (let j = 0; j < m; j++) {\n            let path = [];\n\
    \            let pathSum = 0;\n            let pathLength = 0;\n            let\
    \ queue = [[i, j]];\n            while (queue.length > 0) {\n                let\
    \ [x, y] = queue.shift();\n                if (x < 0 || x >= n || y < 0 || y >=\
    \ m || visited[x][y]) {\n                    continue;\n                }\n  \
    \              visited[x][y] = true;\n                path.push(grid[x][y]);\n\
    \                pathSum += grid[x][y];\n                pathLength++;\n     \
    \           if (pathLength === k) {\n                    if (pathSum < minPathSum)\
    \ {\n                        minPathSum = pathSum;\n                        minPath\
    \ = path;\n                    }\n                    break;\n               \
    \ }\n                queue.push([x - 1, y]);\n                queue.push([x +\
    \ 1, y]);\n                queue.push([x, y - 1]);\n                queue.push([x,\
    \ y + 1]);\n            }\n        }\n    }\n    return minPath;\n}\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n    let\
    \ minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2 =\
    \ [];\n    let minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minPathSum4\
    \ = Infinity;\n    let minPath4 = [];\n    let minPathSum5 = Infinity;\n    let\
    \ minPath5 = [];\n    let minPathSum6 = Infinity;\n    let minPath6 = [];\n  \
    \  let minPathSum7 = Infinity;\n    let minPath7 = [];\n    let minPathSum8 =\
    \ Infinity;\n    let minPath8 = [];\n    let minPathSum9 = Infinity;\n    let\
    \ minPath9 = [];\n    let minPathSum10 = Infinity;\n    let minPath10 = [];\n\
    \    let minPathSum11 = Infinity;\n    let minPath11 = [];\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minPathSum13 = Infinity;\n   \
    \ let minPath13 = [];\n    let minPathSum14 = Infinity;\n    let minPath14 = [];\n\
    \    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = [];\n    let minPathSum17 = Infinity;\n   \
    \ let minPath17 = [];\n    let minPathSum18 = Infinity;\n    let minPath18 = [];\n\
    \    let minPathSum19 = Infinity;\n    let minPath19 = [];\n    let minPathSum20\
    \ = Infinity;\n    let minPath20 = [];\n    let minPathSum21 = Infinity;\n   \
    \ let minPath21 = [];\n    let minPathSum22 = Infinity;\n    let minPath22 = [];\n\
    \    let minPathSum23 = Infinity;\n    let minPath23 = [];\n    let minPathSum24\
    \ = Infinity;\n    let minPath24 = [];\n    let minPathSum25 = Infinity;\n   \
    \ let minPath25 = [];\n    let minPathSum26 = Infinity;\n    let minPath26 = [];\n\
    \    let minPathSum27 = Infinity;\n    let minPath27 = [];\n    let minPathSum28\
    \ =", "    let n = grid.length;\n    let m = grid[0].length;\n    let visited\
    \ = new Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i] = new\
    \ Array(m).fill(false);\n    }\n    let minPath = new Array(k);\n    let minPathSum\
    \ = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2 = new Array(k);\n\
    \    let minPathSum3 = Infinity;\n    let minPath3 = new Array(k);\n    let minPathSum4\
    \ = Infinity;\n    let minPath4 = new Array(k);\n    let minPathSum5 = Infinity;\n\
    \    let minPath5 = new Array(k);\n    let minPathSum6 = Infinity;\n    let minPath6\
    \ = new Array(k);\n    let minPathSum7 = Infinity;\n    let minPath7 = new Array(k);\n\
    \    let minPathSum8 = Infinity;\n    let minPath8 = new Array(k);\n    let minPathSum9\
    \ = Infinity;\n    let minPath9 = new Array(k);\n    let minPathSum10 = Infinity;\n\
    \    let minPath10 = new Array(k);\n    let minPathSum11 = Infinity;\n    let\
    \ minPath11 = new Array(k);\n    let minPathSum12 = Infinity;\n    let minPath12\
    \ = new Array(k);\n    let minPathSum13 = Infinity;\n    let minPath13 = new Array(k);\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = new Array(k);\n    let\
    \ minPathSum15 = Infinity;\n    let minPath15 = new Array(k);\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = new Array(k);\n    let minPathSum17 = Infinity;\n\
    \    let minPath17 = new Array(k);\n    let minPathSum18 = Infinity;\n    let\
    \ minPath18 = new Array(k);\n    let minPathSum19 = Infinity;\n    let minPath19\
    \ = new Array(k);\n    let minPathSum20 = Infinity;\n    let minPath20 = new Array(k);\n\
    \    let minPathSum21 = Infinity", "    const n = grid.length;\n    const m =\
    \ grid[0].length;\n    const visited = new Set<string>();\n    const queue = [[0,\
    \ 0, [grid[0][0]]]];\n    while (queue.length) {\n        const [i, j, path] =\
    \ queue.shift()!;\n        if (path.length === k) {\n            return path;\n\
    \        }\n        if (i > 0 && !visited.has(`${i - 1},${j}`)) {\n          \
    \  visited.add(`${i - 1},${j}`);\n            queue.push([i - 1, j, [...path,\
    \ grid[i - 1][j]]]);\n        }\n        if (i < n - 1 && !visited.has(`${i +\
    \ 1},${j}`)) {\n            visited.add(`${i + 1},${j}`);\n            queue.push([i\
    \ + 1, j, [...path, grid[i + 1][j]]]);\n        }\n        if (j > 0 && !visited.has(`${i},${j\
    \ - 1}`)) {\n            visited.add(`${i},${j - 1}`);\n            queue.push([i,\
    \ j - 1, [...path, grid[i][j - 1]]]);\n        }\n        if (j < m - 1 && !visited.has(`${i},${j\
    \ + 1}`)) {\n            visited.add(`${i},${j + 1}`);\n            queue.push([i,\
    \ j + 1, [...path, grid[i][j + 1]]]);\n        }\n    }\n    return [];\n}\n",
  "    // your code goes here\n    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minPathSum = Infinity;\n    let visited = new\
    \ Array(n);\n    for (let i = 0; i < n; i++) {\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let dfs = (i: number, j: number, path: number[], sum: number) => {\n\
    \        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || path.length\
    \ > k) {\n            return;\n        }\n        path.push(grid[i][j]);\n   \
    \     sum += grid[i][j];\n        visited[i][j] = true;\n        if (path.length\
    \ === k) {\n            if (sum < minPathSum) {\n                minPathSum =\
    \ sum;\n                minPath = path.slice();\n            }\n        } else\
    \ {\n            dfs(i - 1, j, path, sum);\n            dfs(i + 1, j, path, sum);\n\
    \            dfs(i, j - 1, path, sum);\n            dfs(i, j + 1, path, sum);\n\
    \        }\n        path.pop();\n        visited[i][j] = false;\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n         \
    \   dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}\n", "    const\
    \ n = grid.length;\n    const m = grid[0].length;\n    const visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n    const queue = [];\n    const path = [];\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathLength = Infinity;\n    let minPathIndex = Infinity;\n    let\
    \ minPathIndexSum = Infinity;\n    let minPathIndexLength = Infinity;\n    let\
    \ minPathIndexIndex = Infinity;\n    let minPathIndexIndexSum = Infinity;\n  \
    \  let minPathIndexIndexLength = Infinity;\n    let minPathIndexIndexIndex = Infinity;\n\
    \    let minPathIndexIndexIndexSum = Infinity;\n    let minPathIndexIndexIndexLength\
    \ = Infinity;\n    let minPathIndexIndexIndexIndex = Infinity;\n    let minPathIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexLength = Infinity;\n    let\
    \ minPathIndexIndexIndexIndexIndex = Infinity;\n    let minPathIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexLength = Infinity;\n  \
    \  let minPathIndexIndexIndexIndexIndexIndex = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexLength = Infinity;\n\
    \    let minPathIndexIndexIndexIndexIndexIndexIndex = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexLength = Infinity;\n\
    \    let minPathIndexIndexIndexIndexIndexIndexIndexIndex = Infinity;\n    let\
    \ minPathIndexIndexIndexIndexIndexIndexIndexIndexSum = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexLength\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndex =\
    \ Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexSum =\
    \ Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexLength\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexSum\
    \ = Infinity;\n    let minPathIndexIndexIndexIndexIndexIndexIndexIndexIndex",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let minPath = [];\n\
    \    let minPathSum = Infinity;\n    let visited = new Set();\n    let dfs = (i:\
    \ number, j: number, path: number[], pathSum: number) => {\n        if (path.length\
    \ === k) {\n            if (pathSum < minPathSum) {\n                minPathSum\
    \ = pathSum;\n                minPath = path;\n            }\n            return;\n\
    \        }\n        if (i < 0 || i >= n || j < 0 || j >= m) {\n            return;\n\
    \        }\n        if (visited.has(i + ',' + j)) {\n            return;\n   \
    \     }\n        visited.add(i + ',' + j);\n        dfs(i - 1, j, path.concat(grid[i][j]),\
    \ pathSum + grid[i][j]);\n        dfs(i + 1, j, path.concat(grid[i][j]), pathSum\
    \ + grid[i][j]);\n        dfs(i, j - 1, path.concat(grid[i][j]), pathSum + grid[i][j]);\n\
    \        dfs(i, j + 1, path.concat(grid[i][j]), pathSum + grid[i][j]);\n     \
    \   visited.delete(i + ',' + j);\n    };\n    for (let i = 0; i < n; i++) {\n\
    \        for (let j = 0; j < m; j++) {\n            dfs(i, j, [], 0);\n      \
    \  }\n    }\n    return minPath;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
