name: HumanEval_133_sum_squares
language: ts
prompt: "//You are given a list of numbers.\n// You need to return the sum of squared\
  \ numbers in the given list,\n// round each element in the list to the upper int(Ceiling)\
  \ first.\n// Examples:\n// >>> lst([1.0, 2.0, 3.0])\n// 14\n// >>> lst([1.0, 4.0,\
  \ 9.0])\n// 98\n// >>> lst([1.0, 3.0, 5.0, 7.0])\n// 84\n// >>> lst([1.4, 4.2, 0.0])\n\
  // 29\n// >>> lst([-2.4, 1.0, 1.0])\n// 6\nfunction sum_squares(lst: number[]):\
  \ number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = sum_squares;\n  assert.deepEqual(candidate([1.0, 2.0,\
  \ 3.0]),14);\n  assert.deepEqual(candidate([1.0, 2.0, 3.0]),14);\n  assert.deepEqual(candidate([1.0,\
  \ 3.0, 5.0, 7.0]),84);\n  assert.deepEqual(candidate([1.4, 4.2, 0.0]),29);\n  assert.deepEqual(candidate([-2.4,\
  \ 1.0, 1.0]),6);\n  assert.deepEqual(candidate([100.0, 1.0, 15.0, 2.0]),10230);\n\
  \  assert.deepEqual(candidate([10000.0, 10000.0]),200000000);\n  assert.deepEqual(candidate([-1.4,\
  \ 4.6, 6.3]),75);\n  assert.deepEqual(candidate([-1.4, 17.9, 18.9, 19.9]),1086);\n\
  \  assert.deepEqual(candidate([0.0]),0);\n  assert.deepEqual(candidate([-1.0]),1);\n\
  \  assert.deepEqual(candidate([-1.0, 1.0, 0.0]),2);\n}\n\ntest();"
completions: ["    return lst.map(x => Math.ceil(x)).map(x => x * x).reduce((a, b)\
    \ => a + b);\n}\n", "    return lst.map(x => Math.ceil(x)).map(x => x * x).reduce((x,\
    \ y) => x + y);\n}\n", "    let sum = 0;\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        sum += Math.ceil(lst[i]) ** 2;\n    }\n    return sum;\n}\n",
  "    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum += Math.ceil(lst[i])\
    \ ** 2;\n    }\n    return sum;\n}\n", "  return lst.map(Math.ceil).map(x => x\
    \ * x).reduce((x, y) => x + y);\n}\n", "    return lst.map(x => Math.ceil(x)).map(x\
    \ => x * x).reduce((x, y) => x + y);\n}\n", "    return lst.map(x => Math.ceil(x)).map(x\
    \ => x * x).reduce((x, y) => x + y);\n}\n", "    return lst.map(Math.ceil).map(x\
    \ => x * x).reduce((x, y) => x + y, 0);\n}\n", "    let sum = 0;\n    for (let\
    \ i = 0; i < lst.length; i++) {\n        sum += Math.pow(Math.ceil(lst[i]), 2);\n\
    \    }\n    return sum;\n}\n", "    let sum = 0;\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        sum += Math.ceil(lst[i]) ** 2;\n    }\n    return sum;\n}\n",
  "    return lst.map(x => Math.ceil(x)).map(x => x * x).reduce((x, y) => x + y, 0);\n\
    }\n", "    return lst.map(x => Math.ceil(x)).map(x => x * x).reduce((x, y) =>\
    \ x + y);\n}\n", "    return lst.map(e => Math.ceil(e)).map(e => e * e).reduce((a,\
    \ b) => a + b);\n}\n", "  return lst.map(Math.ceil).map(x => x * x).reduce((a,\
    \ b) => a + b, 0);\n}\n", "    return lst.map(x => Math.ceil(x)).map(x => x *\
    \ x).reduce((x, y) => x + y);\n}\n", "  let sum = 0;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    sum += Math.ceil(lst[i]) ** 2;\n  }\n  return sum;\n}\n", "    return\
    \ lst.map(x => Math.ceil(x)).map(x => x * x).reduce((x, y) => x + y);\n}\n", " \
    \   return lst.map(x => Math.ceil(x)).map(x => x * x).reduce((a, b) => a + b);\n\
    }\n", "    let sum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        sum\
    \ += Math.ceil(lst[i]) * Math.ceil(lst[i]);\n    }\n    return sum;\n}\n", " \
    \   return lst.map(x => Math.ceil(x)).map(x => x * x).reduce((x, y) => x + y);\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
