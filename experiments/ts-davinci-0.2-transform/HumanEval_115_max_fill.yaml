name: HumanEval_115_max_fill
language: ts
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example\
  \ 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
  \ 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n//\
  \ Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0,\
  \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n\
  }\n\ntest();"
completions: ["  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for\
    \ (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n    \
    \    count += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "    let\
    \ count = 0;\n    let row = 0;\n    let col = 0;\n    let row_len = grid.length;\n\
    \    let col_len = grid[0].length;\n    let bucket = capacity;\n    while (row\
    \ < row_len) {\n        if (grid[row][col] === 1) {\n            if (bucket ===\
    \ 0) {\n                bucket = capacity;\n                count++;\n       \
    \     }\n            bucket--;\n            grid[row][col] = 0;\n        }\n \
    \       col++;\n        if (col === col_len) {\n            col = 0;\n       \
    \     row++;\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "  let total = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let fill\
    \ = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n\
    \        fill++;\n      }\n    }\n    if (fill > capacity) {\n      total += capacity;\n\
    \    } else {\n      total += fill;\n    }\n  }\n  return total;\n}\n", "  let\
    \ count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j\
    \ < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
    \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count +=\
    \ capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n \
    \ let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        max = Math.max(max,\
    \ j);\n      }\n    }\n  }\n  for (let i = 0; i < grid.length; i++) {\n    for\
    \ (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n    \
    \    count += capacity;\n      }\n      if (j === max) {\n        count -= capacity;\n\
    \      }\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let max_count = 0;\n    let\
    \ row_count = 0;\n    let col_count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max_count) {\n            max_count = count;\n            row_count = 1;\n\
    \        } else if (count === max_count) {\n            row_count++;\n       \
    \ }\n        count = 0;\n    }\n    count = 0;\n    for (let i = 0; i < grid[0].length;\
    \ i++) {\n        for (let j = 0; j < grid.length; j++) {\n            if (grid[j][i]\
    \ === 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max_count) {\n            max_count = count;\n            col_count = 1;\n\
    \        } else if (count === max_count) {\n            col_count++;\n       \
    \ }\n        count = 0;\n    }\n    return (max_count * row_count * col_count\
    \ * capacity);\n}\n", "  let count = 0;\n  let max = 0;\n  let maxIndex = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n  \
    \  if (count > max) {\n      max = count;\n      maxIndex = i;\n    }\n    count\
    \ = 0;\n  }\n  return max * capacity;\n}\n", "  let count = 0;\n  for (let i =\
    \ 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n\
    \      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n    }\n \
    \ }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count +=\
    \ capacity;\n      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  let row = 0;\n  let col = 0;\n\
    \  let rowLen = grid.length;\n  let colLen = grid[0].length;\n  while (row < rowLen)\
    \ {\n    if (grid[row][col] === 1) {\n      grid[row][col] = 0;\n      count++;\n\
    \    }\n    if (col === colLen - 1) {\n      row++;\n      col = 0;\n    } else\
    \ {\n      col++;\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n  \
    \  for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "  let result = 0;\n\
    \  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      sum\
    \ += grid[i][j];\n    }\n    if (sum > max) {\n      max = sum;\n      maxIndex\
    \ = i;\n    }\n  }\n  for (let i = 0; i < grid.length; i++) {\n    if (i === maxIndex)\
    \ {\n      result += max;\n    } else {\n      let sum = 0;\n      for (let j\
    \ = 0; j < grid[i].length; j++) {\n        sum += grid[i][j];\n      }\n     \
    \ result += sum;\n    }\n  }\n  return result;\n}\n", "    let count = 0;\n  \
    \  let max = 0;\n    let max_index = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let sum = 0;\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            sum += grid[i][j];\n        }\n        if (sum > max) {\n   \
    \         max = sum;\n            max_index = i;\n        }\n    }\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        if (i === max_index) {\n           \
    \ continue;\n        }\n        for (let j = 0; j < grid[i].length; j++) {\n \
    \           if (grid[i][j] === 1) {\n                count++;\n            }\n\
    \        }\n    }\n    return count;\n}\n", "  let count = 0;\n  let max = 0;\n\
    \  let maxRow = 0;\n  let maxCol = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
    \ 1) {\n        count++;\n      }\n      if (grid[i][j] > max) {\n        max\
    \ = grid[i][j];\n        maxRow = i;\n        maxCol = j;\n      }\n    }\n  }\n\
    \  if (count === 0) {\n    return 0;\n  }\n  if (count <= capacity) {\n    return\
    \ 1;\n  }\n  let maxCount = 0;\n  for (let i = 0; i < grid.length; i++) {\n  \
    \  for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        maxCount++;\n      }\n    }\n  }\n  if (maxCount <= capacity) {\n   \
    \ return 1;\n  }\n  let maxCount2 = 0;\n  for (let i = 0; i < grid[maxRow].length;\
    \ i++) {\n    if (grid[maxRow][i] === 1) {\n      maxCount2++;\n    }\n  }\n \
    \ if (maxCount2 <= capacity) {\n    return 1;\n  }\n  let maxCount3 = 0;\n  for\
    \ (let i = 0; i < grid.length; i++) {\n    if (grid[i][maxCol] === 1) {\n    \
    \  maxCount3++;\n    }\n  }\n  if (maxCount3 <= capacity) {\n    return 1;\n \
    \ }\n  return 2;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
    \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
    \ = 0;\n        count++;\n        let bucket = capacity;\n        while (bucket\
    \ > 0) {\n          if (i - 1 >= 0 && grid[i - 1][j] === 1) {\n            grid[i\
    \ - 1][j] = 0;\n            bucket--;\n          }\n          if (i + 1 < grid.length\
    \ && grid[i + 1][j] === 1) {\n            grid[i + 1][j] = 0;\n            bucket--;\n\
    \          }\n          if (j - 1 >= 0 && grid[i][j - 1] === 1) {\n          \
    \  grid[i][j - 1] = 0;\n            bucket--;\n          }\n          if (j +\
    \ 1 < grid[i].length && grid[i][j + 1] === 1) {\n            grid[i][j + 1] =\
    \ 0;\n            bucket--;\n          }\n        }\n      }\n    }\n  }\n  return\
    \ count;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
