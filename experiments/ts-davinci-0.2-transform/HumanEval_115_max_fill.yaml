name: HumanEval_115_max_fill
language: ts
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example\
  \ 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
  \ 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n//\
  \ Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0,\
  \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n\
  }\n\ntest();"
completions: ["  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for\
    \ (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n    \
    \    count += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "    let\
    \ count = 0;\n    let row = 0;\n    let col = 0;\n    let row_len = grid.length;\n\
    \    let col_len = grid[0].length;\n    let bucket = capacity;\n    while (row\
    \ < row_len) {\n        if (grid[row][col] === 1) {\n            if (bucket ===\
    \ 0) {\n                bucket = capacity;\n                count++;\n       \
    \     }\n            bucket--;\n            grid[row][col] = 0;\n        }\n \
    \       col++;\n        if (col === col_len) {\n            col = 0;\n       \
    \     row++;\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "  let total = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let fill\
    \ = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n\
    \        fill++;\n      }\n    }\n    if (fill > capacity) {\n      total += capacity;\n\
    \    } else {\n      total += fill;\n    }\n  }\n  return total;\n}\n", "  let\
    \ count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j\
    \ < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
    \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count +=\
    \ capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n \
    \ let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        max = Math.max(max,\
    \ j);\n      }\n    }\n  }\n  for (let i = 0; i < grid.length; i++) {\n    for\
    \ (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n    \
    \    count += capacity;\n      }\n      if (j === max) {\n        count -= capacity;\n\
    \      }\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let max_count = 0;\n    let\
    \ row_count = 0;\n    let col_count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max_count) {\n            max_count = count;\n            row_count = 1;\n\
    \        } else if (count === max_count) {\n            row_count++;\n       \
    \ }\n        count = 0;\n    }\n    count = 0;\n    for (let i = 0; i < grid[0].length;\
    \ i++) {\n        for (let j = 0; j < grid.length; j++) {\n            if (grid[j][i]\
    \ === 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max_count) {\n            max_count = count;\n            col_count = 1;\n\
    \        } else if (count === max_count) {\n            col_count++;\n       \
    \ }\n        count = 0;\n    }\n    return (max_count * row_count * col_count\
    \ * capacity);\n}\n", "  let count = 0;\n  let max = 0;\n  let maxIndex = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n  \
    \  if (count > max) {\n      max = count;\n      maxIndex = i;\n    }\n    count\
    \ = 0;\n  }\n  return max * capacity;\n}\n", "  let count = 0;\n  for (let i =\
    \ 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n\
    \      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n    }\n \
    \ }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count +=\
    \ capacity;\n      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  let row = 0;\n  let col = 0;\n\
    \  let rowLen = grid.length;\n  let colLen = grid[0].length;\n  while (row < rowLen)\
    \ {\n    if (grid[row][col] === 1) {\n      grid[row][col] = 0;\n      count++;\n\
    \    }\n    if (col === colLen - 1) {\n      row++;\n      col = 0;\n    } else\
    \ {\n      col++;\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n  \
    \  for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "  let result = 0;\n\
    \  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length; j++) {\n      sum\
    \ += grid[i][j];\n    }\n    if (sum > max) {\n      max = sum;\n      maxIndex\
    \ = i;\n    }\n  }\n  for (let i = 0; i < grid.length; i++) {\n    if (i === maxIndex)\
    \ {\n      result += max;\n    } else {\n      let sum = 0;\n      for (let j\
    \ = 0; j < grid[i].length; j++) {\n        sum += grid[i][j];\n      }\n     \
    \ result += sum;\n    }\n  }\n  return result;\n}\n", "    let count = 0;\n  \
    \  let max = 0;\n    let max_index = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let sum = 0;\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            sum += grid[i][j];\n        }\n        if (sum > max) {\n   \
    \         max = sum;\n            max_index = i;\n        }\n    }\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        if (i === max_index) {\n           \
    \ continue;\n        }\n        for (let j = 0; j < grid[i].length; j++) {\n \
    \           if (grid[i][j] === 1) {\n                count++;\n            }\n\
    \        }\n    }\n    return count;\n}\n", "  let count = 0;\n  let max = 0;\n\
    \  let maxRow = 0;\n  let maxCol = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
    \ 1) {\n        count++;\n      }\n      if (grid[i][j] > max) {\n        max\
    \ = grid[i][j];\n        maxRow = i;\n        maxCol = j;\n      }\n    }\n  }\n\
    \  if (count === 0) {\n    return 0;\n  }\n  if (count <= capacity) {\n    return\
    \ 1;\n  }\n  let maxCount = 0;\n  for (let i = 0; i < grid.length; i++) {\n  \
    \  for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        maxCount++;\n      }\n    }\n  }\n  if (maxCount <= capacity) {\n   \
    \ return 1;\n  }\n  let maxCount2 = 0;\n  for (let i = 0; i < grid[maxRow].length;\
    \ i++) {\n    if (grid[maxRow][i] === 1) {\n      maxCount2++;\n    }\n  }\n \
    \ if (maxCount2 <= capacity) {\n    return 1;\n  }\n  let maxCount3 = 0;\n  for\
    \ (let i = 0; i < grid.length; i++) {\n    if (grid[i][maxCol] === 1) {\n    \
    \  maxCount3++;\n    }\n  }\n  if (maxCount3 <= capacity) {\n    return 1;\n \
    \ }\n  return 2;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
    \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
    \ = 0;\n        count++;\n        let bucket = capacity;\n        while (bucket\
    \ > 0) {\n          if (i - 1 >= 0 && grid[i - 1][j] === 1) {\n            grid[i\
    \ - 1][j] = 0;\n            bucket--;\n          }\n          if (i + 1 < grid.length\
    \ && grid[i + 1][j] === 1) {\n            grid[i + 1][j] = 0;\n            bucket--;\n\
    \          }\n          if (j - 1 >= 0 && grid[i][j - 1] === 1) {\n          \
    \  grid[i][j - 1] = 0;\n            bucket--;\n          }\n          if (j +\
    \ 1 < grid[i].length && grid[i][j + 1] === 1) {\n            grid[i][j + 1] =\
    \ 0;\n            bucket--;\n          }\n        }\n      }\n    }\n  }\n  return\
    \ count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n            }\n        }\n   \
    \ }\n    return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                count += capacity;\n            }\n        }\n    }\n\
    \    return count;\n}\n", "    let count = 0;\n    let row = grid.length;\n  \
    \  let col = grid[0].length;\n    let bucket = capacity;\n    for (let i = 0;\
    \ i < row; i++) {\n        for (let j = 0; j < col; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                if (bucket > 0) {\n                    bucket--;\n\
    \                    grid[i][j] = 0;\n                } else {\n             \
    \       bucket = capacity;\n                    count++;\n                   \
    \ j--;\n                }\n            }\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n            }\n        }\n   \
    \ }\n    return count;\n}\n", "    let count = 0;\n    let max = 0;\n    let max_index\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n            \
    \    count++;\n            }\n        }\n        if (count > max) {\n        \
    \    max = count;\n            max_index = i;\n        }\n        count = 0;\n\
    \    }\n    return max * capacity;\n}\n", "  let count = 0;\n  for (let i = 0;\
    \ i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n  \
    \    if (grid[i][j] === 1) {\n        count += capacity;\n      }\n    }\n  }\n\
    \  return count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n                grid[i][j] = 0;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count++;\n    \
    \            grid[i][j] = 0;\n                let k = i;\n                while\
    \ (k < grid.length && capacity > 0) {\n                    if (grid[k][j] ===\
    \ 1) {\n                        grid[k][j] = 0;\n                        capacity--;\n\
    \                    }\n                    k++;\n                }\n        \
    \    }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "  let count = 0;\n\
    \  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        max = Math.max(max,\
    \ j);\n      }\n    }\n  }\n  for (let i = 0; i < grid.length; i++) {\n    for\
    \ (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n    \
    \    count += capacity;\n      }\n      if (j === max) {\n        count -= capacity;\n\
    \      }\n    }\n  }\n  return count;\n}\n", "  // Your code here\n  return 0;\n\
    }\n\nexport { max_fill };", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "  let count = 0;\n  let row = grid.length;\n  let col = grid[0].length;\n\
    \  let wells = [];\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j <\
    \ col; j++) {\n      if (grid[i][j] === 1) {\n        wells.push([i, j]);\n  \
    \    }\n    }\n  }\n  let wells_len = wells.length;\n  for (let i = 0; i < wells_len;\
    \ i++) {\n    let [x, y] = wells[i];\n    let bucket = capacity;\n    while (bucket\
    \ > 0) {\n      if (grid[x][y] === 1) {\n        grid[x][y] = 0;\n        bucket--;\n\
    \      }\n      if (x + 1 < row && grid[x + 1][y] === 1) {\n        x++;\n   \
    \   } else if (y + 1 < col && grid[x][y + 1] === 1) {\n        y++;\n      } else\
    \ {\n        break;\n      }\n    }\n    count++;\n  }\n  return count;\n}\n",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
    \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count +=\
    \ capacity;\n      }\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n\
    \    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             max = Math.max(max, j);\n            }\n        }\n    }\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count++;\n    \
    \            grid[i][j] = 0;\n            }\n        }\n        if (max > capacity)\
    \ {\n            count += max - capacity;\n            max = capacity;\n     \
    \   }\n    }\n    return count;\n}\n", "  let count = 0;\n  for (let i = 0; i\
    \ < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n    \
    \  if (grid[i][j] === 1) {\n        count += capacity;\n      }\n    }\n  }\n\
    \  return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   let row = grid[i];\n        let row_count = 0;\n        for (let j = 0; j\
    \ < row.length; j++) {\n            if (row[j] === 1) {\n                row_count++;\n\
    \            }\n        }\n        count += Math.ceil(row_count / capacity);\n\
    \    }\n    return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count\
    \ += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n\
    \    let row = grid.length;\n    let col = grid[0].length;\n    let bucket = capacity;\n\
    \    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n\
    \            if (grid[i][j] === 1) {\n                if (bucket > 0) {\n    \
    \                bucket--;\n                    grid[i][j] = 0;\n            \
    \    } else {\n                    bucket = capacity;\n                    count++;\n\
    \                    j--;\n                }\n            }\n        }\n    }\n\
    \    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "  let total = 0;\n  for (let row of grid) {\n    let rowTotal = 0;\n    for (let\
    \ well of row) {\n      if (well === 1) {\n        rowTotal++;\n      }\n    }\n\
    \    total += Math.ceil(rowTotal / capacity);\n  }\n  return total;\n}\n", " \
    \ let count = 0;\n  const row = grid.length;\n  const col = grid[0].length;\n\
    \  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++) {\n    \
    \  if (grid[i][j] === 1) {\n        count++;\n        grid[i][j] = 0;\n      \
    \  if (i + 1 < row && grid[i + 1][j] === 1) {\n          grid[i + 1][j] = 0;\n\
    \        }\n        if (j + 1 < col && grid[i][j + 1] === 1) {\n          grid[i][j\
    \ + 1] = 0;\n        }\n      }\n    }\n  }\n  return count;\n}\n", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n\nexport { max_fill };", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n   \
    \     let row_count = 0;\n        for (let j = 0; j < row.length; j++) {\n   \
    \         if (row[j] === 1) {\n                row_count++;\n            }\n \
    \       }\n        count += Math.ceil(row_count / capacity);\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n            }\n        }\n   \
    \ }\n    return count;\n}\n", "  // your code here\n  return 0;\n}\n\nexport {\
    \ max_fill };", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n\
    \    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        count += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let\
    \ count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j\
    \ < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
    \      }\n    }\n  }\n  return count;\n}\n", "    let result = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        for (let\
    \ j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n           \
    \     result += capacity;\n            }\n        }\n    }\n    return result;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count\
    \ += capacity;\n      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        grid[i][j] = 0;\n        count++;\n        let bucket = capacity;\n\
    \        while (bucket > 0) {\n          if (i - 1 >= 0 && grid[i - 1][j] ===\
    \ 1) {\n            grid[i - 1][j] = 0;\n            bucket--;\n          }\n\
    \          if (i + 1 < grid.length && grid[i + 1][j] === 1) {\n            grid[i\
    \ + 1][j] = 0;\n            bucket--;\n          }\n          if (j - 1 >= 0 &&\
    \ grid[i][j - 1] === 1) {\n            grid[i][j - 1] = 0;\n            bucket--;\n\
    \          }\n          if (j + 1 < grid[i].length && grid[i][j + 1] === 1) {\n\
    \            grid[i][j + 1] = 0;\n            bucket--;\n          }\n       \
    \ }\n      }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++)\
    \ {\n      if (grid[i][j] === 1) {\n        if (capacity > 0) {\n          grid[i][j]\
    \ = 0;\n          capacity--;\n        } else {\n          count++;\n        }\n\
    \      }\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    let row = grid.length;\n    let col = grid[0].length;\n    let wells = [];\n\
    \    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n\
    \            if (grid[i][j] === 1) {\n                wells.push([i, j]);\n  \
    \          }\n        }\n    }\n    while (wells.length > 0) {\n        let temp\
    \ = [];\n        for (let i = 0; i < wells.length; i++) {\n            let [x,\
    \ y] = wells[i];\n            if (grid[x][y] === 1) {\n                grid[x][y]\
    \ = 0;\n                if (x - 1 >= 0 && grid[x - 1][y] === 1) {\n          \
    \          temp.push([x - 1, y]);\n                }\n                if (x +\
    \ 1 < row && grid[x + 1][y] === 1) {\n                    temp.push([x + 1, y]);\n\
    \                }\n                if (y - 1 >= 0 && grid[x][y - 1] === 1) {\n\
    \                    temp.push([x, y - 1]);\n                }\n             \
    \   if (y + 1 < col && grid[x][y + 1] === 1) {\n                    temp.push([x,\
    \ y + 1]);\n                }\n            }\n        }\n        wells = temp;\n\
    \        count++;\n    }\n    return count * capacity;\n}\n", "  let count = 0;\n\
    \  let row = grid.length;\n  let col = grid[0].length;\n  let max = 0;\n  for\
    \ (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count++;\n      }\n    }\n    max = Math.max(max, count);\n\
    \    count = 0;\n  }\n  return max * capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "    let total = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                total += 1;\n            }\n        }\n        if\
    \ (total > max) {\n            max = total;\n        }\n        total = 0;\n \
    \   }\n    return max * capacity;\n}\n", "  let count = 0;\n  for (let i = 0;\
    \ i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n  \
    \    if (grid[i][j] === 1) {\n        count += capacity;\n      }\n    }\n  }\n\
    \  return count;\n}\n", "  let total = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        total += capacity;\n      }\n    }\n  }\n  return total;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count\
    \ += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j] = 0;\n        count++;\n\
    \        for (let k = i + 1; k < grid.length; k++) {\n          if (grid[k][j]\
    \ === 1) {\n            grid[k][j] = 0;\n            count++;\n          }\n \
    \       }\n      }\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n \
    \   for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                grid[i][j] = 0;\n\
    \                count++;\n                let k = i;\n                while (k\
    \ < grid.length && grid[k][j] === 0) {\n                    grid[k][j] = 1;\n\
    \                    k++;\n                }\n            }\n        }\n    }\n\
    \    return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    let row = grid[i];\n    let sum = row.reduce((a, b) => a + b, 0);\n\
    \    if (sum > capacity) {\n      count += sum - capacity;\n    }\n  }\n  return\
    \ count;\n}\n", "    let count = 0;\n    let max = 0;\n    for (let i = 0; i <\
    \ grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n  \
    \          if (grid[i][j] === 1) {\n                count++;\n            }\n\
    \        }\n        if (count > max) {\n            max = count;\n        }\n\
    \        count = 0;\n    }\n    return max * capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  let max = 0;\n  for (let i =\
    \ 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n\
    \      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n    if (count\
    \ > max) {\n      max = count;\n    }\n    count = 0;\n  }\n  return max * capacity;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  const row = grid.length;\n  const\
    \ col = grid[0].length;\n  for (let i = 0; i < row; i++) {\n    for (let j = 0;\
    \ j < col; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
    \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count;\n}\n", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n  \
    \  for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n       \
    \ count += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n", "  let result = 0;\n  let max = 0;\n  for\
    \ (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        max += capacity;\n      }\n \
    \   }\n  }\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j <\
    \ grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        result += capacity;\n\
    \      }\n    }\n    if (result === max) {\n      return result;\n    }\n  }\n\
    \  return result;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let filled = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j]\
    \ === 1) {\n        filled++;\n      }\n    }\n    if (filled > 0) {\n      count\
    \ += Math.ceil(filled / capacity);\n    }\n  }\n  return count;\n}\n", "    let\
    \ count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j\
    \ = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
    \           count += capacity;\n            }\n        }\n    }\n    return count;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
    \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count +=\
    \ capacity;\n      }\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "  let total = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let count\
    \ = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n\
    \        count++;\n      }\n    }\n    total += Math.ceil(count / capacity);\n\
    \  }\n  return total;\n}\n", "    let count = 0;\n    const max_row = grid.length;\n\
    \    const max_col = grid[0].length;\n    const max_row_sum = grid.map(row =>\
    \ row.reduce((a, b) => a + b, 0));\n    const max_col_sum = grid[0].map((_, i)\
    \ => grid.reduce((a, b) => a + b[i], 0));\n    for (let i = 0; i < max_row; i++)\
    \ {\n        for (let j = 0; j < max_col; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                const row_sum = max_row_sum[i];\n                const\
    \ col_sum = max_col_sum[j];\n                const max_sum = Math.max(row_sum,\
    \ col_sum);\n                const min_sum = Math.min(row_sum, col_sum);\n   \
    \             if (max_sum > capacity) {\n                    count += capacity\
    \ - min_sum;\n                } else {\n                    count += max_sum -\
    \ min_sum;\n                }\n            }\n        }\n    }\n    return count;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
    \ = 0;\n        count++;\n        let bucket = capacity;\n        while (bucket\
    \ > 0) {\n          if (i - 1 >= 0 && grid[i - 1][j] === 1) {\n            grid[i\
    \ - 1][j] = 0;\n            bucket--;\n          }\n          if (j - 1 >= 0 &&\
    \ grid[i][j - 1] === 1) {\n            grid[i][j - 1] = 0;\n            bucket--;\n\
    \          }\n          if (i + 1 < grid.length && grid[i + 1][j] === 1) {\n \
    \           grid[i + 1][j] = 0;\n            bucket--;\n          }\n        \
    \  if (j + 1 < grid[i].length && grid[i][j + 1] === 1) {\n            grid[i][j\
    \ + 1] = 0;\n            bucket--;\n          }\n        }\n      }\n    }\n \
    \ }\n  return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  const row = grid.length;\n  const\
    \ col = grid[0].length;\n  const visited = new Array(row).fill(0).map(() => new\
    \ Array(col).fill(false));\n  for (let i = 0; i < row; i++) {\n    for (let j\
    \ = 0; j < col; j++) {\n      if (grid[i][j] === 1 && !visited[i][j]) {\n    \
    \    count += 1;\n        dfs(grid, i, j, capacity, visited);\n      }\n    }\n\
    \  }\n  return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count++;\n        grid[i][j] = 0;\n      }\n    }\n  }\n \
    \ return count * capacity;\n}\n", "    let count = 0;\n    for (let i = 0; i <\
    \ grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n  \
    \          if (grid[i][j] === 1) {\n                count += capacity;\n     \
    \       }\n        }\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    let row = 0;\n    let col\
    \ = 0;\n    let maxRow = grid.length;\n    let maxCol = grid[0].length;\n    let\
    \ bucket = capacity;\n    while (row < maxRow) {\n        if (grid[row][col] ===\
    \ 1) {\n            if (bucket > 0) {\n                bucket -= 1;\n        \
    \        grid[row][col] = 0;\n            } else {\n                count += 1;\n\
    \                bucket = capacity;\n            }\n        }\n        col +=\
    \ 1;\n        if (col === maxCol) {\n            col = 0;\n            row +=\
    \ 1;\n        }\n    }\n    return count;\n}\n", "  let count = 0;\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++)\
    \ {\n      if (grid[i][j] === 1) {\n        if (capacity > 0) {\n          capacity--;\n\
    \          grid[i][j] = 0;\n        } else {\n          capacity = capacity +\
    \ 1;\n          count = count + 1;\n        }\n      }\n    }\n  }\n  return count;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count++;\n        grid[i][j] = 0;\n      }\n    }\n  }\n \
    \ return count * capacity;\n}\n", "    let count = 0;\n    for (let i = 0; i <\
    \ grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n  \
    \          if (grid[i][j] === 1) {\n                count += capacity;\n     \
    \       }\n        }\n    }\n    return count;\n}\n", "    let result = 0;\n \
    \   for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                result += capacity;\n\
    \                for (let k = i + 1; k < grid.length; k++) {\n               \
    \     if (grid[k][j] === 1) {\n                        result += capacity;\n \
    \                   } else {\n                        break;\n               \
    \     }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
    \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count++;\n                for (let k = i; k < grid.length; k++)\
    \ {\n                    if (grid[k][j] === 1) {\n                        grid[k][j]\
    \ = 0;\n                    }\n                }\n            }\n        }\n \
    \   }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
    \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let row_count = 0;\n    for (let j = 0; j < row.length; j++) {\n      if\
    \ (row[j] === 1) {\n        row_count++;\n      }\n    }\n    count += Math.ceil(row_count\
    \ / capacity);\n  }\n  return count;\n}\n", "  let count = 0;\n  for (let i =\
    \ 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n\
    \      if (grid[i][j] === 1) {\n        count++;\n        grid[i][j] = 0;\n  \
    \    }\n    }\n  }\n  return count * capacity;\n}\n", "    let count = 0;\n  \
    \  for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "  let total = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n    let row_total\
    \ = 0;\n    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n\
    \        row_total += 1;\n      }\n    }\n    total += Math.ceil(row_total / capacity);\n\
    \  }\n  return total;\n}\n", "    let count = 0;\n    let max = 0;\n    let max_index\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let sum = 0;\n  \
    \      for (let j = 0; j < grid[i].length; j++) {\n            sum += grid[i][j];\n\
    \        }\n        if (sum > max) {\n            max = sum;\n            max_index\
    \ = i;\n        }\n    }\n    for (let i = 0; i < grid.length; i++) {\n      \
    \  if (i == max_index) {\n            continue;\n        }\n        for (let j\
    \ = 0; j < grid[i].length; j++) {\n            if (grid[i][j] == 1) {\n      \
    \          count++;\n            }\n        }\n    }\n    return count;\n}\n",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count +=\
    \ capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n \
    \ for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1,\
    \ 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5));", "  let count = 0;\n  let max = 0;\n  let maxIndex = 0;\n  for (let i\
    \ = 0; i < grid.length; i++) {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      sum += grid[i][j];\n    }\n    if (sum > max) {\n      max = sum;\n\
    \      maxIndex = i;\n    }\n  }\n  if (max === 0) {\n    return 0;\n  }\n  for\
    \ (let i = 0; i < grid.length; i++) {\n    if (i === maxIndex) {\n      count\
    \ += grid[i].length;\n    } else {\n      for (let j = 0; j < grid[i].length;\
    \ j++) {\n        if (grid[i][j] === 1) {\n          count++;\n        }\n   \
    \   }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n  for (let i = 0;\
    \ i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n  \
    \    if (grid[i][j] === 1) {\n        count += capacity;\n      }\n    }\n  }\n\
    \  return count;\n}\n", "    let count = 0;\n    let max = 0;\n    for (let i\
    \ = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            if (grid[i][j] === 1) {\n                count++;\n         \
    \   }\n        }\n        if (count > max) {\n            max = count;\n     \
    \   }\n        count = 0;\n    }\n    return max * capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  let row = grid.length;\n  let\
    \ col = grid[0].length;\n  let sum = 0;\n  let max = 0;\n  for (let i = 0; i <\
    \ row; i++) {\n    for (let j = 0; j < col; j++) {\n      sum += grid[i][j];\n\
    \    }\n    if (sum > max) {\n      max = sum;\n    }\n    sum = 0;\n  }\n  return\
    \ max * capacity;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count +=\
    \ capacity;\n      }\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n   \
    \     let row_count = 0;\n        for (let j = 0; j < row.length; j++) {\n   \
    \         if (row[j] === 1) {\n                row_count++;\n            }\n \
    \       }\n        count += Math.ceil(row_count / capacity);\n    }\n    return\
    \ count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n            }\n        }\n   \
    \ }\n    return count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n            }\n        }\n   \
    \ }\n    return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                grid[i][j] = 0;\n                count++;\n          \
    \      let bucket = capacity;\n                while (bucket > 0) {\n        \
    \            if (i > 0 && grid[i - 1][j] === 1) {\n                        grid[i\
    \ - 1][j] = 0;\n                        bucket--;\n                    }\n   \
    \                 if (i < grid.length - 1 && grid[i + 1][j] === 1) {\n       \
    \                 grid[i + 1][j] = 0;\n                        bucket--;\n   \
    \                 }\n                    if (j > 0 && grid[i][j - 1] === 1) {\n\
    \                        grid[i][j - 1] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j < grid[i].length - 1 && grid[i][j\
    \ + 1] === 1) {\n                        grid[i][j + 1] = 0;\n               \
    \         bucket--;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return count;\n}\n", "    let max_fill = 0;\n    let fill\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n            \
    \    fill += 1;\n            }\n        }\n        if (fill > max_fill) {\n  \
    \          max_fill = fill;\n        }\n        fill = 0;\n    }\n    return max_fill\
    \ * capacity;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    let row = grid[i];\n    let row_count = 0;\n    for (let j = 0; j < row.length;\
    \ j++) {\n      if (row[j] === 1) {\n        row_count++;\n      }\n    }\n  \
    \  count += Math.ceil(row_count / capacity);\n  }\n  return count;\n}\n", "  let\
    \ count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j\
    \ < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
    \      }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n  for (let i =\
    \ 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n\
    \      if (grid[i][j] === 1) {\n        grid[i][j] = 0;\n        count++;\n  \
    \      let bucket = capacity;\n        while (bucket > 0) {\n          if (i -\
    \ 1 >= 0 && grid[i - 1][j] === 1) {\n            grid[i - 1][j] = 0;\n       \
    \     bucket--;\n          }\n          if (i + 1 < grid.length && grid[i + 1][j]\
    \ === 1) {\n            grid[i + 1][j] = 0;\n            bucket--;\n         \
    \ }\n          if (j - 1 >= 0 && grid[i][j - 1] === 1) {\n            grid[i][j\
    \ - 1] = 0;\n            bucket--;\n          }\n          if (j + 1 < grid[i].length\
    \ && grid[i][j + 1] === 1) {\n            grid[i][j + 1] = 0;\n            bucket--;\n\
    \          }\n        }\n      }\n    }\n  }\n  return count;\n}\n", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count++;\n        let row = i;\n\
    \        while (row < grid.length && grid[row][j] === 1) {\n          grid[row][j]\
    \ = 0;\n          row++;\n        }\n      }\n    }\n  }\n  return count * capacity;\n\
    }\n", "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
    \ 1) {\n        count++;\n      }\n    }\n    if (count > max) {\n      max =\
    \ count;\n    }\n    count = 0;\n  }\n  return max * capacity;\n}\n", "  // your\
    \ code here\n  return 0;\n}\n\nexport { max_fill };", "  let count = 0;\n  for\
    \ (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n", "    let count = 0;\n    let max = 0;\n  \
    \  for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                max = Math.max(max,\
    \ j);\n            }\n        }\n    }\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count++;\n                grid[i][j] = 0;\n      \
    \          if (j + capacity > max) {\n                    capacity = j + capacity\
    \ - max;\n                } else {\n                    capacity = 0;\n      \
    \          }\n            }\n        }\n    }\n    return count;\n}\n", "  let\
    \ count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j\
    \ < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
    \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n",
  "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
    \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        max += capacity;\n      }\n    }\n  }\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n        if (count === max) {\n       \
    \   return count;\n        }\n      }\n    }\n  }\n  return count;\n}\n", "  let\
    \ count = 0;\n  let row = grid.length;\n  let col = grid[0].length;\n  let water\
    \ = 0;\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++) {\n\
    \      if (grid[i][j] === 1) {\n        water++;\n      }\n    }\n  }\n  count\
    \ = water / capacity;\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5));", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n\
    \    let row = grid[i];\n    let filled = 0;\n    for (let j = 0; j < row.length;\
    \ j++) {\n      if (row[j] === 1) {\n        filled++;\n      }\n    }\n    if\
    \ (filled > 0) {\n      count += Math.ceil(filled / capacity);\n    }\n  }\n \
    \ return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
    \ 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n}\n",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let row_count = 0;\n    for (let j = 0; j < row.length; j++) {\n      if\
    \ (row[j] === 1) {\n        row_count++;\n      }\n    }\n    count += Math.ceil(row_count\
    \ / capacity);\n  }\n  return count;\n}\n", "  let count = 0;\n  let max = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n  \
    \  if (count > max) {\n      max = count;\n    }\n    count = 0;\n  }\n  return\
    \ max * capacity;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count +=\
    \ capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n \
    \ let row = 0;\n  let col = 0;\n  let rowLength = grid.length;\n  let colLength\
    \ = grid[0].length;\n  let bucket = capacity;\n  while (row < rowLength && col\
    \ < colLength) {\n    if (grid[row][col] === 1) {\n      if (bucket === 0) {\n\
    \        bucket = capacity;\n        count++;\n      }\n      bucket--;\n    }\n\
    \    if (col === colLength - 1) {\n      row++;\n      col = 0;\n    } else {\n\
    \      col++;\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
    \ 0], [0, 0, 0]], 5));", "  let count = 0;\n  let max = 0;\n  for (let i = 0;\
    \ i < grid.length; i++) {\n    max = Math.max(...grid[i]);\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === max) {\n        grid[i][j]\
    \ = 0;\n        count++;\n      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n            }\n        }\n   \
    \ }\n    return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        let bucket = capacity;\n        while (bucket > 0) {\n   \
    \       grid[i][j] = 0;\n          bucket--;\n          if (i + 1 < grid.length\
    \ && grid[i + 1][j] === 1) {\n            i++;\n          } else if (j + 1 < grid[i].length\
    \ && grid[i][j + 1] === 1) {\n            j++;\n          } else {\n         \
    \   break;\n          }\n        }\n        count++;\n      }\n    }\n  }\n  return\
    \ count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                grid[i][j] = 0;\n                count++;\n      \
    \          let bucket = capacity;\n                while (bucket > 0) {\n    \
    \                if (i - 1 >= 0 && grid[i - 1][j] === 1) {\n                 \
    \       grid[i - 1][j] = 0;\n                        bucket--;\n             \
    \       }\n                    if (i + 1 < grid.length && grid[i + 1][j] === 1)\
    \ {\n                        grid[i + 1][j] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j - 1 >= 0 && grid[i][j - 1] ===\
    \ 1) {\n                        grid[i][j - 1] = 0;\n                        bucket--;\n\
    \                    }\n                    if (j + 1 < grid[i].length && grid[i][j\
    \ + 1] === 1) {\n                        grid[i][j + 1] = 0;\n               \
    \         bucket--;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return count;\n}\n", "  let count = 0;\n  for (let i =\
    \ 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n\
    \      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n    }\n \
    \ }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "  let count = 0;\n  let i = 0;\n  while (i < grid.length) {\n    let j = 0;\n \
    \   while (j < grid[i].length) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
    \ = 0;\n        count++;\n        j++;\n      } else {\n        j++;\n      }\n\
    \    }\n    i++;\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5));", "    // your code here\n    return 0;\n}\n", "  let count = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n", "    let total = 0;\n    let max = 0;\n  \
    \  for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                total += 1;\n \
    \           }\n        }\n        if (total > max) {\n            max = total;\n\
    \        }\n        total = 0;\n    }\n    return max * capacity;\n}\n", "   \
    \ let count = 0;\n    let max = 0;\n    let max_index = 0;\n    for (let i = 0;\
    \ i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (grid[i][j] === 1) {\n                count++;\n            }\n\
    \        }\n        if (count > max) {\n            max = count;\n           \
    \ max_index = i;\n        }\n        count = 0;\n    }\n    return max * capacity;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count\
    \ += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1,\
    \ 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5));", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for\
    \ (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n    \
    \    count += capacity;\n      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count++;\n\
    \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n",
  "  let count = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
    \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        max = Math.max(max, j);\n      }\n    }\n  }\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n      if (j === max) {\n    \
    \    count -= capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n", "    let count = 0;\n    for (let i = 0; i\
    \ < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n\
    \            if (grid[i][j] === 1) {\n                count += capacity;\n   \
    \         }\n        }\n    }\n    return count;\n}\n", "    let count = 0;\n\
    \    let max = 0;\n    let maxIndex = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        let sum = 0;\n        for (let j = 0; j < grid[i].length; j++)\
    \ {\n            sum += grid[i][j];\n        }\n        if (sum > max) {\n   \
    \         max = sum;\n            maxIndex = i;\n        }\n    }\n    count +=\
    \ max;\n    for (let i = 0; i < grid.length; i++) {\n        if (i != maxIndex)\
    \ {\n            for (let j = 0; j < grid[i].length; j++) {\n                if\
    \ (grid[i][j] == 1) {\n                    count += 1;\n                }\n  \
    \          }\n        }\n    }\n    return count;\n}\n", "  let count = 0;\n \
    \ for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count++;\n        grid[i][j]\
    \ = 0;\n      }\n    }\n  }\n  return count * capacity;\n}\n", "    let count\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n            \
    \    count += capacity;\n            }\n        }\n    }\n    return count;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count\
    \ += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "    let count = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                count += capacity;\n\
    \            }\n        }\n    }\n    return count;\n}\n", "  let count = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j] = 0;\n        count++;\n\
    \        let bucket = capacity;\n        while (bucket > 0) {\n          if (i\
    \ - 1 >= 0 && grid[i - 1][j] === 1) {\n            grid[i - 1][j] = 0;\n     \
    \       bucket--;\n          }\n          if (i + 1 < grid.length && grid[i +\
    \ 1][j] === 1) {\n            grid[i + 1][j] = 0;\n            bucket--;\n   \
    \       }\n          if (j - 1 >= 0 && grid[i][j - 1] === 1) {\n            grid[i][j\
    \ - 1] = 0;\n            bucket--;\n          }\n          if (j + 1 < grid[i].length\
    \ && grid[i][j + 1] === 1) {\n            grid[i][j + 1] = 0;\n            bucket--;\n\
    \          }\n        }\n      }\n    }\n  }\n  return count;\n}\n", "  let count\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1,\
    \ 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5));", "  let result = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        max += capacity;\n      }\n    }\n  }\n  for (let i = 0; i\
    \ < grid.length; i++) {\n    let sum = 0;\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        sum += capacity;\n      }\n \
    \   }\n    if (sum < max) {\n      result += sum;\n    } else {\n      result\
    \ += max;\n    }\n  }\n  return result;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
    \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
    \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
    \ [0, 0, 0]], 5));", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n            }\n        }\n   \
    \ }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count += capacity;\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n\
    \    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        grid[i][j] = 0;\n        count++;\n        let bucket = capacity;\n \
    \       while (bucket > 0) {\n          if (i === 0) {\n            if (grid[i\
    \ + 1][j] === 1) {\n              grid[i + 1][j] = 0;\n              bucket--;\n\
    \            }\n          } else if (i === grid.length - 1) {\n            if\
    \ (grid[i - 1][j] === 1) {\n              grid[i - 1][j] = 0;\n              bucket--;\n\
    \            }\n          } else {\n            if (grid[i + 1][j] === 1) {\n\
    \              grid[i + 1][j] = 0;\n              bucket--;\n            } else\
    \ if (grid[i - 1][j] === 1) {\n              grid[i - 1][j] = 0;\n           \
    \   bucket--;\n            }\n          }\n          if (j === 0) {\n        \
    \    if (grid[i][j + 1] === 1) {\n              grid[i][j + 1] = 0;\n        \
    \      bucket--;\n            }\n          } else if (j === grid[i].length - 1)\
    \ {\n            if (grid[i][j - 1] === 1) {\n              grid[i][j - 1] = 0;\n\
    \              bucket--;\n            }\n          } else {\n            if (grid[i][j\
    \ + 1] === 1) {\n              grid[i][j + 1] = 0;\n              bucket--;\n\
    \            } else if (grid[i][j - 1] === 1) {\n              grid[i][j - 1]\
    \ = 0;\n              bucket--;\n            }\n          }\n        }\n     \
    \ }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n  for (let i = 0; i\
    \ < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n    \
    \  if (grid[i][j] === 1) {\n        count += capacity;\n      }\n    }\n  }\n\
    \  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1,\
    \ 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
    \ [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", " \
    \   let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max) {\n            max = count;\n        }\n        count = 0;\n    }\n \
    \   return max * capacity;\n}\n", "    let count = 0;\n    for (let i = 0; i <\
    \ grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n  \
    \          if (grid[i][j] === 1) {\n                count += capacity;\n     \
    \       }\n        }\n    }\n    return count;\n}\n", "  let count = 0;\n  for\
    \ (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n", "  let count = 0;\n  let max = 0;\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++)\
    \ {\n      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n    if (count\
    \ > max) {\n      max = count;\n    }\n    count = 0;\n  }\n  return max * capacity;\n\
    }\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                count += capacity;\n            }\n        }\n    }\n\
    \    return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "  let total = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row\
    \ = grid[i];\n    let rowTotal = 0;\n    for (let j = 0; j < row.length; j++)\
    \ {\n      if (row[j] === 1) {\n        rowTotal++;\n      }\n    }\n    total\
    \ += rowTotal;\n  }\n  return total;\n}\n", "    let count = 0;\n    let row =\
    \ grid.length;\n    let col = grid[0].length;\n    let bucket = capacity;\n  \
    \  for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n\
    \            if (grid[i][j] === 1) {\n                if (bucket === 0) {\n  \
    \                  bucket = capacity;\n                    count++;\n        \
    \        }\n                bucket--;\n            }\n        }\n    }\n    return\
    \ count;\n}\n", "  let max_fill = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
    \ 1) {\n        max_fill += capacity;\n      }\n    }\n  }\n  return max_fill;\n\
    }\n", "  let count = 0;\n  for (let row = 0; row < grid.length; row++) {\n   \
    \ for (let col = 0; col < grid[row].length; col++) {\n      if (grid[row][col]\
    \ === 1) {\n        count += capacity;\n        grid[row][col] = 0;\n      }\n\
    \    }\n  }\n  return count;\n}\n", "  let count = 0;\n  let row = grid.length;\n\
    \  let col = grid[0].length;\n  let max = 0;\n  let maxRow = 0;\n  let maxCol\
    \ = 0;\n  let maxRowCount = 0;\n  let maxColCount = 0;\n  let maxRowSum = 0;\n\
    \  let maxColSum = 0;\n  let maxRowIndex = 0;\n  let maxColIndex = 0;\n  let maxRowIndexCount\
    \ = 0;\n  let maxColIndexCount = 0;\n  let maxRowIndexSum = 0;\n  let maxColIndexSum\
    \ = 0;\n  let maxRowIndexIndex = 0;\n  let maxColIndexIndex = 0;\n  let maxRowIndexIndexCount\
    \ = 0;\n  let maxColIndexIndexCount = 0;\n  let maxRowIndexIndexSum = 0;\n  let\
    \ maxColIndexIndexSum = 0;\n  let maxRowIndexIndexIndex = 0;\n  let maxColIndexIndexIndex\
    \ = 0;\n  let maxRowIndexIndexIndexCount = 0;\n  let maxColIndexIndexIndexSum\
    \ = 0;\n  let maxRowIndexIndexIndexIndex = 0;\n  let maxColIndexIndexIndexIndex\
    \ = 0;\n  let maxRowIndexIndexIndexIndexCount = 0;\n  let maxColIndexIndexIndexIndexSum\
    \ = 0;\n  let maxRowIndexIndexIndexIndexIndex = 0;\n  let maxColIndexIndexIndexIndexIndex\
    \ = 0;\n  let maxRowIndexIndexIndexIndexIndexCount = 0;\n  let maxColIndexIndexIndexIndexIndexSum\
    \ = 0;\n  let maxRowIndexIndexIndexIndexIndexIndex = 0;\n  let maxColIndexIndexIndexIndexIndexIndex\
    \ = 0;\n  let maxRowIndexIndexIndexIndexIndexIndexCount = 0;\n  let maxColIndexIndexIndexIndexIndexIndexSum\
    \ = 0;\n  let maxRowIndexIndexIndexIndexIndexIndexIndex = 0;\n  let maxColIndexIndexIndexIndexIndexIndexIndex\
    \ = 0;\n  let maxRowIndexIndexIndexIndexIndexIndexIndexCount = 0;\n  let maxColIndexIndexIndexIndexIndexIndexIndexSum\
    \ = 0;\n  let maxRowIndexIndexIndexIndexIndexIndexIndexIndex = 0;\n  let maxColIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = 0;\n ", "  let count = 0;\n  let row = grid.length;\n  let col = grid[0].length;\n\
    \  let wells = [];\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j <\
    \ col; j++) {\n      if (grid[i][j] === 1) {\n        wells.push([i, j]);\n  \
    \    }\n    }\n  }\n  let well_count = wells.length;\n  let buckets = new Array(well_count).fill(0);\n\
    \  let max_bucket = 0;\n  while (true) {\n    let max_bucket = Math.max(...buckets);\n\
    \    if (max_bucket === capacity) {\n      break;\n    }\n    for (let i = 0;\
    \ i < well_count; i++) {\n      let [x, y] = wells[i];\n      if (buckets[i] <\
    \ capacity) {\n        buckets[i]++;\n        grid[x][y]--;\n      }\n    }\n\
    \    count++;\n  }\n  return count;\n}\n", "  let count = 0;\n  const row = grid.length;\n\
    \  const col = grid[0].length;\n  for (let i = 0; i < row; i++) {\n    for (let\
    \ j = 0; j < col; j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n\
    \        grid[i][j] = 0;\n      }\n    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  let max = 0;\n  for (let i =\
    \ 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n\
    \      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n    if (count\
    \ > max) {\n      max = count;\n    }\n    count = 0;\n  }\n  return max * capacity;\n\
    }\n", "  let total = 0;\n  let max = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
    \ 1) {\n        total += 1;\n      }\n    }\n    if (total > max) {\n      max\
    \ = total;\n    }\n    total = 0;\n  }\n  return max * capacity;\n}\n", "  let\
    \ result = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row = grid[i];\n\
    \    let rowSum = row.reduce((a, b) => a + b, 0);\n    if (rowSum > capacity)\
    \ {\n      result += rowSum - capacity;\n    }\n  }\n  return result;\n}\n", " \
    \   let total = 0;\n    for (let row of grid) {\n        let sum = 0;\n      \
    \  for (let i = 0; i < row.length; i++) {\n            if (row[i] === 1) {\n \
    \               sum++;\n            } else {\n                if (sum > 0) {\n\
    \                    total += Math.ceil(sum / capacity);\n                   \
    \ sum = 0;\n                }\n            }\n        }\n        if (sum > 0)\
    \ {\n            total += Math.ceil(sum / capacity);\n        }\n    }\n    return\
    \ total;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n\
    \    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        count += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let\
    \ count = 0;\n  let col = grid[0].length;\n  let row = grid.length;\n  let max\
    \ = 0;\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++) {\n\
    \      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n    if (count\
    \ > max) {\n      max = count;\n    }\n    count = 0;\n  }\n  return max * capacity;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
    \ = 0;\n        count++;\n        if (i + 1 < grid.length) {\n          grid[i\
    \ + 1][j] = 0;\n        }\n        if (j + 1 < grid[i].length) {\n          grid[i][j\
    \ + 1] = 0;\n        }\n      }\n    }\n  }\n  return count;\n}\n", "  let count\
    \ = 0;\n  let row = 0;\n  let col = 0;\n  let max = 0;\n  let maxRow = 0;\n  let\
    \ maxCol = 0;\n  let maxRowCount = 0;\n  let maxColCount = 0;\n  let maxRowCount2\
    \ = 0;\n  let maxColCount2 = 0;\n  let maxRowCount3 = 0;\n  let maxColCount3 =\
    \ 0;\n  let maxRowCount4 = 0;\n  let maxColCount4 = 0;\n  let maxRowCount5 = 0;\n\
    \  let maxColCount5 = 0;\n  let maxRowCount6 = 0;\n  let maxColCount6 = 0;\n \
    \ let maxRowCount7 = 0;\n  let maxColCount7 = 0;\n  let maxRowCount8 = 0;\n  let\
    \ maxColCount8 = 0;\n  let maxRowCount9 = 0;\n  let maxColCount9 = 0;\n  let maxRowCount10\
    \ = 0;\n  let maxColCount10 = 0;\n  let maxRowCount11 = 0;\n  let maxColCount11\
    \ = 0;\n  let maxRowCount12 = 0;\n  let maxColCount12 = 0;\n  let maxRowCount13\
    \ = 0;\n  let maxColCount13 = 0;\n  let maxRowCount14 = 0;\n  let maxColCount14\
    \ = 0;\n  let maxRowCount15 = 0;\n  let maxColCount15 = 0;\n  let maxRowCount16\
    \ = 0;\n  let maxColCount16 = 0;\n  let maxRowCount17 = 0;\n  let maxColCount17\
    \ = 0;\n  let maxRowCount18 = 0;\n  let maxColCount18 = 0;\n  let maxRowCount19\
    \ = 0;\n  let maxColCount19 = 0;\n  let maxRowCount20 = 0;\n  let maxColCount20\
    \ = 0;\n  let maxRowCount21 = 0;\n  let maxColCount21 = 0;\n  let maxRowCount22\
    \ = 0;\n  let maxColCount22 = 0;\n  let maxRowCount23 = 0;\n  let maxColCount23\
    \ = 0;\n  let maxRowCount24 = 0;", "  let count = 0;\n  let max = 0;\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++)\
    \ {\n      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n    if (count\
    \ > max) {\n      max = count;\n    }\n    count = 0;\n  }\n  return max * capacity;\n\
    }\n", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n     \
    \   for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                count += capacity;\n            }\n        }\n    }\n\
    \    return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        grid[i][j] = 0;\n        count++;\n        for (let k = i;\
    \ k < grid.length; k++) {\n          if (grid[k][j] === 1) {\n            grid[k][j]\
    \ = 0;\n            count++;\n          }\n        }\n      }\n    }\n  }\n  return\
    \ count;\n}\n", "  let count = 0;\n  let max = 0;\n  let max_index = 0;\n  let\
    \ max_row = 0;\n  let max_col = 0;\n  let max_row_index = 0;\n  let max_col_index\
    \ = 0;\n  let max_row_count = 0;\n  let max_col_count = 0;\n  let max_row_count_index\
    \ = 0;\n  let max_col_count_index = 0;\n  let max_row_count_index_2 = 0;\n  let\
    \ max_col_count_index_2 = 0;\n  let max_row_count_index_3 = 0;\n  let max_col_count_index_3\
    \ = 0;\n  let max_row_count_index_4 = 0;\n  let max_col_count_index_4 = 0;\n \
    \ let max_row_count_index_5 = 0;\n  let max_col_count_index_5 = 0;\n  let max_row_count_index_6\
    \ = 0;\n  let max_col_count_index_6 = 0;\n  let max_row_count_index_7 = 0;\n \
    \ let max_col_count_index_7 = 0;\n  let max_row_count_index_8 = 0;\n  let max_col_count_index_8\
    \ = 0;\n  let max_row_count_index_9 = 0;\n  let max_col_count_index_9 = 0;\n \
    \ let max_row_count_index_10 = 0;\n  let max_col_count_index_10 = 0;\n  let max_row_count_index_11\
    \ = 0;\n  let max_col_count_index_11 = 0;\n  let max_row_count_index_12 = 0;\n\
    \  let max_col_count_index_12 = 0;\n  let max_row_count_index_13 = 0;\n  let max_col_count_index_13\
    \ = 0;\n  let max_row_count_index_14 = 0;\n  let max_col_count_index_14 = 0;\n\
    \  let max_row_count_index_", "  let count = 0;\n  let max = 0;\n  let max_index\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n  \
    \  if (count > max) {\n      max = count;\n      max_index = i;\n    }\n    count\
    \ = 0;\n  }\n  return max * capacity;\n}\n", "  let count = 0;\n  for (let i =\
    \ 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n\
    \      if (grid[i][j] === 1) {\n        count++;\n        grid[i][j] = 0;\n  \
    \    }\n    }\n  }\n  return count * capacity;\n}\n", "    let count = 0;\n  \
    \  let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             count++;\n            }\n        }\n        if (count > max) {\n\
    \            max = count;\n        }\n        count = 0;\n    }\n    return max\
    \ * capacity;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let\
    \ count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n\
    \        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max) {\n            max = count;\n        }\n        count = 0;\n    }\n \
    \   return max * capacity;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1,\
    \ 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5));", "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n  \
    \      for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n            }\n        }\n   \
    \ }\n    return count;\n}\n", "    let count = 0;\n    let column = grid[0].length;\n\
    \    let row = grid.length;\n    let bucket = capacity;\n    for (let i = 0; i\
    \ < column; i++) {\n        for (let j = 0; j < row; j++) {\n            if (grid[j][i]\
    \ === 1) {\n                if (bucket > 0) {\n                    bucket--;\n\
    \                    grid[j][i] = 0;\n                } else {\n             \
    \       count++;\n                    bucket = capacity - 1;\n               \
    \     grid[j][i] = 0;\n                }\n            }\n        }\n    }\n  \
    \  return count;\n}\n", "    let count = 0;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count += capacity;\n            }\n        }\n   \
    \ }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row\
    \ = grid[i];\n        for (let j = 0; j < row.length; j++) {\n            if (row[j]\
    \ === 1) {\n                count += capacity;\n            }\n        }\n   \
    \ }\n    return count;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "  let count = 0;\n  let max = 0;\n  let max_index = 0;\n  let max_row =\
    \ 0;\n  let max_col = 0;\n  let max_row_index = 0;\n  let max_col_index = 0;\n\
    \  let max_row_count = 0;\n  let max_col_count = 0;\n  let max_row_max = 0;\n\
    \  let max_col_max = 0;\n  let max_row_max_index = 0;\n  let max_col_max_index\
    \ = 0;\n  let max_row_max_count = 0;\n  let max_col_max_count = 0;\n  let max_row_max_row\
    \ = 0;\n  let max_col_max_col = 0;\n  let max_row_max_row_index = 0;\n  let max_col_max_col_index\
    \ = 0;\n  let max_row_max_row_count = 0;\n  let max_col_max_col_count = 0;\n \
    \ let max_row_max_row_max = 0;\n  let max_col_max_col_max = 0;\n  let max_row_max_row_max_index\
    \ = 0;\n  let max_col_max_col_max_index = 0;\n  let max_row_max_row_max_count\
    \ = 0;\n  let max_col_max_col_max_count = 0;\n  let max_row_max_row_max_row =\
    \ 0;\n  let max_col_max_col_max_col = 0;\n  let max_row_max_row_max_row_index\
    \ = 0;\n  let max_col_max_col_max_col_index = 0;\n  let max_row_max_row_max_row_count\
    \ = 0;\n  let max_col_max_col_max_col_count = 0;\n  let max_row_max_row_max_row_max\
    \ = 0;\n  let max_col_max_col_max_col_max = 0;\n  let max_row_max_row_max_row_max_index\
    \ = 0;", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for\
    \ (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n    \
    \    count += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "    let\
    \ count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++) {\n\
    \        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                count++;\n            }\n        }\n        if (count\
    \ > max) {\n            max = count;\n        }\n        count = 0;\n    }\n \
    \   return max * capacity;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        count += capacity;\n      }\n    }\n  }\n  return count;\n\
    }\n", "  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count\
    \ += capacity;\n      }\n    }\n  }\n  return count;\n}\n", "  let count = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1,\
    \ 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5));"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
