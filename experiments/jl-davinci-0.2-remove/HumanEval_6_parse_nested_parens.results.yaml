language: jl
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    max_nesting = []\n    for paren_group in paren_groups\n        max_nesting_level\
    \ = 0\n        nesting_level = 0\n        for paren in paren_group\n         \
    \   if paren == '('\n                nesting_level += 1\n            elseif paren\
    \ == ')'\n                nesting_level -= 1\n            end\n            if\
    \ nesting_level > max_nesting_level\n                max_nesting_level = nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize the output vector\n    output = Vector{Int64}()\n    \n \
    \   # Split the string by spaces\n    paren_groups = split(paren_string, \" \"\
    )\n    \n    # For each group, count the number of open parentheses\n    for group\
    \ in paren_groups\n        open_parens = 0\n        max_open_parens = 0\n    \
    \    for char in group\n            if char == '('\n                open_parens\
    \ += 1\n                if open_parens > max_open_parens\n                   \
    \ max_open_parens = open_parens\n                end\n            elseif char\
    \ == ')'\n                open_parens -= 1\n            end\n        end\n   \
    \     push!(output, max_open_parens)\n    end\n    \n    return output\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input:\n        paren_string: String representing multiple\
    \ groups for nested parentheses separated by spaces.\n    Output:\n        Vector{Int64}:\
    \ Vector of integers representing the deepest level of nesting of parentheses\
    \ for each group.\n    \"\"\"\n    # Split the string by spaces\n    paren_groups\
    \ = split(paren_string, \" \")\n    # Initialize the vector to store the deepest\
    \ level of nesting of parentheses for each group\n    max_nesting_levels = Vector{Int64}(undef,\
    \ length(paren_groups))\n    # Iterate over each group\n    for i in 1:length(paren_groups)\n\
    \        # Initialize the current nesting level to 0\n        curr_nesting_level\
    \ = 0\n        # Initialize the maximum nesting level to 0\n        max_nesting_level\
    \ = 0\n        # Iterate over each character in the group\n        for c in paren_groups[i]\n\
    \            # If the character is an opening parenthesis, increase the current\
    \ nesting level by 1\n            if c == '('\n                curr_nesting_level\
    \ += 1\n            # If the character is a closing parenthesis, decrease the\
    \ current nesting level by 1\n            elseif c == ')'\n                curr_nesting_level\
    \ -= 1\n            end\n            # If the current nesting level is greater\
    \ than the maximum nesting level, update the maximum nesting level\n         \
    \   if curr_nesting_level > max_nesting_level\n                max_nesting_level\
    \ = curr_nesting_level\n            end\n        end\n        # Store the maximum\
    \ nesting level for the current group\n        max_nesting_levels[i] = max_nesting_level\n\
    \    end\n    # Return the vector of maximum nesting levels\n    return max_nesting_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_group\
    \ = paren_groups[i]\n        nesting_level = 0\n        max_nesting_level = 0\n\
    \        for paren in paren_group\n            if paren == '('\n             \
    \   nesting_level += 1\n            elseif paren == ')'\n                nesting_level\
    \ -= 1\n            end\n            if nesting_level > max_nesting_level\n  \
    \              max_nesting_level = nesting_level\n            end\n        end\n\
    \        max_nesting[i] = max_nesting_level\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"((\", \"\")\n    paren_string = replace(paren_string, \"))\", \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n   \nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpg8jshfd9.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpg8jshfd9.jl:1\n\
    in expression starting at /tmp/tmpg8jshfd9.jl:1\n"
  stdout: ''
  timestamp: 1659748302
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \")\", \" ) \")\n    paren_string\
    \ = replace(paren_string, \"(\", \" ( \")\n    paren_string = split(paren_string)\n\
    \    paren_string = filter(x -> x != \"\", paren_string)\n    paren_string = map(x\
    \ -> replace(x, \" \", \"\"), paren_string)\n    paren_string = map(x -> replace(x,\
    \ \")\", \" ) \"), paren_string)\n    paren_string = map(x -> replace(x, \"(\"\
    , \" ( \"), paren_string)\n    paren_string = map(x -> split(x), paren_string)\n\
    \    paren_string = map(x -> filter(y -> y != \"\", x), paren_string)\n    paren_string\
    \ = map(x -> map(y -> replace(y, \" \", \"\"), x), paren_string)\n    paren_string\
    \ = map(x -> map(y -> replace(y, \")\", \" ) \"), x), paren_string)\n    paren_string\
    \ = map(x -> map(y -> replace(y, \"(\", \" ( \"), x), paren_string)\n    paren_string\
    \ = map(x -> map(y -> split(y), x), paren_string)\n    paren_string = map(x ->\
    \ map(y -> filter(z -> z != \"\", y), x), paren_string)\n    paren_string = map(x\
    \ -> map(y -> map(z -> replace(z, \" \", \"\"), y), x), paren_string)\n    paren_string\
    \ = map(x -> map(y -> map(z -> replace(z, \")\", \" ) \"), y), x), paren_string)\n\
    \    paren_string = map(x -> map(y -> map(z -> replace(z, \"(\", \" ( \"), y),\
    \ x), paren_string)\n    paren_string = map(x -> map(y -> map(z -> split(z), y),\
    \ x), paren_string)\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmphbivqie9.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmphbivqie9.jl:1\n\
    in expression starting at /tmp/tmphbivqie9.jl:1\n"
  stdout: ''
  timestamp: 1659748302
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    # Initialize a vector to store the depth of each\
    \ group\n    depth_vector = Int64[]\n    # Split the string into groups\n    paren_groups\
    \ = split(paren_string, \" \")\n    # For each group, calculate the depth\n  \
    \  for group in paren_groups\n        depth = 0\n        max_depth = 0\n     \
    \   for paren in group\n            if paren == '('\n                depth +=\
    \ 1\n            elseif paren == ')'\n                depth -= 1\n           \
    \ end\n            if depth > max_depth\n                max_depth = depth\n \
    \           end\n        end\n        push!(depth_vector, max_depth)\n    end\n\
    \    return depth_vector\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = split(paren_string, \" \")\n  \
    \  paren_string = [replace(i, \")\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \"(\", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \" \", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\
    \") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \"\", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\"\
    ) for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \"\", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\"\
    ) for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string = [replace(\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpv3_4q479.jl:33\nin expression starting at\
    \ /tmp/tmpv3_4q479.jl:33\n"
  stdout: ''
  timestamp: 1659748302
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of integers representing the depth of nesting of each group\
    \ of parentheses.\n    \"\"\"\n    paren_groups = split(paren_string, \" \")\n\
    \    paren_depth = zeros(Int64, length(paren_groups))\n    for i in 1:length(paren_groups)\n\
    \        paren_depth[i] = count_paren_depth(paren_groups[i])\n    end\n    return\
    \ paren_depth\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpzjy8qful.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpzjy8qful.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_paren_depth not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpzjy8qful.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzjy8qful.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzjy8qful.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpzjy8qful.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_paren_depth\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpzjy8qful.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzjy8qful.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzjy8qful.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpzjy8qful.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_paren_depth not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n \
    \    @ Main /tmp/tmpzjy8qful.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzjy8qful.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzjy8qful.jl:22\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748303
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_group\
    \ = paren_groups[i]\n        paren_count = 0\n        max_nesting[i] = 0\n   \
    \     for j in 1:length(paren_group)\n            if paren_group[j] == '('\n \
    \               paren_count += 1\n                if paren_count > max_nesting[i]\n\
    \                    max_nesting[i] = paren_count\n                end\n     \
    \       elseif paren_group[j] == ')'\n                paren_count -= 1\n     \
    \       end\n        end\n    end\n    return max_nesting\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \")\", \"\")\n    paren_string =\
    \ replace(paren_string, \"(\", \" \")\n    paren_string = split(paren_string)\n\
    \    paren_string = map(x -> length(x), paren_string)\n    return paren_string\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp7f57jaey.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmp7f57jaey.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp7f57jaey.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7f57jaey.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7f57jaey.jl:20\ntest set:\
    \ Error During Test at /tmp/tmp7f57jaey.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp7f57jaey.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7f57jaey.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659748304
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string\
    \ = replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmptuge3jhu.jl:37\nin expression starting at\
    \ /tmp/tmptuge3jhu.jl:37\n"
  stdout: ''
  timestamp: 1659748302
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: a string of nested parentheses separated by spaces\n\
    \    Output: a vector of integers representing the deepest level of nesting of\
    \ parentheses for each group\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    paren_levels = []\n    for group in paren_groups\n        level\
    \ = 0\n        max_level = 0\n        for char in group\n            if char ==\
    \ '('\n                level += 1\n            elseif char == ')'\n          \
    \      level -= 1\n            end\n            if level > max_level\n       \
    \         max_level = level\n            end\n        end\n        push!(paren_levels,\
    \ max_level)\n    end\n    return paren_levels\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vector\
    \ = Vector{Int64}()\n    # Split the string into groups\n    paren_groups = split(paren_string,\
    \ \" \")\n    # For each group, calculate the depth\n    for group in paren_groups\n\
    \        depth = 0\n        max_depth = 0\n        for char in group\n       \
    \     if char == '('\n                depth += 1\n            elseif char == ')'\n\
    \                depth -= 1\n            end\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        end\n        # Append\
    \ the depth of the group to the vector\n        push!(depth_vector, max_depth)\n\
    \    end\n    return depth_vector\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: string of nested parentheses separated by spaces\n\
    \    Output: vector of integers representing the deepest level of nesting of parentheses\
    \ for each group\n    \"\"\"\n    paren_groups = split(paren_string, \" \")\n\
    \    paren_levels = []\n    for group in paren_groups\n        paren_levels =\
    \ push!(paren_levels, parse_parens(group))\n    end\n    return paren_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpghzka824.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpghzka824.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpghzka824.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpghzka824.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpghzka824.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpghzka824.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpghzka824.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpghzka824.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpghzka824.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpghzka824.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpghzka824.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpghzka824.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpghzka824.jl:22\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748303
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_string = split(paren_string,\
    \ \" \")\n    max_depth = Vector{Int64}(undef, length(paren_string))\n    for\
    \ i in 1:length(paren_string)\n        depth = 0\n        max_depth[i] = 0\n \
    \       for j in 1:length(paren_string[i])\n            if paren_string[i][j]\
    \ == '('\n                depth += 1\n            elseif paren_string[i][j] ==\
    \ ')'\n                depth -= 1\n            end\n            if depth > max_depth[i]\n\
    \                max_depth[i] = depth\n            end\n        end\n    end\n\
    \    return max_depth\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vector\
    \ = Int64[]\n    # Initialize a variable to store the depth of the current group\n\
    \    depth = 0\n    # Initialize a variable to store the maximum depth of the\
    \ current group\n    max_depth = 0\n    # Iterate over the characters in the string\n\
    \    for c in paren_string\n        # If the character is an opening parenthesis,\
    \ increment the depth\n        if c == '('\n            depth += 1\n        #\
    \ If the character is a closing parenthesis, decrement the depth\n        elseif\
    \ c == ')'\n            depth -= 1\n        # If the character is a space, append\
    \ the maximum depth of the current group to the depth vector\n        elseif c\
    \ == ' '\n            push!(depth_vector, max_depth)\n            # Reset the\
    \ maximum depth of the current group\n            max_depth = 0\n        end\n\
    \        # Update the maximum depth of the current group\n        if depth > max_depth\n\
    \            max_depth = depth\n        end\n    end\n    # Append the maximum\
    \ depth of the last group to the depth vector\n    push!(depth_vector, max_depth)\n\
    \    # Return the depth vector\n    return depth_vector\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize the output vector\n    output = Vector{Int64}()\n    \n \
    \   # Split the string by spaces\n    paren_string = split(paren_string, \" \"\
    )\n    \n    # For each group of parentheses\n    for group in paren_string\n\
    \        # Initialize the counter for the current group\n        counter = 0\n\
    \        # Initialize the max counter for the current group\n        max_counter\
    \ = 0\n        \n        # For each character in the current group\n        for\
    \ char in group\n            # If the character is an opening parenthesis, increment\
    \ the counter\n            if char == '('\n                counter += 1\n    \
    \        # If the character is a closing parenthesis, decrement the counter\n\
    \            elseif char == ')'\n                counter -= 1\n            end\n\
    \            \n            # If the counter is greater than the max counter, update\
    \ the max counter\n            if counter > max_counter\n                max_counter\
    \ = counter\n            end\n        end\n        \n        # Append the max\
    \ counter to the output vector\n        push!(output, max_counter)\n    end\n\
    \    \n    # Return the output vector\n    return output\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    paren_levels = []\n    for\
    \ paren_group in paren_list\n        paren_level = 0\n        max_level = 0\n\
    \        for paren in paren_group\n            if paren == '('\n             \
    \   paren_level += 1\n            elseif paren == ')'\n                paren_level\
    \ -= 1\n            end\n            if paren_level > max_level\n            \
    \    max_level = paren_level\n            end\n        end\n        push!(paren_levels,\
    \ max_level)\n    end\n    return paren_levels\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the maximum nesting level for each group\n\
    \    max_nesting_levels = Vector{Int64}()\n    # Split the string into groups\n\
    \    groups = split(paren_string, \" \")\n    # For each group, find the maximum\
    \ nesting level\n    for group in groups\n        # Initialize the nesting level\
    \ to 0\n        nesting_level = 0\n        # Initialize the maximum nesting level\
    \ to 0\n        max_nesting_level = 0\n        # For each character in the group\n\
    \        for character in group\n            # If the character is an opening\
    \ parenthesis, increment the nesting level by 1\n            if character == '('\n\
    \                nesting_level += 1\n            # If the character is a closing\
    \ parenthesis, decrement the nesting level by 1\n            elseif character\
    \ == ')'\n                nesting_level -= 1\n            end\n            # If\
    \ the nesting level is greater than the maximum nesting level, update the maximum\
    \ nesting level\n            if nesting_level > max_nesting_level\n          \
    \      max_nesting_level = nesting_level\n            end\n        end\n     \
    \   # Add the maximum nesting level to the vector\n        push!(max_nesting_levels,\
    \ max_nesting_level)\n    end\n    # Return the vector\n    return max_nesting_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    paren_list = map(x -> x[2:end-1],\
    \ paren_list)\n    max_nesting = zeros(Int64, length(paren_list))\n    for i in\
    \ 1:length(paren_list)\n        max_nesting[i] = parse_parens(paren_list[i])\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpd332lcsx.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmpd332lcsx.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpd332lcsx.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd332lcsx.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd332lcsx.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpd332lcsx.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpd332lcsx.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd332lcsx.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd332lcsx.jl:19\ntest set:\
    \ Error During Test at /tmp/tmpd332lcsx.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpd332lcsx.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd332lcsx.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd332lcsx.jl:19\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748303
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string\
    \ = split(paren_string, \" \")\n    paren_string = [replace(x, \")\", \"\") for\
    \ x in paren_string]\n    paren_string = [replace(x, \"(\", \"\") for x in paren_string]\n\
    \    paren_string = [length(x) for x in paren_string]\n    return paren_string\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpb7ynogg4.jl:19

    '
  stdout: "test set: Error During Test at /tmp/tmpb7ynogg4.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpb7ynogg4.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpb7ynogg4.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpb7ynogg4.jl:21\ntest set:\
    \ Error During Test at /tmp/tmpb7ynogg4.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpb7ynogg4.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpb7ynogg4.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659748304
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        max_nesting = [maximum(parse_parens(group))]\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpbazrb073.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmpbazrb073.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpbazrb073.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbazrb073.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbazrb073.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpbazrb073.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpbazrb073.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbazrb073.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbazrb073.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpbazrb073.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpbazrb073.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbazrb073.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbazrb073.jl:18\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748303
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: string of nested parentheses separated by spaces\n\
    \    Output: Vector of integers representing the maximum depth of nesting for\
    \ each group of parentheses\n    \"\"\"\n    # Initialize a vector to store the\
    \ depth of nesting for each group of parentheses\n    depth_vector = Int64[]\n\
    \    # Split the string by spaces\n    paren_groups = split(paren_string, \" \"\
    )\n    # Iterate through each group of parentheses\n    for paren_group in paren_groups\n\
    \        # Initialize a counter to keep track of the depth of nesting\n      \
    \  depth = 0\n        # Initialize a counter to keep track of the maximum depth\
    \ of nesting\n        max_depth = 0\n        # Iterate through each character\
    \ in the group of parentheses\n        for char in paren_group\n            #\
    \ If the character is an opening parenthesis, increment the depth counter\n  \
    \          if char == '('\n                depth += 1\n            # If the character\
    \ is a closing parenthesis, decrement the depth counter\n            elseif char\
    \ == ')'\n                depth -= 1\n            end\n            # If the depth\
    \ counter is greater than the maximum depth counter, update the maximum depth\
    \ counter\n            if depth > max_depth\n                max_depth = depth\n\
    \            end\n        end\n        # Append the maximum depth counter to the\
    \ depth vector\n        push!(depth_vector, max_depth)\n    end\n    # Return\
    \ the depth vector\n    return depth_vector\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a stack to store the depth of nested parentheses\n    stack\
    \ = Int64[]\n    # Initialize a vector to store the depth of nested parentheses\
    \ for each group\n    depth = Int64[]\n    # Initialize a variable to store the\
    \ current depth\n    curr_depth = 0\n    # Initialize a variable to store the\
    \ maximum depth\n    max_depth = 0\n    # Iterate through each character in the\
    \ string\n    for i in 1:length(paren_string)\n        # If the character is an\
    \ opening parenthesis, increment the current depth\n        if paren_string[i]\
    \ == '('\n            curr_depth += 1\n        # If the character is a closing\
    \ parenthesis, decrement the current depth\n        elseif paren_string[i] ==\
    \ ')'\n            curr_depth -= 1\n        # If the character is a space, push\
    \ the current depth to the stack and reset the current depth\n        elseif paren_string[i]\
    \ == ' '\n            push!(stack, curr_depth)\n            curr_depth = 0\n \
    \       end\n    end\n    # Iterate through the stack\n    for i in 1:length(stack)\n\
    \        # If the current depth is greater than the maximum depth, replace the\
    \ maximum depth\n        if stack[i] > max_depth\n            max_depth = stack[i]\n\
    \        end\n    end\n    # Iterate through the stack\n    for i in 1:length(stack)\n\
    \        # If the current depth is equal to the maximum depth, push the current\
    \ depth to the vector\n        if stack[i] == max_depth\n            push!(depth,\
    \ max_depth)\n        end\n    end\n    # Return the vector\n    return depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpptsb0sa6.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpptsb0sa6.jl:51\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpptsb0sa6.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpptsb0sa6.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpptsb0sa6.jl:52\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpptsb0sa6.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpptsb0sa6.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpptsb0sa6.jl:53\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpptsb0sa6.jl:53 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpptsb0sa6.jl:50\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748303
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    paren_levels = []\n    for group in paren_groups\n        paren_levels\
    \ = append!(paren_levels, parse_parens(group))\n    end\n    return paren_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmphduy6jm5.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmphduy6jm5.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmphduy6jm5.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphduy6jm5.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphduy6jm5.jl:23\ntest set:\
    \ Error During Test at /tmp/tmphduy6jm5.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmphduy6jm5.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphduy6jm5.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphduy6jm5.jl:23\ntest set:\
    \ Error During Test at /tmp/tmphduy6jm5.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmphduy6jm5.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphduy6jm5.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphduy6jm5.jl:23\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748304
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    # Initialize a vector\
    \ to store the result\n    result = Vector{Int64}()\n    # Split the string by\
    \ space\n    paren_groups = split(paren_string, \" \")\n    # Loop through each\
    \ group\n    for paren_group in paren_groups\n        # Initialize a counter for\
    \ the current group\n        counter = 0\n        # Initialize a maximum counter\
    \ for the current group\n        max_counter = 0\n        # Loop through each\
    \ character in the current group\n        for char in paren_group\n          \
    \  # If the character is '('\n            if char == '('\n                # Increment\
    \ the counter\n                counter += 1\n                # If the current\
    \ counter is larger than the maximum counter\n                if counter > max_counter\n\
    \                    # Update the maximum counter\n                    max_counter\
    \ = counter\n                end\n            # If the character is ')'\n    \
    \        elseif char == ')'\n                # Decrement the counter\n       \
    \         counter -= 1\n            end\n        end\n        # Push the maximum\
    \ counter to the result vector\n        push!(result, max_counter)\n    end\n\
    \    # Return the result vector\n    return result\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"((\", \"(\")\n    paren_string = replace(paren_string, \"))\", \")\")\n  \
    \  paren_string = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n   \nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkdq2tckh.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkdq2tckh.jl:1\n\
    in expression starting at /tmp/tmpkdq2tckh.jl:1\n"
  stdout: ''
  timestamp: 1659748302
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: paren_string - string of nested parentheses separated\
    \ by spaces\n    Output: Vector of integers representing the deepest level of\
    \ nesting of parentheses for each group\n    \"\"\"\n    # Initialize vector to\
    \ store the deepest level of nesting of parentheses for each group\n    deepest_nesting\
    \ = Vector{Int64}()\n    # Split the string into groups of parentheses\n    paren_groups\
    \ = split(paren_string, \" \")\n    # For each group of parentheses\n    for paren_group\
    \ in paren_groups\n        # Initialize a variable to store the current level\
    \ of nesting\n        current_nesting = 0\n        # Initialize a variable to\
    \ store the deepest level of nesting\n        deepest_nesting_current_group =\
    \ 0\n        # For each character in the group of parentheses\n        for character\
    \ in paren_group\n            # If the character is an opening parenthesis\n \
    \           if character == '('\n                # Increment the current level\
    \ of nesting\n                current_nesting += 1\n                # If the current\
    \ level of nesting is greater than the deepest level of nesting\n            \
    \    if current_nesting > deepest_nesting_current_group\n                    #\
    \ Update the deepest level of nesting\n                    deepest_nesting_current_group\
    \ = current_nesting\n                end\n            # If the character is a\
    \ closing parenthesis\n            elseif character == ')'\n                #\
    \ Decrement the current level of nesting\n                current_nesting -= 1\n\
    \            end\n        end\n        # Append the deepest level of nesting for\
    \ the current group to the vector\n        push!(deepest_nesting, deepest_nesting_current_group)\n\
    \    end\n    # Return the vector of integers representing the deepest level of\
    \ nesting of parentheses for each group\n    return deepest_nesting\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: paren_string: String\n    Output: Vector{Int64}\n \
    \   \"\"\"\n    # Initialize a counter to keep track of the depth of nesting\n\
    \    depth = 0\n    # Initialize a vector to store the depth of nesting for each\
    \ group\n    depths = []\n    # Loop through the string\n    for c in paren_string\n\
    \        # If the character is an opening parenthesis, increment the counter\n\
    \        if c == '('\n            depth += 1\n        # If the character is a\
    \ closing parenthesis, decrement the counter\n        elseif c == ')'\n      \
    \      depth -= 1\n        # If the character is a space, append the counter to\
    \ the vector\n        elseif c == ' '\n            push!(depths, depth)\n    \
    \    end\n    end\n    # Return the vector\n    return depths\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwvrd3rgi.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmpwvrd3rgi.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwvrd3rgi.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwvrd3rgi.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpwvrd3rgi.jl:37\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwvrd3rgi.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwvrd3rgi.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpwvrd3rgi.jl:38\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwvrd3rgi.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwvrd3rgi.jl:35\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748303
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth = Vector{Int64}()\n\
    \    # Initialize a counter to keep track of the depth of the current group\n\
    \    count = 0\n    # Iterate through the string\n    for i in paren_string\n\
    \        # If the character is an opening parenthesis, increment the counter\n\
    \        if i == '('\n            count += 1\n        # If the character is a\
    \ closing parenthesis, decrement the counter\n        elseif i == ')'\n      \
    \      count -= 1\n        # If the character is a space, store the current depth\
    \ and reset the counter\n        elseif i == ' '\n            push!(depth, count)\n\
    \            count = 0\n        end\n    end\n    # Return the vector of depths\n\
    \    return depth\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpuygehpf5.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmpuygehpf5.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuygehpf5.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuygehpf5.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpuygehpf5.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuygehpf5.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuygehpf5.jl:32\ntest set: Test\
    \ Failed at /tmp/tmpuygehpf5.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpuygehpf5.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuygehpf5.jl:32\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748303
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    # Initialize the\
    \ output vector\n    output_vec = Vector{Int64}()\n    # Split the string into\
    \ groups\n    paren_groups = split(paren_string, \" \")\n    # For each group,\
    \ find the deepest level of nesting\n    for group in paren_groups\n        #\
    \ Initialize the level of nesting\n        level = 0\n        # Initialize the\
    \ maximum level of nesting\n        max_level = 0\n        # For each character\
    \ in the group\n        for char in group\n            # If the character is an\
    \ opening parenthesis, increase the level of nesting\n            if char == '('\n\
    \                level += 1\n            # If the character is a closing parenthesis,\
    \ decrease the level of nesting\n            elseif char == ')'\n            \
    \    level -= 1\n            end\n            # If the current level of nesting\
    \ is greater than the maximum level of nesting, update the maximum level of nesting\n\
    \            if level > max_level\n                max_level = level\n       \
    \     end\n        end\n        # Append the maximum level of nesting to the output\
    \ vector\n        push!(output_vec, max_level)\n    end\n    # Return the output\
    \ vector\n    return output_vec\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: paren_string: String of nested parentheses separated\
    \ by spaces\n    Output: Vector of integers representing the maximum depth of\
    \ nesting for each group of parentheses\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    max_depth = []\n    for group in paren_groups\n        depth = 0\n\
    \        max_depth_group = 0\n        for paren in group\n            if paren\
    \ == '('\n                depth += 1\n            elseif paren == ')'\n      \
    \          depth -= 1\n            end\n            if depth > max_depth_group\n\
    \                max_depth_group = depth\n            end\n        end\n     \
    \   push!(max_depth, max_depth_group)\n    end\n    return max_depth\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = split(paren_string, \" \")\n  \
    \  max_nesting = Vector{Int64}(undef, length(paren_string))\n    for i in 1:length(paren_string)\n\
    \        paren_string[i] = split(paren_string[i], \"\")\n        max_nesting[i]\
    \ = 0\n        nesting = 0\n        for j in 1:length(paren_string[i])\n     \
    \       if paren_string[i][j] == \"(\"\n                nesting += 1\n       \
    \     elseif paren_string[i][j] == \")\"\n                nesting -= 1\n     \
    \       end\n            if nesting > max_nesting[i]\n                max_nesting[i]\
    \ = nesting\n            end\n        end\n    end\n    return max_nesting\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp54f1qkng.jl:30

    '
  stdout: "test set: Error During Test at /tmp/tmp54f1qkng.jl:33\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ Cannot `convert` an object of type Vector{SubString{String}} to an object of\
    \ type SubString{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::T)\
    \ where T<:SubString at /shared/centos7/julia/1.7.3/share/julia/base/strings/substring.jl:56\n\
    \    convert(::Type{SubString{S}}, !Matched::AbstractString) where S<:AbstractString\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/strings/substring.jl:54\n  \
    \  convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    ...\n  Stacktrace:\n   [1] setindex!(A::Vector{SubString{String}}, x::Vector{SubString{String}},\
    \ i1::Int64)\n     @ Base ./array.jl:903\n   [2] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp54f1qkng.jl:12\n   [3] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [4] macro expansion\n     @ /tmp/tmp54f1qkng.jl:33 [inlined]\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [6] top-level scope\n     @ /tmp/tmp54f1qkng.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp54f1qkng.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: Cannot\
    \ `convert` an object of type Vector{SubString{String}} to an object of type SubString{String}\n\
    \  Closest candidates are:\n    convert(::Type{T}, !Matched::T) where T<:SubString\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/strings/substring.jl:56\n  \
    \  convert(::Type{SubString{S}}, !Matched::AbstractString) where S<:AbstractString\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/strings/substring.jl:54\n  \
    \  convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    ...\n  Stacktrace:\n   [1] setindex!(A::Vector{SubString{String}}, x::Vector{SubStri"
  timestamp: 1659748305
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = split(paren_string, \" \")\n  \
    \  max_nesting = zeros(Int64, length(paren_string))\n    for i in 1:length(paren_string)\n\
    \        parens = paren_string[i]\n        max_nesting[i] = 0\n        current_nesting\
    \ = 0\n        for j in 1:length(parens)\n            if parens[j] == '('\n  \
    \              current_nesting += 1\n            elseif parens[j] == ')'\n   \
    \             current_nesting -= 1\n            end\n            if current_nesting\
    \ > max_nesting[i]\n                max_nesting[i] = current_nesting\n       \
    \     end\n        end\n    end\n    return max_nesting\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # split the string into groups\n    groups = split(paren_string, \" \"\
    )\n    # for each group, find the maximum nesting level\n    max_nesting_levels\
    \ = [find_max_nesting_level(group) for group in groups]\n    return max_nesting_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp5j5w3n9h.jl:15

    '
  stdout: "test set: Error During Test at /tmp/tmp5j5w3n9h.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ find_max_nesting_level not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp5j5w3n9h.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp5j5w3n9h.jl:18 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp5j5w3n9h.jl:17\ntest set:\
    \ Error During Test at /tmp/tmp5j5w3n9h.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: find_max_nesting_level\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Base.Generator{Vector{SubString{String}}, var\"#1#2\"})\n \
    \    @ Base ./array.jl:724\n   [4] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp5j5w3n9h.jl:10\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp5j5w3n9h.jl:19 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp5j5w3n9h.jl:17\ntest set:\
    \ Error During Test at /tmp/tmp5j5w3n9h.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: find_max_nesting_level\
    \ not defined\n  Stacktrace:\n   [1] (::var\"#1#2\")(group::SubString{String})\n\
    \     @ Main ./none:0\n   [2] iterate\n     @ ./generator.jl:47 [inlined]\n  \
    \ [3] collect(itr::Ba"
  timestamp: 1659748304
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = split(paren_string, \" \")\n    max_depth = zeros(Int64,\
    \ length(paren_string))\n    for i in 1:length(paren_string)\n        paren_string[i]\
    \ = replace(paren_string[i], \")\", \"\")\n        paren_string[i] = replace(paren_string[i],\
    \ \"(\", \"\")\n        paren_string[i] = replace(paren_string[i], \" \", \"\"\
    )\n        max_depth[i] = length(paren_string[i])\n    end\n    return max_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp_iafymyn.jl:19

    '
  stdout: "test set: Error During Test at /tmp/tmp_iafymyn.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::SubString{String}, ::String, ::String)\n  Closest\
    \ candidates are:\n    replace(!Matched::Union{Function, Type}, ::Any; count)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n    replace(::AbstractString,\
    \ !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    replace(::Any, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:569\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmp_iafymyn.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_iafymyn.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_iafymyn.jl:21\ntest set:\
    \ Error During Test at /tmp/tmp_iafymyn.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::SubString{String}, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    replace(::Any, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:569\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmp_iafymyn.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_iafymyn.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level "
  timestamp: 1659748305
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_list = split(paren_string,\
    \ \" \")\n    paren_list = map(x -> x[2:end-1], paren_list)\n    paren_list =\
    \ map(x -> count(x, \"(\"), paren_list)\n    return paren_list\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbz1e6nge.jl:19

    '
  stdout: "test set: Test Failed at /tmp/tmpbz1e6nge.jl:22\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 2, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbz1e6nge.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbz1e6nge.jl:21\ntest set: Test\
    \ Failed at /tmp/tmpbz1e6nge.jl:23\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [2, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbz1e6nge.jl:23 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbz1e6nge.jl:21\ntest set: Test\
    \ Failed at /tmp/tmpbz1e6nge.jl:24\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbz1e6nge.jl:24 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbz1e6nge.jl:21\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748304
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string\
    \ = split(paren_string, \" \")\n    paren_string = map(x -> length(findall(x,\
    \ \"\\\\(\")), paren_string)\n    return paren_string\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp84pgn461.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmp84pgn461.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp84pgn461.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp84pgn461.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp84pgn461.jl:19\ntest set:\
    \ Error During Test at /tmp/tmp84pgn461.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp84pgn461.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp84pgn461.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659748305
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the maximum depth of nesting for each group\n\
    \    max_depth = Vector{Int64}()\n    # Initialize a counter to keep track of\
    \ the depth of nesting\n    depth = 0\n    # Initialize a variable to keep track\
    \ of the maximum depth of nesting for each group\n    max_depth_group = 0\n  \
    \  # Iterate through each character in the string\n    for char in paren_string\n\
    \        # If the character is an opening parenthesis, increment the depth counter\n\
    \        if char == '('\n            depth += 1\n        # If the character is\
    \ a closing parenthesis, decrement the depth counter\n        elseif char == ')'\n\
    \            depth -= 1\n        # If the character is a space, append the maximum\
    \ depth of nesting for the group to the vector\n        elseif char == ' '\n \
    \           push!(max_depth, max_depth_group)\n            # Reset the maximum\
    \ depth of nesting for the group to 0\n            max_depth_group = 0\n     \
    \   end\n        # Update the maximum depth of nesting for the group\n       \
    \ if depth > max_depth_group\n            max_depth_group = depth\n        end\n\
    \    end\n    # Append the maximum depth of nesting for the last group to the\
    \ vector\n    push!(max_depth, max_depth_group)\n    return max_depth\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748302
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = split(paren_string, \" \")\n    max_depth = []\n    for\
    \ i in 1:length(paren_string)\n        depth = 0\n        max_depth_i = 0\n  \
    \      for j in 1:length(paren_string[i])\n            if paren_string[i][j] ==\
    \ '('\n                depth += 1\n            elseif paren_string[i][j] == ')'\n\
    \                depth -= 1\n            end\n            if depth > max_depth_i\n\
    \                max_depth_i = depth\n            end\n        end\n        push!(max_depth,\
    \ max_depth_i)\n    end\n    return max_depth\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748302
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \") # remove spaces\n    paren_string = replace(paren_string, \")(\", \") (\"\
    ) # add spaces between groups\n    paren_string = split(paren_string, \" \") #\
    \ split into groups\n    max_nesting = zeros(Int64, length(paren_string))\n  \
    \  for i in 1:length(paren_string)\n        paren_group = paren_string[i]\n  \
    \      paren_group = replace(paren_group, \"()\", \"\") # remove empty parens\n\
    \        paren_group = replace(paren_group, \")(\", \"\") # remove empty parens\n\
    \        paren_group = replace(paren_group, \")\", \"\") # remove right parens\n\
    \        paren_group = replace(paren_group, \"(\", \"\") # remove left parens\n\
    \        max_nesting[i] = length(paren_group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp77za7jjc.jl:25

    '
  stdout: "test set: Error During Test at /tmp/tmp77za7jjc.jl:28\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp77za7jjc.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp77za7jjc.jl:28 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp77za7jjc.jl:27\ntest set:\
    \ Error During Test at /tmp/tmp77za7jjc.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp77za7jjc.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp77za7jjc.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659748305
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_string = split(paren_string,\
    \ \" \")\n    paren_string = [replace(i, \")\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"(\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \"\", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\"\
    ) for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \"\", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\"\
    ) for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \"\", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\"\
    ) for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp638hx117.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp638hx117.jl:1\n\
    in expression starting at /tmp/tmp638hx117.jl:1\n"
  stdout: ''
  timestamp: 1659748303
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_levels = []\n   \
    \ for paren_group in paren_groups\n        paren_level = 0\n        max_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         paren_level += 1\n            elseif paren == ')'\n                paren_level\
    \ -= 1\n            end\n            if paren_level > max_level\n            \
    \    max_level = paren_level\n            end\n        end\n        push!(paren_levels,\
    \ max_level)\n    end\n    return paren_levels\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748302
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of maximum nesting levels for each group of parentheses.\n\
    \    \"\"\"\n    # Initialize a vector to store the maximum nesting levels for\
    \ each group of parentheses.\n    max_nesting_levels = Vector{Int64}()\n    #\
    \ Initialize a vector to store the current nesting level for each group of parentheses.\n\
    \    current_nesting_levels = Vector{Int64}()\n    # Initialize a vector to store\
    \ the current nesting level for each group of parentheses.\n    current_nesting_levels\
    \ = Vector{Int64}()\n    # Initialize a vector to store the current nesting level\
    \ for each group of parentheses.\n    current_nesting_levels = Vector{Int64}()\n\
    \    # Initialize a vector to store the current nesting level for each group of\
    \ parentheses.\n    current_nesting_levels = Vector{Int64}()\n    # Initialize\
    \ a vector to store the current nesting level for each group of parentheses.\n\
    \    current_nesting_levels = Vector{Int64}()\n    # Initialize a vector to store\
    \ the current nesting level for each group of parentheses.\n    current_nesting_levels\
    \ = Vector{Int64}()\n    # Initialize a vector to store the current nesting level\
    \ for each group of parentheses.\n    current_nesting_levels = Vector{Int64}()\n\
    \    # Initialize a vector to store the current nesting level for each group of\
    \ parentheses.\n    current_nesting_levels = Vector{Int64}()\n    # Initialize\
    \ a vector to store the current nesting level for each group of parentheses.\n\
    \    current_nesting_levels = Vector{Int64}()\n    # Initialize a vector to store\
    \ the current nesting level for each group of parentheses.\n    current_nesting_levels\
    \ = Vector{Int64}()\n    # Initialize a vector to store the current nesting level\
    \ for each group of parentheses.\n    current_nesting_levels = Vector{Int64}()\n\
    \    # Initialize a vector to store the current nesting level for each group of\
    \ parentheses.\n    current_nesting_levels = Vector{Int64}()\n    # Initialize\
    \ a vector to store the current nesting level for each group of parentheses.\n\
    \    current_nesting_levels = Vector{Int64}()\n    #\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpct3dcwu8.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpct3dcwu8.jl:1\n\
    in expression starting at /tmp/tmpct3dcwu8.jl:1\n"
  stdout: ''
  timestamp: 1659748303
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_list = split(paren_string,\
    \ \" \")\n    paren_list = [replace(x, \")\", \"\") for x in paren_list]\n   \
    \ paren_list = [replace(x, \"(\", \"\") for x in paren_list]\n    paren_list =\
    \ [replace(x, \" \", \"\") for x in paren_list]\n    paren_list = [replace(x,\
    \ \"\", \"\") for x in paren_list]\n    paren_list = [replace(x, \"\", \"\") for\
    \ x in paren_list]\n    paren_list = [replace(x, \"\", \"\") for x in paren_list]\n\
    \    paren_list = [replace(x, \"\", \"\") for x in paren_list]\n    paren_list\
    \ = [replace(x, \"\", \"\") for x in paren_list]\n    paren_list = [replace(x,\
    \ \"\", \"\") for x in paren_list]\n    paren_list = [replace(x, \"\", \"\") for\
    \ x in paren_list]\n    paren_list = [replace(x, \"\", \"\") for x in paren_list]\n\
    \    paren_list = [replace(x, \"\", \"\") for x in paren_list]\n    paren_list\
    \ = [replace(x, \"\", \"\") for x in paren_list]\n    paren_list = [replace(x,\
    \ \"\", \"\") for x in paren_list]\n    paren_list = [replace(x, \"\", \"\") for\
    \ x in paren_list]\n    paren_list = [replace(x, \"\", \"\") for x in paren_list]\n\
    \    paren_list = [replace(x, \"\", \"\") for x in paren_list]\n    paren_list\
    \ = [replace(x, \"\", \"\") for x in paren_list]\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpetbdcpxh.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpetbdcpxh.jl:1\n\
    in expression starting at /tmp/tmpetbdcpxh.jl:1\n"
  stdout: ''
  timestamp: 1659748303
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces\n\
    \    Output: Vector of integers representing the deepest level of nesting of parentheses\
    \ for each group\n    \"\"\"\n    # Initialize output vector\n    output = Vector{Int64}()\n\
    \    \n    # Split the input string by spaces\n    paren_groups = split(paren_string,\
    \ \" \")\n    \n    # For each group, calculate the deepest level of nesting\n\
    \    for group in paren_groups\n        # Initialize counter\n        counter\
    \ = 0\n        # Initialize maximum counter\n        max_counter = 0\n       \
    \ \n        # Loop through each character in the group\n        for char in group\n\
    \            # If the character is an opening parenthesis, increment the counter\n\
    \            if char == '('\n                counter += 1\n            # If the\
    \ character is a closing parenthesis, decrement the counter\n            elseif\
    \ char == ')'\n                counter -= 1\n            end\n            \n \
    \           # If the counter is greater than the maximum counter, update the maximum\
    \ counter\n            if counter > max_counter\n                max_counter =\
    \ counter\n            end\n        end\n        \n        # Append the maximum\
    \ counter to the output vector\n        push!(output, max_counter)\n    end\n\
    \    \n    # Return the output vector\n    return output\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748303
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: paren_string: String\n    Output: Vector{Int64}\n \
    \   \"\"\"\n    # Initialize the output vector\n    output = Vector{Int64}()\n\
    \    \n    # Split the string into groups of parentheses\n    paren_groups = split(paren_string,\
    \ \" \")\n    \n    # For each group, find the maximum nesting level\n    for\
    \ group in paren_groups\n        # Initialize the nesting level\n        nesting_level\
    \ = 0\n        \n        # Initialize the maximum nesting level\n        max_nesting_level\
    \ = 0\n        \n        # For each character in the group\n        for char in\
    \ group\n            # If the character is an opening parenthesis\n          \
    \  if char == '('\n                # Increase the nesting level\n            \
    \    nesting_level += 1\n                \n                # If the nesting level\
    \ is greater than the maximum nesting level\n                if nesting_level\
    \ > max_nesting_level\n                    # Update the maximum nesting level\n\
    \                    max_nesting_level = nesting_level\n                end\n\
    \            # If the character is a closing parenthesis\n            elseif char\
    \ == ')'\n                # Decrease the nesting level\n                nesting_level\
    \ -= 1\n            end\n        end\n        \n        # Append the maximum nesting\
    \ level to the output vector\n        push!(output, max_nesting_level)\n    end\n\
    \    \n    # Return the output vector\n    return output\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748303
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    # Initialize a vector\
    \ to store the output\n    output = Int64[]\n    # Split the input string by spaces\n\
    \    paren_groups = split(paren_string, \" \")\n    # For each of the groups\n\
    \    for paren_group in paren_groups\n        # Initialize the level of nesting\
    \ to 0\n        level = 0\n        # Initialize the maximum level of nesting to\
    \ 0\n        max_level = 0\n        # For each of the parentheses\n        for\
    \ paren in paren_group\n            # If it is an opening parenthesis\n      \
    \      if paren == '('\n                # Increment the level of nesting\n   \
    \             level += 1\n            # If it is a closing parenthesis\n     \
    \       elseif paren == ')'\n                # Decrement the level of nesting\n\
    \                level -= 1\n            end\n            # Update the maximum\
    \ level of nesting\n            max_level = max(max_level, level)\n        end\n\
    \        # Append the maximum level of nesting to the output vector\n        push!(output,\
    \ max_level)\n    end\n    # Return the output vector\n    return output\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748303
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \"(\" not allowed in \"\")(\\nusing\
    \ Test\\n\\n@testset begin\\n\\ncandidate = parse_nested_parens;\\n\\t@test(candidate(\"\
    (()()) (\" at /tmp/tmpuysjdciq.jl:38\nStacktrace:\n [1] top-level scope\n   @\
    \ /tmp/tmpuysjdciq.jl:38\nin expression starting at /tmp/tmpuysjdciq.jl:38\n"
  stdout: ''
  timestamp: 1659748304
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vector\
    \ = Vector{Int64}()\n    # Initialize a counter to keep track of the depth of\
    \ each group\n    depth_counter = 0\n    # Initialize a vector to store the indices\
    \ of the opening parentheses\n    open_paren_indices = Vector{Int64}()\n    #\
    \ Initialize a vector to store the indices of the closing parentheses\n    close_paren_indices\
    \ = Vector{Int64}()\n    # Initialize a vector to store the indices of the spaces\n\
    \    space_indices = Vector{Int64}()\n    # Initialize a vector to store the indices\
    \ of the opening parentheses of each group\n    group_open_paren_indices = Vector{Int64}()\n\
    \    # Initialize a vector to store the indices of the closing parentheses of\
    \ each group\n    group_close_paren_indices = Vector{Int64}()\n    # Initialize\
    \ a vector to store the indices of the spaces of each group\n    group_space_indices\
    \ = Vector{Int64}()\n    # Initialize a vector to store the indices of the opening\
    \ parentheses of each group\n    group_open_paren_indices = Vector{Int64}()\n\
    \    # Initialize a vector to store the indices of the closing parentheses of\
    \ each group\n    group_close_paren_indices = Vector{Int64}()\n    # Initialize\
    \ a vector to store the indices of the spaces of each group\n    group_space_indices\
    \ = Vector{Int64}()\n    # Initialize a vector to store the indices of the opening\
    \ parentheses of each group\n    group_open_paren_indices = Vector{Int64}()\n\
    \    # Initialize a vector to store the indices of the closing parentheses of\
    \ each group\n    group_close_paren_indices = Vector{Int64}()\n    # Initialize\
    \ a vector to store the indices of the spaces of each group\n    group_space_indices\
    \ = Vector{Int64}()\n    # Initialize a vector to store the indices of the opening\
    \ parentheses of each group\n    group_open_paren_indices = Vector{Int64}()\n\
    \    # Initialize a vector to store the indices of the closing parentheses of\
    \ each group\n    group_close_paren_indices = Vector{Int64}()\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp87hs01r_.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp87hs01r_.jl:1\n\
    in expression starting at /tmp/tmp87hs01r_.jl:1\n"
  stdout: ''
  timestamp: 1659748304
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces\n\
    \    Output: Vector of maximum nesting levels for each group of parentheses\n\
    \    \"\"\"\n    paren_groups = split(paren_string, \" \")\n    max_nesting =\
    \ zeros(Int64, length(paren_groups))\n    for i in 1:length(paren_groups)\n  \
    \      paren_group = paren_groups[i]\n        max_nesting[i] = parse_nested_parens_helper(paren_group)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpgogev4rt.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpgogev4rt.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpgogev4rt.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgogev4rt.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgogev4rt.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpgogev4rt.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpgogev4rt.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgogev4rt.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgogev4rt.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpgogev4rt.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpgogev4rt.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgogev4rt.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgogev4rt.jl:23\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748306
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the deepest level of nesting for each group\n\
    \    deepest_level = Vector{Int64}()\n    # Split the string into groups\n   \
    \ groups = split(paren_string, \" \")\n    # For each group, find the deepest\
    \ level of nesting\n    for group in groups\n        # Initialize a counter to\
    \ keep track of the current level of nesting\n        current_level = 0\n    \
    \    # Initialize a counter to keep track of the deepest level of nesting\n  \
    \      deepest_level_for_group = 0\n        # For each character in the group,\
    \ check if it is an opening or closing parenthesis\n        for char in group\n\
    \            if char == '('\n                # If it is an opening parenthesis,\
    \ increment the current level of nesting\n                current_level += 1\n\
    \                # If the current level of nesting is greater than the deepest\
    \ level of nesting for the group,\n                # update the deepest level\
    \ of nesting for the group\n                if current_level > deepest_level_for_group\n\
    \                    deepest_level_for_group = current_level\n               \
    \ end\n            elseif char == ')'\n                # If it is a closing parenthesis,\
    \ decrement the current level of nesting\n                current_level -= 1\n\
    \            end\n        end\n        # Add the deepest level of nesting for\
    \ the group to the vector\n        push!(deepest_level, deepest_level_for_group)\n\
    \    end\n    # Return the vector\n    return deepest_level\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748304
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses\n    Output: Vector of\
    \ integers representing the deepest level of nesting of parentheses\n    \"\"\"\
    \n    # Initialize a vector to store the deepest level of nesting of parentheses\n\
    \    max_nesting = Vector{Int64}()\n    # Initialize a counter to keep track of\
    \ the current level of nesting\n    curr_nesting = 0\n    # Iterate through the\
    \ string\n    for char in paren_string\n        # If the character is an opening\
    \ parenthesis, increment the counter\n        if char == '('\n            curr_nesting\
    \ += 1\n        # If the character is a closing parenthesis, decrement the counter\n\
    \        elseif char == ')'\n            curr_nesting -= 1\n        # If the character\
    \ is a space, push the current level of nesting to the vector\n        elseif\
    \ char == ' '\n            push!(max_nesting, curr_nesting)\n        end\n   \
    \ end\n    # Return the vector of maximum nesting levels\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5xr7qy0m.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmp5xr7qy0m.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5xr7qy0m.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5xr7qy0m.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp5xr7qy0m.jl:37\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5xr7qy0m.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5xr7qy0m.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp5xr7qy0m.jl:38\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp5xr7qy0m.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5xr7qy0m.jl:35\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748306
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vector\
    \ = Vector{Int64}()\n    # Split the input string into groups\n    groups = split(paren_string,\
    \ \" \")\n    # Iterate over each group\n    for group in groups\n        # Initialize\
    \ a counter to keep track of the depth\n        depth = 0\n        # Initialize\
    \ a variable to keep track of the maximum depth\n        max_depth = 0\n     \
    \   # Iterate over each character in the group\n        for character in group\n\
    \            # If the character is an opening parenthesis, increment the depth\
    \ counter\n            if character == '('\n                depth += 1\n     \
    \       # If the character is a closing parenthesis, decrement the depth counter\n\
    \            elseif character == ')'\n                depth -= 1\n           \
    \ end\n            # Update the maximum depth\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        end\n        # Add\
    \ the maximum depth to the depth vector\n        push!(depth_vector, max_depth)\n\
    \    end\n    # Return the depth vector\n    return depth_vector\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748304
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: paren_string is a string of multiple groups of nested\
    \ parentheses separated by spaces.\n    Output: a vector of integers, where each\
    \ integer represents the maximum level of nesting for each group.\n    \"\"\"\n\
    \    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_group\
    \ = paren_groups[i]\n        max_nesting[i] = parse_parens(paren_group)\n    end\n\
    \    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpa0del5wi.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpa0del5wi.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpa0del5wi.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpa0del5wi.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpa0del5wi.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpa0del5wi.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpa0del5wi.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpa0del5wi.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpa0del5wi.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpa0del5wi.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpa0del5wi.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpa0del5wi.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpa0del5wi.jl:23\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748306
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")\", \"\")\n    paren_string = replace(paren_string, \"(\", \"\")\n    paren_string\
    \ = replace(paren_string, \" \", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpg4_cvy93.jl:41\nin expression starting at\
    \ /tmp/tmpg4_cvy93.jl:41\n"
  stdout: ''
  timestamp: 1659748305
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = parse_parens(paren_group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmptk6_ufoq.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmptk6_ufoq.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmptk6_ufoq.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptk6_ufoq.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptk6_ufoq.jl:18\ntest set:\
    \ Error During Test at /tmp/tmptk6_ufoq.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmptk6_ufoq.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptk6_ufoq.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptk6_ufoq.jl:18\ntest set:\
    \ Error During Test at /tmp/tmptk6_ufoq.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmptk6_ufoq.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptk6_ufoq.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptk6_ufoq.jl:18\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748306
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces\n\
    \    Output: Vector of integers representing the maximum depth of nesting for\
    \ each group of parentheses\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    max_nesting = zeros(Int64, length(paren_groups))\n    for i in 1:length(paren_groups)\n\
    \        paren_group = paren_groups[i]\n        depth = 0\n        max_depth =\
    \ 0\n        for j in 1:length(paren_group)\n            if paren_group[j] ==\
    \ '('\n                depth += 1\n            elseif paren_group[j] == ')'\n\
    \                depth -= 1\n            end\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        end\n        max_nesting[i]\
    \ = max_depth\n    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748304
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    max_nesting = Vector{Int64}(undef, length(paren_groups))\n    for\
    \ i in 1:length(paren_groups)\n        max_nesting[i] = max_nesting_in_paren_group(paren_groups[i])\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp8njp1u39.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmp8njp1u39.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ max_nesting_in_paren_group not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp8njp1u39.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8njp1u39.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8njp1u39.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp8njp1u39.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: max_nesting_in_paren_group\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp8njp1u39.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8njp1u39.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8njp1u39.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp8njp1u39.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: max_nesting_in_paren_group\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp8njp1u39.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8njp1u39.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8njp1u39.jl:23\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748306
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    depth = 0\n   \
    \ max_depth = 0\n    depths = []\n    for i in 1:length(paren_string)\n      \
    \  if paren_string[i] == '('\n            depth += 1\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        elseif paren_string[i]\
    \ == ')'\n            depths = [depths; max_depth]\n            depth -= 1\n \
    \       end\n    end\n    return depths\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp3q6y3_f_.jl:26

    '
  stdout: "test set: Error During Test at /tmp/tmp3q6y3_f_.jl:29\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp3q6y3_f_.jl:7\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3q6y3_f_.jl:29 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp3q6y3_f_.jl:28\ntest set:\
    \ Error During Test at /tmp/tmp3q6y3_f_.jl:30\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp3q6y3_f_.jl:7\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp3q6y3_f_.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659748307
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    This function takes a string of nested parentheses and returns\
    \ a vector of integers representing the maximum level of nesting for each group.\n\
    \    \"\"\"\n    # Initialize a vector to store the maximum level of nesting for\
    \ each group\n    max_nesting_levels = Vector{Int64}()\n    # Split the string\
    \ into groups of parentheses\n    paren_groups = split(paren_string, \" \")\n\
    \    # For each group of parentheses\n    for paren_group in paren_groups\n  \
    \      # Initialize a counter to keep track of the current level of nesting\n\
    \        current_nesting_level = 0\n        # Initialize a counter to keep track\
    \ of the maximum level of nesting\n        max_nesting_level = 0\n        # For\
    \ each character in the group of parentheses\n        for char in paren_group\n\
    \            # If the character is an opening parenthesis\n            if char\
    \ == '('\n                # Increment the current level of nesting\n         \
    \       current_nesting_level += 1\n                # If the current level of\
    \ nesting is greater than the maximum level of nesting\n                if current_nesting_level\
    \ > max_nesting_level\n                    # Update the maximum level of nesting\n\
    \                    max_nesting_level = current_nesting_level\n             \
    \   end\n            # If the character is a closing parenthesis\n           \
    \ elseif char == ')'\n                # Decrement the current level of nesting\n\
    \                current_nesting_level -= 1\n            end\n        end\n  \
    \      # Add the maximum level of nesting for the current group to the vector\
    \ of maximum levels of nesting\n        push!(max_nesting_levels, max_nesting_level)\n\
    \    end\n    # Return the vector of maximum levels of nesting\n    return max_nesting_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748304
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: A string of nested parentheses separated by spaces.\n\
    \    Output: A vector of integers representing the maximum depth of nesting for\
    \ each group of parentheses.\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    max_nesting = []\n    for paren_group in paren_groups\n        max_nesting_level\
    \ = 0\n        current_nesting_level = 0\n        for paren in paren_group\n \
    \           if paren == '('\n                current_nesting_level += 1\n    \
    \        elseif paren == ')'\n                current_nesting_level -= 1\n   \
    \         end\n            if current_nesting_level > max_nesting_level\n    \
    \            max_nesting_level = current_nesting_level\n            end\n    \
    \    end\n        push!(max_nesting, max_nesting_level)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748304
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = split(paren_string, \" \")\n  \
    \  paren_counts = []\n    for paren_group in paren_string\n        paren_count\
    \ = 0\n        max_paren_count = 0\n        for paren in paren_group\n       \
    \     if paren == '('\n                paren_count += 1\n            elseif paren\
    \ == ')'\n                paren_count -= 1\n            end\n            if paren_count\
    \ > max_paren_count\n                max_paren_count = paren_count\n         \
    \   end\n        end\n        push!(paren_counts, max_paren_count)\n    end\n\
    \    return paren_counts\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748304
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string,\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiyh23ye9.jl:38\nin expression starting at\
    \ /tmp/tmpiyh23ye9.jl:38\n"
  stdout: ''
  timestamp: 1659748305
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \"(\" not allowed in \"\")(\\nusing\
    \ Test\\n\\n@testset begin\\n\\ncandidate = parse_nested_parens;\\n\\t@test(candidate(\"\
    (()()) (\" at /tmp/tmpuysjdciq.jl:38\nStacktrace:\n [1] top-level scope\n   @\
    \ /tmp/tmpuysjdciq.jl:38\nin expression starting at /tmp/tmpuysjdciq.jl:38\n"
  stdout: ''
  timestamp: 1659748304
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_group\
    \ = paren_groups[i]\n        paren_count = 0\n        max_count = 0\n        for\
    \ j in 1:length(paren_group)\n            if paren_group[j] == '('\n         \
    \       paren_count += 1\n            elseif paren_group[j] == ')'\n         \
    \       paren_count -= 1\n            end\n            if paren_count > max_count\n\
    \                max_count = paren_count\n            end\n        end\n     \
    \   max_nesting[i] = max_count\n    end\n    return max_nesting\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748305
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    # Initialize a vector to store the depth of each\
    \ group\n    depth_vector = Vector{Int64}()\n    # Split the string into groups\n\
    \    groups = split(paren_string, \" \")\n    # For each group\n    for group\
    \ in groups\n        # Initialize a counter to store the depth of the current\
    \ group\n        depth = 0\n        # Initialize a counter to store the maximum\
    \ depth of the current group\n        max_depth = 0\n        # For each character\
    \ in the group\n        for char in group\n            # If the character is an\
    \ opening parenthesis\n            if char == '('\n                # Increment\
    \ the depth counter\n                depth += 1\n                # If the depth\
    \ counter is greater than the maximum depth counter\n                if depth\
    \ > max_depth\n                    # Update the maximum depth counter\n      \
    \              max_depth = depth\n                end\n            # If the character\
    \ is a closing parenthesis\n            elseif char == ')'\n                #\
    \ Decrement the depth counter\n                depth -= 1\n            end\n \
    \       end\n        # Append the maximum depth of the current group to the depth\
    \ vector\n        push!(depth_vector, max_depth)\n    end\n    # Return the depth\
    \ vector\n    return depth_vector\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748305
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_levels = []\n   \
    \ for group in paren_groups\n        paren_levels = [push!(paren_levels, paren_level(group))]\n\
    \    end\n    return paren_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpaj3cpbjp.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmpaj3cpbjp.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ paren_level not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpaj3cpbjp.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpaj3cpbjp.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpaj3cpbjp.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpaj3cpbjp.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: paren_level\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpaj3cpbjp.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpaj3cpbjp.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpaj3cpbjp.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpaj3cpbjp.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: paren_level not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpaj3cpbjp.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpaj3cpbjp.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpaj3cpbjp.jl:18\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748307
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: string of nested parentheses separated by spaces\n\
    \    Output: vector of integers representing the maximum depth of nesting for\
    \ each group of parentheses\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    max_depth = zeros(Int64, length(paren_groups))\n    for i in 1:length(paren_groups)\n\
    \        paren_group = paren_groups[i]\n        depth = 0\n        max_depth[i]\
    \ = 0\n        for j in 1:length(paren_group)\n            if paren_group[j] ==\
    \ '('\n                depth += 1\n                if depth > max_depth[i]\n \
    \                   max_depth[i] = depth\n                end\n            elseif\
    \ paren_group[j] == ')'\n                depth -= 1\n            end\n       \
    \ end\n    end\n    return max_depth\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748305
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vector\
    \ = Vector{Int64}()\n    # Initialize a variable to store the depth of the current\
    \ group\n    depth = 0\n    # Iterate through the string\n    for i in 1:length(paren_string)\n\
    \        # If the current character is an opening parenthesis, increment the depth\n\
    \        if paren_string[i] == '('\n            depth += 1\n        # If the current\
    \ character is a closing parenthesis, decrement the depth\n        elseif paren_string[i]\
    \ == ')'\n            depth -= 1\n        # If the current character is a space,\
    \ push the current depth to the vector and reset the depth\n        elseif paren_string[i]\
    \ == ' '\n            push!(depth_vector, depth)\n            depth = 0\n    \
    \    end\n    end\n    # Return the vector\n    return depth_vector\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2h7b03rv.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmp2h7b03rv.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2h7b03rv.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2h7b03rv.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp2h7b03rv.jl:34\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2h7b03rv.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2h7b03rv.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp2h7b03rv.jl:35\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2h7b03rv.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2h7b03rv.jl:32\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748307
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n \
    \   paren_string = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4v2u04cl.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4v2u04cl.jl:1\n\
    in expression starting at /tmp/tmp4v2u04cl.jl:1\n"
  stdout: ''
  timestamp: 1659748306
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \")\", \"\")\n    paren_string =\
    \ replace(paren_string, \"(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \" \")\n    paren_string = split(paren_string)\n    paren_string = [parse(Int64,\
    \ x) for x in paren_string]\n    return paren_string\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp4robcl54.jl:19

    '
  stdout: "test set: Error During Test at /tmp/tmp4robcl54.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp4robcl54.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4robcl54.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4robcl54.jl:21\ntest set:\
    \ Error During Test at /tmp/tmp4robcl54.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp4robcl54.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4robcl54.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659748308
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_string = split(paren_string,\
    \ \" \")\n    paren_string = [replace(i, \")\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"(\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \" \", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \"\", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\"\
    ) for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \"\", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\"\
    ) for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \"\", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\"\
    ) for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2yt9yi8l.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2yt9yi8l.jl:1\n\
    in expression starting at /tmp/tmp2yt9yi8l.jl:1\n"
  stdout: ''
  timestamp: 1659748306
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Split the string into groups separated by spaces\n    groups = split(paren_string,\
    \ \" \")\n    # Initialize a vector to store the depth of each group\n    depth\
    \ = zeros(Int64, length(groups))\n    # For each group, find the depth\n    for\
    \ i in 1:length(groups)\n        # Initialize a counter to keep track of the depth\n\
    \        count = 0\n        # Initialize a maximum to keep track of the maximum\
    \ depth\n        maximum = 0\n        # For each character in the group\n    \
    \    for j in 1:length(groups[i])\n            # If the character is an opening\
    \ parenthesis, increment the counter\n            if groups[i][j] == '('\n   \
    \             count += 1\n            # If the character is a closing parenthesis,\
    \ decrement the counter\n            elseif groups[i][j] == ')'\n            \
    \    count -= 1\n            end\n            # If the counter is greater than\
    \ the maximum, update the maximum\n            if count > maximum\n          \
    \      maximum = count\n            end\n        end\n        # Store the maximum\
    \ depth for the group\n        depth[i] = maximum\n    end\n    # Return the vector\
    \ of depths\n    return depth\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748305
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth = Vector{Int64}()\n\
    \    # Split the string into groups\n    groups = split(paren_string, \" \")\n\
    \    # For each group\n    for group in groups\n        # Initialize a counter\
    \ to keep track of the depth\n        counter = 0\n        # Initialize a maximum\
    \ depth variable\n        max_depth = 0\n        # For each character in the group\n\
    \        for char in group\n            # If the character is an opening parenthesis\n\
    \            if char == '('\n                # Increment the counter\n       \
    \         counter += 1\n                # If the counter is greater than the maximum\
    \ depth\n                if counter > max_depth\n                    # Set the\
    \ maximum depth to the counter\n                    max_depth = counter\n    \
    \            end\n            # If the character is a closing parenthesis\n  \
    \          elseif char == ')'\n                # Decrement the counter\n     \
    \           counter -= 1\n            end\n        end\n        # Append the maximum\
    \ depth to the depth vector\n        push!(depth, max_depth)\n    end\n    # Return\
    \ the depth vector\n    return depth\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748305
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for paren in group\n            if paren == '('\n             \
    \   current_nesting_level += 1\n            elseif paren == ')'\n            \
    \    current_nesting_level -= 1\n            end\n            if current_nesting_level\
    \ > max_nesting_level\n                max_nesting_level = current_nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748305
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \")\", \"\")\n    paren_string\
    \ = replace(paren_string, \"(\", \"\")\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"\", \" \")\n    paren_string\
    \ = replace(paren_string, \" \", \"\")\n    return [length(x) for x in split(paren_string,\
    \ \"\")]\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpxa14hvcx.jl:19

    '
  stdout: "test set: Error During Test at /tmp/tmpxa14hvcx.jl:22\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpxa14hvcx.jl:7\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxa14hvcx.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxa14hvcx.jl:21\ntest set:\
    \ Error During Test at /tmp/tmpxa14hvcx.jl:23\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpxa14hvcx.jl:7\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxa14hvcx.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659748309
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n    paren_string = replace(paren_string, \"\", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \"\")\n   \nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpm9bqmeb2.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpm9bqmeb2.jl:1\n\
    in expression starting at /tmp/tmpm9bqmeb2.jl:1\n"
  stdout: ''
  timestamp: 1659748306
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vector\
    \ = Int64[]\n    # Initialize a counter to keep track of the depth of the current\
    \ group\n    depth_counter = 0\n    # Initialize a counter to keep track of the\
    \ number of groups\n    group_counter = 0\n    # Initialize a variable to store\
    \ the maximum depth of the current group\n    max_depth = 0\n    # Initialize\
    \ a variable to store the maximum depth of the current group\n    min_depth =\
    \ 0\n    # Initialize a variable to store the maximum depth of the current group\n\
    \    max_depth_group = 0\n    # Initialize a variable to store the maximum depth\
    \ of the current group\n    min_depth_group = 0\n    # Initialize a variable to\
    \ store the maximum depth of the current group\n    max_depth_group_counter =\
    \ 0\n    # Initialize a variable to store the maximum depth of the current group\n\
    \    min_depth_group_counter = 0\n    # Initialize a variable to store the maximum\
    \ depth of the current group\n    max_depth_group_counter = 0\n    # Initialize\
    \ a variable to store the maximum depth of the current group\n    min_depth_group_counter\
    \ = 0\n    # Initialize a variable to store the maximum depth of the current group\n\
    \    max_depth_group_counter = 0\n    # Initialize a variable to store the maximum\
    \ depth of the current group\n    min_depth_group_counter = 0\n    # Initialize\
    \ a variable to store the maximum depth of the current group\n    max_depth_group_counter\
    \ = 0\n    # Initialize a variable to store the maximum depth of the current group\n\
    \    min_depth_group_counter = 0\n    # Initialize a variable to store the maximum\
    \ depth of the current group\n    max_depth_group_counter = 0\n    # Initialize\
    \ a variable to store the maximum depth of the current group\n    min_depth_group_counter\
    \ = 0\n    # Initialize a variable to store the maximum depth of the current group\n\
    \    max_depth_group_counter = 0\n    # Initialize a variable to store the maximum\
    \ depth of the current group\n    min_depth_group_counter = 0\n    # Initialize\
    \ a variable to store the maximum depth of the current group\n    max_depth_group\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpxkqaiso8.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpxkqaiso8.jl:1\n\
    in expression starting at /tmp/tmpxkqaiso8.jl:1\n"
  stdout: ''
  timestamp: 1659748306
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # split the string into groups\n    groups = split(paren_string, \" \"\
    )\n    # initialize a vector to store the result\n    result = Vector{Int64}(undef,\
    \ length(groups))\n    # loop over the groups\n    for (i, group) in enumerate(groups)\n\
    \        # initialize a counter\n        counter = 0\n        # loop over the\
    \ characters in the group\n        for c in group\n            # if the character\
    \ is an opening parenthesis, increment the counter\n            if c == '('\n\
    \                counter += 1\n            # if the character is a closing parenthesis,\
    \ decrement the counter\n            elseif c == ')'\n                counter\
    \ -= 1\n            end\n        end\n        # store the counter in the result\n\
    \        result[i] = counter\n    end\n    # return the result\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp466oryl5.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmp466oryl5.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp466oryl5.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp466oryl5.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp466oryl5.jl:37\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp466oryl5.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp466oryl5.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp466oryl5.jl:38\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp466oryl5.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp466oryl5.jl:35\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748307
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of integers representing the deepest level of nesting of parentheses\
    \ for each group.\n    \"\"\"\n    # Initialize vector to store the deepest level\
    \ of nesting of parentheses for each group.\n    deepest_level = Vector{Int64}(undef,\
    \ length(split(paren_string)))\n    \n    # Iterate through each group of parentheses.\n\
    \    for i in 1:length(deepest_level)\n        # Initialize counter for the deepest\
    \ level of nesting of parentheses.\n        level = 0\n        # Initialize counter\
    \ for the current level of nesting of parentheses.\n        current_level = 0\n\
    \        # Iterate through each character in the group of parentheses.\n     \
    \   for j in 1:length(split(paren_string)[i])\n            # If the character\
    \ is an opening parenthesis, increment the current level of nesting of parentheses.\n\
    \            if split(paren_string)[i][j] == '('\n                current_level\
    \ += 1\n            # If the character is a closing parenthesis, decrement the\
    \ current level of nesting of parentheses.\n            elseif split(paren_string)[i][j]\
    \ == ')'\n                current_level -= 1\n            end\n            # Update\
    \ the deepest level of nesting of parentheses if the current level of nesting\
    \ of parentheses is greater.\n            if current_level > level\n         \
    \       level = current_level\n            end\n        end\n        # Store the\
    \ deepest level of nesting of parentheses for the group.\n        deepest_level[i]\
    \ = level\n    end\n    return deepest_level\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748306
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string,\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiyh23ye9.jl:38\nin expression starting at\
    \ /tmp/tmpiyh23ye9.jl:38\n"
  stdout: ''
  timestamp: 1659748305
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         current_nesting_level += 1\n            elseif paren == ')'\n      \
    \          current_nesting_level -= 1\n            end\n            if current_nesting_level\
    \ > max_nesting_level\n                max_nesting_level = current_nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748306
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n   \nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpw1_tj1cn.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpw1_tj1cn.jl:1\n\
    in expression starting at /tmp/tmpw1_tj1cn.jl:1\n"
  stdout: ''
  timestamp: 1659748307
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = Vector{Int64}(undef,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_group\
    \ = paren_groups[i]\n        max_nesting[i] = 0\n        current_nesting = 0\n\
    \        for j in 1:length(paren_group)\n            if paren_group[j] == '('\n\
    \                current_nesting += 1\n            elseif paren_group[j] == ')'\n\
    \                current_nesting -= 1\n            end\n            if current_nesting\
    \ > max_nesting[i]\n                max_nesting[i] = current_nesting\n       \
    \     end\n        end\n    end\n    return max_nesting\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748306
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for (i, paren_group) in enumerate(paren_groups)\n\
    \        max_nesting[i] = parse_parens(paren_group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp62q32us2.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmp62q32us2.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp62q32us2.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp62q32us2.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp62q32us2.jl:18\ntest set:\
    \ Error During Test at /tmp/tmp62q32us2.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp62q32us2.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp62q32us2.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp62q32us2.jl:18\ntest set:\
    \ Error During Test at /tmp/tmp62q32us2.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmp62q32us2.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp62q32us2.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp62q32us2.jl:18\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748308
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_levels = []\n   \
    \ for group in paren_groups\n        paren_levels = [push!(paren_levels, parse_parens(group))]\n\
    \    end\n    return paren_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmps48lds8x.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmps48lds8x.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmps48lds8x.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmps48lds8x.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmps48lds8x.jl:18\ntest set:\
    \ Error During Test at /tmp/tmps48lds8x.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmps48lds8x.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmps48lds8x.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmps48lds8x.jl:18\ntest set:\
    \ Error During Test at /tmp/tmps48lds8x.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmps48lds8x.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmps48lds8x.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmps48lds8x.jl:18\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748308
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of integers representing the maximum depth of nesting for\
    \ each group.\n    \"\"\"\n    paren_groups = split(paren_string, \" \")\n   \
    \ max_depth = zeros(Int64, length(paren_groups))\n    for i in 1:length(paren_groups)\n\
    \        max_depth[i] = count_parens(paren_groups[i])\n    end\n    return max_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpzw6q1rji.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpzw6q1rji.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpzw6q1rji.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzw6q1rji.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzw6q1rji.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpzw6q1rji.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpzw6q1rji.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzw6q1rji.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzw6q1rji.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpzw6q1rji.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpzw6q1rji.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzw6q1rji.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzw6q1rji.jl:22\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748308
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of integers representing the deepest level of nesting of parentheses.\n\
    \    \"\"\"\n    paren_list = split(paren_string, \" \")\n    paren_list = [replace(x,\
    \ \" \", \"\") for x in paren_list]\n    paren_list = [replace(x, \")\", \"\"\
    ) for x in paren_list]\n    paren_list = [replace(x, \"(\", \"\") for x in paren_list]\n\
    \    paren_list = [replace(x, \"\", \"\") for x in paren_list]\n    paren_list\
    \ = [length(x) for x in paren_list]\n    return paren_list\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpent037cu.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpent037cu.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::SubString{String}, ::String, ::String)\n  Closest\
    \ candidates are:\n    replace(!Matched::Union{Function, Type}, ::Any; count)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n    replace(::AbstractString,\
    \ !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    replace(::Any, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:569\n\
    \  Stacktrace:\n   [1] (::var\"#1#6\")(x::SubString{String})\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect\n     @ ./array.jl:724\
    \ [inlined]\n   [4] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmpent037cu.jl:12\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpent037cu.jl:24 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpent037cu.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpent037cu.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::SubString{String}, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    replace(::Any, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:569\n\
    \  Stacktrace:\n   [1] (::var\"#1#6\")(x::SubString{String})\n     @ Main ./none:0\n\
    \   [2] iterate\n     @ ./generator.jl:47 [inlined]\n   [3] collect\n     @ ./array.jl:724\
    \ [inlined]\n   [4] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmp"
  timestamp: 1659748310
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        max_nesting_in_group = 0\n        nesting_level\
    \ = 0\n        for char in group\n            if char == '('\n               \
    \ nesting_level += 1\n            elseif char == ')'\n                nesting_level\
    \ -= 1\n            end\n            if nesting_level > max_nesting_in_group\n\
    \                max_nesting_in_group = nesting_level\n            end\n     \
    \   end\n        push!(max_nesting, max_nesting_in_group)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748306
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of integers representing the deepest level of nesting for\
    \ each group of parentheses.\n    \"\"\"\n    # Initialize a vector to store the\
    \ deepest level of nesting for each group of parentheses.\n    deepest_level =\
    \ Vector{Int64}()\n    # Split the string into groups of parentheses.\n    paren_groups\
    \ = split(paren_string, \" \")\n    # Loop through each group of parentheses.\n\
    \    for paren_group in paren_groups\n        # Initialize a counter to store\
    \ the current level of nesting.\n        level = 0\n        # Initialize a counter\
    \ to store the deepest level of nesting.\n        deepest = 0\n        # Loop\
    \ through each character in the group of parentheses.\n        for char in paren_group\n\
    \            # If the character is an opening parenthesis, increment the level\
    \ counter.\n            if char == '('\n                level += 1\n         \
    \   # If the character is a closing parenthesis, decrement the level counter.\n\
    \            elseif char == ')'\n                level -= 1\n            end\n\
    \            # If the level counter is greater than the deepest counter, update\
    \ the deepest counter.\n            if level > deepest\n                deepest\
    \ = level\n            end\n        end\n        # Append the deepest level of\
    \ nesting for the current group of parentheses to the output vector.\n       \
    \ push!(deepest_level, deepest)\n    end\n    # Return the output vector.\n  \
    \  return deepest_level\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748306
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    # Initialize a vector\
    \ to store the maximum nesting level for each group\n    max_nesting_level = Vector{Int64}()\n\
    \    # Initialize a variable to store the current nesting level\n    current_nesting_level\
    \ = 0\n    # Initialize a variable to store the maximum nesting level for the\
    \ current group\n    max_nesting_level_current_group = 0\n    # Iterate over each\
    \ character in the string\n    for char in paren_string\n        # If the character\
    \ is an opening parenthesis, increment the current nesting level\n        if char\
    \ == '('\n            current_nesting_level += 1\n        # If the character is\
    \ a closing parenthesis, decrement the current nesting level\n        elseif char\
    \ == ')'\n            current_nesting_level -= 1\n        # If the character is\
    \ a space, push the current maximum nesting level for the group to the vector\n\
    \        elseif char == ' '\n            push!(max_nesting_level, max_nesting_level_current_group)\n\
    \            # Reset the maximum nesting level for the current group\n       \
    \     max_nesting_level_current_group = 0\n        end\n        # Update the maximum\
    \ nesting level for the current group\n        max_nesting_level_current_group\
    \ = max(max_nesting_level_current_group, current_nesting_level)\n    end\n   \
    \ # Push the maximum nesting level for the last group to the vector\n    push!(max_nesting_level,\
    \ max_nesting_level_current_group)\n    # Return the vector\n    return max_nesting_level\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748306
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces\n\
    \    Output: Vector of integers representing the deepest level of nesting of parentheses\
    \ for each group\n    \"\"\"\n    paren_string = split(paren_string, \" \")\n\
    \    paren_string = [x for x in paren_string if x != \"\"]\n    result = []\n\
    \    for paren in paren_string\n        max_level = 0\n        level = 0\n   \
    \     for c in paren\n            if c == '('\n                level += 1\n  \
    \          elseif c == ')'\n                level -= 1\n            end\n    \
    \        if level > max_level\n                max_level = level\n           \
    \ end\n        end\n        push!(result, max_level)\n    end\n    return result\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748307
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    # Initialize the vector to store the depth of\
    \ nesting for each group\n    depth_vector = Vector{Int64}(undef, length(split(paren_string,\
    \ \" \")))\n    # Iterate over each group\n    for (i, group) in enumerate(split(paren_string,\
    \ \" \"))\n        # Initialize the depth to 0\n        depth = 0\n        # Initialize\
    \ the maximum depth to 0\n        max_depth = 0\n        # Iterate over each character\
    \ in the group\n        for char in group\n            # If the character is an\
    \ opening parenthesis, increment the depth\n            if char == '('\n     \
    \           depth += 1\n            # If the character is a closing parenthesis,\
    \ decrement the depth\n            elseif char == ')'\n                depth -=\
    \ 1\n            end\n            # Update the maximum depth if the current depth\
    \ is greater than the maximum depth\n            if depth > max_depth\n      \
    \          max_depth = depth\n            end\n        end\n        # Store the\
    \ maximum depth for the current group\n        depth_vector[i] = max_depth\n \
    \   end\n    # Return the vector of maximum depths\n    return depth_vector\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748306
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input:\n        paren_string: String representing multiple\
    \ groups of nested parentheses separated by spaces.\n    Output:\n        Vector\
    \ of integers representing the deepest level of nesting of parentheses for each\
    \ group.\n    \"\"\"\n    # Initialize a vector to store the deepest level of\
    \ nesting of parentheses for each group.\n    deepest_level = Vector{Int64}()\n\
    \    # Split the string into groups of nested parentheses.\n    paren_groups =\
    \ split(paren_string, \" \")\n    # For each group of nested parentheses, calculate\
    \ the deepest level of nesting.\n    for paren_group in paren_groups\n       \
    \ # Initialize a counter to keep track of the current level of nesting.\n    \
    \    current_level = 0\n        # Initialize a counter to keep track of the deepest\
    \ level of nesting.\n        deepest_level_counter = 0\n        # Iterate through\
    \ each character in the group of nested parentheses.\n        for char in paren_group\n\
    \            # If the character is an opening parenthesis, increment the current\
    \ level of nesting.\n            if char == '('\n                current_level\
    \ += 1\n            # If the character is a closing parenthesis, decrement the\
    \ current level of nesting.\n            elseif char == ')'\n                current_level\
    \ -= 1\n            end\n            # If the current level of nesting is greater\
    \ than the deepest level of nesting,\n            # update the deepest level of\
    \ nesting.\n            if current_level > deepest_level_counter\n           \
    \     deepest_level_counter = current_level\n            end\n        end\n  \
    \      # Append the deepest level of nesting to the vector.\n        push!(deepest_level,\
    \ deepest_level_counter)\n    end\n    # Return the vector of integers representing\
    \ the deepest level of nesting of parentheses for each group.\n    return deepest_level\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748306
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: paren_string: String\n    Output: Vector{Int64}\n \
    \   \"\"\"\n    paren_string = split(paren_string, \" \")\n    max_levels = []\n\
    \    for paren_group in paren_string\n        max_level = 0\n        level = 0\n\
    \        for paren in paren_group\n            if paren == '('\n             \
    \   level += 1\n            elseif paren == ')'\n                level -= 1\n\
    \            end\n            if level > max_level\n                max_level\
    \ = level\n            end\n        end\n        push!(max_levels, max_level)\n\
    \    end\n    return max_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748307
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of integers representing the deepest level of nesting for\
    \ each group of parentheses.\n    \"\"\"\n    # Initialize a vector of integers\
    \ to store the deepest level of nesting for each group of parentheses.\n    deepest_level\
    \ = Vector{Int64}()\n    # Initialize a counter to keep track of the deepest level\
    \ of nesting for each group of parentheses.\n    counter = 0\n    # Initialize\
    \ a variable to keep track of the current level of nesting.\n    current_level\
    \ = 0\n    # Iterate through the string.\n    for i in 1:length(paren_string)\n\
    \        # If the character is an opening parenthesis, increment the current level\
    \ of nesting.\n        if paren_string[i] == '('\n            current_level +=\
    \ 1\n        # If the character is a closing parenthesis, decrement the current\
    \ level of nesting.\n        elseif paren_string[i] == ')'\n            current_level\
    \ -= 1\n        # If the character is a space, check if the current level of nesting\
    \ is greater than the counter.\n        # If so, update the counter.\n       \
    \ elseif paren_string[i] == ' '\n            if current_level > counter\n    \
    \            counter = current_level\n            end\n            # Push the\
    \ counter to the vector.\n            push!(deepest_level, counter)\n        \
    \    # Reset the counter.\n            counter = 0\n        end\n    end\n   \
    \ # Return the vector.\n    return deepest_level\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpj59ehviz.jl:42

    '
  stdout: "test set: Test Failed at /tmp/tmpj59ehviz.jl:45\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj59ehviz.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj59ehviz.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpj59ehviz.jl:46\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj59ehviz.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj59ehviz.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpj59ehviz.jl:47\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpj59ehviz.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj59ehviz.jl:44\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748309
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")\", \"\")\n    paren_string = replace(paren_string, \"(\", \"\")\n    paren_string\
    \ = replace(paren_string, \" \", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \" \")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \" \")\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"\", \" \")\n    paren_string\
    \ = replace(paren_string, \" \", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \" \")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \" \")\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"\", \" \")\n    paren_string\
    \ = replace(paren_string, \" \", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \" \")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \" \")\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"\", \" \")\n    paren_string\
    \ = replace(paren_string, \" \", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \" \")\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \"\", \" \")\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"\", \" \"\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp8s551zvk.jl:38\nin expression starting at\
    \ /tmp/tmp8s551zvk.jl:38\n"
  stdout: ''
  timestamp: 1659748308
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces\n\
    \    Output: Vector of integers representing the deepest level of nesting for\
    \ each group of parentheses\n    \"\"\"\n    # Initialize empty vector to store\
    \ the deepest level of nesting for each group\n    deepest_level = Vector{Int64}()\n\
    \    \n    # Split the string into groups of parentheses\n    paren_groups = split(paren_string,\
    \ \" \")\n    \n    # Iterate through each group of parentheses\n    for paren_group\
    \ in paren_groups\n        # Initialize a counter to keep track of the current\
    \ level of nesting\n        level = 0\n        # Initialize a counter to keep\
    \ track of the deepest level of nesting\n        deepest = 0\n        \n     \
    \   # Iterate through each character in the group\n        for c in paren_group\n\
    \            # If the character is an opening parenthesis, increment the level\
    \ counter\n            if c == '('\n                level += 1\n            #\
    \ If the character is a closing parenthesis, decrement the level counter\n   \
    \         elseif c == ')'\n                level -= 1\n            end\n     \
    \       \n            # If the level counter is greater than the deepest level\
    \ counter, update the deepest level counter\n            if level > deepest\n\
    \                deepest = level\n            end\n        end\n        \n   \
    \     # Append the deepest level counter to the vector of deepest levels\n   \
    \     push!(deepest_level, deepest)\n    end\n    \n    # Return the vector of\
    \ deepest levels\n    return deepest_level\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748307
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_groups = split(paren_string, \" \")\n  \
    \  paren_levels = Vector{Int64}(length(paren_groups))\n    for i in 1:length(paren_groups)\n\
    \        paren_levels[i] = parse_parens(paren_groups[i])\n    end\n    return\
    \ paren_levels\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpb7zt2wul.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmpb7zt2wul.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpb7zt2wul.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpb7zt2wul.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpb7zt2wul.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpb7zt2wul.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpb7zt2wul.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpb7zt2wul.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpb7zt2wul.jl:20\ntest set:\
    \ Error During Test at /"
  timestamp: 1659748310
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = split(paren_string, \" \")\n  \
    \  paren_string = [replace(x, \")\", \"\") for x in paren_string]\n    paren_string\
    \ = [replace(x, \"(\", \"\") for x in paren_string]\n    paren_string = [replace(x,\
    \ \" \", \"\") for x in paren_string]\n    paren_string = [replace(x, \"\", \"\
    \") for x in paren_string]\n    paren_string = [replace(x, \"\", \"\") for x in\
    \ paren_string]\n    paren_string = [replace(x, \"\", \"\") for x in paren_string]\n\
    \    paren_string = [replace(x, \"\", \"\") for x in paren_string]\n    paren_string\
    \ = [replace(x, \"\", \"\") for x in paren_string]\n    paren_string = [replace(x,\
    \ \"\", \"\") for x in paren_string]\n    paren_string = [replace(x, \"\", \"\"\
    ) for x in paren_string]\n    paren_string = [replace(x, \"\", \"\") for x in\
    \ paren_string]\n    paren_string = [replace(x, \"\", \"\") for x in paren_string]\n\
    \    paren_string = [replace(x, \"\", \"\") for x in paren_string]\n    paren_string\
    \ = [replace(x, \"\", \"\") for x in paren_string]\n    paren_string = [replace(x,\
    \ \"\", \"\") for x in paren_string]\n    paren_string = [replace(x, \"\", \"\"\
    ) for x in paren_string]\n    paren_string = [replace(x, \"\", \"\") for x in\
    \ paren_string]\n    paren_string = [replace(x, \"\", \"\") for x in paren_string]\n\
    \    paren_string = [replace(x, \"\", \"\") for x in paren_string]\n    paren_string\
    \ = [replace(x, \"\", \"\") for x in paren_string]\n    paren_string = [replace(\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpzh28ouhr.jl:33\nin expression starting at\
    \ /tmp/tmpzh28ouhr.jl:33\n"
  stdout: ''
  timestamp: 1659748308
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n        \"\"\"\n    # Split the string into groups\n    groups\
    \ = split(paren_string, \" \")\n    # Initialize a vector to store the output\n\
    \    output = Vector{Int64}(undef, length(groups))\n    for (i, group) in enumerate(groups)\n\
    \        # Initialize a counter\n        counter = 0\n        # Initialize a maximum\
    \ counter\n        max_counter = 0\n        # Iterate through the group\n    \
    \    for paren in group\n            # If the paren is an opening paren, increment\
    \ the counter\n            if paren == '('\n                counter += 1\n   \
    \         # If the paren is a closing paren, decrement the counter\n         \
    \   elseif paren == ')'\n                counter -= 1\n            end\n     \
    \       # Update the maximum counter\n            max_counter = max(max_counter,\
    \ counter)\n        end\n        # Store the maximum counter in the output vector\n\
    \        output[i] = max_counter\n    end\n    return output\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748307
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input:\n        paren_string: String of multiple groups of\
    \ nested parentheses separated by spaces.\n    Output:\n        Vector of Int64s\
    \ representing the deepest level of nesting of parentheses for each group.\n \
    \   \"\"\"\n    # Split the string into groups of nested parentheses\n    paren_groups\
    \ = split(paren_string, \" \")\n    # Initialize a vector to store the deepest\
    \ level of nesting of parentheses for each group\n    max_nesting_levels = zeros(Int64,\
    \ length(paren_groups))\n    # For each group, find the deepest level of nesting\
    \ of parentheses\n    for i in 1:length(paren_groups)\n        # Initialize a\
    \ counter to keep track of the current level of nesting\n        nesting_level\
    \ = 0\n        # Initialize a variable to keep track of the maximum level of nesting\n\
    \        max_nesting_level = 0\n        # For each character in the group, check\
    \ if it is a left or right parenthesis\n        for j in 1:length(paren_groups[i])\n\
    \            # If it is a left parenthesis, increment the nesting level\n    \
    \        if paren_groups[i][j] == '('\n                nesting_level += 1\n  \
    \          # If it is a right parenthesis, decrement the nesting level\n     \
    \       elseif paren_groups[i][j] == ')'\n                nesting_level -= 1\n\
    \            end\n            # If the current nesting level is greater than the\
    \ maximum nesting level, update the maximum nesting level\n            if nesting_level\
    \ > max_nesting_level\n                max_nesting_level = nesting_level\n   \
    \         end\n        end\n        # Store the maximum nesting level for the\
    \ current group in the vector\n        max_nesting_levels[i] = max_nesting_level\n\
    \    end\n    # Return the vector of maximum nesting levels\n    return max_nesting_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748307
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n        Input: String of nested parentheses separated by spaces.\n\
    \        Output: Vector of integers representing the maximum level of nesting\
    \ for each of the groups.\n        \"\"\"\n    paren_string = split(paren_string,\
    \ \" \")\n    max_nesting = zeros(Int64, length(paren_string))\n    for i in 1:length(paren_string)\n\
    \        paren_group = paren_string[i]\n        paren_count = 0\n        for j\
    \ in 1:length(paren_group)\n            if paren_group[j] == '('\n           \
    \     paren_count += 1\n            elseif paren_group[j] == ')'\n           \
    \     paren_count -= 1\n            end\n            if paren_count > max_nesting[i]\n\
    \                max_nesting[i] = paren_count\n            end\n        end\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748307
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces\n\
    \    Output: Vector of integers representing the depth of nesting for each group\
    \ of parentheses\n    \"\"\"\n    # Initialize empty vector to store the depth\
    \ of nesting for each group\n    depth_vector = Int64[]\n    # Split the string\
    \ into groups of parentheses\n    paren_groups = split(paren_string, \" \")\n\
    \    # Iterate through each group\n    for paren_group in paren_groups\n     \
    \   # Initialize depth counter\n        depth = 0\n        # Initialize max depth\n\
    \        max_depth = 0\n        # Iterate through each character in the group\n\
    \        for char in paren_group\n            # If the character is an open parenthesis,\
    \ increment the depth counter\n            if char == '('\n                depth\
    \ += 1\n            # If the character is a closed parenthesis, decrement the\
    \ depth counter\n            elseif char == ')'\n                depth -= 1\n\
    \            end\n            # If the current depth is greater than the max depth,\
    \ update the max depth\n            if depth > max_depth\n                max_depth\
    \ = depth\n            end\n        end\n        # Push the max depth for the\
    \ current group to the depth vector\n        push!(depth_vector, max_depth)\n\
    \    end\n    # Return the depth vector\n    return depth_vector\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748307
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        max_nesting_level = 0\n        current_nesting_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         current_nesting_level += 1\n            elseif paren == ')'\n      \
    \          current_nesting_level -= 1\n            end\n            if current_nesting_level\
    \ > max_nesting_level\n                max_nesting_level = current_nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748306
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    paren_levels = zeros(Int64, length(paren_groups))\n    for i in\
    \ 1:length(paren_groups)\n        paren_levels[i] = parse_nested_parens_single(paren_groups[i])\n\
    \    end\n    return paren_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmph129ukos.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmph129ukos.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_single not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmph129ukos.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph129ukos.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph129ukos.jl:23\ntest set:\
    \ Error During Test at /tmp/tmph129ukos.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_single\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmph129ukos.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph129ukos.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph129ukos.jl:23\ntest set:\
    \ Error During Test at /tmp/tmph129ukos.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_single\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmph129ukos.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph129ukos.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph129ukos.jl:23\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748310
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"((\", \"(\")\n    paren_string = replace(paren_string, \"))\", \")\")\n  \
    \  paren_string = replace(paren_string, \"(((\", \"(\")\n    paren_string = replace(paren_string,\
    \ \")))\", \")\")\n    paren_string = replace(paren_string, \"((((\", \"(\")\n\
    \    paren_string = replace(paren_string, \"))))\", \")\")\n    paren_string =\
    \ replace(paren_string, \"(((((\", \"(\")\n    paren_string = replace(paren_string,\
    \ \")))))\", \")\")\n    paren_string = replace(paren_string, \"((((((\", \"(\"\
    )\n    paren_string = replace(paren_string, \"))))))\", \")\")\n    paren_string\
    \ = replace(paren_string, \"(((((((\", \"(\")\n    paren_string = replace(paren_string,\
    \ \")))))))\", \")\")\n    paren_string = replace(paren_string, \"((((((((\",\
    \ \"(\")\n    paren_string = replace(paren_string, \"))))))))\", \")\")\n    paren_string\
    \ = replace(paren_string, \"(((((((((\", \"(\")\n    paren_string = replace(paren_string,\
    \ \")))))))))\", \")\")\n    paren_string = replace(paren_string, \"((((((((((\"\
    , \"(\")\n    paren_string = replace(paren_string, \"))))))))))\", \")\")\n  \
    \  paren_string = replace(paren_string, \"(((((((((((\", \"(\")\n    paren_string\
    \ = replace(paren_string, \")))))))))))\", \")\")\n    paren_string = replace(paren_string,\
    \ \"((((((((((((\", \"(\")\n    paren_string = replace(paren_string, \"))))))))))))\"\
    , \")\")\n    paren\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmetbczj8.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmetbczj8.jl:1\n\
    in expression starting at /tmp/tmpmetbczj8.jl:1\n"
  stdout: ''
  timestamp: 1659748308
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    max_nesting = zeros(Int64, length(paren_groups))\n    for i in 1:length(paren_groups)\n\
    \        paren_group = paren_groups[i]\n        nesting = 0\n        max_nesting_in_group\
    \ = 0\n        for j in 1:length(paren_group)\n            if paren_group[j] ==\
    \ '('\n                nesting += 1\n            elseif paren_group[j] == ')'\n\
    \                nesting -= 1\n            end\n            if nesting > max_nesting_in_group\n\
    \                max_nesting_in_group = nesting\n            end\n        end\n\
    \        max_nesting[i] = max_nesting_in_group\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748307
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")\", \"\")\n    paren_string\
    \ = replace(paren_string, \"(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"\", \" \")\n    paren_string = replace(paren_string, \" \", \",\")\n    paren_string\
    \ = replace(paren_string, \",\", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(paren_string, \"  \", \" \")\n  \
    \  paren_string = replace(paren_string, \"  \", \" \")\n    paren_string = replace(paren_string,\
    \ \"  \", \" \")\n    paren_string = replace(\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpim_tpnd2.jl:37\nin expression starting at\
    \ /tmp/tmpim_tpnd2.jl:37\n"
  stdout: ''
  timestamp: 1659748308
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    max_nesting = Vector{Int64}(undef, length(paren_groups))\n    for\
    \ (i, paren_group) in enumerate(paren_groups)\n        max_nesting[i] = parse_nested_parens_helper(paren_group)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpexvosqk8.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpexvosqk8.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_nested_parens_helper not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpexvosqk8.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpexvosqk8.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpexvosqk8.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpexvosqk8.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpexvosqk8.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpexvosqk8.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpexvosqk8.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpexvosqk8.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_nested_parens_helper\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpexvosqk8.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpexvosqk8.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpexvosqk8.jl:23\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748310
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of integers representing the maximum nesting level of each\
    \ group.\n    \"\"\"\n    paren_groups = split(paren_string, \" \")\n    max_nesting\
    \ = zeros(Int64, length(paren_groups))\n    for i = 1:length(paren_groups)\n \
    \       max_nesting[i] = count_nesting(paren_groups[i])\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpbv2owt5w.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpbv2owt5w.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ count_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpbv2owt5w.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbv2owt5w.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbv2owt5w.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpbv2owt5w.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: count_nesting\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpbv2owt5w.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbv2owt5w.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbv2owt5w.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpbv2owt5w.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: count_nesting not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpbv2owt5w.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbv2owt5w.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbv2owt5w.jl:22\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748310
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: string of nested parentheses separated by spaces\n\
    \    Output: Vector of integers representing the deepest level of nesting for\
    \ each group of parentheses\n    \"\"\"\n    # Initialize a vector to store the\
    \ depth of each group of parentheses\n    depth_vector = Int64[]\n    # Initialize\
    \ a counter to keep track of the depth of the current group of parentheses\n \
    \   depth_counter = 0\n    # Initialize a variable to keep track of whether we\
    \ are currently inside a group of parentheses\n    inside_parens = false\n   \
    \ # Loop through each character in the string\n    for char in paren_string\n\
    \        # If we are currently inside a group of parentheses\n        if inside_parens\n\
    \            # If the character is an opening parenthesis, increment the depth\
    \ counter\n            if char == '('\n                depth_counter += 1\n  \
    \          # If the character is a closing parenthesis, decrement the depth counter\n\
    \            elseif char == ')'\n                depth_counter -= 1\n        \
    \    # If the depth counter is zero, we have reached the end of a group of parentheses\n\
    \            if depth_counter == 0\n                # Push the current depth counter\
    \ value to the depth vector\n                push!(depth_vector, depth_counter)\n\
    \                # Reset the depth counter\n                depth_counter = 0\n\
    \                # Set the inside_parens variable to false\n                inside_parens\
    \ = false\n            end\n        # If we are not currently inside a group of\
    \ parentheses\n        else\n            # If the character is an opening parenthesis,\
    \ set the inside_parens variable to true\n            if char == '('\n       \
    \         inside_parens = true\n            end\n        end\n    end\n    # Return\
    \ the depth vector\n    return depth_vector\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpnzx7qb69.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpnzx7qb69.jl:1\n\
    in expression starting at /tmp/tmpnzx7qb69.jl:1\n"
  stdout: ''
  timestamp: 1659748309
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_list = split(paren_string, \" \")\n    paren_levels = zeros(Int64,\
    \ length(paren_list))\n    for i in 1:length(paren_list)\n        paren_levels[i]\
    \ = parse_parens(paren_list[i])\n    end\n    return paren_levels\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpan_4cgw6.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmpan_4cgw6.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpan_4cgw6.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpan_4cgw6.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpan_4cgw6.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpan_4cgw6.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpan_4cgw6.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpan_4cgw6.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpan_4cgw6.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpan_4cgw6.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpan_4cgw6.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpan_4cgw6.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpan_4cgw6.jl:18\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748310
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_group\
    \ = paren_groups[i]\n        max_nesting[i] = get_max_nesting(paren_group)\n \
    \   end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp7f7n80nl.jl:17

    '
  stdout: "test set: Error During Test at /tmp/tmp7f7n80nl.jl:20\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_max_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp7f7n80nl.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7f7n80nl.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7f7n80nl.jl:19\ntest set:\
    \ Error During Test at /tmp/tmp7f7n80nl.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_max_nesting\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp7f7n80nl.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7f7n80nl.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7f7n80nl.jl:19\ntest set:\
    \ Error During Test at /tmp/tmp7f7n80nl.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: get_max_nesting not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmp7f7n80nl.jl:11\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7f7n80nl.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7f7n80nl.jl:19\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748310
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        max_nesting_level = 0\n        nesting_level\
    \ = 0\n        for paren in group\n            if paren == '('\n             \
    \   nesting_level += 1\n            elseif paren == ')'\n                nesting_level\
    \ -= 1\n            end\n            if nesting_level > max_nesting_level\n  \
    \              max_nesting_level = nesting_level\n            end\n        end\n\
    \        push!(max_nesting, max_nesting_level)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748308
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input:\n        paren_string: String representing multiple\
    \ groups of nested parentheses separated by spaces.\n    Output:\n        Vector\
    \ of integers representing the deepest level of nesting of parentheses for each\
    \ group.\n    \"\"\"\n    paren_groups = split(paren_string, \" \")\n    max_nesting\
    \ = []\n    for paren_group in paren_groups\n        max_nesting_group = 0\n \
    \       nesting_level = 0\n        for paren in paren_group\n            if paren\
    \ == '('\n                nesting_level += 1\n            elseif paren == ')'\n\
    \                nesting_level -= 1\n            end\n            if nesting_level\
    \ > max_nesting_group\n                max_nesting_group = nesting_level\n   \
    \         end\n        end\n        push!(max_nesting, max_nesting_group)\n  \
    \  end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748308
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    paren_string: string of nested parentheses separated by spaces.\n\
    \    \"\"\"\n    paren_list = split(paren_string, \" \")\n    max_depth = 0\n\
    \    max_depth_list = []\n    for paren in paren_list\n        depth = 0\n   \
    \     for c in paren\n            if c == '('\n                depth += 1\n  \
    \          elseif c == ')'\n                depth -= 1\n            end\n    \
    \    end\n        push!(max_depth_list, depth)\n    end\n    return max_depth_list\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbkzq9x6o.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpbkzq9x6o.jl:31\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbkzq9x6o.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbkzq9x6o.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpbkzq9x6o.jl:32\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbkzq9x6o.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbkzq9x6o.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpbkzq9x6o.jl:33\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbkzq9x6o.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbkzq9x6o.jl:30\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748310
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = split(paren_string, \" \")\n  \
    \  max_level = Vector{Int64}(undef, length(paren_string))\n    for (i, paren)\
    \ in enumerate(paren_string)\n        level = 0\n        max_level[i] = 0\n  \
    \      for c in paren\n            if c == '('\n                level += 1\n \
    \           elseif c == ')'\n                level -= 1\n            end\n   \
    \         if level > max_level[i]\n                max_level[i] = level\n    \
    \        end\n        end\n    end\n    return max_level\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748308
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of integers representing the deepest level of nesting of parentheses\
    \ for each group.\n    \"\"\"\n    # Initialize a vector to store the deepest\
    \ level of nesting of parentheses for each group.\n    deepest_nesting = Vector{Int64}()\n\
    \    # Split the string into groups of nested parentheses.\n    paren_groups =\
    \ split(paren_string, \" \")\n    # For each group of nested parentheses, find\
    \ the deepest level of nesting.\n    for paren_group in paren_groups\n       \
    \ # Initialize a counter to keep track of the deepest level of nesting.\n    \
    \    deepest_level = 0\n        # Initialize a counter to keep track of the current\
    \ level of nesting.\n        current_level = 0\n        # Iterate through each\
    \ character in the group of nested parentheses.\n        for char in paren_group\n\
    \            # If the character is an opening parenthesis, increment the current\
    \ level of nesting.\n            if char == '('\n                current_level\
    \ += 1\n            # If the character is a closing parenthesis, decrement the\
    \ current level of nesting.\n            elseif char == ')'\n                current_level\
    \ -= 1\n            end\n            # If the current level of nesting is greater\
    \ than the deepest level of nesting, update the deepest level of nesting.\n  \
    \          if current_level > deepest_level\n                deepest_level = current_level\n\
    \            end\n        end\n        # Append the deepest level of nesting to\
    \ the vector.\n        push!(deepest_nesting, deepest_level)\n    end\n    # Return\
    \ the vector of deepest levels of nesting.\n    return deepest_nesting\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748308
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # split the string into groups\n    groups = split(paren_string, \" \"\
    )\n    # initialize the output vector\n    output = Vector{Int64}(length(groups))\n\
    \    # loop over the groups\n    for i in 1:length(groups)\n        # initialize\
    \ the counter\n        counter = 0\n        # initialize the maximum counter\n\
    \        max_counter = 0\n        # loop over the characters in the group\n  \
    \      for c in groups[i]\n            # if the character is \"(\" increment the\
    \ counter\n            if c == \"(\"\n                counter += 1\n         \
    \   # if the character is \")\" decrement the counter\n            elseif c ==\
    \ \")\"\n                counter -= 1\n            end\n            # update the\
    \ maximum counter\n            max_counter = max(max_counter, counter)\n     \
    \   end\n        # store the maximum counter in the output vector\n        output[i]\
    \ = max_counter\n    end\n    # return the output vector\n    return output\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpe5v123fg.jl:37

    '
  stdout: "test set: Error During Test at /tmp/tmpe5v123fg.jl:40\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpe5v123fg.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpe5v123fg.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpe5v123fg.jl:39\ntest set:\
    \ Error During Test at /tmp/tmpe5v123fg.jl:41\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpe5v123fg.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpe5v123fg.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpe5v123fg.jl:39\ntest set:\
    \ Error During Test at /"
  timestamp: 1659748312
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    levels = Vector{Int64}()\n    level = 0\n    for c in paren_string\n \
    \       if c == '('\n            level += 1\n        elseif c == ')'\n       \
    \     push!(levels, level)\n            level -= 1\n        elseif c == ' '\n\
    \            continue\n        end\n    end\n    return levels\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmplopgpf81.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmplopgpf81.jl:26\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [2, 2, 1, 3, 2,\
    \ 1, 1, 3, 2, 2, 2, 1] == [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmplopgpf81.jl:26 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplopgpf81.jl:25\ntest set: Test\
    \ Failed at /tmp/tmplopgpf81.jl:27\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [1, 2, 1, 3, 2, 1, 4, 3, 2, 1] == [1, 2, 3, 4]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplopgpf81.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplopgpf81.jl:25\ntest set: Test\
    \ Failed at /tmp/tmplopgpf81.jl:28\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [2, 3, 2, 4, 3, 2, 1] == [4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplopgpf81.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplopgpf81.jl:25\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748311
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n  \
    \  paren_string = split(paren_string, \" \")\n    paren_string = [replace(x, \"\
    )\", \"\") for x in paren_string]\n    paren_string = [replace(x, \"(\", \"\"\
    ) for x in paren_string]\n    paren_string = [length(x) for x in paren_string]\n\
    \    return paren_string\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp_d9t6xhe.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmp_d9t6xhe.jl:25\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp_d9t6xhe.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_d9t6xhe.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_d9t6xhe.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp_d9t6xhe.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp_d9t6xhe.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_d9t6xhe.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.j"
  timestamp: 1659748312
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    paren_levels = []\n    for group in paren_groups\n        paren_levels\
    \ = append!(paren_levels, parse_parens(group))\n    end\n    return paren_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmphduy6jm5.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmphduy6jm5.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmphduy6jm5.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphduy6jm5.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphduy6jm5.jl:23\ntest set:\
    \ Error During Test at /tmp/tmphduy6jm5.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmphduy6jm5.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphduy6jm5.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphduy6jm5.jl:23\ntest set:\
    \ Error During Test at /tmp/tmphduy6jm5.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmphduy6jm5.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphduy6jm5.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphduy6jm5.jl:23\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748304
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        max_nesting_group = 0\n        current_nesting\
    \ = 0\n        for paren in group\n            if paren == '('\n             \
    \   current_nesting += 1\n            elseif paren == ')'\n                current_nesting\
    \ -= 1\n            end\n            if current_nesting > max_nesting_group\n\
    \                max_nesting_group = current_nesting\n            end\n      \
    \  end\n        push!(max_nesting, max_nesting_group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748309
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    paren_levels = []\n    for group in paren_groups\n        paren_levels\
    \ = push!(paren_levels, parse_parens(group))\n    end\n    return paren_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmplj273e7_.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmplj273e7_.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmplj273e7_.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplj273e7_.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplj273e7_.jl:23\ntest set:\
    \ Error During Test at /tmp/tmplj273e7_.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmplj273e7_.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplj273e7_.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplj273e7_.jl:23\ntest set:\
    \ Error During Test at /tmp/tmplj273e7_.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmplj273e7_.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplj273e7_.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplj273e7_.jl:23\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748311
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of integers representing the deepest level of nesting of parentheses\
    \ for each group.\n    \"\"\"\n    # Initialize a vector to store the deepest\
    \ level of nesting for each group.\n    deepest_level = Vector{Int64}()\n    #\
    \ Split the string into groups of parentheses.\n    paren_groups = split(paren_string,\
    \ \" \")\n    # For each group, find the deepest level of nesting.\n    for group\
    \ in paren_groups\n        # Initialize a counter to keep track of the deepest\
    \ level of nesting.\n        level = 0\n        # Initialize a counter to keep\
    \ track of the current level of nesting.\n        curr_level = 0\n        # Iterate\
    \ through the group.\n        for paren in group\n            # If the current\
    \ character is an opening parenthesis, increment the current level of nesting.\n\
    \            if paren == '('\n                curr_level += 1\n            # If\
    \ the current character is a closing parenthesis, decrement the current level\
    \ of nesting.\n            elseif paren == ')'\n                curr_level -=\
    \ 1\n            end\n            # If the current level of nesting is greater\
    \ than the deepest level, update the deepest level.\n            if curr_level\
    \ > level\n                level = curr_level\n            end\n        end\n\
    \        # Push the deepest level of nesting for the current group to the vector.\n\
    \        push!(deepest_level, level)\n    end\n    # Return the vector of deepest\
    \ levels of nesting.\n    return deepest_level\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748309
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vec\
    \ = Vector{Int64}()\n    # Split the string by spaces\n    paren_groups = split(paren_string,\
    \ \" \")\n    # Iterate over each group\n    for paren_group in paren_groups\n\
    \        # Initialize a counter to track the depth\n        depth = 0\n      \
    \  # Initialize a counter to track the max depth\n        max_depth = 0\n    \
    \    # Iterate over each character in the group\n        for paren in paren_group\n\
    \            # If the character is an open paren, increment the depth\n      \
    \      if paren == '('\n                depth += 1\n            # If the character\
    \ is a close paren, decrement the depth\n            elseif paren == ')'\n   \
    \             depth -= 1\n            end\n            # If the depth is greater\
    \ than the max depth, update the max depth\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        end\n        # Push\
    \ the max depth to the vector\n        push!(depth_vec, max_depth)\n    end\n\
    \    # Return the vector\n    return depth_vec\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748309
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    max_nesting = zeros(Int64, length(paren_groups))\n    for i = 1:length(paren_groups)\n\
    \        paren_group = paren_groups[i]\n        max_nesting[i] = get_max_nesting(paren_group)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt8g_lg8b.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmpt8g_lg8b.jl:25\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_max_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpt8g_lg8b.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt8g_lg8b.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt8g_lg8b.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpt8g_lg8b.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_max_nesting\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpt8g_lg8b.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt8g_lg8b.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt8g_lg8b.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpt8g_lg8b.jl:27\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: get_max_nesting not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpt8g_lg8b.jl:16\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpt8g_lg8b.jl:27 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpt8g_lg8b.jl:24\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748311
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_groups = split(paren_string, \" \")\n  \
    \  max_nesting = []\n    for group in paren_groups\n        nesting = 0\n    \
    \    max_nesting_in_group = 0\n        for paren in group\n            if paren\
    \ == '('\n                nesting += 1\n            elseif paren == ')'\n    \
    \            nesting -= 1\n            end\n            if nesting > max_nesting_in_group\n\
    \                max_nesting_in_group = nesting\n            end\n        end\n\
    \        push!(max_nesting, max_nesting_in_group)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748309
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_groups = split(paren_string,\
    \ \" \")\n    max_nesting = []\n    for paren_group in paren_groups\n        max_nesting_level\
    \ = 0\n        nesting_level = 0\n        for paren in paren_group\n         \
    \   if paren == '('\n                nesting_level += 1\n            elseif paren\
    \ == ')'\n                nesting_level -= 1\n            end\n            if\
    \ nesting_level > max_nesting_level\n                max_nesting_level = nesting_level\n\
    \            end\n        end\n        push!(max_nesting, max_nesting_level)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748301
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vector\
    \ = Vector{Int64}(undef, length(split(paren_string, \" \")))\n    # Loop through\
    \ each group\n    for (i, group) in enumerate(split(paren_string, \" \"))\n  \
    \      # Initialize a counter to keep track of the depth of the current group\n\
    \        depth = 0\n        # Loop through each character in the group\n     \
    \   for char in group\n            # If the character is an opening parenthesis,\
    \ increment the depth\n            if char == '('\n                depth += 1\n\
    \            # If the character is a closing parenthesis, decrement the depth\n\
    \            elseif char == ')'\n                depth -= 1\n            end\n\
    \        end\n        # Store the depth of the current group in the depth vector\n\
    \        depth_vector[i] = depth\n    end\n    # Return the depth vector\n   \
    \ return depth_vector\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp_012460s.jl:31

    '
  stdout: "test set: Test Failed at /tmp/tmp_012460s.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_012460s.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_012460s.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp_012460s.jl:35\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_012460s.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_012460s.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp_012460s.jl:36\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_012460s.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_012460s.jl:33\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748311
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces\n\
    \    Output: Vector of maximum nesting levels for each group of parentheses\n\
    \    \"\"\"\n    # Initialize output vector\n    max_nesting_levels = Int64[]\n\
    \    \n    # Split the string into groups of parentheses\n    paren_groups = split(paren_string,\
    \ \" \")\n    \n    # Loop through each group of parentheses\n    for paren_group\
    \ in paren_groups\n        # Initialize counter for nesting levels\n        nesting_level\
    \ = 0\n        # Initialize counter for maximum nesting levels\n        max_nesting_level\
    \ = 0\n        \n        # Loop through each character in the group of parentheses\n\
    \        for char in paren_group\n            # If the character is an opening\
    \ parenthesis, increment the nesting level\n            if char == '('\n     \
    \           nesting_level += 1\n            # If the character is a closing parenthesis,\
    \ decrement the nesting level\n            elseif char == ')'\n              \
    \  nesting_level -= 1\n            end\n            \n            # If the nesting\
    \ level is greater than the maximum nesting level, update the maximum nesting\
    \ level\n            if nesting_level > max_nesting_level\n                max_nesting_level\
    \ = nesting_level\n            end\n        end\n        \n        # Append the\
    \ maximum nesting level to the output vector\n        push!(max_nesting_levels,\
    \ max_nesting_level)\n    end\n    \n    # Return the output vector\n    return\
    \ max_nesting_levels\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748309
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_array = split(paren_string, \" \")\n    paren_array = filter(x ->\
    \ length(x) > 0, paren_array)\n    max_nesting = zeros(Int64, length(paren_array))\n\
    \    for i in 1:length(paren_array)\n        paren_string = paren_array[i]\n \
    \       paren_stack = []\n        max_nesting[i] = 0\n        for j in 1:length(paren_string)\n\
    \            if paren_string[j] == '('\n                push!(paren_stack, j)\n\
    \            elseif paren_string[j] == ')'\n                if length(paren_stack)\
    \ > 0\n                    pop!(paren_stack)\n                else\n         \
    \           break\n                end\n            end\n            max_nesting[i]\
    \ = max(max_nesting[i], length(paren_stack))\n        end\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748309
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # initialize the output vector\n    output = Vector{Int64}()\n    # split\
    \ the string by spaces\n    paren_groups = split(paren_string, \" \")\n    # for\
    \ each group, count the number of open parentheses\n    for group in paren_groups\n\
    \        open_count = 0\n        max_open = 0\n        for char in group\n   \
    \         if char == '('\n                open_count += 1\n                if\
    \ open_count > max_open\n                    max_open = open_count\n         \
    \       end\n            elseif char == ')'\n                open_count -= 1\n\
    \            end\n        end\n        push!(output, max_open)\n    end\n    return\
    \ output\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748309
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")\", \"\")\n    paren_string = replace(paren_string, \"(\", \"\")\n    paren_string\
    \ = split(paren_string, \" \")\n    paren_string = map(x -> length(x), paren_string)\n\
    \    return paren_string\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpint7jcly.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpint7jcly.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpint7jcly.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpint7jcly.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpint7jcly.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpint7jcly.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpint7jcly.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpint7jcly.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659748313
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ group in paren_groups\n        max_nesting_in_group = 0\n        current_nesting\
    \ = 0\n        for paren in group\n            if paren == '('\n             \
    \   current_nesting += 1\n            elseif paren == ')'\n                current_nesting\
    \ -= 1\n            end\n            if current_nesting > max_nesting_in_group\n\
    \                max_nesting_in_group = current_nesting\n            end\n   \
    \     end\n        push!(max_nesting, max_nesting_in_group)\n    end\n    return\
    \ max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748309
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_depth = zeros(Int64,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_group\
    \ = paren_groups[i]\n        depth = 0\n        max_depth[i] = 0\n        for\
    \ j in 1:length(paren_group)\n            if paren_group[j] == '('\n         \
    \       depth += 1\n                if depth > max_depth[i]\n                \
    \    max_depth[i] = depth\n                end\n            elseif paren_group[j]\
    \ == ')'\n                depth -= 1\n            end\n        end\n    end\n\
    \    return max_depth\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748309
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    # Initialize the output vector\n    output = Vector{Int64}(undef,\
    \ length(paren_string))\n    # Initialize the stack\n    stack = Stack{Char}()\n\
    \    # Initialize the current depth\n    depth = 0\n    # Initialize the current\
    \ group\n    group = 0\n    # Iterate over the string\n    for c in paren_string\n\
    \        # If the character is an opening paren, push it to the stack and increment\
    \ the depth\n        if c == '('\n            push!(stack, c)\n            depth\
    \ += 1\n        # If the character is a closing paren, pop from the stack and\
    \ decrement the depth\n        elseif c == ')'\n            pop!(stack)\n    \
    \        depth -= 1\n        # If the character is a space, save the current depth\
    \ and reset the depth\n        elseif c == ' '\n            output[group] = depth\n\
    \            depth = 0\n            group += 1\n        end\n    end\n    # Return\
    \ the output vector\n    return output\nend\nusing Test\n\n@testset begin\n\n\
    candidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpff6jp_r_.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmpff6jp_r_.jl:42\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ Stack not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpff6jp_r_.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpff6jp_r_.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpff6jp_r_.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpff6jp_r_.jl:43\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: Stack\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpff6jp_r_.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpff6jp_r_.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpff6jp_r_.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpff6jp_r_.jl:44\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: Stack not defined\n \
    \ Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main /tmp/tmpff6jp_r_.jl:12\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpff6jp_r_.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpff6jp_r_.jl:41\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748312
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of integers representing the depth of nesting of each group.\n\
    \    \"\"\"\n    paren_list = split(paren_string, \" \")\n    paren_depth = []\n\
    \    for paren in paren_list\n        depth = 0\n        max_depth = 0\n     \
    \   for c in paren\n            if c == '('\n                depth += 1\n    \
    \        elseif c == ')'\n                depth -= 1\n            end\n      \
    \      if depth > max_depth\n                max_depth = depth\n            end\n\
    \        end\n        push!(paren_depth, max_depth)\n    end\n    return paren_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748310
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of integers representing the maximum nesting level for each\
    \ group of parentheses.\n    \"\"\"\n    # Initialize a vector to store the maximum\
    \ nesting level for each group of parentheses.\n    max_nesting_levels = Vector{Int64}()\n\
    \    # Split the input string into groups of parentheses.\n    paren_groups =\
    \ split(paren_string, \" \")\n    # Iterate over each group of parentheses.\n\
    \    for paren_group in paren_groups\n        # Initialize a variable to store\
    \ the current nesting level.\n        current_nesting_level = 0\n        # Initialize\
    \ a variable to store the maximum nesting level.\n        max_nesting_level =\
    \ 0\n        # Iterate over each character in the group of parentheses.\n    \
    \    for char in paren_group\n            # If the character is an opening parenthesis,\
    \ increment the current nesting level.\n            if char == '('\n         \
    \       current_nesting_level += 1\n            # If the character is a closing\
    \ parenthesis, decrement the current nesting level.\n            elseif char ==\
    \ ')'\n                current_nesting_level -= 1\n            end\n         \
    \   # If the current nesting level is greater than the maximum nesting level,\
    \ update the maximum nesting level.\n            if current_nesting_level > max_nesting_level\n\
    \                max_nesting_level = current_nesting_level\n            end\n\
    \        end\n        # Push the maximum nesting level for the current group of\
    \ parentheses to the vector.\n        push!(max_nesting_levels, max_nesting_level)\n\
    \    end\n    # Return the vector of maximum nesting levels.\n    return max_nesting_levels\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748310
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_string = split(paren_string,\
    \ \" \")\n    result = []\n    for i in paren_string\n        result = push!(result,\
    \ parse_parens(i))\n    end\n    return result\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp4lj48anu.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmp4lj48anu.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp4lj48anu.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4lj48anu.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4lj48anu.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp4lj48anu.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp4lj48anu.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4lj48anu.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4lj48anu.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp4lj48anu.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmp4lj48anu.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4lj48anu.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4lj48anu.jl:23\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748312
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces\n\
    \    Output: Vector of integers representing the depth of nesting for each group\
    \ of parentheses\n    \"\"\"\n    paren_groups = split(paren_string, \" \")\n\
    \    depth_of_nesting = []\n    for paren_group in paren_groups\n        depth_of_nesting\
    \ = [depth_of_nesting; parse_parens(paren_group)]\n    end\n    return depth_of_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpftrxunu2.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpftrxunu2.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpftrxunu2.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpftrxunu2.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpftrxunu2.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpftrxunu2.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpftrxunu2.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpftrxunu2.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpftrxunu2.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpftrxunu2.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpftrxunu2.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpftrxunu2.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpftrxunu2.jl:22\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748312
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n \
    \   paren_string = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp4v2u04cl.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp4v2u04cl.jl:1\n\
    in expression starting at /tmp/tmp4v2u04cl.jl:1\n"
  stdout: ''
  timestamp: 1659748306
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_array = split(paren_string,\
    \ \" \")\n    output = zeros(Int64, length(paren_array))\n    for i in 1:length(paren_array)\n\
    \        paren_group = paren_array[i]\n        level = 0\n        max_level =\
    \ 0\n        for j in 1:length(paren_group)\n            if paren_group[j] ==\
    \ '('\n                level += 1\n            elseif paren_group[j] == ')'\n\
    \                level -= 1\n            end\n            if level > max_level\n\
    \                max_level = level\n            end\n        end\n        output[i]\
    \ = max_level\n    end\n    return output\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748310
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vector\
    \ = Vector{Int64}()\n    # Initialize a counter to keep track of the depth of\
    \ the current group\n    depth_counter = 0\n    # Initialize a variable to keep\
    \ track of the start of the current group\n    group_start = 1\n    # Initialize\
    \ a variable to keep track of the end of the current group\n    group_end = 0\n\
    \    # Initialize a variable to keep track of the start of the next group\n  \
    \  next_group_start = 1\n    # Initialize a variable to keep track of the end\
    \ of the next group\n    next_group_end = 0\n    # Initialize a variable to keep\
    \ track of the number of groups\n    num_groups = 0\n    # Initialize a variable\
    \ to keep track of the number of parentheses\n    num_parens = 0\n    # Initialize\
    \ a variable to keep track of the number of spaces\n    num_spaces = 0\n    #\
    \ Initialize a variable to keep track of the number of characters\n    num_chars\
    \ = 0\n    # Initialize a variable to keep track of the number of characters in\
    \ the current group\n    num_chars_in_group = 0\n    # Initialize a variable to\
    \ keep track of the number of characters in the next group\n    num_chars_in_next_group\
    \ = 0\n    # Initialize a variable to keep track of the number of characters in\
    \ the previous group\n    num_chars_in_prev_group = 0\n    # Initialize a variable\
    \ to keep track of the number of characters in the current group\n    num_chars_in_group\
    \ = 0\n    # Initialize a variable to keep track of the number of characters in\
    \ the next group\n    num_chars_in_next_group = 0\n    # Initialize a variable\
    \ to keep track of the number of characters in the previous group\n    num_chars_in_prev_group\
    \ = 0\n    # Initialize a variable to keep track of the number of characters in\
    \ the current group\n    num_chars_in_group = 0\n    # Initialize a variable to\
    \ keep track of the number of characters in the next group\n    num_chars_in_next_group\
    \ = 0\n    # Initialize a variable to keep track of the number\nusing Test\n\n\
    @testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpnxap1ibj.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpnxap1ibj.jl:1\n\
    in expression starting at /tmp/tmpnxap1ibj.jl:1\n"
  stdout: ''
  timestamp: 1659748311
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"((\", \"(\")\n    paren_string = replace(paren_string, \"))\", \")\")\n  \
    \  paren_string = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"()\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n   \nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpkdq2tckh.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpkdq2tckh.jl:1\n\
    in expression starting at /tmp/tmpkdq2tckh.jl:1\n"
  stdout: ''
  timestamp: 1659748302
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: paren_string: String\n    Output: Vector{Int64}\n \
    \   \"\"\"\n    # Initialize the stack\n    stack = []\n    # Initialize the output\
    \ vector\n    output = []\n    # Initialize the max_depth\n    max_depth = 0\n\
    \    # Iterate through the string\n    for i in 1:length(paren_string)\n     \
    \   # If the character is an opening parenthesis, push it to the stack\n     \
    \   if paren_string[i] == '('\n            push!(stack, paren_string[i])\n   \
    \     # If the character is a closing parenthesis, pop from the stack\n      \
    \  elseif paren_string[i] == ')'\n            pop!(stack)\n        end\n     \
    \   # Update the max_depth\n        max_depth = max(max_depth, length(stack))\n\
    \    end\n    # Push the max_depth to the output vector\n    push!(output, max_depth)\n\
    \    # Return the output vector\n    return output\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmppoiyehr7.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmppoiyehr7.jl:39\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [3] == [2, 3, 1,\
    \ 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppoiyehr7.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppoiyehr7.jl:38\ntest set: Test\
    \ Failed at /tmp/tmppoiyehr7.jl:40\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [4] == [1, 2, 3, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppoiyehr7.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppoiyehr7.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     2      3\n"
  timestamp: 1659748312
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces\n\
    \    Output: Vector of maximum nesting levels for each group\n    \"\"\"\n   \
    \ # Initialize vector to store the maximum nesting levels for each group\n   \
    \ max_nesting_levels = Vector{Int64}()\n    # Split the string by spaces\n   \
    \ paren_groups = split(paren_string, \" \")\n    # For each group, find the maximum\
    \ nesting level\n    for group in paren_groups\n        # Initialize the nesting\
    \ level to 0\n        nesting_level = 0\n        # Initialize the maximum nesting\
    \ level to 0\n        max_nesting_level = 0\n        # For each character in the\
    \ group\n        for char in group\n            # If the character is an opening\
    \ parenthesis, increment the nesting level\n            if char == '('\n     \
    \           nesting_level += 1\n            # If the character is a closing parenthesis,\
    \ decrement the nesting level\n            elseif char == ')'\n              \
    \  nesting_level -= 1\n            end\n            # If the nesting level is\
    \ greater than the maximum nesting level, update the maximum nesting level\n \
    \           if nesting_level > max_nesting_level\n                max_nesting_level\
    \ = nesting_level\n            end\n        end\n        # Append the maximum\
    \ nesting level for the group to the vector\n        push!(max_nesting_levels,\
    \ max_nesting_level)\n    end\n    # Return the vector of maximum nesting levels\n\
    \    return max_nesting_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748310
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    # Initialize a vector to store the depth of each\
    \ group\n    depth_vec = Vector{Int64}()\n    # Split the string into groups\n\
    \    paren_groups = split(paren_string, \" \")\n    # Iterate over each group\n\
    \    for group in paren_groups\n        # Initialize depth to zero\n        depth\
    \ = 0\n        # Initialize max_depth to zero\n        max_depth = 0\n       \
    \ # Iterate over each character in the group\n        for char in group\n    \
    \        # If the character is an opening parenthesis, increment depth\n     \
    \       if char == '('\n                depth += 1\n            # If the character\
    \ is a closing parenthesis, decrement depth\n            elseif char == ')'\n\
    \                depth -= 1\n            end\n            # Update max_depth if\
    \ the current depth is greater than max_depth\n            if depth > max_depth\n\
    \                max_depth = depth\n            end\n        end\n        # Push\
    \ the max_depth to the depth_vec\n        push!(depth_vec, max_depth)\n    end\n\
    \    # Return the depth_vec\n    return depth_vec\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748310
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of integers representing the maximum depth of nesting for\
    \ each group of parentheses.\n    \"\"\"\n    # Initialize a vector to store the\
    \ depth of nesting for each group of parentheses.\n    depth_vec = Vector{Int64}()\n\
    \    # Split the input string into groups of parentheses.\n    paren_groups =\
    \ split(paren_string, \" \")\n    # For each group of parentheses, calculate the\
    \ depth of nesting.\n    for paren_group in paren_groups\n        # Initialize\
    \ a counter to keep track of the depth of nesting.\n        depth = 0\n      \
    \  # Initialize a counter to keep track of the maximum depth of nesting.\n   \
    \     max_depth = 0\n        # Iterate through each character in the group of\
    \ parentheses.\n        for char in paren_group\n            # If the character\
    \ is an opening parenthesis, increment the depth counter.\n            if char\
    \ == '('\n                depth += 1\n            # If the character is a closing\
    \ parenthesis, decrement the depth counter.\n            elseif char == ')'\n\
    \                depth -= 1\n            end\n            # If the current depth\
    \ is greater than the maximum depth, update the maximum depth.\n            if\
    \ depth > max_depth\n                max_depth = depth\n            end\n    \
    \    end\n        # Add the maximum depth of nesting for the current group of\
    \ parentheses to the vector.\n        push!(depth_vec, max_depth)\n    end\n \
    \   # Return the vector of maximum depths of nesting.\n    return depth_vec\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748310
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    # Initialize a vector to store the depth of each\
    \ group\n    depth_vector = Int64[]\n    # Initialize a counter to keep track\
    \ of the depth of the current group\n    depth_counter = 0\n    # Initialize a\
    \ counter to keep track of the current group\n    group_counter = 0\n    # Initialize\
    \ a vector to store the current group\n    group_vector = []\n    # Iterate through\
    \ the string\n    for i in 1:length(paren_string)\n        # If the current character\
    \ is a left paren, increment the depth counter\n        if paren_string[i] ==\
    \ '('\n            depth_counter += 1\n        # If the current character is a\
    \ right paren, decrement the depth counter\n        elseif paren_string[i] ==\
    \ ')'\n            depth_counter -= 1\n        # If the current character is a\
    \ space, append the current depth to the depth vector\n        elseif paren_string[i]\
    \ == ' '\n            push!(depth_vector, depth_counter)\n            # Reset\
    \ the depth counter\n            depth_counter = 0\n        end\n    end\n   \
    \ # Append the depth of the last group to the depth vector\n    push!(depth_vector,\
    \ depth_counter)\n    # Return the depth vector\n    return depth_vector\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpizs15azh.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmpizs15azh.jl:42\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpizs15azh.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpizs15azh.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpizs15azh.jl:43\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpizs15azh.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpizs15azh.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpizs15azh.jl:44\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpizs15azh.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpizs15azh.jl:41\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748312
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    # Initialize a vector\
    \ to store the depth of each group\n    depth_vec = Int64[]\n    # Split the string\
    \ by space\n    paren_groups = split(paren_string, \" \")\n    # For each group,\
    \ calculate the depth\n    for paren_group in paren_groups\n        depth = 0\n\
    \        max_depth = 0\n        for paren in paren_group\n            if paren\
    \ == '('\n                depth += 1\n            elseif paren == ')'\n      \
    \          depth -= 1\n            end\n            if depth > max_depth\n   \
    \             max_depth = depth\n            end\n        end\n        push!(depth_vec,\
    \ max_depth)\n    end\n    return depth_vec\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748310
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: paren_string: String\n    Output: Vector{Int64}\n \
    \   \"\"\"\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n    paren_string = replace(paren_string, \")(\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \"\")\n   \nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpgqvjwjw0.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpgqvjwjw0.jl:1\n\
    in expression starting at /tmp/tmpgqvjwjw0.jl:1\n"
  stdout: ''
  timestamp: 1659748311
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vec\
    \ = Vector{Int64}()\n    # Initialize a counter to keep track of the depth of\
    \ each group\n    depth_counter = 0\n    # Initialize a vector to store the indices\
    \ of the start of each group\n    start_indices = Vector{Int64}()\n    # Initialize\
    \ a vector to store the indices of the end of each group\n    end_indices = Vector{Int64}()\n\
    \    # Initialize a vector to store the indices of the start of each group\n \
    \   start_indices = Vector{Int64}()\n    # Initialize a vector to store the indices\
    \ of the end of each group\n    end_indices = Vector{Int64}()\n    # Initialize\
    \ a vector to store the indices of the start of each group\n    start_indices\
    \ = Vector{Int64}()\n    # Initialize a vector to store the indices of the end\
    \ of each group\n    end_indices = Vector{Int64}()\n    # Initialize a vector\
    \ to store the indices of the start of each group\n    start_indices = Vector{Int64}()\n\
    \    # Initialize a vector to store the indices of the end of each group\n   \
    \ end_indices = Vector{Int64}()\n    # Initialize a vector to store the indices\
    \ of the start of each group\n    start_indices = Vector{Int64}()\n    # Initialize\
    \ a vector to store the indices of the end of each group\n    end_indices = Vector{Int64}()\n\
    \    # Initialize a vector to store the indices of the start of each group\n \
    \   start_indices = Vector{Int64}()\n    # Initialize a vector to store the indices\
    \ of the end of each group\n    end_indices = Vector{Int64}()\n    # Initialize\
    \ a vector to store the indices of the start of each group\n    start_indices\
    \ = Vector{Int64}()\n    # Initialize a vector to store the indices of the end\
    \ of each group\n    end_indices = Vector{Int64}()\n    # Initialize a vector\
    \ to store the indices of the start of each group\n    start_indices = Vector{Int64}()\n\
    \    # Initialize a vector to store the indices of the\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpyqx9mljh.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpyqx9mljh.jl:1\n\
    in expression starting at /tmp/tmpyqx9mljh.jl:1\n"
  stdout: ''
  timestamp: 1659748312
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_depth = []\n    for\
    \ group in paren_groups\n        depth = 0\n        max_depth = 0\n        for\
    \ char in group\n            if char == '('\n                depth += 1\n    \
    \        elseif char == ')'\n                depth -= 1\n            end\n   \
    \         if depth > max_depth\n                max_depth = depth\n          \
    \  end\n        end\n        push!(paren_depth, max_depth)\n    end\n    return\
    \ paren_depth\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748311
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of integers representing the maximum depth of nesting for\
    \ each group.\n    \"\"\"\n    paren_groups = split(paren_string, \" \")\n   \
    \ max_nesting = zeros(Int64, length(paren_groups))\n    for i in 1:length(paren_groups)\n\
    \        paren_group = paren_groups[i]\n        max_nesting[i] = get_max_nesting(paren_group)\n\
    \    end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpz5ido3_1.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpz5ido3_1.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_max_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpz5ido3_1.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpz5ido3_1.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpz5ido3_1.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpz5ido3_1.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_max_nesting\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpz5ido3_1.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpz5ido3_1.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpz5ido3_1.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpz5ido3_1.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: get_max_nesting not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpz5ido3_1.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpz5ido3_1.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpz5ido3_1.jl:23\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748313
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of integers representing the deepest level of nesting of parentheses.\n\
    \    \"\"\"\n    paren_groups = split(paren_string, \" \")\n    paren_levels =\
    \ zeros(Int64, length(paren_groups))\n    for i in 1:length(paren_groups)\n  \
    \      paren_levels[i] = get_nesting_level(paren_groups[i])\n    end\n    return\
    \ paren_levels\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpd34vg1ns.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpd34vg1ns.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_nesting_level not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpd34vg1ns.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd34vg1ns.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd34vg1ns.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpd34vg1ns.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_nesting_level\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpd34vg1ns.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd34vg1ns.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd34vg1ns.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpd34vg1ns.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: get_nesting_level not\
    \ defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n \
    \    @ Main /tmp/tmpd34vg1ns.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd34vg1ns.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd34vg1ns.jl:22\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748313
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    # Initialize the output vector\n    output = Vector{Int64}(undef,\
    \ length(split(paren_string)))\n    \n    # Iterate over the groups\n    for (i,\
    \ group) in enumerate(split(paren_string))\n        # Initialize the counter\n\
    \        counter = 0\n        # Iterate over the characters in the group\n   \
    \     for c in group\n            # Increment the counter if the character is\
    \ an opening parenthesis\n            if c == '('\n                counter +=\
    \ 1\n            # Decrement the counter if the character is a closing parenthesis\n\
    \            elseif c == ')'\n                counter -= 1\n            end\n\
    \        end\n        # Store the counter in the output vector\n        output[i]\
    \ = counter\n    end\n    # Return the output vector\n    return output\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp17ei4g4h.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmp17ei4g4h.jl:37\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp17ei4g4h.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp17ei4g4h.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp17ei4g4h.jl:38\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp17ei4g4h.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp17ei4g4h.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp17ei4g4h.jl:39\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp17ei4g4h.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp17ei4g4h.jl:36\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748313
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")\", \"\")\n    paren_string = replace(paren_string,\
    \ \"(\", \"\")\n    return map(x -> length(x), split(paren_string, \")\"))\nend\n\
    using Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpmd6dwmg7.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmpmd6dwmg7.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpmd6dwmg7.jl:7\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmd6dwmg7.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpmd6dwmg7.jl:16\ntest set:\
    \ Error During Test at /tmp/tmpmd6dwmg7.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpmd6dwmg7.jl:7\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpmd6dwmg7.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659748314
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    depth = 0\n    max_depth = 0\n    depths = []\n    for i in\
    \ 1:length(paren_string)\n        if paren_string[i] == '('\n            depth\
    \ += 1\n            if depth > max_depth\n                max_depth = depth\n\
    \            end\n        elseif paren_string[i] == ')'\n            depth -=\
    \ 1\n        end\n        if i == length(paren_string) || paren_string[i+1] ==\
    \ ' '\n            push!(depths, max_depth)\n            max_depth = 0\n     \
    \   end\n    end\n    return depths\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp58bssgj6.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp58bssgj6.jl:37\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp58bssgj6.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp58bssgj6.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp58bssgj6.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp58bssgj6.jl:38\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp58bssgj6.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp58bssgj6.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.j"
  timestamp: 1659748314
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: string of nested parentheses separated by spaces\n\
    \    Output: Vector of integers representing the deepest level of nesting of parentheses\
    \ for each group\n    \"\"\"\n    # initialize a vector to store the output\n\
    \    output = Vector{Int64}()\n    # split the string by spaces\n    paren_groups\
    \ = split(paren_string, \" \")\n    # loop through each group\n    for group in\
    \ paren_groups\n        # initialize a counter to keep track of the level of nesting\n\
    \        level = 0\n        # initialize a variable to keep track of the maximum\
    \ level of nesting\n        max_level = 0\n        # loop through each character\
    \ in the group\n        for char in group\n            # if the character is an\
    \ opening parenthesis, increment the level\n            if char == '('\n     \
    \           level += 1\n            # if the character is a closing parenthesis,\
    \ decrement the level\n            elseif char == ')'\n                level -=\
    \ 1\n            end\n            # update the maximum level of nesting if the\
    \ current level is higher\n            if level > max_level\n                max_level\
    \ = level\n            end\n        end\n        # append the maximum level of\
    \ nesting to the output vector\n        push!(output, max_level)\n    end\n  \
    \  # return the output vector\n    return output\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748311
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    # Initialize an empty stack\n    stack = []\n\
    \    # Initialize a vector to store the maximum depth for each group\n    max_depth\
    \ = []\n    # Initialize a variable to store the current depth\n    curr_depth\
    \ = 0\n    # Initialize a variable to store the maximum depth\n    max_depth_so_far\
    \ = 0\n    # Initialize a variable to store the current character\n    curr_char\
    \ = \"\"\n    # Initialize a variable to store the current group\n    curr_group\
    \ = \"\"\n    # Iterate over the string\n    for i = 1:length(paren_string)\n\
    \        # Get the current character\n        curr_char = paren_string[i]\n  \
    \      # If the current character is a left parenthesis, push it to the stack\n\
    \        if curr_char == \"(\"\n            push!(stack, curr_char)\n        \
    \    # Increment the current depth\n            curr_depth += 1\n            #\
    \ Update the maximum depth so far\n            max_depth_so_far = max(max_depth_so_far,\
    \ curr_depth)\n        # If the current character is a right parenthesis, pop\
    \ the stack\n        elseif curr_char == \")\"\n            pop!(stack)\n    \
    \        # Decrement the current depth\n            curr_depth -= 1\n        #\
    \ If the current character is a space, store the maximum depth so far\n      \
    \  elseif curr_char == \" \"\n            push!(max_depth, max_depth_so_far)\n\
    \            # Reset the maximum depth so far\n            max_depth_so_far =\
    \ 0\n            # Reset the current depth\n            curr_depth = 0\n     \
    \   end\n    end\n    # Return the vector of maximum depths\n    return max_depth\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpetb9o8pj.jl:51

    '
  stdout: "test set: Test Failed at /tmp/tmpetb9o8pj.jl:54\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: Int64[] == [2, 3,\
    \ 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpetb9o8pj.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpetb9o8pj.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpetb9o8pj.jl:55\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: Int64[] == [1, 2, 3, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpetb9o8pj.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpetb9o8pj.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpetb9o8pj.jl:56\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpetb9o8pj.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpetb9o8pj.jl:53\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748313
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    # Initialize a vector to store the depth of each\
    \ group\n    depth_vec = Vector{Int64}(undef, length(split(paren_string, \" \"\
    )))\n    # Initialize a counter for the depth\n    depth = 0\n    # Initialize\
    \ a counter for the group\n    group_counter = 1\n    # Loop through the string\n\
    \    for i in 1:length(paren_string)\n        # If the character is an open paren,\
    \ increment the depth\n        if paren_string[i] == '('\n            depth +=\
    \ 1\n        # If the character is a closed paren, decrement the depth\n     \
    \   elseif paren_string[i] == ')'\n            depth -= 1\n        # If the character\
    \ is a space, store the depth and reset the depth\n        elseif paren_string[i]\
    \ == ' '\n            depth_vec[group_counter] = depth\n            depth = 0\n\
    \            group_counter += 1\n        end\n    end\n    # Return the vector\
    \ of depths\n    return depth_vec\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3hwmfytw.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmp3hwmfytw.jl:38\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3hwmfytw.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3hwmfytw.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp3hwmfytw.jl:39\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 17] == [1, 2, 3, 4]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3hwmfytw.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3hwmfytw.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp3hwmfytw.jl:40\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3hwmfytw.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3hwmfytw.jl:37\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748313
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth_vec\
    \ = Int64[]\n    # Split the string into groups\n    groups = split(paren_string,\
    \ \" \")\n    # Iterate over each group\n    for group in groups\n        # Initialize\
    \ a counter to keep track of the depth\n        depth = 0\n        # Initialize\
    \ a counter to keep track of the maximum depth\n        max_depth = 0\n      \
    \  # Iterate over each character in the group\n        for char in group\n   \
    \         # If the character is an opening parenthesis, increment the depth\n\
    \            if char == '('\n                depth += 1\n            # If the\
    \ character is a closing parenthesis, decrement the depth\n            elseif\
    \ char == ')'\n                depth -= 1\n            end\n            # If the\
    \ depth is greater than the maximum depth, update the maximum depth\n        \
    \    if depth > max_depth\n                max_depth = depth\n            end\n\
    \        end\n        # Append the maximum depth to the vector\n        push!(depth_vec,\
    \ max_depth)\n    end\n    # Return the vector\n    return depth_vec\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748312
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces\n\
    \    Output: Vector of integers representing the deepest level of nesting for\
    \ each group of parentheses\n    \"\"\"\n    # Split the string into groups of\
    \ parentheses\n    paren_groups = split(paren_string, \" \")\n    # Initialize\
    \ a vector to store the results\n    paren_depth = zeros(Int64, length(paren_groups))\n\
    \    # Loop through each group of parentheses\n    for i in 1:length(paren_groups)\n\
    \        # Initialize a counter to keep track of the depth\n        depth = 0\n\
    \        # Initialize a variable to keep track of the maximum depth\n        max_depth\
    \ = 0\n        # Loop through each character in the group\n        for j in 1:length(paren_groups[i])\n\
    \            # If the character is an open parenthesis, increment the depth\n\
    \            if paren_groups[i][j] == '('\n                depth += 1\n      \
    \      # If the character is a closed parenthesis, decrement the depth\n     \
    \       elseif paren_groups[i][j] == ')'\n                depth -= 1\n       \
    \     end\n            # If the depth is greater than the maximum depth, update\
    \ the maximum depth\n            if depth > max_depth\n                max_depth\
    \ = depth\n            end\n        end\n        # Store the maximum depth in\
    \ the results vector\n        paren_depth[i] = max_depth\n    end\n    # Return\
    \ the results vector\n    return paren_depth\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748312
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_list = split(paren_string,\
    \ \" \")\n    paren_list = [replace(x, \")\", \"\") for x in paren_list]\n   \
    \ paren_list = [replace(x, \"(\", \"\") for x in paren_list]\n    paren_list =\
    \ [replace(x, \" \", \"\") for x in paren_list]\n    paren_list = [replace(x,\
    \ \"\", \"\") for x in paren_list]\n    paren_list = [replace(x, \"\", \"\") for\
    \ x in paren_list]\n    paren_list = [replace(x, \"\", \"\") for x in paren_list]\n\
    \    paren_list = [replace(x, \"\", \"\") for x in paren_list]\n    paren_list\
    \ = [replace(x, \"\", \"\") for x in paren_list]\n    paren_list = [replace(x,\
    \ \"\", \"\") for x in paren_list]\n    paren_list = [replace(x, \"\", \"\") for\
    \ x in paren_list]\n    paren_list = [replace(x, \"\", \"\") for x in paren_list]\n\
    \    paren_list = [replace(x, \"\", \"\") for x in paren_list]\n    paren_list\
    \ = [replace(x, \"\", \"\") for x in paren_list]\n    paren_list = [replace(x,\
    \ \"\", \"\") for x in paren_list]\n    paren_list = [replace(x, \"\", \"\") for\
    \ x in paren_list]\n    paren_list = [replace(x, \"\", \"\") for x in paren_list]\n\
    \    paren_list = [replace(x, \"\", \"\") for x in paren_list]\n    paren_list\
    \ = [replace(x, \"\", \"\") for x in paren_list]\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpetbdcpxh.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpetbdcpxh.jl:1\n\
    in expression starting at /tmp/tmpetbdcpxh.jl:1\n"
  stdout: ''
  timestamp: 1659748303
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \"()\", \"\")\n \
    \   paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string,\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpiyh23ye9.jl:38\nin expression starting at\
    \ /tmp/tmpiyh23ye9.jl:38\n"
  stdout: ''
  timestamp: 1659748305
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_groups = split(paren_string, \" \")\n  \
    \  max_nesting = Vector{Int64}(length(paren_groups))\n    for i in 1:length(paren_groups)\n\
    \        max_nesting[i] = parse_parens(paren_groups[i])\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpd2m0mnlr.jl:18

    '
  stdout: "test set: Error During Test at /tmp/tmpd2m0mnlr.jl:21\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpd2m0mnlr.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd2m0mnlr.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd2m0mnlr.jl:20\ntest set:\
    \ Error During Test at /tmp/tmpd2m0mnlr.jl:22\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching Vector{Int64}(::Int64)\n  Closest candidates are:\n    Vector{T}()\
    \ where T at /shared/centos7/julia/1.7.3/share/julia/base/boot.jl:476\n    Array{T,\
    \ N}(!Matched::Core.Compiler.BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    Array{T, N}(!Matched::BitArray{N}) where {T, N} at /shared/centos7/julia/1.7.3/share/julia/base/bitarray.jl:494\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpd2m0mnlr.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd2m0mnlr.jl:22 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd2m0mnlr.jl:20\ntest set:\
    \ Error During Test at /"
  timestamp: 1659748315
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \")\", \" ) \")\n    paren_string\
    \ = replace(paren_string, \"(\", \" ( \")\n    paren_string = split(paren_string)\n\
    \    paren_string = filter(x -> x != \"\", paren_string)\n    paren_string = map(x\
    \ -> x == \"(\" ? 1 : -1, paren_string)\n    paren_string = cumsum(paren_string)\n\
    \    paren_string = filter(x -> x == 0, paren_string)\n    return paren_string\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpfbyk6tz0.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmpfbyk6tz0.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpfbyk6tz0.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfbyk6tz0.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfbyk6tz0.jl:23\ntest set:\
    \ Error During Test at /tmp/tmpfbyk6tz0.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpfbyk6tz0.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfbyk6tz0.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659748315
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = replace(paren_string, \" \", \"\
    \")\n    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string\
    \ = replace(paren_string, \"()\", \"\")\n    paren_string = replace(paren_string,\
    \ \")\", \"\")\n    paren_string = replace(paren_string, \"(\", \"\")\n    paren_string\
    \ = split(paren_string, \" \")\n    paren_string = map(x -> length(x), paren_string)\n\
    \    return paren_string\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpint7jcly.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpint7jcly.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpint7jcly.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpint7jcly.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpint7jcly.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpint7jcly.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpint7jcly.jl:9\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpint7jcly.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659748313
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    # Initialize the\
    \ output vector\n    output = Vector{Int64}()\n    # Split the input string by\
    \ space\n    paren_groups = split(paren_string, \" \")\n    # Iterate through\
    \ each group\n    for group in paren_groups\n        # Initialize the maximum\
    \ level of nesting\n        max_level = 0\n        # Initialize the current level\
    \ of nesting\n        curr_level = 0\n        # Iterate through each character\
    \ in the group\n        for c in group\n            # If the character is an open\
    \ parenthesis, increase the current level of nesting\n            if c == '('\n\
    \                curr_level += 1\n            # If the character is a closed parenthesis,\
    \ decrease the current level of nesting\n            elseif c == ')'\n       \
    \         curr_level -= 1\n            end\n            # Update the maximum level\
    \ of nesting\n            if curr_level > max_level\n                max_level\
    \ = curr_level\n            end\n        end\n        # Append the maximum level\
    \ of nesting to the output vector\n        push!(output, max_level)\n    end\n\
    \    # Return the output vector\n    return output\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748312
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input:\n        paren_string: String of nested parentheses\
    \ separated by spaces.\n    Output:\n        Vector of Int64s representing the\
    \ maximum level of nesting for each group of parentheses.\n    \"\"\"\n    # Initialize\
    \ the output vector\n    output = Vector{Int64}()\n    \n    # Split the input\
    \ string into groups of parentheses\n    paren_groups = split(paren_string, \"\
    \ \")\n    \n    # For each group of parentheses, find the maximum level of nesting\n\
    \    for paren_group in paren_groups\n        # Initialize the level of nesting\n\
    \        level = 0\n        # Initialize the maximum level of nesting\n      \
    \  max_level = 0\n        # For each character in the group of parentheses\n \
    \       for char in paren_group\n            # If the character is an opening\
    \ parenthesis\n            if char == '('\n                # Increment the level\
    \ of nesting\n                level += 1\n                # If the level of nesting\
    \ is greater than the maximum level of nesting\n                if level > max_level\n\
    \                    # Set the maximum level of nesting to the current level of\
    \ nesting\n                    max_level = level\n                end\n      \
    \      # If the character is a closing parenthesis\n            elseif char ==\
    \ ')'\n                # Decrement the level of nesting\n                level\
    \ -= 1\n            end\n        end\n        # Append the maximum level of nesting\
    \ to the output vector\n        push!(output, max_level)\n    end\n    \n    #\
    \ Return the output vector\n    return output\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748312
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_string = split(paren_string,\
    \ \" \")\n    paren_string = [replace(i, \")\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"(\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \" \", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \"\", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\"\
    ) for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \"\", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\"\
    ) for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \"\", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\"\
    ) for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp2yt9yi8l.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp2yt9yi8l.jl:1\n\
    in expression starting at /tmp/tmp2yt9yi8l.jl:1\n"
  stdout: ''
  timestamp: 1659748306
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_group\
    \ = paren_groups[i]\n        nesting_level = 0\n        max_nesting_level = 0\n\
    \        for j in 1:length(paren_group)\n            if paren_group[j] == '('\n\
    \                nesting_level += 1\n            elseif paren_group[j] == ')'\n\
    \                nesting_level -= 1\n            end\n            if nesting_level\
    \ > max_nesting_level\n                max_nesting_level = nesting_level\n   \
    \         end\n        end\n        max_nesting[i] = max_nesting_level\n    end\n\
    \    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748312
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: paren_string is a string of nested parentheses separated\
    \ by spaces.\n    Output: Vector of integers representing the depth of nesting\
    \ of each group of parentheses.\n    \"\"\"\n    paren_string = split(paren_string,\
    \ \" \")\n    depth_vector = []\n    for group in paren_string\n        depth\
    \ = 0\n        max_depth = 0\n        for char in group\n            if char ==\
    \ '('\n                depth += 1\n            elseif char == ')'\n          \
    \      depth -= 1\n            end\n            if depth > max_depth\n       \
    \         max_depth = depth\n            end\n        end\n        push!(depth_vector,\
    \ max_depth)\n    end\n    return depth_vector\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748312
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    max_nesting = []\n    for\
    \ paren_group in paren_groups\n        curr_nesting = 0\n        max_nesting_curr\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         curr_nesting += 1\n            elseif paren == ')'\n               \
    \ curr_nesting -= 1\n            end\n            if curr_nesting > max_nesting_curr\n\
    \                max_nesting_curr = curr_nesting\n            end\n        end\n\
    \        push!(max_nesting, max_nesting_curr)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748312
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \"()\", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \"\")\n    paren_string = replace(paren_string,\
    \ \"((\", \"\")\n    paren_string = replace(paren_string, \"))\", \"\")\n    paren_string\
    \ = replace(paren_string, \"(((\", \"\")\n    paren_string = replace(paren_string,\
    \ \")))\", \"\")\n    paren_string = replace(paren_string, \"((((\", \"\")\n \
    \   paren_string = replace(paren_string, \")))))\", \"\")\n    paren_string =\
    \ replace(paren_string, \"(((((\", \"\")\n    paren_string = replace(paren_string,\
    \ \")))))))\", \"\")\n    paren_string = replace(paren_string, \"((((((\", \"\"\
    )\n    paren_string = replace(paren_string, \"))))))))\", \"\")\n    paren_string\
    \ = replace(paren_string, \"(((((((\", \"\")\n    paren_string = replace(paren_string,\
    \ \"))))))))))\", \"\")\n    paren_string = replace(paren_string, \"((((((((\"\
    , \"\")\n    paren_string = replace(paren_string, \")))))))))))\", \"\")\n   \
    \ paren_string = replace(paren_string, \"(((((((((\", \"\")\n    paren_string\
    \ = replace(paren_string, \"))))))))))))\", \"\")\n    paren_string = replace(paren_string,\
    \ \"((((((((((\", \"\")\n    paren_string = replace(paren_string, \"))))))))))))))\"\
    , \"\")\n    paren_string = replace(paren_string, \"(((((((((((\", \"\")\n   \
    \ paren_string = replace(paren_string, \"))))))))\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: space before \"(\" not allowed in \"\"))))))))\\\
    nusing Test\\n\\n@testset begin\\n\\ncandidate = parse_nested_parens;\\n\\t@test(candidate(\"\
    (()()) (\" at /tmp/tmp_fky16tu.jl:40\nStacktrace:\n [1] top-level scope\n   @\
    \ /tmp/tmp_fky16tu.jl:40\nin expression starting at /tmp/tmp_fky16tu.jl:40\n"
  stdout: ''
  timestamp: 1659748313
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_string = replace(paren_string,\
    \ \" \", \"\")\n    paren_string = replace(paren_string, \")\", \"\")\n    paren_string\
    \ = replace(paren_string, \"(\", \" \")\n    paren_string = split(paren_string)\n\
    \    paren_string = map(x -> length(x), paren_string)\n    return paren_string\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp9l61lot_.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmp9l61lot_.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp9l61lot_.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9l61lot_.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9l61lot_.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp9l61lot_.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmp9l61lot_.jl:12\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9l61lot_.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.j"
  timestamp: 1659748316
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces\n\
    \    Output: Vector of maximum nesting level for each group of parentheses\n \
    \   \"\"\"\n    paren_groups = split(paren_string, \" \")\n    max_nesting = zeros(Int64,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_group\
    \ = paren_groups[i]\n        max_nesting[i] = get_max_nesting(paren_group)\n \
    \   end\n    return max_nesting\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp7xe0jko5.jl:21

    '
  stdout: "test set: Error During Test at /tmp/tmp7xe0jko5.jl:24\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ get_max_nesting not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp7xe0jko5.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7xe0jko5.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7xe0jko5.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp7xe0jko5.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: get_max_nesting\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp7xe0jko5.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7xe0jko5.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7xe0jko5.jl:23\ntest set:\
    \ Error During Test at /tmp/tmp7xe0jko5.jl:26\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: get_max_nesting not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmp7xe0jko5.jl:15\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7xe0jko5.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7xe0jko5.jl:23\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748315
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_levels = []\n   \
    \ for paren_group in paren_groups\n        paren_level = 0\n        max_level\
    \ = 0\n        for paren in paren_group\n            if paren == '('\n       \
    \         paren_level += 1\n            elseif paren == ')'\n                paren_level\
    \ -= 1\n            end\n            if paren_level > max_level\n            \
    \    max_level = paren_level\n            end\n        end\n        push!(paren_levels,\
    \ max_level)\n    end\n    return paren_levels\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748302
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses\n    Output: Vector of\
    \ integers representing the maximum depth of nesting for each group of parentheses\n\
    \    \"\"\"\n    paren_string = split(paren_string, \" \")\n    max_depth = Vector{Int64}(undef,\
    \ length(paren_string))\n    for i in 1:length(paren_string)\n        depth =\
    \ 0\n        max_depth[i] = 0\n        for c in paren_string[i]\n            if\
    \ c == '('\n                depth += 1\n                if depth > max_depth[i]\n\
    \                    max_depth[i] = depth\n                end\n            elseif\
    \ c == ')'\n                depth -= 1\n            end\n        end\n    end\n\
    \    return max_depth\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748313
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize the output vector\n    output = Vector{Int64}()\n    \n \
    \   # Split the string into groups\n    groups = split(paren_string, \" \")\n\
    \    \n    # Loop through each group\n    for group in groups\n        # Initialize\
    \ the counter\n        counter = 0\n        # Initialize the max counter\n   \
    \     max_counter = 0\n        \n        # Loop through each character in the\
    \ group\n        for char in group\n            # If the character is an open\
    \ parenthesis, increment the counter\n            if char == '('\n           \
    \     counter += 1\n            # If the character is a closed parenthesis, decrement\
    \ the counter\n            elseif char == ')'\n                counter -= 1\n\
    \            end\n            \n            # If the counter is greater than the\
    \ max counter, update the max counter\n            if counter > max_counter\n\
    \                max_counter = counter\n            end\n        end\n       \
    \ \n        # Push the max counter to the output vector\n        push!(output,\
    \ max_counter)\n    end\n    \n    # Return the output vector\n    return output\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748313
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = split(paren_string, \" \")\n  \
    \  paren_string = map(x -> split(x, \"\"), paren_string)\n    paren_string = map(x\
    \ -> map(y -> split(y, \"\"), x), paren_string)\n    paren_string = map(x -> map(y\
    \ -> map(z -> split(z, \"\"), y), x), paren_string)\n    paren_string = map(x\
    \ -> map(y -> map(z -> map(a -> split(a, \"\"), z), y), x), paren_string)\n  \
    \  paren_string = map(x -> map(y -> map(z -> map(a -> map(b -> split(b, \"\"),\
    \ a), z), y), x), paren_string)\n    paren_string = map(x -> map(y -> map(z ->\
    \ map(a -> map(b -> map(c -> split(c, \"\"), b), a), z), y), x), paren_string)\n\
    \    paren_string = map(x -> map(y -> map(z -> map(a -> map(b -> map(c -> map(d\
    \ -> split(d, \"\"), c), b), a), z), y), x), paren_string)\n    paren_string =\
    \ map(x -> map(y -> map(z -> map(a -> map(b -> map(c -> map(d -> map(e -> split(e,\
    \ \"\"), d), c), b), a), z), y), x), paren_string)\n    paren_string = map(x ->\
    \ map(y -> map(z -> map(a -> map(b -> map(c -> map(d -> map(e -> map(f -> split(f,\
    \ \"\"), e), d), c), b), a), z), y), x), paren_string)\n    paren_string = map(x\
    \ -> map(y -> map(z -> map(a -> map(b -> map(c -> map(d -> map(e -> map(f -> map(g\
    \ -> split(g, \"\"), f), e), d), c), b), a), z), y), x), paren_string)\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmphrzceqwv.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmphrzceqwv.jl:1\n\
    in expression starting at /tmp/tmphrzceqwv.jl:1\n"
  stdout: ''
  timestamp: 1659748314
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: paren_string is a string of nested parentheses separated\
    \ by spaces.\n    Output: Vector of integers representing the deepest level of\
    \ nesting for each group of parentheses.\n    \"\"\"\n    paren_list = split(paren_string,\
    \ \" \")\n    paren_levels = zeros(Int64, length(paren_list))\n    for (i, paren_group)\
    \ in enumerate(paren_list)\n        paren_levels[i] = paren_level(paren_group)\n\
    \    end\n    return paren_levels\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpkrirgrqd.jl:20

    '
  stdout: "test set: Error During Test at /tmp/tmpkrirgrqd.jl:23\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ paren_level not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpkrirgrqd.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkrirgrqd.jl:23 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkrirgrqd.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpkrirgrqd.jl:24\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: paren_level\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpkrirgrqd.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkrirgrqd.jl:24 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkrirgrqd.jl:22\ntest set:\
    \ Error During Test at /tmp/tmpkrirgrqd.jl:25\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: paren_level not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpkrirgrqd.jl:14\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkrirgrqd.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkrirgrqd.jl:22\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748315
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of each group\n    depth = Vector{Int64}()\n\
    \    # Initialize a counter to keep track of the depth of the current group\n\
    \    count = 0\n    # Initialize a vector to store the indices of the start of\
    \ each group\n    start_indices = Vector{Int64}()\n    # Initialize a vector to\
    \ store the indices of the end of each group\n    end_indices = Vector{Int64}()\n\
    \    # Initialize a vector to store the indices of the start of each group\n \
    \   start_indices = Vector{Int64}()\n    # Initialize a vector to store the indices\
    \ of the end of each group\n    end_indices = Vector{Int64}()\n    # Initialize\
    \ a vector to store the indices of the start of each group\n    start_indices\
    \ = Vector{Int64}()\n    # Initialize a vector to store the indices of the end\
    \ of each group\n    end_indices = Vector{Int64}()\n    # Initialize a vector\
    \ to store the indices of the start of each group\n    start_indices = Vector{Int64}()\n\
    \    # Initialize a vector to store the indices of the end of each group\n   \
    \ end_indices = Vector{Int64}()\n    # Initialize a vector to store the indices\
    \ of the start of each group\n    start_indices = Vector{Int64}()\n    # Initialize\
    \ a vector to store the indices of the end of each group\n    end_indices = Vector{Int64}()\n\
    \    # Initialize a vector to store the indices of the start of each group\n \
    \   start_indices = Vector{Int64}()\n    # Initialize a vector to store the indices\
    \ of the end of each group\n    end_indices = Vector{Int64}()\n    # Initialize\
    \ a vector to store the indices of the start of each group\n    start_indices\
    \ = Vector{Int64}()\n    # Initialize a vector to store the indices of the end\
    \ of each group\n    end_indices = Vector{Int64}()\n    # Initialize a vector\
    \ to store the indices of the start of each group\n    start_indices = Vector{Int64}()\n\
    \    # Initialize a vector to store the indices of the end of each\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpmli2rv_b.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpmli2rv_b.jl:1\n\
    in expression starting at /tmp/tmpmli2rv_b.jl:1\n"
  stdout: ''
  timestamp: 1659748314
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    num_parens = length(paren_string)\n    paren_count = 0\n    max_paren_count\
    \ = 0\n    paren_count_vec = []\n    for i in 1:num_parens\n        if paren_string[i]\
    \ == '('\n            paren_count += 1\n            if paren_count > max_paren_count\n\
    \                max_paren_count = paren_count\n            end\n        elseif\
    \ paren_string[i] == ')'\n            paren_count -= 1\n        elseif paren_string[i]\
    \ == ' '\n            push!(paren_count_vec, max_paren_count)\n            max_paren_count\
    \ = 0\n            paren_count = 0\n        end\n    end\n    push!(paren_count_vec,\
    \ max_paren_count)\n    return paren_count_vec\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3,\
    \ 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748313
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: paren_string: String\n    Output: Vector{Int64}\n \
    \   \"\"\"\n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string\
    \ = replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren_string, \")(\", \") (\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = replace(paren_string,\
    \ \")(\", \") (\")\n    paren_string = replace(paren_string, \")(\", \") (\")\n\
    \    paren_string = replace(paren\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: missing comma or ) in argument list\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpd9dq7ru5.jl:36\nin expression starting at\
    \ /tmp/tmpd9dq7ru5.jl:36\n"
  stdout: ''
  timestamp: 1659748314
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_groups = split(paren_string,\
    \ \" \")\n    max_nesting = zeros(Int64, length(paren_groups))\n    for i in 1:length(paren_groups)\n\
    \        paren_group = paren_groups[i]\n        paren_count = 0\n        for j\
    \ in 1:length(paren_group)\n            if paren_group[j] == '('\n           \
    \     paren_count += 1\n            elseif paren_group[j] == ')'\n           \
    \     paren_count -= 1\n            end\n            max_nesting[i] = max(max_nesting[i],\
    \ paren_count)\n        end\n    end\n    return max_nesting\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpqtaobymc.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpqtaobymc.jl:30\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpqtaobymc.jl:7\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqtaobymc.jl:30 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqtaobymc.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpqtaobymc.jl:31\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpqtaobymc.jl:7\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqtaobymc.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659748316
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_string = split(paren_string,\
    \ \" \")\n    paren_string = [replace(x, \")\", \"\") for x in paren_string]\n\
    \    paren_string = [replace(x, \"(\", \"\") for x in paren_string]\n    paren_string\
    \ = [replace(x, \" \", \"\") for x in paren_string]\n    paren_string = [replace(x,\
    \ \"\", \"\") for x in paren_string]\n    paren_string = [replace(x, \"\", \"\"\
    ) for x in paren_string]\n    paren_string = [replace(x, \"\", \"\") for x in\
    \ paren_string]\n    paren_string = [replace(x, \"\", \"\") for x in paren_string]\n\
    \    paren_string = [replace(x, \"\", \"\") for x in paren_string]\n    paren_string\
    \ = [replace(x, \"\", \"\") for x in paren_string]\n    paren_string = [replace(x,\
    \ \"\", \"\") for x in paren_string]\n    paren_string = [replace(x, \"\", \"\"\
    ) for x in paren_string]\n    paren_string = [replace(x, \"\", \"\") for x in\
    \ paren_string]\n    paren_string = [replace(x, \"\", \"\") for x in paren_string]\n\
    \    paren_string = [replace(x, \"\", \"\") for x in paren_string]\n    paren_string\
    \ = [replace(x, \"\", \"\") for x in paren_string]\n    paren_string = [replace(x,\
    \ \"\", \"\") for x in paren_string]\n    paren_string = [replace(x, \"\", \"\"\
    ) for x in paren_string]\n    paren_string = [replace(x, \"\", \"\") for x in\
    \ paren_string]\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp86gt6b0n.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp86gt6b0n.jl:1\n\
    in expression starting at /tmp/tmp86gt6b0n.jl:1\n"
  stdout: ''
  timestamp: 1659748314
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_list = split(paren_string,\
    \ \" \")\n    paren_list = filter(x -> x != \"\", paren_list)\n    max_nesting\
    \ = []\n    for paren in paren_list\n        max_nesting_count = 0\n        nesting_count\
    \ = 0\n        for char in paren\n            if char == '('\n               \
    \ nesting_count += 1\n            elseif char == ')'\n                nesting_count\
    \ -= 1\n            end\n            if nesting_count > max_nesting_count\n  \
    \              max_nesting_count = nesting_count\n            end\n        end\n\
    \        push!(max_nesting, max_nesting_count)\n    end\n    return max_nesting\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748313
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_array = split(paren_string, \" \")\n    paren_levels = zeros(Int64,\
    \ length(paren_array))\n    for i in 1:length(paren_array)\n        paren_levels[i]\
    \ = parse_parens(paren_array[i])\n    end\n    return paren_levels\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpkhmvqbhw.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmpkhmvqbhw.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpkhmvqbhw.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkhmvqbhw.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkhmvqbhw.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpkhmvqbhw.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmpkhmvqbhw.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkhmvqbhw.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkhmvqbhw.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpkhmvqbhw.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmpkhmvqbhw.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkhmvqbhw.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkhmvqbhw.jl:18\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748316
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize a vector to store the depth of nesting for each group\n \
    \   depth_vector = Vector{Int64}(undef, length(split(paren_string, \" \")))\n\
    \    # Iterate over each group\n    for (i, paren_group) in enumerate(split(paren_string,\
    \ \" \"))\n        # Initialize a counter to keep track of the depth of nesting\n\
    \        depth = 0\n        # Iterate over each character in the group\n     \
    \   for c in paren_group\n            # If the character is an opening parenthesis,\
    \ increment the depth\n            if c == '('\n                depth += 1\n \
    \           # If the character is a closing parenthesis, decrement the depth\n\
    \            elseif c == ')'\n                depth -= 1\n            end\n  \
    \      end\n        # Store the depth of nesting for this group\n        depth_vector[i]\
    \ = depth\n    end\n    # Return the vector\n    return depth_vector\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpx43idfow.jl:31

    '
  stdout: "test set: Test Failed at /tmp/tmpx43idfow.jl:34\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0, 0] ==\
    \ [2, 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpx43idfow.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpx43idfow.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpx43idfow.jl:35\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpx43idfow.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpx43idfow.jl:33\ntest set: Test\
    \ Failed at /tmp/tmpx43idfow.jl:36\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: [0] == [4]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpx43idfow.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpx43idfow.jl:33\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748315
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n    \"\"\"\n    paren_string = split(paren_string,\
    \ \" \")\n    paren_string = [replace(i, \")\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"(\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \"\", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\"\
    ) for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \"\", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\"\
    ) for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n\
    \    paren_string = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string\
    \ = [replace(i, \"\", \"\") for i in paren_string]\n    paren_string = [replace(i,\
    \ \"\", \"\") for i in paren_string]\n    paren_string = [replace(i, \"\", \"\"\
    ) for i in paren_string]\n    paren_string = [replace(i, \"\", \"\") for i in\
    \ paren_string]\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmp638hx117.jl:6\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmp638hx117.jl:1\n\
    in expression starting at /tmp/tmp638hx117.jl:1\n"
  stdout: ''
  timestamp: 1659748303
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_string = replace(paren_string, \" \", \"\")\n    paren_string =\
    \ replace(paren_string, \")(\", \") (\")\n    paren_string = split(paren_string,\
    \ \" \")\n    paren_string = filter(x -> length(x) > 0, paren_string)\n    paren_string\
    \ = map(x -> parse_parens(x), paren_string)\n    return paren_string\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpi0v18e3y.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmpi0v18e3y.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  MethodError:\
    \ no method matching replace(::String, ::String, ::String)\n  Closest candidates\
    \ are:\n    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpi0v18e3y.jl:7\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpi0v18e3y.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpi0v18e3y.jl:18\ntest set:\
    \ Error During Test at /tmp/tmpi0v18e3y.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at /shared/centos7/julia/1.7.3/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at /shared/centos7/julia/1.7.3/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n  \
    \   @ Main /tmp/tmpi0v18e3y.jl:7\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpi0v18e3y.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:"
  timestamp: 1659748316
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    paren_groups = split(paren_string, \" \")\n    paren_levels = zeros(Int64,\
    \ length(paren_groups))\n    for i in 1:length(paren_groups)\n        paren_levels[i]\
    \ = parse_parens(paren_groups[i])\n    end\n    return paren_levels\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmp6yhsp3qu.jl:16

    '
  stdout: "test set: Error During Test at /tmp/tmp6yhsp3qu.jl:19\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n  UndefVarError:\
    \ parse_parens not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp6yhsp3qu.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6yhsp3qu.jl:19 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6yhsp3qu.jl:18\ntest set:\
    \ Error During Test at /tmp/tmp6yhsp3qu.jl:20\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4]\n  UndefVarError: parse_parens\
    \ not defined\n  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n\
    \     @ Main /tmp/tmp6yhsp3qu.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6yhsp3qu.jl:20 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6yhsp3qu.jl:18\ntest set:\
    \ Error During Test at /tmp/tmp6yhsp3qu.jl:21\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [4]\n  UndefVarError: parse_parens not defined\n\
    \  Stacktrace:\n   [1] parse_nested_parens(paren_string::String)\n     @ Main\
    \ /tmp/tmp6yhsp3qu.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6yhsp3qu.jl:21 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6yhsp3qu.jl:18\nTest Summary:\
    \ | Error  Total\ntest set      |     3      3\n"
  timestamp: 1659748316
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    \"\"\"\n    paren_string = split(paren_string, \" \")\n  \
    \  output = []\n    for i in paren_string\n        max_level = 0\n        level\
    \ = 0\n        for j in i\n            if j == '('\n                level += 1\n\
    \            elseif j == ')'\n                level -= 1\n            end\n  \
    \          if level > max_level\n                max_level = level\n         \
    \   end\n        end\n        push!(output, max_level)\n    end\n    return output\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\") == [4])\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748314
- exit_code: 0
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    \"\"\"\n    Input: String of nested parentheses separated by spaces.\n\
    \    Output: Vector of maximum depth of nesting for each group.\n    \"\"\"\n\
    \    paren_groups = split(paren_string, \" \")\n    max_depth = []\n    for group\
    \ in paren_groups\n        depth = 0\n        max_depth_group = 0\n        for\
    \ char in group\n            if char == '('\n                depth += 1\n    \
    \        elseif char == ')'\n                depth -= 1\n            end\n   \
    \         if depth > max_depth_group\n                max_depth_group = depth\n\
    \            end\n        end\n        push!(max_depth, max_depth_group)\n   \
    \ end\n    return max_depth\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ parse_nested_parens;\n\t@test(candidate(\"(()()) ((())) () ((())()())\") ==\
    \ [2, 3, 1, 3])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [1, 2, 3, 4])\n\
    \t@test(candidate(\"(()(())((())))\") == [4])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    3      3

    '
  stdout: ''
  timestamp: 1659748314
- exit_code: 1
  program: "\"\"\" Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n    For each of the group, output\
    \ the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n\n        \"\"\"\nfunction parse_nested_parens(paren_string::String)::Vector{Int64}\
    \ \n    # Initialize an empty vector to store the depth of each group\n    depth_vec\
    \ = Int64[]\n    # Initialize a counter to keep track of the depth\n    depth\
    \ = 0\n    # Initialize a counter to keep track of the group\n    group = 0\n\
    \    # Iterate through each character in the string\n    for i in 1:length(paren_string)\n\
    \        # If the character is a left parenthesis, increment the depth counter\n\
    \        if paren_string[i] == '('\n            depth += 1\n        # If the character\
    \ is a right parenthesis, decrement the depth counter\n        elseif paren_string[i]\
    \ == ')'\n            depth -= 1\n        # If the character is a space, store\
    \ the current depth in the depth vector,\n        # and reset the depth counter\n\
    \        elseif paren_string[i] == ' '\n            push!(depth_vec, depth)\n\
    \            depth = 0\n        end\n    end\n    # Return the depth vector\n\
    \    return depth_vec\nend\nusing Test\n\n@testset begin\n\ncandidate = parse_nested_parens;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [1, 2, 3, 4])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [4])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp0k5d5cnu.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmp0k5d5cnu.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [2, 3, 1, 3]\n   Evaluated: [0, 0, 0] == [2,\
    \ 3, 1, 3]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0k5d5cnu.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0k5d5cnu.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp0k5d5cnu.jl:37\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4]\n   Evaluated: [0, 0, 0] == [1, 2, 3, 4]\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0k5d5cnu.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0k5d5cnu.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp0k5d5cnu.jl:38\n  Expression: candidate(\"(()(())((())))\"\
    ) == [4]\n   Evaluated: Int64[] == [4]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0k5d5cnu.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0k5d5cnu.jl:35\nTest Summary:\
    \ | Fail  Total\ntest set      |    3      3\n"
  timestamp: 1659748316
