language: jl
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_nodes) == 0\n        return []\n   \
    \ end\n    min_even = minimum(even_nodes)\n    min_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpz9auio6l.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpz9auio6l.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpz9auio6l.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpz9auio6l.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpz9auio6l.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpz9auio6l.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpz9auio6l.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpz9auio6l.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpz9auio6l.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpz9auio6l.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    return sort!(even_nodes)[1]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbus5303h.jl:43

    '
  stdout: "test set: Test Failed at /tmp/tmpbus5303h.jl:46\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbus5303h.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbus5303h.jl:45\ntest set: Test Failed at /tmp/tmpbus5303h.jl:47\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbus5303h.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbus5303h.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpbus5303h.jl:49\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbus5303h.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbus5303h.jl:45\ntest set: Test Failed at /tmp/tmpbus5303h.jl:50\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbus5303h.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbus5303h.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpbus5303h.jl:51\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    return sort!(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpgp74km2w.jl:43

    '
  stdout: "test set: Test Failed at /tmp/tmpgp74km2w.jl:46\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgp74km2w.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpgp74km2w.jl:45\ntest set: Test Failed at /tmp/tmpgp74km2w.jl:47\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgp74km2w.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgp74km2w.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpgp74km2w.jl:49\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgp74km2w.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpgp74km2w.jl:45\ntest set: Test Failed at /tmp/tmpgp74km2w.jl:50\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgp74km2w.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgp74km2w.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpgp74km2w.jl:51\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmp0mv597cc.jl:36

    '
  stdout: "test set: Error During Test at /tmp/tmp0mv597cc.jl:39\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0mv597cc.jl:31\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0mv597cc.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0mv597cc.jl:38\ntest set:\
    \ Error During Test at /tmp/tmp0mv597cc.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0mv597cc.jl:31\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0mv597cc.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0mv597cc.jl:38\ntest set:\
    \ Error During Test at /tmp/tmp0mv597cc.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmptwubc2j1.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmptwubc2j1.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmptwubc2j1.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptwubc2j1.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptwubc2j1.jl:33\ntest set:\
    \ Error During Test at /tmp/tmptwubc2j1.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmptwubc2j1.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptwubc2j1.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvytlc3h_.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpvytlc3h_.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even_value =\
    \ Inf\n    min_even_index = Inf\n    for i = 1:length(arr)\n        if arr[i]\
    \ % 2 == 0 && arr[i] < min_even_value\n            min_even_value = arr[i]\n \
    \           min_even_index = i\n        end\n    end\n    if min_even_value ==\
    \ Inf\n        return []\n    end\n    return [min_even_value, min_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbo1or7_x.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmpbo1or7_x.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbo1or7_x.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbo1or7_x.jl:47\ntest set: Test Failed at /tmp/tmpbo1or7_x.jl:49\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbo1or7_x.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbo1or7_x.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpbo1or7_x.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbo1or7_x.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbo1or7_x.jl:47\ntest set: Test Failed at /tmp/tmpbo1or7_x.jl:52\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbo1or7_x.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbo1or7_x.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpbo1or7_x.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx5r4tb4h.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpx5r4tb4h.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code goes here\n    return [0, 0]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpf3u5m8s3.jl:32

    '
  stdout: "test set: Test Failed at /tmp/tmpf3u5m8s3.jl:35\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf3u5m8s3.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpf3u5m8s3.jl:34\ntest set: Test Failed at /tmp/tmpf3u5m8s3.jl:36\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf3u5m8s3.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf3u5m8s3.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpf3u5m8s3.jl:37\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf3u5m8s3.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf3u5m8s3.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpf3u5m8s3.jl:38\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf3u5m8s3.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpf3u5m8s3.jl:34\ntest set: Test Failed at /tmp/tmpf3u5m8s3.jl:39\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 0] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = []\n \
    \   for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_arr,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_arr) == 0\n        return\
    \ []\n    end\n    min_val = even_arr[1][1]\n    min_idx = even_arr[1][2]\n  \
    \  for i in 2:length(even_arr)\n        if even_arr[i][1] < min_val\n        \
    \    min_val = even_arr[i][1]\n            min_idx = even_arr[i][2]\n        end\n\
    \    end\n    return [min_val, min_idx]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpuvfxdbz8.jl:51

    '
  stdout: "test set: Test Failed at /tmp/tmpuvfxdbz8.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpuvfxdbz8.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpuvfxdbz8.jl:53\ntest set: Test Failed at /tmp/tmpuvfxdbz8.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuvfxdbz8.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuvfxdbz8.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpuvfxdbz8.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpuvfxdbz8.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpuvfxdbz8.jl:53\ntest set: Test Failed at /tmp/tmpuvfxdbz8.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuvfxdbz8.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuvfxdbz8.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpuvfxdbz8.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp954t1pfb.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp954t1pfb.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [arr[i] for\
    \ i in 1:length(arr) if iseven(arr[i])]\n    if length(evens) == 0\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpezuwt2ye.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpezuwt2ye.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpezuwt2ye.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpezuwt2ye.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpezuwt2ye.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpezuwt2ye.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpezuwt2ye.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpezuwt2ye.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpezuwt2ye.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpezuwt2ye.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_index = Inf\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0 &&\
    \ arr[i] < min_even\n            min_even = arr[i]\n            min_index = i\n\
    \        end\n    end\n    if min_even == Inf\n        return []\n    end\n  \
    \  return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbo9gbwcc.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmpbo9gbwcc.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbo9gbwcc.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbo9gbwcc.jl:47\ntest set: Test Failed at /tmp/tmpbo9gbwcc.jl:49\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbo9gbwcc.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbo9gbwcc.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpbo9gbwcc.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbo9gbwcc.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbo9gbwcc.jl:47\ntest set: Test Failed at /tmp/tmpbo9gbwcc.jl:52\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbo9gbwcc.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbo9gbwcc.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpbo9gbwcc.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpdu3kx4vo.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpdu3kx4vo.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdu3kx4vo.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdu3kx4vo.jl:42\ntest set: Test Failed at /tmp/tmpdu3kx4vo.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdu3kx4vo.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdu3kx4vo.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpdu3kx4vo.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdu3kx4vo.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdu3kx4vo.jl:42\ntest set: Test Failed at /tmp/tmpdu3kx4vo.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdu3kx4vo.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdu3kx4vo.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpdu3kx4vo.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp954t1pfb.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp954t1pfb.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findall(arr .== min_even)[1]\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpa7i8yi9i.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpa7i8yi9i.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpa7i8yi9i.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpa7i8yi9i.jl:42\ntest set: Test Failed at /tmp/tmpa7i8yi9i.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa7i8yi9i.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa7i8yi9i.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpa7i8yi9i.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpa7i8yi9i.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpa7i8yi9i.jl:42\ntest set: Test Failed at /tmp/tmpa7i8yi9i.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa7i8yi9i.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa7i8yi9i.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpa7i8yi9i.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpg3_zodct.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpg3_zodct.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg3_zodct.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg3_zodct.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg3_zodct.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpg3_zodct.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg3_zodct.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg3_zodct.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg3_zodct.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpg3_zodct.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpffl98ui4.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpffl98ui4.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpffl98ui4.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpffl98ui4.jl:42\ntest set: Test Failed at /tmp/tmpffl98ui4.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpffl98ui4.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpffl98ui4.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpffl98ui4.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpffl98ui4.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpffl98ui4.jl:42\ntest set: Test Failed at /tmp/tmpffl98ui4.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpffl98ui4.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpffl98ui4.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpffl98ui4.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx5r4tb4h.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpx5r4tb4h.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpgb6xiieb.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmpgb6xiieb.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpgb6xiieb.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgb6xiieb.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgb6xiieb.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpgb6xiieb.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpgb6xiieb.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgb6xiieb.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgb6xiieb.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpgb6xiieb.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    smallest_even = minimum(evens)\n    index = findfirst(arr, smallest_even)\n\
    \    return [smallest_even, index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp6q9v4qwt.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp6q9v4qwt.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp6q9v4qwt.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6q9v4qwt.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6q9v4qwt.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp6q9v4qwt.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp6q9v4qwt.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6q9v4qwt.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6q9v4qwt.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp6q9v4qwt.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = [node\
    \ for node in arr if node % 2 == 0]\n    if length(even_nodes) == 0\n        return\
    \ []\n    end\n    min_even_node = minimum(even_nodes)\n    min_even_node_index\
    \ = findall(arr .== min_even_node)[1]\n    return [min_even_node, min_even_node_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp58klidqq.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmp58klidqq.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp58klidqq.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp58klidqq.jl:42\ntest set: Test Failed at /tmp/tmp58klidqq.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp58klidqq.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp58klidqq.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp58klidqq.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp58klidqq.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp58klidqq.jl:42\ntest set: Test Failed at /tmp/tmp58klidqq.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp58klidqq.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp58klidqq.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp58klidqq.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findall(arr .== min_even)[1]\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpy2eya_c0.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpy2eya_c0.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test Failed at /tmp/tmpy2eya_c0.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpy2eya_c0.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test Failed at /tmp/tmpy2eya_c0.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpy2eya_c0.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014593
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n\"\"\"\n    \"Given an array representing a branch\
    \ of a tree that has non-negative integer nodes\n    your task is to pluck one\
    \ of the nodes and return it.\n    The plucked node should be the node with the\
    \ smallest even value.\n    If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpqpb754sw.jl:29\nin expression starting at\
    \ /tmp/tmpqpb754sw.jl:29\n"
  stdout: ''
  timestamp: 1660014591
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_nodes) == 0\n        return []\n   \
    \ end\n    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp7gqi0_64.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp7gqi0_64.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7gqi0_64.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7gqi0_64.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7gqi0_64.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp7gqi0_64.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7gqi0_64.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7gqi0_64.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7gqi0_64.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp7gqi0_64.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvytlc3h_.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpvytlc3h_.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    smallest_even = minimum(even_nodes)\n    smallest_even_index = findfirst(arr,\
    \ smallest_even)\n    return [smallest_even, smallest_even_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp5ohq5ur6.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp5ohq5ur6.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5ohq5ur6.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5ohq5ur6.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5ohq5ur6.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp5ohq5ur6.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5ohq5ur6.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5ohq5ur6.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5ohq5ur6.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp5ohq5ur6.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014596
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for (i,\
    \ v) in enumerate(arr)\n        if v % 2 == 0\n            push!(evens, [v, i])\n\
    \        end\n    end\n    if isempty(evens)\n        return []\n    end\n   \
    \ return sort!(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8ssvqyxv.jl:43

    '
  stdout: "test set: Test Failed at /tmp/tmp8ssvqyxv.jl:46\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8ssvqyxv.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8ssvqyxv.jl:45\ntest set: Test Failed at /tmp/tmp8ssvqyxv.jl:47\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8ssvqyxv.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8ssvqyxv.jl:45\ntest set: Test\
    \ Failed at /tmp/tmp8ssvqyxv.jl:49\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8ssvqyxv.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8ssvqyxv.jl:45\ntest set: Test Failed at /tmp/tmp8ssvqyxv.jl:50\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8ssvqyxv.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8ssvqyxv.jl:45\ntest set: Test\
    \ Failed at /tmp/tmp8ssvqyxv.jl:51\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvytlc3h_.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpvytlc3h_.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code goes here\n    return [0, 0]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpf3u5m8s3.jl:32

    '
  stdout: "test set: Test Failed at /tmp/tmpf3u5m8s3.jl:35\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf3u5m8s3.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpf3u5m8s3.jl:34\ntest set: Test Failed at /tmp/tmpf3u5m8s3.jl:36\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf3u5m8s3.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf3u5m8s3.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpf3u5m8s3.jl:37\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf3u5m8s3.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf3u5m8s3.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpf3u5m8s3.jl:38\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf3u5m8s3.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpf3u5m8s3.jl:34\ntest set: Test Failed at /tmp/tmpf3u5m8s3.jl:39\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 0] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpg3_zodct.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpg3_zodct.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg3_zodct.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg3_zodct.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg3_zodct.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpg3_zodct.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg3_zodct.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg3_zodct.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg3_zodct.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpg3_zodct.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvytlc3h_.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpvytlc3h_.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [x for x\
    \ in arr if x % 2 == 0]\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp39y3g_ir.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp39y3g_ir.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp39y3g_ir.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp39y3g_ir.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp39y3g_ir.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp39y3g_ir.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp39y3g_ir.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp39y3g_ir.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp39y3g_ir.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp39y3g_ir.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmparcb4xca.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmparcb4xca.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmparcb4xca.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmparcb4xca.jl:42\ntest set: Test Failed at /tmp/tmparcb4xca.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmparcb4xca.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmparcb4xca.jl:42\ntest set: Test\
    \ Failed at /tmp/tmparcb4xca.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmparcb4xca.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmparcb4xca.jl:42\ntest set: Test Failed at /tmp/tmparcb4xca.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmparcb4xca.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmparcb4xca.jl:42\ntest set: Test\
    \ Failed at /tmp/tmparcb4xca.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmparcb4xca.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmparcb4xca.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmparcb4xca.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmparcb4xca.jl:42\ntest set: Test Failed at /tmp/tmparcb4xca.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmparcb4xca.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmparcb4xca.jl:42\ntest set: Test\
    \ Failed at /tmp/tmparcb4xca.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmparcb4xca.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmparcb4xca.jl:42\ntest set: Test Failed at /tmp/tmparcb4xca.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmparcb4xca.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmparcb4xca.jl:42\ntest set: Test\
    \ Failed at /tmp/tmparcb4xca.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_nodes) == 0\n        return []\n   \
    \ end\n    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp7gqi0_64.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp7gqi0_64.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7gqi0_64.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7gqi0_64.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7gqi0_64.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp7gqi0_64.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7gqi0_64.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7gqi0_64.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7gqi0_64.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp7gqi0_64.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [x for x\
    \ in arr if x % 2 == 0]\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp39y3g_ir.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp39y3g_ir.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp39y3g_ir.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp39y3g_ir.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp39y3g_ir.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp39y3g_ir.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp39y3g_ir.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp39y3g_ir.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp39y3g_ir.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp39y3g_ir.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpffl98ui4.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpffl98ui4.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpffl98ui4.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpffl98ui4.jl:42\ntest set: Test Failed at /tmp/tmpffl98ui4.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpffl98ui4.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpffl98ui4.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpffl98ui4.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpffl98ui4.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpffl98ui4.jl:42\ntest set: Test Failed at /tmp/tmpffl98ui4.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpffl98ui4.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpffl98ui4.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpffl98ui4.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpno4s7o_m.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpno4s7o_m.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [arr[i] for\
    \ i in 1:length(arr) if arr[i] % 2 == 0]\n    if length(evens) == 0\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp0flac5dl.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp0flac5dl.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0flac5dl.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0flac5dl.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0flac5dl.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp0flac5dl.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0flac5dl.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0flac5dl.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0flac5dl.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp0flac5dl.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014596
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code goes here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp1c4qpw4v.jl:32

    '
  stdout: "test set: Test Failed at /tmp/tmp1c4qpw4v.jl:35\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1c4qpw4v.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp1c4qpw4v.jl:34\ntest set: Test Failed at /tmp/tmp1c4qpw4v.jl:36\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1c4qpw4v.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1c4qpw4v.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp1c4qpw4v.jl:38\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1c4qpw4v.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp1c4qpw4v.jl:34\ntest set: Test Failed at /tmp/tmp1c4qpw4v.jl:39\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: Int64[]\
    \ == [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1c4qpw4v.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1c4qpw4v.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp1c4qpw4v.jl:40\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1."
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpno4s7o_m.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpno4s7o_m.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp954t1pfb.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp954t1pfb.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpno4s7o_m.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpno4s7o_m.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp954t1pfb.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp954t1pfb.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: -1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code goes here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: "test set: Error During Test at /tmp/tmpl8qwz0md.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpl8qwz0md.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpl8qwz0md.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpl8qwz0md.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpl8qwz0md.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpl8qwz0md.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpl8qwz0md.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nums = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nums) == 0\n        return\
    \ []\n    end\n    even_nums = sort(even_nums, by = x -> x[1])\n    return even_nums[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp0p3ynd17.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp0p3ynd17.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0p3ynd17.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0p3ynd17.jl:46\ntest set: Test Failed at /tmp/tmp0p3ynd17.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0p3ynd17.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0p3ynd17.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp0p3ynd17.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0p3ynd17.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0p3ynd17.jl:46\ntest set: Test Failed at /tmp/tmp0p3ynd17.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0p3ynd17.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0p3ynd17.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp0p3ynd17.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = []\n   \
    \ for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_nodes)\n        return\
    \ []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return even_nodes[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp90kkd_40.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp90kkd_40.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = []\n   \
    \ for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_nodes)\n        return\
    \ []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return even_nodes[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp90kkd_40.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp90kkd_40.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_index = -1\n    for i in 1:length(arr)\n        if arr[i] % 2 ==\
    \ 0 && arr[i] < min_even\n            min_even = arr[i]\n            min_even_index\
    \ = i\n        end\n    end\n    if min_even_index == -1\n        return []\n\
    \    end\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmphwoqwa_0.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmphwoqwa_0.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphwoqwa_0.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmphwoqwa_0.jl:47\ntest set: Test Failed at /tmp/tmphwoqwa_0.jl:49\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphwoqwa_0.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphwoqwa_0.jl:47\ntest set: Test\
    \ Failed at /tmp/tmphwoqwa_0.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphwoqwa_0.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmphwoqwa_0.jl:47\ntest set: Test Failed at /tmp/tmphwoqwa_0.jl:52\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphwoqwa_0.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphwoqwa_0.jl:47\ntest set: Test\
    \ Failed at /tmp/tmphwoqwa_0.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findall(arr .== min_even)[1]\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpy2eya_c0.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpy2eya_c0.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test Failed at /tmp/tmpy2eya_c0.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpy2eya_c0.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test Failed at /tmp/tmpy2eya_c0.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpy2eya_c0.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014593
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [node for\
    \ node in arr if node % 2 == 0]\n    if isempty(even_nodes)\n        return []\n\
    \    end\n    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp4f2ngeya.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp4f2ngeya.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4f2ngeya.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4f2ngeya.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4f2ngeya.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp4f2ngeya.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4f2ngeya.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4f2ngeya.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4f2ngeya.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp4f2ngeya.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(evens, [v,\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp4ps5er0t.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp4ps5er0t.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp4ps5er0t.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp4ps5er0t.jl:46\ntest set: Test Failed at /tmp/tmp4ps5er0t.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4ps5er0t.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4ps5er0t.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp4ps5er0t.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp4ps5er0t.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp4ps5er0t.jl:46\ntest set: Test Failed at /tmp/tmp4ps5er0t.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4ps5er0t.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4ps5er0t.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp4ps5er0t.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014596
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = []\n   \
    \ for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_nodes)\n        return\
    \ []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return even_nodes[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp90kkd_40.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp90kkd_40.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp954t1pfb.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp954t1pfb.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp8rw9kryl.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp8rw9kryl.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8rw9kryl.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8rw9kryl.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8rw9kryl.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp8rw9kryl.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8rw9kryl.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8rw9kryl.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8rw9kryl.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp8rw9kryl.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_values)\n        return\
    \ []\n    end\n    even_values = sort(even_values, by = x -> x[1])\n    return\
    \ even_values[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpcycoi7k2.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpcycoi7k2.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcycoi7k2.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpcycoi7k2.jl:46\ntest set: Test Failed at /tmp/tmpcycoi7k2.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcycoi7k2.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcycoi7k2.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpcycoi7k2.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcycoi7k2.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpcycoi7k2.jl:46\ntest set: Test Failed at /tmp/tmpcycoi7k2.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcycoi7k2.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcycoi7k2.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpcycoi7k2.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014596
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpvp5180h3.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpvp5180h3.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvp5180h3.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvp5180h3.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvp5180h3.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpvp5180h3.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvp5180h3.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvp5180h3.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvp5180h3.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpvp5180h3.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmpqafd9hb0.jl:36

    '
  stdout: "test set: Error During Test at /tmp/tmpqafd9hb0.jl:39\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqafd9hb0.jl:31\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqafd9hb0.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqafd9hb0.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpqafd9hb0.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqafd9hb0.jl:31\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqafd9hb0.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqafd9hb0.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpqafd9hb0.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014599
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = []\n   \
    \ for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_nodes)\n        return\
    \ []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return even_nodes[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp90kkd_40.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp90kkd_40.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [arr[i] for\
    \ i in 1:length(arr) if iseven(arr[i])]\n    if length(evens) == 0\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_index = findall(arr\
    \ .== min_even)[1]\n    return [min_even, min_even_index]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9vzizddb.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmp9vzizddb.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9vzizddb.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9vzizddb.jl:42\ntest set: Test Failed at /tmp/tmp9vzizddb.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9vzizddb.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9vzizddb.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp9vzizddb.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9vzizddb.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9vzizddb.jl:42\ntest set: Test Failed at /tmp/tmp9vzizddb.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9vzizddb.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9vzizddb.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp9vzizddb.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpno4s7o_m.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpno4s7o_m.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpno4s7o_m.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpno4s7o_m.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [x for x\
    \ in arr if x % 2 == 0]\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp39y3g_ir.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp39y3g_ir.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp39y3g_ir.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp39y3g_ir.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp39y3g_ir.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp39y3g_ir.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp39y3g_ir.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp39y3g_ir.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp39y3g_ir.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp39y3g_ir.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    if all(x -> x % 2 !=\
    \ 0, arr)\n        return []\n    end\n    evens = filter(x -> x % 2 == 0, arr)\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmplydck9bg.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmplydck9bg.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmplydck9bg.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplydck9bg.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplydck9bg.jl:42\ntest set:\
    \ Error During Test at /tmp/tmplydck9bg.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmplydck9bg.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmplydck9bg.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmplydck9bg.jl:42\ntest set:\
    \ Error During Test at /tmp/tmplydck9bg.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp8rw9kryl.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp8rw9kryl.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8rw9kryl.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8rw9kryl.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8rw9kryl.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp8rw9kryl.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8rw9kryl.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8rw9kryl.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8rw9kryl.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp8rw9kryl.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp954t1pfb.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp954t1pfb.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpiyc824nd.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpiyc824nd.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = []\n   \
    \ for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_nodes)\n        return\
    \ []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return even_nodes[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp90kkd_40.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp90kkd_40.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_index = Inf\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n\
    \            if arr[i] < min_even\n                min_even = arr[i]\n       \
    \         min_index = i\n            end\n        end\n    end\n    if min_even\
    \ == Inf\n        return []\n    end\n    return [min_even, min_index]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpxm4aqu3r.jl:47

    '
  stdout: "test set: Test Failed at /tmp/tmpxm4aqu3r.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxm4aqu3r.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpxm4aqu3r.jl:49\ntest set: Test Failed at /tmp/tmpxm4aqu3r.jl:51\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxm4aqu3r.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxm4aqu3r.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpxm4aqu3r.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxm4aqu3r.jl:53 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpxm4aqu3r.jl:49\ntest set: Test Failed at /tmp/tmpxm4aqu3r.jl:54\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxm4aqu3r.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxm4aqu3r.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpxm4aqu3r.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nums = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nums) == 0\n        return\
    \ []\n    end\n    even_nums = sort(even_nums, by = x -> x[1])\n    return even_nums[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp0p3ynd17.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp0p3ynd17.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0p3ynd17.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0p3ynd17.jl:46\ntest set: Test Failed at /tmp/tmp0p3ynd17.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0p3ynd17.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0p3ynd17.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp0p3ynd17.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0p3ynd17.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0p3ynd17.jl:46\ntest set: Test Failed at /tmp/tmp0p3ynd17.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0p3ynd17.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0p3ynd17.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp0p3ynd17.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpi2knwof0.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpi2knwof0.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test Failed at /tmp/tmpi2knwof0.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpi2knwof0.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test Failed at /tmp/tmpi2knwof0.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpi2knwof0.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx5r4tb4h.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpx5r4tb4h.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = []\n   \
    \ for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_nodes)\n        return\
    \ []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return even_nodes[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp90kkd_40.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp90kkd_40.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpvp5180h3.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpvp5180h3.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvp5180h3.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvp5180h3.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvp5180h3.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpvp5180h3.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvp5180h3.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvp5180h3.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvp5180h3.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpvp5180h3.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_values) == 0\n      \
    \  return []\n    end\n    min_value = even_values[1][1]\n    min_index = even_values[1][2]\n\
    \    for i in 2:length(even_values)\n        if even_values[i][1] < min_value\n\
    \            min_value = even_values[i][1]\n            min_index = even_values[i][2]\n\
    \        end\n    end\n    return [min_value, min_index]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpv33mc7wi.jl:51

    '
  stdout: "test set: Test Failed at /tmp/tmpv33mc7wi.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpv33mc7wi.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpv33mc7wi.jl:53\ntest set: Test Failed at /tmp/tmpv33mc7wi.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv33mc7wi.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv33mc7wi.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpv33mc7wi.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpv33mc7wi.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpv33mc7wi.jl:53\ntest set: Test Failed at /tmp/tmpv33mc7wi.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv33mc7wi.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv33mc7wi.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpv33mc7wi.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [x for x\
    \ in arr if x % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    evens_idx = [i for (i, x) in enumerate(arr) if x % 2 == 0]\n    min_even\
    \ = minimum(evens)\n    min_even_idx = evens_idx[findfirst(evens, min_even)]\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp5b8hb39g.jl:41

    '
  stdout: "test set: Error During Test at /tmp/tmp5b8hb39g.jl:44\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5b8hb39g.jl:36\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5b8hb39g.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5b8hb39g.jl:43\ntest set:\
    \ Error During Test at /tmp/tmp5b8hb39g.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5b8hb39g.jl:36\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5b8hb39g.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5b8hb39g.jl:43\ntest set:\
    \ Error During Test at /tmp/tmp5b8hb39g.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014599
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findall(arr .== min_even)[1]\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpy2eya_c0.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpy2eya_c0.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test Failed at /tmp/tmpy2eya_c0.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpy2eya_c0.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test Failed at /tmp/tmpy2eya_c0.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpy2eya_c0.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014593
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    smallest_even\
    \ = minimum(evens)\n    smallest_even_index = findfirst(arr, smallest_even)\n\
    \    return [smallest_even, smallest_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpieoun_wc.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpieoun_wc.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpieoun_wc.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpieoun_wc.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpieoun_wc.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpieoun_wc.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpieoun_wc.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpieoun_wc.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpieoun_wc.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpieoun_wc.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014599
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmptwubc2j1.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmptwubc2j1.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmptwubc2j1.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptwubc2j1.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmptwubc2j1.jl:33\ntest set:\
    \ Error During Test at /tmp/tmptwubc2j1.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmptwubc2j1.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmptwubc2j1.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_nodes) == 0\n        return []\n   \
    \ end\n    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp7gqi0_64.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp7gqi0_64.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7gqi0_64.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7gqi0_64.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7gqi0_64.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp7gqi0_64.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7gqi0_64.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7gqi0_64.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7gqi0_64.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp7gqi0_64.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    smallest_even = minimum(evens)\n    smallest_even_index = findfirst(arr,\
    \ smallest_even)\n    return [smallest_even, smallest_even_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpfr00ddnm.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpfr00ddnm.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfr00ddnm.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfr00ddnm.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfr00ddnm.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpfr00ddnm.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfr00ddnm.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfr00ddnm.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfr00ddnm.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpfr00ddnm.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014599
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n \nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpj_wh4mo2.jl:32

    '
  stdout: "test set: Error During Test at /tmp/tmpj_wh4mo2.jl:35\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpj_wh4mo2.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpj_wh4mo2.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpj_wh4mo2.jl:34\ntest set:\
    \ Error During Test at /tmp/tmpj_wh4mo2.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpj_wh4mo2.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpj_wh4mo2.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014600
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp0sh0i226.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp0sh0i226.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0sh0i226.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0sh0i226.jl:46\ntest set: Test Failed at /tmp/tmp0sh0i226.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0sh0i226.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0sh0i226.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp0sh0i226.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0sh0i226.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0sh0i226.jl:46\ntest set: Test Failed at /tmp/tmp0sh0i226.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0sh0i226.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0sh0i226.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp0sh0i226.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = [arr[i]\
    \ for i in 1:length(arr) if iseven(arr[i])]\n    if length(even_nodes) == 0\n\
    \        return []\n    end\n    min_even = minimum(even_nodes)\n    min_even_index\
    \ = findall(arr .== min_even)[1]\n    return [min_even, min_even_index]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbv70da8h.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpbv70da8h.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbv70da8h.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbv70da8h.jl:42\ntest set: Test Failed at /tmp/tmpbv70da8h.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbv70da8h.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbv70da8h.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpbv70da8h.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbv70da8h.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbv70da8h.jl:42\ntest set: Test Failed at /tmp/tmpbv70da8h.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbv70da8h.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbv70da8h.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpbv70da8h.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [arr[i] for i\
    \ in 1:length(arr) if iseven(arr[i])]\n    if isempty(evens)\n        return []\n\
    \    end\n    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp8cg0dr9k.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp8cg0dr9k.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8cg0dr9k.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8cg0dr9k.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8cg0dr9k.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp8cg0dr9k.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8cg0dr9k.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8cg0dr9k.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8cg0dr9k.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp8cg0dr9k.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014600
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp954t1pfb.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp954t1pfb.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx5r4tb4h.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpx5r4tb4h.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = [x for\
    \ x in arr if x % 2 == 0]\n    if length(even_nodes) == 0\n        return []\n\
    \    end\n    even_nodes = sort(even_nodes)\n    smallest_even = even_nodes[1]\n\
    \    smallest_even_index = findfirst(arr, smallest_even)\n    return [smallest_even,\
    \ smallest_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpyi39lcv9.jl:41

    '
  stdout: "test set: Error During Test at /tmp/tmpyi39lcv9.jl:44\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpyi39lcv9.jl:36\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpyi39lcv9.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpyi39lcv9.jl:43\ntest set:\
    \ Error During Test at /tmp/tmpyi39lcv9.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpyi39lcv9.jl:36\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpyi39lcv9.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpyi39lcv9.jl:43\ntest set:\
    \ Error During Test at /tmp/tmpyi39lcv9.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014601
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nums = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ arr[i])\n        end\n    end\n    if length(even_nums) == 0\n        return\
    \ []\n    end\n    min_even = minimum(even_nums)\n    min_even_index = findall(arr\
    \ .== min_even)[1]\n    return [min_even, min_even_index]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkhkpm1n8.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmpkhkpm1n8.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkhkpm1n8.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkhkpm1n8.jl:47\ntest set: Test Failed at /tmp/tmpkhkpm1n8.jl:49\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkhkpm1n8.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkhkpm1n8.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpkhkpm1n8.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkhkpm1n8.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkhkpm1n8.jl:47\ntest set: Test Failed at /tmp/tmpkhkpm1n8.jl:52\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkhkpm1n8.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkhkpm1n8.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpkhkpm1n8.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014599
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpvp5180h3.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpvp5180h3.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvp5180h3.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvp5180h3.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvp5180h3.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpvp5180h3.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvp5180h3.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvp5180h3.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvp5180h3.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpvp5180h3.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [arr[i] for i\
    \ in 1:length(arr) if iseven(arr[i])]\n    if isempty(evens)\n        return []\n\
    \    end\n    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp8cg0dr9k.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp8cg0dr9k.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8cg0dr9k.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8cg0dr9k.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8cg0dr9k.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp8cg0dr9k.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8cg0dr9k.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8cg0dr9k.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8cg0dr9k.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp8cg0dr9k.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014600
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    return sort!(even_nodes)[1]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbus5303h.jl:43

    '
  stdout: "test set: Test Failed at /tmp/tmpbus5303h.jl:46\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbus5303h.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbus5303h.jl:45\ntest set: Test Failed at /tmp/tmpbus5303h.jl:47\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbus5303h.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbus5303h.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpbus5303h.jl:49\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbus5303h.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbus5303h.jl:45\ntest set: Test Failed at /tmp/tmpbus5303h.jl:50\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbus5303h.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbus5303h.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpbus5303h.jl:51\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpno4s7o_m.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpno4s7o_m.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findall(arr .== min_even)[1]\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpy2eya_c0.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpy2eya_c0.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test Failed at /tmp/tmpy2eya_c0.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpy2eya_c0.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test Failed at /tmp/tmpy2eya_c0.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpy2eya_c0.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014593
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpvp5180h3.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpvp5180h3.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvp5180h3.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvp5180h3.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvp5180h3.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpvp5180h3.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvp5180h3.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvp5180h3.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvp5180h3.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpvp5180h3.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_values)\n        return\
    \ []\n    end\n    even_values = sort(even_values, by = x -> x[1])\n    return\
    \ even_values[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpcycoi7k2.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpcycoi7k2.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcycoi7k2.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpcycoi7k2.jl:46\ntest set: Test Failed at /tmp/tmpcycoi7k2.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcycoi7k2.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcycoi7k2.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpcycoi7k2.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcycoi7k2.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpcycoi7k2.jl:46\ntest set: Test Failed at /tmp/tmpcycoi7k2.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcycoi7k2.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcycoi7k2.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpcycoi7k2.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014596
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = []\n \
    \   for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_arr,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_arr) == 0\n        return\
    \ []\n    end\n    even_arr = sort(even_arr, by = x -> x[1])\n    return even_arr[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpcvni18xl.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpcvni18xl.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcvni18xl.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpcvni18xl.jl:46\ntest set: Test Failed at /tmp/tmpcvni18xl.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcvni18xl.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcvni18xl.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpcvni18xl.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcvni18xl.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpcvni18xl.jl:46\ntest set: Test Failed at /tmp/tmpcvni18xl.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcvni18xl.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcvni18xl.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpcvni18xl.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014599
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpiyc824nd.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpiyc824nd.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmpqafd9hb0.jl:36

    '
  stdout: "test set: Error During Test at /tmp/tmpqafd9hb0.jl:39\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqafd9hb0.jl:31\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqafd9hb0.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqafd9hb0.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpqafd9hb0.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqafd9hb0.jl:31\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqafd9hb0.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqafd9hb0.jl:38\ntest set:\
    \ Error During Test at /tmp/tmpqafd9hb0.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014599
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for (i, node) in enumerate(arr)\n        if node % 2 == 0\n            push!(even_nodes,\
    \ [node, i])\n        end\n    end\n    if length(even_nodes) == 0\n        return\
    \ []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return even_nodes[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpdeg0jj_m.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpdeg0jj_m.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdeg0jj_m.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdeg0jj_m.jl:46\ntest set: Test Failed at /tmp/tmpdeg0jj_m.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdeg0jj_m.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdeg0jj_m.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpdeg0jj_m.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdeg0jj_m.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdeg0jj_m.jl:46\ntest set: Test Failed at /tmp/tmpdeg0jj_m.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdeg0jj_m.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdeg0jj_m.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpdeg0jj_m.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014599
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findall(arr .== min_even)[1]\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5dmzdbve.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmp5dmzdbve.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp5dmzdbve.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp5dmzdbve.jl:42\ntest set: Test Failed at /tmp/tmp5dmzdbve.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5dmzdbve.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5dmzdbve.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5dmzdbve.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp5dmzdbve.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp5dmzdbve.jl:42\ntest set: Test Failed at /tmp/tmp5dmzdbve.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5dmzdbve.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5dmzdbve.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5dmzdbve.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014599
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    smallest\
    \ = minimum(evens)\n    index = findfirst(arr, smallest)\n    return [smallest,\
    \ index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpn9z6htgh.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpn9z6htgh.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpn9z6htgh.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpn9z6htgh.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpn9z6htgh.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpn9z6htgh.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpn9z6htgh.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpn9z6htgh.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpn9z6htgh.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpn9z6htgh.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014601
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpiyc824nd.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpiyc824nd.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    smallest_even = minimum(even_nodes)\n    smallest_even_index = findfirst(arr,\
    \ smallest_even)\n    return [smallest_even, smallest_even_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp5ohq5ur6.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp5ohq5ur6.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5ohq5ur6.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5ohq5ur6.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5ohq5ur6.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp5ohq5ur6.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp5ohq5ur6.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp5ohq5ur6.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp5ohq5ur6.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp5ohq5ur6.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014596
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_index = -1\n    for i in 1:length(arr)\n        if arr[i] % 2 ==\
    \ 0 && arr[i] < min_even\n            min_even = arr[i]\n            min_even_index\
    \ = i\n        end\n    end\n    if min_even_index == -1\n        return []\n\
    \    end\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmphwoqwa_0.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmphwoqwa_0.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphwoqwa_0.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmphwoqwa_0.jl:47\ntest set: Test Failed at /tmp/tmphwoqwa_0.jl:49\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphwoqwa_0.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphwoqwa_0.jl:47\ntest set: Test\
    \ Failed at /tmp/tmphwoqwa_0.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphwoqwa_0.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmphwoqwa_0.jl:47\ntest set: Test Failed at /tmp/tmphwoqwa_0.jl:52\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphwoqwa_0.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphwoqwa_0.jl:47\ntest set: Test\
    \ Failed at /tmp/tmphwoqwa_0.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findall(arr .== min_even)[1]\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpy2eya_c0.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpy2eya_c0.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test Failed at /tmp/tmpy2eya_c0.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpy2eya_c0.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test Failed at /tmp/tmpy2eya_c0.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy2eya_c0.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy2eya_c0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpy2eya_c0.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014593
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = Inf\n    min_even_index\
    \ = -1\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0 && arr[i] < min_even\n\
    \            min_even = arr[i]\n            min_even_index = i\n        end\n\
    \    end\n    if min_even_index == -1\n        return []\n    end\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpnn85jimv.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmpnn85jimv.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnn85jimv.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnn85jimv.jl:47\ntest set: Test Failed at /tmp/tmpnn85jimv.jl:49\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnn85jimv.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnn85jimv.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpnn85jimv.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnn85jimv.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnn85jimv.jl:47\ntest set: Test Failed at /tmp/tmpnn85jimv.jl:52\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnn85jimv.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnn85jimv.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpnn85jimv.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014599
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(evens, [v,\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    sort!(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp4eir0qd9.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp4eir0qd9.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp4eir0qd9.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp4eir0qd9.jl:46\ntest set: Test Failed at /tmp/tmp4eir0qd9.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4eir0qd9.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4eir0qd9.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp4eir0qd9.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp4eir0qd9.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp4eir0qd9.jl:46\ntest set: Test Failed at /tmp/tmp4eir0qd9.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4eir0qd9.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4eir0qd9.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp4eir0qd9.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014600
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx5r4tb4h.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpx5r4tb4h.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpg3_zodct.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpg3_zodct.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg3_zodct.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg3_zodct.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg3_zodct.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpg3_zodct.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg3_zodct.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg3_zodct.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg3_zodct.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpg3_zodct.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_value = Inf\n\
    \    min_index = Inf\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0 &&\
    \ arr[i] < min_value\n            min_value = arr[i]\n            min_index =\
    \ i\n        end\n    end\n    if min_value == Inf\n        return []\n    end\n\
    \    return [min_value, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpq0up5oqm.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmpq0up5oqm.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpq0up5oqm.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpq0up5oqm.jl:47\ntest set: Test Failed at /tmp/tmpq0up5oqm.jl:49\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq0up5oqm.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq0up5oqm.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpq0up5oqm.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpq0up5oqm.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpq0up5oqm.jl:47\ntest set: Test Failed at /tmp/tmpq0up5oqm.jl:52\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpq0up5oqm.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq0up5oqm.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpq0up5oqm.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014600
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx5r4tb4h.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpx5r4tb4h.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx5r4tb4h.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpx5r4tb4h.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpno4s7o_m.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpno4s7o_m.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nums)\n        return []\n    end\n\
    \    min_even = minimum(even_nums)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpyuuh88uk.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpyuuh88uk.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpyuuh88uk.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpyuuh88uk.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpyuuh88uk.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpyuuh88uk.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpyuuh88uk.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpyuuh88uk.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpyuuh88uk.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpyuuh88uk.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014602
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    if isempty(min_even)\n        return []\n    end\n\
    \    return [min_even, findfirst(arr, min_even)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmpogdy5wzc.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpogdy5wzc.jl:41\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpogdy5wzc.jl:34\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpogdy5wzc.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpogdy5wzc.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpogdy5wzc.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpogdy5wzc.jl:34\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpogdy5wzc.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpogdy5wzc.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpogdy5wzc.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014602
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findall(arr .== min_even)[1]\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5dmzdbve.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmp5dmzdbve.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp5dmzdbve.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp5dmzdbve.jl:42\ntest set: Test Failed at /tmp/tmp5dmzdbve.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5dmzdbve.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5dmzdbve.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5dmzdbve.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp5dmzdbve.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp5dmzdbve.jl:42\ntest set: Test Failed at /tmp/tmp5dmzdbve.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5dmzdbve.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5dmzdbve.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5dmzdbve.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014599
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp954t1pfb.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp954t1pfb.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpno4s7o_m.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpno4s7o_m.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvytlc3h_.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpvytlc3h_.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(evens, [v,\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    return sort!(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmphgv4k4g6.jl:43

    '
  stdout: "test set: Test Failed at /tmp/tmphgv4k4g6.jl:46\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphgv4k4g6.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmphgv4k4g6.jl:45\ntest set: Test Failed at /tmp/tmphgv4k4g6.jl:47\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphgv4k4g6.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphgv4k4g6.jl:45\ntest set: Test\
    \ Failed at /tmp/tmphgv4k4g6.jl:49\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphgv4k4g6.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmphgv4k4g6.jl:45\ntest set: Test Failed at /tmp/tmphgv4k4g6.jl:50\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphgv4k4g6.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphgv4k4g6.jl:45\ntest set: Test\
    \ Failed at /tmp/tmphgv4k4g6.jl:51\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014601
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [x for x\
    \ in arr if x % 2 == 0]\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp39y3g_ir.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp39y3g_ir.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp39y3g_ir.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp39y3g_ir.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp39y3g_ir.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp39y3g_ir.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp39y3g_ir.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp39y3g_ir.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp39y3g_ir.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp39y3g_ir.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = []\n   \
    \ for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_nodes)\n        return\
    \ []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return even_nodes[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp90kkd_40.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp90kkd_40.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmparcb4xca.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmparcb4xca.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmparcb4xca.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmparcb4xca.jl:42\ntest set: Test Failed at /tmp/tmparcb4xca.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmparcb4xca.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmparcb4xca.jl:42\ntest set: Test\
    \ Failed at /tmp/tmparcb4xca.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmparcb4xca.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmparcb4xca.jl:42\ntest set: Test Failed at /tmp/tmparcb4xca.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmparcb4xca.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmparcb4xca.jl:42\ntest set: Test\
    \ Failed at /tmp/tmparcb4xca.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpg3_zodct.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpg3_zodct.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg3_zodct.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg3_zodct.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg3_zodct.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpg3_zodct.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg3_zodct.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg3_zodct.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg3_zodct.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpg3_zodct.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [arr[i] for\
    \ i in 1:length(arr) if arr[i] % 2 == 0]\n    if length(evens) == 0\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp0flac5dl.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp0flac5dl.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0flac5dl.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0flac5dl.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0flac5dl.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp0flac5dl.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0flac5dl.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0flac5dl.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0flac5dl.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp0flac5dl.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014596
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpno4s7o_m.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpno4s7o_m.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = []\n   \
    \ for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_nodes)\n        return\
    \ []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return even_nodes[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp90kkd_40.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp90kkd_40.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test Failed at /tmp/tmp90kkd_40.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp90kkd_40.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp90kkd_40.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp90kkd_40.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    return sort(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb4woqvnu.jl:43

    '
  stdout: "test set: Test Failed at /tmp/tmpb4woqvnu.jl:46\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpb4woqvnu.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpb4woqvnu.jl:45\ntest set: Test Failed at /tmp/tmpb4woqvnu.jl:47\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb4woqvnu.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb4woqvnu.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpb4woqvnu.jl:49\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpb4woqvnu.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpb4woqvnu.jl:45\ntest set: Test Failed at /tmp/tmpb4woqvnu.jl:50\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb4woqvnu.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb4woqvnu.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpb4woqvnu.jl:51\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014601
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx5r4tb4h.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpx5r4tb4h.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    return sort!(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpxbdmarwi.jl:43

    '
  stdout: "test set: Test Failed at /tmp/tmpxbdmarwi.jl:46\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxbdmarwi.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpxbdmarwi.jl:45\ntest set: Test Failed at /tmp/tmpxbdmarwi.jl:47\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxbdmarwi.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxbdmarwi.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpxbdmarwi.jl:49\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxbdmarwi.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpxbdmarwi.jl:45\ntest set: Test Failed at /tmp/tmpxbdmarwi.jl:50\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxbdmarwi.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxbdmarwi.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpxbdmarwi.jl:51\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014601
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp0sh0i226.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp0sh0i226.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0sh0i226.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0sh0i226.jl:46\ntest set: Test Failed at /tmp/tmp0sh0i226.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0sh0i226.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0sh0i226.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp0sh0i226.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0sh0i226.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0sh0i226.jl:46\ntest set: Test Failed at /tmp/tmp0sh0i226.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0sh0i226.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0sh0i226.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp0sh0i226.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpg3_zodct.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpg3_zodct.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg3_zodct.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg3_zodct.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg3_zodct.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpg3_zodct.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg3_zodct.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg3_zodct.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg3_zodct.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpg3_zodct.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpi2knwof0.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpi2knwof0.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test Failed at /tmp/tmpi2knwof0.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpi2knwof0.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test Failed at /tmp/tmpi2knwof0.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpi2knwof0.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpffl98ui4.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpffl98ui4.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpffl98ui4.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpffl98ui4.jl:42\ntest set: Test Failed at /tmp/tmpffl98ui4.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpffl98ui4.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpffl98ui4.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpffl98ui4.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpffl98ui4.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpffl98ui4.jl:42\ntest set: Test Failed at /tmp/tmpffl98ui4.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpffl98ui4.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpffl98ui4.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpffl98ui4.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx5r4tb4h.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpx5r4tb4h.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpno4s7o_m.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpno4s7o_m.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvytlc3h_.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpvytlc3h_.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findall(arr .== min_even)[1]\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpylv5gmmf.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpylv5gmmf.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpylv5gmmf.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpylv5gmmf.jl:42\ntest set: Test Failed at /tmp/tmpylv5gmmf.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpylv5gmmf.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpylv5gmmf.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpylv5gmmf.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpylv5gmmf.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpylv5gmmf.jl:42\ntest set: Test Failed at /tmp/tmpylv5gmmf.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpylv5gmmf.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpylv5gmmf.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpylv5gmmf.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014601
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpno4s7o_m.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpno4s7o_m.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if iseven(arr[i])\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8rcm73o_.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp8rcm73o_.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8rcm73o_.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8rcm73o_.jl:46\ntest set: Test Failed at /tmp/tmp8rcm73o_.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8rcm73o_.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8rcm73o_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp8rcm73o_.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8rcm73o_.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8rcm73o_.jl:46\ntest set: Test Failed at /tmp/tmp8rcm73o_.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8rcm73o_.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8rcm73o_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp8rcm73o_.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014601
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx5r4tb4h.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpx5r4tb4h.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpno4s7o_m.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpno4s7o_m.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort!(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp59k1qha1.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp59k1qha1.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp59k1qha1.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp59k1qha1.jl:46\ntest set: Test Failed at /tmp/tmp59k1qha1.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp59k1qha1.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp59k1qha1.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp59k1qha1.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp59k1qha1.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp59k1qha1.jl:46\ntest set: Test Failed at /tmp/tmp59k1qha1.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp59k1qha1.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp59k1qha1.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp59k1qha1.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014601
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpno4s7o_m.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpno4s7o_m.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_index = -1\n    for i in 1:length(arr)\n        if iseven(arr[i]) &&\
    \ arr[i] < min_even\n            min_even = arr[i]\n            min_index = i\n\
    \        end\n    end\n    if min_even == Inf\n        return []\n    end\n  \
    \  return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpry5qpjv5.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmpry5qpjv5.jl:48\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpry5qpjv5.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpry5qpjv5.jl:47\ntest set: Test Failed at /tmp/tmpry5qpjv5.jl:49\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpry5qpjv5.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpry5qpjv5.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpry5qpjv5.jl:51\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpry5qpjv5.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpry5qpjv5.jl:47\ntest set: Test Failed at /tmp/tmpry5qpjv5.jl:52\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpry5qpjv5.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpry5qpjv5.jl:47\ntest set: Test\
    \ Failed at /tmp/tmpry5qpjv5.jl:53\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014601
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = [x for x in arr if x % 2 == 0]\n    if length(evens) == 0\n  \
    \      return []\n    end\n    smallest_even = minimum(evens)\n    smallest_even_index\
    \ = findfirst(arr, smallest_even)\n    return [smallest_even, smallest_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpw6ct141g.jl:37

    '
  stdout: "test set: Error During Test at /tmp/tmpw6ct141g.jl:40\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpw6ct141g.jl:32\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpw6ct141g.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpw6ct141g.jl:39\ntest set:\
    \ Error During Test at /tmp/tmpw6ct141g.jl:41\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpw6ct141g.jl:32\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpw6ct141g.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpw6ct141g.jl:39\ntest set:\
    \ Error During Test at /tmp/tmpw6ct141g.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014603
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_nodes) == 0\n        return []\n   \
    \ end\n    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp7gqi0_64.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp7gqi0_64.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7gqi0_64.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7gqi0_64.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7gqi0_64.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp7gqi0_64.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7gqi0_64.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7gqi0_64.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7gqi0_64.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp7gqi0_64.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpno4s7o_m.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpno4s7o_m.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpno4s7o_m.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpno4s7o_m.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpno4s7o_m.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpno4s7o_m.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findall(x -> x == min_even, arr)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqgl0pakp.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpqgl0pakp.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqgl0pakp.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqgl0pakp.jl:42\ntest set: Test Failed at /tmp/tmpqgl0pakp.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqgl0pakp.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqgl0pakp.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpqgl0pakp.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqgl0pakp.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqgl0pakp.jl:42\ntest set: Test Failed at /tmp/tmpqgl0pakp.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqgl0pakp.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqgl0pakp.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpqgl0pakp.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014602
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_value = minimum(even_values)\n    for i in 1:length(arr)\n \
    \       if arr[i] == min_value\n            return [min_value, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9t6napu_.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmp9t6napu_.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9t6napu_.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9t6napu_.jl:50\ntest set: Test Failed at /tmp/tmp9t6napu_.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9t6napu_.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9t6napu_.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp9t6napu_.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9t6napu_.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9t6napu_.jl:50\ntest set: Test Failed at /tmp/tmp9t6napu_.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9t6napu_.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9t6napu_.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp9t6napu_.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014602
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = [x for\
    \ x in arr if x % 2 == 0]\n    if length(even_nodes) == 0\n        return []\n\
    \    end\n    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpbla662tt.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpbla662tt.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpbla662tt.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbla662tt.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbla662tt.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpbla662tt.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpbla662tt.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbla662tt.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbla662tt.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpbla662tt.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014603
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # find the smallest even value\n    evens = [x for x in arr if x % 2 ==\
    \ 0]\n    if length(evens) == 0\n        return []\n    end\n    smallest_even\
    \ = minimum(evens)\n    # find the index of the smallest even value\n    smallest_even_index\
    \ = findfirst(arr, smallest_even)\n    return [smallest_even, smallest_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp1fwhq_4d.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp1fwhq_4d.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1fwhq_4d.jl:34\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1fwhq_4d.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1fwhq_4d.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp1fwhq_4d.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1fwhq_4d.jl:34\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1fwhq_4d.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1fwhq_4d.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp1fwhq_4d.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014603
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpi2knwof0.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpi2knwof0.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test Failed at /tmp/tmpi2knwof0.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpi2knwof0.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test Failed at /tmp/tmpi2knwof0.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpi2knwof0.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    evens\
    \ = sort(evens)\n    even = evens[1]\n    idx = findfirst(arr, even)\n    return\
    \ [even, idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp49e70yvr.jl:41

    '
  stdout: "test set: Error During Test at /tmp/tmp49e70yvr.jl:44\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp49e70yvr.jl:36\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp49e70yvr.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp49e70yvr.jl:43\ntest set:\
    \ Error During Test at /tmp/tmp49e70yvr.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp49e70yvr.jl:36\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp49e70yvr.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp49e70yvr.jl:43\ntest set:\
    \ Error During Test at /tmp/tmp49e70yvr.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014604
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx5r4tb4h.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpx5r4tb4h.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: -1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code goes here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: Timeout
  stderr: 'ERROR: LoadError: '
  stdout: "test set: Error During Test at /tmp/tmpl8qwz0md.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpl8qwz0md.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpl8qwz0md.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpl8qwz0md.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpl8qwz0md.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpl8qwz0md.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpl8qwz0md.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, (arr[i],\
    \ i))\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return [evens[1][1], evens[1][2]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpiqsin44h.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpiqsin44h.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpiqsin44h.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpiqsin44h.jl:46\ntest set: Test Failed at /tmp/tmpiqsin44h.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiqsin44h.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiqsin44h.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpiqsin44h.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpiqsin44h.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpiqsin44h.jl:46\ntest set: Test Failed at /tmp/tmpiqsin44h.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiqsin44h.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiqsin44h.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpiqsin44h.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014602
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if isempty(evens)\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_idx = findall(arr .==\
    \ min_even)[1]\n    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpnwtct25s.jl:37

    '
  stdout: "test set: Test Failed at /tmp/tmpnwtct25s.jl:40\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnwtct25s.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnwtct25s.jl:39\ntest set: Test Failed at /tmp/tmpnwtct25s.jl:41\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnwtct25s.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnwtct25s.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpnwtct25s.jl:43\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnwtct25s.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnwtct25s.jl:39\ntest set: Test Failed at /tmp/tmpnwtct25s.jl:44\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnwtct25s.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnwtct25s.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpnwtct25s.jl:45\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014602
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_nodes) == 0\n        return []\n   \
    \ end\n    min_even = minimum(even_nodes)\n    return [min_even, findfirst(arr,\
    \ min_even)]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp0nw6d574.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp0nw6d574.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0nw6d574.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0nw6d574.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0nw6d574.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp0nw6d574.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0nw6d574.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0nw6d574.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0nw6d574.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp0nw6d574.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014604
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for (i, node) in enumerate(arr)\n        if node % 2 == 0\n            push!(even_nodes,\
    \ [node, i])\n        end\n    end\n    if length(even_nodes) == 0\n        return\
    \ []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return even_nodes[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpdeg0jj_m.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpdeg0jj_m.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdeg0jj_m.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdeg0jj_m.jl:46\ntest set: Test Failed at /tmp/tmpdeg0jj_m.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdeg0jj_m.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdeg0jj_m.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpdeg0jj_m.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdeg0jj_m.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdeg0jj_m.jl:46\ntest set: Test Failed at /tmp/tmpdeg0jj_m.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdeg0jj_m.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdeg0jj_m.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpdeg0jj_m.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014599
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpquhbarxj.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpquhbarxj.jl:34\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpquhbarxj.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpquhbarxj.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpquhbarxj.jl:28\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpquhbarxj.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpiyc824nd.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpiyc824nd.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpexpwlju2.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpexpwlju2.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpexpwlju2.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpexpwlju2.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpexpwlju2.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpexpwlju2.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpexpwlju2.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpexpwlju2.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpexpwlju2.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpexpwlju2.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014604
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpvp5180h3.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpvp5180h3.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvp5180h3.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvp5180h3.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvp5180h3.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpvp5180h3.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvp5180h3.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvp5180h3.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvp5180h3.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpvp5180h3.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvytlc3h_.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpvytlc3h_.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvytlc3h_.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpvytlc3h_.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test Failed at /tmp/tmpvytlc3h_.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvytlc3h_.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvytlc3h_.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpvytlc3h_.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpiyc824nd.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpiyc824nd.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_values) == 0\n      \
    \  return []\n    end\n    even_values = sort(even_values, by = x -> x[1])\n \
    \   return even_values[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmppj5sytyd.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmppj5sytyd.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppj5sytyd.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmppj5sytyd.jl:46\ntest set: Test Failed at /tmp/tmppj5sytyd.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppj5sytyd.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppj5sytyd.jl:46\ntest set: Test\
    \ Failed at /tmp/tmppj5sytyd.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppj5sytyd.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmppj5sytyd.jl:46\ntest set: Test Failed at /tmp/tmppj5sytyd.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppj5sytyd.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppj5sytyd.jl:46\ntest set: Test\
    \ Failed at /tmp/tmppj5sytyd.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014603
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpg3_zodct.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpg3_zodct.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg3_zodct.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg3_zodct.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg3_zodct.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpg3_zodct.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg3_zodct.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg3_zodct.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg3_zodct.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpg3_zodct.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    min_even_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpaleeazj2.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpaleeazj2.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpaleeazj2.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpaleeazj2.jl:42\ntest set: Test Failed at /tmp/tmpaleeazj2.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpaleeazj2.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaleeazj2.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpaleeazj2.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpaleeazj2.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpaleeazj2.jl:42\ntest set: Test Failed at /tmp/tmpaleeazj2.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpaleeazj2.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpaleeazj2.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpaleeazj2.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014603
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpiyc824nd.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpiyc824nd.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpiyc824nd.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpiyc824nd.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp954t1pfb.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmp954t1pfb.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:48\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test Failed at /tmp/tmp954t1pfb.jl:51\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp954t1pfb.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp954t1pfb.jl:46\ntest set: Test\
    \ Failed at /tmp/tmp954t1pfb.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014592
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpi2knwof0.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpi2knwof0.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test Failed at /tmp/tmpi2knwof0.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpi2knwof0.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test Failed at /tmp/tmpi2knwof0.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi2knwof0.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi2knwof0.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpi2knwof0.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014597
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpiyc824nd.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpiyc824nd.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiyc824nd.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiyc824nd.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiyc824nd.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpiyc824nd.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if length(even_values) == 0\n        return\
    \ []\n    end\n    min_value = minimum(even_values)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_value\n            return [min_value, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpteosk5sq.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpteosk5sq.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpteosk5sq.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpteosk5sq.jl:50\ntest set: Test Failed at /tmp/tmpteosk5sq.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpteosk5sq.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpteosk5sq.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpteosk5sq.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpteosk5sq.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpteosk5sq.jl:50\ntest set: Test Failed at /tmp/tmpteosk5sq.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpteosk5sq.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpteosk5sq.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpteosk5sq.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1660014603
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [arr[i] for i\
    \ in 1:length(arr) if iseven(arr[i])]\n    if isempty(evens)\n        return []\n\
    \    end\n    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpv8vdnmdn.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpv8vdnmdn.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpv8vdnmdn.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpv8vdnmdn.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpv8vdnmdn.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpv8vdnmdn.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpv8vdnmdn.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpv8vdnmdn.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpv8vdnmdn.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpv8vdnmdn.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014605
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpvp5180h3.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpvp5180h3.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvp5180h3.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvp5180h3.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvp5180h3.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpvp5180h3.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvp5180h3.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvp5180h3.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvp5180h3.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpvp5180h3.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014598
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7vhwgrbo.jl:32

    '
  stdout: "test set: Test Failed at /tmp/tmp7vhwgrbo.jl:35\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7vhwgrbo.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7vhwgrbo.jl:34\ntest set: Test Failed at /tmp/tmp7vhwgrbo.jl:36\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7vhwgrbo.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7vhwgrbo.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp7vhwgrbo.jl:38\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7vhwgrbo.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7vhwgrbo.jl:34\ntest set: Test Failed at /tmp/tmp7vhwgrbo.jl:39\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: Int64[]\
    \ == [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7vhwgrbo.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7vhwgrbo.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp7vhwgrbo.jl:40\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1."
  timestamp: 1660014603
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = [x for x\
    \ in arr if x % 2 == 0]\n    if isempty(even_nums)\n        return []\n    end\n\
    \    min_even = minimum(even_nums)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpopdn6d4b.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpopdn6d4b.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpopdn6d4b.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpopdn6d4b.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpopdn6d4b.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpopdn6d4b.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpopdn6d4b.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpopdn6d4b.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpopdn6d4b.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpopdn6d4b.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014605
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_nodes) == 0\n        return []\n   \
    \ end\n    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp7gqi0_64.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmp7gqi0_64.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7gqi0_64.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7gqi0_64.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7gqi0_64.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp7gqi0_64.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7gqi0_64.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7gqi0_64.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7gqi0_64.jl:42\ntest set:\
    \ Error During Test at /tmp/tmp7gqi0_64.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014595
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n \
    \       Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    \n    Example 3:\n        \n    Example 4:\n        Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n                 so we will choose the first\
    \ zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length\
    \ <= 10000\n        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx5r4tb4h.jl:40

    '
  stdout: "test set: Error During Test at /tmp/tmpx5r4tb4h.jl:43\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx5r4tb4h.jl:35\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx5r4tb4h.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx5r4tb4h.jl:42\ntest set:\
    \ Error During Test at /tmp/tmpx5r4tb4h.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1660014594
