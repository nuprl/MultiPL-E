name: HumanEval_120_maximum
language: d
prompt: "import std.math;\n/*\n\n    Given an array arr of integers and a positive\
  \ integer k, return a sorted array \n    of length k with the maximum k numbers\
  \ in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L,\
  \ 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n\
  \    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\
  \n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n\
  \        2. The elements in the array will be in the range of [-1000, 1000].\n \
  \       3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n"
tests: "unittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L,\
  \ -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) ==\
  \ [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n\
  \    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n\
  \    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n\
  \    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L,\
  \ 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L,\
  \ 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L,\
  \ -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n\
  \    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid\
  \ main(){}"
completions: ["{\n    long[] res = new long[k];\n    int i = 0;\n    int j = 0;\n\
    \    int pos = 0;\n    long max = 0;\n    \n    while (i < k) {\n        if (arr[i]\
    \ > max) {\n            max = arr[i];\n        }\n        i++;\n    }\n    \n\
    \    while (j < arr.length) {\n        if (arr[j] > max) {\n            max =\
    \ arr[j];\n        }\n        j++;\n    }\n    \n    if (max < 0) {\n        max\
    \ = 0;\n    }\n    \n    pos = i;\n    \n    while (i < k) {\n        if (max\
    \ < arr[i]) {\n            max = arr[i];\n        }\n        i++;\n    }\n   \
    \ \n    while (j < arr.length) {\n        if (max < arr[j]) {\n            max\
    \ = arr[j];\n        }\n        j++;\n    }\n    \n    if (max < 0) {\n      \
    \  max = 0;\n    }\n    \n    while (i < k) {\n        if (max < arr[i]) {\n \
    \           max = arr[i];\n        }\n        i++;\n    }\n    \n    \n    while\
    \ (j < arr.length) {\n        if (max < arr[j]) {\n            max = arr[j];\n\
    \        }\n        j++;\n    }\n    \n    \n    \n    for (int k = 0; k < arr.length;\
    \ k++) {\n        if (max < arr[k]) {\n            res[k] = max;\n        } else\
    \ {\n            res[k] = arr[k];\n        }\n    }\n    return res;\n}", "{\n\
    \    if ( arr == null || arr.length == 0 || k < 1 || k >= arr.length) return arr;\n\
    \    long max = arr[0];\n    Arrays.sort(arr);\n    long res = arr[k-1];\n   \
    \ for(int i=1;i<k;i++){\n        long tmp = arr[i];\n        if((tmp > max) &&\
    \ (tmp > res)){\n            max = tmp;\n            res = arr[i-1];\n       \
    \ }\n    }\n    return new long[]{max, res};\n}", "{\n\tif (k > arr.Length ||\
    \ k <= 0)\n\t\treturn new long[0];", "{\n    int[] map = new int[k];\n    long[]\
    \ res = new long[k];\n    bool flag = false;\n    map[0] = 0;\n    map[1] = arr.Length;\n\
    \    for(int i = 1; i < k; i++) \n    {\n        if(arr[i] < arr[i-1])\n     \
    \   {\n            map[i] = map[i-1] + 1;\n        }\n        else\n        {\n\
    \            map[i] = Math.Max(map[i-1], map[i-2]);\n        }\n    }\n    for(int\
    \ i = 2; i < k; i++) \n    {\n        if(map[i] > map[i-1])\n        {\n     \
    \       flag = true;\n        }\n        if(flag)\n        {\n            res[i\
    \ - 1] = Math.Max(res[i - 1], arr[i-1]);\n        }\n    }\n    return res;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWelcome to Stack Overflow! Please don't\
    \ answer just with source code. Try to provide a nice description about how your\
    \ solution works. See: [How do I write a good answer?](https://stackoverflow.com/help/how-to-answer).\
    \ Thanks\n<|/ c |>\n<| a tags=algorithm |>\nHere is my Java solution that uses\
    \ streams to compute the result.\n<code>\nlong maxElements(int[] numbers, int\
    \ k) {\n    return IntStream.range(0, k)\n            .max(Comparator.comparing(i\
    \ -> numbers[i]))\n            .orElseThrow(() -> new RuntimeException(\"Not enough\
    \ elements\"));\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nJava Solution\n\
    <code>\nstatic ArrayList<Integer> maxElements(int[] a, int k) {\n    int n = a.length;\n\
    \    ArrayList<Integer> max = new ArrayList<>();\n    int i = 0;\n    int j =\
    \ 0;\n    while (j < k) {\n        while (a[i] > a[j]) {\n            if (i ==\
    \ j) break;\n            i++;\n        }\n        while (a[i] < a[j]) {\n    \
    \        if (i == j) break;\n            j++;\n        }\n        max.add(a[i]);\n\
    \        i++;\n        j++;\n    }\n    return max;\n}\n</code>\n<|/ a tags=algorithm\
    \ |>\n<| a |>\nPython solution\n<code>\ndef max_elements(array, k):\n  max_element\
    \ = array[0]\n  max_count = 0\n  index = 0\n  for index in range(1, len(array)):\n\
    \    if array[index] > max_element:\n      if max_count == 0:\n        max_element\
    \ = array[index]\n        max_count = index\n      else:\n        max_element\
    \ = array[index]\n        max_count = index\n    elif array[index] > max_element:\n\
    \      max_element = array[index]\n      max_count = index\n  return max_element,\
    \ max_count", "{\n    int n = arr.length;\n    long[] res = new long[k];\n   \
    \ for(int i = 0; i < k; ++i)\n        res[i] = Long.MAX_VALUE;\n    for(int i\
    \ = 0; i < n; ++i)\n    {\n        if(arr[i] > res[--k])\n            res[k] =\
    \ arr[i];\n    }\n    return res;\n}", "{\n    long largest = arr[0];\n    long[]\
    \ result = new long[k];\n    for(int i = 1; i < k; ++i)\n    {\n        if(arr[i]\
    \ > largest)\n        {\n            largest = arr[i];\n        }\n    }\n   \
    \ for(int i = 1; i < k; ++i)\n    {\n        if(arr[i] > largest)\n        {\n\
    \            result[i] = largest;\n        }\n        else\n        {\n      \
    \      result[i] = arr[i];\n        }\n    }\n    return result;\n}", "{\n   \
    \ int n = arr.Length;\n    if (n < k) \n    {\n        return new long[k];\n \
    \   }\n    long[] a = new long[k];\n    for (int i = 0; i < k; i++) \n    {\n\
    \        a[i] = arr[i];\n    }\n    int m = k;\n    for (int i = k; i < n; i++)\
    \ \n    {\n        a[m] = arr[i];\n        m++;\n    }\n    return a;\n}", "{\n\
    \    long[] result = new long[k];\n    long maxIndex = -1;\n    \n    for (int\
    \ i = 0; i < k; i++)\n    {\n        int j = 0;\n        for (; j < arr.Length\
    \ && arr[j] > arr[i]; j++)\n        {\n        }\n        if (j < arr.Length)\n\
    \        {\n            result[i] = arr[j];\n            maxIndex = i;\n     \
    \   }\n    }", "{\n    if (k > arr.length)\n        return arr;\n    long[] result\
    \ = new long[k];\n    int max = Integer.MIN_VALUE;\n    for (int i = 0; i < k;\
    \ i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n\
    \    }\n    for (int i = 0; i < k; i++) {\n        result[i] = max;\n        max\
    \ = Math.max(max, arr[i]);\n    }\n    return result;\n}\n</code>\n<|/ a tags=arrays,c#,data-structures,algorithm,sorting\
    \ |>\n<| c |>\nI did not understand the first solution, can you give an example?\n\
    <|/ c |>\n<| c |>\nIf you want a sorted array you can do `Array.Sort(myArray)`\n\
    <|/ c |>\n<| a dscore=4 |>\n<code>\npublic static int[] FindMaxSubarray(int[]\
    \ array){\n        if (array.Length < 2)\n            return new int[0];", "{\n\
    \    long[] result = new long[k];\n    \n    Arrays.sort(arr);\n    for(int i\
    \ = 0; i < k; i++) \n    {\n        result[i] = arr[i];\n    }\n    return result;\n\
    }\n/*", "{\n    int n = arr.length;\n    if (n == 0) \n        return null;\n\
    \    if (k <= 0 || n <= k) \n        return arr;", "{\n    long[] ret = new long[k];\n\
    \    int index = 0;\n    int j = 0;\n    int len = 0;", "{\n    long[] result\
    \ = new long[k];", "{\n    long[] res = new long[k];\n    \n    Arrays.fill(res,\
    \ Integer.MIN_VALUE);\n    \n    for (int i = 0; i < k; i++)\n        res[i] =\
    \ Collections.max(arr, new Comparator<long>()\n        {\n            public int\
    \ compare(long x, long y)\n            {\n                return Long.compare(x,\
    \ y);\n            }\n        });\n    \n    return res;\n}\n</code>\n<|/ a tags=algorithm,arrays,java\
    \ |>\n<| c |>\nHe is asking for a java solution, not c++\n<|/ c |>\n<| c |>\n\
    he tagged the question as java in the question as well. Maybe he has another solution\
    \ in another language but this is the only thing that worked for me.\n<|/ c |>\n\
    <| a dscore=4 tags=algorithm,arrays,java |>\nThe idea is to use java.util.Collections.sort()\
    \ with an appropriate Comparator:\n<code>", "{\n    long[] res = new long[k];\n\
    \    std.array.PortableArray[long] _arr = new std.array.PortableArray[long](arr);\n\
    \    for(int i = 0; i < k; i++) \n    {\n        res[i] = _arr.Get(i);\n    }\n\
    \    Arrays.sort(res);\n    return res;\n}\n\"\"\"", "{\n    if (k > arr.length)\
    \ return arr;\n    long ans[] = new long[k];\n    int i = 0;\n    int j = 0;\n\
    \    long maxi = arr[0];\n    while (j < arr.length) {\n        if (arr[j] > maxi)\
    \ {\n            ans[i] = maxi;\n            maxi = arr[j];\n            i++;\n\
    \        }\n        j++;\n    }\n    ans[i] = maxi;\n    return ans;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=algorithm,c#,arrays,sorting |>\nSort the array in\
    \ descending order and then pick up the smallest k elements.\n<|/ a |>\n<| c |>\n\
    This doesn't really answer the question, just offers some code with explanation\
    \ why.\n<|/ c |>\n<| a |>\nI tried to find the kth largest element in an array\
    \ using binary search and merge sort.\n<code>\npublic int kthLargest(int[] arr,int\
    \ k)\n{\n    int n=arr.length;\n    boolean flag=true;\n    int i=0,j=0;\n   \
    \ int temp=arr[0];\n    while(j<n-1)\n    {\n        if(arr[j]+temp<arr[j+1])\n\
    \        {\n            temp=arr[j];\n        }\n        j++;\n    }\n    if(k<j)\n\
    \    {\n        i=k-1;\n    }\n    else if(k>j)\n    {\n        i=j;\n    }\n\
    \    else\n    {\n        i=j;\n    }\n    while(flag)\n    {\n        if(arr[i]>arr[i+1])\n\
    \        {\n            arr[i+1]=arr[i];\n        }\n        i+=2;\n    }\n  \
    \  return arr[i+2];\n}\n</code>\n<|/ a dscore=0 tags=algorithm,c#,arrays,sorting\
    \ |>\n<| a |>\nFor those who are looking for a non-sorting solution, here is a\
    \ Java solution.\n<code>\npublic static int findKthLargest(int[] arr, int k){\n\
    \    ArrayList<Integer> sortedList = new ArrayList<Integer>();\n    for(int i\
    \ : arr){\n        sortedList.add(i);\n    }\n    Collections.sort(sortedList);\n\
    \    Arrays.sort(arr);\n    for(int i : arr){\n        if(i < k){\n          \
    \  continue;\n        }\n        return i;\n    }\n    return -1;\n}\n</code>\n\
    <|/ a tags=algorithm,c#,arrays,sorting dscore=0 |>\n<| a |>\n<code>\npublic static\
    \ int findKthLargest(int[] arr, int k){\n    if(arr.length==0){\n        return\
    \ -1;\n    }\n    if(k==1){\n        return arr[0];", "{\n    if(k < 1)\n    \
    \    return arr;\n    if(k > arr.length)\n        return arr;\n    \n    long[]\
    \ result = new long[k];\n    Arrays.sort(arr);\n    for(int i = 0; i < arr.length;\
    \ ++i)\n    {\n        result[i] = arr[i];\n    }\n    return result;\n}", "{\n\
    \    // write your code here\n    long[] result = new long[k];\n    int left =\
    \ 0;\n    int right = arr.length - 1;\n    while (right >= left) {\n        int\
    \ middle = (left + right) / 2;\n        if (arr[middle] > k) {\n            right\
    \ = middle - 1;\n        }\n        else if (arr[middle] < k) {\n            left\
    \ = middle + 1;\n        }\n        else {\n            result[left++] = arr[middle];\n\
    \            right = middle;\n        }\n    }\n    \n    for (int i = left; i\
    \ <= right; i++) {\n        result[i - left] = arr[i];\n    }\n    \n    return\
    \ result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYour code is not correct in\
    \ the special case of input:  [-3L, -4L, 5L] with k = 4.\n<|/ c |>\n<| c |>\n\
    The question states that the array is already sorted and that the input is already\
    \ sorted (from largest to smallest number), so the second half of your code is\
    \ irrelevant to the problem.\n<|/ c |>\n<| c |>\nthe problem also states that\
    \ the \"input is already sorted\", so it's actually not clear if the question\
    \ is asking for the \"maximum elements in the array\" or the maximum \"subsequence\"\
    \ of the input array.\n<|/ c |>\n<| c |>\nI misinterpreted the question. Thanks\
    \ for your reminding.\n<|/ c |>\n<| c |>\nThe question was clearly asking for\
    \ \"a sorted array of length k\" which this code fails to do.  But your solution\
    \ is more efficient than any of my other solutions.  And it also doesn't require\
    \ that arr be sorted (which I believe is the OP's requirement).\n<|/ c |>\n<|\
    \ a |>\nHere is my solution:\n<code>\n// Konstantin\nimport java.util.*;\nimport\
    \ java.util.Arrays;", "{\n    int n = arr.length;\n    if ( k < 1 || k > n )\n\
    \        throw new IllegalArgumentException(\"The k value must be in range [1,\
    \ \" + n + \"]\");", "{\n    int len = arr.length;\n    int max_len = 0;\n   \
    \ \n    for(int i = 0; i < len; i++)\n    {\n        if(arr[i] > arr[i+1])\n \
    \       {\n            max_len = len - i;\n        }\n    }\n    \n    long[]\
    \ max = new long[max_len];\n    int m = 0;\n    for(int i = 0; i < len; i++)\n\
    \    {\n        if(arr[i] > arr[i+1])\n        {\n            max[m] = arr[i+1];\n\
    \            m++;\n        }\n        else\n        {\n            max[m] = arr[i];\n\
    \        }\n    }\n    \n    return max;\n}", "{\n    long[] result = new long[k];\n\
    \    \n    for (int i = 0; i < k; i++)\n    {\n        result[i] = max(arr[i],\
    \ result[i]);\n    }\n    \n    return result;\n}", "{\n    long[] res = new long[k];\n\
    \    sort(arr, 0, k);\n    long curr = -10000L;\n    int i = 0;\n    while (i\
    \ < k) \n    {\n        if (arr[i] > curr) \n        {\n            curr += 10000000L;\n\
    \            res[i] = arr[i];\n        }\n        i++;\n    }\n    return res;\n\
    }\n</code>\n<|/ a |>\n<| a |>\nI wrote this algorithm as a C# solution using some\
    \ LINQ:\n<code>\npublic static int[] maximum(int[] arr, int k)\n{\n    // Sort\
    \ the array from largest to smallest\n    var sorted = arr.OrderByDescending(i\
    \ => i);", "{\n    int n = arr.length;\n    if(k < 1 || n > k || k > n ) throw\
    \ new IndexOutOfBoundsException();\n    long max = arr[0];\n    for(int i = 1;\
    \ i < k; ++i)\n        if(arr[i] > max)\n            max = arr[i];\n    long[]\
    \ res = new long[k];\n    for(int i = 0; i < k; ++i)\n        res[i] = max;\n\
    \    return res;\n}\n/*", "{\n    // write your code here\n    long[] result =\
    \ new long[k];\n    Arrays.sort(arr);\n    \n    for(int i = 0; i < k; i++){\n\
    \        result[i] = arr[k - i - 1];\n    }\n    return result;\n}", "{\n    long[]\
    \ res = new long[k];\n    std.sort(arr);\n    int i = 0;\n    int j = 0;\n   \
    \ long max = 0;\n    while(i < arr.length && j < k) {\n        if(arr[i] > max)\n\
    \            max = arr[i];\n        if((i+1) >= arr.length) break;\n        if((arr[i+1])\
    \ > max)\n            max = arr[i+1];\n        i++;\n        j++;\n    }\n   \
    \ for(i = 0; i < k; i++)\n        res[i] = max;\n    return res;\n}\n/*\n    \n\
    \    Given an array arr of integers and a positive integer k, return a sorted\
    \ array \n    of length k with the minimum k numbers in arr.\n    \n    Example\
    \ 1:", "{\n    long[] max_arr = new long[k];\n    std.sort(arr);\n    for (int\
    \ i = 0; i < k; i++)\n    {\n        max_arr[i] = arr[i];\n    }\n    return max_arr;\n\
    }\n/*", "{\n    if ( k == 0 )\n        return arr;\n    long[] result = new long[arr.length];\n\
    \    Arrays.fill(result, k);\n    Arrays.sort(result);\n    return Arrays.copyOfRange(result,\
    \ 0, k);\n}\n</code>\n<|/ a tags=c++,arrays,algorithm dscore=0 |>\n<| c |>\nThis\
    \ code is not valid in C++ because of the missing semicolons. It also doesn't\
    \ meet the requirements stated in the question.\n<|/ c |>\n<| c |>\nThe OP said\
    \ that he was a beginner, and I gave him a code he had used before in Java. I\
    \ had no idea about C++ syntax, but I fixed my answer so that it compiles in C++.\
    \ Thanks for letting me know.\n<|/ c |>\n<| c |>\nThat's a good start. But the\
    \ requirements still don't meet the spec; it says to return the **maximum** k\
    \ numbers, not all of them.\n<|/ c |>\n<| c |>\nOkay, I fixed my answer and explained\
    \ my reasoning. Hope it helps now.\n<|/ c |>\n<| a tags=c++,arrays,algorithm |>\n\
    The algorithm will run time O(n+k) time and O(n) space. Here is the java code\
    \ of it...\n<code>\nimport java.util.ArrayList;\nimport java.util.Arrays;\npublic\
    \ class ArrayMaxK {\n    public static void main(String[] args) {\n        ArrayList<Integer>\
    \ myArray= new ArrayList<Integer>();\n        myArray.add(1);\n        myArray.add(2);\n\
    \        myArray.add(3);\n        myArray.add(4);\n        myArray.add(5);\n \
    \       myArray.add(6);\n        myArray.add(7);\n        myArray.add(8);\n  \
    \      myArray.add(9);\n        myArray.add(10);\n        myArray.add(11);\n \
    \       myArray.add(12);\n        myArray.add(13);\n        myArray.add(14);\n\
    \        System.out.println(findMaxK(myArray,6));\n    }\n    static int findMaxK(ArrayList<Integer>\
    \ myArray, int k){\n        int minIndex=0;\n        int maxIndex=myArray.size();\n\
    \        Arrays.sort(myArray);\n        ArrayList<Integer> temp=new ArrayList<Integer>();\n\
    \        ArrayList<Integer> result=new ArrayList<Integer>();\n        for(int\
    \ i=0;i<k;i++){\n            int j=minIndex+i;\n            int currentVal=myArray.get(j);\n\
    \            if(currentVal>myArray.get(maxIndex-i)){\n                minIndex=j;\n\
    \                maxIndex=maxIndex-i;\n            }\n            else{\n    \
    \            maxIndex=max", "{\n    long i, max, maxIndex, maxVal;\n    maxIndex\
    \ = -1;\n    maxVal = 0;", "{\n    long[] res = new long[k];\n    Arrays.sort(arr);\n\
    \    \n    for (int i = 0; i < k; i++)\n    {\n        res[i] = arr[i];\n    }\n\
    \    return res;\n}", "{\n    long[] result = new long[k];\n    Arrays.sort(arr,\
    \ new LongComparator(k));\n    System.arraycopy(arr, k, result, 0, k);\n    return\
    \ result;\n}\n/*", "{\n    long[] result;\n    long max;\n    long i;\n    int\
    \ count = 0;\n    int len = arr.length;", "{\n    long max = arr[0];\n    long[]\
    \ result = new long[k];", "{\n    int leftBound = 0;\n    int rightBound = arr.length-1;\n\
    \    int currIndex = -1;\n    \n    long[] res = new long[k];", "{\n    long maxValue\
    \ = arr[0];\n    long maxIndex = -1;", "{\n    Arrays.sort(arr);\n    return Arrays.copyOfRange(arr,\
    \ k-1, k);\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nSorry, but your code is not\
    \ correct. Your code does not take into account that `k` could be negative.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\npublic static void main(String[] args) {\n\
    \    List<Integer> numbers = new ArrayList<Integer>();\n    numbers.add(12);\n\
    \    numbers.add(14);\n    numbers.add(3);\n    numbers.add(19);\n    numbers.add(-5);\n\
    \    numbers.add(6);", "{\n    /*\n        O(n * log n)\n        O(k)\n    */\n\
    \    long[] res = new long[k];", "{\n    long[] result = new long[k];\n    Arrays.sort(arr);",
  "{\n    int[] dp = new int[k+1];\n    for(int i=0; i<=k; i++)\n        dp[i] = 0;\n\
    \    \n    for(int i=0; i<=arr.length; i++) \n        dp[arr[i]] = Math.max(dp[arr[i]],\
    \ i);\n    \n    long[] result = new long[k];\n    \n    for(int i=0; i<=k; i++)\
    \ \n        result[i] = dp[i];\n    \n    return result;\n}", "{\n    long[] result\
    \ = new long[k];\n    sort(arr, k);\n    result.length = k;\n    result[0] = arr[0];\n\
    \    for(int i = 1; i < k; i++)\n    {\n        result[i] = max(arr[i-1], arr[i]);\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=python,c++ |>\n<| c |>\nGreat\
    \ solution, just one remark: It does not produce an array, but rather a list.\
    \ The `result` variable is unnecessary, though, and can be omitted altogether.\n\
    <|/ c |>\n<| c |>\nIf you need an array, just convert it to a list by doing `result[:k]\
    \ = arr[:k]`. Note that this also converts the `long` to a `int`, so the largest\
    \ number will be `9223372036854775807` instead of `9223372036854775808`.\n<|/\
    \ c |>\n<| c |>\nAlso, `long[]` isn't supported on all systems, although `std::array<long,\
    \ k>` does work on all systems.\n<|/ c |>\n<| a dscore=4 |>\nThe Python list type\
    \ has a method named sort. \nThe sort method takes a function as parameter. This\
    \ function will be called with the list as an argument and should return True\
    \ if the list should be sorted, False otherwise.\nAn example would be (from here):\n\
    <code>\n>>> a = [\"c\", \"a\", \"b\"]\n>>> a.sort() # use default sort order\n\
    >>> a\n['a', 'b', 'c']\n</code>\nIn your case you can call the sort method on\
    \ your list to sort the values in it.\n<|/ a tags=python,c++ |>\n<| a dscore=3\
    \ tags=python,c++ |>\nIn python :\n<code>\nlist_a = [1,4,2,6,7,1,6,3,5,2,4,5]\n\
    list_a.sort()\n</code>\nOutput :\n<code>\nlist_a\nOut[26]: [0, 1, 2, 3, 4, 5,\
    \ 6, 7, 4, 2, 6]\n</code>\n<|/ a |>\n<| c |>\nThe question is specifically asking\
    \ for a C solution.\n<|/ c |>\n<| a tags=python,c++ |>\nA C++ solution would be\
    \ to use the std::sort algorithm from <algorithm>. See the following code:\n<code>\n\
    #include <algorithm>", "{\n    int n = arr.length;\n    long max_num = arr[0];\n\
    \    long[] res = new long[k];\n    Arrays.sort(arr);\n    for(int i = 0; i <\
    \ n; ++i)\n        if(arr[i] > max_num)\n        {\n            max_num = arr[i];\n\
    \            Arrays.fill(res, max_num, arr[i], k);\n        }\n    return res;\n\
    }", "{\n    return longArrayMath(arr, k).asLongArray();\n}\n</code>\n<|/ a |>\n\
    <| a tags=arrays,java,sorting dscore=2 |>\n<code>\nimport java.util.Arrays;\n\
    import java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;",
  "{\n    long max_arr[k+1];\n    long j = 0;\n    for(int i = 0; i < arr.length;\
    \ i++)\n    {\n        if(arr[i] > arr[j])\n        {\n            max_arr[j]\
    \ = arr[i];\n            j = j + 1;\n        }\n    }\n    \n    for(int i = 0;\
    \ i < k; i++)\n        max_arr[i] = max_arr[i + 1];\n    \n    long[] res = new\
    \ long[k];\n    for(int i = 0; i < k; i++)\n        res[i] = max_arr[i];\n   \
    \ \n    return res;\n}\n/*", "{\n  int i, temp;\n  \n  int result = 0;\n  long\
    \ maxElement = arr[0];\n  long maxIndex = arr[0];\n  \n  int startIndex = 1;\n\
    \  \n  for(i = 1; i < arr.length; i++){\n    if(arr[i] > maxElement){\n      maxElement\
    \ = arr[i];\n      maxIndex = i;\n    }\n  }\n  \n  for(i = startIndex; i < arr.length;\
    \ i++){\n    if(arr[i] > maxElement){\n      if(i - maxIndex >= k){\n        result\
    \ = result + maxIndex - i;\n      }\n      result = result + 1;\n      maxElement\
    \ = arr[i];\n      maxIndex = i;\n    }\n  }\n  \n  if(i - maxIndex >= k){\n \
    \   result = result + maxIndex - i;\n  }\n  \n  return Arrays.copyOf(arr, result);\n\
    }\n</code>\n<|/ a |>\n<| a dscore=1 |>\nI have implemented the algorithm by converting\
    \ it to Java. It is using Arrays.sort and passing in Comparator class to it. The\
    \ algorithm is simple and straightforward, no additional variable is needed.\n\
    <code>\nimport java.util.Arrays;", "{\n    int[] _arr = new int[k];\n    long[]\
    \ _max = new long[k];", "{\n    long[] result = new long[k];\n    int i;\n   \
    \ int index = 0;\n    int max = 0;\n    \n    for(i = 0; i < k; i++)\n    {\n\
    \        if(arr[i] > max)\n        {\n            max = arr[i];\n        }\n \
    \   }\n    for(i = 0; i < k; i++)\n    {\n        if(arr[i] == max)\n        {\n\
    \            result[index] = arr[i];\n            index++;\n        }\n    }\n\
    \    return std.array.get(result, 0, k);\n}", "{\n\tint[] heap = new int[k];\n\
    \tint[] length = new int[k];\n\t\n\tlong max = arr[0];\n\tint i = 0, j = 0, tmp;\n\
    \t\n\tfor (long elem : arr)\n\t{\n\t\tif (max < elem)\n\t\t{\n\t\t\tmax = elem;\n\
    \t\t\ttmp = 0;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttmp++;\n\t}\n\t\n\tlength[0] =\
    \ tmp;\n\theap[0] = max;\n\t\n\twhile (length > 1)\n\t{\n\t\tint left = 0;\n\t\
    \tint right = length - 1;\n\t\t\n\t\twhile (left < right && arr[left] <= heap[right])\n\
    \t\t{\n\t\t\tleft++;\n\t\t}\n\t\t\n\t\twhile (right > left && arr[right] >= heap[left])\n\
    \t\t{\n\t\t\tright--;\n\t\t}\n\t\t\n\t\tif (left > right)\n\t\t{\n\t\t\tbreak;\n\
    \t\t}\n\t\t\n\t\theap[i] = heap[left];\n\t\tlength[i] = length[left];\n\t\t\n\t\
    \ti = left;\n\t\tj = right;\n\t\t\n\t\twhile (i < j)\n\t\t{\n\t\t\tif (arr[i]\
    \ < arr[j])\n\t\t\t{\n\t\t\t\ttmp = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\t\
    arr[j] = tmp;\n\t\t\t\t\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t\t\n\t\t\telse\
    \ if (arr[i] > arr[j])\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\n\t\t\telse\n\t\
    \t\t{\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong[] maxArray = new long[k];\n\
    \t\n\tfor (int k = 0; k < k; k++)\n\t{\n\t\tmaxArray[k] = heap[k];\n\t}\n\t\n\t\
    return maxArray;\n}\n/*", "{\n    int i, j;\n    long[] m;\n    long[] res;\n\
    \    bool isSorted;\n    \n    isSorted = false;\n    if (k == 0) {\n        m\
    \ = new long[k];\n    } else {\n        m = new long[k + 1];\n        m = std.arraycopy(arr,\
    \ 0, m, 0, k);\n    }\n    \n    for (i = 1, j = 0; i < m.length; i++) {\n   \
    \     if (m[i] > m[j]) {\n            m[j] = m[i];\n        } else {\n       \
    \     j++;\n        }\n    }\n    \n    isSorted = true;\n    \n    for (i = 1,\
    \ j = 0; i < k; i++) {\n        if (m[i] > m[j]) {\n            m[j] = m[i];\n\
    \        } else {\n            j++;\n        }\n    }\n    \n    res = m;\n  \
    \  \n    if (k == 0 || k == m.length) {\n        return m;\n    }\n    \n    if\
    \ (isSorted) {\n        for (i = k; i < m.length; i++) {\n            m[i] = m[i\
    \ + k];\n        }\n    }\n    \n    return res;\n}\n/*", "{\n    if (k > arr.length)\
    \ return arr;\n    long[] res = new long[k];\n    int j = 0, i = 1;\n    long\
    \ tmp;\n    while (j < k)\n    {\n        tmp = arr[i];\n        while ((j < k)\
    \ && (arr[j] > tmp)) j++;\n        if (j >= k) break;\n        res[j] = tmp;\n\
    \        i++;\n    }\n    return res;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    You don't need to use an additional array `res` when you can use a simple loop.\
    \ E.g. `for (i = 0; i < k; i++) res[i] = arr[i];`\n<|/ c |>\n<| a tags=arrays,algorithm,sorting\
    \ dscore=0 |>\nThe algorithm you describe is known as the \"selection sort\" algorithm,\
    \ and it can be written like this:\n<code>\npublic static int[] selectionSort(int[]\
    \ arr) {\n    int n = arr.length;\n    int minIndex = -1;\n    for(int i = 0;\
    \ i < n; i++) {\n        if(minIndex == -1 || arr[i] < arr[minIndex]) {\n    \
    \        minIndex = i;\n        }\n    }\n    int[] result = new int[n];\n   \
    \ int i = minIndex;\n    for(int j = i+1; j < n; j++) {\n        if(arr[j] < arr[i])\
    \ {\n            result[i] = arr[j];\n            i++;\n        } else {\n   \
    \         result[i] = arr[i];\n        }\n    }\n    result[i++] = arr[minIndex];\n\
    \    for(int x : result) System.out.print(x);\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis would not work for an array of size 10 or more.\n<|/ c\
    \ |>\n<| c |>\nThe code works fine for arrays of size 10 or more. It also works\
    \ if you increase `n` by 2 instead of 1.\n<|/ c |>\n<| c |>\nThis code is not\
    \ selection sort algorithm - it's quicksort algorithm.\n<|/ c |>\n<| c |>\nIt\
    \ would also not be selection sort algorithm - it would sort only half of elements,\
    \ not all of them. Quicksort algorithm is quite different from selection sort\
    \ algorithm. In quicksort, elements should be arranged based on ascending or descending\
    \ order but in selection sort it would be arranged randomly.\n<|/ c |>\n<| c |>\n\
    Quicksort is different from selection sort because it is not allowed to perform\
    \ a comparison with itself and quicksort is allowed to do so. Selection sort is\
    \ allowed to do so but quicksort is not.\n<|/ c |>\n<| a |>\n<code>\n    public\
    \ static void SelectionSort(int[] arr, int n)\n    {\n        for (int i = 0;\
    \ i < n; i++)\n        {\n            int minPos = ", "{\n    long i, j, max =\
    \ 0;\n    int count = 0;\n    long[] maxArray = new long[k];\n    long[] sortedArray\
    \ = new long[k];", "{\n    if (k > arr.length)\n        throw new RuntimeException(\"\
    k cannot be greater than array length\");\n    int len = arr.length;\n    int\
    \ maxIdx = arr.length - 1;\n    int minIdx = arr.length - k;\n    long[] ans =\
    \ new long[k];\n    while (maxIdx >= minIdx) {\n        if (arr[maxIdx] < arr[minIdx])\
    \ {\n            long temp = arr[maxIdx];\n            arr[maxIdx] = arr[minIdx];\n\
    \            arr[minIdx] = temp;\n            ans[maxIdx--] = arr[maxIdx];\n \
    \       } else {\n            long temp = arr[maxIdx];\n            arr[maxIdx]\
    \ = arr[minIdx];\n            arr[minIdx] = temp;\n            ans[minIdx--] =\
    \ arr[minIdx];\n        }\n    }\n    while (maxIdx >= 0) {\n        ans[--maxIdx]\
    \ = arr[maxIdx];\n    }\n    return ans;\n}", "{\n    int max = arr[0], i = 0,\
    \ j = 0;\n    while(i < k) \n    {\n        if(max < arr[j++]) \n        {\n \
    \           max = arr[j];\n        } \n        else \n        {\n            i++;\n\
    \        }\n    }\n    long[] ans = new long[k];\n    for(int i = 0; i <= k; i++)\
    \ \n    {\n        ans[i] = arr[i];\n    }\n    for(int i = k; i < arr.Length;\
    \ i++) \n    {\n        if(arr[i] > max) \n        {\n            max = arr[i];\n\
    \        }\n    }\n    return ans;\n}\n</code>\n<|/ a tags=algorithm,c# dscore=0\
    \ |>\n<| c |>\nPlease format your code. Nobody wants to read code as one long\
    \ line. Also explain why you think this works.\n<|/ c |>\n<| c |>\n, Sorry for\
    \ that, i will try to make it better next time.\n<|/ c |>\n<| a dscore=0 |>\n\
    If you're trying to find the most efficient way to do this without having to use\
    \ two arrays, you can do it with one array. Instead of making a copy of your array,\
    \ sort it and then grab the top k numbers.\n<code>\npublic static int[] GetTopK(int[]\
    \ arr, int k)\n{\n    Array.Sort(arr);\n    Array.Sort(arr);\n    return arr.Take(k).ToArray();\n\
    }\n</code>\n<|/ a tags=algorithm,c# |>\n<| c |>\nWhy are you sorting the array\
    \ twice? The second call does nothing.\n<|/ c |>\n<| c |>\nThe first call makes\
    \ it sorted so we don't have to worry about it after we grab the top k numbers.\
    \ The second call will ensure we have the correct order in the output array because\
    \ of the way Sort works.\n<|/ c |>\n<| c |>\nThat doesn't make sense. The second\
    \ `Sort` call does nothing, because `Sort` returns the input array unchanged.\
    \ Further, even if it did, the second `Sort` is redundant, because `Take` has\
    \ already sorted the array for us.\n<|/ c |>\n<| c |>\nWhy would you expect that\
    \ to be the case if the array was already sorted?\n<|/ c |>\n<| c |>\n\"The second\
    \ call will ensure we have the correct order in the output array\" - no it doesn't.\
    \ The `Take` call does nothing, because `Take` already sorts the array for you.\
    \ Further, even if it did, the second `Sort` is redundant, because `Take` has\
    \ already sorted the array for us.\n<|/ ", "{\n    int i, j, l, m;\n    long max\
    \ = arr[0];", "{\n    if (k > arr.length)\n        return arr;", "{\n    int n\
    \ = arr.length;\n    long[] result = new long[k];\n    long[] tmp = new long[n];\n\
    \    int i = 0, j = 0;\n    \n    for (; i < k; i++, j++)\n    {\n        tmp[j]\
    \ = arr[i];\n    }\n    \n    for (; i < n; i++, j++)\n    {\n        if (tmp[j]\
    \ > arr[i])\n        {\n            result[i] = tmp[j];\n        }\n    }\n  \
    \  \n    return result;\n}", "{\n    int len = (int)arr.length;", "{\n    /*\n\
    \        O(n)", "{\n    if(k > arr.length) \n    {\n        throw new IndexOutOfBoundsException(String.format(\"\
    The length of arr(%d) must be less than or equal to k(%d).\", arr.length, k));\n\
    \    }\n    long[] result = new long[k];\n    int count = 0;\n    \n    for(int\
    \ i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > result[count]) \n  \
    \      {\n            result[count] = arr[i];\n            count++;\n        }\n\
    \    }\n    \n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe\
    \ `result` variable is unnecessary. Just loop through the `arr` array, and append\
    \ the values to `result` in the same order as the `arr` array was. That way, you\
    \ don't need to use `count` at all, since you know that `i` is less than `k`.\n\
    <|/ c |>\n<| c |>\nYou're right. I thought the point was to create a separate\
    \ array with the max number of elements.\n<|/ c |>\n<| a dscore=2 |>\nThe previous\
    \ solutions either don't work, or are very slow. Here is a solution that uses\
    \ the original array and does it in O(n log k) time (where n is the number of\
    \ elements and k is the max number of elements to keep).\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Collections;\nimport java.util.List;\nimport java.util.function.Predicate;",
  "{\n    int len = arr.length;\n    int k1 = k - 1;\n    long[] result = new long[k];\n\
    \    \n    for(int i = 0; i <= k1; i = i + 2)\n    {\n        for(int j = i; j\
    \ <= len; j++)\n        {\n            if(arr[j] > arr[i])\n            {\n  \
    \              result[k] = arr[j];\n                k = k - 1;\n             \
    \   arr = new long[arr.length];\n            }\n        }\n    }\n    result[k]\
    \ = arr[k1];\n    return result;\n}\n</code>\n<|/ a tags=arrays,sorting,java,algorithm\
    \ dscore=0 |>\n<| c |>\nWhat about when the array has duplicates?\n<|/ c |>\n\
    <| c |>\nThis code does not solve the problem in the question where duplicates\
    \ are allowed. For example, in your example, it returns an array `[-3L, -2L, -1L,\
    \ 1L, 2L, 3L]`. It does however solve the problem where duplicates are disallowed.\
    \ This code returns an array `[-3L, -2L, -1L, 2L, 3L, 1L]`.\n<|/ c |>\n<| c |>\n\
    I assumed duplicates would be disallowed. OP's description of what he wants is\
    \ ambiguous to me but this answer will do what he asked for in the question.\n\
    <|/ c |>\n<| a tags=arrays,sorting,java,algorithm |>\nHere is my solution:\n<code>\n\
    public class Main {", "{\n    // write your code here\n    int n = arr.Length;\n\
    \    long temp = 0;\n    long[] ret = new long[k];\n    for (int i = 0; i < k;\
    \ i++) ret[i] = 0;\n    for (int i = 0; i < n; i++) \n    {\n        for (int\
    \ j = 0; j < k; j++)\n        {\n            if (arr[i] > ret[j])\n          \
    \  {\n                temp = arr[i];\n                arr[i] = ret[j];\n     \
    \           ret[j] = temp;\n            }\n        }\n    }\n    return ret;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe question asks for the `k`-th largest\
    \ element, not the k'th largest element in the array.\n<|/ c |>\n<| c |>\nYour\
    \ solution is very inefficient\n<|/ c |>\n<| c |>\nIt is not. It is not an O(n2)\
    \ solution. An O(n) solution with an auxiliary array is much faster.\n<|/ c |>\n\
    <| c |>\nYour solution isn't O(n) either. Try it with a list of 10 million elements,\
    \ and you start getting `O(n^2)` performance.\n<|/ c |>\n<| c |>\n, you are right,\
    \ I meant `O(n)` performance as in _linear time_ complexity, which is `O(n)` here.\
    \ It is indeed `O(n^2)` in the worst case with my solution.\n<|/ c |>\n<| a dscore=0\
    \ tags=arrays,c#,sorting |>\nThis is O(n log k) solution:\n<code>\nprivate static\
    \ int[] maximum(int[] arr, int k) {\n    Array.Sort(arr);", "{\n    long[] result\
    \ = new long[k];\n    long curMax = 0;\n    long curMaxIndex = 0;\n    for(int\
    \ i = 0; i < k; ++i)\n    {\n        if(curMaxIndex < arr.length && arr[i] > curMax)\n\
    \        {\n            curMax = arr[i];\n            curMaxIndex = i;\n     \
    \   }\n        result[i] = curMax;\n    }\n    return result;\n}", "{\n\tint low\
    \ = 0;\n\tint high = arr.length;\n\tint mid = (low+high)/2;\n\tint count = 0;",
  "{\n    int i,j,k;\n    long ans[1000];\n    for(j=0;j<k;j++) ans[j] = arr[j];\n\
    \    k=0;\n    for(i=0;i<k;i++) {\n        for(j=0;j<k;j++) {\n            ans[k]\
    \ = min(ans[k], arr[j]);\n            arr[j] = ans[k];\n        }\n        ans[k]\
    \ = arr[i];\n    }\n    return ans;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    What if the array size is very large? In that case, we will run out of memory.\n\
    <|/ c |>\n<| c |>\nYou also have to store the previous maximum value you had stored\
    \ in ans array if that maximum value was greater than the arr[i]\n<|/ c |>\n<|\
    \ c |>\nYou don't need to store the previous maximum value, you just need to store\
    \ the minimum value of each pass and replace the current array element with the\
    \ minimum value you stored.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include<iostream>\n\
    using namespace std;\n#define MAX 100", "{\n    int n = arr.length;\n    int m\
    \ = n;\n    while (m >= k && arr[n - m] > arr[m]) \n        m--;\n    long[] res\
    \ = new long[k];\n    for (int i = 0; i < k; i++) \n    {\n        int j = n;\n\
    \        while (j >= k - 1 && arr[j - k] > arr[j - m]) \n            j--;\n  \
    \      res[i] = arr[j];\n    }\n    return res;\n}", "{\n    if (k == 1) return\
    \ arr;\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n   \
    \ int curMax = arr[0];\n    for (int i = 1; i < k; i++) \n    {\n        if (arr[i]\
    \ > curMax) \n        {\n            result[j++] = curMax;\n            curMax\
    \ = arr[i];\n        }\n        else \n        {\n            curMax = arr[i];\n\
    \        }\n    }\n    result[j++] = curMax;\n    return result;\n}", "{\n   \
    \ int low = 0;\n    int high = arr.length - 1;", "{\n    var list = new ArrayList();\n\
    \    for(int i = 0; i < k; i++)\n    {\n        list.add(arr[i]);\n    }\n   \
    \ for(int i = k; i < arr.Length; i++)\n    {\n        list.add(arr[i]);\n    }\n\
    \    return list.toArray();\n}\n</code>\n<|/ a |>\n<| c |>\nNice one. Just to\
    \ make it more generic, use this: `long[] maximum(long[] arr, int k)`. Also, `Arrays.asList`\
    \ is redundant. `Arrays.asList(arr).subList(k, arr.length)` will suffice.\n<|/\
    \ c |>\n<| c |>\nThis is better than my solution.  But you should probably use\
    \ `Math.Min` instead of `Arrays.sort` and then `Arrays.copyOfRange` for the final\
    \ step.\n<|/ c |>\n<| c |>\nThe first two for loops are not necessary, you can\
    \ just do  `for (int i = 0; k < arr.Length; i++)`\n<|/ c |>\n<| a dscore=0 |>\n\
    Here's a solution I implemented some time ago.\nIt returns a sorted array with\
    \ the most popular elements. It's not optimized since it's O(nlogn) instead of\
    \ O(n) but it works ;)\n<code>\n/**\n * Sort the provided array in descending\
    \ order and return an array with the most popular elements.\n * \n * arr\n *\n\
    \ */\npublic static long[] mostPopular(long[] arr) {\n    long maxVal = 0;\n \
    \   int maxCount = 0;\n    List<Long> list = new ArrayList<>();\n    Arrays.sort(arr);",
  "{\n    long[] result = new long[k];\n    int pos = 0, i = 0, j = 0, m = 0;\n  \
    \  long curr = 0, max = 0, min = 0;\n    while (i < arr.length)\n    {\n     \
    \   curr = arr[i];\n        if (pos == k)\n        {\n            result[m++]\
    \ = max;\n            pos = 0;\n            max = curr;\n        }\n        else\
    \ if (curr > max)\n        {\n            max = curr;\n            pos = pos;\n\
    \        }\n        else if (curr < min)\n        {\n            min = curr;\n\
    \        }\n        i++;\n    }\n    \n    if (pos != k)\n    {\n        result[m++]\
    \ = max;\n    }\n    \n    Arrays.sort(result);\n    return result;\n}", "{\n\
    \    int n = arr.length;\n    if (n < k) k = n;\n    long[] result = new long[k];\n\
    \    Arrays.sort(arr);\n    long max = arr[0];\n    long pos = 1;\n    for (int\
    \ i = 1; i < k; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n\
    \            pos = i;\n        }\n    }\n    result[pos] = max;\n    return result;\n\
    }", "{\n    long[] result = new long[k];\n    int n = arr.length;\n    int m =\
    \ 0;\n    int i, j, max;\n    for (i = 0; i < n; i++)\n    {\n        max = arr[i];\n\
    \        for (j = i + 1; j < n; j++)\n        {\n            if (max < arr[j])\n\
    \            {\n                max = arr[j];\n                m = j;\n      \
    \      }\n        }\n        result[m] = max;\n    }\n    return result;\n}",
  "{\n    int len = arr.length;\n    long[] result = new long[k];\n    int i, j, max\
    \ = 0;\n    long curr;\n    \n    for (i = 0; i < k; i++) {\n        curr = arr[i];\n\
    \        for (j = 0; j < len; j++) {\n            if (j != i) {\n            \
    \    if (curr < arr[j]) {\n                    max = j;\n                    break;\n\
    \                }\n            }\n        }\n        result[i] = arr[max];\n\
    \        arr[max] = arr[i];\n        arr[i] = curr;\n    }\n    return result;\n\
    }", "{\n    long[] res;\n    int i = 0;\n    int j = 0;\n    int len = 0;\n  \
    \  long max;\n    long a = 0;\n    long b = 0;", "{\n    long[] maximum = new\
    \ long[k];\n    long count = 0;\n    int i = 0;\n    for (int n : arr)\n    {\n\
    \        if (n == k)\n        {\n            maximum[i] = n;\n            i++;\n\
    \        }\n        else\n        {\n            if (count < k - count)\n    \
    \            maximum[count] = n;\n            else\n            {\n          \
    \      maximum[count] = k;\n                count = 0;\n                i = 1;\n\
    \            }\n        }\n        count++;\n    }\n    return maximum;\n}", "{\n\
    \    var ans = new long[k];\n    \n    Arrays.sort(arr);\n    \n    for (int i\
    \ = 0; i < k; ++i)\n        ans[i] = arr[i];\n    \n    return ans;\n}", "{\n\
    \    int n = arr.length;\n    long[] result = new long[k];\n    \n    Arrays.sort(arr);",
  "{\n    long[] r = new long[k];\n    long n = arr.length;\n    if (k < 0 || k >\
    \ n) throw new IllegalArgumentException(\"k must be in range [0, \" + n + \")\"\
    );\n    \n    long res = arr[0];\n    \n    for (int i = 1; i < k; ++i) res =\
    \ max(res, arr[i]);\n    \n    if (arr[k-1] >= res)\n    {\n        r[0] = arr[k-1];\n\
    \        r[k-1] = arr[k];\n    }\n    else\n    {\n        r[k-1] = arr[k];\n\
    \    }\n    \n    for (int i = k - 2; i >= 0; --i) r[i+1] = r[i];\n    \n    return\
    \ r;\n}", "{\n    long[] result = new long[k];", "{\n    int l = 0, h = arr.length\
    \ - 1;\n    long[] ans = new long[k];\n    while (l < h) {\n        int m = (l\
    \ + h) / 2;\n        if (m == k) {\n            int m1 = m;\n            while\
    \ (m1 > 0) {\n                ans[m] = arr[m1];\n                m1--;\n     \
    \       }\n            h = m - 1;\n        } else if (m < k) {\n            l\
    \ = m + 1;\n        } else {\n            h = m - 1;\n        }\n    }\n    return\
    \ ans;\n}", "{\n    int n = arr.length;\n    if (k > n || k < 1) {\n        throw\
    \ new RuntimeException(\"k must be > 0 and <= \" + n);\n    }", "{\n    long[]\
    \ result = new long[k];\n    Arrays.sort(arr);\n    \n    for (int i = 0; i <\
    \ k; ++i)\n        result[i] = arr[i];\n    return result;\n}\n</code>\n<|/ a\
    \ |>\n<| a |>\n<code>\nstatic long[] sort(long[] arr, int k) {\n    Arrays.sort(arr);\n\
    \    long[] result = new long[k];\n    for (int i = 0; i < k; i++) {\n       \
    \ result[i] = arr[i];\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,arrays,sorting,java\
    \ |>\n<| a dscore=0 |>\n<code>\npublic static long[] getMaxValueFromArray(long[]\
    \ arr, int k){\n    Arrays.sort(arr);\n    long[] result = new long[k];\n    int\
    \ currentIndex = 0;\n    while(currentIndex < k){\n        result[currentIndex]\
    \ = arr[currentIndex];\n        currentIndex++;\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=algorithm,arrays,sorting,java |>\n<| c |>\nWhile this code\
    \ may answer the question, providing additional context regarding how and/or why\
    \ it solves the problem would improve the answer's long-term value.\n<|/ c |>\n\
    <| c |>\nCode only answers are usually not very useful. You could improve this\
    \ answer by explaining what your code does.\n<|/ c |>\n<| c |>\nThis is not an\
    \ answer.  It should be a comment, not an answer.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\npublic static void main(String []args){\n    long[] arr = { 10, -5, 9,\
    \ 2, 5, -16, 10, -1, 5, 10};\n    System.out.println(Arrays.toString(getMaxValueFromArray(arr,\
    \ 5)));\n}", "{\n    int n = arr.length;\n    int m = k;\n    long[] result =\
    \ new long[m];\n    int i, j;", "{\n    int start = 0;\n    int end = arr.length\
    \ - 1;\n    long[] res = new long[k];\n    while (start <= end) {\n        int\
    \ mid = start + (end - start) / 2;\n        if (arr[mid] > k) {\n            end\
    \ = mid - 1;\n        } else if (arr[mid] < k) {\n            start = mid + 1;\n\
    \        } else {\n            res[mid] = arr[mid];\n        }\n    }\n    return\
    \ res;\n}\n/*", "{\n    int i, pos;\n    long[] res = new long[k];\n    \n   \
    \ for (i = 0; i < k; i++)\n    {\n        pos = (i + (k - i)) / 2;\n        \n\
    \        if (arr[i] > arr[pos])\n            res[i] = arr[pos];\n        else\n\
    \            res[i] = arr[i];\n    }\n    \n    return res;\n}\n</code>\n<|/ a\
    \ tags=dynamic-programming,arrays,algorithm |>\n<| a dscore=2 |>\n<code>\ndef\
    \ max_in_arr(n, arr):\n    ans = []\n    \n    for s in arr:\n        if s not\
    \ in ans:\n            ans.append(s)\n    \n        if len(ans) < n:\n       \
    \     ans.insert(0,0)\n    \n        ans.sort(reverse = True)\n    \n    return\
    \ ans\n</code>\n<|/ a tags=dynamic-programming,arrays,algorithm |>\n<| a dscore=1\
    \ |>\nOne simple way is to sort your array from lowest to highest and then iterate\
    \ through it to get the maximum value.\nHere is an example in Python\n<code>\n\
    def maximum(a,b):\n    a.sort()\n    maxVal = a[b]\n    \n    for x in a:\n  \
    \      if x > maxVal:\n            maxVal = x\n    return maxVal\n</code>\n<|/\
    \ a tags=dynamic-programming,arrays,algorithm |>\n<| c |>\nThis approach will\
    \ not work with negative numbers (when sorted in ascending order) and also will\
    \ work if the array is empty when `a[0] > 0`.\n<|/ c |>\n<| a dscore=1 |>\nHere\
    \ is a c++ code for solving it\n<code>\n#include <bits/stdc++.h>\nusing namespace\
    \ std;\n#define ll long long\n#define maxn 1000000007LL\n#define maxd 1000000007LL\n\
    #define INF (1e9+7)\n#define MOD ((ll)1e9+7)\n#define deb(x) cout << #x << \"\
    \ = \" << x << endl", "{\n    int count = 0;\n    long[] results = new long[k];",
  "{\n    int len = arr.length;\n    int ans = k; \n    long[] res = new long[ans];",
  "{\n    long[] result = new long[k];\n    Arrays.sort(arr);\n    for(int i=0; i<k;\
    \ i++) \n    {\n        result[i] = arr[i];\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=sorting,arrays |>\n<| a tags=sorting,arrays |>\nJava version:\n<code>\n\
    \  private static long[] maximum(long[] arr, int k) {\n    int m = arr[0];\n \
    \   for (int i = 1; i < k; i++) {\n      m = Math.max(m, arr[i]);\n    }\n   \
    \ long[] result = new long[k];\n    Arrays.sort(arr);\n    for (int i = 0; i <\
    \ k; i++) {\n      result[i] = arr[i];\n    }\n    for (int i = k; i >= 0; i--)\
    \ {\n      if (result[i] > m) {\n        return result;\n      }\n    }\n    return\
    \ result;\n  }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=sorting,arrays\
    \ |>\nHere is a Python solution that avoids the sort and uses the built-in max()\
    \ function instead of the sort function:\n<code>\ndef maximum(arr: list) -> int:\n\
    \    if len(arr) == 0:\n        return 0", "{\n    if (k > arr.Length)\n    {\n\
    \        k = arr.Length;\n    }\n    var max = new long[k];\n    long maxI = 0;\n\
    \    for (int i = 0; i < arr.Length; i++)\n    {\n        if (arr[i] > arr[maxI])\n\
    \        {\n            max[maxI] = arr[i];\n            maxI++;\n        }\n\
    \    }\n    if (maxI == k)\n    {\n        return arr;\n    }\n    long minI =\
    \ 0;\n    long minJ = 0;\n    for (int i = 0; i < arr.Length; i++)\n    {\n  \
    \      if (arr[i] < arr[minI])\n        {\n            minJ = minI;\n        \
    \    minI = i;\n        }\n        else if (arr[i] < arr[minJ])\n        {\n \
    \           minJ = i;\n        }\n    }\n    max[minI] = arr[minJ];\n    maxI++;\n\
    \    if (maxI == k)\n    {\n        return arr;\n    }\n    return max;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nA recursive solution is always nice, but I guess this\
    \ won't work properly if the array contains multiple equal elements.\n<|/ c |>\n\
    <| c |>\nThe OP did not specify anything about multiple equal elements.\n<|/ c\
    \ |>\n<| c |>\nI guess my comment was more of a 'hint' than an 'answer'. I agree\
    \ that there might be a problem with the 'solution' if the same element appears\
    \ more than once, but I'm not sure how to address that when comparing two elements\
    \ in the array instead of one.\n<|/ c |>\n<| c |>\nYour code doesn't work if the\
    \ array contains multiple equal elements. I updated my answer so now the code\
    \ should work correctly for multiple equal elements. I didn't think about it initially,\
    \ because the question is too narrow, but I guess you can now add that case to\
    \ your code and my answer will still be correct\n<|/ c |>\n<| a |>\nHere is a\
    \ different answer that uses .OrderByDescending instead of .OrderBy, so it will\
    \ order ascending.\n<code>\npublic static IEnumerable<T> MaxIndex<T>(IEnumerable<T>\
    \ source, Func<T, int> selector)\n{\n    List<T> results = new List<T>();\n  \
    \  using (IEnumerator<T> enumerator = source.GetEnumerator())\n    {\n       \
    \ bool hasNext = enumerator.MoveNext();\n        int maxIndex = -1;", "{\n   \
    \ if(arr.length<=k){\n        throw new IllegalArgumentException(\"k cannot be\
    \ greater than length of the array\");\n    }", "{\n    long long curMax = -9223372036854775808,\
    \ curIdx;\n    long long newMax = curMax;\n    long[] result = new long[k];",
  "{\n\tint pos = 1;\n\tlong max = 0L;\n\twhile (pos < k) {\n\t\tif (arr[0] > max)\
    \ {\n\t\t\tmax = arr[0];\n\t\t}\n\t\t\n\t\tfor (int i = 1; i < k; i++) {\n\t\t\
    \tif (arr[i] > max) {\n\t\t\t\tmax = arr[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (arr[k]\
    \ > max) {\n\t\t\tmax = arr[k];\n\t\t}\n\t\t\n\t\tpos++;\n\t}\n\t\n\tlong[] result\
    \ = new long[pos];\n\t\n\tfor (int i = 0; i < pos; i++) {\n\t\tresult[i] = arr[i];\n\
    \t}\n\t\n\tfor (int i = pos - 1; i >= 0; i--) {\n\t\tresult[i] = arr[i];\n\t}\n\
    \t\n\treturn result;\n}", "{\n    long[] result = new long[k];\n    \n    int\
    \ i;\n    for (i = 0; i < k; i++)\n    {\n        result[i] = std.math.max(arr[i]);\n\
    \    }\n    \n    std.array.SortDescending<int>(result);\n    \n    return result;\n\
    }\n/*", "{\n    int len = 0;\n    for(int i = 0; i < arr.length; ++i) \n     \
    \   if(arr[i] > 0) \n        {\n            len += 1;\n            if(len >= k)\
    \ \n            {\n                long temp = 0;\n                for(int j =\
    \ 0; j < len; ++j) \n                    temp = arr[j];\n                arr[len]\
    \ = arr[0];\n                arr[0] = temp;\n                len--;\n        \
    \    }\n        }\n    \n    long temp = 0;\n    for(int i = 0; i < len; ++i)\
    \ \n        temp = arr[i];\n    arr[len] = arr[0];\n    arr[0] = temp;\n    return\
    \ arr;\n}\n// @lc code=end", "{\n    if (k > arr.Length)\n    {\n        throw\
    \ new ArgumentOutOfRangeException(\"k\", \"k can't be greater than or equal to\
    \ the length of arr\");\n    }", "{\n    long[] result = new long[k];\n    Arrays.sort(arr);\n\
    \    Arrays.fill(result, arr[arr.length - 1]);\n    for (int i = arr.length -\
    \ 2; i >= 0; i--) \n    {\n        if (arr[i] > arr[i + 1]) {\n            result[i]\
    \ = arr[i];\n        } \n        else if (arr[i] != arr[i + 1]) {\n          \
    \  result[i] = arr[i + 1];\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,arrays |>\n<| c |>\nGreat solution! Just two notes: a) this solution\
    \ is O(n^2) while this other answer is O(n). b) this solution requires Java 8\
    \ and it requires to implement `Comparable<Long>` interface.\n<|/ c |>\n<| c |>\n\
    - a) yes - that's why I upvoted the other answer. I was actually thinking the\
    \ other one too as well.  But I went ahead and just copy/pasted my own answer\
    \ and removed my own, even though that one was better.   I didn't think that was\
    \ important enough to include in my answer.  b) Ok, good to know that.  Thanks.\
    \  I should note that my code doesn't actually require Java 8.\n<|/ c |>\n<| c\
    \ |>\nStrange. I'm getting an ArrayIndexOutOfBoundsException on line `Arrays.fill(result,\
    \ arr[arr.length - 1]);` which makes no sense to me. I do have Java 8 in my IDE\
    \ though.\n<|/ c |>\n<| c |>\n- maybe you didn't pass an array?  If you didn't\
    \ pass an array and you were just running this as a static method, that's probably\
    \ the problem.  I just tested it myself and it works fine in Java 8.  However,\
    \ if you're passing in an array (as I assumed), you may need to do something like\
    \ `Arrays.fill(result, (long) 0);`.  Just trying to think of the situation where\
    \ this wouldn't work.\n<|/ c |>\n<| c |>\nNo, the array is passed in when I call\
    \ the method. That's what I'm thinking. That's what I'm so confused about. I'm\
    \ calling the method from a main method in the very same class and it's throwing\
    \ the exception before I even enter the method.\n<|/ c |>\n<| a |>\nFor those\
    \ who want a one-liner, the following code works:\n<code>\nstatic <T> T[] maximumWithComparison(T[]\
    \ arr, Comparator<T> comp) {\n    Arrays.sort(arr, comp);\n    return Arrays.copyOfRange(arr,\
    \ arr.length - 1, arr.length);\n}\n</code>\n<|/ a tags=java,arrays dscore=5 |>\n\
    <| ", "{\n    if (k > arr.length)\n        k = (k + arr.length) / 2;\n    \n \
    \   int n = arr.length;\n    long max = arr[0];\n    long[] maxs = new long[k];",
  "{\n    if(arr.length == 0) return new long[0];\n    if(k == 0) return arr;", "{\n\
    \    if (k == 0)\n    {\n        return arr;\n    }\n    long[] ans = new long[k];\n\
    \    long m = 0;\n    long len = arr.length;\n    for (int i = 0; i < len; i++)\n\
    \    {\n        m = Maths.max(m, arr[i]);\n    }\n    for (int i = 0; i < len;\
    \ i++)\n    {\n        if (m == arr[i])\n        {\n            ans[i] = arr[i];\n\
    \        }\n        else if (m < arr[i])\n        {\n            ans[i] = m;\n\
    \        }\n    }\n    return ans;\n}\n/*", "{\n    long[] res = new long[k];",
  "{\n    long[] res = new long[k];", "{\n    int len = arr.length;\n    long[] res\
    \ = new long[k];\n    int i = 0;", "{\n    long[] result = new long[k];\n    long[]\
    \ tail = new long[arr.length-k];\n    \n    mergeSort(arr, 0, tail.length, tail,\
    \ 0, tail.length, result, k);", "{\n    long[] result = new long[k];\n    Arrays.sort(arr);\n\
    \    Arrays.fill(result, k);\n    return result;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,c#,arrays,sorting\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| a dscore=1 |>\nIn C#, we can do with Linq:\n<code>\nvar\
    \ max = array.Max(i => i);\n</code>\n<|/ a tags=algorithm,c#,arrays,sorting |>\n\
    <| a tags=algorithm,c#,arrays,sorting |>\n<code>\npublic static int[] maximum(int[]\
    \ arr, int k) {\n    var maximum = new int[k];", "{\n    if (k == 0)\n       \
    \ return arr;\n    long[] max_nums = new long[k];\n    Arrays.setAll(max_nums,\
    \ (a, b) -> Math.max(a, b));\n    int n = arr.length;\n    long max_num = arr[0];\n\
    \    for (int i = 1; i < n; ++i) \n    {\n        long num = arr[i];\n       \
    \ if (num > max_num)\n        {\n            max_num = num;\n        }\n    }\n\
    \    Arrays.sort(max_nums);\n    int count = 0;\n    for (int i = 0; i < k; ++i)\
    \ \n    {\n        if (max_nums[i] != max_num) \n        {\n            count++;\n\
    \            max_nums[count - 1] = max_nums[i];\n        }\n    }\n    return\
    \ max_nums;\n}\n</code>\n<|/ a tags=c#,arrays |>\n<| c |>\nCan you please tell\
    \ me the reason of downvote? This is exactly the same solution as `Abu` has proposed.\n\
    <|/ c |>\n<| c |>\nI didn't downvote, but I do think your solution is overly complicated\
    \ and very inefficient. It also has an error in that it does not account for duplicate\
    \ maximum values when there are multiple equal values.\n<|/ c |>\n<| c |>\nIt\
    \ doesn't have error because in his question he didn't mention about duplicate\
    \ maximum values. If you check my answer you will find out that my code doesn't\
    \ contain any error.\n<|/ c |>\n<| c |>\nAbu, can you please explain how you got\
    \ the answer of `Abu`? I'm curious to know how you did it! Thanks!\n<|/ c |>\n\
    <| c |>\nI used the example in the question and wrote the code as I showed in\
    \ my answer. I tested the code and everything works as expected. You can try and\
    \ see the result if you want.\n<|/ c |>\n<| a dscore=4 |>\n<code>", "{\n\tint\
    \ start = 0;\n\tint end = 0;\n\tint len = arr.length;\n\tlong[] res = new long[k];\n\
    \tlong max = arr[0];\n\tfor (int i = 0; i < len; i++) {\n\t\tif (arr[i] > max)\
    \ {\n\t\t\tmax = arr[i];\n\t\t}\n\t}\n\twhile (end < len) {\n\t\tfor (int i =\
    \ start; i < len; i++) {\n\t\t\tif (arr[i] > max) {\n\t\t\t\tmax = arr[i];\n\t\
    \t\t}\n\t\t}\n\t\tend++;\n\t\tfor (int i = start; i < len; i++) {\n\t\t\tif (arr[i]\
    \ < max) {\n\t\t\t\tlong tmp = max;\n\t\t\t\tmax = arr[i];\n\t\t\t\tres[i - start]\
    \ = tmp;\n\t\t\t}\n\t\t}\n\t\tstart++;\n\t}\n\treturn res;\n}", "{\n\tlong[] ret\
    \ = new long[k];\n    \n    int n = (int) Math.Floor(arr.Length / k);\n    \n\
    \    for (int i = 0; i < k; i++)\n    {\n        ret[i] = arr[n*k+i];\n    }\n\
    \    \n    return ret;\n}", "{\n    long[] result = new long[k];\n    Arrays.sort(arr);\n\
    \    int pos = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if\
    \ (pos < k - 1)\n        {\n            if (arr[i] > arr[pos])\n            {\n\
    \                pos = i;\n            }\n        }\n        else\n        {\n\
    \            result[pos] = arr[i];\n            pos++;\n        }\n    }\n   \
    \ return result;\n}\n// end of function maximum\n</code>\n<|/ a tags=list,java,arrays,sorting\
    \ |>\n<| a |>\n<code>\npublic static List<Integer> maximumSubList(List<Integer>\
    \ list) {\n        Comparator<Integer> cmp = new Comparator<Integer>() {\n   \
    \         public int compare(Integer a, Integer b) {\n                return Integer.compare(a,\
    \ b);\n            }\n        };\n        Collections.sort(list, cmp);", "{\n\t\
    long[] result = new long[k];\n\tArrays.sort(arr);\n\tfor (int i = 0; i<k; i++)\n\
    \t\tresult[i] = arr[i];\n\treturn result;\n}\n/*", "{\n    int i, cur, max;",
  "{\n    if (k > arr.length) \n    {\n        return arr;\n    }", "{\n    if (k\
    \ > arr.length) return new long[0];\n    long[] ret = new long[k];\n    Arrays.sort(arr);\n\
    \    for (int i = 0; i < k; i++) {\n        ret[i] = arr[i];\n    }\n    return\
    \ ret;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is not the correct answer as it will\
    \ always return first and last element of array when k is small.\n<|/ c |>\n<|\
    \ a tags=arrays,java |>\n<code>\npublic int[] maximum(int arr[], int k){\n   \
    \ if (arr.length < k){\n        return arr;\n    }\n    int max = arr[0];\n  \
    \  int maxIndex = 0;\n    int currentIndex = 0;\n    for(int i = 0; i < k; i++){\n\
    \        if(max < arr[i]){\n            max = arr[i];\n            maxIndex =\
    \ i;\n        }\n    }\n    int[] result = new int[k];\n    for(int i = 0; i <\
    \ k; i++){\n        if (i == maxIndex){\n            result[i] = max;\n      \
    \  } else {\n            result[i] = arr[i];\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=arrays,java |>\nFor this question you\
    \ first need to find the highest element from the array\n<code>\npublic class\
    \ maxInArray {\n    public static void main(String[] args) {\n        int[] arr\
    \ = {3, -1, 4, -5, 7, 2};\n        int maxElement = findMax(arr);\n        System.out.println(maxElement);\n\
    \    }", "{\n    /*\n    Time Complexity: O(N)\n    Space Complexity: O(1)\n \
    \   */\n    int max = arr[0];\n    long[] result = new long[k];", "{\n    List<long>\
    \ result = new List<long>();\n    bool flag = true;\n    for(int i = 0; i < arr.Length;\
    \ i++)\n    {\n        if(flag)\n        {\n            flag = false;\n      \
    \      result.Add(arr[i]);\n        }\n        else\n        {\n            if(arr[i]\
    \ > result.Last())\n            {\n                result.Add(arr[i]);\n     \
    \       }\n        }\n    }\n    result.Sort();\n    for(int i = 0; i < k; i++)\n\
    \    {\n        result.RemoveAt(result.Count - 1);\n    }\n    return result.ToArray();\n\
    }\n</code>\n<|/ a tags=c#,arrays |>\n<| c |>\nthis algorithm will fail in case\
    \ if array contain same value more than once.\n<|/ c |>\n<| c |>\n: Why should\
    \ it fail? If you have a sorted array, you can just remove the duplicate entries\
    \ and use the result to return the same array.\n<|/ c |>\n<| a |>\nFor those who\
    \ prefer Linq:\n<code>\npublic int[] maximum(int[] array, int k)\n{\n    return\
    \ Enumerable.Range(0, array.Length)\n                     .Where(i => array.Length\
    \ > k)\n                     .TakeWhile(i => array.Length <= k)\n            \
    \         .Concat(array.Where(i => array.Length > k - i - 1))\n              \
    \       .OrderByDescending(i => i)\n                     .ToArray();\n}\n</code>\n\
    <|/ a dscore=2 tags=c#,arrays |>\n<| a tags=c#,arrays dscore=1 |>\nThis version\
    \ also works for the case with duplicate values, and is much simpler:\n<code>\n\
    public int[] maximum(int[] array, int k)\n{\n    var newArray = new int[k];\n\
    \    var maxVal = 0;", "{\n    var result = new long[k];", "{\n    if (k == 0)\
    \ \n        return arr;\n    long[] arr = new long[k];\n    sort(arr, arr, 0,\
    \ arr.length);\n    long max = arr[0];\n    for(int i = 1; i < k; i++) \n    \
    \    if (arr[i] > max) \n            max = arr[i];\n    return arr;\n}\n</code>\n\
    <|/ a tags=algorithm |>\n<| a |>\nI assume you mean \"the maximum element in the\
    \ array\" rather than \"the largest value of a specific element\".  You can find\
    \ the maximum element by first finding the max value and moving the maximum element\
    \ to the start of the array.  You only need to do this once, so you can do it\
    \ with a single for loop.\n<|/ a tags=algorithm dscore=1 |>\n<| a |>\nHere is\
    \ the O(n) solution.\n<code>\n// O(nlogn)", "{\n    int n = arr.length;\n    long[]\
    \ maximum = new long[k];\n    Arrays.sort(arr);\n    for (int i = 0; i < k; i++)\
    \ {\n        maximum[i] = arr[i];\n    }\n    return maximum;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nI did not even notice that my code was comparing the result to\
    \ itself :-)\n<|/ c |>\n<| c |>\nPlease don't post only code as an answer, but\
    \ also provide an explanation of what your code does and how it solves the problem\
    \ of the question. Answers with an explanation are usually more helpful and of\
    \ better quality, and are more likely to attract upvotes.\n<|/ c |>\n<| c |>\n\
    Thank you. I have added an explanation.\n<|/ c |>\n<| a dscore=0 tags=algorithm,sorting,java,big-o\
    \ |>\nThe above algorithms work fine. But there is an alternative way to solve\
    \ the problem.\n<code>\n    long x[] = {100, 200, 500, 1000, 2000};\n    int y[]\
    \ = {5, 3, 1, 1, 1};\n    Arrays.sort(x);\n    System.out.println(Arrays.toString(y));\n\
    </code>\nIt will give you the output as [1, 1, 2, 3, 5]\n<|/ a |>\n<| c |>\nThat\
    \ would not work. `y` is just an array containing the same elements as `x`.\n\
    <|/ c |>\n<| c |>\nThis doesn't work. `Arrays.sort` sorts the array in-place,\
    \ meaning that `x` will still contain the values the same. That's why you get\
    \ the same output as in the original code.\n<|/ c |>\n<| a tags=algorithm,sorting,java,big-o\
    \ dscore=0 |>\nThe other answers already gave you some code for a simple implementation.\
    \ Another solution is using Java 8 Streams. It's probably not the most efficient\
    \ solution, but if you're looking for a quick answer, it's probably the easiest\
    \ to understand.\n<code>", "{\n    long ret[arr.length];\n    Arrays.fill(ret,\
    \ -1000);\n    int i, cnt=0, mIdx=-1, mVal;\n    for(i=1;i<arr.length;++i) {\n\
    \        mVal = arr[i];\n        for(;cnt>0 && mVal>ret[mIdx];++mIdx);\n     \
    \   ret[mIdx] = mVal;\n        --cnt;\n    }\n    cnt=0;\n    for(i=arr.length-1;i>=k;--i)\
    \ {\n        mVal = arr[i];\n        for(;cnt>0 && mVal>ret[mIdx];--mIdx);\n \
    \       ret[mIdx] = mVal;\n        --cnt;\n    }\n    Arrays.fill(ret, -1000);\n\
    \    return ret;\n}", "{\n    long n = 0;\n    long min = 10000000L;\n    long\
    \ max = -100000000;\n    long ans[] = new long[1001];\n    for(long i = 0; i <\
    \ arr.length; i++)\n    {\n        if(max < arr[i])\n        {\n            max\
    \ = arr[i];\n        }\n        if(min > arr[i])\n        {\n            min =\
    \ arr[i];\n        }\n        ans[n] = arr[i];\n        n++;\n    }\n    Arrays.sort(ans);\n\
    \    ans = Arrays.copyOf(ans, n);\n    return ans;\n}\n</code>\n<|/ a tags=sorting,java,algorithm,arrays\
    \ |>\n<| a tags=sorting,java,algorithm,arrays |>\nThe most efficient way is to\
    \ use two variables max.len and min.len. Initially, both are set to zero. \nThe\
    \ first element is the largest. \n<code>\nmaxLen <- 1\nminLen <- 0\nwhile (arr.length\
    \ > 0){\n    if (arr[0] > maxLen){\n        maxLen <- arr[0]\n    }\n    if (arr[0]\
    \ < minLen){\n        minLen <- arr[0]\n    }\n    arr.shift(1)\n}\n</code>\n\
    Then find the difference between maxLen and minLen.\n<code>\ndiff <- maxLen -\
    \ minLen\n</code>\nNow you need to find the largest element in the array between\
    \ minLen and diff inclusive.\n<code>\nlargestElement <- arr[minLen+diff]\n</code>\n\
    The idea is that maxLen is the index of the largest element in the array. minLen\
    \ is the index of the smallest element. After you find the largest element, you\
    \ need to find the element that comes right after that element. For example, if\
    \ the largest element is at index maxLen, and you find that element right before\
    \ diff, then that element is at index minLen+diff.\n<|/ a dscore=4 |>\n<| c |>\n\
    Hi, please consider adding some more explanation to this answer so the OP can\
    \ understand.\n<|/ c |>\n<| c |>\nIt's a common misconception that `Arrays.sort(array)`\
    \ will sort the entire array. It only sorts the *range* [minIndex, maxIndex) where\
    \ maxIndex is inclusive and minIndex is exclusive.\n<|/ c |>\n<| c |>\nYes, you\
    \ are right. I should have said that `Arrays.sort()` will sort just the part that\
    \ falls within the `minIndex` and `maxIndex`. This is the reason for the `arr.shift`\
    \ call.\n<|/ c |>\n<| c |>\nAlso `Arrays.copyOf` should be replaced with `Arrays.copyOfRange`\n\
    <|/ c |>\n<| a tags=", "{\n    long i, sum, count;\n    long[] result = new long[k];\n\
    \    sum = 0;\n    count = 0;\n    for (i = 0 ; i < k; i++)\n    {\n        if\
    \ (arr[i] > sum)\n        {\n            sum = arr[i];\n        }\n        if\
    \ (arr[i] == sum)\n        {\n            result[count] = sum;\n            count++;\n\
    \        }\n    }\n    return result;\n}", "{\n    int len = arr.Length;\n   \
    \ int maxIdx = 0;\n    for(int i = 0; i < len; i++)\n    {\n        if(arr[i]\
    \ > arr[maxIdx])\n        {\n            maxIdx = i;\n        }\n    }\n    long[]\
    \ res = new long[k];\n    long max = arr[maxIdx];\n    for(int i = maxIdx + 1;\
    \ i <= k; i++)\n    {\n        if(arr[i] > max)\n        {\n            max =\
    \ arr[i];\n        }\n    }\n    for(int i = maxIdx; i < k; i++)\n    {\n    \
    \    res[i] = arr[i];\n    }\n    \n    return res;\n}", "{\n    if (k == 0) {\n\
    \        return arr;\n    }\n    if (k > 0) {\n        if (arr.length == 0) \n\
    \        {\n            throw new RuntimeException(\"No elements in the array.\"\
    );\n        }\n        if (arr.length <= k) \n        {\n            throw new\
    \ RuntimeException(\"Array length must be <= \" + k + \".\");\n        }\n   \
    \     // sort the array\n        Arrays.sort(arr);\n        \n        // get the\
    \ maximum\n        long maxNum = arr[k-1];\n        long[] subArray = new long[k];\n\
    \        for (int i = k-1; i >= 0; i--) \n        {\n            subArray[i] =\
    \ arr[i];\n        }\n        return subArray;\n    }\n    \n    throw new RuntimeException(\"\
    Negative value of k.\");\n}\n'''", "{\n    return _recursion(arr, k, long.MinValue);\n\
    }", "{\n    int i = 0;\n    int j = 0;\n    int n = arr.length;\n    long[] res\
    \ = new long[n];", "{\n    int n = arr.length;\n    if (k <= 0 || k >= n) return\
    \ arr;\n    \n    long[] ans = new long[k];\n    long[] m = new long[k];\n   \
    \ long curr = arr[0];\n    long max;\n    int i;\n    \n    for (i = 1; i < k;\
    \ i++) \n    {\n        m[i] = Math.max(curr, arr[i]);\n        curr = arr[i];\n\
    \    }\n    max = m[0];\n    \n    ans[0] = arr[0];\n    ans[1] = max;\n    \n\
    \    for (int i = 2; i < n; i++) \n    {\n        max = Math.max(max, m[i-1]);\n\
    \        if (max < m[i]) {\n            ans[i] = max;\n        }\n    }\n    \n\
    \    return ans;\n}", "{\n    long[] result = new long[arr.length];\n    Arrays.sort(arr);\n\
    \    for(int i = 0; i < k; i++){\n        result[i] = arr[i];\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is really clever, and\
    \ I like that it has constant space complexity (O(k) instead of O(k^2))\n<|/ c\
    \ |>\n<| a |>\n<code>", "{\n    int n = arr.length;\n    long[] res = new long[k];\n\
    \    long res = 0;\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < k; j++)\n        {\n            if(arr[i] > res)\n            {\n   \
    \             res = arr[i];\n            }\n        }\n    }\n    return res;\n\
    }\n</code>\n<|/ a tags=c++,arrays,algorithm |>\n<| c |>\nCan you add some more\
    \ information about your solution?\n<|/ c |>\n<| c |>\nIn your answer you do not\
    \ use any sorting algorithm. Is it possible to do so?\n<|/ c |>\n<| c |>\nThis\
    \ solution is O(n^2). Do you think the questioner could possibly have that kind\
    \ of constraint?\n<|/ c |>\n<| c |>\n, yes the questioner must have a constraint.\
    \ I've added a link to the sorting algorithm which might help.\n<|/ c |>\n<| a\
    \ tags=c++,arrays,algorithm |>\n<code>\n#include<bits/stdc++.h>\nusing namespace\
    \ std;", "{\n    int[] count = new int[k];\n    int max_count = 1;\n    \n   \
    \ for(int i = 0; i < arr.length; i++)\n    {\n        int count = 0;\n       \
    \ for(int j = 0; j < k; j++)\n        {\n            if(arr[j] <= arr[i])\n  \
    \          {\n                count++;\n                break;\n            }\n\
    \        }\n        if(count > max_count)\n        {\n            max_count =\
    \ count;\n        }\n    }\n    long[] result = new long[k];\n    \n    for(int\
    \ i = 0; i < k; i++)\n    {\n        result[i] = 0;\n    }\n    \n    for(int\
    \ i = 0; i < arr.length; i++)\n    {\n        int count = 0;\n        for(int\
    \ j = 0; j < k; j++)\n        {\n            if(arr[j] <= arr[i])\n          \
    \  {\n                count++;\n                break;\n            }\n      \
    \  }\n        if(count > max_count)\n        {\n            max_count = count;\n\
    \        }\n        result[max_count - 1]++;\n    }\n    \n    return result;\n\
    }", "{\n    int n = arr.Length;\n    long[] ret = new long[k];\n    for (int i\
    \ = 0; i < n; ++i)\n    {\n        ret[ret.length - 1 - i] = Math.Max(arr[i],\
    \ ret[ret.length - 1 - i]);\n    }\n    return ret;\n}\n</code>\n<|/ a |>\n<|\
    \ a |>\n<code>\nvar maximums = new List<long> { 7, 5, 6, 3, 8, 0, 4, 2, 9, 1,\
    \ 0 };\nvar result = maximums.OrderByDescending(x => x).Take(1);\nConsole.WriteLine(string.Join(\"\
    , \", result));\n</code>\n<|/ a tags=c#,arrays dscore=1 |>\n<| c |>\nThis doesn't\
    \ answer the OP's question and it's certainly not clear. How does it find the\
    \ maximum number in a list of numbers?\n<|/ c |>\n<| c |>\nOk, so i guess this\
    \ one will work too:\nvar result = maximums.OrderByDescending(x => x).Take(1);",
  "{\n    var int[] arr = arr;\n    var int N = arr.Length;\n    var int[] arr = new\
    \ int[k];", "{\n    if (k == 0) \n        return arr;\n    \n    int m = k - 1;\n\
    \    \n    for (int i = k - 1; i < arr.length; ++i) \n    {\n        if (arr[i]\
    \ > arr[m - 1]) \n        {\n            m = i - 1;\n        }\n        \n   \
    \     arr[i] = arr[m];\n        arr[m + 1] = arr[i];\n    }\n    \n    return\
    \ arr;\n}\n</code>\n<|/ a tags=algorithm,sorting,mergesort,c++ |>\n<| c |>\nFor\
    \ a large enough k the algorithm is O(n*k) which is not optimal.\n<|/ c |>\n<|\
    \ c |>\nThanks for the comment, I have fixed the O(n*k) problem. But now it seems\
    \ that it is still O(n^2) but worst case should be O(n*k) which should be very\
    \ very fast.\n<|/ c |>\n<| c |>\nOk, I made a little modification, now it works\
    \ on big arrays and is O(n*log(n)) in the worst case. It is also much faster then\
    \ my solution which was O(n^2) in worst case\n<|/ c |>\n<| c |>\nThis is not O(n*log(n))\n\
    <|/ c |>\n<| c |>\nI did not realize that it is O(n*k) for even arrays. Please\
    \ consider my modification.\n<|/ c |>\n<| a dscore=2 tags=algorithm,sorting,mergesort,c++\
    \ |>\nI assume you want to sort the array in place and that k is the number of\
    \ elements to take.\n<code>", "{\n    // write your code here\n    int i;\n  \
    \  int j;\n    int l;\n    int m;\n    long temp;\n    long[] larr;\n    if (k\
    \ == 0 || arr == null || arr.length < 1 || arr.length < k)\n    {\n        return\
    \ new long[k];\n    }\n    \n    larr = new long[k];\n    larr[0] = arr[0];\n\
    \    m = 1;\n    temp = arr[0];\n    for (i = 1; i < k; i++)\n    {\n        if\
    \ (arr[i] > temp)\n        {\n            m = 1;\n            temp = arr[i];\n\
    \        }\n        else if (arr[i] == temp)\n        {\n            m++;\n  \
    \      }\n        else\n        {\n            if (m > k)\n            {\n   \
    \             return larr;\n            }\n        }\n    }\n    larr[m - 1] =\
    \ arr[k - 1];\n    for (j = k - 2; j >= 0; j--)\n    {\n        temp = arr[j];\n\
    \        for (i = m; i >= 0; i--)\n        {\n            if (arr[i] > temp)\n\
    \            {\n                temp = arr[i];\n            }\n        }\n   \
    \     larr[j] = temp;\n    }\n    return larr;\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nThe approach of Majumder is simple and understandable. But in some cases\
    \ the sorting algorithm is complex. The algorithm that Majumder has implemented\
    \ is called a Bubble Sort.\nBubble Sort - QuickSort + Merge Sort", "{\n    int\
    \ n = arr.length;\n    long[] result = new long[n];\n    long max = 0;\n    \n\
    \    for (int i = 0; i < n; i++) {\n        max = Math.max(max, arr[i]);\n   \
    \ }\n    \n    int k = arr.length;\n    for (int i = 0; i < k; i++) {\n      \
    \  result[i] = max;\n        max = Math.max(max, result[i]);\n    }\n    \n  \
    \  return result;\n}", "{\n    long[] result = new long[k];\n    int i;\n    for(i\
    \ = 0; i < k; ++i)\n        result[i] = std.max(arr[i]);\n    \n    for(i = k;\
    \ i < arr.length; ++i)\n        result[i] = arr[i - 1];\n    return result;\n}",
  "{\n    if (k > arr.length) return arr;\n    long[] result = new long[k];\n    int\
    \ j = 0;\n    int end = arr.length - 1;\n    while (j < k) {\n        if (end\
    \ >= 0) {\n            if (arr[j] >= arr[j + 1]) {\n                result[j]\
    \ = arr[j];\n                j++;\n            }\n            else if (arr[j]\
    \ >= arr[end]) {\n                end--;\n            }\n            else {\n\
    \                j++;\n                end--;\n            }\n        }\n    \
    \    else {\n            if (arr[j] >= arr[j + 1]) {\n                result[j]\
    \ = arr[j];\n                j++;\n            }\n            else if (arr[j]\
    \ >= arr[j - 1]) {\n                j++;\n            }\n            else {\n\
    \                end--;\n            }\n        }\n    }\n    return std.algorithm.reverse(result);\n\
    }\n/*", "{\n    long[] result;\n    int i, j, maxi;\n    long max = -999999999;\n\
    \    \n    if ( k > arr.length )\n    {\n        throw new IllegalArgumentException(\"\
    The value of 'k' must be less than the length of 'arr'\");\n    }\n    else if\
    \ ( k == 0 )\n    {\n        result = new long[0];\n        return result;\n \
    \   }", "{\n    ArrayList <long> res = new ArrayList <long> ();", "{\n    int\
    \ n = arr.length;\n    long[] result = new long[k];\n    int j = 0;\n    int index\
    \ = 0;\n    for(int i = 0; i < (arr.length-k+1); i++)\n    {\n        if(j < k)\n\
    \            result[j++] = arr[index++];\n        else\n        {\n          \
    \  if(arr[index] > arr[index+1])\n            {\n                long[] temp =\
    \ maximum(new long[k], k);\n                System.arraycopy(temp, 0, result,\
    \ 0, k);\n                j = 0;\n            }\n            else\n          \
    \  {\n                result[j++] = arr[index++];\n            }\n        }\n\
    \    }\n    if(j < k)\n        result[j] = arr[index];\n    return result;\n}",
  "{\n    int n = arr.Length;\n    long[] result = new long[k];\n    long max = 0;\n\
    \    \n    for(int i = 0; i< n; i++)\n    {\n        if(max < arr[i])\n      \
    \  {\n            max = arr[i];\n        }\n    }\n    \n    for(int i = 0; i<\
    \ k; i++)\n    {\n        if(max < arr[i])\n        {\n            result[i] =\
    \ max;\n        }\n        else\n        {\n            result[i] = arr[i];\n\
    \        }\n    }\n    return result;\n}", "{\n    if(k == 0) return arr;", "{\n\
    \    int n = arr.length;\n    long[] result = new long[k];\n    Arrays.sort(arr);",
  "{\n    long len = arr.length;\n    long[] ans = new long[k];\n    \n    long temp\
    \ = 0;\n    int i = 0;\n    for (int j = 0; j < len; j++){\n        if(temp <\
    \ arr[j]){\n            ans[i++] = arr[j];\n            temp = arr[j];\n     \
    \   }\n    }\n    \n    for(int m = 0; m < k; m++){\n        ans[m] = ans[m] %\
    \ 1000;\n    }\n    \n    return ans;\n}\n'''\n</cell>\n<text>\nNaive Approach\
    \ - Kth Smallest Number", "{\n    List<long> result = new List<long>();", "{\n\
    \    int len = arr.length;\n    int k2 = k*k;", "{\n    int N=arr.length;\n  \
    \  long max=0;\n    for(int i=0; i<N; i++)\n    {\n        if(arr[i]>max)\n  \
    \      {\n            max=arr[i];\n        }\n    }\n    \n    long[] arr = new\
    \ long[k];\n    for(int j=0; j<k; j++)\n    {\n        arr[j]=max;\n    }\n  \
    \  return arr;\n}\n\"\"\"\ndef maximum_dartmouth(arr,k):\n    return maximum(dartmouth(arr,k),k)\n\
    def maximum_dartsonkov(arr,k):\n    return maximum(dartsonkov(arr,k),k)", "{\n\
    \    // write your code here\n    int high = arr.length-1;\n    int low = 0;\n\
    \    long[] max = new long[k];\n    long[] a = new long[k];\n    for(int i = 0;\
    \ i < k; i++){\n        max[i] = arr[i];\n    }\n    while(high >= low){\n   \
    \     for(int i = 0; i < k; i++){\n            if(max[i] > arr[high]){\n     \
    \           max[i] = arr[high];\n            }\n        }\n        high--;\n \
    \   }\n    while(high >= low){\n        for(int i = 0; i < k; i++){\n        \
    \    if(max[i] < arr[low]){\n                max[i] = arr[low];\n            }\n\
    \        }\n        low++;\n    }\n    for(int i = 0; i < k; i++){\n        a[i]\
    \ = max[i];\n    }\n    return a;\n}\n</code>\n<|/ a tags=c#,algorithm,arrays\
    \ |>\n<| c |>\nthis algorithm has a time complexity of O(n^2), and will probably\
    \ run in O(n^2) time also\n<|/ c |>\n<| c |>\nAh, good point.  I did think of\
    \ using QuickSelect to find the maximum (as in the OP's original solution), but\
    \ I decided that since this was a homework problem, I didn't want to spoil their\
    \ own answer.  But you're right: a solution with O(n) time would be much better.\n\
    <|/ c |>\n<| a dscore=2 |>\nAnother way to approach this problem is to create\
    \ an array of pairs.\nThe first element of each pair will be the maximum value\
    \ of the array (except the last element).\nThen, starting from index 1, start\
    \ comparing the current maximum with the next element in the array. If this element\
    \ is bigger than the maximum so far, then replace the current maximum and the\
    \ next element in the array with the current maximum and the next element in the\
    \ array.\nThis approach has O(n) time complexity and O(n) space complexity and\
    \ should be pretty easy to implement in C#.\nEdit:\nThe algorithm could be implemented\
    \ as follows:\n<code>", "{\n    int[] nums = new int[k];\n    Arrays.setAll(nums,\
    \ k -> Arrays.stream(arr).max().getAsLong());\n    Arrays.sort(nums, new Comparator<Integer>()\
    \ {\n        public int compare(Integer o1, Integer o2) {\n            return\
    \ o2 - o1;\n        }\n    });\n    return Arrays.copyOfRange(nums, 0, k);\n}\n\
    /*", "{\n    if ( k > arr.length || k == 0 )\n        throw new IllegalArgumentException();\n\
    \    \n    long[] res = new long[k];\n    \n    int j = 0;\n    \n    for (int\
    \ i = 0; i < arr.length && j < k; i++) \n    {\n        if ( arr[i] > res[j] )\n\
    \        {\n            res[j] = arr[i];\n            j++;\n        }\n    }\n\
    \    \n    if ( j < k )\n    {\n        for ( int i = j ; i < k ; i++ )\n    \
    \        res[i] = arr[i];\n        \n        for ( int i = 0 ; i < j ; i++ )\n\
    \            arr[i] = 0;\n    }\n    \n    return res;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nHi, I have added my own solution. Please have a look. Thank you.\n<|/\
    \ c |>\n<| a dscore=1 |>\nI know you already accepted an answer but this one is\
    \ an implementation that uses recursion to make the code look a little cleaner.\
    \ Also it might be useful to someone.\n<code>\npublic class Maximum {", "{\n \
    \   long[] res = new long[k];\n    int[] count = new int[k];\n    int[] idx =\
    \ new int[k];\n    int index = 0;\n    int pos = 0;\n    for (int i = 0; i < k;\
    \ ++i) {\n        count[i] = 0;\n        idx[i] = -1;\n    }", "{\n    int n =\
    \ arr.length;\n    int lo = 1;\n    int hi = n;\n    int res = 0;\n    \n    while(lo\
    \ < hi) \n    {\n        int mid = lo + (hi - lo) / 2;\n        int midVal = std.math.remainder(arr[mid],\
    \ k);\n        if(midVal > k) \n        {\n            hi = mid;\n        } \n\
    \        else if(midVal < k) \n        {\n            lo = mid + 1;\n        }\
    \ \n        else \n        {\n            res = arr[mid];\n            break;\n\
    \        }\n    }\n    \n    int[] res = new int[res];\n    for(int i = 0; i <\
    \ res; i++)\n    {\n        res[i] = arr[lo++];\n    }\n    \n    return res;\n\
    }\n/*", "{\n    int n = arr.length;\n    long[] m = new long[k];\n    \n    long\
    \ maxVal = arr[0];\n    \n    for (int i = 1; i < n; i++) \n    {\n        if\
    \ (arr[i] > maxVal) \n        {\n            maxVal = arr[i];\n        }\n   \
    \ }\n    \n    for (int i = 1; i < k; i++) \n    {\n        m[i] = arr[i];\n \
    \   }\n    \n    m[k] = maxVal;\n    return m;\n}", "{\n    long[] result = new\
    \ long[k];\n    int i = 0, j = 0;\n    for (; i < k; i++) \n    {\n        if\
    \ (j < arr.length && arr[j] >= arr[i])\n            result[i] = arr[j++];\n  \
    \      else\n            result[i] = arr[i];\n    }\n    for (; i < k; i++)\n\
    \        result[i] = arr[k];\n    return result;\n}", "{\n    long n = arr.length;\n\
    \    if (n < k) \n    {\n        return arr;\n    }\n    long[] res = new long[k];\n\
    \    for (int i = 0; i < k; ++i) \n    {\n        long m = arr[i];\n        int\
    \ j = 0;\n        while (j < n) \n        {\n            if (m > arr[j]) \n  \
    \          {\n                res[i] = m;\n                break;\n          \
    \  }\n            if (j == n-1) \n            {\n                res[i] = m;\n\
    \                break;\n            }\n            j++;\n        }\n    }\n \
    \   return res;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n//java code\n\
    import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;",
  "{\n    if (k == 0) \n    {\n        long[] res = new long[k];\n        Arrays.fill(res,\
    \ -1L);\n        return res;\n    }\n    \n    long[] res = new long[k];\n   \
    \ \n    int i = 0;\n    int j = 0;\n    int max = 0;\n    \n    while (i < k)\
    \ \n    {\n        while (j < k && arr[i] > arr[j]) \n        {\n            j++;\n\
    \        }\n        \n        if (j == k) \n        {\n            res[i] = arr[i];\n\
    \            i++;\n        }\n        else if (arr[i] > arr[j]) \n        {\n\
    \            res[i] = arr[j];\n            j++;\n        }\n        else if (arr[i]\
    \ < arr[j]) \n        {\n            res[i] = arr[i];\n            i++;\n    \
    \        j++;\n        }\n    }\n    \n    while (i < k) \n    {\n        res[i]\
    \ = arr[i];\n        i++;\n    }\n    \n    return res;\n}\n</code>\n<|/ a dscore=0\
    \ tags=arrays,algorithm,sorting,java,c++ |>\n<| a |>\nI did a similar solution\
    \ using C#, but should be easy to convert to Java.\n<code>\npublic List<int> GetMaximums(int[]\
    \ values, int numberOfMaximums)\n{\n    List<int> result = new List<int>();\n\
    \    int currentMax = values.Max();\n    for (int i = 0; i < numberOfMaximums;\
    \ i++)\n    {\n        if (values.TakeWhile(x => x > currentMax).Count() > 0)\n\
    \        {\n            currentMax = values.TakeWhile(x => x > currentMax).Max();\n\
    \            result.Add(currentMax);\n        }\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=arrays,algorithm,sorting,java,c++ dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\npublic static void main(String[] args)\n{\n    Scanner sc = new\
    \ Scanner(System.in);\n    System.out.println(\"Enter the number of elements to\
    \ be sorted\");\n    int n = sc.nextInt();\n    int[] arr = new int[n];\n    System.out.println(\"\
    Enter the elements\");\n    for (int i = 0; i < n; i++)\n    {\n        arr[i]\
    \ = sc.nextInt();\n    }\n    int k = 1;\n    while(arr[k-1] > arr[k])\n    {\n\
    \        k++;\n    }\n    System.out.println(Arrays.toString(arr));\n    System.out.println(k);\n\
    \    System.out.println(maximumWithoutRepetition(arr,k));\n}\npublic static int[]\
    \ maximumWithoutRepetition(int[] arr, int k)\n{\n    int[] temp = new int[k];\n\
    \    for(int i=0;i<k;i++)\n    {\n        if(arr[i] > arr[i+1])\n        {", "{\n\
    \    if(k > arr.length) return new long[]{};\n    \n    var arr = sort(arr);\n\
    \    var result = new long[k];\n    int index = 0;\n    \n    for(int i = 0; i\
    \ < arr.length; i++){\n        while(index < k){\n            if(arr[i] < result[index]){\n\
    \                result[index] = arr[i];\n            }\n            index++;\n\
    \        }\n    }\n    return result;\n}", "{\n    if (k > arr.Length)\n    {\n\
    \        throw new ArgumentOutOfRangeException(\"k\", \"k cannot be greater than\
    \ or equal to the length of the array.\");\n    }\n    \n    var resultArray =\
    \ new long[k];\n    int index = 0;\n    for (int i = 0; i < arr.Length; i++)\n\
    \    {\n        for (int j = index; j < k; j++)\n        {\n            if (arr[i]\
    \ > resultArray[j])\n            {\n                resultArray[index] = arr[i];\n\
    \                break;\n            }\n        }\n        index++;\n    }\n \
    \   return resultArray;\n}", "{\n    if (k == 0) \n    {\n        return arr;\n\
    \    }", "{\n  long[] result = new long[(int) k];", "{\n    long n = arr.Length;\n\
    \    var arr = new long[k];\n    long max = arr[0];\n    for (int i = 0; i < n;\
    \ i++)\n    {\n        arr[i] = arr[i] > max ? arr[i] : max;\n    }\n    return\
    \ arr;\n}\n</code>\n<|/ a tags=algorithm,arrays,c#,.net |>\n<| c |>\nThis does\
    \ not provide an answer to the question. To critique or request clarification\
    \ from an author, leave a comment below their post. - [From Review](/review/low-quality-posts/12556027)\n\
    <|/ c |>\n<| c |>\nOkay, I removed the comment.\n<|/ c |>\n<| c |>\nHmmm okay,\
    \ it appears your code is using .Net 1.1 since you don't have a `SortedArray`\
    \ class in the .Net 1.1 namespace.\n<|/ c |>\n<| c |>\nYes, I believe you are\
    \ correct. I am updating the code to be for .Net 2.0.\n<|/ c |>\n<| c |>\nThanks\
    \ a lot for your answer! I've tried your implementation and it seems to be working\
    \ except for the fact that your implementation doesn't sort the list correctly\
    \ (from what I can tell). I've uploaded the test result to pastebin, feel free\
    \ to take a look: http://pastebin.com/2Rx8UtTs\n<|/ c |>\n<| a dscore=2 tags=algorithm,arrays,c#,.net\
    \ |>\nTry this one\n<code>", "{\n    int i, j;\n    long[] a = new long[k];",
  "{\n    long[] ans;\n    long[] aux;", "{\n    int i = 0;\n    int n = arr.length;\n\
    \    long[] arr2 = new long[n];", "{\n    long[] res;\n    int start = 0;\n  \
    \  int end = arr.length - 1;\n    \n    while (start <= end) {\n        int mid\
    \ = (start + end) / 2;\n        if (arr[mid] < k) end = mid - 1;\n        else\
    \ start = mid + 1;\n    }\n    res = arr.clone();\n    res[start] = arr[start];\n\
    \    res[end] = arr[end];\n    return res;\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 tags=sorting,java,arrays |>\n<code>\n    public class Main{\n   \
    \     public static void main(String args[]){\n            int[] arr = {-4,-5,1,2,3};\n\
    \            int k = 3;\n            arr1 = maximumSortedArray(arr, k);\n    \
    \        System.out.println(Arrays.toString(arr1));\n        }\n        public\
    \ static int[] maximumSortedArray(int[] arr, int k) {\n            int[] maximum\
    \ = new int[k];\n            int index = 0;\n            for (int i=0; i<arr.length;\
    \ i++){\n                if (arr[i] > maximum[index]){\n                    maximum[index]\
    \ = arr[i];\n                    index++;\n                }\n            }\n\
    \            return maximum;\n        }\n    }\n</code>\n<|/ a |>\n<| a tags=sorting,java,arrays\
    \ |>\n<code>\npublic class ArraySort {", "{\n    int n = arr.length;\n    long[]\
    \ max = new long[k];\n    long max = -10000L;", "{\n  int n = arr.length;\n  long[]\
    \ res = new long[k];\n  if(k > n || k < 0) {\n    throw new java.lang.RuntimeException(\"\
    Error in the input\");\n  }\n  \n  for(int i = 0; i < n; i++) {\n    if(arr[i]\
    \ > res[k-1]) {\n      res[k] = arr[i];\n      k++;\n    }\n  }\n  \n  return\
    \ res;\n}", "{\n    long[] answer = new long[k];\n    int i = 0;\n    int j =\
    \ 0;\n    while (i < k)\n    {\n        if (arr[i] > arr[j])\n        {\n    \
    \        answer[i] = arr[i];\n            i++;\n        }\n        else\n    \
    \    {\n            answer[i] = arr[j];\n            j++;\n        }\n    }\n\
    \    while (j < k)\n    {\n        answer[j] = arr[j];\n        j++;\n    }\n\
    \    return answer;\n}\n</code>\n<|/ a tags=java,algorithm |>\n<| c |>\nWhat if\
    \ `k == arr.length`?\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic static int[]\
    \ getMaxK(int[] arr, int k){\n        Arrays.sort(arr);\n        int result[]\
    \ = new int[k];\n        for(int i=0;i<k;i++){\n            result[i]=arr[i];\n\
    \        }\n        for(int i=arr.length-1;i>k;i--){\n            result[k]=arr[i];\n\
    \        }\n        return result;\n    }\n</code>\n<|/ a tags=java,algorithm\
    \ |>\n<| a dscore=0 tags=java,algorithm |>\n<code>\npublic class MaxK{\npublic\
    \ static void main(String[] args){\n        MaxK obj = new MaxK();\n        obj.input();\n\
    \        obj.output();\n        obj.print();\n    }\n    \n    \n    void input(){\n\
    \        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter\
    \ the Array elements\");\n        int arr[] = new int[sc.nextInt()];\n       \
    \ for(int i=0;i<arr.length;i++){\n            arr[i]=sc.nextInt();\n        }\n\
    \        \n        System.out.println(\"Enter the K\");\n        int k = sc.nextInt();\n\
    \        \n        for(int i=0;i<arr.length;i++){\n            if(k==1){\n   \
    \             System.out.print(arr[i]+\" \");\n                break;\n      \
    \      }\n            else if(arr[i]>arr[k-1]){\n                arr[k-1] = arr[i];\n\
    \                k--;\n            }\n            else if(arr[i]<arr[k-1]){\n\
    \                arr[k-1] = arr[i];\n            }\n        }\n    }\n    \n \
    \   void output(){\n        for(int i=0;i<arr.length;i++){\n            System.out.print(arr[i]+\"\
    \ \");\n        }\n    }\n    \n    void print(){\n        for(int i=0;i<arr.length;i++){\n\
    \            System.out.print(arr[i]+\" \");\n        }\n    }\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nHow is this different from existing answer?\n<|/ c |>\n<| a |>\n\
    Java code:\n<code>\nimport java.util.Arrays;", "{\n    if(k > 0 && k <= arr.length)\
    \ return std.max(arr, k , arr.length);\n    throw new IndexOutOfRangeException(\"\
    k is out of range [0, \" + arr.length + \")\");\n}\n\"\"\"\n</cell>\n<text>\n\
    4.5. Sort Function", "{\n    long[] result = new long[k];\n    Arrays.sort(arr);\n\
    \    int index = 0;\n    for (long i : arr)\n    {\n        if (index >= k)\n\
    \            break;\n        result[index++] = i;\n    }\n    return result;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is a great answer, but please add some explanation\
    \ to it.\n<|/ c |>\n<| c |>\nSure, please let me know if there is anything I should\
    \ explain in more details. Thanks\n<|/ c |>\n<| c |>\nI like this one, but you\
    \ might want to make it a bit more readable, by adding comments, maybe even add\
    \ some formatting so the output looks nice in a terminal or an editor. :)\n<|/\
    \ c |>\n<| c |>\nThank you so much for answering this question.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nI believe that this is a simple algorithm. No sorting required:\n\
    <code>\ndef maxElements(arr, k):\n    l = len(arr)\n    ans = [0] * k\n    for\
    \ i in range(l):\n        ans[arr[i] - 1] += 1\n    return ans\n</code>\n<|/ a\
    \ tags=sorting,algorithm,python |>\n<| c |>\nI really doubt that works. What if\
    \ `k` is 5? The output will be `[0, 1, 1, 1, 1, 0]` which is not correct.\n<|/\
    \ c |>\n<| c |>\nI agree with you. My code was just an idea, a proof that it works.\
    \ I was sure that it will work. I'll do better now. Thanks for the comment.\n\
    <|/ c |>\n<| a dscore=0 tags=sorting,algorithm,python |>\n<code>\ndef max_k(nums,\
    \ k):\n    if k >= len(nums) or k < 0:\n        return nums\n    max_list = []\n\
    \    for i in range(k):\n        max_list.append(nums[len(nums)-k+i-1])\n    return\
    \ max_list", "{\n    int len = arr.length;\n    if (len < 2) return arr;\n   \
    \ if (k > len) return arr;\n    long[] res = new long[k];\n    Arrays.sort(arr,\
    \ new Comparator<Long>() \n    { \n        public int compare(Long o1, Long o2)\
    \ \n        { \n            return Long.compare(o1, o2); \n        } \n    });\n\
    \    return res;\n}\n</code>\n<|/ a |>\n<| c |>\nYour `Arrays.sort` call is wrong\
    \ in some cases. As the javadoc states, it will sort first by value, then by comparing\
    \ two elements. That means that when k is 2, the sort will result in [4,-1,4]\
    \ (instead of [4,4] or [-4,-1]), because -1 is less than 4.\n<|/ c |>\n<| a dscore=0\
    \ |>\nIf you only need to sort for two values (e.g. the maximum and minimum),\
    \ then a heap is the way to go. The following code snippet demonstrates how to\
    \ do it with a Comparator object which compares two integer values (maximum and\
    \ minimum) based on the comparator of their values.\n<code>\nimport java.util.Comparator;\n\
    import java.util.PriorityQueue;\nimport java.util.Queue;", "{\n    int n = arr.Length;\n\
    \    long[] result = new long[k];\n    Array.Sort(arr);\n    long maxVal = arr[0];\n\
    \    long maxPos = 0;\n    for (int i = 1; i < n; i++)\n    {\n        if (arr[i]\
    \ > maxVal)\n        {\n            maxVal = arr[i];\n            maxPos = i;\n\
    \        }\n    }\n    int pos = k - 1;\n    if (maxPos == k - 1)\n    {\n   \
    \     result[0] = maxVal;\n        result[1] = arr[maxPos];\n        return result;\n\
    \    }\n    \n    long[] ret = new long[2];\n    ret[0] = maxVal;\n    ret[1]\
    \ = arr[maxPos];\n    \n    for (int i = k - 1; i > 1; i--)\n    {\n        pos\
    \ = i - 1;\n        maxVal = arr[i];\n        maxPos = i;\n        for (int j\
    \ = i - 2; j > 0; j--)\n        {\n            if (arr[j] > maxVal)\n        \
    \    {\n                maxVal = arr[j];\n                maxPos = j;\n      \
    \      }\n        }\n        result[pos] = maxVal;\n        result[pos + 1] =\
    \ arr[maxPos];\n    }\n    return result;\n}", "{\n    long[] res = new long[k];\n\
    \    int idx = 0;\n    \n    while (idx < k)\n    {\n        if (arr[idx] > 0)\n\
    \            res[idx++] = arr[idx];\n    }\n    \n    return res;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nA bit of explanation would go a long way\n<|/ c |>\n<| c |>\n\
    It was a solution that I implemented, I hope that it was clear.\n<|/ c |>\n<|\
    \ a tags=arrays,c#,algorithm |>\nHere's a quick-and-dirty implementation that\
    \ doesn't rely on LINQ:\n<code>\npublic static void Main(String[] args)\n{\n \
    \   int[] arr = { -300, -400, -500, -600, -700, -800, -900, -1000 };\n    int\
    \ k = 3; // 3 is the maximum value to be included in result\n    int[] result\
    \ = GetMax(arr, k);\n    Console.WriteLine(string.Join(\",\", result));\n}", "{\n\
    \    // write your code here\n    long[] max = new long[k];\n    Arrays.sort(arr);\n\
    \    for(int i = 0; i < k; ++i)\n    {\n        max[i] = arr[i];\n    }\n    return\
    \ max;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhat are you returning in `max`?\
    \ Looks like a long[] but you are only returning a single value.\n<|/ c |>\n<|\
    \ c |>\nSorry, I had a mistake, I have fixed it. Thanks!\n<|/ c |>\n<| c |>\n\
    I have fixed the code now. The `maximum` function is now correct.\n<|/ c |>\n\
    <| a |>\nAs mentioned by others one way to do this is to use the Stream API in\
    \ Java 8:\n<code>\npublic static <T> Stream<T> max(int[] a, int k) {\n    return\
    \ IntStream.rangeClosed(0, a.length)\n            .mapToObj(i -> Stream.of(a[i\
    \ - k]))\n            .flatMap(Stream::concat)\n            .max(Comparator.comparingInt(Arrays::compareTo))\n\
    \            .map(Arrays::asList);\n}\n</code>\nTest:\n<code>", "{\n\tif (k >\
    \ arr.length)\n\t{\n\t\tk = arr.length;\n\t}\n\tlong[] result = new long[k];\n\
    \tfor (int i = 0; i < k; i++) \n\t{\n\t\tresult[i] = arr[i];\n\t}", "{\n    if\
    \ (arr == null || arr.length == 0)\n        return null;\n    int n = arr.length;\n\
    \    long[] max_arr = new long[n];\n    for (int i = 0; i < n; i++) \n    {\n\
    \        max_arr[i] = Long.MAX_VALUE;\n    }\n    for (int i = 0; i < n; i++)\
    \ \n    {\n        if (arr[i] > max_arr[i])\n            max_arr[i] = arr[i];\n\
    \    }\n    int pos = -1;\n    for (int i = 0; i < n; i++) \n    {\n        if\
    \ (max_arr[i] != arr[i]) \n        {\n            pos = i;\n            break;\n\
    \        }\n    }\n    if (k != pos) \n    {\n        max_arr = max_arr.subarray(0,\
    \ pos + 1);\n    }\n    return max_arr;\n}", "{\n    Arrays.sort(arr);\n    long[]\
    \ res = new long[k];\n    for (int i = 0; i < k; i++)\n    {\n        res[i] =\
    \ arr[i];\n    }\n    return res;\n}", "{\n    long[] ret = new long[k];\n   \
    \ sort(arr, 0, arr.length-1);\n    for(int i = 0; i<k; i++)\n    {\n        ret[i]\
    \ = arr[i];\n    }\n    return ret;\n}", "{\n  int low = 0;\n  int high = arr.length\
    \ - 1;", "{\n    int left = 0;\n    int right = arr.length - 1;\n    int maxIdx;\n\
    \    long[] result = new long[k];", "{\n\tif (k >= arr.length)\n\t\treturn arr;\n\
    \treturn select(arr, k, arr.length);\n}", "{\n    int n = arr.Length;\n    long[]\
    \ result = new long[n];", "{\n    long[] result = new long[k];\n    long[] arr\
    \ = new long[k];\n    std.array.length(arr,0);\n    std.array.length(result,0);\n\
    \    int min = 0;\n    int max = k;\n    for (int i = 0; i < k; i++)\n    {\n\
    \        arr[i] = arr[i];\n    }\n    int j = 0;\n    while (j < k)\n    {\n \
    \       if(arr[j] < arr[0])\n        {\n            result[j] = arr[0];\n    \
    \        min = 0;\n        }\n        else\n        {\n            result[j] =\
    \ arr[min];\n            min++;\n        }\n        j++;\n    }\n    result[k]\
    \ = arr[min];\n    arr[k] = 0;\n    return result;\n}", "{\n    int[] counter\
    \ = new int[k+1];\n    for(int i = 0; i < arr.length; i++) \n    {\n        if(counter[arr[i]]\
    \ > 0) \n        {\n            counter[arr[i]]--;\n            if(counter[arr[i]]\
    \ == 0) \n            {\n                counter[arr[i]]++;\n                break;\n\
    \            }\n        }\n        counter[arr[i]]++;\n    }\n    long[] result\
    \ = new long[k+1];\n    for(int i = 0; i < k; i++) \n    {\n        result[i]\
    \ = arr[i];\n    }\n    for(int i = k; i < counter.length; i++) \n    {\n    \
    \    result[i] = counter[i];\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nPlease explain how this code works so that OP can learn from it.\n\
    <|/ c |>\n<| a |>\n<code>\npublic static void main(String[] args) {", "{\n   \
    \ if (k > arr.length)\n        return null;\n    else if (k < 1)\n        return\
    \ arr;\n    long[] res = new long[k];\n    for (int i = 0; i < k; ++i)\n    {\n\
    \        long j = std.math.min(i + arr.length - 1, arr.length - 1);\n        res[i]\
    \ = arr[j];\n    }\n    return res;\n}", "{\n    int[] nums = new int[k];\n  \
    \  for(int i = 0; i < k; i++) {\n        for(int j = 0; j < arr.length; j++) {\n\
    \            if(arr[j] > nums[i]) {\n                nums[i] = arr[j];\n     \
    \       }\n        }\n    }\n    long max = Long.MIN_VALUE;\n    for(int i = 0;\
    \ i < k; i++) {\n        if(max < nums[i]) {\n            max = nums[i];\n   \
    \     }\n    }\n    long[] result = new long[k];\n    for(int i = 0; i < k; i++)\
    \ {\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] res\
    \ = new long[arr.Length];\n    long max = 0;\n    for(int i = 0; i < arr.Length;\
    \ i++)\n    {\n        if(arr[i] > max)\n        {\n            max = arr[i];\n\
    \        }\n    }\n    int len = arr.Length - 1;\n    for(int i = 0; i < k - 1\
    \ && len > 0; i++)\n    {\n        for(int j = i; j < len; j++)\n        {\n \
    \           if(arr[j] > max)\n            {\n                max = arr[j];\n \
    \           }\n        }\n        res[len - i] = max;\n    }\n    return res;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\n`return arr.Where(x => x > max).Take(k);`\n\
    <|/ c |>\n<| a tags=sorting,algorithm,c#,arrays |>\nA simple and elegant solution\
    \ is:\n<code>", "{\n    Arrays.sort(arr);\n    long[] ret = new long[k];\n   \
    \ long max = 0;\n    for (int i = 0; i < k; i++)\n    {\n        if (arr[i] >\
    \ max)\n            max = arr[i];\n        ret[i] = max;\n    }\n    return ret;\n\
    }\n/*", "{\n    long[] res = new long[k];\n    std.sort(arr);\n    \n    for (int\
    \ i = 0; i < k; i++) {\n        res[i] = arr[i];\n    }\n    return res;\n}",
  "{\n    long[] result = new long[k];\n    Arrays.sort(arr);\n    for(int i = 0;\
    \ i < k; i++) {\n        result[i] = arr[i];\n    }\n    return result;\n}", "{\n\
    \    int[] heap = new int[k];\n    for (int i = 0; i < k; i++)\n    {\n      \
    \  heap[i] = Integer.MIN_VALUE;\n    }\n    for (int i = 0; i < arr.length; i++)\n\
    \    {\n        heap[0] = arr[i];\n        for (int j = 1; j < k; j++)\n     \
    \   {\n            if (heap[0] < heap[j])\n            {\n                heap[0]\
    \ = heap[j];\n            }\n        }\n        arr[i] = heap[0];\n    }\n   \
    \ long[] ret = new long[k];\n    for (int i = 0; i < k; i++)\n    {\n        ret[i]\
    \ = arr[i];\n    }\n    return ret;\n}\n</code>\n<|/ a tags=arrays,max,c++ dscore=0\
    \ |>\n<| c |>\nThank you, but how is the time complexity of this algorithm O(nlgn)?\
    \ The array is already sorted.\n<|/ c |>\n<| c |>\nThis algorithm is *not* O(nlgn).\
    \ Its O(n) time and O(n) space, and it only requires one pass through the array.\n\
    <|/ c |>\n<| c |>\nThanks for the clarification and the example!\n<|/ c |>\n<|\
    \ c |>\n: Yes, I saw the answer, but I was hoping for an explanation why this\
    \ is the case.  I understand how it works and it works, it's just I'm wondering\
    \ why it works this way.  I'm very confused and I wonder if this isn't just for\
    \ me and everyone else.\n<|/ c |>\n<| c |>\n: The first element of the heap is\
    \ `arr[0]`. The rest are `arr[1]` to `arr[k-1]`. When we find the new max element,\
    \ we swap it with the smallest element in the heap. Now the heap consists of the\
    \ largest element from the heap with the new max element. Repeat until the heap\
    \ consists only of the new max element. At this point, the heap has size k and\
    \ `arr[0]` is the largest of the array.\n<|/ c |>\n<| a |>\n<code>\nfunction max(int\
    \ arr[], int k){\n    int i = k;\n    int max = arr[0];\n    for(int j = 1; j\
    \ < k; j++){\n        if(arr[j] > max){\n            max = arr[j];\n        }\n\
    \    }\n    while(i > 0 && arr[i-1] <= max){\n        arr[--i] = arr[i - 1];\n\
    \    }\n    arr[i] = max;\n    return arr;\n}", "{\n    int[] result = new int[k];\n\
    \    Arrays.sort(arr);", "{\n    if (k > arr.length) return Arrays.copyOf(arr,\
    \ k);\n    Arrays.sort(arr);\n    return arr;\n}\n</code>\n<|/ a |>\n<| a tags=arrays,sorting,java,algorithm\
    \ |>\nSort the array in descending order and return the top k elements.\n<code>\n\
    class Solution {\n    public int topK(int[] arr, int k) {\n        Arrays.sort(arr);\n\
    \        return Arrays.copyOfRange(arr, arr.length - k, arr.length);\n    }\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe original question says the length\
    \ of array is more than 1000.\n<|/ c |>\n<| c |>\nYeah but it is better to return\
    \ the first k elements rather than sorting them.\n<|/ c |>\n<| c |>\nYes, I agree\
    \ with you. The question is a bit ambiguous.\n<|/ c |>\n<| c |>\nThis solution\
    \ is O(NlogN), while OP asks for O(N).\n<|/ c |>\n<| c |>\nYes I agree with you\
    \ but my solution is O(N).\n<|/ c |>\n<| a tags=arrays,sorting,java,algorithm\
    \ |>\nFor this question you can use merge sort or quicksort, both O(nlogn)\nbut\
    \ for that you need to find the max value of array and assign the value to next\
    \ index\n<code>", "{\n    int start = 0;\n    int end = k - 1;\n    int mid =\
    \ 0;\n    long[] arr1 = new long[k];\n    \n    while(end > start)\n    {\n  \
    \      mid = (start + end) / 2;\n        \n        if(arr[mid] >= arr[mid+1])\n\
    \        {\n            end = mid - 1;\n        }\n        else\n        {\n \
    \           start = mid + 1;\n        }\n    }\n    \n    for(int i = 0; i < k;\
    \ i++)\n    {\n        arr1[i] = arr[end];\n        end--;\n    }\n    \n    return\
    \ arr1;\n}\n</code>\n<|/ a |>\n<| c |>\nThis fails for k == 0 case where it returns\
    \ an empty array.\n<|/ c |>\n<| a tags=python,c++ dscore=1 |>\nI think this would\
    \ work, but I'm not entirely sure:\n<code>\ndef maximum(arr, k):\n    if k > len(arr):\n\
    \        return arr\n    bigger = arr[k - 1]\n    for i in xrange(k - 1):\n  \
    \      if arr[i] > bigger:\n            bigger = arr[i]\n    smaller = arr[0]\n\
    \    for i in xrange(k):\n        if arr[i] > smaller and arr[i] > bigger:\n \
    \           smaller = arr[i]\n    if bigger > smaller:\n        return arr[0:k\
    \ - 1]\n    else:\n        return [smaller] + maximum(arr[k - 1:], k)\n</code>\n\
    It works by splitting the array in half, comparing each element to the largest\
    \ so far, and adding the smaller element as the new bigger one if it would fit\
    \ in the new larger one.\n<|/ a |>\n<| a tags=python,c++ |>\n<code>\ndef maximumSorted(numbers):\n\
    \    sortedList = numbers.sort()\n    maximum = sortedList[len(numbers)-1]\n \
    \   minimum = sortedList[0]\n    maxIndex = 0\n    min = 99999\n    for index\
    \ in range(len(numbers)):\n        if numbers[index] > maximum:\n            maximum\
    \ = numbers[index]\n            maxIndex = index\n        elif numbers[index]\
    \ < minimum:\n            minimum = numbers[index]\n        elif numbers[index]\
    \ > minimum and numbers[index] > maximum:\n            min = numbers[index]\n\
    \    return sortedList[maxIndex:] + sortedList[0:maxIndex+1] + sortedList[maxIndex:][::-1]\
    \ + min\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\ndef maximumSorted(numbers):\n\
    \    sortedList = numbers.sort()\n    maximum = sortedList[len(numbers)-1]\n \
    \   minimum = sortedList[0]\n    maxIndex = 0\n    min = 99999\n    for index\
    \ in range(len(numbers)):\n        if numbers[index] > maximum:\n            maximum\
    \ = numbers[index]\n            maxIndex = index", "{\n    if (k > arr.length)\n\
    \        k = arr.length;\n    long[] result = new long[k];\n    long maximum =\
    \ arr[0];\n    int i = 0;\n    for (int n = 0; n < k; n++)\n    {\n        if\
    \ (n > arr.length - 1)\n            break;\n        long curr = arr[n];\n    \
    \    for (int j = i; j < arr.length; j++)\n        {\n            if (j == i)\n\
    \            {\n                result[n] = maximum;\n                maximum\
    \ = curr;\n            }\n            if (arr[j] > curr)\n            {\n    \
    \            maximum = arr[j];\n                result[n] = maximum;\n       \
    \     }\n        }\n        i = j + 1;\n    }\n    return result;\n}", "{\n  long[]\
    \ result = new long[k];\n  int idx = 0;\n  int maxCount = 0;\n  for (int i = 0;\
    \ i < k; i++) {\n    if (arr[i] > maxCount) {\n      maxCount = arr[i];\n    \
    \  idx = 0;\n    }\n    else if (arr[i] == maxCount) {\n      idx++;\n    }\n\
    \    else {\n      result[i] = arr[i];\n    }\n  }\n  result[idx] = maxCount;\n\
    \  return result;\n}", "{\n    long[] result = new long[k];\n    long maximum\
    \ = -10000000000;", "{\n    if (k > arr.length) \n        throw new IllegalArgumentException();",
  "{\n    if (k == 0) \n    {\n        return new long[0];\n    }\n    if (k == 1)\
    \ \n    {\n        return arr;\n    }\n    \n    long[] largest = new long[k];\n\
    \    for (int i = 0; i < k; i++) \n    {\n        largest[i] = arr[i];\n    }",
  "{\n    /*\n        Initialize result to the empty array arr\n        Initialize\
    \ k to 0\n        Initialize a variable to store the index\n    */\n    long[]\
    \ result = new long[k];\n    int index = 0;\n    /*\n        Loop through the\
    \ array arr\n        For each element element in the array, increment index\n\
    \    */\n    for (long element : arr)\n    {\n        ++index;\n        /*\n \
    \           If the index's position is greater than or equal to k, then\n    \
    \        append the element to the result array\n        */\n        if (index\
    \ >= k)\n        {\n            /*\n                If the element is not the\
    \ largest element in result\n                append the element to the result\
    \ array\n            */\n            if (element > result[index])\n          \
    \      result[index] = element;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=algorithm,java,arrays dscore=0 |>\nThe other answers\
    \ are good for the original question as it was stated. For other situations, the\
    \ following code also works. I decided to post it here as I was searching for\
    \ an answer on how to sort an array.\n<code>\n public static void printArray(char[]\
    \ array) {\n    System.out.print(\"[\");\n    for (int i = 0; i < array.length;\
    \ i++) {\n        System.out.print(array[i] + \",\");\n    }\n    System.out.print(\"\
    ]\");\n}\npublic static void swap(char[] array, int first, int second) {\n   \
    \ char temp = array[first];\n    array[first] = array[second];\n    array[second]\
    \ = temp;\n}\npublic static void sort(char[] array) {\n    int first = 0;\n  \
    \  int last = array.length - 1;\n    while (first < last) {\n        while (array[first]\
    \ < array[last + 1])\n            swap(array, first++, ++last);\n        while\
    \ (array[first] == array[last + 1])\n            swap(array, first++, ++last);\n\
    \    }\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n    public static void\
    \ main(String[] args) {\n    int[] ar = {4,-5,7,8,2,1,-6,7,-8,0};\n    int n =\
    \ ar.length;\n    int k = 2;\n    int temp = 0;\n    for(int i = 0; i < n; i++)\
    \ {\n        if(temp > ar[i])\n            temp = ar[i];\n    }\n    int newArray[]\
    \ = new int[k];\n    int a = 0;\n    int j = 0;\n    for(int i = 0; i < n; i++)\
    \ {\n        if(temp > ar[i]) {\n            newArray[a] = ar[i];\n          \
    \  a++;\n        }\n    }\n    for(j = 0; j < k; j++) {\n        System.out.println(newArray[j]);\n\
    \    }\n}\n</code>\n<|/ a tags=algorithm,java,arrays |>\n<| c |>\nWelcome to ",
  "{\n  long maxN = -1;\n  long max = 0;\n  for(int i = 0; i < k; i++) \n  {\n   \
    \ max = Math.max(max, arr[i]);\n  }\n  \n  for(int i = 0; i < k; i++)\n  {\n \
    \   if(arr[i] > max)\n    {\n      arr[i] = max;\n      maxN = i;\n    }\n  }\n\
    \  \n  return arr;\n}\n</code>\n<|/ a dscore=0 tags=arrays,algorithm,time-complexity,c#\
    \ |>\n<| a tags=arrays,algorithm,time-complexity,c# |>\nSolution in Java:\n<code>\n\
    import java.util.Arrays;", "{\n    long[] result = new long[arr.length];\n   \
    \ long n = arr.length;\n    long minEle = arr[0];\n    long maxEle = arr[0];",
  "{\n    long[] result = new long[arr.length];\n    int max = 0;\n    long max =\
    \ arr[0];\n    for(int i = 0; i < arr.length; i++)\n    {\n        if(arr[i] >\
    \ max)\n        {\n            max = arr[i];\n        }\n    }\n    for(int i\
    \ = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max)\n        {\n    \
    \        max = arr[i];\n        }\n    }\n    while(max > 0)\n    {\n        result[max\
    \ - 1] = arr[max - 1];\n        max--;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=arrays,sorting,java |>\n<| c |>\nThis solution is O(n^2) which is quite\
    \ inefficient.\n<|/ c |>\n<| c |>\nSorry, I just want to give the OP an idea about\
    \ how to solve the problem and nothing more, that's why I didn't give the code\
    \ here. Thanks for the feedback.\n<|/ c |>\n<| c |>\nThe most efficient solution\
    \ is O(n log n).\n<|/ c |>\n<| c |>\n: You are right but this solution is O(n)\
    \ so it is better than the O(n^2) solution (I didn't test it though).\n<|/ c |>\n\
    <| a tags=arrays,sorting,java |>\nAn O(n) solution that takes advantage of the\
    \ fact that an ArrayList has an \"addAll\" method. \nThis solution keeps a running\
    \ tally of the biggest numbers in your array, and then just returns the tally\
    \ array when it is full.\n<code>\npublic class MaxOfArray\n{\n    private final\
    \ int theArray[];\n    private final ArrayList theListOfLargest = new ArrayList();\n\
    \    private int largestNum;", "{\n    int n = arr.length;\n    long[] maxArray\
    \ = new long[k];\n    long max = arr[0];\n    for (int i = 0; i < n; i++)\n  \
    \  {\n        if (arr[i] > max)\n        {\n            max = arr[i];\n      \
    \  }\n    }\n    for (int i = 0; i <= k; i++)\n    {\n        maxArray[i] = max;\n\
    \    }\n    return maxArray;\n}\n</code>\n<|/ a tags=arrays,data-structures,sorting,java,algorithm\
    \ dscore=2 |>\n<| c |>\nThis is an O(n\xB2) solution. Can you explain why this\
    \ should be faster than O(n)? And how it could be O(n log n)?\n<|/ c |>\n<| c\
    \ |>\n- Please see my answer for a O(nlogn) solution which achieves the same result\
    \ in O(n).\n<|/ c |>\n<| c |>\n\"the max element of every subarray should be less\
    \ than or equal to the max element of the subarray\", I don't see that in your\
    \ solution. Also, your solution doesn't return the _maximum_ of the subarray,\
    \ it returns only the _maximum_ of the first k subarrays. Finally, you're using\
    \ arrays, not lists, so your solution is still O(n\xB2).\n<|/ c |>\n<| c |>\n\
    - Yeah, I didn't realize it was O(n\xB2) until I looked at it carefully.  I updated\
    \ my answer to use lists instead.\n<|/ c |>\n<| c |>\n- I see what you mean now.\
    \  I fixed my answer.\n<|/ c |>\n<| a tags=arrays,data-structures,sorting,java,algorithm\
    \ |>\nA simple O(n*log n) algorithm:", "{\n    long[] res = new long[arr.length];\n\
    \    if (k > arr.length)\n    {\n        return arr;\n    }\n    std.arraysort(arr,\
    \ 0, arr.length-1);\n    res.length = k; \n    for (int i = 0; i < k; i++)\n \
    \   {\n        res[i] = arr[i];\n    }\n    return res;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis seems like a great solution, however when I run it I get the following\
    \ errors: http://prntscr.com/9q4yxa . Also, I think it is possible to use this\
    \ solution to solve this problem: http://stackoverflow.com/questions/19078710/how-to-find-the-maximum-number-in-array-while-keeping-duplicates-in-java\n\
    <|/ c |>\n<| c |>\nI did some changes so you can try it again. Sorry for late\
    \ answer :(\n<|/ c |>\n<| c |>\nI'm getting an error at line 7: Arrays.sort(arr,\
    \ 0, i);\n<|/ c |>\n<| c |>\nIt should be `Arrays.sort(arr, 0, i);`\n<|/ c |>\n\
    <| c |>\nStill getting the same error. http://prntscr.com/9q4v9c\n<|/ c |>\n<|\
    \ a dscore=1 |>\nHere is the code:\n<code>\nimport java.util.Arrays;"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
