name: HumanEval_90_next_smallest
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
  \ of integers.\n    Write a function next_smallest() that returns the 2nd smallest\
  \ element of the array.\n    Return null if there is no such element.\n    >>> next_smallest([1L,\
  \ 2L, 3L, 4L, 5L])\n    2L\n    >>> next_smallest([5L, 1L, 4L, 3L, 2L])\n    2L\n\
  \    >>> next_smallest([])\n    None\n    >>> next_smallest([1L, 1L])\n    None\n\
  \    \n*/\nNullable!(long) next_smallest(long[] lst) \n"
tests: "unittest\n{\n    alias candidate = next_smallest;\n\n{\n        auto result\
  \ = candidate([1L, 2L, 3L, 4L, 5L]);\n        assert(!result.isNull && result.get\
  \ == 2L);\n}\n\n{\n        auto result = candidate([5L, 1L, 4L, 3L, 2L]);\n    \
  \    assert(!result.isNull && result.get == 2L);\n}\n\n{\n        auto result =\
  \ candidate([]);\n        assert(result.isNull);\n}\n\n{\n        auto result =\
  \ candidate([1L, 1L]);\n        assert(result.isNull);\n}\n\n{\n        auto result\
  \ = candidate([1L, 1L, 1L, 1L, 0L]);\n        assert(!result.isNull && result.get\
  \ == 1L);\n}\n\n{\n        auto result = candidate([1L, 1L]);\n        assert(result.isNull);\n\
  }\n\n{\n        auto result = candidate([-35L, 34L, 12L, -45L]);\n        assert(!result.isNull\
  \ && result.get == -35L);\n}\n\n}\nvoid main(){}"
completions: ["{\n    var len : Py_ssize_t = lst.len();\n    var idx : Py_ssize_t\
    \ = lst.idx(1);\n    var x : long = lst.val(idx);\n    \n    // if list is empty\n\
    \    if (idx > 0) \n    {\n        // if value is not the smallest\n        if\
    \ (x == lst.val(idx-1))\n        {\n            idx += 1;\n            x = lst.val(idx);\n\
    \        }\n        else\n        {\n            // if value is the smallest\n\
    \            idx += 1;\n        }\n    }\n    // if list is empty\n    if (idx\
    \ == lst.len()) \n    {\n        return null;\n    }\n    // if value is not the\
    \ smallest\n    if (x == lst.val(idx-1))\n    {\n        idx += 1;\n        x\
    \ = lst.val(idx);\n    }\n    return x;\n}", "{\n    var smallest = lst[0];\n\
    \    var i = 1;\n    var n = 0;\n    for (i = 0; i < lst.length; ++i)\n    {\n\
    \        n = std.math._min(smallest, lst[i]);\n        smallest = n;\n    }\n\
    \    return smallest;\n}\n/*", "{\n    int  i;\n    long ret;\n    \n    for(i=1;\
    \ i<lst.length; ++i)\n    {\n        if(lst[i]<lst[(i<<1)%lst.length])\n     \
    \       return lst[i];\n    }\n    return null;\n}", "{\n    if(lst.isEmpty) \n\
    \    {\n        return null;\n    }\n    else\n    {\n        return lst[1];\n\
    \    }\n}\n</code>\n<|/ a dscore=0 tags=d,arrays |>\n<| c |>\nPlease do not edit\
    \ others' answers.\n<|/ c |>\n<| c |>\nSorry, I did not mean that you should edit\
    \ my answer. I was just trying to make it easier to understand for future visitors\
    \ who read this question.\n<|/ c |>\n<| c |>\nI understand, but you edited it.\
    \ This could have been avoided had you just provided a comment to my answer and\
    \ left a comment about your editing and I would have approved it. I was merely\
    \ trying to make things clear to future visitors. I understand that there could\
    \ be conflicts with my approach.\n<|/ c |>\n<| c |>\nI did not edit your answer,\
    \ I simply edited my comment. Yes I understand, your comment was a nice addition.\
    \ But as I said it could be avoided if someone just edited my answer and left\
    \ a comment saying they approved your edit. I would have approved it if I had\
    \ not edited your answer. Anyway, I edited my answer to show that your answer\
    \ was incorrect. Sorry for that confusion.\n<|/ c |>\n<| a dscore=0 |>\nIn D programming\
    \ language the shortest way of returning the next smallest element in the list\
    \ is to use the array operator \"op\" on that list.\n<code>\nimport std.array,\
    \ std.array, std.algorithm, std.range;", "{\n\tif (lst.length == 0)\n\t{\n\t\t\
    return null;\n\t}\n\tif (lst.length == 1)\n\t{\n\t\treturn lst[0];\n\t}\n\tlong\
    \ min_val = lst[0];\n\tlong min_idx = 1;\n\tfor (int i = 1; i < lst.length; i++)\n\
    \t{\n\t\tif (lst[i] < min_val)\n\t\t{\n\t\t\tmin_val = lst[i];\n\t\t\tmin_idx\
    \ = i;\n\t\t}\n\t}\n\treturn lst[min_idx];\n}\n/* \n  Implement a function that\
    \ returns the next greater element. The next greater element in the array is the\
    \ first element that comes after the first element in the array.\n  The function\
    \ next_greater() has the following prototype:", "{\n    if(lst.length==0)\n  \
    \      return null;\n    var result=lst[0];\n    for(var i=1;i<lst.length;i++)\n\
    \    {\n        if(lst[i]<result)\n        {\n            result=lst[i];\n   \
    \     }\n    }\n    return result;\n}", "{\n    int idx = 1; // index of 2nd smallest\
    \ element in lst\n    int idx1 = -1; // index of 1st element in lst that corresponds\
    \ to 2nd smallest element\n    \n    if (lst.length == 1) {\n        return null;\n\
    \    }\n    \n    int i;\n    int j;\n    int smallest = lst[0];\n    \n    for\
    \ (i = 1; i < lst.length; ++i) {\n        if (lst[i] < smallest) {\n         \
    \   smallest = lst[i];\n            idx1 = i;\n        }\n    }\n    \n    idx1\
    \ = idx1 - 1; // change index for next comparison\n    idx = idx1 + 1; // change\
    \ index for next iteration\n    \n    while (idx != idx1) {\n        if (lst[idx]\
    \ < smallest) {\n            smallest = lst[idx];\n            idx1 = idx;\n \
    \       }\n        idx++;\n    }\n    \n    return smallest;\n}", "{\n    if (lst.length\
    \ == 0) return null;\n    var pivot = lst[lst.length/2];\n    var left = lst.filter((e)\
    \ -> { return e < pivot; });\n    var right = lst.filter((e) -> { return e > pivot;\
    \ });\n    return right.length ? right[0] : null;\n}\n/*", "\t:\n\tlst.lenght\
    \ == 0 ? null : lst[lst.lenght - 2];\n\t\t\nfunction next_smallest([X|Xs]) where\
    \ {X:Type}\n{\n\tif null lst = null Xs = null \n\t\telse Xs.len() > 0 \n\t\t\t\
    ? Xs[Xs.lenght-2] \n\t\t\t\t? Xs[Xs.lenght-2]\n\t\t\t\t: next_smallest(Xs)\n\t\
    \t\t: X;\nend;", "{\n    int? minIndex = std.array.min(lst);\n    if (minIndex\
    \ > 0)\n    {\n        if (minIndex == 1)\n            return lst[minIndex];\n\
    \        else\n            return std.array.drop(lst[minIndex], 1);\n    }\n \
    \   return null;\n}", "{\n    int len = lst.length;\n    int minIdx = len - 1;\n\
    \    if (len <= 1) return null;\n    for (int i = 0; i < len; i++) \n    {\n \
    \       if (lst[minIdx] > lst[i]) \n        {\n            minIdx = i;\n     \
    \   }\n    }\n    return lst[minIdx];\n}\n/* \n    You are given an array that\
    \ consists of two parts\n    (possibly null) such that the first part is sorted\
    \ in ascending\n    order and the second part is sorted in descending order. \n\
    \    Write a function that returns the maximum value from the second part \n \
    \   without using sorting.\n*/\nNullable!(double) maxFromList(Nullable!(double)\
    \ lst) \n{\n    if (lst == null) return null;\n    if (lst == 0) return 0.0;\n\
    \    if (lst == 1) return 0.0;\n    return maxFromList(lst._1);\n}", "{\n    if\
    \ (lst.isEmpty) \n        return Nullable(null);\n    else \n        return (lst.head\
    \ < lst.tail.head) ? lst.tail : lst.head;\n}\n/*", "{\n\tint first = 0;\n\tint\
    \ second = 1;\n\t\n\tif (lst.length == 0)\n\t{\n\t\treturn Nullable!(long)null;\n\
    \t}\n\tif (lst.length == 1)\n\t{\n\t\treturn Nullable!(long)lst[0];\n\t}\n\twhile\
    \ ((first < lst.length) && (lst[first] < lst[second]))\n\t{\n\t\tfirst++;\n\t\
    }\n\twhile ((second < lst.length) && (lst[second] < lst[first]))\n\t{\n\t\tsecond++;\n\
    \t}\n\tif (first == lst.length)\n\t{\n\t\treturn Nullable!(long)lst[second];\n\
    \t}\n\telse\n\t{\n\t\treturn Nullable!(long)lst[first];\n\t}\n}", "  : lst ==\
    \ [] || lst == [0]\n    ? Nullable!(0)\n    : lst.head < lst.tail.head ? Nullable!(lst.head)\n\
    \    : (lst.head < lst.tail.head ? Nullable!(lst.tail.head) : next_smallest(lst.tail))\n\
    {\n    Nullable! head(lst.head);\n    Nullable! tail(lst.tail);\n    while (head\
    \ == Nullable!(0)) head = tail.head;\n    while (tail.head == Nullable!(0)) tail.head\
    \ = head.next;\n    while (head == Nullable!(0)) head = tail.head;\n    while\
    \ (tail.head == Nullable!(0)) tail.head = head.next;\n    return Nullable!(head.next);\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease note that this algorithm does not\
    \ perform any sorting. It just checks if the first element is smaller than the\
    \ next one. If yes, return the next one. Else, return the smallest one that is\
    \ larger than the current one. Also, if you have an array with two identical elements,\
    \ it should return null instead of throwing an error.\n<|/ c |>\n<| c |>\n: You're\
    \ right, it's unnecessary - thanks for the reminder. I added a variant that does\
    \ not require a loop.\n<|/ c |>\n<| c |>\n, your algorithm is still O(n^2). Try\
    \ this array: [1,5,3,7,4,2]. It will run through your while loop at least 5 times:\
    \ once in each iteration of the loop, once in each iteration of the while loop.\
    \ And each time it has to check if head is smaller or equal to tail.head. That\
    \ means that it will run at least n log n times.\n<|/ c |>\n<| c |>\n: It is a\
    \ constant-time algorithm. It only runs through the array once in the worst case.\
    \ It is not O(n^2). See http://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.pdf\
    \ for details.\n<|/ c |>\n<| a tags=arrays,algorithm |>\n<code>\n// C++ program\
    \ to print all \n// smallest element in the array \n// using recursive function\
    \ \nusing namespace std; \n \n// function to find minimum \n// element in an array ",
  "{\n    int first=std.arrayIndex(long,lst);\n    if(first>0)\n    {\n        int\
    \ second=first+1;\n        int smaller=std.min(second,std.arrayIndex(long,lst));\n\
    \        if(smaller==first)\n        {\n            second++;\n        }\n   \
    \     else\n        {\n            second=smaller;\n        }\n        if(second<std.length(lst)\
    \ && lst[second]==lst[first])\n        {\n            second++;\n        }\n \
    \       if(second<std.length(lst))\n        {\n            return lst[second];\n\
    \        }\n    }\n    return null;\n}", "{\n    var res = new long?(null);\n\
    \    var min = lst[0];\n    var minPos = 0;\n    for(int i = 1; i < lst.Length;\
    \ i++)\n    {\n        if(lst[i] < min)\n        {\n            minPos = i;\n\
    \            min = lst[i];\n        }\n    }", "{\n    var i = 0;\n    var cur\
    \ = lst[i];\n    while(cur != null)\n    {\n        i = i+1;\n        cur = lst[i];\n\
    \    }\n    return cur;\n}", "{\n    Nullable!(long) temp;\n    if (lst.Length\
    \ == 0)\n        return null;\n    else if (lst.Length == 1)\n        return lst[0];\n\
    \    else\n    {\n        temp = (lst[1] > lst[0]) ? lst[1] : lst[0];\n      \
    \  foreach (var item in lst)\n            if (item < temp)\n                temp\
    \ = item;\n        return temp;\n    }\n}", "{\n    long min = 2L;\n    int i;\n\
    \    for (i = 0; i < lst.Length; ++i) \n    {\n        if (lst[i] < min) {\n \
    \           min = lst[i];\n        }\n    }\n    return min;\n}", "{\n    var\
    \ len = lst.__size;\n    var min = lst.__min;\n    var i = 0;\n    var temp =\
    \ null;\n    var temp2 = null;\n    var res = null;\n    \n    for(i = 0; i <\
    \ len; ++ i)\n    {\n        if (min < lst[i])\n        {\n            temp =\
    \ lst[i];\n            temp2 = min;\n            min = temp2;\n            \n\
    \            if (temp == null)\n            {\n                break;\n      \
    \      }\n        }\n        else\n        {\n            if (temp != null)\n\
    \            {\n                res = temp;\n                break;\n        \
    \    }\n        }\n    }\n    \n    return res;\n}\n/*", "    requires lst.length\
    \ >= 2;\n    requires lst.allSatisfy(x => x >= 0); // must be positive\n    //\
    \ find the two smallest items and return the second one\n    var left=lst[0];\n\
    \    var right=lst[1];\n    for(var i=2; i<lst.length; ++i) {\n        var el=lst[i];\n\
    \        if(el < left) {\n            left=el;\n        }\n        else if(el\
    \ < right) {\n            right=el;\n        }\n    }\n    return right;\n   \
    \ \nend ;", "{\n    long[] tmp;\n    if(!lst.length)\n        return null;\n \
    \   tmp = lst;\n    \n    var min;\n    while(true)\n    {\n        min = tmp[0];\n\
    \        for(int i = 1; i < tmp.length; i++)\n        {\n            if(tmp[i]\
    \ < min)\n            {\n                min = tmp[i];\n            }\n      \
    \  }\n        if(min==tmp[0])\n            return null;\n        tmp.swap(0, min);\n\
    \    }\n}", "{\n    int[] a;\n    int i=0;\n    int j=lst.length;\n    long min=lst[0];\n\
    \    while(j>i){\n        int idx=std.random.nextInt(j);\n        a=new int[j];\n\
    \        for(int k=0;k<j;k++){\n            a[k]=lst[k];\n        }\n        std.copy(a,\
    \ a, j);\n        std.shuffle(a, a);\n        for(int k=0;k<j;k++){\n        \
    \    if(a[k]==min){\n                i=k+1;\n                if(i==j){\n     \
    \               return null;\n                }\n            }\n        }\n  \
    \      j--;\n    }\n    return lst[i+1];\n}\n</code>\n<|/ a tags=c#,sorting,algorithm,c\
    \ |>\n<| c |>\nIt would be really helpful to understand why the downvotes happened.\
    \ Would you mind pointing out what I might be doing wrong?\n<|/ c |>\n<| c |>\n\
    Thanks for the code. Your approach works very well. Now I want to implement the\
    \ same for finding the median element. I am not able to figure out how to do it.\
    \ Could you please help me on this?\n<|/ c |>\n<| c |>\n: I added the median part\
    \ - hope it helps.\n<|/ c |>\n<| c |>\n- Thanks, I really appreciate your efforts.\
    \ Your code helped me to write my own median function. I am now trying to figure\
    \ out how to get the median value based on a random integer which can have three\
    \ different values - low, medium and high. I am trying to implement a partition\
    \ function. But I am not able to get it work. Could you please help me on this?\
    \ Thanks.\n<|/ c |>\n<| c |>\n: I added the code for that. Not sure how good it\
    \ is though - I hope you learn a lot :)\n<|/ c |>\n<| a dscore=1 |>\nYour code\
    \ is very inefficient. Try this one:\n<code>\npublic static int? NextSmallest(int[]\
    \ lst)\n{\n    int smallest = lst[0];\n    for (int i = 0; i < lst.Length; i++)\n\
    \    {\n        if (lst[i] < smallest)\n        {\n            smallest = lst[i];\n\
    \        }\n    }\n    return smallest;\n}\n</code>\n<|/ a tags=c#,sorting,algorithm,c\
    \ |>\n<| a tags=c#,sorting,algorithm,c |>\nI believe you are looking for the following\
    \ algorithm, assuming that the array is sorted.\n<code>\ndef nextSmallest(arr):\n\
    \    smallest = arr[0]\n    for i in range(len(arr)):\n", "{\n    for(; !lst.empty;\
    \ lst.pop())\n    {\n        if(lst.front() > lst.back())\n            return\
    \ lst.front();\n    }\n    return null;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    This doesn't work if you have a list where the first element isn't the smallest.\
    \  For example, if your list is: [1,10,11,15] and you only want the second smallest\
    \ element to be 11, but the first element isn't the smallest.  So your function\
    \ will return null.\n<|/ c |>\n<| c |>\n: That's not true. `min` will return the\
    \ smallest element. `list.pop` removes the smallest element, so `min` will return\
    \ the next smallest element. Since `list.pop` removes the smallest element, `list`\
    \ will still have one element, and `min` will return the smallest of that element.\n\
    <|/ c |>\n<| c |>\nYou might be right about that, but I couldn't get min() to\
    \ work, probably because I'm using an older version of the language than you are.\
    \  I ended up doing something similar to this.\n<|/ c |>\n<| c |>\n`std.array`\
    \ has `min` which takes a comparison function to do an ascending sort, so you\
    \ could do `lst.min(compare)` where `compare` is the comparison function you define.\
    \ Of course, that assumes you know how to define an ascending order for your type.\n\
    <|/ c |>\n<| c |>\n: I guess my mistake was I thought min returned the minimum\
    \ element, but it's actually returning the next minimum element.  So I went ahead\
    \ and modified my answer to use a `for` loop and `pop` to get the minimum element,\
    \ then compare it to the next minimum element.  It's not as simple as using the\
    \ built-in `min` function, but it's still an elegant solution.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nThe answer given by Dave is really great, I modified it to give\
    \ the second smallest element in the list. The following is my modification of\
    \ the answer.\n<code>\nimport std.algorithm;\nimport std.array;\nimport std.arrayiterator;\n\
    import std.conv;\nimport std.typecons;\nimport std.math;\n/*", "{\n  if (is_empty(lst))\n\
    \    return Nullable!long.null;\n  else if (is_empty(lst))\n    return Nullable!long.null;\n\
    \  else \n  {\n    var elem = lst[1..];\n    var smallest = elem[0];\n    var\
    \ smaller = 0;\n    for (var i = 1;  i < elem.length;  ++i)\n      if (elem[i]\
    \ < smallest)\n      {\n        smallest = elem[i];\n        smaller = i;\n  \
    \    }\n    lst = elem.slice!(1, smaller);\n    return smallest;\n  }\n}", "{\n\
    \    int[] idx = std.int[lst.length];\n    int[] cnts = std.int[lst.length];\n\
    \    long[] res = null;\n    int i = 0;\n    for(i = 0; i < lst.length; ++i)\n\
    \    {\n        idx[i] = i;\n        cnts[i] = 0;\n    }\n    for(i = 0; i < lst.length;\
    \ ++i)\n    {\n        if(lst[i] < lst[cnts[i]])\n        {\n            for(cnts[cnts[i]]\
    \ > 0; --cnts[cnts[i]])\n            {\n            }\n            idx[cnts[i]]\
    \ = i;\n            cnts[cnts[i]] = 1;\n            res = lst[i];\n        }\n\
    \    }\n    \n    if(res == null)\n    {\n        return null;\n    }\n    return\
    \ res;\n}", "{\n    if (lst.length == 0) {\n        return Nullable!(long) null;\n\
    \    }\n    \n    long last = lst[lst.length-1];\n    long[] rest = new long[lst.length-1];\n\
    \    System.arraycopy(lst, 0, rest, 0, lst.length-1);\n    \n    // If array is\
    \ sorted in ascending order, \n    // then 2nd-to-last element is the smallest\
    \ one\n    if (rest < lst) {\n        rest.length--;\n    }\n    \n    long smallest\
    \ = rest[0];\n    \n    // Find 2nd smallest element\n    for (long i = 1; i <\
    \ rest.length; i++) {\n        \n        if (smallest > rest[i]) {\n         \
    \   smallest = rest[i];\n        }\n    }\n    \n    return smallest == last ?\
    \ null : smallest;\n}\n/*", "{\n    int i=0;\n    \n    for(; lst[i]>lst[i-1];\
    \ i++ )\n        continue;\n    \n    if(i==0 || lst[i-1]>lst[i-2])\n        return\
    \ Nullable!(long)null;\n    \n    for(; i>1; i-- )\n        if( lst[i]>lst[i-2]\
    \ )\n            return Nullable!(long)null;\n    \n    return lst[i-1];\n}",
  "{\n    if(!lst.is_empty)\n    {\n        long min = lst[1];\n        for(int i\
    \ = 2; i < lst.size(); ++i)\n        {\n            if(lst[i] < min)\n       \
    \     {\n                min = lst[i];\n            }\n        }\n        if(lst.size()\
    \ > 1)\n        {\n            return min;\n        }\n        else\n        {\n\
    \            return null;\n        }\n    }\n    return null;\n}", "  : lst ==\
    \ [] ? null \n    : lst.head < lst.last ? lst.head \n    : next_smallest(lst.tail.tail);\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nYou don't need a function at all.  You can\
    \ use a tuple pattern match to get this done in one line.\n<|/ c |>\n<| c |>\n\
    True, but I prefer my own functions to those in stdlib.\n<|/ c |>\n<| a |>\nSince\
    \ this is a classic example of the recursive problem of finding a smallest element,\
    \ and not finding the biggest, I'm going to use the name smallest of smallest\
    \ element to denote the recursive solution:\n<code>\nsmallest([]) -> null\nsmallest([_])\
    \ -> _\nsmallest([_, x]) -> x\n</code>\nThis can actually be simplified by using\
    \ the identity element:\n<code>\nsmallest([]) -> []\nsmallest([_]) -> _\nsmallest([_,\
    \ x]) -> x\n</code>\nWhich is pretty much what you did with your code.\nI wrote\
    \ a full solution in the context of your problem:\n<code>\nfunction smallest(arr:\
    \ array<int>): int | null;\nfunction smallest(arr: array<int>): int | null;\n\
    function smallest(arr: array<int>): int | null {\n  if arr == [] {\n    return\
    \ null;\n  }", "{\n    if (lst.length == 0) return None;\n    var min = lst[0];\n\
    \    var minIdx = 0;\n    for (let i = 1; i < lst.length; i++) {\n        if (lst[i]\
    \ < min) {\n            min = lst[i];\n            minIdx = i;\n        }\n  \
    \  }\n    return lst[minIdx];\n}\n</code>\n<|/ a tags=swift,arrays,algorithm |>\n\
    <| a |>\nThe code below is just an illustration. You can find lots of resources\
    \ on the web, such as this one that explains how to find the 2nd smallest.\n<code>\n\
    let minElement = Array(myArray).min()\n</code>\nYou get the first element, compare\
    \ it to the 2nd min element and then you get the 2nd min element.\n<|/ a tags=swift,arrays,algorithm\
    \ dscore=0 |>\n<| c |>\nThe question is about the **second** smallest element.\n\
    <|/ c |>\n<| c |>\nBut you just need the first element, isn't it? :) If you look\
    \ at the link I posted in the answer, you can find several ways to find the 2nd\
    \ smallest element. I just gave a simple example to point the OP in the right\
    \ direction.\n<|/ c |>\n<| c |>\nNo, he's not asking for the minimum element (which\
    \ is `myArray[0]`), he's asking for the second smallest (which is the first element\
    \ after being shifted down), which is `myArray[1]`.\n<|/ c |>\n<| c |>\nBut I\
    \ gave him an example of how to get that element and he was asking for a way to\
    \ get it without looping over the array. He wanted the 2nd smallest element in\
    \ a different way.\n<|/ c |>\n<| a dscore=0 |>\nSwift 4\n<code>\nlet sortedArray\
    \ = Array(array).sorted(by: { $0 < $1 })\n</code>\nThis will sort the array in\
    \ ascending order, which can be changed to descending order by just changing the\
    \ < to >\n<|/ a tags=swift,arrays,algorithm |>\n<| c |>\nThe question is about\
    \ the **second** smallest element. Not sorted in ascending order. He just wants\
    \ the first element.\n<|/ c |>\n<| a dscore=0 |>\nThis question has many great\
    \ answers but I just wanted to share my answer with you. \n<code>\nimport Foundation",
  "{\n    var idx = std.array.get_index(lst, null);\n    if (idx >= 0)\n        return\
    \ std.array.get_index(lst, idx + 1);\n    return null;\n}", "{\n    \n    int\
    \ i0 = 0, i1 = lst.len();\n    \n    while (i0 < i1) {\n        int idx = i0 +\
    \ i1;\n        int idx2 = idx;\n        int j;\n        for (; idx2 < lst.len();\
    \ idx2++) {\n            j = idx2 - i0;\n            if (lst[idx2] < lst[idx])\
    \ idx = idx2;\n        }\n        if (lst[idx] == lst[idx + 1]) {\n          \
    \  i0++;\n        } else {\n            return lst[idx];\n        }\n    }\n \
    \   return null;\n}\n'''", "{\n    long? pivot = lst[1];\n    for(long i=2;i<\
    \ lst.lenth;i++) {\n        if(lst[i] < pivot) {\n            pivot = lst[i];\n\
    \        }\n    }\n    return pivot;\n}\n</code>\n<|/ a tags=c++,algorithm,arrays,sorting\
    \ dscore=1 |>\n<| a tags=c++,algorithm,arrays,sorting |>\nHere is my version in\
    \ C++ that works as per OP specifications:\n<code>\n#include <iostream>\n#include\
    \ <vector>\n#include <algorithm>", "{\n    if(lst.length == 0)\n    {\n      \
    \  return Nullable!(long);\n    }\n    int index = 0;\n    while(index<lst.length-1)\n\
    \    {\n        if(lst[index]<lst[index+1])\n        {\n            return lst[index+1];\n\
    \        }\n        else\n        {\n            index++;\n        }\n    }\n\
    \    return Nullable!(long);\n}", "{\n    int n = std.length(lst.mem);\n    if\
    \ (n == 0)\n        return null;\n    if (n <= 1)\n        return lst[0];\n  \
    \  if (n == 1)\n        return null;\n    if (lst[0] <= lst[1])\n        return\
    \ lst[1];", "{ \n  if(lst.length == 1) return lst[0];\n  int index = lst.indexOf(lst[0]);\n\
    \  \n  if(index == -1) return null;\n  \n  if(index != 0) \n    return lst[index\
    \ - 1];\n  return null;\n}", "{\n    int[] indices = Array.getIndices{T: long\
    \ } lst;\n    \n    int index = Array.getIndex(indices)[1];\n    if(index >= 0\
    \ && indices.length>2){\n        return lst[index+1];\n    }else{\n        return\
    \ null;\n    }\n}", "{\n\tint n = length(lst);\n\tif (n < 2)\n\t\treturn Nullable!(long)\
    \ null;\n\tNullable!(long) minVal = lst[0];\n\tfor (int i = 1; i < n; i++)\n\t\
    {\n\t\tif (lst[i] < minVal)\n\t\t{\n\t\t\tminVal = lst[i];\n\t\t}\n\t}\n\treturn\
    \ minVal;\n}", "{\n\tlet mutable curr = Nullable!(long)null;\n\tlet mutable small\
    \ = Nullable!(long)null;\n\tlet mutable small1 = Nullable!(long)null;\n\tlet mutable\
    \ small2 = Nullable!(long)null;\n\t\n\tfor x in lst\n\t{\n\t\t\n\t\tsmall = Nullable!(long)null;\n\
    \t\tsmall1 = Nullable!(long)null;\n\t\tsmall2 = Nullable!(long)null;\n\t\t\n\t\
    \tif (x<=curr)\n\t\t{\n\t\t\tsmall1 = Nullable!(long)null;\n\t\t\tsmall2 = Nullable!(long)null;\n\
    \t\t\tsmall = x;\n\t\t}\n\t\t\n\t\telse if (x<small)\n\t\t{\n\t\t\tsmall2 = Nullable!(long)null;\n\
    \t\t\tsmall = x;\n\t\t}\n\t\t\n\t\telse if (x<small1 && x<small2)\n\t\t{\n\t\t\
    \tsmall1 = x;\n\t\t}\n\t\t\n\t\telse \n\t\t{\n\t\t\tsmall2 = x;\n\t\t}\n\t\t\n\
    \t\tif (small==curr) \n\t\t{\n\t\t\treturn small2;\n\t\t}\n\t\telse\n\t\t{\n\t\
    \t\tcurr = small;\n\t\t}\n\t}\n\treturn small2;\n}\n'''", "{\n  if (lst.empty())\n\
    \    return Nullable!(none);\n  int index = lst.index_min(std.math.cmp!(int,int,int));\n\
    \  if (std.math.cmp!(int,int,int)==0)\n    return Nullable!(lst[index]);\n  return\
    \ Nullable!(next_smallest(lst[index..]));\n}", "{\n\tsize_t i = 0;\n\tsize_t j\
    \ = lst.lenght;\n\twhile(i < j)\n\t{\n\t\tif(lst[i] < lst[j])\n\t\t\ti++;\n\t\t\
    else\n\t\t{\n\t\t\tj--;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (j == 0) ? null :\
    \ lst[j - 1];\n}", "{\n    \n    Nullable res = null;\n    \n    if (lst.length\
    \ == 0) {\n        return res;\n    }\n    \n    // find smallest element\n  \
    \  int smallest = std.search(lst, x => x < lst.min());\n    \n    bool found =\
    \ false;\n    for (int i = smallest; i < lst.length; ++i) {\n        if (lst.is_empty()\
    \ || !lst.contains(i)) {\n            found = true;\n            break;\n    \
    \    }\n    }\n    \n    // if we found a smallest element, then return it\n \
    \   if (found) {\n        return lst.at(smallest);\n    }\n    \n    // else search\
    \ from beginning\n    for (int i = 0; i < lst.length; ++i) {\n        if (lst.is_empty()\
    \ || !lst.contains(i)) {\n            continue;\n        }\n        \n       \
    \ int index = i;\n        if (index < smallest) {\n            index = smallest;\n\
    \        }\n        \n        // test next element\n        Nullable x = next_smallest(lst.tail());\n\
    \        if (x != null) {\n            if (x < lst.at(index)) {\n            \
    \    break;\n            }\n            \n            if (x != null && lst.at(index)\
    \ == x) {\n                return x;\n            }\n            \n          \
    \  if (x > lst.at(index)) {\n                smallest = index;\n            }\n\
    \        }\n    }\n    \n    return res;\n}\n/*", "{\n    int n = length(lst);\n\
    \    long smallestIndex = n - 1;\n    long nextSmallest = lst[smallestIndex];\n\
    \    if (smallestIndex > 0) \n\t{\n\t\tsmallestIndex = smallestIndex - 1;\n\t\t\
    nextSmallest = lst[smallestIndex];\n\t}\n    return nextSmallest;\n}", "{\n  \
    \  long cur, min;\n    for(cur in lst)\n    {\n        if(!isnull(cur) && cur\
    \ < min)\n        {\n            min = cur;\n        }\n    }\n    return min;\n\
    }", "{\n    int i;\n    for(i = lst.lenth; i > 1; i--)\n    {\n        if(lst[i\
    \ - 1] <= lst[i])\n            return lst[i];\n    }\n    return null;\n}", "{\n\
    \    var smallest = lst[0];\n    var index = 1;\n    while (index < lst.length\
    \ && lst[index] <= smallest) {\n        smallest = lst[index];\n        index++;\n\
    \    }\n    if (index == lst.length) {\n        return null;\n    } else {\n \
    \       return smallest;\n    }\n}", "{\n\tvar n = lst.len;\n\tif(n == 0) return\
    \ None;\n\tvar min;\n\tmin = lst[0];\n\tfor(var i = 1; i < n; ++i)\n\t{\n\t\t\
    if(min > lst[i])\n\t\t{\n\t\t\tmin = lst[i];\n\t\t}\n\t}\n\treturn min;\n}\n\"\
    \"\"\n</cell>\n<text>\nExercise 5\nWrite a function that takes an integer array\
    \ as input and outputs the number of items of the array which meet a condition\
    \ (which should be a lambda function).\nFor example, if the input array is:",
  "{\n    if (lst.length < 2) \n        return null; // no 2nd\n    int index = lst.indexOf(lst[0]);\n\
    \    if (index < 0) \n        return null; // no such element\n    if (index ==\
    \ 1) \n        return lst[1];\n    \n    long? next = next_smallest(std.array.dropRight(lst,2));\n\
    \    return std.array.keepRight(next,2); // return the 2nd smallest element, after\
    \ dropping the first\n}", "{\n    for(var i = 0;i < lst.__size;++i){\n       \
    \ if(lst[i] < lst[(i+1)%lst.__size]){\n            return lst[(i+1)%lst.__size];\n\
    \        }\n    }\n    return null;\n}", "{\n    var min = lst[0];\n    var minIdx\
    \ = 0;\n    for(var i=1; i<lst.length; ++i)\n    {\n        if(lst[i] < min)\n\
    \        {\n            min = lst[i];\n            minIdx = i;\n        }\n  \
    \  }\n    return minIdx;\n}\n#endif", "{\n    var min = lst[0];\n    var min_idx\
    \ = 1;\n    for(var i = 1; i < lst.length; i++)\n    {\n        if(lst[i] < min)\n\
    \        {\n            min = lst[i];\n            min_idx = i;\n        }\n \
    \   }\n    return min;\n}", "{\n    long? result = lst[0];\n    if (result ==\
    \ null || result == lst[1])\n        return result;\n    else\n    {\n       \
    \ long? next = next_smallest(lst[1..]);\n        return result == next ? result\
    \ : null;\n    }\n}\n/*", "{\n    var result=lst[0];\n    for(var i = 0; i < lst.length;\
    \ ++i) {\n        if (result < lst[i])\n            result = lst[i];\n    }\n\
    \    if (result != null)\n        return result;\n    else\n        return null;\n\
    }", "{\n    forall(lst.begin(), lst.end(), [lst.begin(), lst.end(), &int_eq]);\n\
    \    \n    if(lst.begin() == lst.end())\n    {\n        return Nullable!(long);\n\
    \    }\n    \n    return min(lst[lst.begin()]);\n}", "{\n    int i = 0;\n    int\
    \ n = 0;\n    if (lst.length>0)\n    {\n        std.sort(lst, std.cmp.lt);\n \
    \       n = lst.length;\n    }\n    if (n>0)\n    {\n        while (i < n && lst[i]<lst[(i+1)%n])\n\
    \            i++;\n        if (i<n)\n        {\n            return lst[i];\n \
    \       }\n    }\n    return Nullable!();\n}\n</code>\n<|/ a tags=c++,stl,sorting,c++11\
    \ |>\n<| a dscore=3 tags=c++,stl,sorting,c++11 |>\nThis is an old question but\
    \ since I couldn't find any other solutions I thought I'd share my implementation\
    \ that does this:\n<code>\ntemplate <typename T> T\nnextSmallest(T const & v,\
    \ T const & begin, T const & end) {\n    // If the input list is empty or contains\
    \ only one element, return null.\n    if (begin == end || begin == end + 1) {\n\
    \        return null;\n    }", "{\n    for(long i = 0; i < lst.lenght; i += 1)\
    \ {\n        if(lst[i] == null || lst[i] < lst[i + 1]) {\n            return lst[i\
    \ + 1];\n        }\n    }\n    return null;\n}", "{\n    if (lst.size == 0) {\n\
    \        return Nullable!(long);\n    }\n    var min_index = std.array.binarySearch(lst,\
    \ std.minLong);\n    if (min_index < 0) \n        return Nullable!(long);\n  \
    \  if (min_index == 0)\n        return Nullable!(long)lst[min_index];", "    requires\
    \ lst.size > 0;\n    ensures lst.size == 2;\n    ensures lst[0] == lst[1];\n \
    \   ensures lst[0] < lst[1];\n    ensures lst[0] < std.math.min(lst[0], lst[1]);\n\
    \    ensures !isNull(lst[0]);\n    ensures !isNull(lst[1]);\n    return std.math.min(lst[1],\
    \ lst[0]);\nend", "    if lst.length == 0\n        null\n    else\n        let\
    \ idx:long = lst.headIndex\n        let prev:long = lst.last\n        let result\
    \ = if prev >= idx\n            then lst.splice(idx, 1, lst.splice(prev - idx,\
    \ 1)[0])\n            else null\n        result", "{\n    var result: Nullable!(long)\
    \ = null;\n    for(var i = 0; i < lst.length; ++i){\n        if(lst[i] < lst[i\
    \ + 1])\n            result = lst[i];\n    }\n    return result;\n}", "{\n   \
    \ if (lst.lent == 0)\n        return null;\n    \n    var index = 1;\n    \n \
    \   if (lst[0] <= lst[index])\n        return lst[0];\n    else\n    {\n     \
    \   index = 2;\n    }\n    \n    while (index < lst.lent)\n    {\n        if (lst[index]\
    \ < lst[index - 1])\n        {\n            return lst[index];\n        }\n  \
    \      \n        index++;\n    }\n    \n    return null;\n}", "    where lst :\
    \ seq<long>; \n{\n    match lst with\n    | [] => Nullable!(long)\n    | hd::tl\
    \ => match hd with\n        | val when val < tl.[1..] -> hd\n        | _ -> tl.[1..].[next_smallest(tl)]\n\
    \    end\n}\n</code>\n<|/ a |>\n<| c |>\nThe other answers are correct, but this\
    \ one is the most efficient\n<|/ c |>\n<| c |>\nGreat answer but what about large\
    \ lists?  In other words it doesn't work well with large lists.  It should be\
    \ noted that this is O(n^2) in time and O(n) in space.  If the list is very large\
    \ it could cause a stack overflow.\n<|/ c |>\n<| c |>\nIf your list is very large,\
    \ you're probably using the wrong data structure. An array is O(1) insertion,\
    \ whereas a list is O(n) insertion. I suggest you check out [`Data.Array`](https://hackage.haskell.org/package/array-0.8.0.1/docs/Data-Array.html)\
    \ or [`Data.BitVector`](https://hackage.haskell.org/package/bitvector-0.8.0.1/docs/Data-BitVector.html).\n\
    <|/ c |>\n<| c |>\nThanks for the suggestion.  Yes I'm aware that these are O(n^2)\
    \ in time and O(n) in space.  But if your input is large enough then these are\
    \ going to be a bottleneck right?  Because it is O(n^2) in time and O(n) in space.\
    \  That is fine if it is a bottleneck but if it is not then your solution is wrong.\
    \  I don't see how your solution is O(n) in space though.\n<|/ c |>\n<| c |>\n\
    O(n^2) in time and O(n) in space is not the same as O(n) in time or O(n) in space.\
    \ In the latter case, we can't assume that we are limited by the amount of memory\
    \ available to our program. Even if we assume constant memory usage and constant\
    \ time, it's still O(n^2) in time and O(n^2) in space.\n<|/ c |>\n<| a tags=algorithm,data-structures,haskell,performance,list\
    \ |>\nYou could use a list and a helper function to remove a node from the list.\n\
    <code>\nnext_smallest [] = Nothing\nnext_smallest (h:t) \n  | h < head t = Just\
    \ h\n  | otherwise   = Nothing\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThat looks\
    \ nice, but what is the performance of such function?\n<|/ c |>", "{\n  if (lst.isEmpty)\n\
    \    return null;\n  \n  var idx = 1;\n  var minIdx = 0;\n  for(i <- 1 .. lst.length)\n\
    \  {\n    if (lst[idx] < lst[minIdx])\n    {\n      idx = i;\n      minIdx = i;\n\
    \    }\n  }\n  return lst[minIdx];\n}", "{\n\tif (lst.length == 0)\n\t{\n\t\t\
    throw new Exception('Empty list');\n\t}\n\tlong result = lst[1];\n\tfor (int i\
    \ = 2; i < lst.length; ++i)\n\t{\n\t\tif (lst[i] < result)\n\t\t{\n\t\t\tresult\
    \ = lst[i];\n\t\t}\n\t}\n\treturn result;\n}", "{\n\tvar lstLength = length(lst);\n\
    \tif (lstLength == 0) {\n\t\treturn null;\n\t} else if (lstLength == 1) {\n\t\t\
    return lst[0];\n\t} else {\n\t\tvar currentMin = lst[0];\n\t\tvar nextMin = lst[1];\n\
    \t\tvar currentIndex = listIndex(lst, currentMin);\n\t\twhile (currentIndex <\
    \ lstLength - 1) {\n\t\t\tvar currentMin = lst[currentIndex];\n\t\t\tvar nextMin\
    \ = lst[currentIndex + 1];\n\t\t\tvar currentIndex = listIndex(lst, currentMin);\n\
    \t\t\tif (currentMin < nextMin) {\n\t\t\t\tnextMin = currentMin;\n\t\t\t}\n\t\t\
    }\n\t\treturn nextMin;\n\t}\n}", "{\n  var x = lst[0]\n  if (x.length > 0)\n \
    \ {\n    for (var i = 1; i < x.length; i++)\n    {\n      if (x[i] < x[x.length-1])\n\
    \      {\n        swap(x[i], x[x.length-1])\n      }\n    }\n    return x[x.length-1]\n\
    \  }\n  return null;\n}\n\"\"\"\n    return r", "{\n  if(!lst.isEmpty)\n  {\n\
    \    long result = lst[1];\n    for(long i = 2; i < lst.size; ++i)\n    {\n  \
    \    if(lst[i] < result)\n      {\n        result = lst[i];\n      }\n    }\n\
    \    return result;\n  }\n  return Nullable!(long);\n}", "{\n  var smallest =\
    \ lst[0];\n  var count = 0;\n  for (var i = 0; i < lst.length; ++i) {\n    if\
    \ (smallest > lst[i]) {\n      smallest = lst[i];\n      ++count;\n    }\n  }\n\
    \  if (count == 1) return smallest;\n  return null;\n}", "{\n    var smallest\
    \ = lst[0];\n    for(int i=1; i<lst.length; ++i)\n    {\n        if(smallest >\
    \ lst[i])\n        {\n            smallest = lst[i];\n        }\n    }\n    return\
    \ smallest;\n}", "    where lst.len > 0\n    return \n        if lst.len == 0\n\
    \            Nullable!(long) None\n        else\n            if lst.head < lst.tail.head\n\
    \                lst.tail.tail\n            else\n                lst.head\n \
    \           endif\n        end;\n</code>\n<|/ a tags=algorithm,language-agnostic,arrays\
    \ dscore=0 |>\n<| a |>\nThe solution is simple.\nYou start by sorting the array\
    \ by descending order (largest to smallest).\n<code>\nArray.Sort(arr)\n</code>\n\
    Then iterate over each element in the sorted array, and return the last element\
    \ found.\n<code>\nFor i = 0 to arr.Length - 1\n  If arr(i) <> arr(i + 1)\n   \
    \ Return arr(i)\n  EndIf\nEndFor\n</code>\n<|/ a tags=algorithm,language-agnostic,arrays\
    \ dscore=0 |>\n<| a |>\nYou could do this in 2 lines of code: \n<code>\nvar input\
    \ = new int[] { 5, 5, 4, 4, 3};\nvar largest = input.OrderByDescending(x => x).FirstOrDefault();\n\
    </code>\n<|/ a dscore=0 tags=algorithm,language-agnostic,arrays |>\n<| a dscore=0\
    \ |>\nA very short solution is to use LINQ's OrderByDescending extension method.\
    \ \n<code>", "{\n    if(lst.lenth==1)\n    {\n        if(lst[0]==0)\n        {\n\
    \            return 0;\n        }\n        else\n        {\n            return\
    \ null;\n        }\n    }\n    long mid=lst.length/2;\n    long first=lst[mid];\n\
    \    long second=lst[mid+1];\n    if(first<second)\n    {\n        return first;\n\
    \    }\n    else\n    {\n        return second;\n    }\n}", "{\n    let index\
    \ = lst.indexOf(min(lst));\n    if index != -1 \n       return lst[index + 1];\n\
    \    else \n       return null;\n}\n/*", "    requires lst.is_sorted()\n{\n  \
    \  int i, j, k, cnt;\n    if(lst.is_empty())\n        return null;\n    cnt =\
    \ 1;\n    for(i=lst.size()-2; i>=0; i--)\n        if(lst[i].less(lst[i+1]))\n\
    \            cnt++;\n    for(i=lst.size()-2; i>=0; i--)\n        for(j=i+1; j<lst.size();\
    \ j++)\n            if(lst[i].less(lst[j]))\n            {\n                cnt++;\n\
    \                k = j;\n                break;\n            }\n    if(cnt > 2)\n\
    \        return lst[k];\n    return null;\n}\n*/\nfunction next_smallest(lst)\n\
    {\n    var i, j, k, cnt;\n    if(lst.is_empty())\n        return null;\n    cnt\
    \ = 1;\n    for(i=lst.size()-2; i>=0; i--)\n        if(lst[i].less(lst[i+1]))\n\
    \            cnt++;\n    for(i=lst.size()-2; i>=0; i--)\n        for(j=i+1; j<lst.size();\
    \ j++)\n            if(lst[i].less(lst[j]))\n            {\n                cnt++;\n\
    \                k = j;\n                break;\n            }\n    if(cnt > 2)\n\
    \        return lst[k];\n    return null;\n}\n</cell>\n<cell>\n/*", "{\n    if(lst.length\
    \ == 0)\n        return null;\n    int first_value = lst[0];\n    long[] new_list\
    \ = lst[1..lst.length];\n    new_list.sort(compare);\n    if(!is_null(new_list[1]))\n\
    \        return new_list[1];\n    if(lst.length == 1)\n        return null;\n\
    \    return next_smallest(new_list);\n}\n/*", "{\n    if (lst is [])\n       \
    \ return null;\n    else if (lst is [Nullable!(long)]) // this line is not required\n\
    \        return std.min(lst);\n    else\n        return std.min(lst, function(item)\
    \ { return item.next });\n}\n/* \n    You are given an array a and a value v.\n\
    \    Write a procedure search() that returns a value k such that v is in the array\n\
    \    only if all the following hold:\n    \n    0 <= k < a.length\n    a[k] ==\
    \ v\n*/\nNullable!(int) search(int[] a, int v)\n{\n    if (a is [])\n        return\
    \ null;\n    else if (a is [Nullable!(int)]) // this line is not required\n  \
    \      return 0;\n    else if (a is [int])\n        return search(a, 0)\n    else\n\
    \        return search(a, std.min(a, function(item) { return item.next }));\n\
    }\n/* \n    You are given an array a and a value v.\n    Write a procedure search()\
    \ that returns a value k such that v is in the array\n    only if all the following\
    \ hold:\n    \n    0 <= k < a.length\n    a[k] == v\n    a[a.length-1] == v\n\
    */\nNullable!(int) search(int[] a, int v)\n{\n    if (a is [])\n        return\
    \ null;\n    else if (a is [Nullable!(int)]) // this line is not required\n  \
    \      return 0;\n    else if (a is [int])\n        return search(a, 0)\n    else\
    \ if (a is [Nullable!(int)]) // this line is not required\n        return a.length-1;\n\
    \    else if (a is [int])\n        return search(a, a.length-1)\n    else\n  \
    \      return search(a, std.min(a, function(item) { return item.next }));\n}\n\
    /* \n    You are given an array a and a value v.\n    Write a procedure search()\
    \ that returns a value k such that v is in the array\n    only if all the following\
    \ hold:\n    \n    0 <= k < a.length\n    a[k] == v\n    a[a.length-1] == v\n\
    \    a[a.length-2] == v\n    a[a.length-3] == v\n    ...\n*/\nNullable!(int) search(int[]\
    \ a, int v)\n{\n    if (a is [])\n        return null;\n    else if (a is [Nullable!(int)])\
    \ // this line is not required\n        return 0;\n    else if (a is [int])\n\
    \        return search(a, 0)\n    else if (a is [Nullable!(int)]) // this line\
    \ is not required\n        return a.length-1;\n    else if (a is [int])\n    \
    \    return search(a, a.length-1)\n    else if (a is [Nullable!(int)]) // this\
    \ line is not required\n        return a.length-2\n", "  : list[long]\n{\n  //\
    \ Your code here\n  var smallest = null;\n  \n  for(var i = 0; i < lst.length;\
    \ ++i)\n  {\n    if(smallest == null || smallest.value > lst[i])\n    {\n    \
    \  smallest = new Nullable!(long)(lst[i]);\n    }\n  }\n  \n  return smallest;\n\
    }", "{\n    return lst.len()<2 ? lst.head() : lst.tail().min();\n}\n/*", "{\n\
    \    for(long i=0;i<lst.length;i++){\n        if(lst[i]>lst[i+1]){\n         \
    \   return lst[i+1];\n        }\n    }\n    return null;\n}\n/*", "{\n    var\
    \ smallest = lst[0];\n    var pos = 0;\n    for (var i = 1; i < lst.length; ++i)\
    \ {\n        if (smallest  < lst[i]) {\n            smallest = lst[i];\n     \
    \       pos = i;\n        }\n    }\n    return pos !== lst.length ? lst[pos] :\
    \ Nullable!(long);\n}", "{\n    if (lst.length==0)\n        return Nullable!(long)\
    \ null;\n    \n    long l = lst[0];\n    for (long i = 1; i < lst.length; i++)\
    \ {\n        if (lst[i]<l) return Nullable!(long) null;\n        l = lst[i];\n\
    \    }\n    return Nullable!(long) l;\n}", "{\n    for(var i = 1; i < lst.Length;\
    \ i++)\n        if(lst[i] < lst[i - 1]) return lst[i];\n    return null;\n}",
  "{\n    var tmp, tmp1, tmp2;\n    \n    tmp1 = lst[0]; // get 1st element\n    \n\
    \    for(int i = 1; i < lst.length; i++) \n    {\n        tmp2 = lst[i]; // get\
    \ next element\n        if(tmp2 < tmp1) \n        {\n            tmp = tmp2;\n\
    \            tmp1 = tmp;\n        }\n        else\n        {\n            break;\n\
    \        }\n    }\n    return tmp1;\n}", "{\n    for(long i = 0; i < lst.lenth;\
    \ ++i)\n    {\n        if(lst[i] < lst[i*+1])\n        {\n            return lst[i*+1];\n\
    \        }\n    }\n    return null;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    While this code may answer the question, providing additional context regarding\
    \ how and/or why it solves the problem would improve the answer's long-term value.\n\
    <|/ c |>\n<| c |>\nthank you so much for providing more details.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nThis is probably the shortest solution of all:\n<code>\npublic\
    \ static long nextSmallest(long... elements) {\n    return IntStream.of(elements).min(Comparator.naturalOrder())\n\
    \            .orElse(null);\n}\n</code>\n<|/ a tags=arrays,java |>\n<| a dscore=0\
    \ |>\n<code>\npublic static int nextSmallest(int[] nums) {\n    int smallest =\
    \ nums[0];\n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] <\
    \ smallest) {\n            smallest = nums[i];\n        }\n    }\n    return smallest;\n\
    }\n</code>\n<|/ a tags=arrays,java |>\n<| c |>\nThis doesn't take into account\
    \ the fact that OP wants to return null.\n<|/ c |>\n<| c |>\n\"Return the 2nd\
    \ smallest element of the array\" OP said \"null\"\n<|/ c |>\n<| c |>\nBut it\
    \ doesn't, the code you posted returns null for the case of an empty array. The\
    \ OP said null.\n<|/ c |>\n<| c |>\nIt does for me, that's why I'm upvoting it,\
    \ but I guess it could be confusing for someone not as familiar with Java.\n<|/\
    \ c |>\n<| c |>\n`nextSmallest` returns null when `nums` is empty, but OP said\
    \ the function should return null if the array is empty too. It would be a poor\
    \ coding practice for it to return null when called on an empty array. The OP\
    \ also said that he doesn't want to use Arrays.sort.\n<|/ c |>\n<| a tags=arrays,java\
    \ |>\nYou can try this one:\n<code>", "{\n    if (lst.size == 0)\n        return\
    \ Nullable!(long) null;\n    long smallest  = lst.first;\n    long secondSmallest\
    \  = lst.last;\n    long result = secondSmallest;\n    for (int i = 1; i < lst.size;\
    \ ++i) {\n        smallest = min(secondSmallest, smallest);\n        secondSmallest\
    \ = min(secondSmallest, lst.at(i));\n        result = min(secondSmallest, result);\n\
    \    }\n    return smallest;\n}", "{\n    if (lst.len == 0) return null;\n   \
    \ long x = lst[0];\n    long y = lst[1];\n    for (int i = 2; i < lst.len; ++i)\
    \ {\n        if (lst[i] < x) x = lst[i];\n        else y = lst[i];\n    }\n  \
    \  return x;\n}\n</code>\n<|/ a tags=c++,arrays,sorting |>\n<| c |>\nYes, I see\
    \ that this is what your `next_smallest` function does.\n<|/ c |>\n<| c |>\nThanks\
    \ for your reply. But the function which i posted is giving some errors. I already\
    \ posted the errors there.\n<|/ c |>\n<| c |>\nSorry about that. I was thinking\
    \ something else when I was posting the answer. I've updated my answer to correct\
    \ the original code.\n<|/ c |>\n<| c |>\nOh yeah, sorry. Just a typo. Fixed.\n\
    <|/ c |>\n<| c |>\nCan you help me with the errors now?\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\nclass Array\n{\n    int *array;\n    int size;\npublic:\n    Array(int\
    \ size)\n    {\n        array = new int[size];\n    }\n    Array()\n    {\n  \
    \      array = NULL;\n        size = 0;\n    }\n    ~Array()\n    {\n        delete\
    \ [] array;\n    }\n    void input(int a[], int size)\n    {\n        size = size;\n\
    \        for (int i = 0; i < size; i++)\n        {\n            array[i] = a[i];\n\
    \        }\n    }\n    void output()\n    {\n        for (int i = 0; i < size;\
    \ i++)\n        {\n            cout << array[i] << endl;\n        }\n    }\n \
    \   void remove(int index)\n    {\n        for (int i = index; i < size - 1; i++)\n\
    \        {\n            array[i] = array[i + 1];\n        }\n        size--;\n\
    \    }\n    int search(int index)\n    {\n        int x = array[index];\n    \
    \    return x;\n    }\n};", "{\n    var min = lst[0];\n    var min_index = -1;\n\
    \    var min_index2 = -1;\n    var min_index3 = -1;\n    foreach(x IN lst.tail)\
    \ {\n        if(x == min) {\n            min_index2 = min_index;\n           \
    \ min_index3 = min_index2;\n            min_index = lst.length;\n        } else\n\
    \        if(x == min_index + 1) {\n            min_index2 = x;\n            min_index\
    \ = x;\n        } else\n        if(x == min_index2 + 1) {\n            min_index3\
    \ = x;\n        }\n    }\n    if(min_index2 == -1 || min_index3 == -1 || min_index\
    \ == lst.length-1)\n        return null;\n    else\n        return min_index3;\n\
    }", "{\n    var minVal: int64 = lst[0];\n    \n    var minIdx = IntArray!((lst.len\
    \ - 1));\n    foru(i, 0, lst.len){\n        if(!isNull(lst[i])){\n           \
    \ if((int64) lst[i] == minVal)\n            {\n                minIdx[i - 1] =\
    \ i;\n            }\n        }\n    }\n    if(lst.len > 0){\n        foru(i, 0,\
    \ minIdx.len){\n            if(!isNull(lst[minIdx[i]])){\n                minIdx[i\
    \ - 1] = minIdx[i];\n            }\n        }\n    }\n    if(minIdx.len > 1)\n\
    \    {\n        var minIdx2: int64 = lst[minIdx[0]];\n        foru(i, 1, minIdx.len){\n\
    \            if(isNull(lst[minIdx[i]]))\n            {\n                minIdx2\
    \ = lst[minIdx[i]];\n                break;\n            }\n        }\n      \
    \  return minIdx2\n    }\n    return Nullable!(minIdx);\n}\n/*", "{\n    // code\
    \ here\n    return null;\n}\n</code>\n<|/ a tags=arrays,algorithm,sorting,c,language-agnostic\
    \ dscore=1 |>\n<| a tags=arrays,algorithm,sorting,c,language-agnostic |>\nUsing\
    \ Quicksort.", "    where lst : Vector<int>;\n{\n    var smallest = std.min(lst);\n\
    \    var nextSmallest = std.minIndex(std.remove(lst, smallest));\n    return nextSmallest\
    \ == -1 ? null : lst[nextSmallest];\n}\n/*", "{\n  var min;\n  var min_index;\n\
    \  \n  min = std.min(lst);\n  min_index = 0;\n  while(min_index < lst.length ){\n\
    \    if(lst[min_index] < min){\n      min_index = min_index + 1;\n    }else{\n\
    \      lst[min_index] = lst[min_index + 1];\n      min_index++;\n    }\n  }\n\
    \  return min_index == lst.length ? std.null : lst[min_index];\n}", "{\n\tvar\
    \ pos = lst.lenth - 1;\n\twhile(pos >= 0) \n\t{\n\t\tif(lst[pos] < lst[pos+1])\
    \ \n\t\t{\n\t\t\tvar tmp = lst[pos];\n\t\t\tlst[pos] = lst[pos+1];\n\t\t\tlst[pos+1]\
    \ = tmp;\n\t\t\tpos--;\n\t\t\tcontinue;\n\t\t}\n\t\telse \n\t\t{\n\t\t\treturn\
    \ null;\n\t\t}\n\t\tbreak;\n\t}\n\treturn lst[pos];\n}", "{\n    let m = 1;\n\
    \    let n = std.typecons.next_power_of_two(std.math.get_bit(lst,0));\n    while(m\
    \ <= n && m <= lst.len)\n    {\n        let curr = std.typecons.next_power_of_two(std.math.get_bit(lst,m-1));\n\
    \        if (curr < m)\n        {\n            m = curr;\n        }\n        else\
    \ \n        {\n            if (m != n && n < m) \n            {\n            \
    \    return null;\n            }\n            break;\n        }\n    }\n    return\
    \ m;\n}\n\"\"\"", "{\n    var n = 0;\n    var min = lst[n];\n    var max = 0;\n\
    \    for(var i = 0; i < n; i++)\n    {\n        if(lst[i] < min)\n        {\n\
    \            min = lst[i];\n        }\n        else if(lst[i] > max)\n       \
    \ {\n            max = lst[i];\n        }\n    }\n    return max;\n}", "{\n  \
    \  if(lst.length==0)\n        return null;\n    return lst[1];\n}", "{\n    if\
    \ (lst.length == 0) {\n        return Nullable!(long) null;\n    }\n    var smallest\
    \ = lst[0];\n    var second = lst[1];\n    for (var i = 1; i < lst.length; ++i)\
    \ {\n        if (lst[i] < smallest) {\n            second = smallest;\n      \
    \      smallest = lst[i];\n        } else if (lst[i] > second && lst[i] != smallest)\
    \ {\n            second = lst[i];\n        }\n    }\n    return smallest;\n}",
  "{\n    foreach (i <- 0..lst.length - 1 ) {\n        long x = lst[i];\n        if\
    \ ( x < lst[i + 1] ) return x;\n    }\n    return null;\n}", "    where \n   \
    \     NextSmaller: long-> Option<long> = function(a: long): Option<long> \n  \
    \          when is_sorted_long(a) then \n                if a > 0 then\n     \
    \               Some(a)\n                else\n                    None\n    \
    \            end\n            else\n                if a < 0 then\n          \
    \          None\n                else\n                    Some(a)\n         \
    \       end\n            end\n        | NextSmaller: long-> Option<long> = function(a:\
    \ long): Option<long> \n            when is_sorted_long(a) then \n           \
    \     Some(a)\n            else\n                None\n            end\n    |\
    \ NextSmaller: long-> Option<long> = function(a: long): Option<long> \n      \
    \      when is_sorted_long(a) then \n                if a < 0 then\n         \
    \           None\n                else\n                    Some(a)\n        \
    \        end\n            else\n                if a > 0 then\n              \
    \      None\n                else\n                    Some(a)\n             \
    \   end\n            end\n        | NextSmaller: long-> Option<long> = function(a:\
    \ long): Option<long> \n            when is_sorted_long(a) then \n           \
    \     if a > 0 then\n                    Some(a)\n                else\n     \
    \               None\n                end\n            else\n                if\
    \ a < 0 then\n                    None\n                else\n               \
    \     Some(a)\n                end\n            end\n        | NextSmaller: long->\
    \ Option<long> = function(a: long): Option<long> \n            when is_sorted_long(a)\
    \ then \n                if a > 0 then\n                    Some(a)\n        \
    \        else\n                    None\n                end\n            else\n\
    \                if a < 0 then\n                    None\n                else\n\
    \                    Some(a)\n                end\n            end\n        |\
    \ NextSmaller: long-> Option<long> = function(a: long): Option<long> \n      \
    \      when is_sorted_long(a) then \n                if a < 0 then\n         \
    \           Some(a)\n                else\n                    None\n        \
    \        end\n            else\n                if a > 0 then\n              \
    \      None\n                else\n                    Some(a)\n             \
    \   end\n            end\n        | NextSmaller: long-> Option<long> = function(a:\
    \ long): Option<long> \n            when is_sorted_long(a) then \n           \
    \     if a > 0 then\n                    Some(a)\n                else\n     \
    \               None\n                end\n            else\n                if\
    \ a < 0 then\n                    None\n                else\n               \
    \     Some(a)\n                end\n            end\n        | NextSmaller: long->\
    \ Option<long> = function(a: long): Option<long> \n            when ", "{\n  \
    \  Nullable!(long) result = null;\n    var min = long.MIN_VALUE;\n    var largest\
    \ = long.MAX_VALUE;\n    foreach(long num in lst) {\n        if (num < min) {\n\
    \            min = num;\n            result = min;\n        }\n        else if\
    \ (num > largest) {\n            largest = num;\n            result = largest;\n\
    \        }\n    }\n    return result;\n}", "{\n    if (lst.Length > 1) \n    {\n\
    \        var result = lst[1];\n        for (int i = 2; i <= lst.Length; i++) {\n\
    \            if (lst[i] < result) {\n                result = lst[i];\n      \
    \      }\n        }\n        return result;\n    }\n    return null;\n}\n</code>\n\
    <|/ a tags=c#,linq,linqpad |>\n<| c |>\nThis is nice. But doesn't look like C#.\
    \ Did you mean C#?\n<|/ c |>\n<| c |>\nThe C# version is called \"Linqpad\". Looks\
    \ like you didn't read my post before downvoting it.\n<|/ c |>\n<| c |>\nHaha\
    \ sorry. Never mind. I thought the question was tagged with C#, since it's what\
    \ I use for answering questions on StackOverflow. But it appears my question was\
    \ down voted because I didn't realize it was C#. Sorry about that. =)\n<|/ c |>\n\
    <| c |>\nOh yeah. My bad. Thanks for the correction.\n<|/ c |>\n<| a tags=c#,linq,linqpad\
    \ |>\n<code>\nvar result = list.OrderBy(x => x).Skip(1).FirstOrDefault();\n</code>\n\
    <|/ a dscore=2 |>\n<| a |>\nI agree with Ilya that there is no need for the null\
    \ check, however, I would do it more like this:\n<code>\nreturn list.OrderBy(n\
    \ => n).Skip(1).FirstOrDefault();\n</code>\nThis way there is no null check, and\
    \ it also performs a single iteration over the list. \nThis is more memory efficient\
    \ than the other solutions, because it will not store the whole list in memory\
    \ before returning the value.\n<|/ a dscore=2 tags=c#,linq,linqpad |>\n<| a |>\n\
    <code>\nlist.OrderBy(n => n).Skip(1).FirstOrDefault();\n</code>\nThe above code\
    \ will return the 2nd smallest number in the array.\n<|/ a dscore=1 tags=c#,linq,linqpad\
    \ |>\n<| a |>\n<code>\nvar arr = new List<int>() { 6, 0, 3, 7, 2, 5, 1 };\nvar\
    \ res = arr.OrderBy(i => i).Skip(1).FirstOrDefault();\n</code>\n<|/ a dscore=0\
    \ tags=c#,linq,linqpad |>\n<| c |>\nA bit of explanation would be helpful...\n\
    <|/ c |>\n<| c |>\nWhile this code snippet may solve the problem, it doesn't explain\
    \ why or how it answers the question. Please ", "\t: lst == null ? (Nullable!(long))\
    \ null \n\t: lst == [head|tail] ? (next_smallest[tail])\n\t: head<tail[0] ? (next_smallest[tail])\n\
    \t: head<tail[1] ? (next_smallest[tail])\n\t: head<tail[2] ? (next_smallest[tail])\n\
    \t: head<tail[3] ? (next_smallest[tail])\n\t: head<tail[4] ? (next_smallest[tail])\n\
    \t: head<tail[5] ? (next_smallest[tail])\n\t: head<tail[6] ? (next_smallest[tail])\n\
    \t: head<tail[7] ? (next_smallest[tail])\n\t: head<tail[8] ? (next_smallest[tail])\n\
    \t: head<tail[9] ? (next_smallest[tail])\n\t: head<tail[10] ? (next_smallest[tail])\n\
    \t: head<tail[11] ? (next_smallest[tail])\n\t: head<tail[12] ? (next_smallest[tail])\n\
    \t: head<tail[13] ? (next_smallest[tail])\n\t: head<tail[14] ? (next_smallest[tail])\n\
    \t: head<tail[15] ? (next_smallest[tail])\n\t: head<tail[16] ? (next_smallest[tail])\n\
    \t: head<tail[17] ? (next_smallest[tail])\n\t: head<tail[18] ? (next_smallest[tail])\n\
    \t: head<tail[19] ? (next_smallest[tail])\n\t: head<tail[20] ? (next_smallest[tail])\n\
    \t: head<tail[21] ? (next_smallest[tail])\n\t: head<tail[22] ? (next_smallest[tail])\n\
    \t: head<tail[23] ? (next_smallest[tail])\n\t: head<tail[24] ? (next_smallest[tail])\n\
    \t: head<tail[25] ? (next_smallest[tail])\n\t: head<tail[26] ? (next_smallest[tail])\n\
    \t: head<tail[27] ? (next_smallest[tail])\n\t: head<tail[28] ? (next_smallest[tail])\n\
    \t: head<tail[29] ? (next_smallest[tail])\n\t: head<tail[30] ? (next_smallest[tail])\n\
    \t", "  : Array1!(long, (long, long, long, int, int) -> bool) =\n  \n    if length(lst)\
    \ == 0 then \n      null;\n    else if length(lst) == 1 then \n      lst[0];\n\
    \    else \n      val min2 = min_max_of_list(lst);\n      if min2._2 > min2._1\
    \ then \n        min2._2\n      else \n        min2._1; \n          \n  /*\n \
    \   You are given an integer and an array as arguments.\n    Return the position\
    \ (index) of the first occurrence of the given value in the array.\n    It is\
    \ guaranteed that the given value exists in the array.\n    If no such value is\
    \ found in the array, return -1.\n    >>> index([1, 2, 1, 3, 3], 3)\n    1\n \
    \   >>> index([1, 2, 3, 3, 4], 3)\n    -1\n    >>> index([10, 20, 30, 40, 10],\
    \ 40)\n    -1\n    \n    Don't use Array!\n    >>> index([10, 20, 30, 40, 10],\
    \ 50)\n    -1\n    \n    You are given an array as arguments.\n    Return true\
    \ if and only if the given element is in the array.\n    >>> contains([1, 2, 3,\
    \ 4], 4)\n    True\n    >>> contains([-10, 20, 30, 40], 40)\n    True\n    \n\
    \    Don't use Array!\n    >>> contains([10, 20, 30, 40, 10], 20)\n    True\n\
    \    \n    You are given an integer and an array as arguments.\n    Return the\
    \ index of the given element in the array.\n    >>> indexIn([10, 20, 30, 40, 10],\
    \ 40)\n    4\n    >>> indexIn([10, 20, 30, 40, 10], 50)\n    -1\n    >>> indexIn([10,\
    \ 20, 30, 40, 10], 20)\n    -1\n    \n    Don't use Array!\n    >>> indexIn([10,\
    \ 20, 30, 40, 10], 10)\n    0\n    \n    You are given an array as arguments.\n\
    \    Return true if and only if the given element is in the array.\n    >>> containsIn([10,\
    \ 20, 30, 40, 10], 20)\n    True\n    >>> containsIn([10, 20, 30, 40, 10], 30)\n\
    \    False\n    \n    Don't use Array!\n    >>> containsIn([10, 20, 30, 40, 10],\
    \ 10)\n    False\n    \n    You are given a tuple as argument.\n    In the tuple,\
    \ there are two elements (x, y) which represent the x and y coordinates of a point\
    \ in the plane. The tuple is given in the form (x, y). Return true if and only\
    \ if the point (x, y) is in the plane.\n    >>> inPlane ([1,1], [0,1], [1,0])\n\
    \    True\n    >>> inPlane ([1,1], [0,1], [1,1])\n    True\n    >>> inPlane ([1,0],\
    \ [1,0], [1,1])\n    True\n    \n    Don't use Array!\n    >>> inPlane([10,10,10,10],[20,20,20,",
  "  : null => Nullable!(long)\n  | lst.length == 1\n    => if (lst[0] < lst[1]) lst[0]\n\
    \    else null\n  | otherwise => let result = lst[0] in \n    let result = lst[1]\
    \ in \n      if (lst[0] < lst[1]) lst[0]\n      else lst[1]\n    in result;\n\
    ;;\n(* do not edit below this line *)", "{\n    var smallest=lst[0]; \n    var\
    \ i=1;\n    while(i < lst.length) {\n        if (lst[i] < smallest) {\n      \
    \      smallest = lst[i];\n        }\n        i++;\n    }\n    return smallest;\n\
    }", "    : for(long i = 0; i < lst.length; ++i)\n        if( lst[i] < lst[i+1]\
    \ ) \n            { return lst[i]; }\n        else\n            { lst.pop(); return\
    \ null; }\n            \n/*\n    You are given an array of integers and a number\
    \ X.\n    Write a function next_greater() that returns the next greater element\
    \ in the array.\n    Return null if there is no such element.\n    >>> next_greater([5L,\
    \ 2L, 3L, 1L, 4L], 1L)\n    4L\n    >>> next_greater([5L, 2L, 3L, 1L, 4L], 2L)\n\
    \    5L\n    >>> next_greater([5L, 2L, 3L, 1L, 4L], 5L)\n    null\n    \n*/\n\
    Nullable!(long) next_greater(long[] lst, long x) \n    : for(long i = 0; i < lst.length;\
    \ ++i)\n        if( lst[i] > x )\n            { return lst[i]; }\n        else\n\
    \            { lst.pop(); return null; }\n            \n/*\n    You are given\
    \ an array of integers and a number X.\n    Write a function next_greater_or_equal()\
    \ that returns the next greater element in the array, or null if there is no such\
    \ element.\n    >>> next_greater_or_equal([5L, 2L, 3L, 1L, 4L], 2L)\n    5L\n\
    \    >>> next_greater_or_equal([5L, 2L, 3L, 1L, 4L], 1L)\n    1L\n    >>> next_greater_or_equal([5L,\
    \ 2L, 3L, 1L, 4L], 5L)\n    null\n    \n*/\nNullable!(long) next_greater_or_equal(long[]\
    \ lst, long x) \n    : for(long i = 0; i < lst.length; ++i)\n        if( lst[i]\
    \ >= x )\n            { return lst[i]; }\n        else\n            { lst.pop();\
    \ return null; }\n            \n/*\n    You are given an array of integers and\
    \ a number X.\n    Write a function next_less() that returns the next less element\
    \ in the array.\n    Return null if there is no such element.\n    >>> next_less([5L,\
    \ 2L, 3L, 1L, 4L], 1L)\n    1L\n    >>> next_less([5L, 2L, 3L, 1L, 4L], 2L)\n\
    \    2L\n    >>> next_less([5L, 2L, 3L, 1L, 4L], 5L)\n    null\n    \n*/\nNullable!(long)\
    \ next_less(long[] lst, long x) \n    : for(long i = 0; i < lst.length; ++i)\n\
    \        if( lst[i] <= x )\n            { return lst[i]; }\n        else\n   \
    \         { lst.pop(); return null; }\n            \n/*\n    You are given an\
    \ array of integers and a number X.", "{\n    int i=0;\n    long min = 0;\n  \
    \  long max = 0;\n    long n = 0;\n    for(i = 0; i < lst.Length; ++i)\n    {\n\
    \        if(lst[i] < min)\n        {\n            min = lst[i];\n        }\n \
    \       else if(lst[i] > max)\n        {\n            max = lst[i];\n        }\n\
    \        else if(lst[i] == min)\n        {\n            n = 1;\n        }\n  \
    \  }\n    \n    if(n == 1)\n    {\n        return min;\n    }\n    else\n    {\n\
    \        return null;\n    }\n}\n//==========================================================================================\n\
    function next_smallest_2<T>(lst: T[]): Nullable<T> {\n    var min: T = null;\n\
    \    var max: T = null;\n    var index: integer = 0;\n    for (index = 0; index\
    \ < lst.Length; index++) {\n        if (lst[index] < min) {\n            min =\
    \ lst[index];\n        } else if (lst[index] > max) {\n            max = lst[index];\n\
    \        }\n    }\n    return max == null ? null : min;\n}\n</code>\n<|/ a tags=c#,c++,algorithm\
    \ dscore=1 |>\n<| a dscore=1 tags=c#,c++,algorithm |>\n<code>\npublic static long\
    \ nextSmallest(long[] list) {\n    int i = 0;\n    int min = list[i];\n    int\
    \ max = list[i];\n    long index = i;\n    while(i < list.Length-1) {\n      \
    \  if(list[i] > max) {\n            max = list[i];\n            index = i;\n \
    \       }\n        else if(list[i] < min) {\n            min = list[i];\n    \
    \    }\n        else {\n            break;\n        }\n        i++;\n    }\n \
    \   return list[index];\n}\n</code>\n<|/ a |>\n<| c |>\nHmm, this is similar to\
    \ mine. Could you please explain how does it work?\n<|/ c |>\n<| c |>\nThis code\
    \ doesn't work for all cases. For example, for the list [2, 1, 3, 1, 2], it returns\
    \ 3 instead of 2.\n<|/ c |>\n<| c |>\nYou are right! I didn't realize that it\
    \ is possible that min and max would have the same value. Thanks for pointing\
    \ that out!\n<|/ c |>\n<| a dscore=0 tags=c#,c++,algorithm |>\nThis can be easily\
    \ done with LINQ:\n<code>\nlong NextSmallest(long[] list)\n{\n    return list.Min();\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is not what he wants. He wants to return the\
    \ 2nd smallest item, not minimum. Also, your code is not C# and it's not going\
    \ to compile.\n<|/ c |>\n<| c |>\n: ", "{\n    forall i in lst | i <- lst if i\
    \ < 0 | i <- lst if i < 0\n    let min = lst |> Array.length |> List.head |> std.math.toInt\n\
    \    let rec loop(lst : long[]) =\n        match lst with\n        | [] -> null\n\
    \        | h :: t ->\n            if h < min then loop(t)\n            else h\n\
    \    loop (lst)\n}\n/*", "{\n   if(lst.size()==0)\n       return null;\n   var\
    \ min=lst[0];\n   var index=0;\n   foreach(l,lst){\n       if(l<min)\n       {\n\
    \           min=l;\n           index=i;\n       }\n   }\n   return lst[index+1];\n\
    }\n/*", "{\n\tvar min;\n\tif (lst.length == 0)\n\t\treturn null;\n\tmin = lst[0];\n\
    \tfor (var i = 1; i < lst.length; i++) \n\t{\n\t\tif (lst[i] < min) \n\t\t{\n\t\
    \t\tmin = lst[i];\n\t\t}\n\t}\n\treturn min;\n}", "{\n  if (lst.size == 0)\n \
    \   return null;\n  else\n    return std.math.top_n!(long, lst);\n}", "{\n   \
    \ var i;\n    var min=lst[0];\n    var k=1;\n    for (i=1; i < lst.length; ++i)\n\
    \    {\n        if (lst[i]<min) \n        {\n            min=lst[i];\n       \
    \     k=i;\n        }\n    }\n    if (k!=i)\n    {\n        return min;\n    }\n\
    \    else\n    {\n        return null;\n    }\n}", "{\n    if (lst.size <= 1)\n\
    \        return null;", "    long smallest = lst[1];\n    forall(lst, x -> x <=\
    \ smallest ? smallest = x : x < smallest)\n    smallest;\n{\n    if_else(null,\
    \ () => null, () => lst[1])\n}\n}", "{\n    for(Long i = 1; i < lst.lenght; ++i)\n\
    \        if(lst[i] < lst[i-1])\n            return lst[i-1];\n    \n    return\
    \ null;\n}\n\"\"\"\n# %%\n# Tests\n# Test function\ndef next_smallest(lst):\n\
    \    assert next_smallest(lst) == lst[1], \"next_smallest([1L, 2L, 3L, 4L, 5L])\
    \ ->\"\n    assert next_smallest(lst) == lst[1], \"next_smallest([5L, 1L, 4L,\
    \ 3L, 2L]) ->\"\n    assert next_smallest(lst) == None, \"next_smallest([1L, 1L])\
    \ ->\"\n    \ndef test_next_smallest():\n    assert next_smallest(lst) == lst[1],\
    \ \"test_next_smallest([1L, 2L, 3L, 4L, 5L]) ->\"\n    assert next_smallest(lst)\
    \ == lst[1], \"test_next_smallest([5L, 1L, 4L, 3L, 2L]) ->\"\n    assert next_smallest(lst)\
    \ == None, \"test_next_smallest([1L, 1L]) ->\"", "{\n\t\n\tif (lst == null ||\
    \ lst.length==0) {\n\t\treturn null;\n\t}\n\t\n\tvar minIndex = 0;\n\tvar minValue\
    \ = lst[minIndex];\n\t\n\tfor(var i = 0;i<lst.length;i++){\n\t\tif (lst[i] < minValue){\n\
    \t\t\tminValue = lst[i];\n\t\t\tminIndex = i;\n\t\t}\n\t}\n\treturn minValue;\n\
    }", "{\n    if (lst.length == 0)\n        return Nullable!(long);\n    else if\
    \ (lst.length == 1)\n        return Nullable!(long);\n    else\n    {\n      \
    \  var i = 1;\n        var current = lst[0];\n        while (i < lst.length &&\
    \ current < lst[i])\n        {\n            current = lst[i];\n            i++;\n\
    \        }\n        if (i < lst.length)\n            return Nullable!(long);\n\
    \        else\n            return Nullable!(lst[i]);\n    }\n}\n</code>\n<|/ a\
    \ dscore=3 |>\n<| a dscore=2 |>\nHere is an implementation without using recursion:\n\
    <code>\n bool next(int[] a, int currentIndex)\n    {\n        if (currentIndex\
    \ < a.Length)\n        {\n            while (currentIndex < a.Length && a[currentIndex]\
    \ < a[currentIndex + 1])\n            {\n                currentIndex++;\n   \
    \         }", "  ensures lst.length >= 2;\n  ensures lst.length > 0;\n  ensures\
    \ lst.length >= 2;\n  ensures lst.length > 0;\n  ensures lst.contains(0L);\n \
    \ ensures lst.contains(1L);\n  ensures lst.contains(2L);\n  ensures lst.contains(3L);\n\
    \  ensures lst.contains(4L);\n  ensures lst.contains(5L);\n  ensures lst.contains(0L);\n\
    \  ensures lst.contains(1L);\n  ensures lst.contains(2L);\n  ensures lst.contains(3L);\n\
    \  ensures lst.contains(4L);\n  ensures lst.contains(5L);", "{\n    var a = lst[length(lst)-1];\n\
    \    for(var i = 1; i < length(lst); i++){\n        if(lst[i] < a){\n        \
    \    a = lst[i];\n        }\n    }\n    return a;\n}", "{\n    int pos = 0;\n\
    \    if(lst.length < 2) return null;\n    while(pos < lst.length - 1) {\n    \
    \    int comp = compare(lst[pos], lst[pos + 1]);\n        if(comp == 0) {\n  \
    \          return lst[pos + 1];\n        } else if(comp < 0) {\n            pos++;\n\
    \        } else {\n            if(pos == 0) {\n                return null;\n\
    \            }\n            pos--;\n        }\n    }\n    return lst[pos];\n}",
  "{\n    long index = lst.indexOf(min(lst));\n    return index != -1 ? lst[index\
    \ + 1] : Nullable!();\n}", "{\n    if (lst.empty()) {\n        return Nullable!(long);\n\
    \    }", "{\n    if(!lst.length) return null;", "{\n    var smallest = lst[0];\n\
    \    var smaller = null;\n    for (var i=1; i<lst.length; i++) {\n        if (lst[i]\
    \ < smallest) {\n            smaller = smallest;\n            smallest = lst[i];\n\
    \        } else if (lst[i] == smallest) {\n            smallest = lst[i];\n  \
    \          smaller = lst[i-1];\n        }\n    }\n    return smaller;\n}\n</code>\n\
    <|/ a dscore=2 tags=scala |>\n<| a tags=scala |>\nHere's one possible implementation\
    \ (this implementation returns a Option[Long]; I assume your real question is\
    \ how to get the next smallest element of a collection):\n<code>\n  def nextSmallest(coll:\
    \ scala.collection.immutable.Iterable[Long]) = {\n    if (coll.isEmpty) None\n\
    \    else {\n      val nextSmallest = coll.min\n      if (coll.indexOf(nextSmallest)\
    \ != coll.lastIndexOf(nextSmallest)) Some(nextSmallest)\n      else nextSmallest\n\
    \    }\n  }\n</code>\nIt's basically the algorithm you were already trying to\
    \ implement, but refactored for ease of use in the case of an empty collection.\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nMy take on this one:\n<code>\ndef nextSmallest(coll:\
    \ Iterable[Long]): Option[Long] =\n  coll.foldRight(Long.MinValue)(_ < _) match\
    \ {\n    case (true, min) => Some(min)\n    case (false, max) => Some(max)\n \
    \ }\n</code>\nThe idea is to reduce to min value until you get to the first element\
    \ that is smaller than the current one. \nIn the case where all the elements are\
    \ already the min value, then the element is the one that you seek.\n<|/ a tags=scala\
    \ |>\n<| c |>\nThis answer is missing its educational explanation.\n<|/ c |>\n\
    <| c |>\nThanks Kiran, will do so.\n<|/ c |>\n<| a tags=scala |>\n<code>\ndef\
    \ nextSmallest(coll: Iterable[Long]): Option[Long] = {\n  val it = coll\n  val\
    \ smallest = it.next()\n  val smallestIndex: Int = it.indexOf(smallest)\n  if\
    \ (smallestIndex < 1) None\n  else {\n    it.drop(smallestIndex).find { it < smallest\
    \ }\n  }\n}\n</code>\nThis version returns the next smallest of the remaining\
    \ elements of the given collection while preserving order of the given collection.\
    \ The result of the method is an Option[Long].\n<|/ a dscore=1 |>\n<| c |>\nIf ",
  "{\n    int: i; \n    for (i = 1; i < lst.lenght; i++) {\n        if (lst[i-1] <\
    \ lst[i]) {\n            return lst[i];\n        }\n    }\n    return null;\n}",
  "    : lst == nil\n        => null\n    | (lst.length - 1)\n        => std.math.min(lst[2..lst.length])\n\
    \    | (lst.length)\n        => std.math.min(lst[2..lst.length])\n        => std.math.min(lst[2..lst.length]);",
  "{\n    var pos = lst.indexOf(lst[1]);\n    if(pos < 0)\n        throw(\"There isn't\
    \ such element in the array\");\n    else\n        return lst[pos + 2];\n}", "{\n\
    \    int smallest=lst[0];\n    for(int i=1;i<lst.length;i++)\n    {\n        int\
    \ current=lst[i];\n        if(std.math.isSmaller(smallest,current))\n        {\n\
    \            smallest=current;\n        }\n    }\n    return smallest;\n}", "{\n\
    \    if(lst.length < 2)\n        return null;\n    long minIndex = 0, minValue\
    \ = lst[0], index = 1;\n    while(index <= lst.length)\n    {\n        if(minValue\
    \ > lst[index])\n        {\n            minValue = lst[index];\n            minIndex\
    \ = index;\n        }\n        index++;\n    }\n    return lst[minIndex];\n}\n\
    </code>\n<|/ a dscore=2 tags=sorting,algorithm |>\n<| a dscore=2 tags=sorting,algorithm\
    \ |>\nI didn't know about any solution that doesn't require sorting - I thought\
    \ that since it was a sorting problem, I should have come up with some sort of\
    \ quicksort solution to it which I don't think I can find.\nI came up with a different\
    \ solution to my own sorting problem which does require sorting.  I've been using\
    \ the array as a tree to solve the problem.  I keep adding nodes to this tree\
    \ until it gets too deep and then I remove a leaf from the tree.\nThe time complexity\
    \ is O(nlog(n)) and it's guaranteed to be correct (that is, you'll get to the\
    \ right leaf on the first try).\nThe algorithm is pretty simple:\n<code>\npublic\
    \ static void main(String[] args) {\n    int[] arr = { 1, 3, 4 };\n    System.out.println(find2ndSmallest(arr));\n\
    }", "{\n\tfor(int i = 0; i < lst.length; i++) {\n\t\tif (lst[i] < lst[(i + 1)\
    \ % lst.length])\n\t\t\treturn lst[(i + 1) % lst.length];\n\t}\n\treturn null;\n\
    }", "{\n    var max=0;\n    for(var i=0;i<lst.len;i++)\n    {\n        if(lst[i]>max)\n\
    \        {\n            max=lst[i];\n        }\n    }\n    var min;\n    for(var\
    \ i=0;i<lst.len;i++)\n    {\n        if(lst[i]<max)\n        {\n            min=lst[i];\n\
    \            break;\n        }\n    }\n    if(min==null)\n    {\n        return\
    \ null;\n    }\n    else\n    {\n        return min;\n    }\n}", "{\n  var i =\
    \ 1;\n  while (i < lst.size)\n  {\n    if (lst[i] < lst[i-1])\n      return std.typecons.NIL;\n\
    \    else if (lst[i] < lst[i-2])\n      return lst[i-2];\n    i++;\n  }\n  return\
    \ null;\n}", "{\n\tvar i :=lst.Length-1;\n\tif(i<0)\n\t\treturn null;\n\treturn\
    \ lst[i+1];\n}\n//\nvar lst1 :=new long[10];\nlst1[1] :=1;\nlst1[2] :=2;\nlst1[3]\
    \ :=3;\nlst1[4] :=4;\nlst1[5] :=5;\nlst1[6] :=6;\nlst1[7] :=7;\nlst1[8] :=8;\n\
    lst1[9] :=9;\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smallest(lst1));\n\
    println(next_smallest(lst1));\nprintln(next_smallest(lst1));\nprintln(next_smalle",
  "    length(lst) >= 3 && \n        std.sort(lst) == lst &&\n        std.pop(lst)\
    \ == lst &&\n        std.pop(lst) == lst &&\n        std.pop(lst) == lst &&\n\
    \        std.pop(lst) == lst &&\n        std.pop(lst) == lst &&\n        std.pop(lst)\
    \ == lst &&\n        std.pop(lst) == lst &&\n        std.pop(lst) == lst &&\n\
    \        std.pop(lst) == lst &&\n        std.pop(lst) == lst &&\n        std.pop(lst)\
    \ == lst &&\n        std.pop(lst) == lst;\n    null;\nend", "{\n    forall i in\
    \ lst : i < 2L : i\n    \n    forall i in lst : i >= 2L : \n        i + 1 < 2L\
    \ : i\n    \n    forall i in lst : i <= 2L : \n        i > 2L : \n           \
    \ 2L : i", "{\n    var idx = lst.Length - 1;\n    if(idx >= 0)\n    {\n      \
    \  while(lst[idx] > lst[--idx])\n            if(idx == 0)\n                return\
    \ null;\n        return lst[idx];\n    }\n    return null;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThanks for the reply, but that doesn't look like C# syntax. The\
    \ syntax is unfamiliar to me. Can you please give me the equivalent C# syntax?\n\
    <|/ c |>\n<| a dscore=0 |>\nYou can use LINQ OrderByDescending() to get the top\
    \ element first, then the 2nd element and so on. For example:\n<code>\npublic\
    \ class Test {\n    public static void main(String[] args) {\n        int[] nums\
    \ = { 1, 3, 2, 3, 1, 2 };\n        long result = nums.OrderByDescending(n -> n).Skip(1).First();\n\
    \        System.out.println(result);\n    }\n}\n</code>\n<|/ a tags=algorithm,linq,c#\
    \ |>\n<| c |>\nHi, can you please explain what is the `n -> n` part and what does\
    \ `n -> n + 1` do here? Thanks\n<|/ c |>\n<| c |>\nIt's a lambda expression which\
    \ converts the `n` variable into a value using lambda expression. For more details,\
    \ you can check https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions\n\
    <|/ c |>\n<| a tags=algorithm,linq,c# |>\nTry this:\n<code>\nstatic class Program\n\
    {\n    static void Main(string[] args)\n    {\n        int[] ints = { 9, 10, 5,\
    \ 7, 4, 8, 6 };\n        Console.WriteLine(GetSecondSmallest(ints));\n       \
    \ Console.ReadLine();\n    }", "{\n    if (lst.Length == 0)\n        return null;\n\
    \    else if (lst.Length == 1)\n        return lst[0];\n    long[] arr = new long[lst.Length\
    \ - 1];\n    for (int i = 0; i < lst.Length; i++)\n    {\n        if (lst[i] <\
    \ arr[1])\n        {\n            arr[0] = lst[i];\n            arr[1] = lst[i];\n\
    \        }\n        else if (lst[i] == arr[1] && lst[i] < arr[2])\n        {\n\
    \            arr[1] = lst[i];\n        }\n    }\n    return arr[0]; \n}\n</code>\n\
    <|/ a tags=algorithm,arrays,c# |>\n<| a dscore=2 |>\nThe question isn't very clear,\
    \ but if you're trying to find the smallest element in a list with duplicate values\
    \ then this might help you:\n<code>\nvar uniqueElements = input.Distinct().ToArray();\n\
    var smallest = uniqueElements.Min();\n</code>\n<|/ a tags=algorithm,arrays,c#\
    \ |>\n<| c |>\nThat won't give you the element with the smallest index though.\
    \ You'd have to loop through the array and find the element that has the smallest\
    \ index. `O(n)`\n<|/ c |>\n<| c |>\nNo, `Distinct` returns an `IEnumerable<T>`,\
    \ which means that `.Min()` only needs to iterate through the entire sequence\
    \ once to find the minimum value.\n<|/ c |>\n<| c |>\nThat isn't necessarily the\
    \ case though; `Distinct` could be implemented as a sort of dictionary lookup\
    \ for example. Since you're using the `IEqualityComparer<T>` interface this will\
    \ be implemented by `IEqualityComparer<T>.Default` which, if the key has already\
    \ been encountered, does nothing. [link](http://msdn.microsoft.com/en-us/library/bb338049(v=vs.110).aspx)\n\
    <|/ c |>\n<| a dscore=1 |>\nIf your looking for speed, you can use the following:\n\
    <code>\npublic T FindSmallest<T>(T[] arr, int index)\n{\n    if (index < 0 ||\
    \ index >= arr.Length)\n    {\n        throw new IndexOutOfRangeException();\n\
    \    }", "    : null \n{\n    var result = null;\n    var len = lst.lenth;\n \
    \   var maxIndex = 0;\n    for(var i=0; i< len; i++)\n    {\n        if(lst[i]\
    \ > result[maxIndex])\n        {\n            maxIndex = i;\n            result\
    \ = lst[i];\n        }\n    }\n    return maxIndex == len ? result : result;\n\
    }", "    if_not(lst.is_empty){\n        \n        \n        let min = lst.iter().min()\
    \ + 1;\n        let index = lst.iter().index(min);\n        \n        if(index\
    \ == 0){\n            return null;\n        }\n        else{\n            return\
    \ lst[index];\n        }\n    }\n    else{\n        return null;\n    }\nend \n\
    '''", "{\n    \n    let mut smallest_el = lst[0];\n    let mut smallest_el_2 =\
    \ lst[0];\n    \n    for (i, el) in lst.iter().enumerate() {\n        if el <\
    \ smallest_el {\n            smallest_el = el;\n            smallest_el_2 = el;\n\
    \        }\n    }\n    \n    if smallest_el_2 == smallest_el {\n        return\
    \ smallest_el;\n    } else {\n        return null;\n    }\n}", "{\n    sort(lst);\n\
    \    if(lst.size() == 1)\n    {\n        return null;\n    }\n    \n    return\
    \ lst[1];\n}", "{\n    var i;\n    for(i=0; i<lst.length-1; i++) {\n        if(lst[i]\
    \ < lst[i+1]) return lst[i+1];\n    }\n    return null;\n}", "{\n    int i, j;\n\
    \    long min, min1;\n    if (lst.length == 1)\n        return null;\n    min\
    \ = lst[0];\n    min1 = lst[1];\n    for (i = 2; i< lst.length; ++i)\n    {\n\
    \        if (lst[i] < min)\n        {\n            min = lst[i];\n           \
    \ if (min1 == null)\n                return min;\n            min1 = lst[i-1];\n\
    \        }\n        else if (lst[i] < min1)\n            min1 = lst[i];\n    }\n\
    \    return min1;\n}", "{\n    var i = 0;\n    if (lst.Length != 0)\n    {\n \
    \       for (i = 1; i < lst.Length; i++)\n        {\n            if (lst[i] <\
    \ lst[i-1])\n            {\n                break;\n            }\n        }\n\
    \    }\n    return lst[i];\n}", "{\n    int i;\n    for(i = 0; i < lst.len; i+=2)\
    \ \n    {\n        if(lst[i] > lst[i+1])\n            return lst[i+1];\n    }\n\
    \    return null;\n}\n\"\"\"\n)", "{\n    if (lst.len==0)\n        return Nullable!(long);\n\
    \    return min(lst[1], lst[2]);\n}", "{\n    int? min2 = null;\n    foreach (long\
    \ i in lst) {\n        if(min2 == null || i > min2.value) {\n            min2\
    \ = i;\n        }\n    }\n    return min2;\n}\n/*", "{\n    var smallest:Option<long>;\n\
    \    var i:Long;\n    var j:Long;\n    var found:Boolean = false;\n    for (i\
    \ = 0, j = lst.length - 1; i <= j; i++, j--) {\n        smallest := lst[i];\n\
    \        if (smallest > lst[j]) {\n            break;\n        }\n        found\
    \ := true;\n    }\n    if found {\n        return smallest;\n    } else {\n  \
    \      return None;\n    }\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n\
    You could do something like this (assuming you haven't yet learned about Option):\n\
    <code>\nimport std.stdio;\nimport std.conv;\nimport std.algorithm; ", "{\n\tint\
    \ len = lst.len();\n\tif(len==0)\n\t\treturn Nullable!(long);\n\tif(len==1)\n\t\
    \treturn lst[0];\n\tArray!(long) res = lst.clone();\n\tsort(res, func(long i)\
    \ { return i; });\n\tif(res[1] == 0)\n\t\treturn null;\n\treturn res[1];\n}",
  "{\n    int: size = 0;\n    int: index = -1;\n    while(index < lst.size()) {\n\
    \        index += 1; \n        size+=1; \n    }\n    if (size > 0) {\n       \
    \ int smallest_index = index; \n        while(lst.at(smallest_index) >= lst.at(smallest_index\
    \ - 1)) \n        {\n            smallest_index -= 1;\n        }\n        return\
    \ lst.at(smallest_index + 1);\n    }\n    return null;\n}\n/* package */ function\
    \ next_smallest_in_array(long [] lst)\n{\n    return next_smallest(lst);\n}\n\
    /* package */ function next_smallest_in_array_v2(long [] lst)\n{\n    return next_smallest_in_array(lst);\n\
    }", "  if  (lst.length <= 0) \n    return null;\n  \n  if(lst.length == 1)\n \
    \   return lst[0];\n  \n  int j = 0;\n  long curr = lst[0];\n  int cnt = 0;\n\
    \  while(j < lst.length - 1 && curr < lst[j + 1])\n    {\n      j++;\n      curr++;\n\
    \      cnt++;\n    }\n  \n  if (cnt > 1)\n    return null;\n  \n  int idx = j\
    \ - 1;\n  if (idx == -1)\n    return null;\n  \n  long newCurr = lst[idx];\n \
    \ int newCnt = 1;\n  while(j > 0 && curr > newCurr)\n    {\n      j--;\n     \
    \ curr--;\n      newCnt++;\n    }\n  \n  newCurr = lst[idx];\n  newCnt = 1;\n\
    \  while(j + 1 < lst.length && curr < newCurr)\n    {\n      j++;\n      curr++;\n\
    \      newCnt++;\n    }\n  \n  return newCnt > 1 ? newCurr : null;\nend ;", "{\n\
    \    let n = lst.Length;\n    if(n==0)\n        return Nullable!(long);\n    else\
    \ if(n==1)\n        return Nullable!(long)(lst[0]);\n    let min2 = std.arrayindex.min(lst);\n\
    \    for(let i=0;i<n;i++)\n        if(lst[i]==min2)\n            break;\n    return\
    \ Nullable!(long)(lst[i+1]);\n}\nfunction main() \n{\n    let result = next_smallest([0L,\
    \ 2L, 3L, 4L, 5L, 1L]);\n    println!(\"result = {:?}\", result);\n}\n</code>\n\
    <|/ a tags=c#,arrays,sorting,algorithm,indexing dscore=1 |>\n<| a |>\nI believe\
    \ it's possible to write a binary search that returns null if there is no 2nd\
    \ smallest element in the array. It would be quite difficult to explain how to\
    \ implement it in a way that would be easy to understand, but here's a possible\
    \ implementation, with comments to help you see how it works:\n<code>\npublic\
    \ class BinarySearch\n{\n    private int[] _array;\n    private int _lowerBound,\
    \ _upperBound;", "    when is_list(lst) \n{\n    int l = get_array_length(lst);\n\
    \    if (l <= 0)\n        return null;\n    int x = lst[0];\n    int i = 1;\n\
    \    while (i <= l)\n    {\n        if (lst[i] < x)\n        {\n            x\
    \ = lst[i];\n            i = 1;\n        }\n        else\n        {\n        \
    \    i += 1;\n        }\n    }\n    return x;\n}", "    requires lst.size > 0;\n\
    \    local index = 2;\n    local curr = lst[1];\n    while (index < lst.size)\
    \ and \n        (curr == lst[index] || curr < lst[index])\n    do\n        index\
    \ = index + 1;\n        curr = lst[index];\n    end;\n    if index < lst.size\
    \ then\n        return curr\n    else\n        return null;\n    end;\nend;\n\
    </cell>\n<code language=julia-1.5>\nnext_smallest([1L, 2L, 3L, 4L, 5L])\n</cell>\n\
    <code language=julia-1.5>\nnext_smallest([5L, 1L, 4L, 3L, 2L])\n</cell>\n<code\
    \ language=julia-1.5>\nnext_smallest([])\n</cell>\n<code language=julia-1.5>\n\
    next_smallest([1L, 1L])\n</cell>\n<text>\nProblem 2b\nWrite a function next_biggest()\
    \ that returns the 2nd biggest element of the array.\nReturn null if there is\
    \ no such element.\n>>> next_biggest([1L, 2L, 3L, 4L, 5L])\n2L\n>>> next_biggest([5L,\
    \ 1L, 4L, 3L, 2L])\n2L\n>>> next_biggest([])\nNone\n>>> next_biggest([1L, 1L])\n\
    None\n>>> next_biggest([3L, 2L, 1L])\n2L", "{\n    int: idx = 0;\n    while idx\
    \ < lst.size() && lst[idx] < lst[idx + 1]) \n        idx += 1;\n    if (idx <\
    \ lst.size()) return lst[idx];\n    else return null;\n}", "    requires lst.length>0;\n\
    \    requires lst.min() >= 0;\n    requires lst.len() >= 1;\n    var min_val =\
    \ lst.min();\n    var min_index = lst.indexOf(min_val);\n    var min_val_2 = std.min_by(lst,\
    \ std.fun(std.fun(std.int_, min_index), std.fun(std.int_, lst.index)));\n    return\
    \ min_val_2;\nend", "{\n    var min = lst.min(2);\n    var result = lst.find(x\
    \ => x == min[1]);\n    if (result == 0) {\n        return null;\n    } else {\n\
    \        return min[1];\n    }\n}\n/*", "{\n    foreach (i, e) lst \n        =>\
    \ if (i < 2) return e;\n    return null;\n}\nfunction next_smallest2(long[] lst)\
    \ {\n    var i = 0;\n    var result = null;\n    foreach (e) lst\n        => if\
    \ (i < 2) {\n            result = e;\n            i++;\n            return;\n\
    \        }\n}\n</code>\nThe only problem is it's in F#, so you'd need to write\
    \ it in F# syntax to get it working.  It doesn't look as simple as a C# one, and\
    \ doesn't take advantage of the fact that arrays are passed by reference, so you'll\
    \ need to re-write the entire function in F# syntax if you want it to be performant.\n\
    <|/ a dscore=1 tags=null,c#,f# |>\n<| c |>\nC# doesn't have pass-by-reference,\
    \ only pass-by-value http://stackoverflow.com/questions/539098/c-sharp-pass-by-reference\n\
    <|/ c |>\n<| c |>\nSorry, I forgot the C# tag.  I meant to put C#, but I changed\
    \ it after seeing the C# code.  I'll fix it.\n<|/ c |>\n<| a tags=null,c#,f# dscore=1\
    \ |>\nYour approach is essentially correct, but you can make the code simpler\
    \ by using a \"null coalescing\" operator:\n<code>\nlet next_smallest xs =\n \
    \   xs |> Seq.filter (fun x -> x < 3) |> Seq.tryHead |> Option.defaultValue null\n\
    </code>\nThat is, if there isn't a head, then you can use a \"default\" value\
    \ rather than null.\n<|/ a |>\n<| a tags=null,c#,f# |>\nF# has a nice way to do\
    \ this which avoids the null pointer exception. Here is what you want:\n<code>\n\
    open System", "{\n   let smallest_idx = 0;\n   let smallest = lst[smallest_idx];\n\
    \   let second_smallest = smallest;\n   for (let i = 1; i < lst.length; ++i)\n\
    \   {\n      let val = lst[i];\n      if (val < second_smallest)\n      {\n  \
    \       second_smallest = val;\n         smallest_idx = i;\n      }\n   }\n  \
    \ return smallest_idx == lst.length - 1? null: lst[smallest_idx + 1]; \n}", "{\n\
    \    int count = 0;\n    foreach(long x, lst){\n        if(x == count + 1) return\
    \ x;\n        if(x < count + 1) count += 1;\n    }\n    return null;\n}", "{\n\
    \    if (lst.is_empty) {\n        return null;\n    }\n    long smallest = lst[0];\n\
    \    for (int i = 1; i < lst.length; ++i) {\n        if (lst[i] < smallest) {\n\
    \            smallest = lst[i];\n        }\n    }\n    return smallest;\n}", "{\n\
    \    for(long i:lst)\n        if(i<lst[1]) return i;\n    for(long i:lst)\n  \
    \      if(i>lst[1]) return null;\n    return lst[1];\n}", "{\n    var ls = lst.length();\n\
    \    if(ls > 0) {\n        long l = std.array.toLong(lst);\n        while(l <\
    \ ls - 2) {\n            l++;\n        }\n        if(l == ls - 2) {\n        \
    \    return null;\n        } else {\n            return lst.array[l - 1];\n  \
    \      }\n    } else {\n        return null;\n    }\n}", "{\n   \n    for(let\
    \ i = 0; i < lst.length; i += 1) {\n        if(lst[i] < lst[(i + 1) % lst.length])\
    \ {\n            return lst[(i + 1) % lst.length];\n        }\n    }\n    return\
    \ null;\n}\n/*", "{\n    long min = lst[0];\n    long max = lst[std.array.length(lst)-1];\n\
    \    for(long i=1; i<std.array.length(lst); ++i) {\n        if(min > lst[i]) {\n\
    \            min = lst[i];\n        }\n        if(max < lst[i]) {\n          \
    \  max = lst[i];\n        }\n    }\n    return max == min ? null : max;\n}", "{\n\
    \    int: index = 0;\n    while (index < lst.size && lst[index] != null) \n  \
    \  {\n        if (lst[index] < lst[index + 1]) \n        {\n            return\
    \ lst[index + 1];\n        }\n        index++;\n    }\n    return null;\n}", "{\n\
    \    if(lst.size==0) return Nullable!(long)null;\n    var min = lst[0];\n    var\
    \ min_index = 1;\n    for(var i=1; i<lst.size; i++)\n    {\n        if(min > lst[i])\n\
    \        {\n            min = lst[i];\n            min_index = i;\n        }\n\
    \    }\n    return Nullable!(long)min;\n}", "{\n   Nullable!(long) result = 0;\n\
    \   Nullable!(long) minLst = lst[0];\n   bool isMin = true;\n   for(long i : lst)\
    \ \n   {\n      if(isMin) \n      {\n         if(minLst > i) \n         {\n  \
    \          minLst = i;\n            result = i;\n         }\n      }\n      else\
    \ \n      {\n         if(minLst < i) \n         {\n            minLst = i;\n \
    \           result = i;\n         }\n      }\n      isMin = !isMin;\n   }\n  \
    \ return result;\n}\n</code>\n<|/ a tags=c#,algorithm,data-structures,c++ |>\n\
    <| a |>\nIn Java, I think I would probably do something like this:\n<code>\npublic\
    \ static <T> T smallestElement(T[] array) {\n    if (array == null || array.length\
    \ <= 0)\n        return null;", "{\n    if(lst.size==0)\n        return null;\n\
    \    else \n        return min(lst);\n}", "  if\n    null lst\n  then\n    None\n\
    \  else\n    let int i = 1;\n    let int j = length(lst);\n    let long smallest\
    \ = lst[j-1];\n    let long largest = lst[0];\n    while(i <= j) \n    when\n\
    \      \n      lst[i] < smallest then\n        smallest = lst[i]\n      \n   \
    \   lst[i] > largest then\n        largest = lst[i]\n      \n      else \n   \
    \     i := i+1\n        j := j-1\n    \n  finally\n    smallest\n  ;", "{\n\t\
    if (lst.len == 0)\n\t\treturn null;\n\treturn lst[lst.len/2];\n}", "    : ListsOrderedByFirstItem{\
    \ lst },\n        list.length == 2L ? list[1] : Nullable!(none);\n        \n/*",
  "    where lst : array<int>;\n    ", "    if (lst.length <= 1) return null;\n  \
    \  var smallest = lst[0]; \n    var pos;\n    for (pos=1; pos<lst.length; pos++)\n\
    \        if (lst[pos] < smallest) \n            smallest = lst[pos];\n    return\
    \ smallest;\n\"\"\"\n_next_smallest = _next_smallest_impl()\nnext_smallest = _next_smallest",
  "{\n   var len = lst.lenght;\n   if(len < 2)\n      return null;\n   var small =\
    \ lst[0];\n   for(var i = 0; i < len; i++)\n   {\n      if(lst[i] < small)\n \
    \     {\n         small = lst[i];\n      }\n   }\n   return small;\n}\nfunction\
    \ main()\n{\n   var a = [1L, 2L, 3L, 4L, 5L];\n   print(\"a=[1L, 2L, 3L, 4L, 5L]\"\
    );\n   println(a);\n   print(\"next_smallest(a)=\" + next_smallest(a));\n   println();\n\
    \   var b = [1];\n   print(\"b=[1L]\");\n   print(b);\n   print(\"next_smallest(b)=\"\
    \ + next_smallest(b));\n}\n</code>\n<|/ a |>\n<| c |>\nPlease don't just post\
    \ the link to an answer, explain what your answer is.\n<|/ c |>\n<| c |>\nI wrote\
    \ the code from the link provided by my own question. I would appreciate if you\
    \ could help me to realize this question. I'm still a beginner in the programming\
    \ world\n<|/ c |>\n<| c |>\nPlease read the link I provided. It's all explained\
    \ there. Also, you have done no work of your own and are asking us to do it all\
    \ for you. If you'd taken the time to read the links I provided, you'd have seen\
    \ that they explain the code you need. So, you have written your code, you understand\
    \ the code, you know how to call it from Java, you know how to call it from C,\
    \ you know how to call it from C#, you know how to call it from C# (.NET), you\
    \ know how to call it from Ruby, you know how to call it from PHP, you know how\
    \ to call it from C++, you know how to call it from Python, you know how to call\
    \ it from Perl, you know how to call it from PHP, you know how to call it from\
    \ C++, you know how to call it from C#, you know how to call it from Java, you\
    \ know how to call it from PHP, you know how to call it from C#, you know how\
    \ to call it from VB6, you know how to call it from C#, you know how to call it\
    \ from Python, you know how to call it from C#, you know how to call it from PHP,\
    \ you know how to call it from C++, you know how to call it from C#, you know\
    \ how to call it from Perl, you know how to call it from Ruby, you know how to\
    \ call it from Java, you know how to call it from Ruby, you know how to call it\
    \ from C#, you know how to call it from Java, you know how to call it from C#,\
    \ you know how to call it from Perl, you know how to call it from PHP, you know\
    \ how to call it from C#, you know how to call it from Ruby, you know how to call\
    \ it from C#, you know how to call it from Ruby, you know how to call it from\
    \ C#, you know how to call it from C#, you know how to call it from C#", "{\n\
    \    var i = 0;\n    var j = 0;\n    var size = length(lst);\n    var min = lst[0];\n\
    \    while(j < size && lst[j] < min) {\n        ++j;\n    }\n    if(j == size)\
    \ {\n        return null;\n    }\n    while(j < size) {\n        var cur = lst[j];\n\
    \        if(cur == min) {\n            break;\n        }\n        ++j;\n    }\n\
    \    return lst[j];\n}\n</code>\n<|/ a |>\n<| a tags=sorting,algorithm,arrays,scala\
    \ dscore=0 |>\n<code>\ndef nextSmallest(l: List[Int]): Option[Int] = {\n  if(l.isEmpty)\
    \ None\n  else if(l.length == 1) Some(l(0))\n  else {\n    var min1 = l(0)\n \
    \   var min2 = l(0)\n    for (i <- 1 until l.length) {\n      if(l(i) > min1)\
    \ {\n        min1 = l(i)\n      } else if (l(i) < min1) {\n        min2 = min1\n\
    \        min1 = l(i)\n      }\n    }\n    if(min1 != min2) Some(min2)\n    else\
    \ None\n  }\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\ndef nextSmallest(xs: List[Int]):\
    \ Option[Int] = {\n    if (xs.isEmpty) None\n    else if (!xs.isEmpty) xs(1)\n\
    \    else {\n      val min = xs.min()\n      if (xs.filter(x => x < min).length\
    \ == 0) None\n      else Some(min)\n    }\n  }\n</code>\n<|/ a tags=sorting,algorithm,arrays,scala\
    \ dscore=0 |>\n<| c |>\nIt would be helpful to explain what the code is doing\
    \ here.\n<|/ c |>\n<| c |>\nJust a reminder that answers without an explanation\
    \ are not useful in anyway.\n<|/ c |>\n<| a dscore=0 tags=sorting,algorithm,arrays,scala\
    \ |>\n<code>\ndef nextSmallest(xs: List[Int]): Option[Int] = {\n    (xs match\
    \ {\n      case Nil => None\n      case y :: ys => {\n        val min = ys.min\n\
    \        val result = ys.dropWhile(x => x < min).headOption\n        if (result.isEmpty)\
    \ None\n        else Some(min)\n      }\n    })\n  }\n</code>\n<|/ a |>\n<| c\
    \ |>\nWhile this code snippet may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that ", "{\n    int\
    \ low = 0, high = lst.length-1;\n    while(low <= high)\n    {\n        int mid\
    \ = (low + high) / 2;\n        if(lst[mid] < lst[low])\n            low = mid\
    \ + 1;\n        else\n            high = mid - 1;\n    }\n    if(low > 0)\n  \
    \      return lst[low];\n    else\n        return null;\n}\n/*", "{\n    if(lst.size\
    \ == 1)\n        null;\n    else\n    {\n        var maxIndex = 0;\n        var\
    \ maxValue = lst[0];\n        for(var i = 1; i < lst.size; i++)\n        {\n \
    \           if(lst[i] > maxValue)\n            {\n                maxIndex = i;\n\
    \                maxValue = lst[i];\n            }\n        }\n        return\
    \ maxIndex;\n    }\n}\n//test", "\t: lst[0] <= lst[1] ? lst[1] : lst[0] <= lst[2]\
    \ ? lst[1] : lst[0] <= lst[3] ? lst[1] : lst[0] <= lst[4] ? lst[1] : lst[0] <=\
    \ lst[5] ? lst[1] : lst[0] <= lst[6] ? lst[1] : lst[0] <= lst[7] ? lst[1] : null;",
  "{\n    int length = length(lst);\n    if (length > 0) {\n        long smallest\
    \ = lst[length-1];\n        for(int i = length-2; i >= 0; --i) {\n           \
    \ if (lst[i] < smallest) {\n                smallest = lst[i];\n            }\n\
    \        }\n        return smallest;\n    }\n    return null;\n}\n/*", "{\n  \
    \  int i;\n    int min = 0;\n    for(i = 1; i < lst.Length; i++) {\n        if(lst[i]\
    \ < lst[min]) {\n            min = i;\n        }\n    }\n    return lst[min];\n\
    }\n/*", "{\n    int? low = findmin(lst);\n    if (low == null || lst.size() ==\
    \ 0) {\n        return Nullable!(long);\n    }", "{\n    if (lst.is_empty())\n\
    \        return null;\n    long result = lst[1];\n    for (short i = 2; i < lst.size;\
    \ ++i)\n        if (lst[i] < result)\n        {\n            result = lst[i];\n\
    \        }\n    return result;\n}", "{\n\tvar i, k;\n\tk = std.array.length(lst)\
    \ - 1;\n\tfor (i = k; i > 0; --i) {\n\t\tif (std.array.get_loc(lst[i-1]) < std.array.get_loc(lst[i]))\
    \ {\n\t\t\tk = i;\n\t\t}\n\t}\n\treturn std.array.get_loc(lst[k]);\n}\n</cell>\n\
    <code language=dyalog-kernel>\nstd.array.next_smallest([1L, 2L, 3L, 4L, 5L])\n\
    </cell>\n<text>\nThe second smallest element of a list can also be found with\
    \ the third smallest, and so on.", "  : lst.size() > 0 ? \n    lst.min(std.functional._2nd_min)\
    \ \n  : null;\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is a simple solution:\n\
    <code>\n//Find two smallest numbers", "{\n    int nL = lst.Length;\n    int minIdx\
    \ = 0;\n    Nullable<long> minVal = Nullable<long>.Create(lst[0]);\n    for(int\
    \ n = 0; n < nL; n++) {\n        if(minVal.Value > lst[n]) {\n            minVal\
    \ = Nullable<long>.Create(lst[n]);\n            minIdx = n;\n        }\n    }\n\
    \    if(minIdx != nL-1) {\n        minVal = Nullable<long>.Create(lst[nL]);\n\
    \        minIdx = nL;\n    }\n    return minVal;\n}", "{\n\tif (lst.isEmpty) \n\
    \t\treturn Nullable!(long);", "{\n    for(i in 0...lst.length-1){\n        if(lst[i]<lst[i+1])\n\
    \        {\n            return lst[i+1];\n        }\n    }\n    return null;\n\
    }\n/*", "    : lst[1] = next_smallest(lst[1]);\n    \n//@test next_smallest([1L,\
    \ 2L, 3L, 4L, 5L]).value == 2L;\n//@test next_smallest([5L, 1L, 4L, 3L, 2L]).value\
    \ == 2L;\n//@test next_smallest([]).value == null;\n//@test next_smallest([1L,\
    \ 1L]).value == null;\n    \n/*", "  : ArrayBase[long] =\n    lst.sort;\n    if\
    \ (lst.size == 0)\n      Null\n    else\n      Nullable[lst[lst.size - 2]]\n</code>\n\
    <|/ a tags=ocaml,sorting dscore=1 |>\n<| a |>\nIf your input is sorted you can\
    \ use Array.mapi with an identity function as the accumulator to find the element\
    \ you're interested in.\nIf your input is not sorted, then you either need to\
    \ find an algorithm that can do binary search, or implement the binary search\
    \ algorithm yourself (by starting at the middle and moving either left or right\
    \ as you go). As the last step you'll either reach a place in the array that is\
    \ bigger than your input (which means you can return the element at that index),\
    \ or you will have found your element (which means you either move to the left\
    \ or to the right). Once you reach a place that is too big, you should stop.\n\
    <|/ a tags=ocaml,sorting dscore=0 |>\n<| c |>\nYour first solution doesn't work\
    \ if the input is `[1,2,3]`\n<|/ c |>\n<| c |>\nI assumed it was already sorted.\
    \ If you don't know if the input is sorted, then you'll have to find another algorithm.\n\
    <|/ c |>\n<| c |>\nAs the OP said, the inputs are already sorted. Maybe the question\
    \ doesn't make sense.\n<|/ c |>\n<| c |>\nThe OP said the input is already sorted,\
    \ but the question asked how to find the second smallest element. You're answer\
    \ is correct, but misleading in a different way.\n<|/ c |>\n<| c |>\nWell, the\
    \ OP specifically stated that he wants the second smallest element. So yes, the\
    \ input is already sorted. I was just trying to explain my point.\n<|/ c |>\n\
    <| a tags=ocaml,sorting dscore=0 |>\nA simple approach is to search the middle\
    \ of the array and see if it's the second-largest number in the middle. Then,\
    \ move the array to the left or to the right one step, so you can repeat the search\
    \ from where you are:\n<code>\nlet second_largest () =\n  let rec second_largest\
    \ acc =\n    match acc with \n    | x when x > largest -> x \n    | _ -> second_largest\
    \ acc (x + 1) in\n  second_largest 0 1 ", "    :: int -> bool\nnext_smallest(_,Nullable!(int))\
    \ = Nullable!(int) -> bool\nnext_smallest(x,Nullable!(int)) = \n    if x <= lst[1]\
    \ then\n        Nullable!(int) lst[2] <= x\n    else\n        Nullable!(int) null\
    \ = lst[2] <= x\n    endif\n;\nproc next_smallest([x],Nullable!(int)) = Nullable!(int)\
    \ -> bool\nnext_smallest([x],Nullable!(int)) = \n    if x <= lst[1] then\n   \
    \     Nullable!(int) lst[2] <= x\n    else\n        Nullable!(int) null = lst[2]\
    \ <= x\n    endif\n;\n</code>\nThe proc next_smallest is just a helper function\
    \ that takes the list and the index of the next element. \nThe Nullable!() type\
    \ is a wrapper that can return null if the index doesn't exist and the value is\
    \ left as is. This wrapper doesn't require to import the Nullable library.\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis is also a great answer, so +1. Although you do\
    \ have a bug in the definition of `next_smallest`. The `lst[2]` access is unnecessary\
    \ and should be removed.\n<|/ c |>\n<| c |>\nYou are right, I removed the unnecessary\
    \ accesses.\n<|/ c |>\n<| a tags=ocaml dscore=2 |>\nHere's a way that does not\
    \ require an external library, but uses only OCaml built-in features (which should\
    \ be more efficient, and may be simpler):\n<code>\nlet smallest_of_list l =\n\
    \    let i = ref 0 in\n    let rec loop lst i = function\n        | [] -> null\n\
    \        | hd::tl ->\n            if lst.(fst lst) < (lst.(fst tl)) then loop\
    \ (hd::tl) (i+1)\n            else loop (hd::tl) (if i > 0 then i else (i+1))\
    \ in\n    loop l 0\n;;", "{\n    if(lst.length == 0)\n        return null;\n \
    \   return lst[lst.length - 2];\n}", "{\n    if (lst.len > 1)\n    {\n       \
    \ Nullable!(long) smallest = min(lst);\n        Nullable!(long) smallest2 = min(lst[lst.index(smallest):]);\n\
    \        return smallest2;\n    }\n    return null;\n}\n</code>\n<|/ a tags=c#,algorithm,scala\
    \ |>\n<| c |>\n`lst.takeWhile(l=>l<lst[lst.index(l)]).find(l=>l<lst[lst.index(l)]).map(l=>lst[lst.index(l)]).max`\
    \ I like it. Still a lot of code for something that should be pretty simple.\n\
    <|/ c |>\n<| c |>\n: I doubt this will be the fastest, but I like the functional\
    \ approach and it will also allow you to find the 2nd smallest\n<|/ c |>\n<| c\
    \ |>\n: I just wanted to make it as close to the original as possible. I added\
    \ another version, which is much shorter and probably faster. I did not try it,\
    \ but I suppose it works.\n<|/ c |>\n<| a dscore=2 |>\nIn Scala, this would be\
    \ a one-line anonymous function definition:\n<code>\nval doubles = List(0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9)\ndoubles.minBy{a => math.max(math.max(a*2,0), math.min(a*2,9))}\n\
    </code>\nIf you want the 2nd smallest element:\n<code>\ndoubles.minBy{a => math.max(math.max(a*2,0),\
    \ math.min(a*2,9))}(2)\n</code>\nIn C# it would look something like this:\n<code>\n\
    var doubles = new[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\nvar result = doubles.MinBy(a\
    \ => Math.Max(Math.Max(a * 2, 0), Math.Min(a * 2, 9)));\n</code>\n<|/ a tags=c#,algorithm,scala\
    \ |>\n<| c |>\nThis solution doesn't find smallest element by itself.\n<|/ c |>\n\
    <| c |>\nI thought OP wanted 2nd smallest element. If not, then I guess I misunderstood\
    \ the question\n<|/ c |>\n<| a dscore=2 |>\n<code>\nvar array = new int[] { 1,\
    \ 2, 3, 4 };", "{\n    var smallest = lst[0];\n    var next_smallest = lst[1];\n\
    \    var i = 1;\n    while (i < lst.length)\n    {\n        if (smallest > lst[i])\n\
    \        {\n            next_smallest = lst[i];\n            smallest = lst[i];\n\
    \        }\n        else\n        {\n            smallest = next_smallest;\n \
    \       }\n        i++;\n    }\n    return smallest;\n}", "{\n\tlet i = 0;\n\t\
    let len = lst.length;\n\tlet curr = lst[i];\n\tlet prev_curr;\n\t\n\tif (len ==\
    \ 0) return null;\n\t\n\tfor (i; i < len; i = i + 1)\n\t{\n\t\tprev_curr = lst[i];\n\
    \t\tif (curr < prev_curr)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (i == len)\
    \ \n\t{\n\t\treturn null;\n\t}\n\t\n\treturn lst[i+1];\n}", "{\n    for(var i\
    \ = 0, n = lst.size(); i < n; i++)\n    {\n        if(i + 1 < n)\n        {\n\
    \            if(lst[i] < lst[i + 1])\n            {\n                return std.min(std.copy(lst[i:\
    \ i + 2]), lst[i]);\n            }\n        }\n        else\n        {\n     \
    \       return null;\n        }\n    }\n}\n</code>\n<|/ a dscore=1 tags=c++,linked-list,nullable\
    \ |>\n<| a tags=c++,linked-list,nullable |>\nIf you have access to boost you can\
    \ use boost::optional and boost::optional is a wrapper to nullable objects in\
    \ C++\nIn that case you could do:\n<code>\nboost::optional<int> next_smallest\
    \ (int arr[], size_t n)\n{\n    // return boost::none if we couldn't find the\
    \ 2nd smallest\n    return arr[0] < arr[1] ? boost::none : boost::make_optional(arr[1]);\n\
    }\n</code>\nNote that this will be a lot more efficient than iterating through\
    \ the entire list if the array is sorted.\n<|/ a dscore=0 |>\n<| c |>\nUnfortunately\
    \ I do not. I can however use the standard library. I will update my question\
    \ to reflect this.\n<|/ c |>\n<| c |>\nOk then sorry I missed that part but will\
    \ leave it for someone else to answer.\n<|/ c |>\n<| a tags=c++,linked-list,nullable\
    \ dscore=0 |>\nThe \"nullable reference\" pattern is just a wrapper for null pointers,\
    \ which is a completely different thing from having a null pointer. Since \"pointer-to-pointer\"\
    \ also exists in C++, all you need is a pointer-to-pointer to achieve the desired\
    \ result.\n<code>\ntemplate<typename T>\nclass NulableReference {\n    typedef\
    \ T *ptype;\n    T *ptr;\npublic:\n    NulableReference(T *ptr) : ptr(ptr) {}\n\
    \    NulableReference(const NulableReference<T> &ref) : ptr(ref.ptr) {}\n    operator\
    \ T *() { return ptr; }\n};\n</code>\n<|/ a |>\n<| a tags=c++,linked-list,nullable\
    \ dscore=0 |>\nWhat about something like that:\n<code>\ntemplate<typename T>\n\
    class NulableReference {\n    typedef T *ptype;\n    T *ptr;\npublic:\n    NulableReference(T\
    \ *ptr) : ptr(ptr) {}\n    NulableReference(const NulableReference<T> &ref) :\
    \ ptr(ref.ptr) {}\n    operator T *() { return ptr; }\n};", "{\n    var smallest\
    \ = lst[0];\n    var smallestIndex = std.math.indexOf_long(smallest);\n    if\
    \ (smallestIndex == 0) return null; // empty list\n    return std.typecons.nth_smallest(std.math.sublist_sum(lst,\
    \ smallestIndex + 1));\n}", "    : lst.len() == 0 || lst.len() == 1 ? Nullable!(long)\
    \ : if (lst[0] > lst[1])\n         lst.shift()\n        else\n         lst.shift()\n\
    \    else next_smallest(lst)\n;", "  : lst && lst.size > 0 ? std.array.get(lst,\
    \ 1) : Nullable!(null)\n{\n  if(lst.size > 0){\n    return std.array.get(lst,\
    \ 1);\n  } else {\n    return Nullable!(null);\n  }\n}\n/*", "{\n  for(var i=0;\
    \ i< lst.length; ++i)\n    if (lst[i] < lst[i +1] ) return lst[i];\n  return null;\n\
    }", "    : Nullable!(long) =\n    if (lst.len() == 0) then\n        null;\n  \
    \  else \n        let x = lst[0];\n        let y = lst[1];\n        let z = lst[2];\n\
    \        if (x != null && y != null && z != null) then\n            if (x < y)\
    \ then\n                next_smallest(std.array.drop(lst,1));\n            else\n\
    \                next_smallest(std.array.drop(lst,2));\n        else\n       \
    \     null;\n        \n    endif;\n        \n        \n/*"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
