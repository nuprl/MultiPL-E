name: HumanEval_162_string_to_md5
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given a string 'text',\
  \ return its md5 hash equivalent string.\n    If 'text' is an empty string, return\
  \ null.\n\n    >>> string_to_md5(\"Hello world\")\n    \"3e25960a79dbc69b674cd4ec67a72c62\"\
  \n    \n*/\nNullable!(string) string_to_md5(string text) \n"
tests: "unittest\n{\n    alias candidate = string_to_md5;\n\n{\n        auto result\
  \ = candidate(\"Hello world\");\n        assert(!result.isNull && result.get ==\
  \ \"3e25960a79dbc69b674cd4ec67a72c62\");\n}\n\n{\n        auto result = candidate(\"\
  \");\n        assert(result.isNull);\n}\n\n{\n        auto result = candidate(\"\
  A B C\");\n        assert(!result.isNull && result.get == \"0ef78513b0cb8cef12743f5aeb35f888\"\
  );\n}\n\n{\n        auto result = candidate(\"password\");\n        assert(!result.isNull\
  \ && result.get == \"5f4dcc3b5aa765d61d8327deb882cf99\");\n}\n\n}\nvoid main(){}"
completions: ["{\n    if (text.length == 0) {\n        return null;\n    }\n    string\
    \ md5sum = MD5_Hash(text.toUtf8String());\n    return md5sum;\n}", "{\n    char[]\
    \ text = text.toCharArray();\n    if(text.length == 0)\n        return Null!(\"\
    null\");\n    int len = text.length;\n    for(int i = 0; i < len; i++) {\n   \
    \     int c = (int)text[i];\n        if(c > 255)\n            throw new RuntimeException(\"\
    Invalid char (\" + c + \") in md5 of \" + text + \" at index \" + i);\n    }\n\
    \    MD5 md5 = new MD5();\n    md5.update(text, 0, len);\n    byte[] digest =\
    \ md5.digest();\n    char[] result = new char[digest.length * 2];\n    for(int\
    \ i = 0; i < digest.length; i++) {\n        byte b = digest[i];\n        result[i\
    \ * 2] = (int)((b >> 4) + 0x0);\n        result[i * 2 + 1] = (int)((b & 0xf) +\
    \ 0x8);\n    }\n    return String!(char[]) result;\n}\n/*", "{\n    int len =\
    \ text.length();\n    Nullable!(int)MD5::digest(text.asBytes(), len);\n    return\
    \ text.asBytes();\n}", "{\n    Nullable!(string) md5 = null;\n    \n    if (text\
    \ != null && text != \"\")\n    {\n        md5 = md5(text);\n    }\n    \n   \
    \ return md5;\n}", "{\n    if (text.len() == 0) return Nullable!(\"null\");\n\
    \    else return \"\\\"$text\\\"\";\n}\n</code>\nThe full version of the file\
    \ can be found here.\n<|/ a dscore=3 |>\n<| c |>\nIt would be cool if you could\
    \ share the resulting code as an example here: http://std.github.io/#md5\n<|/\
    \ c |>\n<| a tags=hash,md5,haskell,string |>\nSince I still see this question\
    \ getting lots of views I thought I'd contribute a solution I came up with. I\
    \ was working on a project that needed to create a md5 hash function using Haskell\
    \ but then I needed to find a way to ensure that the Haskell code didn't interfere\
    \ with my PHP code. I also wanted to make sure that I didn't run afoul of any\
    \ existing md5 implementations on the platform so I started looking for libraries.\n\
    I found a library that does exactly what I wanted and was relatively easy to work\
    \ with:\n<code>\n{-# LANGUAGE OverloadedStrings #-}", "{\n    if (text.isNullOrEmpty())\n\
    \        return null;\n    else \n        return hex.stringToHex(std.crypto.md5(text));\
    \ \n}", "{\n    if (text == \"\") return null;\n    var h = md5(text.encode());\n\
    \    return h.substring(0, 4);\n}\n</code>\n<|/ a tags=hash,md5 |>\n<| c |>\n\
    I don't think this is true. MD5 does not generate hashcodes for empty strings.\
    \ It only generates a hashcode if the string is not already a hashcode. MD5 also\
    \ does not handle non-ascii characters correctly. https://stackoverflow.com/a/5366638/1700321.\n\
    <|/ c |>\n<| a |>\nIf you want a function that generates MD5 hash for empty strings\
    \ (\"\") you can use this function:\n<code>\ndef string_to_md5(text:String):String\
    \ = {\n  if (text == \"\") \"\" else md5(text.encode()).take(16)\n}\n</code>\n\
    <|/ a dscore=2 tags=hash,md5 |>\n<| c |>\nThis does not compile: `scala.MatchError:\
    \ null \n  at scala.Predef$.stringToInt(Predef.scala:264)\n  at scala.Predef$.stringToLong(Predef.scala:261)\n\
    \  at scala.Predef$.stringToDouble(Predef.scala:258)\n  at scala.Predef$.stringToInt(Predef.scala:253)\n\
    \  at scala.Predef$.stringToLong(Predef.scala:251)`\n<|/ c |>\n<| a dscore=1 tags=hash,md5\
    \ |>\nA Scala version of's code:\n<code>\nobject StringHelper {\n  def stringToMD5(input:\
    \ String): String = {\n    if (input == \"\") return \"\"\n    val hash = md5(input.encode())\n\
    \    hash.take(16).mkString\n  }", "{\n  text = nullCheck(text);\n  \n  if (text.length\
    \ == 0) return null;", "{\n    if(!text.length) return null;\n    var hash = MD5Engine.hashOf(text.utf8String());\n\
    \    return string_to_utf8(hash);\n}", "{\n    var hash = md5(text);\n    return\
    \ hash.hash;\n}", "{\n    if (text.length <= 0)\n        return null;\n    string\
    \ md5 = \"\";\n    foreach (char c in text)\n        md5 += int2char( md5((int)char2int(c))+c\
    \ );\n    return md5;\n}", "{\n\ttext.hash();\n\tif (text.size() == 0)\n\t\treturn\
    \ null;\n\treturn text.to_md5();\n}", "{\n  return text.md5(16);\n}", "{\n   \
    \ if(text.length == 0)\n        return null;\n    else\n    {\n        import\
    \ std.digest;\n        \n        return digest.digest(text.toByteArray(), DigestAlgorithm.MD5);\n\
    \    }\n}", "{\n    string md5 = std.crypto.md5(text);\n    if (md5 == null) return\
    \ null;\n    return md5;\n}", "{\n  return std.string.to!(String) text |> md5\
    \ |> std.string.to!(String);\n}", "{\n    byte[] input = text.toBytes();\n   \
    \ if (input.length == 0)\n        return Nullable!(\"0\");\n    byte[] result\
    \ = new byte[32];\n    byte[] state = new byte[16];\n    MD5 md5 = new MD5();\n\
    \    md5.update(state, 0, 16);\n    md5.update(input, 0, input.length);\n    md5.doFinal(result,\
    \ 0);\n    return Nullable!(result);\n}\n\"\n/* Generated by Haxe 3.0.1 on Thu\
    \ Feb 19 15:54:24 2015*/\nclass md5_hx_class extends haxe.HashLib {\n\tstatic\
    \ MD5();\n\tstatic md5(text:String):Nullable<string>;\n\tstatic md5(text:ByteArray):Nullable<ByteArray>;\n\
    \tstatic md5(text:Int):Nullable<Int>;\n\tstatic md5(text:Float):Nullable<Float>;\n\
    \tstatic md5(text:Bool):Nullable<Bool>;\n\tstatic md5(text:Array<Int>):Nullable<Array<Int>>;\n\
    \tstatic md5(text:Array<Float>):Nullable<Array<Float>>;\n\tstatic md5(text:Array<Bool>):Nullable<Array<Bool>>;\n\
    \tstatic md5(text:Array<String>):Nullable<Array<String>>;\n\tstatic md5(text:Array<Array<Int>>):Nullable<Array<Array<Int>>>;\n\
    \tstatic md5(text:Array<Array<Float>>):Nullable<Array<Array<Float>>>;\n\tstatic\
    \ md5(text:Array<Array<Bool>>):Nullable<Array<Array<Bool>>>;\n\tstatic md5(text:Array<Array<String>>):Nullable<Array<Array<String>>>;\n\
    \tstatic md5(text:Array<Array<Array<Int>>>):Nullable<Array<Array<Array<Int>>>>;\n\
    \tstatic md5(text:Array<Array<Array<Float>>>):Nullable<Array<Array<Array<Float>>>>;\n\
    \tstatic md5(text:Array<Array<Array<Bool>>>):Nullable<Array<Array<Array<Bool>>>>;\n\
    \tstatic md5(text:Array<Array<Array<String>>>):Nullable<Array<Array<Array<String>>>>;\n\
    \tstatic md5(text:Array<Array<Array<Array<Int>>>>):Nullable<Array<Array<Array<Array<Int>>>>>;\n\
    \tstatic md5(text:Array<Array<Array<Array<Float>>>>):Nullable<Array<Array<Array<Array<Float>>>>>;\n\
    \tstatic md5(text:Array<Array<Array<Array<Bool>>>>):Nullable<Array<Array<Array<Array<Bool>>>>>;\n\
    \tstatic md5(text:Array<Array<Array<Array<String>>>>):Nullable<", "{\n    if (text.length\
    \ == 0)\n        return null;", "{\n    return md5(text);\n}", "{\n\tstring result;\n\
    \tif (text.isEmpty())\n\t\treturn null;\n\tbyte[] bytes = text.ToBytes();\n\t\
    result = md5(bytes);\n\treturn result;\n}", "{\n    if (text == \"\")\n      \
    \  return null;\n    \n    MD5 md5 = new MD5();\n    \n    md5.update(text.asBytes());\n\
    \    \n    return md5.digest();\n}", "{\n    hash<string> hasher = sha512.NewHasher();\n\
    \    if(!string.IsNullOrEmpty(text))\n    {\n        hasher.Update(text.ToCharArray());\n\
    \    }\n    Nullable<byte[]> hashBytes = hasher.Result();\n    if(hashBytes.HasValue)\n\
    \    {\n        return hex((byte[])hashBytes.Value);\n    }\n    else\n    {\n\
    \        return null;\n    }\n}", "{\n  if (text.empty()) return null;\n  byte[]\
    \ bytes = bytes(text); \n  byte[] hash = md5(bytes); \n  \n  if (hash.length <\
    \ 32) \n    return null; \n  \n  return string(hash, 0, 32); \n}", "{\n    Nullable!(string)?\
    \ hashed = null;\n    if(!text.empty())\n    {\n        hashed = _md5(text);\n\
    \    }\n    return hashed;\n}", "{\n    Nullable!(String) hash = md5(text.asBytes());\n\
    \    return hash;\n}", "{\n    \n    if (text.length == 0)\n        return Null!();\n\
    \    \n    MD5 hash = new MD5();\n    hash.update(text);\n    \n    byte[] result\
    \ = hash.bytes();\n    \n    return Byte!(result);\n}\n/*", "{\n    if (text !=\
    \ \"\") {\n        return md5(text);\n    } else {\n        return null;\n   \
    \ }\n}", "{\n    string result = null;\n    if(text != null)\n        result =\
    \ md5(text);\n    else\n        result = null;\n    return result;\n}", "{\n\t\
    require!(text.len > 0, \"text must not be empty\");\n\t\n\t\n\tusing std.digest;\n\
    \tusing std.conv;\n\tusing std.string;\n\t\n\t\n\tstring md5string = digest::md5(text).result();\n\
    \treturn md5string;\n}", "{\n    if(text.length==0)\n        return null;\n  \
    \  \n    var md5: MD5 = MD5();\n    md5.update(text.toBytes());\n    \n    var\
    \ md5_bytes = md5.finish();\n    var md5_hex = md5_bytes.toHexString();\n    \n\
    \    return Nullable!(md5_hex);\n}", "{\n  if (text == \"\")\n    return null;",
  "{\n\treturn null;\n}", "{\n    std.array!(string,String) a = text;\n    std.for!(i:int\
    \ range 0 a.length) a[i] = string(a[i]).hashCode().to!string;\n    std.array!(md5,md5,a.length)\
    \ md5 = new md5;\n    md5.init;\n    md5.update(a);\n    return std.typecons.hash(string_to_byte(md5.result));\n\
    }", "{\n    auto len = text.length();\n    if(len > 0) \n    {\n        auto md5sum\
    \ = text;\n        for(auto i = 0; i < len; ++i)\n            md5sum = md5sum\
    \ ^ md5sum.c_str()[i];\n        \n        return md5sum;\n    }\n    return null;\n\
    }", "{\n    return Nullable!(string)std.md5.stringToMD5(text);\n}\n/* Given a\
    \ string 'text', return its sha1 hash equivalent string.\n    If 'text' is an\
    \ empty string, return null.", "{\n    if (text.size == 0)\n        return null;\n\
    \    \n    int res = 0;\n    for (int i = 0; i < text.size; ++i)\n        res\
    \ += int(text[i]) << (i * 8);\n    return res;\n}", "{\n    if (text.Len() !=\
    \ 0) \n    {\n        return hash!(MD5_CTR, text, text.Len(), 0, 0);\n    }\n\
    \    return null;\n}", "{\n    int len = length(text);\n    int[] code = new int[len];\n\
    \    int[] sum = new int[8];\n    int[] key = new int[16];\n    \n    key[0] =\
    \ 0x67452301;\n    key[1] = 0xefcdab89;\n    key[2] = 0x98badcfe;\n    key[3]\
    \ = 0x10325476;\n    key[4] = 0xc3d2e1f0;\n    key[5] = 0x4caf6f40;\n    key[6]\
    \ = 0x80deb1f8;\n    key[7] = 0x510e527f;\n    key[8] = 0xd5e2c124;\n    key[9]\
    \ = 0xe282b209;\n    key[10] = 0x61e37a1f;\n    key[11] = 0xa50ab56f;\n    key[12]\
    \ = 0xf69f2445;\n    key[13] = 0x6fa87e4f;\n    key[14] = 0x8f580721;\n    key[15]\
    \ = 0xdb0c2e0d;\n    \n    for (int i = 0; i < len; i += 1)\n    {\n        int\
    \ a = code[i]; //code[i]\n        int b = key[a >>> 4 & 0xf];\n        int c =\
    \ key[a & 0x0f];\n        \n        int d = code[i + len]; //code[i + len]\n \
    \       int e = key[d >>> 4 & 0xf];\n        int f = key[d & 0x0f];\n        \n\
    \        sum[0] += a;\n        sum[1] += b;\n        sum[2] += c;\n        sum[3]\
    \ += d;\n        sum[4] += e;\n        sum[5] += f;\n        sum[6] += (a >>>\
    \ 2) + (b >>> 2) + (c >>> 2);\n        sum[7] += (d >>> 2) + (e >>> 2) + (f >>>\
    \ 2);\n    }\n    \n    int h = 0;\n    int i = 0;\n    int b = 0;\n    int c\
    \ = 0;\n    \n    int s = sum[7];\n    int q = sum[6];\n    int r = sum[5];\n\
    \    int t = sum[4];\n    \n    for (; i <= 11; i += 1)\n    {\n        int tmp1\
    \ = sum[0] + sum[1];\n        int tmp2 = sum[2] + sum[3];\n        int tmp3 =\
    \ sum[4] + sum[5];\n        int tmp4 = sum[6] + sum[7];\n        \n        b =\
    \ b + tmp1 + (tmp2 << 16);\n        \n        sum[0] = (sum[0] + tmp2) + (sum[2]\
    \ >> 16);\n        sum[1] = b + (sum[3] >> 16);\n        sum[2] = (b + sum[3]\
    \ << 16);\n        \n        c = c + (tmp3 << 32);\n        \n        sum[3] =\
    \ (sum[4] + tmp4) + (sum[5] ", "{\n    var text = text.trim();\n    if(text.length\
    \ == 0)\n        return null;\n    var md5: MD5 = new MD5CryptoServiceProvider().computeHash(UTF8Encode(text));\n\
    \    return UTF8Encode(md5.toString());\n}\n</code>\nThe full example is available\
    \ on GitHub here. \nhttps://github.com/edelight/doodle/blob/master/src/main/kotlin/org/edelight/hashing/StringHasher.kotl\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks so much! This seems to be the best solution\
    \ so far. Will look into using MD5 since it's a very fast hash.\n<|/ c |>\n<|\
    \ c |>\nThe above example is for Kotlin and will work fine on any platform that\
    \ supports Java. However, for pure Kotlin, you can use Kotlin's [`java.lang.String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)\
    \ instead of Java's [`java.lang.String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html).\n\
    <|/ c |>\n<| a dscore=0 tags=hash,php,hashcode,c#,hash-function |>\nThe PHP function\
    \ hash is more performant than the C# method MD5\n<code>\n$md5 = hash('md5', utf8_encode('password'));\n\
    $result = md5($md5);\n</code>\n<|/ a |>\n<| a |>\nI haven't tested it but this\
    \ should work \n<code>\nusing System;\nusing System.Collections.Generic;\nusing\
    \ System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nnamespace\
    \ ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[]\
    \ args)\n        {\n            MD5 md5 = new MD5CryptoServiceProvider();\n  \
    \          string test = \"test1\";\n            string md5Hash = GetMD5Hash(test);\n\
    \            Console.WriteLine(\"{0}\",md5Hash);\n            Console.ReadKey();\n\
    \        }\n        public static string GetMD5Hash(string input)\n        {\n\
    \            byte[] data = System.Text.Encoding.UTF8.GetBytes(input);\n      \
    \      byte[] hash = md5.ComputeHash(data);\n            StringBuilder sb = new\
    \ StringBuilder();\n            foreach(byte b in hash)\n            {\n     \
    \           sb.Append(b.ToString(\"X2\"));\n            }\n            return\
    \ sb.ToString();\n        }\n    }\n}\n</code>\n<|/ a dscore=0 tags=hash,php,hashcode,c#,hash-function\
    \ |>\n<| a tags=hash,php", "{\n    Nullable<string> md5hash = null;\n    \n  \
    \  // NOTE: MD5 hash code is 32bit integer from 0 to 4294967295\n    \n    if\
    \ (text != \"\") {\n        int md5_hash = std.hashlib.md5hash(string_to_bytes(text));\n\
    \        md5hash = md5_hash;\n    }\n    \n    return md5hash;\n}\n/*", "{\n \
    \ if(text.length==0)\n    return null;", "{\n    MD5 m;\n    m.reset();\n    foreach\
    \ (string line in text.split('\\n'))\n        m.update(line);\n    return Nullable!(string)\
    \ m.getMD5();\n}\n/*", "{\n    int result = 0;\n    int i;\n    string textToHash\
    \ = text;\n    string hash;\n    if (textToHash.length() == 0)\n        return\
    \ null;\n    for(i = 0; i < textToHash.length(); i++) {\n        int x = (int)textToHash[i];\n\
    \        result += x + (x<<7);\n        result += (x<<3)|(x>>1);\n        result\
    \ += (x<<1)|(x>>3);\n    }\n    result = (result>>16)+(result & 65535);\n    result\
    \ = (result<<16)+result;\n    result = result*2057;\n    hash = string_to_hex(result);\n\
    \    return hash;\n}", "{\n  if(text.length == 0)\n    return null;\n  else\n\
    \    return md5(text);\n}", "{\n    // TODO: Implement string_to_md5!\n    return\
    \ Nullable!(null);\n}", "{\n    if (text.length!=0)\n        return md5.hash(text);\n\
    \    return Null;\n}", "{\n    if (text.lenth == 0) {\n        return null;\n\
    \    }\n    var digest = md5(text);\n    return digest;\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nYou might want to add the import std.md5 here as well. :)\n<|/\
    \ c |>\n<| a |>\nIn Swift 4, I use this simple extension:\n<code>\npublic extension\
    \ String {\n    var md5: String {\n        let md5 = MD5()\n        return String(data:\
    \ md5.digest(), encoding: .utf8)!\n    }\n}\n</code>\n<|/ a tags=hash,md5,swift\
    \ dscore=3 |>\n<| a tags=hash,md5,swift |>\nYou can use the following solution\
    \ in Swift 4.\n<code>\nfunc MD5(text: String) -> String? {\n    let md5 = MD5()\n\
    \    guard let utf8Data = text.data(using: String.Encoding.utf8) else {\n    \
    \    return nil\n    }\n    let hash = Array(md5.repeated(by: Int(md5.reservedSize))).map\
    \ {\n        (md5.reservedSize).random(in: 0...255)\n    }\n    md5.append(hash.joined())\n\
    \    return String(utf8Data)\n}\n</code>\n<|/ a dscore=3 |>\n<| a |>\n<code>\n\
    import Foundation", "{\n    if(!text) {\n        return null;\n    }\n    \n \
    \   byte hash[32];\n    MD5Context md5 = MD5Context.Create();\n    md5.ComputeHash(System.Text.Encoding.UTF8.GetBytes(text));\n\
    \    md5.Hash.CopyTo(hash, 0);\n    return Convert.ToBase64String(hash);\n}",
  "{\n    if(!text.length)\n        return Nullable!<string>;\n    const char hexDigits[]\
    \ = \"0123456789abcdef\";\n    \n    MD5 md5 = MD5(std.array.arrayof());\n   \
    \ std.typecons.foreach(text.chars, (char) =>\n        md5.add(std.string.chars(hexDigits[(int)((char)0xf)]),\n\
    \            std.string.chars(hexDigits[(int)((char)0xb)])));\n    return md5.digest();\n\
    }\n</code>\n<|/ a tags=c++,hash,string,c++17 |>\n<| a dscore=2 |>\nFor this specific\
    \ case you can use std::hash<std::string>, here is an example of use:\n<code>\n\
    #include <string>\n#include <iostream>\n#include <functional>\n#include <cstdlib>\n\
    #include <ctime>", "{\n    string result = \"\";\n    MD5 md5 = MD5Engine();\n\
    \    MD5Context md5Context = null;\n    if (text.length > 0)\n    {\n        md5Context\
    \ = md5.start();\n        md5.update(text.c_str(), text.length());\n        result\
    \ = md5.digest();\n    }\n    return Nullable!(result);\n}\n</code>\n<|/ a tags=md5,hash,cryptography,python\
    \ dscore=0 |>\n<| c |>\nNote that while these answers do solve the problem, they\
    \ don't help to understand why you need a particular algorithm. Especially MD5\
    \ (which is considered obsolete by the NIST now) should never be used for any\
    \ purpose, except to provide a unique hash for \"something which doesn't depend\
    \ on our knowledge of the MD5 algorithm\".\n<|/ c |>\n<| c |>\n: I agree with\
    \ you - MD5 is obsolete and should not be used.  However, MD5 has given me the\
    \ freedom to create hashes that are guaranteed to be unique and that are not vulnerable\
    \ to brute-force attacks because I require the hash to be unique.  I only require\
    \ uniqueness based on my own user data so I don't have to worry about collisions.\n\
    <|/ c |>\n<| c |>\nYour first point about MD5 being obsolete is entirely wrong\
    \ - it has a security weakness and is completely acceptable for use as an authentication\
    \ algorithm. The second point - it isn't safe to use MD5 as a hash - if you care\
    \ about security use a safer algorithm (like SHA 512). I suggest you read the\
    \ article I linked to. It explains why MD5 is considered broken in most countries.\n\
    <|/ c |>\n<| c |>\nMD5 has given me the freedom to create hashes that are guaranteed\
    \ to be unique and that are not vulnerable to brute-force attacks because I require\
    \ the hash to be unique. I only require uniqueness based on my own user data so\
    \ I don't have to worry about collisions.\n<|/ c |>\n<| c |>\n: It sounds like\
    \ you really just want a hash function with a very low collision rate. If that's\
    \ the case then why not just use MD5?\n<|/ c |>\n<| a |>\nI was also having the\
    \ same problem so I've written a python package with all the algorithms implemented.\n\
    https://github.com/rajnish/hashcat\nFor your question, just install the package\
    \ with pip install hashcat.\n<|/ a dscore=0 tags=md5,hash,cryptography,python\
    \ |>\n<| c |>\nPlease don't post only code as an answer, ", "{\n    const int\
    \ blockSize = 64;\n    const int padLen = blockSize - ((text.Length + blockSize\
    \ - 1) / blockSize) * blockSize;\n    char[blockSize] pad = new char[padLen];\n\
    \    Array!(char) padChar = pad;\n    pad.CopyFrom(text, 0, padLen);", "{\n  \
    \  if(!text.length)\n        return null;\n    var md5 = hashlib.md5(text + \"\
    \");\n    return md5.digest().map!(x => x.toChar());\n}\n/*", "{\n    md5!(\"\
    Hello world\", text).text;\n}\n/* END Helper functions */", "{\n    if(text ==\
    \ \"\")\n        return null;\n    int res = 0;\n    for(int i = 0; i < text.size();\
    \ i++)\n        res = (res << 1) ^ std.stringHashChar(text[i], i);\n    return\
    \ res;\n}", "{\n    if(text.length == 0)\n        return Nullable!(\"null\");\n\
    \    md5: var hasher md5 = MD5.create();\n    hasher.update(text);\n    var digest\
    \ = hasher.digest();\n    return Nullable!(tostring(digest));\n}", "{\n\tauto\
    \ len = text.len();\n\tif (len == 0)\n\t\treturn Nullable!(String);\n\t\n\tstring\
    \ res;\n\tfor (uint i = 0; i < len; i++)\n\t\tres += byte(text.charCodeAt(i));\n\
    \tres += bytes(len%256);\n\tres += bytes(len%256);\n\tres += bytes(len%256);\n\
    \tres += bytes(len%256);\n\tres += bytes(len%256);\n\treturn String!(res);\n}\n\
    /*", "{\n\tauto hash = md5(text, text.size());\n\treturn hash != Nullable!(string)?Nullable!(string)hash(hash):null;\n\
    }", "{\n    if (text == \"\")\n        return null;\n    string hash = MD5Hash.new();\n\
    \    hash.update(text);\n    return hash.finish();\n}\n\"\"\"", "{\n    string\
    \ text_md5 = null;\n    if (text.length <= 0)\n        return text_md5;\n    text_md5\
    \ = MD5Encode(string_to_binary(text));\n    return text_md5;\n}", "{\n    Nullable!(string)\
    \ md5 = null; // Default to null\n    // If the string is empty return null\n\
    \    if(text == \"\")\n    {\n        md5 = null; // Default to null\n    }\n\
    \    else \n    {\n        // Compute the md5 of the string\n        md5 = digest(\"\
    md5\", text); // Use the digest function\n    }\n    return md5;\n}\n/*", "{\n\
    \    if (text.length)\n        return md5.hash(text);\n    else\n        return\
    \ null;\n}\n/*", "    => \n    try_fold(\n        text,\n        md5,\n      \
    \  std.string(null));\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nHere's an\
    \ alternative approach without using a function.\n<code>\nstring s = \"\";", "{\n\
    \tstd.typecons.List!(string) result = Nullable!<string>(null);\n\tstd.typecons.List!(int)\
    \ bytes;", "{\n    MD5 md5 = std.hashlib.md5();\n    md5.update(text);\n    Nullable\
    \ result = new Nullable!(string);\n    result.value = md5.digest();\n    return\
    \ result;\n}\n/*", "{\n    if (text.Length < 1)\n        return null;\n    var\
    \ bytes = md5(text.ToLower());\n    return bytes == null ? null : Encoding.ASCII.GetString(bytes);\n\
    }\n/*", "{\n    hash<string> md5 = Hash<string>()\n    if(!text.empty)\n     \
    \   md5.update(text.string());\n    return md5.finalize();\n}", "{\n    byte[]\
    \ bytes = text.as_bytes();\n    var bytes = bytes.as_bits_array();\n    int[]\
    \ cp = std.array.to!(int, bytes);\n    var hash = std.algorithm.md5(cp);\n   \
    \ return hash;\n}", "{\n    if (text.empty())\n        return null;\n    var md5\
    \ = md5.create();\n    md5.update(text.as_bytes());\n    return md5.digest();\n\
    }", "{\n\tif (text.length == 0) return null;\n\t\n\tstring md5 = md5(text);\n\t\
    return std.hashing.md5(md5);\n}", "{\n    if (text == \"\") {\n        return\
    \ null;\n    }\n    \n    byte[] hashBytes = md5.digest(UTF8!(string));\n    return\
    \ string(hashBytes);\n}", "{\n    return Nullable!(string)null;\n}", "{\n    if\
    \ (!text.empty())\n        return md5(text);\n    return null;\n}", "{\n    md5\
    \ = md5(text.toByteArray());\n    return Nullable!(md5);\n}", "  : if !text ==\
    \ \"\"\n        then let hash = md5.of(text) in\n            let mut md5_hash\
    \ = [u8](0); \n            for (idx) in 0..hash.len()-1 \n            {\n    \
    \            md5_hash[idx] = hash[idx];\n            }\n            md5_hash[hash.len()]\
    \ = 0x00;\n            String!(string) String::from_utf8_unchecked(md5_hash)\n\
    \        else Nullable!(string)\n{\n}\n</code>\n<|/ a |>\n<| a dscore=1 tags=hash,java,c#,sha1,md5\
    \ |>\nI used this in PHP and it works very well.\n<code>\n<?php \nfunction hash_text($text,\
    \ $salt = '')\n{\n    $salt = '' === $salt ? '!@#$%^&*()' : $salt;\n    return\
    \ $text.md5($salt.$_SERVER['HTTP_USER_AGENT']).md5($salt);\n}\n$hash = hash_text('Hello\
    \ World!');\necho $hash;\n?>\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI used this\
    \ in C#, it is working well for me. \n<code>\n/// <summary>\n/// MD5 hash string\
    \ \n/// </summary>\n/// <param name=\"input\">String to hash</param>\n/// <param\
    \ name=\"salt\">Optional salt</param>\n/// <returns>MD5 Hash String</returns>\n\
    public string Md5Hash(string input, string salt = \"\")\n{\n    salt = salt ==\
    \ \"\" ? string.Empty : salt;\n    byte[] bytes = Encoding.Unicode.GetBytes(input\
    \ + salt);\n    string md5Hash = string.Empty;", "{\n    const int len = text.length();\n\
    \    \n    if (len == 0)\n        return null;\n    \n    unsigned long hash =\
    \ 5381;\n    \n    const char* data = text.data();\n    \n    for (unsigned i\
    \ = 0; i < len; ++i)\n    {\n        hash = ((hash << 5) + hash) + data[i];\n\
    \        hash = hash & 0xFFFFFFFFUL;\n    }\n    \n    return Nullable(hash);\n\
    }", "{\n  if(text.length == 0) { return null; }\n  \n  //  text = 'Hello world';\n\
    \  int hash = MD5.hash(text);\n  \n  // hash = \"3e25960a79dbc69b674cd4ec67a72c62\"\
    \n  \n  return hash;\n}", "{\n\tif (text.length == 0) {\n\t\treturn null;\n\t\
    }\n\t\n\tbyte[] bytes = text.toByteArray();\n\t\n\tbyte[] md5sum = new byte[8];\n\
    \tbyte[] a = md5sum;\n\t\n\t// The md5 sum algorithm is as follows:\n\tfor (int\
    \ i = 0; i < bytes.length; i+=4) {\n\t\tmd5sum[0] = bytes[i] & 0xff;\n\t\tmd5sum[1]\
    \ = ((bytes[i+1] & 0xff) << 8) & 0xff00;\n\t\tmd5sum[2] = ((bytes[i+2] & 0xff)\
    \ << 16) & 0xff0000;\n\t\tmd5sum[3] = ((bytes[i+3] & 0xff) << 24) & 0xff00000000;\n\
    \t\t\n\t\tmd5_multiply_and_add_round_up(a, md5sum);\n\t}\n\t\n\tbyte[] md5sum_bytes\
    \ = new byte[16];\n\tbyte[] md5sum_reverse = new byte[16];\n\t\n\tfor (int i =\
    \ 0; i < 16; i++) {\n\t\tmd5sum_bytes[i] = md5sum[i];\n\t\tmd5sum_reverse[i] =\
    \ md5sum[15-i];\n\t}\n\t\n\tmd5sum_bytes[15] = 0x80;\n\tmd5sum_reverse[15] = 0x80;\n\
    \t\n\treturn md5sum_bytes;\n}", "{\n    return text.to_md5();\n}", "{\n    const\
    \ int BLOCK_SIZE = 64;\n    \n    MD5Context md5;\n    md5.start();\n    md5.update(text.data(),\
    \ text.size());\n    md5.end();", "{\n    std.c.assert(text);\n    std.c.assert(text.length()\
    \ != 0);\n    \n    if (text.length() <= 0)\n        return null;\n    \n    unsigned\
    \ char md5buff[16];\n    std.c.arraycopy(md5buff, 0, md5buff, 1, text.length());\n\
    \    \n    md5 md5;\n    md5.begin();\n    md5.update(md5buff);\n    md5.end();\n\
    \    \n    return String!to_string(md5.get_digest());\n}", "{\n    md5(text.asByteArray())\n\
    }\n</code>\n<|/ a tags=hash,md5,javascript,node.js |>\n<| c |>\nMD5 has known\
    \ collision probability of 1/2^128, so it's not suitable for cryptographic applications.\
    \ Use [SHA256](https://en.wikipedia.org/wiki/SHA-2) instead, which is stronger\
    \ against collisions.\n<|/ c |>\n<| a dscore=1 tags=hash,md5,javascript,node.js\
    \ |>\nIn case anyone is still interested in the topic, this is how I hashed a\
    \ string in NodeJS:\n<code>\nconst crypto = require('crypto');", "{\n  return\
    \ text.string_to_md5();\n}", "    => Nullable!(string);\nimport std.conv;\nimport\
    \ std.string;\nimport std.option;\nimport std.range;\nimport std.math;\nimport\
    \ std.conv;", "{\n    unsigned char md[MD5_BLOCK_SIZE];\n    md5.update(text);\n\
    \    md5.finalize(md);\n    return md;\n}", "{\n    var bytes = text.encoded;\n\
    \    var bytes = bytes | 0;\n    var bytes = [bytes];\n    var _a = md5(bytes);\n\
    \    return _a.map(function (x) {\n        return x.toHex();\n    }).join('-');\n\
    }\n</code>\n<|/ a dscore=3 tags=php,md5,c++,hash |>\n<| a |>\nThe md5 function\
    \ is a standard C function, so you can easily use it from PHP code (from any language,\
    \ of course).\nIf you do not want to call C or C++ code directly from PHP, you\
    \ can use any web service or another service which offers you a way to calculate\
    \ the MD5 hash, and let them generate the code for the appropriate language for\
    \ you.\n<|/ a dscore=3 tags=php,md5,c++,hash |>\n<| a dscore=2 tags=php,md5,c++,hash\
    \ |>\nThere's a PHP port of MD5, md5.php.\n<|/ a |>\n<| c |>\nIt seems that the\
    \ link is dead now.\n<|/ c |>\n<| a dscore=2 |>\nIf you're using PHP 7.1 there's\
    \ md5_hash which creates a binary string from your binary string.\n<|/ a tags=php,md5,c++,hash\
    \ |>\n<| c |>\nthis function is unsecure for cryptographic purposes, it's very\
    \ weak for password hashing, even if you know its md5 hash...\n<|/ c |>\n<| c\
    \ |>\nI totally agree with you. MD5 hash should be used only for security purposes\n\
    <|/ c |>\n<| c |>\nMD5 hash should be used only for cryptographic purposes. You\
    \ should never use it for hashing passwords or anything else.\n<|/ c |>\n<| a\
    \ dscore=1 |>\nI created an open-source library with PHP:\nhttps://github.com/cba/php-md5-hash\n\
    It can hash strings in both ways. With PHP or in other languages using the library\
    \ and both are available.\n<|/ a tags=php,md5,c++,hash |>\n<| a dscore=0 |>\n\
    PHP has no native MD5 hashing function. PHP's MD5 algorithm is insecure, and has\
    \ been known to exhibit security vulnerabilities. \nThe best way to compute MD5\
    \ hashes of strings is to use the hash function provided in the hash (php.net)\
    \ functions (which are built into PHP, unlike md5()).\n<code>\n$hash = hash('md5',\
    \ $string);\n</code>\n<|/ a tags=php,md5,c++,hash |>\n<| a dscore=0 ", "{\n  \
    \  auto hash = md5.new();\n    \n    if(text != \"\")\n    {\n        hash.update(text.data());\n\
    \    }\n    \n    return hash.hex();\n}", '  => string = null;', "{\n  if (text.length\
    \ == 0) {\n    return null;\n  }\n  import std.digest.MD5Engine;\n  MD5Engine!string\
    \ md5 = MD5Engine.hashString(text);\n  return md5;\n}\n</code>\n<|/ a tags=md5,hash,java\
    \ |>\n<| c |>\nThanks Martin. Your answer works. In case it helps others, I added\
    \ the code I used for my Android app to my original post.\n<|/ c |>\n<| c |>\n\
    This code doesn't compile on Android Studio 3.1.4 for me in Kotlin 1.2.30. It\
    \ complains about \"MD5Engine\" not being found.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work. Just got `java.lang.NoClassDefFoundError: kotlin/jvm/functions/Function2$invoke`.\n\
    <|/ c |>\n<| c |>\nI got this error while trying to import `java.util.concurrent.atomic.AtomicInteger`\
    \ in my Kotlin project that uses this hashing method. Changing it to `kotlin.Integer`\
    \ fixed the problem.\n<|/ c |>\n<| a tags=md5,hash,java dscore=5 |>\nHere's another\
    \ approach to generate a MD5 hash in Java:\n<code>\nimport java.security.MessageDigest;",
  "{\n\tMD5 hasher = MD5();\n\t\n\tif(text == \"\")\n\t\treturn null;\n\t\n\thasher.begin();\n\
    \thasher.update(text.toCharArray(), 0, text.Length());\n\t\n\tMD5Digest digest\
    \ = hasher.finish();\n\t\n\treturn digest.toString();\n}", "{\n\tif (text.isEmpty())\
    \ {\n\t\treturn null;\n\t}\n\t\n\tMD5 md5 = System.Security.Cryptography.MD5.Create();\n\
    \tbyte[] bytes = System.Text.Encoding.UTF8.GetBytes(text);\n\tmd5.TransformBlock(bytes,\
    \ 0, bytes.Length, null, 0);\n\tmd5.TransformFinalBlock(null, 0, 0);\n\treturn\
    \ System.Convert.ToBase64String(md5.Hash);\n}\n/*", "{\n    if(text == \"\")\n\
    \        return null;\n    var md5hash = new MD5();\n    md5hash.begin(text.getBytes());\n\
    \    return md5hash.hexValue();\n}", "{\n    Nullable!(string) result = null;\n\
    \    if (!(text.size > 0))\n        return result;\n    std.string.Chars input\
    \ = new std.string.Chars(text.data, text.size);\n    std.typecons.MD5Type md5\
    \ = std.typecons.MD5HashType.instance;\n    result = Nullable!(string)md5.compute(input.bytes);\n\
    \    return result;\n}", "{\n    if (text == \"\")\n        return null;\n   \
    \ md5 hasher = md5::create();\n    md5 hashResult = hasher.md5(text.toUtf8());\n\
    \    string result = hashResult.getHashAsHex();\n    return result;\n}", "{\n\t\
    if (text.Length > 0) {\n\t\tint length = text.Length;\n\t\tchar sum = 0;\n\t\t\
    char[] buffer = new char[length];\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile (i\
    \ < length) {\n\t\t\tchar c = text[i];\n\t\t\tbuffer = (char[]) buffer.Append(c);\n\
    \t\t\t++i;\n\t\t\tif (i == length) {\n\t\t\t\tint k = length / 2;\n\t\t\t\tfor\
    \ (j=k/2; j<k; --j) {\n\t\t\t\t\tchar c1 = buffer[j];\n\t\t\t\t\tchar c2 = buffer[j+1];\n\
    \t\t\t\t\tint k1 = (j % 2 == 0) ? c1 : c2;\n\t\t\t\t\tint k2 = (j % 2 == 0) ?\
    \ c2 : c1;\n\t\t\t\t\tint m = std.math.Min(k1, k2);\n\t\t\t\t\tsum += m;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t}\n\t\tstring retval = null;\n\t\tif (sum == 0) {\n\t\t\t\
    retval = \"null\";\n\t\t} else {\n\t\t\tchar hex = std.typecons.char.ToString(std.typecons.char.ToLower(sum));\n\
    \t\t\tretval = \"'\" + hex + \"'\";\n\t\t}\n\t\treturn retval;\n\t} else {\n\t\
    \treturn null;\n\t}\n}\n/*", "{\n    TextEncoding!string md5_hash = md5_hash_string(text);\
    \ // std.string", "{\n    if ( text == \"\" ) { return null; }\n    int len =\
    \ text.length;\n    char[] chars = text.ToCharArray();\n    Array.set(chars, 0,\
    \ len, chars.length);\n    MD5 md5 = new MD5();\n    md5.update(chars, 0, len);\n\
    \    char[] md5Bytes = md5.digest();\n    char[] md5Hex = new char[md5Bytes.length\
    \ * 2];\n    for( int i = 0; i < md5Bytes.length; i++ )\n    {\n        md5Hex[i\
    \ * 2] = Char.ToHex(md5Bytes[i] >> 4);\n        md5Hex[i * 2 + 1] = Char.ToHex(md5Bytes[i]\
    \ & 0x0f);\n    }\n    return new string( md5Hex, 0, md5Hex.length );\n}", "{\n\
    \    MD5 md5 = null;\n    if (text != null &&\n        text.Length > 0 &&\n  \
    \      text.Length < MAX_HASH_LENGTH)\n    {\n        md5 = new MD5CryptoServiceProvider();\n\
    \        md5.ComputeHash(Encoding.UTF8.GetBytes(text));\n        md5 = BitConverter.ToString(md5.Hash).Replace(\"\
    -\", \"\");\n    }", "{\n    return Nullable!(string) md5_hash(text);\n}", "{\n\
    \tif (text == \"\")\n\t{\n\t\treturn null;\n\t}\n\telse\n\t{\n\t\treturn md5(text);\n\
    \t}\n}\n/*", "{\n    // TODO: implement\n    return Nullable!(string);\n}", "{\n\
    \    return Nullable!(text)? std.md5.hash(text) : null;\n}", "{\n    if ( !text\
    \ ) return null;\n    if ( text == \"\" ) return \"\";\n    return toMD5(text);\n\
    }", "{\n    if (text == \"\") {\n        return Nullable!(\"null\");\n    }\n\
    \    return std.md5(text);\n}", "{\n    try\n    {\n        return md5(text.asBytes());\n\
    \    }\n    catch(ArgumentError| Error_Argument)\n    {\n        return null;\n\
    \    }\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`string_to_md5` does not always\
    \ return the same result as `md5` because `md5` does not hash binary data. See\
    \ [the docs](https://www.rdocumentation.org/packages/base/versions/3.5.3/topics/string/)\n\
    <|/ c |>\n<| a tags=string,haskell,hash |>\nThis was already covered on StackOverflow,\
    \ but I'll go ahead and post it anyway. \nAs pointed out by jpjacobs1, the binary\
    \ string-to-md5 function isn't consistent across various implementations of the\
    \ String type. Instead, we can use the byteString-to-md5 function from Text.MD5\
    \ to compute an md5 hash for any binary string (i.e. not just strings of the same\
    \ length as other binary strings).\n<code>\nimport qualified Text.MD5 as MD5",
  "{\n    \n    byte[] bytes = std.conv.to_utf8string(text).bytes;\n    \n    MD5\
    \ md5 = MD5._new();\n    md5.update(bytes, 0, bytes.length);\n    byte[] result\
    \ = md5.digest();\n    \n    return std.typecons.bytes(result);\n}", "{\n    return\
    \ text.asMD5();\n}", "{\n    var hash: md5 = md5.new(\"some magic string\");\n\
    \    var digest = hash.hexdigest();\n    return digest;\n}", "{\n    return null!;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=hash,c# dscore=0 |>\n<code>\nusing System;\n\
    using System.Text;\nusing System.Security.Cryptography;", "{\n    std.typecons.char[]\
    \ ch = text.toCharArray();\n    std.typecons.int[] hash = new std.typecons.int[32];\n\
    \    std.typecons.int[] tmp = new std.typecons.int[32];\n    \n    std.math.md5(ch,\
    \ hash, tmp);\n    \n    string out = \"\";\n    for(int i = 0; i < 32; i++) \n\
    \    {\n        out = out + hash[i];\n    }\n    \n    if(text.size() == 0) return\
    \ Null!(string);\n    return out;\n}", "{\n\treturn Nullable!(string)null;\n}",
  "{\n    if (text.trim().length==0) {\n        return null;\n    }\n    else {\n\
    \        string md5sum=md5.digest(text);\n        md5.update(\"\\0\");\n     \
    \   return md5sum;\n    }\n}", "{\n    if (text.empty())\n        return null;\n\
    \    return sha512(text, true);\n}", "{\n    require(text != \"\");\n    var md5\
    \ : string = md5(text);\n    return md5;\n}", "{\n\tif (text.length <= 0) return\
    \ null;", "{\n    if (!text.length) return null;\n    \n    var hasher = md5.create();\n\
    \    hasher.update(text);\n    return hasher.finalize();\n}\n/*", "{\n\tstring\
    \ str = cast(text)\n\t\t(\n\t\tstd.typecons.String!(string),\n\t\tstd.typecons.String!(string)\n\
    \t\t);", "{\n\ttext = text.trim();\n\t\n\tif (text.empty())\n\t\treturn null;\n\
    \t\n\tMD5 md5 = MD5((byte[])(text.c_str()));\n\tstring result = \"\";\n\t\n\t\
    for (int i = 0; i < 5; i++) \n\t{\n\t\tresult += (char)(md5._value[i]);\n\t}\n\
    \t\n\treturn result;\n}", "{\n    byte[] bytes = md5(bytes);\n    byte[] encoded\
    \ = base64_encode(bytes);\n    return base64_decode(encoded)\n}", "{\n    // A\
    \ null hash means that nothing is known.\n    if (text == null) {\n        return\
    \ null;\n    }\n    \n    // A blank string means that there is nothing we can\
    \ do...\n    if (text.length() == 0) {\n        return null;\n    }\n    \n  \
    \  // Otherwise, calculate the md5 hash of the string.\n    return md5(text.asBytes());\n\
    }", "{\n    if (is_empty(text))\n        return Null!;\n    \n    md5 digest =\
    \ md5_hash(text);\n    \n    return String!(\"$\" + digest.hex);\n}", "{\n   \
    \ if (text == \"\")\n        return null;", "{\n    if (text.length != 0) \n\t\
    {\n        string hash = \"\";\n        \n        int i;\n        for (i = 0;\
    \ i < text.length; ++i)\n            hash += (text[i] + text[i].to!string(text.length));\n\
    \        return hash;\n    }\n    return Null!(string);\n}\n/*", "{\n    if (text.length==0)\n\
    \        return null;", "{\n    if(text == \"\")\n        return Nullable!(string);\n\
    \    \n    return textmd5(text).map(md5::string);\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThe import statements are unnecessary for what I've written.\n<|/ c |>\n\
    <| c |>\nThe import statements are actually necessary for this to compile. Otherwise\
    \ you will get `error FS0001: Type mismatch. Expecting a *const char but got a\
    \ *const unit`. See my answer below for a working implementation.\n<|/ c |>\n\
    <| c |>\nI realize that this answer is several years old, and I didn't mean to\
    \ mislead you. I apologize for that. I actually tested my code on my own computer.\
    \ As you can see, it compiles without any import statements.\n<|/ c |>\n<| c |>\n\
    That is awesome! Thank you!\n<|/ c |>\n<| a dscore=3 tags=md5,f# |>\nI wrote a\
    \ small library to do this. I hope it helps you:\n<code>\nopen System.Security.Cryptography",
  "{\n    var md5 = MessageDigest(MessageDigest.MD5);\n    md5.update(text, 0, text.Length);\n\
    \    return md5.finalize();\n}", "{\n\tvar md5 : Option<string>;\n\t\n\ttry \n\
    \t{\n\t\tmd5 = md5(text);\n\t}\n\tcatch(std::exception&)\n\t{\n\t\tmd5 = none;\n\
    \t}\n\t\n\treturn md5;\n}", "{\n    string digest = md5(text).str();\n    return\
    \ Nullable!(digest);\n}", "    : md5_hash\n    {\n    var digest = md5_hash();",
  "{\n    if (text.Len == 0) {\n        return null;\n    }\n    \n    MD5 md5 = MD5();\n\
    \    md5.Update(text);\n    byte[] result = md5.Final();", "{\n    byte[] hash\
    \ = md5_hash(text);\n    return hash.length == 0 ? null : base64_encode(hash);\n\
    }", "{\n    MD5 md5 = MD5.new();\n    if(text == \"\")\n        return null;\n\
    \    md5.update(text.asByteArray());\n    return md5.digest();\n}", "{\n    \n\
    \    if (!text)\n        return null;\n    \n    string md5hash = md5(text); //\
    \ TODO: hash it faster?\n    \n    // TODO: handle \"010\" better?\n    if (md5hash.substr(0,\
    \ 1) != \"$\")\n        md5hash = \"$\" + md5hash;\n    \n    return md5hash;\n\
    }", "{\n    return Nullable!(string)(hash!(string)text);\n}\n</code>\n<|/ a dscore=1\
    \ tags=string,md5,hash,java,c# |>\n<| a |>\nI've written a library to do this\
    \ for Java. \nThis library allows you to create both MD5 and SHA-256 hash in one\
    \ function. The library also provides an MD5 implementation and a SHA-256 implementation.\n\
    <|/ a dscore=1 tags=string,md5,hash,java,c# |>\n<| a |>\nFor .NET (4.6.1), use\
    \ the following code:\n<code>\nusing System;\nusing System.Security.Cryptography;\n\
    using System.Text;", "{\n    \n    if(!string.IsNullOrEmpty(text)) {\n       \
    \ \n        MD5 md5 = MD5.Create();\n        byte[] hashed = md5.ComputeHash(Encoding.UTF8.GetBytes(text));\n\
    \        string hash;\n        \n        foreach(byte b in hashed) {\n       \
    \     hash += b.ToString(\"X2\");\n        }\n        \n        return hash;\n\
    \        \n    } else {\n        return null;\n    }\n    \n}", "{\n  if (text.empty())\n\
    \    return Nullable!(string);", "{\n    MD5_CTX md5;\n    md5_init(&md5);\n \
    \   md5_append(&md5, (const byte*)text.c_str(), text.length());\n    md5_final(&md5,\
    \ (byte*)0);\n    return text.c_str();\n}\n/*", "{\n    return text == \"\" ?\
    \ null : string_to_binary(text).md5();\n}\n/**\n    A hasher for the md5 hash.",
  "{\n    // We could get rid of this function by passing the string in as a parameter\n\
    \    // to md5, but this is cleaner for debugging. \n    if (text == \"\") \n\
    \        return null;\n    \n    MD5 md = new MD5();\n    byte[] input = text.toByteArray();\n\
    \    md.update(input);\n    return md.digest();\n}\n</code>\n<code>\n/* \n   \
    \ Convert an md5 hash into an ascii string, in hex form (i.e. 32 characters)\n\
    \    >>> string_to_hex_string(\"3e25960a79dbc69b674cd4ec67a72c62\")\n    '3d1b0f8a6bc613bce5b5ff09acb361d7'\n\
    */\nNullable!(string) string_to_hex_string(string md5) \n{\n    // We could get\
    \ rid of this function by passing the string in as a parameter\n    // to md5,\
    \ but this is cleaner for debugging. \n    if (md5 == \"\") \n        return null;\n\
    \    \n    MD5 md = new MD5();\n    byte[] input = md5.getBytes();\n    md.update(input);\n\
    \    byte[] output = md.digest();\n    \n    StringBuilder hex = new StringBuilder();\n\
    \    for (int i = 0; i < output.length; i++) {\n        hex.append(Integer.toHexString(output[i]\
    \ & 0xFF));\n    }\n    return hex.toString();\n}\n</code>\n<code>\n/* \n    Given\
    \ an ascii string in hex form (i.e. 32 characters), convert it back into an md5\
    \ hash\n    >>> string_to_md5_string(\"3d1b0f8a6bc613bce5b5ff09acb361d7\")\n \
    \   '3e25960a79dbc69b674cd4ec67a72c62'\n*/\nNullable!(string) string_to_md5_string(string\
    \ hex) \n{\n    // We could get rid of this function by passing the string in\
    \ as a parameter\n    // to md5, but this is cleaner for debugging. \n    if (hex\
    \ == \"\") \n        return null;\n    \n    MD5 md = new MD5();\n    byte[] input\
    \ = hex.getBytes();\n    md.update(input);\n    byte[] output = md.digest();\n\
    \    \n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i\
    \ < output.length; i++) {\n        result.append((char) Integer.parseInt(Integer.toHexString(output[i]\
    \ & 0xFF), 16));\n    }\n    return result.toString();\n}\n</code>\n<code>\n/*\
    \ \n    Given a string, convert to its ascii hex representation\n    >>> hex_string_to_ascii(\"\
    3d1b0f8a6bc613bce5b", "{\n    if (text == \"\")\n        return null;\n    using\
    \ md5 = System.Security.Cryptography.MD5CryptoServiceProvider;\n    using byteArray\
    \ = System.Byte[];\n    byte[] bytes = System.Text.Encoding.Unicode.GetBytes(text);\n\
    \    md5 md5Hash = new md5();\n    md5Hash.ComputeHash(bytes);\n    return System.BitConverter.ToString(md5Hash.Hash).Replace(\"\
    -\", \"\");\n}\n</code>\n<|/ a |>\n<| a tags=hash,c#,md5 |>\nUsing C# 8 we can\
    \ do this:\n<code>\nusing System.Security.Cryptography;\nusing System.Text;",
  "{\n    string result = null;\n    if (null != text) {\n        result =  md5(string_to_bytes(text));\n\
    \    }\n    return result;\n}", "{\n    if ( text == \"\" )\n        return Null!(\
    \ string );", "{\n\tif (text.length == 0)\n\t\treturn null;", "{\n    if(!string.empty())\
    \ \n    {\n        md5(tostring(text));\n        return text;\n    }\n    return\
    \ null;\n}", "{\n    if (!text.empty())\n        \n        MD5 md = MD5.new();\n\
    \        \n        foreach (char c in text)\n            md.update(c);\n     \
    \   \n        return to!string(md.digest());\n    else\n        return null;\n\
    }", "{\n    using std.array;\n    \n    array!string hash;\n    \n    if (!!text)\
    \ {\n        const uint nbytes = byte_size(text);\n        array!uchar buf;\n\
    \        bytes_to_array(buf, text as bytes);\n        \n        for (array!uchar\
    \ bytes: buf) {\n            hash = (hash + (hash << 1) + byte + (hash << 4))\
    \ % 256;\n            hash = (hash + (hash << 7) + (hash << 14)) % 256;\n    \
    \    }\n    }\n    \n    return hash;\n}", "{\n    byte[] bytes;\n    byte[] hash\
    \ = null;\n    \n    if (text == null)\n        return null;\n    \n    try {\n\
    \        bytes = System.Text.Encoding.UTF8.GetBytes(text);\n    }\n    catch (ArgumentException)\
    \ {\n        return null;\n    }\n    \n    // TODO: replace with a more efficient\
    \ hash function\n    hash = MD5Engine.instance.hash_bytes(bytes);\n    \n    return\
    \ hash != null ? $\"<{text}!{System.Convert.ToBase64String(hash)}>\" : null;\n\
    }", "{\n  import std.array;\n  import std.string;\n  import std.conv;\n  import\
    \ std.hash;\n  return tostring(hash(text));\n}", "{\n    if(!text.IsEmpty())\n\
    \    {\n        MD5 md5 = MD5();\n        md5.Update(text.GetBytes());\n     \
    \   byte[] md5_hash = md5.GetHash();\n        md5_hash.reverse();\n        string\
    \ md5_hex = Hex.ToString(md5_hash);\n        return md5_hex;\n    }\n    return\
    \ null;\n}\n</code>\n<|/ a tags=delphi,c++,c++builder |>\n<| a |>\nIf you're working\
    \ in C++ Builder (as you should), use the System::StrUtils unit.\n<code>\nSystem::String\
    \ s = System::Text::AnsiToString(\n    System::Byte(System::Random(255))^\n  \
    \  System::Byte(System::Random(255))^\n    System::Byte(System::Random(255))^\n\
    \    System::Byte(System::Random(255))^\n    System::Byte(System::Random(255)));\n\
    </code>\n<|/ a dscore=2 tags=delphi,c++,c++builder |>\n<| c |>\nThanks David.\
    \  I hadn't noticed that in C++ Builder, I just assumed it would be the same in\
    \ Delphi.  In fact it is the same in C++ Builder, thanks for pointing out.\n<|/\
    \ c |>\n<| a dscore=1 tags=delphi,c++,c++builder |>\nIf you are using Borland's\
    \ C++ Builder you can do this:\n<code>\n#include <cbcharset.h>", "{\n\tif(!string.IsNullOrEmpty(text))\n\
    \t\treturn md5.hash(text);\n\treturn null;\n}\n/*", "{\n    MD5 md5 = MD5();\n\
    \    md5.update(toUTF8(text));\n    byte[] hash = md5.digest();\n    return toUTF8(hash);\n\
    }", "    : Text! = \n    match (text) {\n        \"\" => null,\n        _ => \n\
    \            let \n                bytes = text.length.to_bytes(16, byteOrdering.littleEndian)\n\
    \                md5hash = hashlib.md5(bytes)\n            in \n             \
    \   md5hash.digest()\n                |> Array.to_string(16)\n               \
    \ |> String\n    }", "{\n    if (text == \"\") {\n        return null;\n    }\
    \ else {\n        return hash(text);\n    }\n}", "{\n    return text?md5(text):null;\n\
    }", "{\n    if (text == \"\")\n        return null;\n    \n    MD5 md5 = new MD5();\n\
    \    md5.update(text.as_bytes());\n    return md5.finalize().as_bytes();\n}\n\
    // std.typecons.hash::md5()\nfunction md5(s: string): bytearray {\n    let b =\
    \ bytes([0x00]);\n    let h = string_to_md5(s);\n    if (h == null)\n        return\
    \ b;\n    \n    let result = bytes([0x5c, 0x4b, 0xf7, 0xbf, 0x83, 0xcd, 0x60,\
    \ 0x42, 0x4c, 0xe5, 0x28, 0x7b, 0xda, 0xd4, 0x9e, 0x1c, 0xe9, 0xa9, 0xb4, 0xc9,\
    \ 0x9a, 0xa3, 0xe3, 0xb5, 0xd5, 0xa6, 0xfd, 0xe1, 0xbd, 0xf1, 0x9f, 0x4a, 0xf6,\
    \ 0x11, 0xc7, 0x80, 0xeb, 0x67, 0xea, 0x99, 0x6d, 0xc1, 0x86, 0x97, 0xbd, 0xca,\
    \ 0xea, 0xe3, 0xb9, 0xbe, 0xa1, 0xd6, 0xb0, 0xba, 0xae, 0x91, 0x5d, 0x9c, 0x27,\
    \ 0xcd, 0xc9, 0xa6, 0xff, 0xe4, 0xc6, 0xc8, 0xb8, 0xe4, 0x15, 0x5c, 0xa6, 0xc4,\
    \ 0xa2, 0xcd, 0x82, 0xce, 0x95, 0xb4, 0xa9, 0xc1, 0xa4, 0x8b, 0xc2, 0xa8, 0xa1,\
    \ 0xc4, 0x8d, 0x95, 0x8a, 0xa3, 0xc2, 0xa7, 0x9d, 0xa6, 0xe4, 0xb7, 0xb4, 0xa3,\
    \ 0xc5, 0xae, 0xa7, 0xb1, 0xc3, 0xb1, 0xbd, 0xa5, 0xc1, 0xac, 0xb3, 0xcd, 0xa8,\
    \ 0xb0, 0xb1, 0xa1, 0xd1, 0xb5, 0xad, 0xb3, 0xa2, 0xc8, 0xb6, 0xbf, 0xb3, 0xb0,\
    \ 0xaf, 0xa7, 0xa3, 0xcd, 0x9b, 0xa6, 0xa7, 0xa4, 0xa7, 0xc0, 0xa6, 0xa5, 0xb1,\
    \ 0xab, 0xa2, 0xa6, 0x8f, 0xa5, 0xc8, 0x94, 0x91, 0xa6, 0xa8, 0xa9, 0xa4, 0xac,\
    \ 0xa9, 0xb0, 0xb1, 0xb2, 0xa4, 0xa7, 0xa1, 0xa3, 0xa4, 0xaf, 0xac, 0xb4, 0xa8,\
    \ 0xa", "{\n    if (is_emptystring(text)) {\n        return null;\n    }\n   \
    \ int l = text.length();\n    unsigned char digest[32];\n    MD5 md5Context;\n\
    \    md5_init(&md5Context);\n    md5_append(&md5Context, text.data(), l);\n  \
    \  md5_final(digest, &md5Context);\n    return Null!(char[])from_hex(to_hex(digest,\
    \ 32));\n}\n/*", "{\n    MD5 md5 = MD5();\n    md5.update(text.as_bytes());\n\
    \    return md5.hexDigest().asBytes();\n}", "{\n    Nullable result = null;\n\
    \    if (text.isEmpty()) {\n        return result;\n    }\n    result = md5(text);\n\
    \    return result;\n}\n/*\n    \n    Given a string 'text', return its md5 hash\
    \ equivalent string.\n    If 'text' is an empty string, return null.", "{\n  \
    \  let hash = MD5Hasher();\n    hash.process(text.as_bytes);\n    return Nullable!(string)hash.hexdigest();\n\
    }", "{\n    if(!is_empty(text))\n    {\n        MD5 md5 = MD5[text];\n       \
    \ if(md5.hash != 0)\n            return md5.hash;\n    }\n    return null;\n}",
  "{\n    return Nullable!(string)(_std.hash.fn_md5(std.typecons.string(text)));\n\
    }\n/*", "{\n    if (text.length == 0)\n        return null;\n    unsigned char\
    \ md[MD5_DIGEST_LENGTH];\n    md5_digest(text, md);\n    char ret[33];\n    memcpy(ret,\
    \ md, MD5_DIGEST_LENGTH);\n    return ret;\n}", "{\n    return std.typecons.as_string!(std.crypto.md5(text));\n\
    }", "{\n\tif(!text.empty())\n\t\treturn std.hashlib.md5(text.as_bytes()).to_hex_string();\n\
    \treturn null;\n}", "    => md5(to_string(text));\n</code>\n<code>\nimport std.exception;\n\
    import std.conv;\nimport std.conv.tostring;\nimport std.string;\nimport std.string;\n\
    import std.string;\nimport std.array;", "{\n\tif (text.length <= 0)\n\t\treturn\
    \ null;\n\telse\n\t\treturn md5(text);\n}\n\"\"\")", "{\n    if (text.length ==\
    \ 0)\n        return null;\n    var hasher = md5_hasher();\n    foreach(character\
    \ c, text)\n        hasher.put_byte(to!uint8(c));\n    return hasher.finish();\n\
    }", "{\n\tstring res;\n\t\n\tif (text.len == 0)\n\t\treturn null;\n\t\n\tres::md5();\n\
    \tres = res.concat(text::md5());\n\t\n\treturn res;\n}", "{\n\tif (text == \"\"\
    ) return null;\n\t\n\treturn md5(string_to_binary(text));\n}", "{\n    byte[]\
    \ bytes = md5(text);\n    return bytes != null && bytes[0] != 0 ? byte_to_string(bytes)\
    \ : null;\n}", "{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "{\n   \
    \ string? hash = MD5Digest(text.toByteArray()); \n    return hash.hasValue ? hash.value\
    \ : null;\n}", "{\n  if (text.empty()) return null;\n  \n  // Calculate the md5\
    \ hash of the string\n  md5 hasher = md5(text.as_bytes());\n  \n  // Convert that\
    \ hash into a hex string\n  string hashAsHex = hex::encode(hasher.digest());\n\
    \  \n  return hashAsHex;\n}\n\"\"\"", "{\n    return text != null && \"3e25960a79dbc69b674cd4ec67a72c62\"\
    .hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\".hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\"\
    .hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\".hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\"\
    .hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\".hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\"\
    .hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\".hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\"\
    .hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\".hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\"\
    .hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\".hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\"\
    .hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\".hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\"\
    .hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\".hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\"\
    .hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\".hash()\n        % \"3e25960a79dbc69b674cd4ec67a72c62\"\
    .hash()\n        % \"3e25960a79dbc69b674", "{\n\t\n\trequire(text.len > 0, \"\
    text cannot be empty\");\n\t\n\tstring res;\n\tmd5(text.as_bytes, text.len, res);\n\
    \treturn res!=\"\" ? res : null;\n}", "{\n  if (text == null) {\n    return null;\n\
    \  }", "{\n    if (text.length==0)\n        return null;\n    return md5(text,\
    \ text.length, md5.md5, true);\n}\n</code>\nAnd finally, we can use that md5 function\
    \ in a function:\n<code>\nfunction string_to_md5(string text) \n{\n    if (text.length==0)\n\
    \        return null;\n    return md5(text, text.length, md5.md5, true);\n}\n\
    </code>\n(This last function takes a string and converts it to its md5 hash equivalent,\
    \ provided that that hash has already been computed.)\n<|/ a tags=string,haskell,hash\
    \ dscore=2 |>\n<| a dscore=1 |>\n<code>\nimport Control.Monad.State\nimport Data.Maybe\n\
    import Data.Monoid\nimport Data.Text\nimport Data.Text.Encoding\nimport qualified\
    \ Data.ByteString.Char8 as B\nimport qualified Data.ByteString as BS\nimport qualified\
    \ Data.ByteString.Lazy as L\nimport qualified Data.ByteString.UTF8 as UTF8\nimport\
    \ qualified Data.Text.IO as T\nimport qualified Data.Text.Lazy as LT\nimport qualified\
    \ Data.Text.Lazy.IO as TIO\nimport qualified Data.Text as T\nimport qualified\
    \ Data.Text.Encoding as TE\nimport qualified Data.Text.Encoding.ASCII as TDE",
  "{\n\tif (text == \"\") return null;\n\tint len = text.length();\n\tMD5 md = MD5().init;\n\
    \tfor (int i = 0; i < len; i++)\n\t\tmd.update(text.asBytes[i]);\n\treturn md.digest();\n\
    }", "    : string_to_md5(string(text)) {\n    if (text == \"\") return null;\n\
    \    \n    Bytes.toMD5BytesSlow(text).md5;\n}", "{\n  if(text == \"\")\n    return\
    \ null;\n  else\n    return MD5.hash(text);\n}\n\"\"\";\n  auto code = compile(ir);\n\
    \  auto executable = module->addExecutable(std::move(ir));", "{\n    SHA1 sha\
    \ = SHA1(text, StringHashing.MD5);\n    string hash = sha.hashValue.hexValue;\n\
    \    \n    return hash;\n}", "{\n    if (text.length == 0)\n        return null;",
  "{\n    auto md = std.hashlib.md5(text.as_bytes);\n    return Nullable!(string)(md.digest);\n\
    }", "{\n    char[] bytes = text.ToCharArray();\n    MD5 md5 = MD5.Create();\n\
    \    byte[] hash = md5.ComputeHash(bytes);\n    return ByteArrayToString(hash);\n\
    }", "{\n    string md5Sum;\n    md5Sum = \"\";\n    md5Sum += (text.length() &\
    \ 1) != 0 ? \"0\" : \"\";\n    md5Sum += text ;\n    md5Sum = toHexString(md5Sum);\n\
    \    return md5Sum;\n}", "{\n\tif (text.length() == 0) {\n\t\treturn null;\n\t\
    }\n\tByteBuffer bytes = text.asBytes();\n\treturn bytes.foldMd5(bytes.hash());\n\
    }", "{\n    return text.md5();\n}", "{\n    Nullable<string> md5 = null;", "{\n\
    \    if (text.length == 0)\n        return null;\n    using md5 = md5_c; // use\
    \ std.md5\n    md5 md = md5_init();\n    md5_append(md, (const byte *)text.c_str(),\
    \ text.size());\n    byte hash[32];\n    md5_finish(md, hash);\n    stringstream\
    \ ss;\n    \n    for(int i = 0; i < 32; i++)\n    {\n        ss << hex << hash[i];\n\
    \    }\n    \n    return ss.str();\n}\n/*", "{\n    int hash;\n    \n    if (text\
    \ == \"\")\n        return Nullable!(string);\n    \n    hash = md5(text);\n \
    \   \n    return Nullable!(string){\n        \"0x\" + hexstring(hash),\n    };\n\
    }", "{\n  if (text.length <= 0) return null;\n  var md5_value = md5(text);\n \
    \ return new string(\"${md5_value}\");\n}", "{\n    return null!=text?hash(string_to_bin(text)):null;\n\
    }\n/* Returns the MD5 hash of binary data. \n*/\nNullable!(byte[]) string_to_md5(byte[]\
    \ data) {\n    return null!=data?hash(data):null;\n}", "{\n\tif (text == null\
    \ || text.length == 0)\n\t\treturn null;\n\tconst uint32 len = text.length();\n\
    \tconst uint32 h0 = MD5_HASH(text.asBytes(), len);\n\tconst uint32 h1 = MD5_HASH(text.asBytes(),\
    \ len - 8);\n\treturn new Nullable!(char[64]);\n}\n'''", "{\n    if(text.isEmpty())\n\
    \        return null;\n    return md5.hash(text);\n}\n/*", "{\n    if (text !=\
    \ \"\")\n        return hash_string(text);\n    return null;\n}", "{\n    \n \
    \   Nullable!(string) md5 = null;\n    \n    if (text != \"\")\n    {\n      \
    \  md5 = text;\n    }\n    else\n    {\n        md5 = null;\n    }\n    \n   \
    \ return md5;\n}\n/*", "{\n\trequire(text.length > 0, text, \" text cannot be\
    \ an empty string\");\n\t\n\tstring result = md5(text);\n\tif (result == null)\n\
    \t\treturn null;\n\t\n\treturn result;\n}", "{\n    if(text==\"\")\n    {\n  \
    \      return null;\n    }\n    else\n    {\n        string hash=std.sha1(text.asBytes());\n\
    \        return hash;\n    }\n}", "{\n    Nullable hash = md5();\n    \n    if\
    \ (text.Length > 0) {\n        hash = md5.Transform(text.AsCharArray(), text.Length);\n\
    \    }\n    \n    return hash;\n}", "{\n    if (text.length == 0)\n        return\
    \ null;", "{\n    text is null => null;\n    text is string s => _md5.hash(s);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is by far the most elegant solution, thanks!\
    \ I added a couple of improvements I made after I finished implementing this.\n\
    <|/ c |>\n<| c |>\nI did some tests and found that MD5 has a few issues on some\
    \ platforms (eg. Python, C#). So I made my own version, which is not that difficult\
    \ after all.\n<|/ c |>\n<| c |>\nThe implementation of string_to_md5() is missing\
    \ a return statement; I added one and a test run is now passing in Python, Scala,\
    \ and C#. \nThe main reason for using Nullable is because null is not supported\
    \ by md5 hashing.\n<|/ c |>\n<| c |>\nThe string conversion should be done with\
    \ 'text' instead of 's'. The `s => ` part of the function definition is where\
    \ you should put your string conversion logic.\n<|/ c |>\n<| a dscore=5 |>\nThe\
    \ best way I have found to do this is to run md5hash on a byte array. \n<code>\n\
    md5hash(\"hello\".getBytes(\"UTF-8\"))\n</code>\n<|/ a tags=md5,hash,java |>\n\
    <| c |>\nThis is actually the best way as it will work on any character encoding\
    \ (UTF-8, Latin-1, etc). It doesn't require you to encode it before hashing.\n\
    <|/ c |>\n<| c |>\nThis is what I am looking for, thanks. One could also pass\
    \ 'null' instead of 'String' if you don't want to encode it.\n<|/ c |>\n<| c |>\n\
    It will work on all encodings except UTF-16, UTF-32, UTF-8 and UTF-7, but only\
    \ if you use a non-ASCII character for example.\n<|/ c |>\n<| c |>\nIt won't work\
    \ with multibyte encodings, for example Chinese\n<|/ c |>\n<| c |>\nthis won't\
    \ work if your String contains characters like a Chinese word or punctuation marks\
    \ because md5hash method doesn't support Chinese characters\n<|/ c |>\n<| a dscore=5\
    \ tags=md5,hash,java |>\nAs of Java 11, the java.util.Base64 class is available.\n\
    It can be used to encode the String into a byte array.\nThe standard library also\
    \ includes a utility class called Base64Utils, for base64 encoding and decoding\
    \ operations.\n<|/ a |>\n<| c |>\nThis is an excellent answer. But if you're "]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
