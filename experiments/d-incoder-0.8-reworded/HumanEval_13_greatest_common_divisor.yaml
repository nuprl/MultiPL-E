name: HumanEval_13_greatest_common_divisor
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Return a greatest common divisor\
  \ of two integers a and b\n    >>> greatest_common_divisor(3L, 5L)\n    1L\n   \
  \ >>> greatest_common_divisor(25L, 15L)\n    5L\n    \n*/\nlong greatest_common_divisor(long\
  \ a, long b) \n"
tests: "unittest\n{\n    alias candidate = greatest_common_divisor;\n\n    assert(candidate(3L,\
  \ 7L) == 1L);\n    assert(candidate(10L, 15L) == 5L);\n    assert(candidate(49L,\
  \ 14L) == 7L);\n    assert(candidate(144L, 60L) == 12L);\n}\nvoid main(){}"
completions: ["{\n    // TODO: Optimize this for integer types. \n    long gcd = 1;\n\
    \    while (a > 0 && b > 0)\n    {\n        if ((a & 1) == 0)\n        {\n   \
    \         a >>= 1;\n            gcd *= a;\n        }\n        if (b & 1)\n   \
    \     {\n            b >>= 1;\n            gcd *= b;\n        }\n        a >>=\
    \ 1;\n        b >>= 1;\n    }\n    return gcd;\n}", "{\n\tif (a == 0)\n\t\treturn\
    \ b;\n\tif (b == 0)\n\t\treturn a;\n\tlong g = gcd(a, b);\n\tif (g == 1)\n\t\t\
    return a;\n\treturn g;\n}", "{\n\treturn a > b ? greatest_common_divisor(b, a)\
    \ : a;\n}", "{\n\tif (a == 0) return b;\n\tif (b == 0) return a;\n\t\n\twhile\
    \ (a != b)\n\t{\n\t\tif (a > b) \n\t\t\ta %= b;\n\t\telse \n\t\t\tb %= a;\n\t\
    }\n\treturn a;\n}\n/*\n Return the least common multiple of two integers a and\
    \ b\n    >>> least_common_multiple(5L, 7L)\n    25L\n    \n*/\nlong least_common_multiple(long\
    \ a, long b) \n{\n\tlong m = a;\n\tfor (long n = b; n != 0; n--)\n\t\tm += n %\
    \ m;\n\t\n\treturn m;\n}", "{\n    return std.math.gcd(a, b);\n}", "{\n    return\
    \ gcd(a, b);\n}\n/*\n Calculate the least common multiple of two integers a and\
    \ b\n    >>> least_common_multiple(2L, 3L)\n    6L\n    >>> least_common_multiple(5L,\
    \ 2L)\n    15L\n    \n*/\nlong least_common_multiple(long a, long b) \n{\n   \
    \ long x = a * b;\n    while (x > 0) {\n        long r = x % a;\n        x = a;\n\
    \        a = r;\n    }\n    return a;\n}\n/*\n Return the smallest number of two\
    \ integers a and b that is a multiple of\n each other. Two integers a and b are\
    \ said to be multiples of a and b if a\n and b are both divisible by each other.\
    \ \n    >>> smallest_multiple_of_three(15L, 10L)\n    1L\n    >>> smallest_multiple_of_three(2L,\
    \ 4L)\n    2L\n    \n*/\nlong smallest_multiple_of_three(long a, long b) \n{\n\
    \    long r1 = a % 3;\n    long r2 = b % 3;\n    return least_common_multiple(r1,\
    \ r2);\n}\n/*\n Return the largest integer that is evenly divisible by all integers\
    \ from a\n to b.\n    >>> largest_even_multiple_of(20L, 10L)\n    20L\n    \n\
    */\nlong largest_even_multiple_of(long a, long b) \n{\n    long x;\n    x = 31L;\n\
    \    while (x >= b) \n    {\n        if (x % 2 == 0) \n        {\n           \
    \ x = x + 1L;\n        }\n        else \n        {\n            x = x + 1L;\n\
    \        }\n    }\n    return a;\n}", "{\n\tif (a < b) {\n\t\ta %= b;\n\t\tfor\
    \ (int i = 0; i < b; ++i)\n\t\t\tif (a % b == 0)\n\t\t\t\tbreak;\n\t\treturn b;\n\
    \t}\n\tif (b < a) {\n\t\tb %= a;\n\t\tfor (int i = 0; i < a; ++i)\n\t\t\tif (b\
    \ % a == 0)\n\t\t\t\tbreak;\n\t\treturn a;\n\t}\n\tlong temp = a;\n\twhile (true)\
    \ {\n\t\ta %= b;\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\tb %= a;\n\t}\n}", "{\n\
    \tlong r = a % b;\n\tlong tmp;\n\twhile (r != 0)\n\t{\n\t\ttmp = r;\n\t\tr = b%r;\n\
    \t\tb = tmp;\n\t}\n\treturn b;\n}", "{\n    long rem;\n    while (b != 0)\n  \
    \  {\n        rem = a % b;\n        a = b;\n        b = rem;\n    }\n    return\
    \ a;\n}", "{\n  if (a == 0)\n    return b;\n  if (b == 0)\n    return a;\n  if\
    \ (a < b) {\n    long temp = a;\n    a = b;\n    b = temp;\n  }\n  if (b == 0)\n\
    \    return a;\n  if (b == 1)\n    return a;\n  long r = 0L;\n  long t = a;\n\
    \  while (b > 0L) {\n    r = b;\n    t = t;\n    while (r != 0L) {\n      long\
    \ x = r;\n      r = t % x;\n      t = x;\n    }\n    b = r;\n  }\n  return t;\n\
    }", "{\n    return greatest_common_divisor(a, b, c);\n}", "{\n    long gcd = 1;\n\
    \    for (long i=1; i<=a; i+=i) \n    {\n        long t = b / i;\n        if (t\
    \ >= gcd) gcd = t;\n    }\n    return gcd;\n}", "{\n    long n = a;\n    while\
    \ (n > b)\n    {\n       n = n%b;\n    }\n    return b;\n}\n*/\n/*\n Returns the\
    \ smallest common denominator of a and b\n*/\nlong min_common_divisor(long a,\
    \ long b) \n{\n    // The idea is to divide a and b to make sure you get the smallest\
    \ common denominator\n    // a >= b (since a is the common factor)\n    // if\
    \ a/b > 1 then a is at least as large as b\n    // if a/b > 1 then a = b\n   \
    \ // if a/b == 1 then a = b\n    // a = b\n    long l = (a / b) % 10;\n    if\
    \ (l == 0) \n    {\n        l = (b / a) % 10;\n    }\n    return l;\n}\n/*\n Returns\
    \ the greatest common denominator of a and b\n*/\nlong greatest_common_divisor_long(long\
    \ a, long b) \n{\n    long l = min_common_divisor(a, b);\n    while (l > 1) \n\
    \    {\n       l = (a / l) % 10;\n    }\n    return l;\n}\n/*\n Returns floor(log2(a))\n\
    */\nlong log2(long a)\n{\n    return floor(log(a) / log(_2));\n}\n/*\n Returns\
    \ the least common multiple of two integers a and b\n*/\nlong least_common_multiple(long\
    \ a, long b) \n{\n    long d = greatest_common_divisor_long(a, b);\n    long x\
    \ = 1;\n    while (d != 0)\n    {\n       x = x * d;\n       d = d % 10;\n   \
    \ }\n    return x;\n}\n/*\n Returns gcd(a, b)\n*/\nlong gcd(long a, long b)\n\
    {\n    long c;\n    if (a != 0)\n    {\n       while (a != b)\n       {\n    \
    \      c = a;\n          a = b;\n          b = c;\n       }\n    }\n    return\
    \ b;\n}\n/*\n Returns the next perfect power of 2 greater than or equal to a\n\
    */\nlong next_power_of_2(long a) \n{\n    while (1)\n    {\n        if (a <= 1)\
    \ \n        {\n            return a;\n        }\n        a = 2 * a;\n    }\n}\n\
    /*\n Returns the next power of 2 that is >= a power of 2\n*/\nlong next_power_of_2_long(long\
    \ a) \n{\n    while (1)\n    {\n        if (a < _2) \n        {\n            return\
    \ a;\n        }\n        a = 2 * a;\n    }\n}\n/*\n Returns the smallest power\
    \ of 2 that is >= a\n*/\nlong next_power_of_2_long(long ", "{\n    return std.math.reciprocal(b)\
    \ * std.math.reciprocal(a);\n}\n/*\n Return true if a is divisible by b\n */",
  "{\n    return std.math.gcd(a, b);\n}", "{\n\tlong i, q, b, d;\n\t\n\tq = (a%b);\
    \ a = b;\n\tb = a;\n\ta = q;\n\t\n\tfor (d = b; d != 0; d /= 2) { q = (d%b); b\
    \ = d; d = q; }\n\t\n\treturn a;\n}", "{\n\tif (a == 0 || b == 0)\n\t\treturn\
    \ 0;", "{\n    long nDiv = (long)Math.gcd(a, b);\n    return ((a % nDiv) + (b\
    \ % nDiv)) % nDiv;\n}", "{\n\tlong gcd;\n\tif (a == 0)\n\t\treturn b;\n\tif (b\
    \ == 0)\n\t\treturn a;\n\tgcd = __gcd(a, b);\n\tif (gcd == 0)\n\t\treturn __gcd(b,\
    \ a);\n\telse\n\t\treturn gcd;\n}\n/*\n Return the least common multiple of 2\
    \ integers a and b\n    >>> least_common_multiple(3L, 5L)\n    3L\n    \n*/\n\
    long least_common_multiple(long a, long b)\n{\n\treturn (b * b) / __gcd(a, b);\n\
    }\n/*\n Compare a to b, returning -1 if b < a, 0 if a = b, +1 if b > a\n*/", "{\n\
    \    int gcd;\n    long x, y;\n    \n    if (a < 0)\n    {\n        std.timer.stop(\"\
    greatest_common_divisor\");\n        return std.pow(a, (long)(-b - 1));\n    }\n\
    \    if (b < 0)\n    {\n        std.timer.stop(\"greatest_common_divisor\");\n\
    \        return std.pow(b, (long)(-a - 1));\n    }\n    x = a;\n    y = b;\n \
    \   gcd = 0;\n    while (y != 0)\n    {\n        x %= y;\n        gcd++;\n   \
    \     y /= x;\n    }\n    return gcd;\n}", "{\n    if (a>b) return greatest_common_divisor(b,a);\n\
    \    if (b == 0)\n        return a;\n    long c = a;\n    while (true)\n    {\n\
    \        while (b > 0)\n        {\n            c += b;\n            if (c == a)\
    \ return c;\n            b /= 2;\n        }\n        return 0;\n    }\n}", "{\n\
    \    if (a < 0) return 0;\n    if (b < 0) return 0;\n    if (a == 0) return b;\n\
    \    if (b == 0) return a;\n    if (a > b) std.swap(a,b);\n    if (a < b) std.swap(a,b);\n\
    \    long gcd = a; \n    while (true)\n    {\n        long m = (gcd % b); \n \
    \       if (m == 0) return gcd;\n        if (m == b) break;\n        gcd = m;\
    \ \n    }\n    return 0;\n}", "{\n  // Write your code here.\n}\n*/", "{\n\tlong\
    \ x, y, z;\n\tif(a==0 || b==0)\n\t\treturn 0;\n\tx=a;\n\ty=b;\n\twhile((x%y)!=0)\
    \ {\n\t\tx++;\n\t\tif(z==0)\n\t\t\tz=1;\n\t\telse\n\t\t\tz=0;\n\t}\n\treturn x;\n\
    }", "{\n    long t;\n    while (b > 0) {\n        if (a % b == 0) {\n        \
    \    t = b;\n            b = a / b;\n            a = t;\n        } else {\n  \
    \          b--;\n        }\n    }\n    return a;\n}", "{\n\tlong gcd =1;\n\twhile(a\
    \ && b)\n\t{\n\t\tif(a%b == 0)\n\t\t{\n\t\t\tgcd = b;\n\t\t\tbreak;\n\t\t}\n\t\
    \telse if(b%a == 0)\n\t\t{\n\t\t\tgcd = a;\n\t\t\tbreak;\n\t\t}\n\t\ta = a/b;\n\
    \t\tb = b/a;\n\t}\n\treturn gcd;\n}", "{\n  if(b == 0)\n    return a;\n  return\
    \ greatest_common_divisor(b, a % b);\n}\n#endif\n\"\"\"", "{\n\tlong max = 1;\n\
    \twhile (b > 0) {\n\t\tif (b&1) {\n\t\t\ta = b*a > max ? a*2 : b*a;\n\t\t} else\
    \ {\n\t\t\ta = b*a > max ? a : b*a;\n\t\t}\n\t\tb = b>>1;\n\t\tmax = greatest_common_divisor(max,a);\n\
    \t}\n\treturn max;\n}", "{\n    if(a == 0 || b == 0) \n        return 0;\n   \
    \ \n    // find GCD\n    long gcd = __gcd(a, b);\n    \n    // return if b is\
    \ smaller than a\n    if(b < a)\n        gcd = __gcd(b, a);\n    \n    return\
    \ gcd;\n}", "{\n\tint gcf = 1;\n\twhile (b) {\n\t\tlong t = a % b;\n\t\tif (t\
    \ != 0) gcf = gcd(gcf, t);\n\t\ta = b;\n\t\tb = t;\n\t}\n\treturn gcf;\n}", "{\n\
    \    long m;\n    if(a<b) std.swap(a, b);\n    m = a % b;\n    if(a<b) std.swap(a,\
    \ m);\n    return m;\n}", "{\n    if (a == 1) return b;\n    if (b == 1) return\
    \ a;\n    long gcd = __gcd(a, b);\n    while (__gcd(a, __gcd(b, gcd)) == gcd)\n\
    \    {\n        a = __gcd(a, gcd)*__gcd(b, gcd)*__gcd(gcd, a);\n        b = __gcd(b,\
    \ gcd)*__gcd(gcd, b);\n        gcd = __gcd(gcd, a);\n    }\n    return gcd > 1\
    \ ? gcd(a, b) : 1;\n}", "{\n    long x;\n    long y;\n    if(b == 0) return a;\n\
    \    for(x = 1; x < (a * b + 1) / b; x++) {\n        y = x * b;\n        y = y\
    \ - (a / y);\n        if(y >= b) break;\n    }\n    return y;\n}", "{\n    long\
    \ long gcd = a;\n    while (b > 0) {\n        long long tmp = a;\n        a =\
    \ b;\n        b = tmp % b;\n        gcd = gcd*b;\n    }\n    return gcd;\n}",
  "{\n  // assert(a < b);\n  // assert(b != 0);\n  long remainder = a%b;\n  if (remainder\
    \ > 0) return greatest_common_divisor(b, remainder);\n  else return b;\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis algorithm works but has a high runtime complexity.\
    \  I would imagine a better algorithm would have less runtime complexity since\
    \ it would be a lot faster if it could stop after knowing the greatest common\
    \ divisor.  I wrote a Python version of this algorithm, but it was slower than\
    \ the C++ implementation.\n<|/ c |>\n<| c |>\nYes, I know. I've written my own\
    \ `gcd` implementation, but I just wanted to show that other algorithms exist.\
    \ Thanks for the downvote, though.\n<|/ c |>\n<| c |>\nThe algorithm is too slow\
    \ for large numbers, because it has a high time complexity. Using `std::gcd_lcm`\
    \ does not change that.\n<|/ c |>\n<| c |>\nThe algorithm is slower than the std::gcd_lcm\
    \ implementation because it does extra work.", "{\n\t\n\tif(a < b) \n\t{\n\t\t\
    a = b; \n\t}\n\tint i = 1;\n\twhile(a > 0 && b > 0)\n\t{\n\t\tif((a & 1) == (b\
    \ & 1))\n\t\t{\n\t\t\ta = a >> 1; \n\t\t\tb = b >> 1; \n\t\t}\n\t\telse \n\t\t\
    {\n\t\t\ta = a >> 1; \n\t\t}\n\t\t++i;\n\t}\n\treturn (long) i;\n}", "{\n\tlong\
    \ d = a%b;\n\ta /= b;\n\tif (a==0) return b;\n\twhile (a != d) {\n\t\ta /= b;\n\
    \t\tif (a==0) return b;\n\t}\n\treturn a;\n}", "{\n\tlong d;\n\tif(b==0) return\
    \ a;\n\tif(a<b) std.swap(a,b);\n\td=a%b;\n\tif(a<b) std.swap(a,b);\n\treturn d;\n\
    }", "{\n  if(b == 0)\n    return a;\n  if(b > a)\n  {\n    long temp = a;\n  \
    \  a = b;\n    b = temp;\n  }\n  return greatest_common_divisor(b, a % b);\n}",
  "{\n    /* Compute gcd of a,b using the binary method */\n    int gcd;\n    if (b\
    \ == 0) {\n        gcd = a;\n    } else {\n        gcd= greatest_common_divisor(b,\
    \ a % b);\n    }\n    /* Return gcd */\n    return gcd;\n}\n/*\n Return number\
    \ of factors of n in number\n    >>> number_of_factors(3L)\n    0\n    >>> number_of_factors(7L)\n\
    \    2\n    >>> number_of_factors(29L)\n    2\n    \n*/", "{\n\tlong x = 0;\n\t\
    long y = 0;\n\t\n\twhile(a != 0)\n\t{\n\t\tx = (x << 1) + (a & 1);\n\t\ty = a\
    \ >> 1;\n\t\ta = y;\n\t}\n\t\n\twhile(x != 0 && b != 0)\n\t{\n\t\tx = x >> 1;\n\
    \t\ty = y >> 1;\n\t\tif(b & 1)\n\t\t\tx = x|y;\n\t\tb = b >> 1;\n\t}\n\t\n\treturn\
    \ x;\n}", "{\n\treturn a.gcdOf(b);\n}", "{\n\tlong gcd;\n\tbool b_is_large, a_is_large;\n\
    \t\n\tb_is_large = a>b; // Is the number too big to fit in long?\n\ta_is_large\
    \ = a<b;\n\t\n\tif(a_is_large)\n\t{\n\t\treturn greatest_common_divisor(b,a);\n\
    \t}\n\telse\n\t{\n\t\tif(b == 0)\n\t\t{\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tfor(;\
    \ b > 0; b /= 10)\n\t\t{\n\t\t\tif(a%b == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t\
    }\n\t\t}\n\t\t\n\t\tgcd = b;\n\t\t\n\t\tif(b_is_large)\n\t\t{\n\t\t\twhile(a/gcd\
    \ >= b) \n\t\t\t{\n\t\t\t\tgcd *= 10;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\
    while(a/gcd <= b) \n\t\t\t{\n\t\t\t\tgcd /= 10;\n\t\t\t}\n\t\t}\n\t\treturn gcd;\n\
    \t}\n}", "{\n    return std.math.gcd(a, b);\n}\n/*\n Return a least common multiple\
    \ of two integers a and b\n    >>> least_common_multiple(3L, 5L)\n    3L\n   \
    \ >>> least_common_multiple(25L, 15L)\n    30L\n    \n*/\nlong least_common_multiple(long\
    \ a, long b) \n{\n    return std.math.lcm(a, b);\n}\n/*\n Return the factorial\
    \ of n\n    \n    Factorial(n) = 0  if n<=1\n    Factorial(n) = n*Factorial(n-1)\
    \  if n>=2\n    \n*/\nlong factorial(long n) \n{\n    switch(n) {\n        case\
    \ 0:\n            return 1;\n        case 1:\n            return 1;\n        default:\n\
    \            return n * factorial(n-1);\n    }\n}\n/*\n Return the nth Fibonacci\
    \ number\n    \n    Fibonacci(n) = 0  if n<=1\n    Fibonacci(n) = 1 if n<=2\n\
    \    Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2)\n    \n*/\nlong fibonacci(long\
    \ n) \n{\n    if(n == 0) {\n        return 0;\n    } else if(n == 1) {\n     \
    \   return 1;\n    } else if(n == 2) {\n        return 1;\n    } else {\n    \
    \    return fibonacci(n-1) + fibonacci(n-2);\n    }\n}\n/*\n Return the nth Euler\
    \ number\n    \n    Euler(n) = 0  if n<=1\n    Euler(n) = 1  if n<=2\n    Euler(n)\
    \ = Euler(n-1) + Euler(n-2)\n    \n*/\nlong euler(long n) \n{\n    if(n == 0)\
    \ {\n        return 0;\n    } else if(n == 1) {\n        return 1;\n    } else\
    \ if(n == 2) {\n        return 2;\n    } else {\n        return euler(n-1) + euler(n-2)\n\
    \    }\n}\n/*\n Return the nth Lambert number\n    \n    Lambert(n) = 0  if n<=1\n\
    \    Lambert(n) = 1  if n<=2\n    Lambert(n) = Lambert(n-1) + Lambert(n-2)\n \
    \   \n*/\nlong lambert(long n) \n{\n    if(n == 0) {\n        return 0;\n    }\
    \ else if(n == 1) {\n        return 1;\n    } else if(n == 2) {\n        return\
    \ 1;\n    } else {\n        return lambert(n-1) + lambert(n-2)\n    }\n}\n/*\n\
    \ Return a ", "{\n\tint d = 0;\n\twhile(b) {\n\t\tif(b % a == 0) {\n\t\t\tb =\
    \ a / b;\n\t\t} else {\n\t\t\ta = b;\n\t\t}\n\t}\n\treturn a;\n}", "{\n  long\
    \ x;\n  if (a>=0 && b>=0) {\n    x=a%b;\n    if (x>=0) \n      return greatest_common_divisor(b,x);\n\
    \    else\n      return b;\n  }\n  else \n    return b;\n}", "{\n    /*\n    Find\
    \ the GCD of a and b and return the result rounded to the closest integer.\n \
    \   The algorithm is described in Algorithm 1 of HAC by Rhodes 1972.\n    */\n\
    \    long r;\n    while(b != 0)\n    {\n        r = a % b;\n        a = b;\n \
    \       b = r;\n    }\n    return a;\n}", "{\n\tstd.typecons.Long r = std.math.gcd(a,\
    \ b);\n\treturn std.typecons.Long(r.s, r.e);\n}", "{\n    if( a==0)\n        return\
    \ b;\n    if( b==0)\n        return a;\n    if(a > b)\n        std.swap(a, b);\n\
    \    long temp = a%b;\n    return greatest_common_divisor(b,temp);\n}", "{\n \
    \   return a%b;\n}\n/*\n Return True if the two integers a and b are equal, False\
    \ if they are not\n    \n*/", "{\n    if (a == 1)\n        return b;\n    else\
    \ if (b == 1)\n        return a;\n    else if (a < 0)\n        return greatest_common_divisor(b,\
    \ a);\n    else if (b < 0)\n        return greatest_common_divisor(a, b);\n  \
    \  else if (a > b)\n        return greatest_common_divisor(a, b);\n    else if\
    \ (a == 1)\n        return b;\n    else if (b == 1)\n        return a;\n    else\
    \ if (a > b)\n        return greatest_common_divisor(a, b);\n    else\n      \
    \  return greatest_common_divisor(b, a);\n}", "{\n    return std.math.gcd(a, b);\n\
    }\n/*\n Return a least common multiple\n    >>> lcm(3L, 4L)\n    6L\n    \n*/\n\
    long lcm(long a, long b) \n{\n    return std.math.lcm(a, b);\n}\n/*\n Convert\
    \ an integer to a string\n    >>> str(1L)\n    \"1\"\n    >>> str(12345L)\n  \
    \  \"12345\"\n*/\nstring str(long a)\n{\n    return to_string(std.conv.to!int,\
    \ a);\n}\n/*\n A tuple where each element is the sum of two tuples.\n    >>> t\
    \ = (1, 2, 3)\n    >>> t\n    (3, 2, 3)\n    \n*/\ntuple<> sum(tuple<> a, tuple<>\
    \ b)\n{\n    return std.tuple.zip(a, b).map([](int i, int j) { return i + j; });\n\
    }\n/*\n A tuple where each element is the difference of two tuples.\n    >>> t\
    \ = (1, 2, 3)\n    >>> t\n    (1, 2, 3)\n    \n*/\ntuple<> diff(tuple<> a, tuple<>\
    \ b)\n{\n    return std.tuple.zip(a, b).map([](int i, int j) { return i - j; });\n\
    }\n/*\n A tuple where each element is the product of two tuples.\n    >>> t =\
    \ (1, 2, 3)\n    >>> t\n    (1, 2, 3)\n    \n*/\ntuple<> prod(tuple<> a, tuple<>\
    \ b)\n{\n    return std.tuple.zip(a, b).map([](int i, int j) { return i * j; });\n\
    }\n/*\n A tuple where each element is the maximum value of two tuples.\n    >>>\
    \ t = (1, 2, 3)\n    >>> t\n    (1, 2, 3)\n    \n*/\ntuple<> max(tuple<> a, tuple<>\
    \ b)\n{\n    return std.tuple.zip(a, b).map([](int i, int j) { return max(i, j);\
    \ });\n}\n/*\n A tuple where each element is the minimum value of two tuples.\n\
    \    >>> t = (1, 2, 3)\n    >>> t\n    (1, 2, 3)\n    \n*/\ntuple<> min(tuple<>\
    \ a, tuple<> b)\n{\n    return std.tuple.zip(a, b).map([](int i, int j) { return\
    \ min(i, j); });\n}\n/*\n A tuple where each element is the absolute value of\
    \ two tuples.\n    >>> t = (1, 2, 3)\n    >>> t\n    (1, 2, 3)\n    \n*/\ntuple<>\
    \ abs(tuple<> a)\n{\n    return std.tuple.zip(a).map([](int i) { return abs(i);\
    \ });\n}\n/*\n A tuple where each element is the factorial of its index.\n   \
    \ >>> t = ", "{\n  if(a%b == 0)\n    return b;\n  if(b%a == 0)\n    return a;\n\
    \  long r1 = greatest_common_divisor(b, a % b);\n  long r2 = greatest_common_divisor(a,\
    \ b % a);\n  if(r2 == 0)\n    return r1;\n  return r1 * r2;\n}", "{\n\tlong x,\
    \ y, q, r, res;", "{\n\tif (a == 0 || b == 0)\n\t{\n\t\treturn 0;\n\t}\n\tlong\
    \ res = 1;\n\twhile (a != b)\n\t{\n\t\tif (a > b)\n\t\t{\n\t\t\ta -= b;\n\t\t\
    }\n\t\telse\n\t\t{\n\t\t\tb -= a;\n\t\t}\n\t\tres *= a;\n\t}\n\treturn res;\n\
    }\n/*\n Return the least common multiple of two integers a and b\n    >>> least_common_multiple(5L,\
    \ 9L)\n    3L\n    \n*/\nlong least_common_multiple(long a, long b)\n{\n\tlong\
    \ gcd = greatest_common_divisor(a, b);\n\tlong lcm = 1;\n\twhile (gcd != 0)\n\t\
    {\n\t\tif (a / gcd > b)\n\t\t{\n\t\t\tgcd = b / gcd;\n\t\t}\n\t\telse\n\t\t{\n\
    \t\t\tgcd = a / gcd;\n\t\t}\n\t\tlcm *= gcd;\n\t}\n\treturn lcm;\n}\n/*\n Return\
    \ the least common multiple of two integers a and b using the \n Euclid's algorithm\n\
    \    >>> euclid_lcm_euclid(4L, 6L)\n    16L\n    \n*/\nlong euclid_lcm_euclid(long\
    \ a, long b)\n{\n\tlong res = 1;\n\twhile (b != 0)\n\t{\n\t\tif (a % b != 0)\n\
    \t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tres *= a;\n\t\ta /= b;\n\t}\n\treturn res;\n\
    }\n/*\n Return the least common multiple of two integers a and b using the \n\
    \ Euler's algorithm\n    >>> euclid_lcm_euler(4L, 6L)\n    16L\n    \n*/\nlong\
    \ euclid_lcm_euler(long a, long b)\n{\n\tlong res = 1;\n\twhile (b != 0)\n\t{\n\
    \t\tif (a % b != 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tres *= a;\n\t\ta /= b;\n\
    \t\tb--;\n\t}\n\treturn res;\n}\n/*\n Return the least common multiple of two\
    \ integers a and b using the \n Greatest common divisor\n    >>> euclid_lcm_greatest_common_divisor(3L,\
    \ 5L)\n    1L\n    >>> euclid_lcm_greatest_common_divisor(25L, 15L)\n    5L\n\
    \    \n*/\nlong euclid_lcm_greatest_common_divisor(long a, long b)\n{\n\tif (a\
    \ == 0 || b == 0)\n\t{\n\t\treturn 0;\n\t}\n\tlong res = 1;\n\twhile (a != b)\n\
    \t{\n\t\tif (a > b)", "{\n    long m;\n    while (a != 0) \n    {\n        m =\
    \ a;\n        a = b / a;\n        b = m;\n    }\n    return b;\n}\n/*\n Return\
    \ the least common multiple of a and b\n    >>> least_common_multiple(2L, 4L)\n\
    \    2L\n    >>> least_common_multiple(5L, 6L)\n    6L\n*/\nlong least_common_multiple(long\
    \ a, long b) \n{\n    long m;\n    while (a != 0) \n    {\n        m = a;\n  \
    \      a = b / a;\n        b = m;\n    }\n    return b;\n}\n/*\n Return the number\
    \ of digits in the given string\n    >>> count_digits(\"\"L)\n    0L\n    >>>\
    \ count_digits(\"123\")\n    3L\n    \n*/\nlong count_digits(string x) \n{\n \
    \   long count = 0;\n    for (int i = 0; i < x.length; ++i)\n    {\n        if\
    \ (x[i] >= '0' && x[i] <= '9')\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}", "{\n  long x;\n  if(b == 0)\n    return a;\n  x\
    \ = gcd(a,b);\n  return x % b;\n}\n/*\n Return a least common multiple of two\
    \ integers a and b\n    >>> least_common_multiple(3L, 5L)\n    3L\n    \n*/\n\
    long least_common_multiple(long a, long b) \n{\n  long x;\n  if(b == 0)\n    return\
    \ a;\n  x = lcm(a,b);\n  return x;\n}\n/*\n Return an infinity of the form (a\
    \ * i) / (b * i)\n    >>> infinity(5L, 15L)\n    inf\n    \n*/\nlong infinity(long\
    \ a, long b) \n{\n  return a * b / (a * b + 1);\n}\n/*\n Return an infinity of\
    \ the form (a / b) * b\n    >>> infinity(5L, 15L)\n    inf\n    \n*/\nlong infinity2(long\
    \ a, long b) \n{\n  return a * b;\n}\n/*\n Return the floor of a float\n    >>>\
    \ floor(2.5) == 1\n    True\n    \n*/\nlong floor(double x) \n{\n  long i;\n \
    \ i = (long)floor(x);\n  if(isnan(x))\n    return i;\n  if(i < 0)\n    i += long(pow(double(LONG_MIN),\
    \ -1L));\n  \n  return i;\n}\n/*\n Return the ceil of a float\n    >>> ceil(2.5)\
    \ == 1\n    True\n    \n*/\nlong ceil(double x) \n{\n  long i;\n  i = (long)ceil(x);\n\
    \  if(isnan(x))\n    return i;\n  if(i < 0)\n    i += long(pow(double(LONG_MIN),\
    \ -1L));\n  \n  return i;\n}\n/*\n Return the natural logarithm of a float\n \
    \   >>> log(4.0)\n    2.0\n    \n*/\ndouble log(double x) \n{\n  return log(x)\
    \ * double(LOG_BASE);\n}\n/*\n Return the base 2 log of a double\n    >>> log2(4.0)\n\
    \    2.0\n    \n*/\ndouble log2(double x) \n{\n  return log(x) / double(LOG_BASE);\n\
    }\n/*\n Return the base 10 log of a double\n    >>> log10(4.0)\n    2.0\n    \n\
    */\ndouble log10(double x) \n{\n  return log(x) / double(LOG_BASE);\n}\n/*\n Return\
    \ the base e log of a double\n    >>> log10e(4.0)\n    2.0\n    \n*/\ndouble log10e(double\
    \ x) \n{\n  return log(x) / double(LOG", "{\n    if (b == 0)\n        return a;\n\
    \    else\n        return greatest_common_divisor(b, a % b);\n}", "{\n    if (a\
    \ < b) \n    {\n        long maxdiv = a;\n        while ((maxdiv / b) != (a/b))\
    \ \n            maxdiv = b;\n        return maxdiv;\n    }\n    \n    long maxdiv\
    \ = b;\n    while ((maxdiv / a) != (b / a)) \n        maxdiv = a;\n    return\
    \ maxdiv;\n}", "{\n\treturn long.gcd(a, b);\n}", "{\n    return ((a % b) < b)\
    \ ? a : b;\n}\n/*\n Return the least common multiple of two integers a and b\n\
    \    >>> least_common_multiple(3L, 5L)\n    3L\n    >>> least_common_multiple(25L,\
    \ 15L)\n    15L\n    \n*/\nlong least_common_multiple(long a, long b) \n{\n  \
    \  return (a * b) / greatest_common_divisor(a, b);\n}", "{\n    long d = 0;\n\
    \    for(; b > 0; b--) \n        d = (d << 1) + (a & 1); \n    return d; \n}",
  "{\n\tif (b == 0)\n\t\treturn a;\n\treturn greatest_common_divisor(b, div(a,b));\n\
    }", "{\n   //assert(a != 0)\n   //assert(b != 0)\n   //assert(a >= 0)\n   //assert(b\
    \ >= 0)\n   //assert(a <= b)\n   //assert(b > 0)\n   \n   long res = a;\n   while(b\
    \ > 0) {\n      if (b & 1) res = res * a;\n      b >>= 1;\n      a = a * 10;\n\
    \   }\n   return res;\n}", "{\n\tlong gcd;\n\tint rem;\n\twhile (b) {\n\t\tgcd\
    \ = a;\n\t\trem = b % gcd;\n\t\ta = gcd;\n\t\tb = rem;\n\t}\n\treturn a;\n}",
  "{\n\tlong greatest = 1;\n\t\n\twhile (a && b)\n\t{\n\t\tif (a > b)\n\t\t\tgreatest\
    \ = b;\n\t\telse\n\t\t\tgreatest = a;\n\t\ta%=greatest;\n\t\tb%=greatest;\n\t\
    }\n\t\n\treturn greatest;\n}", "{\n\tif (a<0) \n\t{\n\t\ta=-a; b=-b;\n\t}\n\t\
    long t;\n\tlong d=a%b;\n\tt=a/b;\n\twhile (d!=0)\n\t{\n\t\ta=b;\n\t\tb=d;\n\t\t\
    d=a%b;\n\t}\n\treturn b;\n}", "{\n    long c;\n    long remainder;\n    c = a;\n\
    \    remainder = b;\n    while (remainder) {\n        if (0 == remainder) {\n\
    \            break;\n        }\n        c = remainder % c;\n        remainder\
    \ = c % b;\n    }\n    return c;\n}", "{\n    return std.math.gcd(a, b);\n}\n\
    /*\n Return a least common multiple of two integers a and b\n    >>> least_common_multiple(3L,\
    \ 5L)\n    3L\n    >>> least_common_multiple(15L, 25L)\n    30L\n*/\nlong least_common_multiple(long\
    \ a, long b)\n{\n    return std.math.lcm(a, b);\n}", "{\n   long r = 1;\n   while\
    \ (b != 0) {\n      long temp = b;\n      b = a % b;\n      a = temp;\n      r++;\n\
    \   }\n   return r;\n}", "{\n    int i;\n    long gcd = 1L;\n    for (i = 0; a\
    \ % i == 0; ++i) {\n        gcd *= i;\n    }\n    gcd *= b / a;\n    if (gcd !=\
    \ 1) {\n        gcd %= b;\n    }\n    return gcd;\n}", "{\n    long x = 3L;\n\
    \    long y = b;\n    while (a > 0 && y > 0) {\n        if (a >= y) {\n      \
    \      x -= y;\n            y /= x;\n        }\n        a /= 2;\n        y /=\
    \ 2;\n    }\n    return x;\n}\n/*\n Find greatest common divisor of two integers\
    \ a and b\n    >>> greatest_common_divisor(3L, 5L)\n    1L\n    >>> greatest_common_divisor(25L,\
    \ 15L)\n    5L\n    \n*/\ndouble greatest_common_divisor(double a, double b) \n\
    {\n    double x = 3.0;\n    double y = b;\n    while (a > 0.0 && b > 0.0) {\n\
    \        if (a > b) {\n            x -= y;\n            y /= x;\n        }\n \
    \       a /= 2;\n        b /= 2;\n    }\n    return x;\n}\n/*\n Find least common\
    \ multiple of two integers a and b\n    >>> least_common_multiple(5L, 10L)\n \
    \   25L\n    >>> least_common_multiple(5L, 3L)\n    15L\n    \n*/\nlong least_common_multiple(long\
    \ a, long b) \n{\n    long x = 1;\n    long y = b;\n    while (b > 0) {\n    \
    \    if (a >= b) {\n            x -= y;\n            y /= x;\n        }\n    \
    \    a /= 2;\n        b /= 2;\n    }\n    return x;\n}\n/*\n Find least common\
    \ multiple of two integers a and b\n    >>> least_common_multiple(5L, 10L)\n \
    \   25L\n    >>> least_common_multiple(5L, 3L)\n    15L\n    \n*/\ndouble least_common_multiple(double\
    \ a, double b) \n{\n    double x = 1;\n    double y = b;\n    while (b > 0.0)\
    \ {\n        if (a >= b) {\n            x -= y;\n            y /= x;\n       \
    \ }\n        a /= 2;\n        b /= 2;\n    }\n    return x;\n}\n/*\n Find smallest\
    \ integer not greater than a\n    >>> smallest_not_greater(9L, 10L)\n    9\n \
    \   >>> smallest_not_greater(9L, 2L)\n    10\n    \n*/\nlong smallest_not_greater(long\
    \ a, long b) \n{\n    long x;\n    if (a >= b) \n        x = a;\n    else\n  \
    \      x = b;\n    while (x > 0) \n    {\n        if (a < x) \n            x =\
    \ a;\n        else\n            return x;\n    }\n    return a;\n}\n/*\n Find\
    \ smallest integer not greater than a\n    >>> smallest_not_greater(9L, 10L)\n\
    \    9\n    >>> smalle", "{\n    return std.math.gcd(a, b);\n}\n/*\n Calculate\
    \ the least common multiple of two integers a and b\n    >>> least_common_multiple(3L,\
    \ 5L)\n    3L\n    >>> least_common_multiple(5L, 2L)\n    2L\n*/\nlong least_common_multiple(long\
    \ a, long b) \n{\n    return std.math.lcm(a, b);\n}\n/*\n Return the factorial\
    \ of a number\n \n   >>> factorial(0)\n    1L\n   >>> factorial(25)\n    265L\n\
    \ \n*/\nlong factorial(long n) {\n    return std.math.factorial(n);\n}\n/*\n Return\
    \ the number of seconds between two dates in milliseconds\n \n   >>> date1 = 'Thu,\
    \ 13 Jul 2003 23:36:49'\n   >>> date2 = 'Thu, 13 Jul 2003 23:50:00'\n   >>> milliseconds_between(date1,\
    \ date2)\n   557600L\n \n*/\nlong milliseconds_between(string date1, string date2)\
    \ {\n    DateTime dt1 = std.datetime.strptime(date1, \"%a, %d %b %Y %H:%M:%S\"\
    );\n    DateTime dt2 = std.datetime.strptime(date2, \"%a, %d %b %Y %H:%M:%S\"\
    );\n    return dt1.time_since_epoch() - dt2.time_since_epoch();\n}\n/*\n Calculate\
    \ the number of seconds between two dates in milliseconds\n \n   >>> date1 = 'Thu,\
    \ 13 Jul 2003 23:36:49'\n   >>> date2 = 'Thu, 13 Jul 2003 23:50:00'\n   >>> milliseconds_between(date1,\
    \ date2)\n   557600L\n \n*/\nlong milliseconds_between(string date1, string date2)\n\
    {\n    DateTime dt1 = std.datetime.strptime(date1, \"%a, %d %b %Y %H:%M:%S\");\n\
    \    DateTime dt2 = std.datetime.strptime(date2, \"%a, %d %b %Y %H:%M:%S\");\n\
    \    return dt1.time_since_epoch() - dt2.time_since_epoch();\n}", "{\n\tlong gcd;\n\
    \tif (a < b) {\n\t\tgdc = a;\n\t\ta = b;\n\t\tb = gcd;\n\t}\n\twhile (b != 0)\
    \ {\n\t\tgdc = b;\n\t\tb = a % b;\n\t\ta = gcd;\n\t}\n\treturn a;\n}", "{\n  \
    \  int gcd = 1;\n    for (; ((a != 0) && (b != 0));) {\n        if ((a & 1) ==\
    \ (b & 1))\n            gcd = (a >> 1) ^ gcd;\n        gcd = (gcd > a) ? (a ^\
    \ gcd) : (gcd ^ gcd);\n        gcd = (gcd > b) ? (b ^ gcd) : (gcd ^ gcd);\n  \
    \      a >>= 1;\n        b >>= 1;\n    }\n    return gcd;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nYour code works, but is not faster than the answer by Joe Z. Your answer\
    \ takes about 6x longer to complete on my machine.\n<|/ c |>\n<| c |>\nYeah, I\
    \ didn't think that far ahead... the only thing that would make this code faster\
    \ is if you didn't have to use a bitmask.\n<|/ c |>\n<| c |>\nI don't think that's\
    \ true. Your code gives me a result of 24 for greatest_common_divisor(5,5); your\
    \ answer gives me 6. Your code does exactly what I want it to do -- find the GCD.\n\
    <|/ c |>\n<| c |>\nI ran my code and the result from my code was 6... what did\
    \ you do to get 6?\n<|/ c |>\n<| c |>\nI ran it again (no compiler on hand, and\
    \ on a different machine) and got 6 from Joe's answer. So perhaps I'm misreading\
    \ something...\n<|/ c |>\n<| a |>\n<code>\nfunction int gcd(int a, int b) \n{\n\
    \    if (b == 0)\n        return a;\n    else\n        return gcd(b, a%b);\n}\n\
    </code>\n<|/ a dscore=2 tags=algorithm,c++ |>\n<| c |>\nHe wants the gcd of two\
    \ numbers, not a function returning the gcd of a and b.\n<|/ c |>\n<| c |>\nYes,\
    \ that's what I'm looking for. The code I posted is what I use now. Thanks.\n\
    <|/ c |>\n<| c |>\nI think this one is correct, but Joe Z's code is faster.\n\
    <|/ c |>\n<| c |>\nI believe the OP wants the gcd of two numbers... I don't think\
    \ it's necessary to post another function to do that.\n<|/ c |>\n<| c |>\nI misread\
    \ the question.  I just thought his code was wrong.\n<|/ c |>\n<| a tags=algorithm,c++\
    \ |>\nThe C++ code I used to verify ", "{\n    long common = 1;\n    while (a\
    \ != 0) {\n        if (a > b)\n            a -= b;\n        else\n           \
    \ b -= a;\n        common++;\n    }\n    return common;\n}", "{\n    return math.gcd(a,\
    \ b);\n}", "{\n\tlong temp = a;\n\twhile (temp > 0) {\n\t\ttemp = (temp % b);\n\
    \t}\n\treturn temp;\n}", "{\n    /*\n     Compute the greatest common divisor\
    \ using Euclid's algorithm,\n     with the invariant that gcd(a, b) == gcd(b,\
    \ a).\n     \n     This is better than using the Euclidean algorithm due to the\n\
    \     fact that it is faster and uses less memory. ", "{\n    long temp = a;\n\
    \    while(b > 0) {\n        temp = temp * b / gcd(a, b);\n        a  = a / gcd(a,\
    \ b);\n        b = b / gcd(a, b);\n    }\n    return temp;\n}", "{\n\tlong tmp;\n\
    \t\n\ttmp = a;\n\twhile (a / b != 0) \n\t{\n\t\ttmp = b;\n\t\tb = a % b;\n\t\t\
    a = tmp;\n\t}\n\treturn a;\n}\n/*\n Return the least common multiple of two integers\
    \ a and b\n    >>> least_common_multiple(3L, 5L)\n    3L\n    >>> least_common_multiple(25L,\
    \ 15L)\n    15L\n*/\nlong least_common_multiple(long a, long b)\n{\n\treturn std.math._mul_long(a,\
    \ greatest_common_divisor(b, a));\n}\n/*\n Return the smallest power of two that\
    \ strictly divides a.\n    >>> (1 << greatest_common_divisor(25, 15)) % 25\n \
    \   12L\n    >>> (1 << greatest_common_divisor(25, 15)) % 10\n    25L\n*/\nlong\
    \ greatest_divisor_power_of_2(long a)\n{\n\treturn std.math.pow(2.0, greatest_common_divisor(a\
    \ >> 1, a & 1));\n}\n/*\n Return a * 2**b where a is an integer and b is an integer.\n\
    \    >>> ((3 * 5) << least_common_multiple(25, 15)) % 25\n    12L\n    >>> ((3\
    \ * 5) << least_common_multiple(25, 15)) % 10\n    25L\n*/\nlong least_divisor_power_of_2(long\
    \ a, long b)\n{\n\treturn std.math._mul_long(std.math.pow(2.0, a), b);\n}\n/*\n\
    \ Return the smallest power of two that divides a and b\n    >>> ((3 * 5) << greatest_divisor_power_of_2(25))\
    \ % 25\n    12L\n    >>> ((3 * 5) << greatest_divisor_power_of_2(25)) % 10\n \
    \   25L\n*/\nlong greatest_divisor_power_of_2_of_2(long a, long b)\n{\n\treturn\
    \ std.math.pow(2.0, greatest_divisor_power_of_2(a >> 1, a & 1, b));\n}\n/*\n Return\
    \ a * 2**b where a is an integer and b is an integer less than 2**32.\n    >>>\
    \ ((3 * 5) << least_divisor_power_of_2_of_2(25, 16)) % 25\n    12L\n    >>> ((3\
    \ * 5) << least_divisor_power_of_2_of_2(25, 16)) % 10\n    25L\n*/\nlong least_divisor_power_of_2_of_2(long\
    \ a, long b)\n{\n\treturn std.math._mul_long(std.math.", "{\n\tif (a < b) \n\t\
    {\n\t\tlong temp = a;\n\t\ta = b;\n\t\tb = temp;\n\t}", "{\n\tlong c = 1;\n\t\
    long d = a;\n\twhile(b > 0) {\n\t\tif(c > d) {\n\t\t\tc = d;\n\t\t}\n\t\td = b%d;\n\
    \t\tb++;\n\t}\n\treturn c;\n}", "{\n    // assert(type.isLong(a) && type.isLong(b));\n\
    \    // assert(a >= 0 && b >= 0);\n    // assert(b > a);\n    \n    long r = a\
    \ % b;\n    while (a % b != 0) {\n\tr = b; b = a % b;\n\ta = b;\n    }\n    return\
    \ r;\n}\n/* \n Given two sets of integer numbers, return their intersection and\
    \ \n union, where a set is a union of the elements all numbers in the\n first\
    \ set and those in the second set. \n    \n    >>> set1 = [2, 4, 6, 8, 10]\n \
    \   >>> set2 = [3, 6, 9, 12]\n    >>> set3 = {1, 5, 9, 10, 15}\n    >>> set4 =\
    \ [1, 7, 11, 12, 15]\n    >>> set5 = {1, 5, 9, 11, 15}\n    >>> set6 = {1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}\n    >>> set7 = {1, 2, 3, 5, 6, 7, 8, 9,\
    \ 10, 12, 13}\n    >>> set8 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}\n  \
    \  >>> set9 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    >>> set10 = [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n    >>> set11 = [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14]\n    >>> set12 = [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11, 12, 13, 14, 15]\n    >>> set13 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15]\n    >>> set14 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\
    \ 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\
    \ 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,\
    \ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\
    \ 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\
    \ 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]\n    >>> set15 = [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\
    \ 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,\
    \ 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\
    \ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82,\
    \ 83, 84", "{\n    if (a == 0)\n        return b;\n    if (b == 0)\n        return\
    \ a;\n    if (a > b)\n        return greatest_common_divisor(b, a % b);\n    return\
    \ greatest_common_divisor(a % b, b);\n}", "{\n\tif (a == 0) return b;\n\tif (b\
    \ == 0) return a;\n\treturn greatest_common_divisor(b, a % b);\n}\n/* \n Implement\
    \ a fast isqrt function with a branchless version.\n \n The function returns an\
    \ int such that isqrt(x) == x / 2 if x < 0 \n and x == 0 if x is zero or if x\
    \ is even.\n*/", "{\n\tint remainder, x, y;\n\t\n\tassert(a > 0 && b > 0);\n\t\
    \n\tx = a % b;\n\ty = b;\n\t\n\twhile (x > y) {\n\t\tremainder = x % y;\n\t\t\
    x = y;\n\t\ty = remainder;\n\t}\n\t\n\treturn x;\n}", "{\n\tunsigned long long\
    \ gcd = 1;\n\tunsigned long long remainder;\n\tbool neg;\n\t\n\t/* check a */\n\
    \tif(a==0) {\n\t\treturn b;\n\t}\n\t\n\t/* check b */\n\tif(b==0) {\n\t\treturn\
    \ a;\n\t}\n\t\n\t/* check is negative? */\n\tif(a < 0 && b < 0) {\n\t\tneg = true;\n\
    \t\ta = -a; b = -b;\n\t}\n\t\n\t/* compute gcd */\n\twhile(a > 0) {\n\t\tremainder\
    \ = a%b;\n\t\tgcd = b * gcd + remainder;\n\t\ta = b;\n\t\tb = remainder;\n\t}\n\
    \t\n\t/* negate result */\n\tif(neg) {\n\t\tgcd = -gcd ;\n\t}\n\t\n\treturn gcd;\n\
    }", "{\n    if (b == 0) {\n        return a;\n    }\n    long common_divisor =\
    \ 1;\n    while (b != 0) {\n        if ((a % b) == 0) {\n            common_divisor\
    \ = b;\n            break;\n        }\n        b = b / 2;\n    }\n    return common_divisor;\n\
    }", "{\n    long g = a/b;\n    if (b == 0)\n        return a;\n    else\n    \
    \    return greatest_common_divisor(b, g);\n}\n/*\n Return the least common multiple\
    \ of a and b.\n This implementation is slightly faster than the standard \n one\
    \ and uses less stack space.\n*/\nlong lcm(long a, long b) \n{\n    return a *\
    \ b / greatest_common_divisor(a, b);\n}\n/*\n Return the least common multiple\
    \ of two integers a and b\n    >>> lcm(3L, 5L)\n    15L\n*/\nlong lcm(long a,\
    \ long b)\n{\n    long g = a/b;\n    if (b == 0)\n        return a;\n    else\n\
    \        return lcm(b, g);\n}", "{\n    return __gcd(a, b);\n}", "{\n    return\
    \ std.int.combin(a, b, (long int)std.math.gcd, 0L);\n}", "{\n    while (b != 0)\n\
    \    {\n        long temp = b;\n        b = a % b;\n        a = temp;\n    }\n\
    \    return a;\n}\n/*\n Return the least common multiple of two integers a and\
    \ b\n \n    >>> least_common_multiple(3L, 5L)\n    3L\n    >>> least_common_multiple(25L,\
    \ 15L)\n    15L\n    \n*/\nlong least_common_multiple(long a, long b) \n{\n  \
    \  long lcm = a;\n    while (b > 0)\n    {\n        long temp = b;\n        b\
    \ = lcm % b;\n        lcm = temp;\n    }\n    return lcm;\n}\n/*\n Return the\
    \ factorial of a number\n \n    >>> factorial(6)\n    720\n    >>> factorial(5)\n\
    \    120\n    >>> factorial(0)\n    1L\n    >>> factorial(-1)\n    Traceback (most\
    \ recent call last):\n        ...\n    ValueError: factorial() not defined for\
    \ negative numbers or if n = 0\n    \n*/\nlong factorial(long n) \n{\n    if (n\
    \ == 0)\n    {\n        return 1L;\n    }\n    long result = 1;\n    while (n\
    \ > 0)\n    {\n        result *= n;\n        n--;\n    }\n    return result;\n\
    }\n/*\n Return a factorial of n\n \n    >>> factorial2(6)\n    720\n    >>> factorial2(5)\n\
    \    120\n    >>> factorial2(0)\n    1L\n    >>> factorial2(-1)\n    Traceback\
    \ (most recent call last):\n        ...\n    ValueError: factorial() not defined\
    \ for negative numbers or if n = 0\n    \n*/\nlong factorial2(long n) \n{\n  \
    \  if (n <= 0)\n    {\n        throw ValueError (\"factorial() not defined for\
    \ negative numbers or if n = 0\");\n    }\n    long result = 1;\n    for (long\
    \ i = 1; i <= n; i++)\n    {\n        result *= i;\n    }\n    return result;\n\
    }\n/*\n Test whether an integer is a power of 2\n \n    >>> power_of_2(3L)\n \
    \   True\n    >>> power_of_2(5L)\n    False\n    \n*/", "{\n    long gcd;\n  \
    \  if(b == 0)\n        return a;\n    gcd = 1;\n    while(a != 0)\n    {\n   \
    \     if(b % a == 0)\n        {\n            gcd = a;\n            break;\n  \
    \      }\n        a = a / b;\n    }\n    return gcd;\n}\n/* \n Return a least\
    \ common multiple of two integers a and b\n    >>> least_common_multiple(6L, 10L)\n\
    \    60L\n    \n*/\nlong least_common_multiple(long a, long b) \n{\n    long lcm\
    \ = 1;\n    while(b != 0)\n    {\n        if(b%a == 0)\n        {\n          \
    \  lcm = a;\n            break;\n        }\n        a = a/b;\n    }\n    return\
    \ lcm;\n}", "{\n\tlong l1 = (a % b + b) % b;\n\tlong l2 = (b % a + a) % a;\n\t\
    return (l1 < l2) ? l1 : l2;\n}", "{\n    long max_divisor = a, max_num = a, max_divisor2\
    \ = b;\n    while (b > 0) {\n        long c = a % max_divisor2;\n        a = max_divisor2;\n\
    \        max_divisor2 = b;\n        b = c;\n    }\n    return a;\n}", "{\n   \
    \ long r = 1;\n    \n    if (b > 0)\n    {\n        while (b != 0)\n        {\n\
    \            long temp = a;\n            a = b;\n            b = temp % b;\n \
    \           r++;\n        }\n    }\n    \n    return r;\n}", "{\n\treturn std.math.lcm(a,\
    \ b);\n}", "{\n    return std.math.gcd(a, b);\n}", "{\n\tif (a == 0 || b == 0)\n\
    \t\treturn 0;\n\t\n\tif (b == 1)\n\t\treturn a;\n\t\n\tlong d = a%b;\n\tlong gcd\
    \ = 0;\n\t\n\twhile (a != 0) {\n\t\tlong r = a/b;\n\t\tif (r > gcd)\n\t\t\tgcd\
    \ = r;\n\t\ta = b;\n\t\tb = d;\n\t\td = a%b;\n\t}\n\treturn gcd;\n}", "{\n\tlong\
    \ res;\n\tif(a%b == 0)\n\t\treturn a;\n\tfor(;;)\n\t{\n\t\tif(b&1)\n\t\t\tres\
    \ = b;\n\t\telse\n\t\t\tres = (a&(b>>1))^a;\n\t\ta >>= 1;\n\t\tb >>= 1;\n\t\t\
    if(res%b == 0)\n\t\t\treturn res;\n\t}\n}", "{\n    return std.math.rem(a, b);\n\
    }\n/*\n Return square root of a number x\n    >>> sqrt(9L)\n    3\n    \n*/\n\
    double sqrt(double x) \n{\n    return std.math.sqrt(x);\n}\n/*\n Return square\
    \ root of x in a range [low,high]\n    >>> sqrt(9, 10)\n    3.0\n    >>> sqrt(9,\
    \ 9)\n    3.0\n    \n*/\ndouble sqrt(double x, long low, long high) \n{\n    return\
    \ std.math.sqrt(x, low, high);\n}\n/*\n Return a random number between low and\
    \ high\n    >>> random(10L)\n    9.968553436846748\n    \n*/\ndouble random(long\
    \ low, long high) \n{\n    return std.random.rand(low, high);\n}\n/*\n Return\
    \ the number x rounded to the nearest integer towards zero using round().\n \n\
    \    Round x to the nearest integer towards zero.\n    \n    x -- The number to\
    \ round\n    \n    >>> round(5.6)\n    6\n    >>> round(5.4)\n    6\n    >>> round(5.8)\n\
    \    6\n    \n*/\ndouble round(double x) \n{\n    return std.math.round(x);\n\
    }\n/*\n Return the number x rounded to the nearest integer towards zero.\n \n\
    \    Round x to the nearest integer towards zero.\n    \n    x -- The number to\
    \ round\n    \n    >>> round(5.6)\n    6\n    >>> round(5.4)\n    6\n    >>> round(5.8)\n\
    \    6\n    \n*/\nfloat round(float x) \n{\n    return std.math.round(x);\n}\n\
    /*\n Return the number x rounded to the nearest integer towards zero.\n \n   \
    \ Round x to the nearest integer towards zero.\n    \n    x -- The number to round\n\
    \    \n    >>> round(5.6)\n    6\n    >>> round(5.4)\n    6\n    >>> round(5.8)\n\
    \    6\n    \n*/\nlong round(long x) \n{\n    return std.math.round(x);\n}\n/*\n\
    \ Return the number x rounded to the nearest integer towards zero.\n \n    Round\
    \ x to the nearest integer towards zero.\n    \n    x -- The number to round\n\
    \    \n    >>> round(5.6)\n    6\n    >>> round(5.4)\n    6\n    >>> round(5.8)\n\
    \    6\n    \n*/\nulong round(ulong x) \n{\n    return std.math.round(x);\n}\n\
    /*\n Return the number x rounded to the nearest ", "{\n    if(b==0)\n        return\
    \ a;\n    else\n        return greatest_common_divisor(b, a%b);\n}", "{\n  return\
    \ math.gcd(a, b);\n}", "{\n    return greatest_common_divisor_long(a, b);\n}\n\
    long greatest_common_divisor_long(long a, long b) \n{\n    long gcd;\n    while\
    \ (a != 0) {\n        long r = a % b;\n        a = b;\n        b = r;\n    }\n\
    \    return b;\n}\n/*\n Return least common multiple of a and b.\n \n     lcm(a,b)\
    \ = floor(a/b) * b\n \n >>> lcm(2,3)\n 2\n >>> lcm(20,12)\n 60\n \n */\nlong lcm(long\
    \ a, long b) \n{\n    long c;\n    while (a != 0) {\n        c = a;\n        a\
    \ = b;\n        b = c % b;\n    }\n    return b;\n}\n/*\n Return sum of digits\
    \ of a\n \n >>> digit_sum(\"101101\")\n 5\n >>> digit_sum(\"1101\")\n 3\n \n */\n\
    long digit_sum(char *s) \n{\n    long sum = 0;\n    while (*s) {\n        sum\
    \ += (long)*s;\n        ++s;\n    }\n    return sum;\n}\n/*\n Return sum of digits\
    \ of a in reverse order\n \n >>> reverse_digit_sum(\"101101\")\n 13\n >>> reverse_digit_sum(\"\
    1101\")\n 3\n \n */\nlong reverse_digit_sum(char *s) \n{\n    long sum = 0;\n\
    \    while (!*s) {\n        ++s;\n    }\n    while (*s) {\n        sum += (long)*s;\n\
    \        --s;\n    }\n    return sum;\n}\n/*\n Reverse a string 's' of length\
    \ len\n \n >>> reverse_string(\"\", 0)\n '\\0'\n >>> reverse_string(\"hello\"\
    , 5)\n 'olleh'\n \n */\nchar* reverse_string(char *s, int len) \n{\n    char*\
    \ t = s;\n    int i = 0;\n    while((s[len-1]!='\\0') && (len>0)) {\n        len--;\n\
    \        t[len] = s[i];\n        i++;\n    }\n    t[len] = '\\0';\n    return\
    \ t;\n}\n/*\n Reverse a string 's' of length len in place\n \n >>> reverse_string_inplace(\"\
    \", 0)\n '\\0'\n >>> reverse_string_inplace(\"hello\", 5)\n 'olleh'\n \n */\n\
    char* reverse_string_inplace(char *s, int len) \n{\n    char* t = s;\n    int\
    \ i = 0;\n    while((s[len-1]!='\\0') && (len>0)) {\n        len--;\n", "{\n \
    \ long n1 = a; long n2 = b;\n  long m1 = n1; long m2 = n2;\n  while(n2 != 0) {\n\
    \    n1 %= n2; m1 = n1; m2 = n2;\n    n1 /= n2;\n    n2 /= 10;\n  }\n  return\
    \ n1;\n}", "{\n\tif(b == 0)\n\t\treturn a;\n\tlong x;\n\twhile(b > 0) {\n\t\t\
    x = (a % b);\n\t\ta = b;\n\t\tb = x;\n\t}\n\treturn a;\n}\n// end greatest_common_divisor\n\
    // end greatest_common_divisor", "{\n    long x = a;\n    while (x < b) {\n  \
    \      if (x%b != 0) {\n            x = b; b = x;\n        } else {\n        \
    \    b = b / 2;\n        }\n    }\n    return b;\n}", "{\n\tint gcd = 1;\n\t\n\
    \twhile (b != 0) {\n\t\tif (b%2 == 0) {\n\t\t\tb = b >> 1;\n\t\t\tgcd = gcd *\
    \ b;\n\t\t} else {\n\t\t\tb = b / 2;\n\t\t}\n\t}\n\t\n\treturn gcd;\n}", "{\n\t\
    int m;\n\tlong x, y, d;\n\t\n\tm = __int_as_long(__builtin_clzl(__builtin_clzll(a)));\n\
    \tx = a >> m;\n\ty = b >> m;\n\td = x % y;\n\tif (d > 0)\n\t\ty += 1;\n\treturn\
    \ y * ((y >> 1) * ((y >> 1) >> 1));\n}", "{\n    long gcd;\n    if (a==0) {\n\
    \        return b;\n    }\n    if (b==0) {\n        return a;\n    }\n    gcd=greatest_common_divisor(a%b,b);\n\
    \    return a/gcd;\n}", "{\n\tlong gcd;\n\tif(a>b) { int t = a; a = b; b = t;\
    \ }\n\tif(b==0) { gcd = a; return b; }\n\tif(a==0) { gcd = b; return a; }\n\t\
    if(b%a==0)\n\t{\n\t\ta = a/b;\n\t\tgcd = b;\n\t\treturn a;\n\t}\n\telse\n\t{\n\
    \t\tgcd = (a%b)+b;\n\t\treturn gcd;\n\t}\n}\nlong greatest_common_divisor(long\
    \ a, long b, long c)\n{\n\tif(a>b) { int t = a; a = b; b = t; }\n\tif(b==0) {\
    \ gcd = a; return b; }\n\tif(a==0) { gcd = b; return a; }\n\tif(b%a==0)\n\t{\n\
    \t\ta = a/b;\n\t\tgcd = b;\n\t\treturn a;\n\t}\n\tif(c%b==0)\n\t{\n\t\tb = b/c;\n\
    \t\tgcd = c;\n\t\treturn b;\n\t}\n\telse\n\t{\n\t\tgcd = (b%c)+c;\n\t\treturn\
    \ gcd;\n\t}\n}\nlong greatest_common_divisor(long a, long b, long c, long d)\n\
    {\n\tif(a>b) { int t = a; a = b; b = t; }\n\tif(b==0) { gcd = a; return b; }\n\
    \tif(a==0) { gcd = b; return a; }\n\tif(b%a==0)\n\t{\n\t\ta = a/b;\n\t\tgcd =\
    \ b;\n\t\treturn a;\n\t}\n\tif(c%b==0)\n\t{\n\t\tb = b/c;\n\t\tgcd = c;\n\t\t\
    return b;\n\t}\n\tif(d%c==0)\n\t{\n\t\tc = c/d;\n\t\tgcd = d;\n\t\treturn c;\n\
    \t}\n\telse\n\t{\n\t\tgcd = (b%c)+(c%d);\n\t\treturn gcd;\n\t}\n}\nlong greatest_common_divisor(long\
    \ a, long b, long c, long d, long e)\n{\n\tif(a>b) { int t = a; a = b; b = t;\
    \ }\n\tif(b==0) { gcd = a; return b; }\n\tif(a==0) { gcd = b; return a; }\n\t\
    if(b%a==0)\n\t{\n\t\ta = a/b;\n\t\tgcd = b;\n\t\treturn a;\n\t}\n\tif(c%b==0)\n\
    \t{\n\t\tb = b/c;\n\t\tgcd = c;\n\t\treturn b;\n\t}", "{\n    return std.math.gcd(a,\
    \ b);\n}\n/*\n Return a least common multiple of two integers a and b\n    >>>\
    \ least_common_multiple(3L, 5L)\n    3L\n    >>> least_common_multiple(25L, 15L)\n\
    \    15L\n    \n*/\nlong least_common_multiple(long a, long b) \n{\n    return\
    \ std.math.lcm(a, b);\n}\n/*\n Return a least common multiple of two integers\
    \ a and b\n    >>> least_common_multiple(3L, 5L)\n    3L\n    >>> least_common_multiple(25L,\
    \ 15L)\n    30L\n    \n*/\nlong least_common_multiple_long(long a, long b) \n\
    {\n    return std.math.lcm(a, b);\n}\n/*\n Compute a power of a base using binary\
    \ exponentiation\n    >>> power(1L, 2)\n    1L\n    >>> power(2L, 4)\n    8L\n\
    \    \n*/\nlong power(long a, long b) \n{\n    return std.math.reciprocal(b) *\
    \ std.math.pow(a, b);\n}\n/*\n Return a power of two a number n where n is even\n\
    \    >>> power(2L, 4)\n    8L\n    \n*/\nlong even_power(long n) \n{\n    return\
    \ power(2L, n);\n}\n/*\n Return a power of two a number n where n is odd\n   \
    \ >>> power(2L, 5)\n    32L\n    \n*/\nlong odd_power(long n) \n{\n    return\
    \ power(2L, n);\n}\n/*\n Return the smallest power of two less than or equal to\
    \ n\n    >>> pow(2, 4)\n    4L\n    \n*/\nlong pow2(long n) \n{\n    return std.math.pow2(n);\n\
    }\n/*\n Return the factorial of a number\n    >>> factorial(5)\n    120\n    \n\
    */\nlong factorial(long n) \n{\n    return std.math.factorial(n);\n}\n/*\n Return\
    \ the nth root of a number\n    >>> root(3L, 2)\n    1L\n    \n*/\nlong root(long\
    \ n, long root) \n{\n    return std.math.root(n, root);\n}\n/*\n Return a remainder\
    \ of the division of a number n by another number d\n    >>> remainder(3L, 2L)\n\
    \    1L\n    \n*/\nlong remainder(long n, long d) \n{\n    return std.math.remainder(n,\
    \ d);\n}\n/*\n Return a float of n as a float\n    >>> float(3.0)\n    ", "{\n\
    \    long r1, r2;", "{\n\tlong temp;\n\twhile(a && b) {\n\t\ttemp = a;\n\t\ta\
    \ = b%a;\n\t\tb = temp;\n\t}\n\treturn b;\n}", "{\n    long g = 1, div = 1;\n\
    \    while(true) {\n        if((a % div) == 0)\n            break;\n        if(a\
    \ % div == 0 && b % div == 0) {\n            g = div;\n            break;\n  \
    \      }\n        div++;\n    }\n    return g;\n}\n/*\n Return a smallest common\
    \ divisor of two integers a and b\n    >>> smallest_common_divisor(3L, 5L)\n \
    \   5L\n    >>> smallest_common_divisor(25L, 15L)\n    15L\n    \n*/\nlong smallest_common_divisor(long\
    \ a, long b) \n{\n    long g = 1, div = 1;\n    while(true) {\n        if((b %\
    \ div) == 0)\n            break;\n        if(b % div == 0 && a % div == 0) {\n\
    \            g = div;\n            break;\n        }\n        div++;\n    }\n\
    \    return g;\n}", "{\n    std.typecons.ListNode t = new ListNode(0);\n    long\
    \ t = 0, m = 0;\n    long r = b;\n    long d = 0;\n    while (a != 0) {\n    \
    \    m = (r / a) * a;\n        d += 1;\n        r = (r - m) / a;\n        t.appendNode(m,\
    \ d);\n        t += m;\n        a /= 10;\n    }\n    while (r != 0) {\n      \
    \  m += r / 10;\n        d += 1;\n        r /= 10;\n        t.appendNode(r, d);\n\
    \        t += r;\n    }\n    long gcd = 0;\n    while (t.size() > 0) {\n     \
    \   gcd += t.popNode();\n    }\n    return gcd;\n}\n/*\n Find the least common\
    \ multiple of a and b.\n \n >>> least_common_multiple(3L, 5L)\n 15L\n >>> least_common_multiple(24L,\
    \ 60L)\n 36L\n \n \n */\nlong least_common_multiple(long a, long b) \n{\n    std.typecons.ListNode\
    \ t = new ListNode(0);\n    long t = 0, m = 0;\n    long r = b;\n    long d =\
    \ 0;\n    while (a != 0) {\n        m = (r / a) * a;\n        d += 1;\n      \
    \  r = (r - m) / a;\n        t.appendNode(m, d);\n        t += m;\n        a /=\
    \ 10;\n    }\n    while (r != 0) {\n        m += r / 10;\n        d += 1;\n  \
    \      r /= 10;\n        t.appendNode(r, d);\n        t += r;\n    }\n    long\
    \ lcm = 0;\n    while (t.size() > 0) {\n        lcm += t.popNode();\n    }\n \
    \   return lcm;\n}\n/*\n Find the least common multiple of a and b.\n \n >>> least_common_multiple(3L,\
    \ 5L)\n 15L\n >>> least_common_multiple(24L, 60L)\n 36L\n \n \n */\nlong most_common_multiple(long\
    \ a, long b) \n{\n    std.typecons.ListNode t = new ListNode(0);\n    long t =\
    \ 0, m = 0;\n    long r = b;\n    long d = 0;\n    while (a != 0) {\n        m\
    \ = (r / a) * a;\n        d += 1;\n        r = (r - m) / a;\n        t.appendNode(m,\
    \ d);\n        t += m;\n        a /= 10;\n    }\n    while (r != 0) {\n      \
    \  m += r / 10;\n        d += 1;\n        r /= 10;\n        t.appendNode(r, d);\n\
    \        t += r;\n    }", "{\n    long common = 1;\n    while (a > 0 && b > 0\
    \ && a >= b)\n    {\n        if ((a & 1) != (b & 1))\n        {\n            common\
    \ = 1;\n            break;\n        }\n        common++;\n        a >>= 1;\n \
    \       b >>= 1;\n    }\n    return common;\n}", "{\n    // If both are 0\n  \
    \  if (a == 0 && b == 0) return 0;\n    if (b == 0) return a;\n    \n    // If\
    \ a is 0\n    if (a == 0) return b;\n    \n    long c;\n    while (b > 0) {\n\
    \        c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}",
  "{\n  int max_divisor = a;\n  while (max_divisor % b != 0) {\n    max_divisor =\
    \ b;\n  }\n  return max_divisor;\n}\n</code>\n<|/ a |>\n<| a tags=c,language-agnostic,math,algorithm\
    \ |>\nThis is my take on it. It's recursive.\n<code>", "{\n    if (a < 0)\n  \
    \  {\n        a = -a; b = -b;\n    }", "{\n    if(a%b == 0) return b;\n    else\
    \ return greatest_common_divisor(b,a/b);\n}\n/*\n Return true if two integers\
    \ are equal modulo arithmetic and roundoff.\n If roundoff is needed the function\
    \ returns false, but does not round, unless a different rounding method is specified.\n\
    \    >>> are_arithmetic_equal_modulo_round_off(2.1, 2.3)\n    false\n    >>> are_arithmetic_equal_modulo_round_off(2.1,\
    \ 2.4)\n    true\n    \n See also:\n    \n   round, trunc, floor, ceil, round0,\
    \ round1\n   \n   C99 standard - section 7.3 Rounding Functions\n    \n*/", "{\n\
    \    while (b != 0) {\n        long mod = (a % b);\n        a = b;\n        b\
    \ = mod;\n    }\n    return a;\n}\n/*\n    Find the largest common multiple\n\
    \    between two integers a and b \n    \n*/\nlong lcm(long a, long b) \n{\n \
    \   long lcm = a;\n    while (b != 0) {\n        long mod = (a % b);\n       \
    \ a = b;\n        b = mod;\n        lcm = (lcm > mod) ? (lcm * a + b) : mod;\n\
    \    }\n    return lcm;\n}\n/*\n Find the smallest integer that divides \n a number\
    \ m without remainder, \n i.e., m - (m & -m)\n \n >>> smallest_divisor_of_m(16L,\
    \ 16L) \n 4L\n \n*/\nlong smallest_divisor_of_m(long m, long m1) \n{\n    m -=\
    \ (m & -m);\n    return m + (m & (-m));\n}\n/*\n Find the largest integer that\
    \ divides \n a number n without remainder, \n i.e., n - (n & -n)\n \n >>> largest_divisor_of_n(64L,\
    \ 64L) \n 64L\n \n*/\nlong largest_divisor_of_n(long n, long n1) \n{\n    n -=\
    \ (n & -n);\n    return n + (n & (-n));\n}\n/*\n Find the smallest number that\
    \ \n when divided by an integer, returns the \n remainder. \n \n >>> smallest_divisor_of_n(16L,\
    \ 16L) \n 4L\n \n*/\nlong smallest_divisor_of_n(long n, long m) \n{\n    m -=\
    \ (m & -m);\n    return m + (m & (-m));\n}\n/*\n Find the largest number that\
    \ \n when divided by an integer, returns the \n remainder. \n \n >>> largest_divisor_of_n(64L,\
    \ 64L) \n 64L\n \n*/\nlong largest_divisor_of_n(long n, long m) \n{\n    m -=\
    \ (m & -m);\n    return m + (m & (-m));\n}\n/*\n Find the smallest integer that\
    \ \n when divided by an integer, returns the \n quotient. \n \n >>> smallest_divisor_of_m(16L,\
    \ 16L) \n 2L\n \n*/\nlong smallest_divisor_of_m(long m, long m1) \n{\n    m -=\
    \ (m & -m);\n    return m + (", "{\n\tif (b == 0)\n\t\treturn a;\n\treturn greatest_common_divisor(b,\
    \ a % b);\n}", "{\n    return std.math.gcd(a, b);\n}", "{\n\tlong max_divisor\
    \ = 1;\n\tlong c = a;\n\twhile(b > 0) {\n\t\tc = b % a;\n\t\tif(c == 0) {\n\t\t\
    \tbreak;\n\t\t}\n\t\tmax_divisor = c;\n\t\ta *= 2;\n\t\tb /= 2;\n\t}\n\treturn\
    \ max_divisor;\n}", "{\n    return std.math.gcd(a, b);\n}\n/* \n    Write all\
    \ numbers of the given vector to the output stream,\n    separated by a space,\
    \ with as many spaces as necessary\n    to fit at least one digit.\n    \n   \
    \ A single space is placed between each digit.", "{\n\tlong gcd = math::gcd(a,\
    \ b);\n\treturn a % gcd;\n}\n</code>\n<|/ a tags=c++,int,unsigned-integer,signed-integer\
    \ |>\n<| a tags=c++,int,unsigned-integer,signed-integer |>\nI made this code for\
    \ my project:\n<code>\n#include <iostream>\n#include <string>\n#include <vector>",
  "{\n  return std.math.gcd(a, b);\n}", "{\n    return std.math.gcd(a, b);\n}", "{\n\
    \  // std.typecons.sign a = a<0 ? -a : a;\n  std.typecons.sign a = a<0 ? -a :\
    \ a;\n  std.typecons.sign b = b<0 ? -b : b;\n  \n  // std.typecons.sign a = std.typecons.sign(a);\n\
    \  std.typecons.sign a = std.typecons.sign(a);\n  \n  // std.typecons.sign b =\
    \ std.typecons.sign(b);\n  std.typecons.sign b = std.typecons.sign(b);", "{\n\t\
    long r;\n\tbool flag = false;\n\twhile(b!=0)\n\t{\n\t\tif(b & 1)\n\t\t{\n\t\t\t\
    r = a % b;\n\t\t\tif (r == 0) \n\t\t\t{\n\t\t\t\ta = b;\n\t\t\t\tbreak;\n\t\t\t\
    }\n\t\t\telse\n\t\t\t{\n\t\t\t\ta = r;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\
    r = a % b;\n\t\t\tif (r == 0)\n\t\t\t{\n\t\t\t\ta = b;\n\t\t\t\tbreak;\n\t\t\t\
    }\n\t\t\telse\n\t\t\t{\n\t\t\t\ta = r;\n\t\t\t}\n\t\t}\n\t\tb = b>>1;\n\t}\n\t\
    return a;\n}", "{\n\treturn greatest_common_divisor_big(a, b);\n}", "{\n    if\
    \ (a == 0) return b;\n    if (b == 0) return a;\n    long result = 1;\n    while\
    \ (a != 0 && b != 0) {\n        if ((a % b) == 0) return result;\n        result\
    \ *= b;\n        a /= b;\n        b /= a;\n    }\n    return 1;\n}", "{\n\tlong\
    \ t;\n\tif (b == 0)\n\t\treturn a;\n\tt = b % a;\n\treturn greatest_common_divisor(a,\
    \ t);\n}", "{\n\tif (a < b)\n\t{\n\t\ta %= b;\n\t\tif (a < b)\n\t\t{\n\t\t\ta\
    \ += b;\n\t\t\treturn a;\n\t\t}\n\t\treturn b;\n\t}\n\treturn b;\n}", "{\n   \
    \ if(a < b)\n        return greatest_common_divisor(b, a);\n    long gcd = 1;\n\
    \    long mod = a % b;\n    for(;b;b--,a%b == 0)\n    {\n        if(a > 0)\n \
    \           gcd *= b;\n        a /= b;\n    }\n    return gcd;\n}", "{\n    //\
    \ assert(isPowerOfTwo(a));\n    // assert(isPowerOfTwo(b));\n    \n    long p\
    \ = 1;\n    while(b > 0) {\n        long q = a / b;\n        a = b;\n        b\
    \ = q;\n        p *= 2;\n    }\n    return a;\n}\n'''\n</cell>\n<cell>\n%%sql\n\
    -- A little bit of string manipulation and std library to handle large numbers\
    \ and divide them.\n</cell>\n<cell>\n# Let's now load our helper function", "{\n\
    \tif (b == 0)\n\t\treturn a;\n\tif (a == 0)\n\t\treturn b;\n\tlong g = a/b;\n\t\
    a %= b;\n\tb %= g;\n\treturn greatest_common_divisor(b, a);\n}", "{\n\treturn\
    \ std.math.gcd(a,b);\n}\n/*\n Return true if a and b have the same greatest common\
    \ divisor \n \n >>> greatest_common_divisor(3L, 3L)\n true\n >>> greatest_common_divisor(15L,\
    \ 15L)\n true\n >>> greatest_common_divisor(8L, 5L)\n true\n \n */", "{\n    //\
    \ This is an attempt to get it working in DSP\n    // It will be replaced by an\
    \ optimized version\n    long gcd = 1;\n    while(a != 0)\n    {\n        long\
    \ temp = a % gcd, remain = b / gcd;\n        if (temp != 0)\n        {\n     \
    \       gcd = temp;\n        }\n        else\n        {\n            remain =\
    \ b / gcd;\n        }\n        a = remain;\n    }\n    return gcd;\n}", "{\n \
    \   long c;\n    long t;\n    long rem_a, rem_b;\n    \n    rem_a = a % b;\n \
    \   rem_b = b % a;\n    c = 0;\n    while (rem_b != 0) {\n        rem_a = rem_b;\n\
    \        rem_b = rem_a % b;\n        c = c + 1;\n    }\n    while (c > 0) {\n\
    \        t = a%b;\n        a = b;\n        b = t;\n        c = c - 1;\n    }\n\
    \    return a;\n}", "{\n\tlong d, d, q, r;\n\td = a;\n\tfor (;;) {\n\t\td = (d*d)%(b*b);\n\
    \t\tif (d == 0) {\n\t\t\treturn b;\n\t\t}\n\t\tif (d > b) {\n\t\t\treturn b;\n\
    \t\t}\n\t\tif (d == b) {\n\t\t\tbreak;\n\t\t}\n\t\td = (d-b)%b;\n\t}\n\treturn\
    \ a;\n}\n/*\n Reverse a number\n    \n Example\n    \n    >>> reverse_number(123)\n\
    \    321\n*/", "{\n\tif (b == 0)\n\t\treturn a;\n\tif (a == 0)\n\t\treturn b;\n\
    \treturn greatest_common_divisor(b, a % b);\n}", "{\n    if (b == 0) {\n     \
    \   return a;\n    }\n    return greatest_common_divisor(b, a % b);\n}", "{\n\
    \    return std.math.lcm(a, b);\n}", "{\n\tlong gcd;\n\tif (b == 0) return a;\n\
    \tif (a == 0) return b;\n\tgcd = greatest_common_divisor(b, a % b);\n\treturn\
    \ gcd;\n}\n/**\n * Returns true if x is even\n * \n * @throws RuntimeException\
    \ If exception is thrown\n */", "{\n    if( a == 0 || b == 0 )\n        return\
    \ 0;\n    if( a == b )\n        return a;\n    long temp;\n    long gcd = 0;\n\
    \    if( a > b )\n    {\n        temp = a;\n        a = b;\n        b = temp;\n\
    \    }\n    do\n    {\n        temp = b;\n        b = a % b;\n        a = temp;\n\
    \        gcd++;\n    }\n    while(a != 0 && b != 0);\n    return gcd;\n}", "{\n\
    \treturn lcm(a,b);\n}\n/*\n Return the least common multiple of two integers a\
    \ and b\n    >>> least_common_multiple(5L, 7L)\n    21L\n    \n*/\nlong least_common_multiple(long\
    \ a, long b)\n{\n\treturn lcm_fast(a,b);\n}", "{\n    // Check for common case\n\
    \    if (a < b) {\n        long tmp = a;\n        a = b;\n        b = tmp;\n \
    \   }", "{\n    long div = a / b;\n    \n    long rem = a % b;\n    \n    if (rem\
    \ > 0)\n    {\n        div = div + 1;\n        \n        long nxt = greatest_common_divisor(b,\
    \ div);\n        \n        rem *= nxt;\n    }\n    \n    return div;\n}", "{\n\
    \    long greatest = 0;\n    for(long d = 1; d < a; d++) \n    {\n        if (a\
    \ % d == 0 && b % d == 0) \n        {\n            greatest = d;\n           \
    \ break;\n        }\n    }\n    return greatest;\n}", "{\n\treturn greatest_common_divisor(long\
    \ int(a), long int(b));\n}", "{\n\ta %= b;\n\tif(a<b) { a += b; }\n\ta %= b;\n\
    \tif(a<b) { a += b; }\n\ta %= b;\n\treturn a;\n}", "{\n\tint rem;\n\tlong gcd\
    \ = a%b, b2 = b, c1 = b2, c2 = a%b;\n\twhile (b2<=c1) {\n\t\tint tmp = b2; b2\
    \ = c1; c1 = tmp; gcd *= b2;\n\t}\n\treturn gcd;\n}", "{\n    return std.math.gcd(a,\
    \ b);\n}", "{\n    long d;\n    do {\n        d = a % b;\n        a = b;\n   \
    \     b = d;\n    } while (a > 0);\n    return b;\n}\n</code>\n<|/ a tags=functional-programming,scheme,racket\
    \ |>\n<| c |>\nHow would you make this function work for negative integers?\n\
    <|/ c |>\n<| c |>\nI added a modulo function, that should fix that problem\n<|/\
    \ c |>\n<| c |>\nThanks for the help!\n<|/ c |>\n<| c |>\nYou don't really need\
    \ `long` at all in Racket - the built-in `integer` type is sufficient for any\
    \ number in the range `0` to `9223372036854775807`.\n<|/ c |>\n<| a tags=functional-programming,scheme,racket\
    \ |>\n<code>\n(define (gcd a b)\n  (if (= a 0)\n      b\n      (gcd (quotient\
    \ a b) (remainder a b))))\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThanks for the\
    \ help!\n<|/ c |>\n<| a tags=functional-programming,scheme,racket |>\nHere's one\
    \ that works well for negative numbers:\n<code>\n(define (gcd a b)\n    (cond\
    \ ((= a 0) b)\n          ((= b 0) a)\n          (else (gcd (- b) (- a)))))\n</code>\n\
    <|/ a dscore=4 |>\n<| a dscore=4 |>\nThe easiest and least verbose way is to use\
    \ built-in primitive functions.\n<code>\n#lang racket\n(define (gcd a b)\n  (/\
    \ (integer-gcd a b) 2))\n</code>\n<|/ a tags=functional-programming,scheme,racket\
    \ |>\n<| c |>\nThe only problem is that (integer-gcd a b) is only available in\
    \ Racket and not in Racket+\n<|/ c |>\n<| a tags=functional-programming,scheme,racket\
    \ dscore=3 |>\n<code>\n(define (gcd a b)\n  (if (= a 0)\n      b\n      (gcd (remainder\
    \ a b) (remainder (quotient a b) b))))\n</code>\n<|/ a |>\n<| c |>\nThis answer\
    \ contains code that is better than most of the other answers here. Thanks!\n\
    <|/ c |>\n<| a tags=functional-programming,scheme,racket |>\n<code>\n(define (gcd\
    \ a b)\n  (let loop (", "{\n\tif(b == 0)\n\t\treturn a;\n\treturn greatest_common_divisor(b,\
    \ a % b);\n}\n/*\n Return the smallest number n such that 2**(n-1) <= a <= 2**n.\n\
    \    Use n to determine a number of bit shifts required.\n */", "{\n    long m;\n\
    \    m = a % b;\n    if (m < 0) {\n        m += b;\n    }\n    return m;\n}\n\
    /* \n Return the greatest common divisor of a and b\n    \n*/\nlong gcd(long a,\
    \ long b) \n{\n    if (b == 0)\n        return a;\n    return greatest_common_divisor(a,\
    \ b);\n}", "{\n    int n = a / b;\n    int remainder = a % b;\n    if (remainder\
    \ > n) { n = remainder; }\n    return b;\n}\n</code>\n<|/ a dscore=1 tags=function,lua,c++\
    \ |>\n<| c |>\nThanks for your response. Do you know why this program doesn't\
    \ work for positive integers. For example: `greatest_common_divisor(13, 18)` returns\
    \ `12` instead of `18`\n<|/ c |>\n<| c |>\nIf you're not familiar with integer\
    \ overflow, check [this link](http://www.cs.utah.edu/dept/old/texinfo/glibc-manual-0.02/library_21.html#SEC57)\n\
    <|/ c |>\n<| c |>\n, just add `return b + a;` after `int n = a / b;`\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "{\n\tif (a == 0)\n\t\treturn b;\n\tif (b == 0)\n\t\
    \treturn a;\n\treturn greatest_common_divisor(b, a % b);\n}\n/*\n Return a least\
    \ common multiple of two integers a and b\n >>> least_common_multiple(20L, 40L)\n\
    \ 20L\n >>> least_common_multiple(20L, 30L)\n 40L\n >>> least_common_multiple(20L,\
    \ 50L)\n 20L\n >>> least_common_multiple(20L, 30L)\n 40L\n*/\nlong least_common_multiple(long\
    \ a, long b)\n{\n\tif (a == 0 || b == 0)\n\t\treturn 0;\n\tif (a > b)\n\t\tstd::swap(a,\
    \ b);\n\tint result = 1;\n\twhile (result > 0 && a > 0)\n\t{\n\t\tresult /= a;\n\
    \t\ta--;\n\t}\n\tif (result != 1)\n\t\tresult = a;\n\twhile (b > 0)\n\t{\n\t\t\
    result *= b;\n\t\tb--;\n\t}\n\treturn result;\n}\n/*\n Given a binary number,\
    \ return its compliment. \n >>> compliment(1L)\n 1L\n >>> compliment(-1L)\n 2L\n\
    \ >>> compliment(2L)\n 1L\n >>> compliment(0)\n 0L\n*/\nlong compliment(long value)\n\
    {\n\tif (value == 0) \n\t\treturn 0;\n\telse\n\t\treturn ~value;\n}\n/*\n Given\
    \ two binary numbers, return their sum\n >>> sum_of_two_binary(1L, 0L)\n 1L\n\
    \ >>> sum_of_two_binary(0L, 1L)\n 0L\n >>> sum_of_two_binary(1L, 1L)\n 1L\n*/\n\
    long sum_of_two_binary(long number1, long number2)\n{\n\treturn number1 + number2;\n\
    }\n/*\n Given a binary number, return its parity. \n >>> parity(1L)\n 1L\n >>>\
    \ parity(-1L)\n -1L\n >>> parity(2L)\n 1L\n >>> parity(0)\n 0L\n*/\nlong parity(long\
    \ value)\n{\n\tif (value == 0) \n\t\treturn 0;\n\telse\n\t\treturn -value;\n}\n\
    /*\n Given a binary number, return its parity with leading zeros removed. \n >>>\
    \ parity_with_leading_zeros(0L)\n 0L\n >>> parity_with_leading_zeros(1L)\n 1L\n\
    \ >>> parity_with_leading_zeros(2L)\n 1L\n >>> parity_with_leading_zeros(3L)\n\
    \ 2L\n ", "{\n\tif (a == 0 || b == 0)\n\t\treturn 0;\n\tif (b == 1)\n\t\treturn\
    \ a;\n\tlong gcd = greatest_common_divisor(b, a % b);\n\tif (a == gcd)\n\t\treturn\
    \ a;\n\treturn gcd;\n}\n/*\n Return a power of two with given exponent\n    >>>\
    \ power_of_2(3, 3)\n    8\n    >>> power_of_2(7, 1)\n    128\n    \n*/\nlong power_of_2(long\
    \ exponent, long base) \n{\n\tlong n = 1;\n\tfor (long power = 1; power < exponent;\
    \ power++)\n\t\tn *= base;\n\treturn n;\n}\n/*\n Convert a string representing\
    \ a number in base to a long integer\n @param string number\n @param string base\n\
    \ @return long number\n @throws Exception \n @note Exception raised if string\
    \ contains non-numeric characters or \n   no base can be found for given base\n\
    */\nlong base_to_integral_string(string number, string base) \n{\n\tlong result\
    \ = 0;\n\tfor (auto c: number) \n\t{\n\t\tif (!std.isdigit(c))\n\t\t\tthrow new\
    \ Exception(to_string() << \"Invalid character in string: \" << c);\n\t\tint val\
    \ = (c - '0');\n\t\tif (base == \"dec\") \n\t\t{\n\t\t\tif (val < 0) \n\t\t\t\t\
    throw new Exception(to_string() << \"Invalid value in string: \" << number);\n\
    \t\t\tresult += val * std.powl(10, std.log10(std.type_size<string>::size));\n\t\
    \t}\n\t\telse\n\t\t{\n\t\t\tif (val == 0)\n\t\t\t\tthrow new Exception(to_string()\
    \ << \"Invalid value in string: \" << number);\n\t\t\tresult += (val << std.log10(std.type_size<string>::size))\
    \ * std.powl(10, std.log10(std.type_size<string>::size));\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\n Convert a string representing a number to base to a long integer\n\
    \ @param string number\n @param string base\n @return long number\n @throws Exception\
    \ \n @note Exception raised if string contains non-numeric characters or \n  \
    \ no base can be found for given base\n*/\nlong decimal_to_base_string(string\
    \ number, string base) \n{\n\tlong result = 0;\n\tfor (auto c: number) \n\t{\n\
    \t\tif (!std.isdigit(c))\n\t\t\tthrow new Exception(to_string() << \"Invalid character\
    \ in string: \" << c);\n\t\tint val = (c - '0');\n\t\tif (base == \"dec\") \n\t\
    \t{\n\t\t\tif (val < 0) \n\t\t\t\tthrow new Exception(to_string() << \"Invalid\
    \ value in string: \" << number);\n\t\t\tresult += val * st", "{\n    long p =\
    \ 1;\n    long q = a / p;\n    long r = a % p;\n    while(p != 1) {\n        p\
    \ = q;\n        q = r / p;\n        r = r % p;\n    }\n    return q * b % p;\n\
    }\n// END OF greatest_common_divisor in file std.math", "{\n  long d, t;\n  \n\
    \  d = a / b;\n  t = a % b;\n  while (t != 0) {\n    d = d;\n    t = t;\n  }\n\
    \  \n  return d;\n}", "{\n\tlong d = 1;\n\twhile(a != 0) {\n\t\tlong m = (a +\
    \ b) / 2;\n\t\tif (a % 2 == 1 && b % 2 == 1) m++;\n\t\tif (m > d) { d = m; a =\
    \ m % a; b = m % b; }\n\t\telse break;\n\t}\n\treturn d;\n}", "{\n    if (a <\
    \ b) \n        swap(a, b);", "{\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn\
    \ greatest_common_divisor(b, a%b);\n}\n/*\n Return the least common multiple of\
    \ two integers a and b\n    >>> least_common_multiple(3L, 5L)\n    3L\n    >>>\
    \ least_common_multiple(25L, 15L)\n    15L\n    \n*/\nlong least_common_multiple(long\
    \ a, long b)\n{\n\tlong greatest_common_divisor = greatest_common_divisor(a, b);\n\
    \tif(b == 0)\n\t\treturn a;\n\telse\n\t\treturn a/greatest_common_divisor;\n}\n\
    /*\n Return the value of pi\n    \n*/\ndouble pi()\n{\n\tdouble pi = 3.141592653589793;\n\
    \treturn pi;\n}\n/*\n Return the value of e\n    \n*/\ndouble e()\n{\n\tdouble\
    \ e = 2.718281828459045;\n\treturn e;\n}\n/*\n Return the value of pi/2\n    \n\
    */\ndouble pi_half()\n{\n\tdouble pi_half = 4.0;\n\treturn pi_half;\n}\n/*\n Return\
    \ the value of e^2\n    \n*/\ndouble e_half()\n{\n\tdouble e_half = 1.5;\n\treturn\
    \ e_half;\n}\n/*\n Return the value of e^(-2)\n    \n*/\ndouble e2_half()\n{\n\
    \tdouble e2_half = 0.5772156649015329;\n\treturn e2_half;\n}\n/*\n Return the\
    \ value of e^(-1)\n    \n*/\ndouble e_half_inverse()\n{\n\tdouble e_half_inverse\
    \ = 1.0;\n\treturn e_half_inverse;\n}\n/*\n Return the value of e^(1/2)\n    \n\
    */\ndouble e1_half()\n{\n\tdouble e1_half = 0.16666666666666666667;\n\treturn\
    \ e1_half;\n}\n/*\n Return the value of e^(1/4)\n    \n*/\ndouble e4_half()\n\
    {\n\tdouble e4_half = 0.2309597535448805164;\n\treturn e4_half;\n}\n/*\n Return\
    \ the value of e^(1/8)\n    \n*/\ndouble e8_half()\n{\n\tdouble e8_half = 0.390882698109519144;\n\
    \treturn e8_half;\n}\n/*\n Return the value of e^(1/16)\n    \n*/\ndouble e16_half()\n\
    {\n\tdouble e16_half = 0.577215", "{\n  long max = 1;\n  while (max <= b)\n  {\n\
    \    if (a % max == 0 && b % max == 0)\n      max = max * 2;\n    else\n     \
    \ max = max * 2 + 1;\n  }\n  return max;\n}", "{\n    long res;\n    if(a == 0)\n\
    \        return b;\n    if(b == 0)\n        return a;\n    res = a % b;\n    if(res\
    \ == 0)\n        return b;\n    return greatest_common_divisor(b,res);\n}", "{\n\
    \t// TODO: fix this so it uses integers\n\tif (a == 1)\n\t\treturn b;\n\tif (b\
    \ == 1)\n\t\treturn a;\n\treturn __gcd(a, b);\n}\n/*\n Return the least common\
    \ multiple of two integers a and b\n    >>> least_common_multiple(3L, 5L)\n  \
    \  3L\n    >>> least_common_multiple(2L, 5L)\n    5L\n    \n*/\nlong least_common_multiple(long\
    \ a, long b) \n{\n\t// TODO: fix this so it uses integers\n\tif (a == 1)\n\t\t\
    return b;\n\tif (b == 1)\n\t\treturn a;\n\treturn a * b;\n}\n/*\n Return true\
    \ if the two integers a and b are equal or both 1\n    >>> is_one(4L, 4L)\n  \
    \  True\n    >>> is_one(4L, 4L)\n    True\n    \n*/", "{\n\treturn a > b ? greatest_common_divisor(b,\
    \ a % b) : a;\n}\n/*\n Return true iff all elements of 'a' are in 'b'.\n */",
  "{\n\tlong x, y, temp;\n\t\n\tx = a;\n\ty = b;\n\twhile(y != 0) \n\t{\n\t\ttemp\
    \ = y;\n\t\ty = x % y;\n\t\tx = temp;\n\t}\n\treturn x;\n}", "{\n\tlong x = 0;\n\
    \tif (a > b) {\n\t\tlong t = b;\n\t\tb = a;\n\t\ta = t;\n\t}\n\tfor (long y =\
    \ 1; b <= a / 2; ++y) {\n\t\tif (a % y == 0)\n\t\t\tbreak;\n\t}\n\tx = y;\n\t\
    while (a % x == 0) {\n\t\tx = x + 1;\n\t\ta = a / x;\n\t}\n\treturn x;\n}\n'''",
  "{\n    long gcd =  1;\n    while (b != 0)\n    {\n        if ((b&1) == 1)\n   \
    \     {\n            gcd = lcm(gcd, b);\n        }\n        b /= 2;\n    }\n \
    \   return gcd;\n}", "{\n    long gcd;\n    \n    if(a < 0)\n        a = -a;\n\
    \    if(b < 0)\n        b = -b;\n    if(a < b)\n        return a;\n    if(a ==\
    \ b)\n        return a;\n    \n    for(gcd=a; a > b; a--)\n        if(b % a ==\
    \ 0)\n            break;\n    for(; b > a; b--)\n        if(b % a == 0)\n    \
    \        break;\n    return gcd;\n}", "{\n    long gcd;\n    \n    while ( b )\n\
    \    {\n        gcd=b%a;\n        b=a;\n        a=gcd;\n    }\n    return a;\n\
    }\n/* Test std.math.rem_n() */", "{\n\tif(b == 0)\n\t\treturn a;\n\tlong gcd =\
    \ greatest_common_divisor(b, a%b);\n\treturn a / gcd >= b ? a / gcd : gcd;\n}",
  "{\n    return greatest_common_divisor(a,b,1,1);\n}\nlong greatest_common_divisor(long\
    \ a, long b, long c, long d)\n{\n    long gcd;\n    if(a == 0) {\n        return\
    \ b;\n    }\n    else if(a == 1){\n        return c;\n    }\n    else if(a ==\
    \ 2){\n        return d;\n    }\n    else if(a > b) { \n        return greatest_common_divisor(b,a,1,1);\n\
    \    }\n    else {\n        gcd = greatest_common_divisor(b%a,a,1,1);\n      \
    \  if(gcd!=1)\n            return gcd;\n        gcd = greatest_common_divisor(b%a,a,1,1);\n\
    \        if(gcd!=1)\n            return gcd;\n        return a;\n    }\n}", "{\n\
    \    int gcd = 1;\n    while (b != 0) \n    {\n        long temp = b;\n      \
    \  b = a % b;\n        a = temp;\n        gcd *= gcd < 0 ? gcd : gcd > a ? a :\
    \ gcd;\n    }\n    return gcd;\n}", "{\n    if (a == 0)\n        return b;\n \
    \   else if (b == 0)\n        return a;\n    long low = b;\n    while (a % low\
    \ == 0) {\n        low--;\n        if (low == 0)\n            return b;\n    }\n\
    \    return low;\n}", "{\n    return gcd(a,b); \n}\n/*\n Return true if two integers\
    \ a and b are relatively prime\n    >>> is_relatively_prime(15L, 12L)\n    True\n\
    \    >>> is_relatively_prime(-3L, 2L)\n    True\n    >>> is_relatively_prime(15L,\
    \ 8L)\n    False\n*/", "{\n    long m;\n    long t;\n    while (b != 0)\n    {\n\
    \    \tm = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}", "{\n\
    \  long x = a % b;\n  while (x > b)\n    x -= b;\n  return x;\n}", "{\n    long\
    \ n = a % b;\n    while (a != b) {\n        if (a > b) {\n            a = a -\
    \ b;\n        } else {\n            b = b - a;\n        }\n        n = a % b;\n\
    \    }\n    return n;\n}", "{\n    long d = 0;\n    while (b > 0) {\n        if\
    \ (a % b == 0)\n            return b;\n        b /= 2;\n    }\n    return a;\n\
    }\n/* Compute the prime factorization of the number a and return the number\n\
    \ * of prime factors.  \n */\nlong prime_factorization(long a, long d = 0)\n{\n\
    \    bool prime = true;\n    long b = a;\n    while (b > 0) {\n        if (b %\
    \ 2 == 0)\n            prime = false;\n        b /= 2;\n    }\n    if (prime)\n\
    \        return d;\n    d = 2;\n    while (a > 2) {\n        if (a % d == 0)\n\
    \            return d;\n        d *= 2;\n        a /= d;\n    }\n    return d;\n\
    }\n/* Compute the power of the number a to the power p, where p is a\n * power\
    \ of 2, and return the result.\n */\nlong power2(long a, long p)\n{\n    long\
    \ c = 1;\n    while (p > 0) {\n        if (p % 2 == 1)\n            c *= a;\n\
    \        a *= a;\n        p /= 2;\n    }\n    return c;\n}\n/* Return the square\
    \ of a number.  \n */\nlong square(long a)\n{\n    return a*a;\n}\n/* Compute\
    \ the GCD of a and b and return the result.  \n */\nlong gcd(long a, long b)\n\
    {\n    return greatest_common_divisor(b, a % b);\n}\n/* Compute the lcm of a and\
    \ b and return the result.  \n */\nlong lcm_of_2s(long a, long b)\n{\n    return\
    \ a * b / (b * a);\n}\n/* Compute the gcd of the integers a, b, and c.  \n */\n\
    long gcd_of_3s(long a, long b, long c)\n{\n    return greatest_common_divisor(b,\
    \ c);\n}\n/* Compute the lcm of three integers a, b, c, and d.  \n */\nlong lcm_of_3s(long\
    \ a, long b, long c, long d)\n{\n    return (a * b + c * d) / (b * c + d * a);\n\
    }\n/* Compute the gcd of the integers a, b, and c, and return the result.  \n\
    \ */\nlong gcd_of_2s(long a, long b, long c)\n{\n    return greatest_common_divisor(b,\
    \ c);\n}\n/* Compute the gcd of the integers a, b, c, d, e, and f.  \n */\nlong\
    \ gcd_of_5s(long a, long b, long c, long d, long e, long f)\n{\n    return greatest_common_divisor(b,\
    \ c);\n}\n/* Compute the lcm of five integers a, b, c, d, e, and f.  \n */\nlong\
    \ lcm_of_5s(", "{\n    long gcd;\n    \n    while (a != 0)\n    {\n        gcd\
    \ = std.math.gcd((std.int) a, (std.int) b);\n        a = std.math.modf(a, gcd);\n\
    \        b = std.math.modf(b, gcd);\n    }\n    return a;\n}", "{\n    long t;\n\
    \    while (b != 0)\n    {\n        t = a;\n        a = b;\n        b = t;\n \
    \   }\n    return a;\n}", "{\n    long gcd = 0;\n    for(long i = a; ; i = i /\
    \ 2) \n    {\n        if(i % 2 == 0 && i != 0)\n        {\n            gcd = i;\n\
    \            break;\n        }\n        if(i != 1)\n            gcd = 1;\n   \
    \ }\n    for(long i = b; ; i = i / 2)\n    {\n        if(i % 2 == 0 && i != 0)\n\
    \        {\n            gcd = i;\n            break;\n        }\n        if(i\
    \ != 1)\n            gcd = 1;\n    }\n    return gcd;\n}", "{\n    // assert(a\
    \ != 0 && b != 0);\n    long gcd;\n    while (b != 0)\n    {\n        gcd = a\
    \ % b;\n        a = b;\n        b = gcd;\n    }\n    return a;\n}\n/*\n Return\
    \ the least common multiple of two integers a and b\n    >>> least_common_multiple(2L,\
    \ 5L)\n    3L\n    \n*/\nlong least_common_multiple(long a, long b) \n{\n    //\
    \ assert(a != 0 && b != 0);\n    long lcm;\n    while (b != 0)\n    {\n      \
    \  lcm = a % b;\n        a = b;\n        b = lcm;\n    }\n    return a;\n}\n/*\n\
    \ Return the least common multiple of a list of integers n\n    >>> least_common_multiple([2L,\
    \ 5L, 7L])\n    15L\n    \n*/\nlong least_common_multiple(long n[]) \n{\n    //\
    \ assert(n != nil);\n    return least_common_multiple(n[0], n[1]);\n}\n/*\n Return\
    \ the least common multiple of a list of integers n\n    >>> least_common_multiple([2L,\
    \ 5L, 7L], 2)\n    15L\n    \n*/\nlong least_common_multiple(long n[], long k)\
    \ \n{\n    // assert(n != nil && k != 0);\n    long lcm = k; \n    for (int i\
    \ = 0; i < n.length; i++) \n    {\n        lcm = lcm * n[i];\n    }\n    return\
    \ lcm;\n}\n/*\n Return the GCD of two integers\n    >>> gcd(3L, 5L)\n    1L\n\
    \    \n*/\nlong gcd(long a, long b) \n{\n    return greatest_common_divisor(a,\
    \ b);\n}\n/*\n Return the GCD of two lists of integers n\n    >>> gcd([2L, 5L,\
    \ 7L])\n    15L\n    \n*/\nlong gcd(long n[]) \n{\n    // assert(n != nil);\n\
    \    return greatest_common_divisor(n[0], n[1]);\n}\n/*\n Return the GCD of two\
    \ lists of integers n\n    >>> gcd([2L, 5L, 7L], 2)\n    15L\n    \n*/\nlong gcd(long\
    \ n[], long k) \n{\n    // assert(n != nil && k != 0);\n    return greatest_common_divisor(n[0],\
    \ n[1]);\n}\n/*\n Return a random integer in the range 0..a\n    >>> random(0)\n\
    \    0L\n    \n*/\nlong random(long a) \n{\n    // assert(a != 0);\n    return\
    \ std.random.random();\n}\n/*\n Return a random integer in the ", "{\n  long temp;\n\
    \  if(b == 0) return a;\n  if(b > a) return greatest_common_divisor(b, a % b);\n\
    \  temp = a;\n  a %= b;\n  if(b != 0) temp = b;\n  do\n  {\n    a %= temp;\n \
    \   temp %= temp;\n  }\n  while(b != 0);\n  return temp;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=1 |>\n<code>", "{\n    while (b > 0) {\n        long r = a % b;\n\
    \        a = b;\n        b = r;\n    }\n    return a;\n}\n/*\n Return a least\
    \ common multiple of two integers a and b\n    >>> least_common_multiple(3L, 5L)\n\
    \    3L\n    >>> least_common_multiple(25L, 15L)\n    30L\n*/\nlong least_common_multiple(long\
    \ a, long b) \n{\n    int lcm = -1;\n    while (a != 0) {\n        a = b % a;\n\
    \        b = lcm;\n        lcm = a;\n    }\n    return lcm;\n}\n/*\n Return a\
    \ factorial of n\n    >>> factorial(3L)\n    6L\n    \n*/\nlong factorial(int\
    \ n)\n{\n    long result = 1;\n    for (int i = 0; i < n; i++)\n        result\
    \ *= n;\n    return result;\n}\n/*\n Return square root of number\n    >>> sqrt(9L)\n\
    \    5.00000000000000000000\n    \n*/\nfloat sqrt(float x)\n{\n    float result\
    \ = 0;\n    float a = 0;\n    float b = 0;\n    float delta;\n    float sqrtOfX;\n\
    \    for (int i = 0; i < 10; i++) {\n        a += x;\n        b = a * a - x;\n\
    \        if (b < 0) {\n            delta = b / a;\n            a = delta;\n  \
    \          if (a > 0)\n                result = result + delta / a;\n        \
    \    return result;\n        }\n        delta = b / a;\n        a = delta;\n \
    \   }\n    return result;\n}\n/*\n Return logarithm of number x to the base e\n\
    \    >>> log(2.0L, eL)\n    1.60943791243410037\n    \n*/\nfloat log(float x,\
    \ float e)\n{\n    float result = x;\n    float a = 0;\n    float b = 0;\n   \
    \ float delta;\n    float logOfX;\n    for (int i = 0; i < 10; i++) {\n      \
    \  a += x;\n        b = a * a - x;\n        if (b < 0) {\n            delta =\
    \ b / a;\n            a = delta;\n            if (a > 0)\n                result\
    \ = result + delta / a;\n            return result;\n        }\n        delta\
    \ = b / a;\n        a = delta;\n    }\n    return result;\n}\n/*\n Return cube\
    \ root of number\n    >>> cube(9L)\n    3.0000000000000004\n    \n*/\nfloat cube(float\
    \ x)\n{\n    float result = x;\n    float a = 0;\n    float b = 0;\n    float\
    \ delta;\n    float cubeOfX;\n    for (int i = 0; i < 10; i++) {\n        a +=\
    \ x;\n        b = a * a - x;\n        if (b < 0) {\n            delta = b / a;\n\
    \            a = delta;\n            if (a > 0)", "{\n    return std::max(a, b)\
    \ / std::min(a, b);\n}\nlong greatest_common_divisor(long a, long b, long max_divisor)\n\
    {\n    return greatest_common_divisor(a, b, max_divisor);\n}", "{\n    if (a>b)\n\
    \        std::swap(a, b);\n    long x = a;\n    long y = b;\n    for (;;) {\n\
    \        long q = a / y;\n        a = b;\n        b = q;\n        if (b==0)\n\
    \            break;\n        x = y;\n        y = x;\n    }\n    return x;\n}",
  "{\n    return std.math.gcd(a, b);\n}\n/*\n Return a least common multiple of two\
    \ integers a and b\n    >>> least_common_multiple(2L, 3L)\n    6L\n    >>> least_common_multiple(2L,\
    \ 4L)\n    6L\n    \n*/\nlong least_common_multiple(long a, long b)\n{\n    return\
    \ std.math.lcm(a, b);\n}", "{\n\tif(b == 0) {\n\t\treturn a;\n\t}", "{\n    if\
    \ (a == 0 || b == 0) {\n        return 0;\n    }\n    if (a > b) {\n        long\
    \ t = a;\n        a = b;\n        b = t;\n    }\n    long gcd = std.math.lcm(a,\
    \ b);\n    if (a == 1 && b == 1) return 1;\n    if (a == 1) return b;\n    if\
    \ (b == 1) return a;\n    return gcd;\n}\n/*\n This function computes the gcd\
    \ of two integers a and b and\n returns it as an integer. If gcd(a,b) = 1, then\
    \ return a\n and if gcd(a,b) = b, then return b.", "{\n\tif(b == 0)\n\t\treturn\
    \ a;\n\tif(b == 1) \n\t\treturn a;\n\tif(b & 1)\n\t\treturn greatest_common_divisor(a\
    \ % b, (b >> 1));\n\telse\n\t\treturn greatest_common_divisor(a % b, (b >> 1));\n\
    }", "{\n\tlong x = 0;\n\tlong lcm = 1;\n\t\n\tfor(;;) \n\t{\n\t\tlong div = lcm/a;\n\
    \t\tif(div > x) x = div;\n\t\tif(lcm%a < b%x) break;\n\t\tlcm = div;\n\t\ta =\
    \ b;\n\t\tb = x/a;\n\t}\n\t\n\treturn x;\n}", "{\n    long a1 = a % b;\n    long\
    \ b1 = b - a1;\n    long gcd = std.math.gcd(a1, b1);\n    return a1 * gcd + b1;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "{\n    long c = a % b;\n   \
    \ while (c != 0) \n    {\n        if (a > b)\n        {\n            a -= b;\n\
    \        }\n        else\n        {\n            b -= c;\n        }\n        c\
    \ = a % b;\n    }\n    return b;\n}\n</code>\n<|/ a tags=c#,algorithm,python dscore=3\
    \ |>\n<| c |>\nIf you're going to make such a big edit to his answer, at least\
    \ include the [original source code](http://stackoverflow.com/revisions/11566092/1).\n\
    <|/ c |>\n<| c |>\nI wouldn't post something so simple as a solution.  I'm assuming\
    \ he will learn more from this than just copy paste his/her homework\n<|/ c |>\n\
    <| c |>\nI up-voted your answer because I believe it has a much higher quality\
    \ than the accepted one.\n<|/ c |>\n<| a dscore=3 |>\nThe algorithm for finding\
    \ the greatest common divisor of two numbers is a classic example of a binary\
    \ search algorithm.\nThe Wikipedia entry has a good example of binary search in\
    \ C.\nHere's my C implementation of a binary search algorithm in case someone\
    \ needs it:\n<code>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\
    #include <stdbool.h>"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
