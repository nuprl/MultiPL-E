name: HumanEval_76_is_simple_power
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nYour task is to write a function\
  \ that returns true if a number x is a simple\n    power of n and false in other\
  \ cases.\n    x is a simple power of n if n**int=x\n    For example:\n    >>> is_simple_power(1L,\
  \ 4L)\n    true\n    >>> is_simple_power(2L, 2L)\n    true\n    >>> is_simple_power(8L,\
  \ 2L)\n    true\n    >>> is_simple_power(3L, 2L)\n    false\n    >>> is_simple_power(3L,\
  \ 1L)\n    false\n    >>> is_simple_power(5L, 3L)\n    false\n    \n*/\nbool is_simple_power(long\
  \ x, long n) \n"
tests: "unittest\n{\n    alias candidate = is_simple_power;\n\n    assert(candidate(16L,\
  \ 2L) == true);\n    assert(candidate(143214L, 16L) == false);\n    assert(candidate(4L,\
  \ 2L) == true);\n    assert(candidate(9L, 3L) == true);\n    assert(candidate(16L,\
  \ 4L) == true);\n    assert(candidate(24L, 2L) == false);\n    assert(candidate(128L,\
  \ 4L) == false);\n    assert(candidate(12L, 6L) == false);\n    assert(candidate(1L,\
  \ 1L) == true);\n    assert(candidate(1L, 12L) == true);\n}\nvoid main(){}"
completions: ["{\n   if (n == 1L) return true;\n   \n   var i = 1;\n   \n   while\
    \ (i < n) \n   {\n       if (x % i == 0L) \n       {\n           x = x / i;\n\
    \           return false;\n       }\n       i++;\n   }\n   return true;\n}\n</cell>\n\
    <text>\nQuestion 7: Write a function that returns the number x raised to the power\
    \ n. \n    x raised to the power n is given as:", "{\n    if(x < 0)\n    {\n \
    \       return false;\n    }\n    else if(x == 0)\n    {\n        return true;\n\
    \    }\n    else if(x > 0 && x < n)\n    {\n        return (n * n) == x;\n   \
    \ }\n    return false;\n}\n</code>\n<|/ a tags=math,c#,function |>\n<| c |>\n\
    I suspect you mean `long n` instead of `int n`. I tried it with 5 and it gives\
    \ me the incorrect answer as you did.\n<|/ c |>\n<| c |>\nI edited my answer to\
    \ remove my mistakes. I was using long instead of long in is_simple_power. Now\
    \ it works fine.\n<|/ c |>\n<| c |>\nOops, I made a mistake. I forgot to change\
    \ `int` to `long` in the `is_simple_power` function. Now it is corrected.\n<|/\
    \ c |>\n<| a |>\nIt might be a solution:\n<code>", "{\n\tif (x == 1) \n\t{\n\t\
    \treturn true;\n\t}\n\telse if (x < 1 || n < 1) \n\t{\n\t\treturn false;\n\t}\n\
    \telse if (n == 1) \n\t{\n\t\treturn true;\n\t}\n\telse if (n == 2) \n\t{\n\t\t\
    return (is_power_of_2(x));\n\t}\n\telse if (n % 2 == 0) \n\t{\n\t\treturn (is_power_of_2(x)\
    \ && is_power_of_2(n));\n\t}\n\telse \n\t{\n\t\treturn (is_power_of_2(x) && is_power_of_2(n)\
    \ && is_simple_power(x / 2, n-1));\n\t}\n}", "{\n\tif(n==0)\n\t\treturn true;\n\
    \tif(n==1)\n\t\treturn x==1;\n\tif(n==-1)\n\t\treturn x==1;\n\treturn is_simple_power(x,n/2);\n\
    }\n</code>\nThis is not the best algorithm possible, but it is simple and easy\
    \ to understand. \nBy the way, this code does not check for negative numbers.\
    \ \nIt also checks whether the power is a multiple of 2, but this can be easily\
    \ remedied.\n<|/ a tags=performance,c++,time-complexity,recursion,loops |>\n<|\
    \ c |>\nThis is a good idea, but it does not seem to return true if the number\
    \ is negative. Also, for me this would be hard to remediate.\n<|/ c |>\n<| c |>\n\
    It does return true if the number is negative. The power has to be a multiple\
    \ of 2 for this to work.\n<|/ c |>\n<| c |>\nYour code does seem to be the simplest\
    \ way to check if a number is a power of two. I think this should be the accepted\
    \ answer.\n<|/ c |>\n<| c |>\n: Yes, but you had mentioned in your question that\
    \ you were not interested in negative numbers. Also, I noticed that your question\
    \ was marked as a duplicate of [this](http://stackoverflow.com/questions/152580/how-to-determine-if-a-number-is-a-power-of-2),\
    \ which is why I mentioned this solution.\n<|/ c |>\n<| c |>\nHmm, I must have\
    \ missed that. Yes, the accepted answer to that question seems good, but I am\
    \ not able to solve it for negative numbers. I think I am going to just delete\
    \ this question, as I think it is not a good question to ask here.\n<|/ c |>\n\
    <| a tags=performance,c++,time-complexity,recursion,loops |>\nIf your numbers\
    \ are positive (which they should be), you can just use binary search:\n<code>",
  "{\n    return std.math.pow(x, intdiv(x, n)) == x;\n}", "{\n    if (n == 0) return\
    \ true;\n    long xsq = x*x;\n    if (n%2 == 0)\n    {\n        if (xsq == (long)\
    \ n) return true;\n        else return (xsq > n) ;\n    }\n    else return (xsq\
    \ > n) ;\n}\n/*\nYour task is to implement the function is_power_of_2(long) given\
    \ by\n    \n    n > 0L\n    n <= 0L\n    2^n = x\n    x > 1L\n    \n    Your implementation\
    \ must be recursive.\n    Your function must not use any non-standard function\
    \ like log2.\n    \n    If n is 0L, then the function must return true.\n*/",
  "{\n  return x == std.pow(n,x);\n}\n</code>\n<|/ a tags=c++,gcc,std,c++11 |>\n<|\
    \ a tags=c++,gcc,std,c++11 |>\nThe function std::pow is not standard C++; you\
    \ can implement it yourself as:\n<code>\ntemplate <typename T, typename U>\nT\
    \ pow(U const &x, U const &n)\n{\n  return std::pow(n, x);\n}\n</code>\nIt works\
    \ with double, long and int. With C++0x, you can even specify the return type\
    \ directly:\n<code>\ntemplate <typename T, typename U>\nusing pow = std::pow<T>;",
  "{\n  if (n < 0L) {\n    throw runtime_error(\"Error: n can't be negative or zero!\"\
    );\n  }\n  if (n > 0L) {\n    if (std.math.isPowerOf(x, n)) {\n      return true;\n\
    \    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n\
    }\n</code>\n<|/ a tags=c++ dscore=0 |>\n<| c |>\nThis question was asked in an\
    \ interview. Your answer is not very helpful and does not answer the question.\
    \ Could you please elaborate your answer a little bit more?\n<|/ c |>\n<| c |>\n\
    I believe that this answers the question. It just doesn't use exceptions and I\
    \ fail to see how it's going to be any better than just looping.\n<|/ c |>\n<|\
    \ c |>\nWhat exactly do you fail to see?\n<|/ c |>\n<| c |>\nThe interviewer asked\
    \ me this question and I provided him an answer but I wasn't satisfied with it.\
    \ I was looking for a better solution.\n<|/ c |>\n<| c |>\nWell, it's better than\
    \ nothing. But I fail to see how this can be any better than just looping. As\
    \ for \"interviewer asked this question\", this answer seems correct to me. Can\
    \ you explain why this doesn't satisfy the requirements?\n<|/ c |>\n<| a |>\n\
    The interviewer was looking for an alternative to try-catch blocks. Since C++\
    \ doesn't have them, they were looking for a way to implement them in a way that\
    \ they could understand and follow the flow of the program. \n<code>", "{\n  int\
    \ z = 1;\n  while(z <= n/2) {\n    if(z*n==x) {\n      return true;\n    }\n \
    \   z *= 2;\n  }\n  return false;\n}\n</code>\n<|/ a dscore=0 tags=time-complexity,algorithm,big-o\
    \ |>\n<| c |>\nI believe the OP wanted to know how to determine the big-Oh time\
    \ complexity, rather than to implement the algorithm itself.\n<|/ c |>\n<| a |>\n\
    <code>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>", "{\n    if (x==1)\
    \ return true;\n    int pow = log2(n);\n    if (x<pow) return true;\n    if (x==pow)\
    \ return true;\n    return false;\n}\n</code>\n<|/ a dscore=0 tags=python,math\
    \ |>\n<| c |>\nThis is an interesting solution. I've been trying to think of how\
    \ I'd convert this to Python as I can't think of a way to use bitwise operators\
    \ in Python. Still looking for a good way to do it.\n<|/ c |>\n<| c |>\nActually\
    \ that works. I just converted it to a Python script and ran it and it returned\
    \ true for x = 1 and n = 4. That's pretty cool.\n<|/ c |>\n<| c |>\nAh, I see\
    \ I didn't read your comment properly. I was trying to do it in Python, which\
    \ didn't work because I don't think there is an operator for bitwise operations\
    \ in Python. I just tried it again using Python and it works.\n<|/ c |>\n<| c\
    \ |>\nHi Eric Lippert, you forgot to import the log2 function. The function definition\
    \ is  from math import log2\n<|/ c |>\n<| c |>\nIt says log2 is not defined on\
    \ Windows. I did import it though. What are you using?\n<|/ c |>\n<| a tags=python,math\
    \ |>\nIf you only need to check powers of 2, you could use Python's builtin pow()\
    \ function. It's not particularly efficient, but I assume that's okay.\n<code>\n\
    def is_power_of_two(n):\n  return pow(2, n-1, 2) <= n\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=python,math |>\nAn approach that works in any language that uses\
    \ the integer pow() function would be to simply use integer arithmetic to determine\
    \ if the number is even or not.\nIn Python, for example:\n<code>\ndef is_power_of_two(n):\n\
    \    return (n == pow(2, n - 1))\n</code>\nOr you could use the same approach\
    \ as above, but with an if statement:\n<code>\ndef is_power_of_two(n):\n    if\
    \ n == 1:\n        return True\n    else:\n        return (n == pow(2, n - 1))\n\
    </code>\nThat approach is pretty inefficient, but it's pretty straight forward\
    \ to understand and implement.\n<|/ a dscore=0 |>\n<| c |>\nThis will fail for\
    \ n \u2260 1, or for negative numbers.\n<|/ c |>\n<| c |>\nThanks. I updated it\
    \ with a check for n == 1.\n<|/ c |>\n<| c |>\nNo, this will fail for n == 0,\
    \ which I believe is the desired result.\n<|/ c |>\n<| c ", "{\n\tif(n == 1) \n\
    \t\treturn true;\n\tif(n == 0) \n\t\treturn false;\n\treturn n%x == 0 && is_simple_power(x/n,\
    \ n-1);\n}", "{\n    auto pow = [=](long a, long b) {\n        return std.math.pow(std.intmaxval,\
    \ a) == b;\n    };\n    return (pow(n, n) == x) ? true : false;\n}", "{\n  //\
    \ TODO: fill this in!\n  return false;\n}\n</code>\n<|/ a |>\n<| c |>\nCan you\
    \ please let me know how do I go about checking the power of n ? Like n**int=x\
    \ ?\n<|/ c |>\n<| c |>\nThe \"simple\" case that you are mentioning is that n\
    \ is a power of n.  You might want to think of some other cases as well.  For\
    \ example, what about `n` being 1 or a power of 0?  If you think about what you\
    \ should be doing with these, you'll see that they aren't a power of `n`.\n<|/\
    \ c |>\n<| c |>\nYeah you are right there should be other cases too but that is\
    \ just a starting point. Can you please tell me how to go about checking the power\
    \ of n ? Like n**int=x ?\n<|/ c |>\n<| c |>\n`if (x==1L) { return true; }` would\
    \ be the simplest case, where `x` is exactly 1.\n<|/ c |>\n<| c |>\nI tried this\
    \ but it didn't work like I wanted it to be.. \nHere is the code :\n`if (x==1L)\
    \ { return true; }\nif (x==2L) { return true; }\nif (x==3L) { return true; }\n\
    if (x==4L) { return true; }\nif (x==5L) { return true; }\nif (x==6L) { return\
    \ true; }\nif (x==7L) { return true; }\nif (x==8L) { return true; }\nif (x==9L)\
    \ { return true; }\nif (x==10L) { return true; }\nif (x==11L) { return true; }\n\
    if (x==12L) { return true; }\nif (x==13L) { return true; }\nif (x==14L) { return\
    \ true; }\nif (x==15L) { return true; }\nif (x==16L) { return true; }\nif (x==17L)\
    \ { return true; }\nif (x==18L) { return true; }\nif (x==19L) { return true; }\n\
    if (x==20L) { return true; }\nif (x==21L) { return true; }\nif (x==22L) { return\
    \ true; }\nif (x==23L) { return true; }\nif (x==24L) { return true; }\nif (x==25L)\
    \ { return true; }\nif (x==26L) { return true; }\nif (x==27L) { return true; }\n\
    if (x==28L) { return true; }\nif (x==29L) { return true; }\nif (x==30L) { return\
    \ true; }\nif (x==31L) { return true; }\nif (x==32L) { return true; }\nif (",
  "{\n    long long power = 1;\n    long long base = 1;\n    long long exponent =\
    \ 0;\n    long long power_of_x;\n    bool result = false;\n    if (n>1){\n   \
    \     power_of_x = pow(x, n);\n        base = power_of_x - x;\n        exponent\
    \ = n;\n        result = true;\n    }\n    return result;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThanks for the suggestion, but I didn't understand it clearly. Could\
    \ you please elaborate on the algorithm for me?\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\nimport std.core;\nimport std.algorithm;\nimport std.conv;\nimport std.stdio;\n\
    import std.string;\nimport std.conv;", "{\n    if(n>0)\n    {\n        if (std.is_power_of_two(n))\
    \ {\n            return std.pow(x,n) == x;\n        }\n    }\n    return false;\n\
    }\n</code>\n<|/ a tags=c,c++,stl,algorithm,time-complexity |>\n<| a |>\nHere is\
    \ another solution in C:\n<code>\n#include <stdio.h>\n#include <stdbool.h>", "{\n\
    \    return x % n == 0;\n}", "{\n    double result = pow(x, n);\n    double result2\
    \ = sqrt(result);\n    if (result2 != result) {\n        return false;\n    }\n\
    \    return true;\n}", "{\n     /* write your code here */\n    \n     return\
    \ is_power((double)x, (double)n, true, 1);\n     \n}", "{\n    long power = 1;\n\
    \    long square = 0;\n    long a = 1;\n    long sum = 0;\n    long i = 1;\n \
    \   \n    if (n == 0) return true;\n    if (n == 1) return false;\n    if (n ==\
    \ -1) return false;\n    \n    while (i*i <= n) {\n        square = a*a;\n   \
    \     a = sum + i*power;\n        sum = square;\n        power = power*x;\n  \
    \      i = i*10;\n    }\n    return ((square-sum)==(power*power));\n}", "{\n \
    \   if(!is_integer(n) || !is_integer(x))\n        return false;\n    if(n < 0)\n\
    \        return x < 0;\n    if(n > 64)\n        return x < 0;\n    if(n < 64)\n\
    \        return false; // not power of 2\n    return pow(x, n) == x;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThank you very much for your help :) I understand it better\
    \ now !\n<|/ c |>\n<| a tags=c,math,bit-manipulation,algorithm |>\nThe general\
    \ formula is:", "{\n    if (x < 0 || n < 1)\n        return false;\n    long n\
    \ = pow(x, n);\n    return n == x;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`pow`\
    \ returns `double` - so if you call it with `x=8L` and `n=1` it will return `8.0`\
    \ and not `8.0`\n<|/ c |>\n<| c |>\n`long n = pow(x, n);` will return `long long`\
    \ so if you compare it with `x` it will be `long long n = 8L` instead of `long\
    \ long` which was required.\n<|/ c |>\n<| c |>\nThis code doesn't seem to be doing\
    \ the right thing.  For example, `is_simple_power(8L, 1L)` returns `true`.\n<|/\
    \ c |>\n<| c |>\nThis code is correct. `8L**1` returns `8.0`\n<|/ c |>\n<| c |>\n\
    `long n = pow(x, n);` is probably returning `long long`, as `pow()` returns `double`\
    \ (at least on my machine).\n<|/ c |>\n<| a dscore=0 |>\n<code>\nfunction is_powerofn(n:Long,\
    \ x:Long) \n{\n  if(x < 1 || n < 1)\n  {\n    return false;\n  }\n  var power\
    \ = 1;\n  var temp:Long = x;\n  while(temp > 1)\n  {\n    power = power * temp;\n\
    \    temp = temp/2;\n  }\n  return n%power==0;\n}\n</code>\n<|/ a tags=java,c++,algorithm\
    \ |>\n<| c |>\nHow does this work? What does it do?\n<|/ c |>\n<| c |>\nIt calculates\
    \ n to the power of x. If x is even it calculates the square of x and divides\
    \ it by 2. If x is odd it multiplies x by itself and divides it by 2. If x is\
    \ 1 it returns true.\n<|/ c |>\n<| c |>\nI think you didn't understand what a\
    \ power function is. This function checks whether `n` is power of `x` not `x to\
    \ n` :)\n<|/ c |>\n<| c |>\nThe example I gave above is `n` power of `x` which\
    \ means it checks whether the input `n` is power of `x`. What else do you want?\n\
    <|/ c |>\n<| c |>\nI see, sorry, I misunderstood it. I thought you were saying\
    \ that `n` was power of `x`, but now I think you're saying that `n` is the square\
    \ of `x`, which is the power of `x`.  ", "{\n    if(x < 0 || n < 0) {\n      \
    \  return false;\n    }", "{\n    if(n < 0 || n > 1000000000)\n        return\
    \ true;\n    if(x != pow(x, n))\n        return true;\n    return false;\n}",
  "{\n    long y = (1L<<n)-1;\n    return (x == pow(y, x))\n}\n</code>\n<|/ a tags=bit-manipulation,algorithm,python,c++,math\
    \ dscore=2 |>\n<| a dscore=2 |>\nThe fastest solution is to use the formula nth\
    \ power of 2 which can easily be done using bitwise operations.\n<code>", "{\n\
    \    if (n == 1)\n        return true;\n    if (n % 2 == 0)\n        return is_simple_power(x,\
    \ n / 2);\n    return false;\n}", "{\n    long y = x;\n    long base = n;\n  \
    \  long count = 1;\n    while (n != 1)\n    {\n        if (n % 2 != 0)\n     \
    \   {\n            count = count * y;\n            y = y * y;\n        }\n   \
    \     n = n/2;\n    }\n    long sum = 0;\n    while (base != 1)\n    {\n     \
    \   sum = sum + base;\n        base = base * y;\n    }\n    long power = sum;\n\
    \    \n    if (power == x)\n        return true;\n    return false;\n}", "{\n\
    \    if(x < n)\n        return false;", "{\n    bool result = true;\n    if ((n\
    \ == 0) || (n==1))\n    {\n        result = true;\n    }\n    else if ( (x&1)\
    \ == 0 && x%2 == 1)\n    {\n        result = is_simple_power(x / 2, n);\n    }\n\
    \    else\n    {\n        /*\n        If x is a power of n, then n is a power\
    \ of n.\n        For example:\n        1**4 = 1\n        2**2 = 32\n        8**2\
    \ = 64\n        3**2 = 9\n        5**3 = 25\n        5**5 = 625\n        7**3\
    \ = 49\n        7**5 = 725\n        10**2 = 31\n        10**5 = 55\n        100**3\
    \ = 9\n        100**5 = 625\n        1000**3 = 8\n        1000**5 = 312\n    \
    \    100000**3 = 9\n        100000**5 = 625\n        1000000**3 = 8\n        1000000**5\
    \ = 512\n        10000000**3 = 8\n        10000000**5 = 512\n        100000000**3\
    \ = 8\n        100000000**5 = 512\n        1000000000**3 = 8\n        1000000000**5\
    \ = 512\n        10000000000**3 = 8\n        10000000000**5 = 512\n        100000000000**3\
    \ = 8\n        100000000000**5 = 512\n        1000000000000**3 = 8\n        1000000000000**5\
    \ = 512\n        10000000000000**3 = 8\n        10000000000000**5 = 512\n    \
    \    100000000000000**3 = 8\n        100000000000000**5 = 512\n        1000000000000000**3\
    \ = 8\n        1000000000000000**5 = 512\n        10000000000000000**3 = 8\n \
    \       10000000000000000**5 = 512\n        100000000000000000**3 = 8\n      \
    \  100000000000000000**5 = 512\n        1000000000000000000**3 = 8\n        1000000000000000000**5\
    \ = 512\n        1000000000000000000000**3 = 8\n        1000000000000000000000**5\
    \ = 512\n        10000000000000000000000**3 = 8\n        10000000000000000000000**5\
    \ = 512\n        100000000000000000000000**3 = 8\n        100000000000000000000000**5\
    \ = 512\n        1000000000000000000000000**3 = 8\n        1000000000000000000000000**5\
    \ = 512\n        10000000000000000000000000**3 = 8\n        10000000000000000000000000**5\
    \ = 512\n        10000000000000000000000000000000000**3 = 8\n        10000000000000000000000000000000000**5\
    \ = 512\n        10000000000000000000000000000000000000**3 = 8\n        10000000000000000000000000000000000000**5\
    \ = 512\n        100000000000000000000000000000000000000**3 = 8\n        100000000000000000000000000000000000000**5\
    \ = 512\n        1000000000000000000000000000000000000000**3 = 8\n        1000000000000000000000000000000000000000**5\
    \ = 512\n        10000000000000000000000000000000000000000**3 = 8\n        10000000000000000000000000000000000",
  "{\n    if (x<0 || n<=0)\n        return false;\n    if (n==1)\n        return true;\n\
    \    if (x%n!=0)\n        return false;\n    return is_simple_power(x/n, n);\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease avoid code-only answers. Please\
    \ add some explanation. How does this answer the question? How does it differ\
    \ from the other one?\n<|/ c |>\n<| c |>\nThis code works perfectly fine.", "{\n\
    \    if(x==0)\n        return true;\n    \n    unsigned long power=1;\n    for(long\
    \ i=0; i<n; i++)\n        power*=x;\n    \n    long power2=1;\n    for(long i=0;\
    \ i<n-1; i++)\n        power2*=x;\n    \n    if(power2==power)\n    {\n      \
    \  if(power==n)\n            return true;\n        else\n            return false;\n\
    \    }\n    \n    return power2==power;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nHere is a solution that is probably more elegant, though perhaps slower.\
    \ Though it uses recursion, so if you're going to do this a lot, performance might\
    \ be an issue.\n<code>\n#include <iostream>", "{\n    if (x == 0)\n        return\
    \ true; // 0**0 = 1 => true\n    if (n == 1)\n        return true; // n**0 = 1\
    \ => true\n    if (n == 0)\n        return false; // n**1 = 1 => false\n    if\
    \ (x < 0)\n        return false; // x ** (-n) = -(x**n) => false\n    if (x <\
    \ n)\n        return is_simple_power(x * n); // n**n = x ** n\n    \n    long\
    \ result = 1;\n    while (n) {\n        if ((x & n) == 0) {\n            if (n\
    \ % 2 == 0)\n                result = result * x;\n            else {\n      \
    \          if (result == 1)\n                    result = (x >> 1);\n        \
    \        else\n                    result = result * x;\n                result\
    \ *= x;\n            }\n            \n            n /= 2;\n        }\n       \
    \ else \n            n = (n - 1) / 2;\n        x *= x;\n    }\n    \n    if (x\
    \ != result && result != 1)\n        return false;\n    \n    return true;\n}\n\
    </code>\n<|/ a tags=function,python |>\n<| c |>\nYour function is incorrect for\
    \ negative numbers. Eg `is_simple_power(1,-1)` returns true but it's not. Also\
    \ you should be returning false if the value isn't a power, not the other way\
    \ around. I've added my own answer below to fix these issues.\n<|/ c |>\n<| a\
    \ tags=function,python |>\n<code>\ndef check(value):\n    pow_num=0\n    pow_val=1\n\
    \    while pow_num<=len(str(value)):\n        if value==pow_val:\n           \
    \ return True\n        else:\n            pow_val*=value\n            pow_num+=1",
  "{\n\t// TODO: your solution here\n\tif(n==0)\n\t\treturn true;\n\tif(n==1)\n\t\t\
    return false;\n\tif(x==1L)\n\t\treturn true;\n\tif(x==(x<<n))\n\t\treturn is_simple_power(x<<n,n-1);\n\
    \treturn false;\n}\n/*\nNow write a function that returns the least common multiple\
    \ of a list of numbers.\n    For example, given the list of numbers: 3, 6, 9,\
    \ 12, the function should return 31.\n    \n    Your solution should work with\
    \ any list not just with powers of numbers.\n    \n    You should return the largest\
    \ number in the list that is a multiple of all \n    the numbers in the list if\
    \ they are all factors of another number.\n    For example:\n    \n    >>> factors([3,\
    \ 6, 9, 12])\n    31\n    >>> factors([])\n    1\n    >>> factors([])\n    1\n\
    \    >>> factors([1])\n    1\n    >>> factors([1])\n    1\n    \n*/\nlong factors(long\
    \ numbers[]) \n{\n\t// TODO: your solution here\n\tlong max=numbers[0];\n\tfor(int\
    \ i=0;i<numbers.length;i++){\n\t\tif(numbers[i]>max){\n\t\t\tmax=numbers[i];\n\
    \t\t}\n\t}\n\tfor(int i=0;i<numbers.length;i++){\n\t\tfor(int j=i+1;j<numbers.length;j++){\n\
    \t\t\tif(numbers[i]%numbers[j]==0){\n\t\t\t\tmax=numbers[i];\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn max;\n}\n/*\nNow write a function that returns all\
    \ the prime factors of an integer.\n    For example, given the integer 4 the function\
    \ should return (2, 2)\n    \n    Your solution should work with any integer.\n\
    \    \n    Your solution should find the prime factors of a number.\n    The number\
    \ must be an integer.\n    \n    You may use the prime numbers found here:\n \
    \   http://www.primes.utm.edu/lists/small/10000.txt\n    \n    You may also use\
    \ the Sieve of Eratosthenes found here:\n    http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.pdf\n\
    \    \n    You may use the Miller-Rabin primality test found here:\n    http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD852.pdf\n\
    \    \n    The prime numbers will be stored as a list in a static array.\n   \
    \ \n    Your function should return the array as part of a tuple,\n    where the\
    \ first element is the prime factors and the second is the sum of the prime factors.\n\
    \    For example:\n    \n    >>> factors_of_prime(10)\n    (2, 5)\n    >>> factors_of_prime(13)\n\
    \    (3, 3)\n    >>> factors_of_prime(", "{\n    long int i = 1;\n    long int\
    \ res = 1;\n    \n    while (true)\n    {\n        long int temp = 1;\n      \
    \  long int power;\n        \n        while (i <= n && res <= x)\n        {\n\
    \            temp *= i;\n            res *= temp;\n            power++;\n    \
    \    }\n        \n        if (temp == n && res == x)\n        {\n            return\
    \ true;\n        }\n        \n        i++;\n    }\n    \n    return false;\n}",
  "{\n    double d = sqrt(double(x));\n    double b = pow(d, double(n));\n    return\
    \ double(b) == double(x);\n}\n</code>\n<|/ a tags=c++ dscore=1 |>\n<| c |>\nIf\
    \ `n` is really small, `sqrt(double(x));` might overflow and cause your program\
    \ to crash.\n<|/ c |>\n<| c |>\n: Well, you could also use \"bignum\" libraries\
    \ like [GMP](http://gmplib.org/) which provide arbitrary precision integer arithmetic\
    \ in C++, without having to worry about integer overflow, but it's even more work\
    \ to setup, and may not be worth the effort to learn it just for this.\n<|/ c\
    \ |>\n<| c |>\n: Thanks, I added your hint to the answer.\n<|/ c |>\n<| c |>\n\
    Why not use `std::complex`? :P\n<|/ c |>\n<| c |>\n: That would probably also\
    \ work. But as I said, I didn't want to introduce another library to the OP to\
    \ solve this trivial problem.\n<|/ c |>\n<| a tags=c++ |>\n<code>", "{\n    long\
    \ n = 1;\n    bool result = true;\n    bool result = true;\n    bool result =\
    \ true;\n    bool result = true;\n    bool result = true;\n    bool result = true;\n\
    \    bool result = true;\n    bool result = true;\n    bool result = true;\n \
    \   bool result = true;\n    bool result = true;\n    bool result = true;\n  \
    \  bool result = true;\n    bool result = true;\n    bool result = true;\n   \
    \ bool result = true;\n    bool result = true;\n    bool result = true;\n    bool\
    \ result = true;\n    bool result = true;\n    bool result = true;\n    bool result\
    \ = true;\n    bool result = true;\n    bool result = true;\n    bool result =\
    \ true;\n    bool result = true;\n    bool result = true;\n    bool result = true;\n\
    \    bool result = true;\n    bool result = true;\n    bool result = true;\n \
    \   bool result = true;\n    bool result = true;\n    bool result = true;\n  \
    \  bool result = true;\n    bool result = true;\n    bool result = true;\n   \
    \ bool result = true;\n    bool result = true;\n    bool result = true;\n    bool\
    \ result = true;\n    bool result = true;\n    bool result = true;\n    bool result\
    \ = true;\n    bool result = true;\n    bool result = true;\n    bool result =\
    \ true;\n    bool result = true;\n    bool result = true;\n    bool result = true;\n\
    \    bool result = true;\n    bool result = true;\n    bool result = true;\n \
    \   bool result = true;\n    bool result = true;\n    bool result = true;\n  \
    \  bool result = true;\n    bool result = true;\n    bool result = true;\n   \
    \ bool result = true;\n    bool result = true;\n    bool result = true;\n    bool\
    \ result = true;\n    bool result = true;\n    bool result = true;\n    bool result\
    \ = true;\n    bool result = true;\n    bool result = true;\n    bool result =\
    \ true;\n    bool result = true;\n    bool result = true;\n    bool result = true;\n\
    \    bool result = true;\n    bool result = true;\n    bool result = true;\n \
    \   bool result = true;\n    bool result = true;\n    bool result = true;\n  \
    \  bool result = true;\n    bool result = true;\n    bool result = true;\n   \
    \ bool result = true;\n    bool result = true;\n    bool result = true;\n    bool\
    \ result = true;\n    bool result = true;\n    bool result = true;\n    bool result\
    \ = true;\n    bool result = true;\n    bool result = true;\n    bool result =\
    \ true;\n    bool result = true;\n    bool result = true;\n    bool result = true;\n\
    \    bool result = true;\n    bool result = true;\n    bool result = true;\n \
    \   bool result = true;\n    bool result = true;\n    bool result = true;\n  \
    \  bool result = true;\n", "{\n\tif(n == 1) \n\t{\n\t\treturn true;\n\t}", "{\n\
    \    long intrem, intrem_rem;\n    intrem = x;\n    intrem_rem = n;\n    while(intrem\
    \ > intrem_rem) {\n        intrem /= intrem_rem;\n        intrem_rem /= intrem_rem;\n\
    \    }\n    if (intrem == 0)\n        return true;\n    return false;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nA more straight forward method without recursion.\
    \ This is a Python 3 solution.\n<code>\ndef is_power2(n):\n    \"\"\"\n    Check\
    \ if an integer is a power of 2.", "{\n    long y= 1;\n    long tmp= 1;\n    bool\
    \ isPower= true;\n    while( y<n ) {\n        tmp= tmp* y;\n        y += 1;\n\
    \        isPower= (tmp==x)?true:isPower;\n    }\n    return isPower;\n}", "{\n\
    \    long fact = 1;\n    for(int i = 1; i <= n; i++) {\n        fact *= i;\n \
    \   }\n    long result = x ** (fact - 1);\n    return result == x;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI really like this implementation, but the problem\
    \ with this approach is that if the integer is really large, for example 2^64,\
    \ then the factorial is calculated and stored for the long variables. But then\
    \ it is calculated and stored again for the long variables, thus making double\
    \ the time it took for the calculation to finish.\n<|/ c |>\n<| a dscore=1 tags=math,bignum,python,algorithm\
    \ |>\nIf your input is in form of string, you can use this\n<code>\nimport math",
  "{\n    return (x == pow(long n, int(x))) ? true : false;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nPlease add an explanation to your answer\n<|/ c |>\n<| c |>\nThis is\
    \ not a very good explanation of `pow`. `pow` will return the result of the power.\
    \ If it returns `0`, then it would not matter what the exponent was, as it will\
    \ still return `0`. Furthermore, it is worth noting that `pow(long x, long y)`\
    \ returns a `long`, whereas `pow` returns a `double`.\n<|/ c |>\n<| c |>\nI made\
    \ a mistake. `pow` returns a `long` but the code uses `double`.\n<|/ c |>\n<|\
    \ a dscore=3 tags=c++,math |>\nThe general formula for logarithms is log(a)ln(b).\
    \ So if you take the log base 10 then multiply that by the power you want and\
    \ apply the inverse log function, the result will be an exponent in that base\
    \ 10. You will need to use this formula, as opposed to doing it by hand, as the\
    \ formula is simple to implement. Hope that helps.\n<|/ a |>\n<| c |>\nThis seems\
    \ wrong, as the log() functions return `double`s and `double`s don't have any\
    \ built in way to convert them back to an integer.\n<|/ c |>\n<| c |>\n: I stand\
    \ corrected. It seems like you could use the pow() function, but that would not\
    \ be a solution as it would require you to know the base. So I would go with one\
    \ of the other solutions.\n<|/ c |>\n<| c |>\nI suspect the OP needs a solution\
    \ that works with any base.  You can't just use log10.  You also can't just multiply\
    \ the result of a log by 10.\n<|/ c |>\n<| a dscore=3 tags=c++,math |>\nHere is\
    \ a very fast implementation (I wrote it this morning without testing it):\n<code>",
  "{\n  if (n==0) return true;\n  else if (n==1) return x==1;\n  else if (is_simple_power(x,\
    \ n/2))\n  {\n    if (std.typecons.is_simple_power(x,n/2)) return true;\n    else\
    \ return false;\n  }\n  else return false;\n}", "{\n    long pow = 0;\n    long\
    \ base = 1;", "{\n    if (x == 0 || n == 0 || x == 1)\n        return 1;\n   \
    \ return std.math.isPowerOfTwo(n) && ((x * n) % n == 0);\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis answer is very similar to the answer posted below. His solution\
    \ uses isPowerOfTwo which is very efficient.\n<|/ c |>\n<| c |>\nHis solution\
    \ uses `% n` which is a slow modulo operator. I think that `% n` does more than\
    \ that since it uses it to check for `n == 0`.\n<|/ c |>\n<| c |>\nNo, his solution\
    \ uses `%n` which does more than `isPowerOfTwo` and also tests for `n == 0` which\
    \ could be optimized out by simply checking `if (x == 0 || n == 0 || x == 1)`\
    \ which is what `% n` does.\n<|/ c |>\n<| c |>\nYes, I agree, but his solution\
    \ is clearly superior. His solution uses `% n` and is also a little more optimized\
    \ than the one proposed by others.\n<|/ c |>\n<| a |>\nYou can just use % in the\
    \ condition to check if a number is a simple power of n.\nThe code below checks\
    \ the % condition for n == 1, which is the case when n % 1 == 0 because if n is\
    \ 1 then 1 % 1 == 0 and if n is 0 then 1 % 0 == 0.\n<code>", "{\n    // TODO:\
    \ your implementation here\n}", "{\n  if (x == 1L) return true;\n  else\n  {\n\
    \    long intpart = x / n;\n    long powerpart = x % n;\n    \n    if (powerpart\
    \ == 0)\n    {\n      return true;\n    }\n    \n    return is_simple_power(intpart,\
    \ n);\n  }\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nJust a note, there may be\
    \ a slight rounding error in the calculation of `powerpart` if the number doesn't\
    \ have perfect powers. For example, `is_simple_power(5L, 3L)` returns `false`.\n\
    <|/ c |>\n<| c |>\n, good point. I've edited my answer to handle these cases.\n\
    <|/ c |>\n<| c |>\nStill not going to work for `is_simple_power(5L, 5L)`. Should\
    \ be `false`.\n<|/ c |>\n<| a |>\n<code>\n#include<iostream>\n#include<cmath>\n\
    using namespace std;", "{\n    long i;\n    bool result = true;\n    for (i =\
    \ 0; i < n; i++) {\n        if (x % i == 0) {\n            result = false;\n \
    \       }\n    }\n    return result;\n}\n</code>\n<|/ a tags=integer-arithmetic,c,algorithm\
    \ |>\n<| c |>\nOh my god, you are a god. Thank you so much!\n<|/ c |>\n<| c |>\n\
    I'm a fool lol. I didn't think of the fact that the only thing I needed to test\
    \ was the power. Thank you for pointing that out!\n<|/ c |>\n<| c |>\nI'm glad\
    \ this was useful, don't forget to upvote useful answers and accept the best one\
    \ :)\n<|/ c |>\n<| c |>\nCan you please explain why you used long instead of long\
    \ long?\n<|/ c |>\n<| c |>\nLong is 8 bytes, longlong 64bits, if your numbers\
    \ are too big to fit in a long your number will be lost (if you don't care about\
    \ it)\n<|/ c |>\n<| a tags=integer-arithmetic,c,algorithm |>\n<code>\n#include\
    \ <stdio.h>\n#include <stdlib.h>\n#include <string.h>", "{\n    int k;\n    bool\
    \ result = true;\n    for (k = 0, result && ((n * n) != x); (k++) && result &&\
    \ ((n = n * n), x-- ))\n    {\n    }\n    return result;\n}", "{\n    if (n==0)\
    \ return true;\n    \n    return x == (int) pow(n, (int)floor(log10(x)));\n}",
  "{\n   if (x == 1) \n     return true;\n   if (n == 0) \n     return false;\n  \
    \ if (n == 1) \n     return true;\n   if (n % 2 == 0)\n     return is_simple_power(x,\
    \ n / 2) || is_simple_power(x * x, (n - 1) / 2);\n   return is_simple_power(x\
    \ * x, (n - 1) / 2);\n}\n</code>\n<|/ a tags=biginteger,c++,algorithm |>\n<| c\
    \ |>\nThis solution can be optimized by doing binary search. Check out this link:\
    \ https://cs.stackexchange.com/questions/30182/how-to-check-whether-an-long-integer-is-simple-power\n\
    <|/ c |>\n<| a dscore=2 |>\nSince your question is tagged with C++ I assume you\
    \ have a solution in mind but can't get it working.\nThe approach I used is to\
    \ first convert your number to decimal. For example, if you have 5^10, your number\
    \ would be 5 to the power of 10.\nThis can be achieved with the std::pow function.\n\
    Once you have this number you can convert it to a string.\nTo convert a number\
    \ to a string you can use the std::to_string function.\nCombined with the pow()\
    \ function you can check if your number is a power of any number.\nI implemented\
    \ the solution in C++ as follows:\n<code>\n#include <iostream>\n#include <string>\n\
    #include <vector>", "{\n  return isPowerOf(n,x);\n}", "{\n    if(n==0) return\
    \ true;\n    if(n==1L) return true;\n    long c = 1L;\n    while(c < n){\n   \
    \     if(x%c==0){\n            return false;\n        }\n        c <<= 1;\n  \
    \  }\n    return true;\n}", "{\n  if(n < 1) return false;\n  if(n == 1) return\
    \ true;\n  if(x == 1) return true;\n  \n  long p = pow(x, n);\n  \n  if(p == x)\
    \ return true;\n  \n  return false;\n}", "{\n    if(n==0)\n        return true;\n\
    \    long m = n-1;\n    long rem = x % n;\n    \n    if (rem == 0)\n    {\n  \
    \      if (is_simple_power(x, m))\n            return true;\n    }\n    else\n\
    \    {\n        return false;\n    }\n    return true;\n}\n</code>\n<|/ a tags=algorithm,math\
    \ dscore=1 |>\n<| a tags=algorithm,math |>\nYou can use the following algorithm,\
    \ which checks for integer powers of n:", "{\n    if (x < 0)\n    {\n        return\
    \ false;\n    }\n    \n    if (x < n)\n    {\n        return false;\n    }\n \
    \   \n    if (x == 1)\n    {\n        return true;\n    }\n    \n    long d =\
    \ 1L;\n    while (n>1)\n    {\n        d *= x;\n        if (d==n)\n        {\n\
    \            return true;\n        }\n        n /= x;\n    }\n    return false;\n\
    }", "{\n\tif(n==0)\n\t\treturn true;\n\tif(n==1)\n\t\treturn x==1;\n\tif(n>1 &&\
    \ n<10)\n\t\treturn is_simple_power(x*x, n/2);\n\treturn false;\n}", "{\n    bool\
    \ result = true;\n    if (x==1L)\n        result = true;\n    else if ((n!=2L)\
    \ && (n!=3L) && (n!=4L) && (n!=5L))\n        result = false;\n    else if (n==1L)\n\
    \        result = true;\n    else if ((n%2L==0L) && (n%3L==0L) && (n%4L==0L) &&\
    \ (n%5L==0L))\n        result = true;\n    else if ((n%2L==0L) && (n%3L==0L) &&\
    \ (n%4L==0L) && (n%5L!=0L))\n        result = false;\n    else if ((n%2L==0L)\
    \ && (n%3L!=0L) && (n%4L==0L) && (n%5L==0L))\n        result = false;\n    else\
    \ if ((n%2L==0L) && (n%3L!=0L) && (n%4L!=0L) && (n%5L==0L))\n        result =\
    \ false;\n    else if ((n%2L==0L) && (n%3L!=0L) && (n%4L!=0L) && (n%5L!=0L))\n\
    \        result = false;\n    else if ((n%2L!=0L) && (n%3L==0L) && (n%4L==0L)\
    \ && (n%5L==0L))\n        result = false;\n    else if ((n%2L!=0L) && (n%3L!=0L)\
    \ && (n%4L==0L) && (n%5L!=0L))\n        result = false;\n    else if ((n%2L!=0L)\
    \ && (n%3L!=0L) && (n%4L!=0L) && (n%5L!=0L))\n        result = false;\n    return\
    \ result;\n}\n</code>\n<|/ a tags=c++ |>\n<| c |>\ni cant use \"long long int\"\
    \ thats why i am using \"long\"\n<|/ c |>\n<| c |>\nI see that you've marked this\
    \ as a C++ question, but you mentioned this in your question.  Is this for C or\
    \ C++ ?\n<|/ c |>\n<| c |>\nfor c++. thanks for the help :)\n<|/ c |>\n<| c |>\n\
    The most efficient solution would involve an iterative solution which would also\
    \ require that you have a constant number of `1L`s.  I would suggest you either\
    \ write out your conditions by hand and test them or implement them in C# and\
    \ see if you get the same results.\n<|/ c |>\n<| c |>\nYou have a variable `c` ",
  "{\n\tbool ans;\n\tans = false;\n\tif(n >= 1 && n <= 64)\n\t{\n\t\tlong p = 1;\n\
    \t\tlong q;\n\t\tif(n == 1)\n\t\t\tans = true;\n\t\telse\n\t\t{\n\t\t\tfor(long\
    \ i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tif(((i+1) % 4 == 0))\n\t\t\t\t{\n\t\t\t\
    \t\tq = p * x;\n\t\t\t\t\tif(x == q)\n\t\t\t\t\t\tans = true;\n\t\t\t\t}\n\t\t\
    \t\tp *= x;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}", "{\n    if( std.typecons.is_int(x)\
    \ && std.typecons.is_int(n) )\n    {\n        auto pow = std.math.pow(std.typecons.to_int(x),\
    \ std.typecons.to_int(n));\n        if( pow.is_int() && pow.get_int()==x )\n \
    \       {\n            return true;\n        }\n    }\n    return false;\n}",
  "{\n\treturn (n % x == 0L);\n}", "{\n    long power = 1;\n    \n    while(n != 0)\
    \ \n    {\n        if((n % 2) == 0) \n        {\n            power = power * x;\n\
    \            x = x * x;\n        }\n        n /= 2;\n        x *= x;\n    }\n\
    \    \n    return (power == x);\n}", "{\n    if (n > 1)\n    {\n        if (pow(x,\
    \ n) == x)\n            return true;\n    }\n    return false;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nWhy would you use a long for `is_simple_power(long x, long n)`\
    \ if you're only going to return true/false?\n<|/ c |>\n<| c |>\nThat is true,\
    \ I should have used double instead. Thanks for your comment.\n<|/ c |>\n<| c\
    \ |>\nI dont know why you guys downvoted you, Im still learning python and still\
    \ learning the basics so dont be offended, and thanks for helping.\n<|/ c |>\n\
    <| c |>\nNo problem. You didn't learn anything by copying my answer though. I'd\
    \ have used `bool` instead of `int` since that is what `is_simple_power` returns.\
    \ `int` is a bad choice for something that can only ever be 1 or 0.\n<|/ c |>\n\
    <| c |>\nyes, your right, I didn't know that. Thanks for your help :)\n<|/ c |>\n\
    <| a tags=powering,python,algorithm dscore=3 |>\n<code>\ndef is_simple_power(x,n):\n\
    \    return ((n-1)**2==x) or (x==1) or (n<2)\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ for you help!\n<|/ c |>\n<| a dscore=3 tags=powering,python,algorithm |>\n<code>\n\
    def is_power_of_two(x):\n    return x != 0 and ((x & (x - 1)) == 0)\n</code>\n\
    <|/ a |>\n<| a dscore=3 |>\nOne approach is to use logarithms since they can be\
    \ used to find powers of numbers, e.g.:\n<code>\ndef power_of_two(num):\n    if\
    \ num == 1:\n        return True\n    if num % 2 == 0:\n        return False\n\
    \    return power_of_two(num // 2)\n</code>\nThe above function works by recursing\
    \ the function until the function returns False. This method only requires you\
    \ to compute the logarithm of the number first and the check for a power by doing\
    \ that log2(x) == num.\nThis approach also works by computing the logarithm of\
    \ the number first and then applying the function to the log2, so is more general.\n\
    <|/ a tags=powering,python,algorithm |>\n<| c |>\nI don't think this can be considered\
    \ an improvement over `pow(x, n)`. `pow(x,n)` will call `pow` on every call, which\
    \ can easily be replaced with a `log2`\n<|/ c |>\n<| c |>\nYes, the log2 is better\
    \ than using the ", "{\n\treturn (n == x);\n}\n/*\nYour task is to write a function\
    \ that returns true if a number x is an integer multiple of y\n    and false in\
    \ other cases.\n    x is an integer multiple of y if y**2=x\n    For example:\n\
    \    >>> is_integer_multiple(5L, 2L)\n    true\n    >>> is_integer_multiple(5L,\
    \ 4L)\n    false\n    >>> is_integer_multiple(5L, 1L)\n    false\n    \n*/", "{\n\
    \    if(n == 0) return true;\n    if(n == 1) return x == 1;\n    return (x ==\
    \ 1) || (x == n) \n        && is_simple_power(x % n, n-1);\n}", "{\n    long power\
    \ = 1;\n    long p = 1;\n    long counter = 0;\n    while (power != n)\n    {\n\
    \        counter++;\n        p *= x;\n        power *= p;\n    }\n    if (counter\
    \ <= 1) return true;\n    else return false;\n}\n</code>\n<|/ a tags=c++ dscore=0\
    \ |>\n<| c |>\nI didn't even think about this solution, very elegant.  But I don't\
    \ understand why this works.  `p` is never greater than `n` so how can it ever\
    \ equal `n`?  It seems to me that since `power` always equals `n` in the loop,\
    \ the loop will never be exited.\n<|/ c |>\n<| c |>\nThe loop never exits because\
    \ `power` does not get increased. `power` is equal to `n` when `p` equals `1`\
    \ at the start of the loop. So the loop will iterate until `power` equals `n`.\
    \ The loop will never exit until `power` equals `1` and `n` equals `1`. So if\
    \ `power` is equal to `1`, `p` must also be equal to `1`. And if `power` is less\
    \ than `1`, `p` must also not equal `1` until it gets larger.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nWe can do it this way, but it is not efficient to loop through\
    \ the entire list. This would also loop through the entire list for each number\
    \ in the list:\n<code>", "{\n    //assert(n > 0);\n    //assert(x < n);\n    //assert(x\
    \ <= n);\n    \n    if(n == 1)\n        return x % 2 == 0;\n    \n    long r =\
    \ n % 2 == 0 ? x : x * x;\n    long p = (r * r) - (r / 2);\n    long n2 = n *\
    \ n;\n    \n    if(p == n2)\n        return true;\n    \n    if((p % n) == 0)\n\
    \        return true;\n    \n    return false;\n}", "{\n\treturn pow(x, n) ==\
    \ x;\n}", "{\n    if (x <= 1L) {\n        return n == 1L;\n    }\n    if (n >=\
    \ 2L) {\n        long r = 1L;\n        long d = x;\n        while (d % 2 == 0)\
    \ {\n            d /= 2;\n            r *= x;\n        }\n        return n ==\
    \ r;\n    }\n    long s = x / n;\n    return x % n == s;\n}\n</code>\n<|/ a dscore=3\
    \ tags=c++,algorithm |>\n<| c |>\nFor anyone who needs it, here is a `is_pow()`\
    \ implementation using bit manipulation (and without `pow()`): https://gist.github.com/aidanmr/7373526\n\
    <|/ c |>\n<| c |>\nThe `is_simple_power` function above is incorrect for negative\
    \ integers.\n<|/ c |>\n<| a dscore=3 |>\nI've been working on this problem, and\
    \ I've come up with the following solution.\n<code>", "{\n  return ((n%(int)n\
    \ == 0) && (n%(int)x == 0)) ? true : false;\n}", "{\n    if (n == 0)\n       \
    \ return true;\n    if (n == 1)\n        return (x == n) ? true : false;\n   \
    \ if (n % 2 == 0)\n        return is_simple_power(x, n / 2);\n    else\n     \
    \   return (x == n) ? true : is_simple_power(x, (n / 2) ^ 2);\n}\n</cell>\n<text>\n\
    To test your function try the following scenarios:", "{\n    if(n > 1L || n <\
    \ 0L)\n    {\n        return false;\n    }\n    long i = 1L;\n    while((i) <=\
    \ n)\n    {\n        if(x == i * (i-1))\n        {\n            return true;\n\
    \        }\n        i += 2L;\n    }\n    return false;\n}\n</code>\n<|/ a tags=integer,c++,math,pow,algorithm\
    \ dscore=0 |>\n<| c |>\nThis does not provide an answer to the question. Once\
    \ you have sufficient [reputation](https://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](https://stackoverflow.com/help/privileges/comment);\
    \ instead, [provide answers that don't require clarification from the asker](https://meta.stackexchange.com/questions/214173/why-do-i-need-50-reputation-to-comment-what-can-i-do-instead).\
    \ - [From Review](/review/low-quality-posts/19394865)\n<|/ c |>\n<| c |>\n.G Thanks\
    \ for the suggestion. I'll be more careful next time.\n<|/ c |>\n<| c |>\n.G I've\
    \ added some comments to explain my thought process while programming.\n<|/ c\
    \ |>\n<| c |>\nIt would still be nice to explain why your code should work and\
    \ why the others dont. Otherwise your answer doesn't add much to the site. At\
    \ least put a description of why it works.\n<|/ c |>\n<| c |>\n.G I've added my\
    \ thoughts to my answer. Thanks.\n<|/ c |>\n<| a |>\n<code>\n#include <stdio.h>",
  "{\n  long intx = x;\n  long nintn = n;\n  long pow_intn = pow(intx, nintn);\n \
    \ long pow_nintn = pow(n, intn);\n  long result = pow_nintn - pow_intn;\n  if\
    \ (result == 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nI'm getting a lot of falses and a lot of trues when\
    \ I run this test cases, even when it should print only falses and only trues.\n\
    <|/ c |>\n<| c |>\nI tested my function and it gives the expected results (not\
    \ all `true`s and `false`s, but only `true`s or `false`s). Could you paste your\
    \ code here?\n<|/ c |>\n<| c |>\nI added the full code with my test cases, can\
    \ you test it with your test cases?\n<|/ c |>\n<| c |>\nThanks. I ran my function\
    \ with your test cases and it's giving me the expected results (not all `true`s\
    \ and `false`s, but only `true`s or `false`s). I'm pretty sure my function works\
    \ with all test cases. Could you please paste your code here?\n<|/ c |>\n<| a\
    \ dscore=2 tags=c++,algorithm |>\nThis is a general question and you can do it\
    \ in many ways. Below is a simple O(n) solution. You can change it to take logarithms\
    \ of n and make it run in O(log n) time.\n<code>", "{\n   if(n == 0)\n      return\
    \ true;\n   \n   if(is_powerof(n, x))\n      return true;\n   return false;\n\
    }\n</code>\n<|/ a dscore=1 tags=c++,algorithm,c,math |>\n<| c |>\nthanks. what\
    \ if the number is larger than the limit of a long long?\n<|/ c |>\n<| c |>\n\
    You will need a big number library.\n<|/ c |>\n<| c |>\nThe \"big number library\"\
    \ you mean? Do you mean the GNU gmp library?\n<|/ c |>\n<| c |>\nYes, GNU gmp\
    \ library. Here is a [link](https://www.gnu.org/software/gmp/manual/gmp.html)\n\
    <|/ c |>\n<| c |>\nI see that GMP has been deprecated in favor of MPFR and MPC.\
    \ Do you know of any good alternatives?\n<|/ c |>\n<| a tags=c++,algorithm,c,math\
    \ |>\nThis can be easily solved using logarithms and exponentiations. To solve\
    \ this problem we take an arbitrary positive integer n and multiply it by itself\
    \ n^log(n) and then we take the logarithm of this product (ln(n^log(n))). By doing\
    \ this we get a number between 0 and n^log(sqrt(n)). Finally we divide this number\
    \ by n and we know if the number is a power of n.\nTo do this in C we can use\
    \ math.h library, but we can also use bitwise operators.\nTo understand how this\
    \ works we must remember that exponentiation is 2^n and logarithm is ln(n). If\
    \ we take an example n=3 then n^log(n) = 4^3 = 16 and ln(n) = ln(16) = ln(4) =\
    \ 2. So the number we get is between 0 and 16 and the answer is that n is a power\
    \ of 3.\nWe can use math.h library for this, but we can also use bitwise operations,\
    \ we can do exactly the same thing with bitwise operators.\nFor example:\n<code>\n\
    #include <stdio.h>\n#include <math.h>", "{\n    bool is_n1=true;\n    bool is_n2=true;\n\
    \    bool is_n3=true;\n    bool is_n4=true;\n    bool is_n5=true;\n    bool is_n6=true;\n\
    \    bool is_n7=true;\n    bool is_n8=true;\n    bool is_n9=true;\n    bool is_n10=true;\n\
    \    bool is_n11=true;\n    bool is_n12=true;\n    bool is_n13=true;\n    bool\
    \ is_n14=true;\n    bool is_n15=true;\n    bool is_n16=true;\n    bool is_n17=true;\n\
    \    bool is_n18=true;\n    bool is_n19=true;\n    bool is_n20=true;\n    bool\
    \ is_n21=true;\n    bool is_n22=true;\n    bool is_n23=true;\n    bool is_n24=true;\n\
    \    bool is_n25=true;\n    bool is_n26=true;\n    bool is_n27=true;\n    bool\
    \ is_n28=true;\n    bool is_n29=true;\n    bool is_n30=true;\n    bool is_n31=true;\n\
    \    bool is_n32=true;\n    bool is_n33=true;\n    bool is_n34=true;\n    bool\
    \ is_n35=true;\n    bool is_n36=true;\n    bool is_n37=true;\n    bool is_n38=true;\n\
    \    bool is_n39=true;\n    bool is_n40=true;\n    bool is_n41=true;\n    bool\
    \ is_n42=true;\n    bool is_n43=true;\n    bool is_n44=true;\n    bool is_n45=true;\n\
    \    bool is_n46=true;\n    bool is_n47=true;\n    bool is_n48=true;\n    bool\
    \ is_n49=true;\n    bool is_n50=true;\n    bool is_n51=true;\n    bool is_n52=true;\n\
    \    bool is_n53=true;\n    bool is_n54=true;\n    bool is_n55=true;\n    bool\
    \ is_n56=true;\n    bool is_n57=true;\n    bool is_n58=true;\n    bool is_n59=true;\n\
    \    bool is_n60=true;\n    bool is_n61=true;\n    bool is_n62=true;\n    bool\
    \ is_n63=true;\n    bool is_n64=true;\n    ", "{\n    if (n==0)\n        return\
    \ true;\n    if (x==1)\n        return true;\n    if (x>n)\n        return false;\n\
    \    long n2 = n*n;\n    if (n2 == 1)\n        return true;\n    if (x > n2)\n\
    \        return false;\n    long p = x;\n    while (true)\n    {\n        long\
    \ r = p%n;\n        if (p == r)\n            return true;\n        if (p>n)\n\
    \            return false;\n        p = r;\n    }\n}", "{\n    if(n == 0)\n  \
    \      return true;\n    \n    long power_of_n = 1;\n    \n    while(power_of_n\
    \ <= n)\n    {\n        if(pow(x, power_of_n) == x)\n            return true;\n\
    \        \n        power_of_n *= 10;\n    }\n    \n    return false;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=c++,c++11 |>\nIf you have to write it in C++ then\
    \ this is the simplest solution :\n<code>\n#include <iostream>\nusing namespace\
    \ std;", "{\n    long result = 1L;\n    while (n > 1L) {\n        result *= x;\n\
    \        n /= 2L;\n    }\n    return n == 1L && result == x;\n}\n</code>\nNow\
    \ let's test it out:\n<code>", "{\n    long r = n%x;\n    \n    if(n==1)\n   \
    \     return true;\n    if(r==0)\n        return false;\n    \n    long res =\
    \ (r*x)/r;\n    long m = (r*x)/(r+1);\n    return is_simple_power(res, n);\n}\n\
    </code>\n<|/ a dscore=1 tags=numbers,c++,math |>\n<| a tags=numbers,c++,math |>\n\
    First of all you don't need an algorithm. A simple check for the power function\
    \ will suffice.\n<code>\n#include <iostream>\nusing namespace std;", "{\n    if\
    \ (n == 1) return true;\n    \n    //write your code here\n    return false; //\
    \ your code here\n}\n</code>\n<|/ a tags=c++,c++11,if-statement |>\n<| a tags=c++,c++11,if-statement\
    \ |>\nFirst off, your if statement should probably be a while loop because that\
    \ is the intention of your if statement.  Secondly, the reason your current implementation\
    \ doesn't work is that you are missing a return true statement.\n<code>", "{\n\
    \  // YOUR CODE HERE\n  bool res = true;\n  int exponent = (int) log(x);\n  if\
    \ (exponent != n) \n  {\n    res = false;\n  }\n  return res;\n}\n</code>\n<|/\
    \ a tags=c++,c++17 dscore=0 |>\n<| a |>\n<code>\n#include <bits/stdc++.h>\nusing\
    \ namespace std;", "{\n    if (x==1)\n        return true;\n    if (n%2==1)\n\
    \        return is_simple_power(x*x, n/2);\n    else\n        return is_simple_power(x*x,\
    \ n/2) && is_simple_power(x, n/2);\n}\n</code>\n<|/ a tags=algorithm,math,c++\
    \ |>\n<| c |>\nThis answer doesn't handle the corner case of powers of 2, e.g.\
    \ `is_simple_power(2, 0)` returns true but should return false.  Also this answer\
    \ doesn't require `is_simple_power` to return bool.\n<|/ c |>\n<| c |>\n: Yes,\
    \ I wrote it before seeing your comment. Fixed now.\n<|/ c |>\n<| a dscore=0 tags=algorithm,math,c++\
    \ |>\nA more elegant and efficient solution:\n<code>\nlong long pow(const long\
    \ long x, const long long y)\n{\n   long long res = 1;", "{\n    if (n==0) return\
    \ true;\n    \n    long res = 1;\n    for (int i = 0; i < n; ++i) res *= x;\n\
    \    return (res==x);\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=math,c++ |>\n\
    Here's a solution in Java:\n<code>\npublic boolean isSimplePower(int x, int n)\
    \ {\n    while (n > 0)\n        if (n % 2 == 0)\n            x /= 2;\n       \
    \ x %= n;\n        n--;\n    return x != 0;\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a |>\n<code>\n#include<iostream>", "{\n    long power=1;\n    long i=0;\n  \
    \  \n    while(power<n)\n    {\n        if((x&power)==0)\n        {\n        \
    \    return false;\n        }\n        power*=n;\n    }\n    \n    return true;\n\
    }", "{\n    if(n==0) return true;\n    if(is_simple_power(x, n/2)) return true;\n\
    \    return false;\n}\n</code>\nThis implementation is not very efficient since\
    \ it uses (recursively) is_simple_power, but at least it is easy to understand.\n\
    <|/ a tags=algorithm,python |>\n<| a |>\nFor python 3.7, this should work:\n<code>\n\
    def is_power_of_two(number):\n    return (number & (number - 1)) == 0\n</code>\n\
    <|/ a tags=algorithm,python dscore=2 |>\n<| a dscore=2 tags=algorithm,python |>\n\
    Here's a recursive solution, using Python built-in math.\n<code>\nfrom math import\
    \ log", "{\n    return (int)std.math.pow(std.math.toint(n), std.math.toint(x))==x;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you very much for your answer. My\
    \ problem was that i only know how to use 'if' and 'else'. I didn't really thought\
    \ that i need to use 'while' as well. Thanks a lot.\n<|/ c |>\n<| a dscore=0 |>\n\
    A simple solution in C++:\n<code>\n#include <iostream>\n#include <string>", "{\n\
    \    if (x==1L) return true;\n    if (x==0L) return false;\n    long y=long(x);\n\
    \    long r=long(n);\n    long i=long(log(x))/long(log(r));\n    if (i>=long(trunc(x/n)))\n\
    \    {\n        if (x>r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*",
  "{\n    if (n<1) {\n        return false;\n    }\n    if (n==1) {\n        return\
    \ true;\n    }\n    // n!=1 \n    return ((n%2==0) && (x%n==0));\n}\n</code>\n\
    <|/ a |>\n<| a tags=big-o,time-complexity,c++,algorithm,space-complexity |>\n\
    The problem is quite simple since you only have to check 2 things at a time:",
  "{\n    unsigned long long int power=1;\n    long long int n=1;\n    unsigned long\
    \ long int x=1;\n    while(power)\n    {\n        power=power*n;\n        n=n/10;\n\
    \        x=x*10;\n    }\n    if(x==n) return true;\n    else return false;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\ni don't know why but i have a problem with\
    \ this. it says \"long long int not declared\". how can i fix it? thanks\n<|/\
    \ c |>\n<| c |>\nI do not think this code works as intended. `pow` will return\
    \ `1` for `0` and `0` for `1`.\n<|/ c |>\n<| c |>\n- It seems like this problem\
    \ has been fixed by changing `n` to a `long long`. See this answer for an explanation\
    \ on why this may work: https://stackoverflow.com/a/1224745/4763359\n<|/ c |>\n\
    <| c |>\nThe question was tagged `c++` but this code doesn't look like C++ at\
    \ all. Your answer also won't work properly for negative integers.\n<|/ c |>\n\
    <| c |>\n- I tested it with a few negative numbers and it seemed to work correctly.\
    \ Are there negative numbers in your test data? Perhaps you could update your\
    \ answer with negative numbers that it doesn't work for?\n<|/ c |>\n<| a |>\n\
    My answer is more general, but you asked about C++.\n<code>\n#include <iostream>\n\
    #include <cmath>", "{\n    return ((n&1) == 0) ? (n==x) : ((n<x) && ((pow(x,n)-x)==0));\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer, but it's just\
    \ not what I'm looking for. I would like to know how can i do this without using\
    \ pow. I tried with long pow(x, long) but the result is very very slow and I don't\
    \ know why it's so slow.\n<|/ c |>\n<| c |>\n: I updated my answer with a simpler\
    \ solution. Have a look.\n<|/ c |>\n<| c |>\nThanks, it's much better than pow(x,\
    \ n) but for bigger numbers the result is not correct. I edited my question to\
    \ show you the result.\n<|/ c |>\n<| c |>\n: Do you really need to use long type?\
    \ It's very bad performance to cast long type to int type. Have a look at my updated\
    \ answer which is now using unsigned long long.\n<|/ c |>\n<| c |>\n: I updated\
    \ my answer again to include another solution to your problem.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nThe fastest way to check if n is a simple power of x is to check\
    \ if n is divisible by x.\nIf so, n is a simple power of x.\nSo the fastest way\
    \ to check if n is a simple power of x is to just test whether n is divisible\
    \ by x.\nFor bigger numbers, you can first check if n is a power of x and then\
    \ check whether n is divisible by x.\nNote that this last test can be done using\
    \ only divisions. Since you said that your power is of the form n^int, you can\
    \ first test whether n is a power of x, then check if n is divisible by int.\n\
    So the code would look something like this:\n<code>", "{\n    if (x == 1L)\n \
    \       return true;\n    return n % x == 0L && is_simple_power(x, n / x);\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nYou have a typo in the third line of is_simple_power,\
    \ where you check for x == n. You should use x == n instead. Thanks!\n<|/ c |>\n\
    <| c |>\nAlso you could shorten your function by removing the if/else, just return\
    \ the value of n % x. Or you could remove the if and just do n % (x == 0L ? 1\
    \ : x).\n<|/ c |>\n<| c |>\nThanks guys. The mistakes have been fixed.\n<|/ c\
    \ |>\n<| a |>\nThis is another way to do it using recursion.\n<code>", "{\n  \
    \  return (x == n**(int(x)));\n}\n</code>\n<|/ a tags=algorithm,math,python,big-o\
    \ |>\n<| c |>\nThank you so much for sharing this.\n<|/ c |>\n<| c |>\nThanks\
    \ for the explanation of why this is O(n).  However, how do you know that `a **\
    \ b` is O(n)?\n<|/ c |>\n<| c |>\nThe point is that this solution will not work\
    \ for all powers, and the complexity of the `**` operator is O(n). You can read\
    \ more about the [Big O notation](https://en.wikipedia.org/wiki/Big_O_notation)\n\
    <|/ c |>\n<| a dscore=2 |>\nThis is an interesting problem to think about. I've\
    \ worked out an O(n) solution that works in my head, but I'm not 100% sure that\
    \ it's correct.\nFirst you need to write a function that will find if a number\
    \ is a power of some given base. Let's call this function is_power_of_base().\
    \ Since this function needs to iterate over every digit of the number I'm going\
    \ to call it power_of_base().\n<code>\ndef is_power_of_base(x, base):\n    \"\"\
    \" Returns true if x is a power of base. Otherwise, returns false. \"\"\"\n  \
    \  exponent = int(str(x)[-1:])\n    for i in xrange(exponent):\n        if x %\
    \ base:\n            return false\n    return true\n</code>\nNow we need to write\
    \ a function that will find all of the possible powers of some base numbers. One\
    \ way I thought of doing this is by writing a function that will find all of the\
    \ possible powers of a base number. I'm going to call this function base_powers().\n\
    <code>\ndef base_powers(base):\n    \"\"\" Yields all the powers of base that\
    \ are less than or equal to base. \"\"\"\n    yield 0\n    i = 0\n    while i\
    \ * base < base:\n        i = i + 1\n        yield i\n</code>\nI imagine that\
    \ this function will take a long time and will take up more memory than is needed,\
    \ but that might not be a concern. I'll implement this function as a generator\
    \ function and use it in an iterator called base_powers_iterator().\n<code>\n\
    def base_powers_iterator():\n    \"\"\" Yields all the possible powers of base\
    \ that are less than or equal to base. \"\"\"\n    yield 0\n    i = 0\n    while\
    \ i * base < base:\n        i = i + 1\n        yield i\n</code>\nNow that we have\
    \ these functions we can write a function that will test if some number is a power\
    \ of some base number. I'm going to call this function is_power_of_base().\n<code>\n\
    def is_power_of_base(number, base):\n    \"\"\" Returns true if number is a power\
    \ of base. Otherwise, returns false. \"\"\"\n    exponent = int(str(number)[-1:])\n\
    \    for i in xrange(exponent):\n        if number % base:\n", "{\n  // write\
    \ your function here\n  return true;\n}\n</code>\n<|/ a tags=c++ |>\n<| c |>\n\
    I am a bit confused, how would I apply this concept to my code snippet?\n<|/ c\
    \ |>\n<| c |>\nIt seems the snippet you gave is different from what you are trying\
    \ to achieve, which is to implement `is_simple_power`, so that it returns true\
    \ if the numbers are simple powers.\n<|/ c |>\n<| c |>\nWhat exactly is your question\
    \ then? Can you please edit your question to include some more information on\
    \ what exactly you're trying to achieve?\n<|/ c |>\n<| c |>\nI updated my code\
    \ snippet to show you what I am trying to do.\n<|/ c |>\n<| c |>\nI think I see\
    \ what you're trying to do now. The function `is_simple_power` can be implemented\
    \ using my solution. I'll add some comments to the code as well.\n<|/ c |>\n<|\
    \ a |>\nThe question is how are you going to define power of a number n.\nLets\
    \ say the number is 2n and you call a method is_simple_power(int n) and you return\
    \ true if the n is simple power and false if it is a composite number.\nYou can\
    \ define power of a number n as\n2^n = x * 2^(n-1)\nwhere x is base and n is power.\n\
    For example if n is 5 then 2^5 = 1*2^4 = 16*2^3 = 256*2^2 = 65536*2^1 = 256 *\
    \ 16 * 8 = 16*64 * 4 = 256*128 * 2 = 256*256 * 1 = 256*65536 * 2 = 65536*256 *\
    \ 1 = 65536*65536 * 4 = 65536*65536 * 8 = 65536*65536 * 16 = 65536*4294967296\
    \ * 2 = 65536*4294967296 * 4 = 4294967296*4294967296 * 8 = 4294967296*4294967296\
    \ * 16 = 4294967296*2147483648 * 2 = 4294967296*2147483648 * 4 = 2147483648 *\
    \ 4294967296 * 8 = 2147483648 * 4294967296 * 16 = 2147483648 * 2147483648\nSo\
    \ you can implement is_simple_power(int n) method like this\n<code>", "{\n   \
    \ long base = 1;\n    long counter = 1;\n    while (x > n) {\n        base = base\
    \ * counter;\n        counter = counter + 1;\n    }\n    if (x == base) return\
    \ true;\n    else return false;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWhat\
    \ about `is_simple_power(3L, 0L)` ? :P\n<|/ c |>\n<| a |>\nI like to use factorial\
    \ function for calculating power of n. \n<code>\npublic int getPower (int n){\n\
    \    int factorial = 1;\n    for(int i = 1; i <= n; i++){\n        factorial =\
    \ factorial * i;\n    }\n    return factorial;\n}\n</code>\nHope it helps!\n<|/\
    \ a tags=algorithm,c++ dscore=3 |>\n<| c |>\nThis answer does not consider that\
    \ if `x % n` is not equal to `0` then `x ^ n` is zero, otherwise it is one. You\
    \ can see that from the code in the other answers, where `factorial` is always\
    \ initialized to 1.\n<|/ c |>\n<| a |>\nHere is my solution. It was solved using\
    \ recursion using Pascal's triangle as base.\n<code>", "{\n    /* TODO: Use logarithms\
    \ */\n    return std.math.isPowerOfTwo(n);\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nIsn't this just the same as the builtin `pow` function? This doesn't seem\
    \ to answer the question, which wants to know if it is a power of `n`, not `n`\
    \ to the power of some number.\n<|/ c |>\n<| c |>\nMy bad, you are right. Though\
    \ I didn't see that before I answered. I'll edit my answer shortly.\n<|/ c |>\n\
    <| a dscore=0 |>\nTry this one:\n<code>", "{\n    if (n == 1) return true;\n \
    \   if (x < n) return false;\n    \n    for (long i = 2; i <= (n - x) / 2L; ++i)\
    \ \n    {\n        if (x * i != n) return false;\n    }\n    \n    return true;\n\
    }\n</code>\n<|/ a tags=algorithm |>\n<| c |>\nI like the second approach. Its\
    \ easier to understand, but I am not able to get it to compile with the Visual\
    \ Studio 2017 compiler. I am not sure if its my compiler version, or if its my\
    \ code, or maybe the compiler version is wrong (I have the latest compiler from\
    \ Microsoft for Windows 10 Pro 64-bit).\n<|/ c |>\n<| c |>\nHi again. I wrote\
    \ this in Java. Maybe someone can help in C#? The Java code compiles, but I get\
    \ an exception in Visual Studio 2017 and its not very descriptive about what is\
    \ going wrong.\n<|/ c |>\n<| c |>\nI wrote it in a `C++` environment. I'm sure\
    \ you could compile this in Visual Studio as well, but that would require some\
    \ extra work. I'll try to look at this when I get home.\n<|/ c |>\n<| c |>\nI\
    \ have been trying to compile your code on my machine and I get the error \"'long'\
    \ does not name a type\". I believe it is because 'long' is introduced in Java\
    \ 9. I will give this a shot in Java. Thanks.\n<|/ c |>\n<| a dscore=1 |>\nThe\
    \ best way to determine whether a number is a power of another number is to use\
    \ a binary search. It works by seeing if half of the number you are trying to\
    \ find is divisible by the smaller of the two numbers that you are trying to find.\
    \ Here is a Python implementation of the algorithm, which also works in JavaScript\
    \ because they both use the same binary search algorithm. Also this implementation\
    \ is based on the fact that you can calculate 2**n by just dividing by 2 until\
    \ you get to 1, then taking the remainder when you divide by 2, and doing that\
    \ again until you get to 1 again. The only tricky part is getting those 2 numbers.\
    \ So I just use Python's pow() function to do that:\n<code>\ndef power(num, power):\n\
    \    if power == 0:\n        return 1\n    \n    power = 2 ** power\n    \n  \
    \  while power > 1:\n        if num % (power // 2) % 2 == 1:\n            return\
    \ power\n        \n        power *= 2\n    \n    return 1\n</code>\n<|/ a tags=algorithm\
    \ |>\n<| a tags=algorithm dscore=1 |>\nIf n is a power of 2 then n is divisible\
    \ by itself, so you can simply check if n is divisible by 2\n<code>\npublic static\
    \ boolean isPowerOf2(long n) {\n     return (n ", "{\n    long exponent, base;\n\
    \    bool isSimplePower = false;", "{\n    long long pow_xx = pow(x.toLong(),\
    \ n);\n    if (pow_xx.toLong() == pow_xx)\n        return true;\n    else\n  \
    \      return false;\n}\n</code>\n<|/ a dscore=2 tags=c++ |>\n<| c |>\nWhy would\
    \ you make `pow_xx` a `long long`? This only makes the code a bit more cumbersome.\n\
    <|/ c |>\n<| c |>\nHmm. Maybe it makes the code more cumbersome but maybe it also\
    \ speeds up things since it doesn't have to call `pow`. `long long` can usually\
    \ be `int64_t`... I guess it's just a matter of taste.\n<|/ c |>\n<| c |>\nI guess\
    \ it just depends on what your compiler decides to do with `long long`. Even if\
    \ `long long` can represent every power of 2 from 1 to `std::numeric_limits<long\
    \ long>::max()` without loss of precision, `long` cannot represent such numbers\
    \ precisely.\n<|/ c |>\n<| c |>\nActually, `long long` is still `long long`, which\
    \ means that it cannot represent `pow(long long, long long)`.\n<|/ c |>\n<| c\
    \ |>\nYes, but it does make `pow_xx` a `long long` because `pow` returns an `unsigned\
    \ long long`, so you don't lose precision if you convert it to `long long` before\
    \ assigning it to a `long long` variable.\n<|/ c |>\n<| a dscore=0 tags=c++ |>\n\
    <code>\n#include <iostream>\n#include <string>", "{\n    if(n==1) return true;\n\
    \    if(x==1) return false;\n    if(n>1) return ((n%2==0)&&(x%n==0));\n    return\
    \ false;\n}", "{\n    return (x == pow(x, (int)n));\n}\n</code>\n<|/ a tags=c++,pow\
    \ |>\n<| c |>\nThis fails to detect `4L`\n<|/ c |>\n<| c |>\nthank you! Fixed\
    \ :)\n<|/ c |>\n<| c |>\n`pow` is a very slow function and it can sometimes result\
    \ in overflow error. Moreover, there is no need to convert to `int`, just compare\
    \ with `==` operator.\n<|/ c |>\n<| c |>\nSure, just compared with `==` was an\
    \ option, but I wrote it as fast as possible :)\n<|/ c |>\n<| c |>\n`int` is required\
    \ to be 32-bits on most systems. But yes, a quick check of `(int)pow(x, n)` would\
    \ be enough.\n<|/ c |>\n<| a tags=c++,pow |>\nHere's an example of how you can\
    \ check if a number is a power of another number:\n<code>\n#include <iostream>\n\
    #include <iomanip>\n#include <cmath>\nusing namespace std;", "{\n    if (n ==\
    \ 1)\n        return true;\n    return std.isPowerOfTwo(n) && std.pow2(n) == x;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=c++ |>\nA solution that does not use\
    \ any STD library:\n<code>\n#include <cmath>", "{\n  if (n < 0 || n < x)\n   \
    \ return false;\n  long m = n;\n  for (; m > 1; m >>= 1)\n    if (x % m == 0)\n\
    \      return false;\n  m = n;\n  for (; m > 1; m >>= 1)\n    if (x == m * m)\n\
    \      return true;\n  return false;\n}", "{\n    bool isSimple = false;\n   \
    \ int power = 1;\n    while (power < n) {\n        power <<= 1;\n        isSimple\
    \ = (x%power) == 0;\n        x = x / power;\n    }\n    return isSimple;\n}",
  "{\n  if(n==0)\n    return true;\n  if(n<0)\n    return false;\n  if(is_simple_power(x,(n-1)))\n\
    \  {\n    long xn = x*x;\n    long n = n*n;\n    if(xn==n)\n      return true;\n\
    \  }\n  return false;\n}", "{\n\treturn ((int)x.mantissa.pow(x.exponent) == (int)x.mantissa);\n\
    }", "{\n    if(n == 0) return true;\n    if(is_simple_power(x, n-1)) return true;\n\
    \    return std.typecons.pow(x) == x;\n}\n</code>\n<|/ a |>\n<| c |>\n: Please\
    \ see my edit, which I added some comments on\n<|/ c |>\n<| c |>\nI believe this\
    \ is the best solution. One comment though, why don't you use `pow` rather than\
    \ `*`?\n<|/ c |>\n<| c |>\nThat is correct, `pow` is what I was originally thinking\
    \ of, but I wanted to make it clear that `pow` was the correct function to use.\
    \ Thanks for catching that and pointing it out :)\n<|/ c |>\n<| c |>\nThis implementation\
    \ fails when x is big.\n<|/ c |>\n<| c |>\n: It worked for me in Python 2.7.10\
    \ and Python 3.5.2 on Windows 10. Have you tried it yourself?\n<|/ c |>\n<| a\
    \ dscore=5 tags=algorithm,big-o,c++ |>\nThe other answers have a few problems:",
  "{\n\tif(n==1) return true;\n\tif(n==2) return true;\n\tif(n==3) return true;\n\t\
    if(n==4) return true;\n\tif(n==5) return true;\n\tif(n==6) return true;\n\tif(n==7)\
    \ return true;\n\tif(n==8) return true;\n\tif(n==9) return true;\n\tif(n==10)\
    \ return true;\n\tif(n==11) return true;\n\tif(n==12) return true;\n\tif(n==13)\
    \ return true;\n\tif(n==14) return true;\n\tif(n==15) return true;\n\tif(n==16)\
    \ return true;\n\tif(n==17) return true;\n\tif(n==18) return true;\n\tif(n==19)\
    \ return true;\n\tif(n==20) return true;\n\tif(n==21) return true;\n\tif(n==22)\
    \ return true;\n\tif(n==23) return true;\n\tif(n==24) return true;\n\tif(n==25)\
    \ return true;\n\tif(n==26) return true;\n\tif(n==27) return true;\n\tif(n==28)\
    \ return true;\n\tif(n==29) return true;\n\tif(n==30) return true;\n\tif(n==31)\
    \ return true;\n\tif(n==32) return true;\n\tif(n==33) return true;\n\tif(n==34)\
    \ return true;\n\tif(n==35) return true;\n\tif(n==36) return true;\n\tif(n==37)\
    \ return true;\n\tif(n==38) return true;\n\tif(n==39) return true;\n\tif(n==40)\
    \ return true;\n\tif(n==41) return true;\n\tif(n==42) return true;\n\tif(n==43)\
    \ return true;\n\tif(n==44) return true;\n\tif(n==45) return true;\n\tif(n==46)\
    \ return true;\n\tif(n==47) return true;\n\tif(n==48) return true;\n\tif(n==49)\
    \ return true;\n\tif(n==50) return true;\n\tif(n==51) return true;\n\tif(n==52)\
    \ return true;\n\tif(n==53) return true;\n\tif(n==54) return true;\n\tif(n==55)\
    \ return true;\n\tif(n==56) return true;\n\tif(n==57) return true;\n\tif(n==58)\
    \ return true;\n\tif(n==59) return true;\n\tif(n==60) return true;\n\tif(n==61)\
    \ return true;\n\tif(n==62) return true;\n\tif(n==63) return true;\n\tif", "{\n\
    \tif (x == 1L) return true;\n\t\n\tif (x < 1L || n < 0L) return false;\n\t\n\t\
    long y = (long)log(x);\n\tlong r = floor(y / n) + (y % n == 0L ? 0L : 1L);\n\t\
    \n\treturn y == r * n;\n}", "{\n    return n.gte(x);\n}", "{\n    if(x < 0 ||\
    \ n <= 0)\n        return false;", "{\n    if (x==1)\n        return true;\n \
    \   long int=typecons.pow(int,n);\n    return typecons.pow(x*x,n)==x;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis code will work, but is extremely inefficient, requiring\
    \ O(logn) comparisons. It is better to use the solution with exponentiation, which\
    \ requires just a single division.\n<|/ c |>\n<| a tags=math,algorithm,c++ |>\n\
    If you want it more readable use this:\n<code>", "{\n    if (x == 1) {\n     \
    \   return true;\n    }\n    if (x%n==0) {\n        return true;\n    }\n    if\
    \ (x%n==1) {\n        return false;\n    }\n    if (x%n==2) {\n        return\
    \ is_simple_power(x/n, n);\n    }\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your\
    \ effort. I am not looking for a solution to the problem, but a solution using\
    \ recursion. I am able to write a function that can calculate simple power of\
    \ any number, but i am unable to make my code recursive so that i can calculate\
    \ the power of a number N using recursion.\n<|/ c |>\n<| c |>\nI made you a recursive\
    \ function so you can write `is_simple_power(3, 2)` and not have it crash\n<|/\
    \ c |>\n<| c |>\nThe problem is you are not using recursion properly, your function\
    \ does not use recursion, you are using a loop inside a loop, that is not recursion\
    \ and will cause stack overflow if `n` is large enough and `x` is small.\n<|/\
    \ c |>\n<| c |>\nI made you a recursive function so you can write `is_simple_power(3,\
    \ 2)` and not have it crash\n<|/ c |>\n<| c |>\nI didn't understand your comment.\
    \ I asked how would you solve the problem using recursion. If you can solve the\
    \ problem using recursion, please let me know how would you do it.\n<|/ c |>\n\
    <| a tags=c++,recursion,c++11,loops,algorithm |>\nYou can use recursive function\
    \ like so:\n<code>", "{\n    if (x==n)\n        return true;\n    if (x<n)\n \
    \       return is_simple_power(x*n, n);\n    else\n        return false;\n}",
  "{\n    if (x == 0 || n == 0)\n    {\n        return false;\n    }\n    else if\
    \ (n == 1)\n    {\n        return true;\n    }\n    else if (n % 2 == 0)\n   \
    \ {\n        return is_simple_power(x, n / 2) && is_simple_power(x * (x % n),\
    \ n - 1);\n    }\n    else\n    {\n        return false;\n    }\n}", "{\n    return\
    \ ((x == 1) && (n == 0));\n}", "{\n     if (x == 1L)\n         return true;\n\
    \     if (n % 2L != 0L)\n         return false;\n     return is_simple_power(x<<1L,\
    \ n-1);\n}", "{\n    return (n % x == 0) && is_simple_power(x, n/x);\n}", "{\n\
    \    int i;\n    for(i=2; i<=n; i++)\n    {\n        if(x%i == 0)\n          \
    \  return false;\n    }\n    return true;\n}", "{\n    if(x == 1)\n        return\
    \ true;\n    \n    if(x == 0)\n        return false;\n    \n    if(n % 2 == 0)\n\
    \        return false;\n    \n    long y = x >> 1;\n    \n    if(n == 1)\n   \
    \     return true;\n    \n    if(y != 0)\n    {\n        long y2 = y >> 1;\n \
    \       \n        if(n == 3)\n            return true;\n        \n        if(y2==0\
    \ && n%2!=0)\n            return false;\n        \n        if(y2 == n && n%2==0)\n\
    \            return false;\n        \n        \n        if(n != 6 && n != 12)\n\
    \            return false;\n    }\n    \n    return false;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nYou should add some explanation as to why you choose to implement\
    \ the logic you did instead of just posting code.\n<|/ c |>\n<| c |>\nWhat if\
    \ n is 1? You don't need to check that.\n<|/ c |>\n<| c |>\nYou don't need to\
    \ check n to 1!\n<|/ c |>\n<| a tags=c,algorithm dscore=2 |>\n<code>\nlong power(int\
    \ base, long exponent){\n    if (exponent < 1){\n        return 1;\n    }\n  \
    \  if (exponent == 1){\n        return base;\n    }\n    long result = 1;\n  \
    \  long remainder = exponent;\n    while (remainder){\n        if (remainder %\
    \ 2 == 0){\n            result = result * base;\n        }\n        base = base\
    \ * base;\n        remainder = remainder / 2;\n    }\n    return result;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nIf you only need the powers of 2, this is the best\
    \ solution.\n<|/ c |>\n<| c |>\nthis would return incorrect answers for powers\
    \ of 3\n<|/ c |>\n<| a |>\n<code>", "{\n    long i, xpow;\n    \n    xpow = pow(x,\
    \ n);\n    if(xpow == x)\n        return true;\n    else \n        return false;\n\
    }", "{\n    return ((n*n) == x);\n}", "{\n    \n    /* Your code here */\n   \
    \ \n}\n/////////////////////////////////////////////////", "{\n  if (n < 1 ||\
    \ n == 0) return false;\n  if (n % 2 == 0) return x == pow(x, n, n);\n  long c\
    \ = 1L;\n  while (n) \n  {\n    c = (c * x) % n;\n    n--;\n  }\n  return c ==\
    \ x;\n}", "{\n    if(n==1) \n    {\n        return true;\n    }\n    if(x<n*n)\
    \ \n    {\n        return false;\n    }\n    \n    return true;\n}", "{\n   long\
    \ square = x * x;\n   square = sqrt(square);\n   if (square != (long)(x * x))\
    \ \n   {\n       return false;\n   }\n   if (n == 1) \n   {\n       return true;\n\
    \   }\n   return (square == (n * n)); \n}\n</code>\n<|/ a dscore=0 tags=math,c++\
    \ |>\n<| a |>\nThe question asks to determine if x is a power of n.\nThe question\
    \ doesn't ask to determine if x is a multiple of n.\nHere is an example to verify\
    \ a power of n.\n<code>\n#include <iostream>\n#include <cmath>", "{\n    if (n\
    \ == 1)\n    {\n        return (x % n == 0);\n    }\n    \n    bool even = false;\n\
    \    bool power = false;\n    int n_sq = n;\n    \n    while (n > 1)\n    {\n\
    \        power = false;\n        \n        if (n % 2 == 0)\n        {\n      \
    \      even = false;\n        }\n        else\n        {\n            even = true;\n\
    \        }\n        \n        n_sq = n_sq * n_sq;\n        \n        if (n_sq\
    \ == x)\n        {\n            power = true;\n        }\n        \n        n\
    \ = n / 2;\n    }\n    \n    return (even && power);\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nYou need `pow(n, 2)` instead of `n * n`.\n<|/ c |>\n<| c |>\n: I didn't\
    \ check the validity of the code (it was just written to give an idea), but you\
    \ are right, I'll edit the answer. Thanks for pointing this out.\n<|/ c |>\n<|\
    \ a |>\nHere is a code example in C++ that might help. It computes the number\
    \ to the power of the input.\n<code>", "{\n    long r = 1L;\n    for (int i =\
    \ 0; i < n; i++) r *= x;\n    return r == x;\n}\n</code>\n<|/ a tags=algorithm,language-agnostic\
    \ |>\n<| c |>\n`is_simple_power(2,1)` will result in true even though it is not.\n\
    <|/ c |>\n<| c |>\nOk, now I see what OP meant. I just didn't get that from his\
    \ description.\n<|/ c |>\n<| c |>\nThe problem is that the function needs to return\
    \ `true` when the power is in fact an integer power, and `false` when it is not.\n\
    <|/ c |>\n<| c |>\nSorry, I still don't understand what OP wants. How do you define\
    \ \"simple power\"?\n<|/ c |>\n<| c |>\nIt would be good to include a description\
    \ of what your function is doing. Just saying \"I wrote this for you\" does not\
    \ help the person asking the question.\n<|/ c |>\n<| a |>\nOne of the most common\
    \ ways to do this is to use logarithms. \nIf x is a power of n, then log(x) =\
    \ log(n) + log(n-1) + ... + log(1) + 1, which is basically the log of n multiplied\
    \ by some power of n.\nThis can be done by first calculating the natural logarithm\
    \ of your base (in this case 2), then calculating the logarithm of your power.\n\
    Here's a Python function which returns the value of log(x) for any number x.\n\
    <code>\nfrom math import log", "{\n    return (x == 1) || ((n % x) == 1);\n}",
  "{\n    return ((int)pow((int)n, (int)x) == x);\n}\n</code>\n<|/ a |>\n<| a |>\n\
    I agree with the other answers that you should just use powers, rather than reinvent\
    \ the wheel using pow and integer division. But for whatever reason, you're asked\
    \ to write this in C, so here is a solution that uses C's long long type to get\
    \ you past the size limitation of int. \n<code>\nlong long power(long long x,\
    \ long long n)\n{\n    long long prod = 1;\n    long long result = x;\n    while\
    \ (n--)\n        prod *= result;\n    return prod;\n}\n</code>\nThe loop is just\
    \ to prevent overflow from occurring when multiplying the product. \nIf you don't\
    \ want to use long long, you can use this version of power, which only uses ints\
    \ up to a certain limit:\n<code>", "{\n    if (n == 0) return true;\n    long\
    \ power = 1;\n    while (n < power) {\n        power = power * n;\n    }\n   \
    \ long power = power;\n    return (n == power) ? true : false;\n}\n'''\n</cell>\n\
    <cell>\n%%sql \n-- A very simple recursive implementation of the is_simple_power\
    \ function:\nwith recursive power(n, power) as (\n  select 1, 1\n  union all\n\
    \  select n, power*n from power\n)\nselect is_simple_power(power(2, 3), 3), power(power(2,\
    \ 3), 3)\n</cell>\n<cell>\n%%sql", "{\n    if(n<0)\n    {\n        // handle negative\
    \ numbers\n        return false;\n    }\n    \n    long d = n%x == 0 ? n/x : n/x;\n\
    \    \n    // return true if n is a simple power\n    return d == (int)d;\n}\n\
    </code>\nAnd finally, a test that checks all your functions against the requirements:\n\
    <code>", "{\n    if (x==1L) return true;\n    if (x==0L) return false;\n    if\
    \ (n==0L) return false;\n    long long int i = 1;\n    while (i<n) i++;\n    long\
    \ long int y = 1;\n    while (!(x%n)) {\n        if (y==n) return true;\n    \
    \    y++;\n    }\n    return false;\n}", "{\n    if(n == 0) return true;\n   \
    \ if(n == 1) return x == 1;\n    return std.pow(x, std.ceil(std.log(n))) == n;\n\
    }", "{\n    long nsq=n*n;\n    return std.math.isPowerOfTwo(nsq) &&\n\t(x == std.math.remainder(nsq,\
    \ n) ? true : false);\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nYour approach\
    \ of checking for the last n bits of the number is not very robust and will fail\
    \ at some edge cases. Here's how I solved this:", "{\n    // Insert your code\
    \ here\n    if (x == 1L) return true;\n    if (n % x == 0) {\n        if (n%x\
    \ == 0) {\n            return false;\n        }\n    }\n    long r = 1;\n    while\
    \ (x != 1) {\n        long tmp = r * x;\n        if (tmp < n) r = tmp;\n     \
    \   else {\n            r = 1L;\n            return false;\n        }\n    }\n\
    \    return true;\n}\n</code>\n<|/ a tags=c,c++,algorithm dscore=4 |>\n<| c |>\n\
    I doubt that this is the best solution. Look at the example. is_simple_power(5L,\
    \ 3L) returns true.\n<|/ c |>\n<| c |>\nPlease tell me if my algorithm is faulty.\
    \ It works fine.\n<|/ c |>\n<| c |>\nPlease tell me if my algorithm is faulty.\
    \ It works fine.\n<|/ c |>\n<| c |>\n: I think that OP's algorithm fails [**on\
    \ this**](http://en.wikipedia.org/wiki/Power_of_two#Powers_not_of_the_power_of_two).\
    \ It should return `false`.\n<|/ c |>\n<| c |>\nThe question is tagged C, not\
    \ C++.\n<|/ c |>\n<| a tags=c,c++,algorithm |>\nA simple (but not very efficient)\
    \ algorithm would be:\n<code>", "{\n  // Your code goes here\n  if ( x == 1L )\n\
    \    return true;\n  else if ( n == 1L )\n    return false;\n  else if ( x < n\
    \ )\n    return true;\n  else\n    return false;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThe code is not working\n<|/ c |>\n<| c |>\nThe code works fine on [Wandbox](https://wandbox.org/permlink/r1IqIuR0KZsF4oCc2).\
    \ Are you sure you used `isSimplePower`?\n<|/ c |>\n<| c |>\ni did use isSimplePower\
    \ but still it returns false\n<|/ c |>\n<| c |>\nI did check the return value.\
    \ I did not use the `isSimplePower` function but a function that checks for simple\
    \ power of numbers. Could you please post the code you used?\n<|/ c |>\n<| c |>\n\
    i used the same code you posted on Wandbox but still it returns false\n<|/ c |>\n\
    <| a tags=python,python-3.x dscore=0 |>\n<code>\ndef is_simple_power(x,n):\n \
    \ xs = str(x)\n  for i in range(0,n):\n    if xs[i]==\"1\":\n        return True\n\
    \    elif xs[i]==\"9\":\n        return False\n    elif xs[i] in \"0\":\n    \
    \    return False\n    else:\n        return True\n</code>\n<|/ a |>\n<| c |>\n\
    Please don't post only code as an answer, but also provide an explanation of what\
    \ your code does and how it solves the problem of the question. Answers with an\
    \ explanation are usually more helpful and of better quality, and are more likely\
    \ to attract upvotes\n<|/ c |>\n<| c |>\nWhile this code may provide a solution\
    \ to the question, it's better to add context as to why/how it works. This can\
    \ help future users learn, and apply that knowledge to their own code. You are\
    \ also likely to have positive feedback from users in the form of upvotes, when\
    \ the code is explained.\n<|/ c |>\n<| a dscore=0 tags=python,python-3.x |>\n\
    <code>\ndef is_simple_power(x,n):\n    for i in range(1,n+1):\n        if ((x//i)==1):\n\
    \            return True\n    return False\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    <code>\ndef is_simple_power(x,n):\n    for i in range(1,n+1):\n        if (x%i==0):\n\
    \            return True\n    return False\n</code>\n<|/ a tags=python,python-3.x\
    \ |>\n<| c ", "{\n    if(n == 1) return true;\n    if(n < 1) return false;\n \
    \   if((x & (n - 1)) == 0) return (pow(x, n) == x);\n    \n    long ans = 1;\n\
    \    for(long i = 3; i * i <= n; i += 2) ans *= x;\n    return (x == ans);\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't work in the following case:\nis_simple_power(1L,3L)\
    \ is false.\n<|/ c |>\n<| c |>\nI did test it. (And you asked about the *correct*\
    \ answer)\n<|/ c |>\n<| c |>\nI said correct in quotes.\n<|/ c |>\n<| c |>\nI\
    \ see now. I had some issues with my test case. I now have it working\n<|/ c |>\n\
    <| a tags=numbers,function,python |>\n<code>\ndef isPowerOfFour(n):\n    answer\
    \ = True\n    while answer:\n        if (n&(n-1)==0):\n            answer = False\n\
    \        else:\n            n = (n&(n-1))*4\n    return answer\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a tags=numbers,function,python |>\n<code>\ndef isPowerOfFour(n):\n\
    \  if n==1:\n    return True\n  if(n==4):\n    return True\n  else:\n    while(n>1):\n\
    \      if n&(n-1)==0:\n         return False\n      n=n//4\n    return True\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\nUsing recursion:\n<code>\ndef is_power_of_four(num):\n\
    \    if num == 1:\n        return True\n    if num == 4:\n        return True\n\
    \    return num == (num & (num-1))\n</code>\n<|/ a dscore=2 tags=numbers,function,python\
    \ |>\n<| a |>\n<code>\ndef isPowerOfFour(n):\n    if n == 1:\n        return True\n\
    \    if n == 4:\n        return True\n    if n not in range(5):\n        return\
    \ False\n    while n > 1:\n        if n&(n-1) == 0:\n            return False\n\
    \        n = n // 4\n    return True", "{\n    return (std.math.pow(std.math.ipow(x,\
    \ n), n)) == x;\n}\n</cell>\n<cell>\nassert is_simple_power(1L, 4L) == true\n\
    assert is_simple_power(2L, 2L) == true\nassert is_simple_power(8L, 2L) == true\n\
    assert is_simple_power(3L, 2L) == false\nassert is_simple_power(3L, 1L) == false\n\
    assert is_simple_power(5L, 3L) == false\n</cell>\n<text>\n5.2 Power factors\n\
    What is power of factor?", "{\n    if (x == 0) \n    {\n        return true;\n\
    \    }\n    else if (x % n == 0) \n    {\n        return is_simple_power(x / n,\
    \ n);\n    }\n    else \n    {\n        return false;\n    }\n}", "{\n    if (x\
    \ == 1) return true;\n    if (x == 0 || n == 0 || n == 1) return false;\n    \n\
    \    long a = 1;\n    long p = 1;\n    \n    for (int i = 2; i <= n; i++) {\n\
    \        if (x % i == 0) {\n            a = a * i;\n            p = p * i;\n \
    \       }\n    }\n    \n    return a == x;\n}", "{\n    double n1 = (double)n;\n\
    \    double power = n ** (double)x;\n    bool ret = ( power == (double)x );\n\
    \    return ret;\n}", "{\n    return n==1 && x==1;\n}", "{\n  if (n == 1) return\
    \ true;\n  if (n % 2 == 0)\n    {\n      long y = n * x;\n      if (y == x) return\
    \ true;\n      else\n\treturn false;\n    }\n  else\n    {\n      long y = (x\
    \ + 1L) / 2;\n      if (y == x) return true;\n      else\n\treturn false;\n  \
    \  }\n}\n#endif\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>\n//Function to check\
    \ whether a number is a power of another number", "{\n    long y = x * x;\n  \
    \  y = y * y;\n    if (y >= n) return true;\n    else return false;\n}", "{\n\
    \    if(x != 1)\n        return std.is_pow(x,n);\n    return true;\n}", "{\n \
    \   // write your code here\n    return x == (long int) pow(n, (long int) x);\n\
    }\n</code>\nTest Code:\n<code>", "{\n  if(x == n)\n    return true;\n  \n  if((x\
    \ & (x - 1)) == 0)\n    if(x <= n / 2)\n      return true;\n  else\n    if(n >>\
    \ 1 == 1)\n      return true;\n  \n  return false;\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nIt would be nice if someone could explain how this works, in particular\
    \ the `|` operator on booleans. In particular, why `|` on a boolean is different\
    \ than `|` on a number. Why does it have to be the bitwise OR and why does it\
    \ affect the outcome?\n<|/ c |>\n<| c |>\nThis code works fine but fails for some\
    \ large inputs. For example, `is_simple_power(3L, 100000000L)` returns `true`\
    \ when it should return `false`. I'm pretty sure this can be fixed by changing\
    \ the `&&` operator to `||`, but I'm not sure how. I tried changing `&&` to `||`,\
    \ but it didn't work. Any ideas?\n<|/ c |>\n<| c |>\nI think this fails for large\
    \ numbers (long integers) due to integer overflow. Reason being n is only a power\
    \ of 2 and that causes it to overflow.\n<|/ c |>\n<| c |>\nThis fails for large\
    \ numbers, for which I assume you mean \"large number\" as in numbers larger than\
    \ a billion. How would you go about fixing this? (I'm not familiar with the limitations\
    \ of the language.)\n<|/ c |>\n<| c |>\nYou would have to write your own version\
    \ of `|` that works with `long`.\n<|/ c |>\n<| a tags=c++,algorithm,math |>\n\
    <code>", "{\n    return (n == 1) || (x % n == 0); // check if x is power of n\n\
    }", "{\n    if (n <= 0) return false;\n    if (n == 1) return true;\n    if (x\
    \ == 1) return true;\n    if (x == (long)pow(n, (int)floor((n - 1) / 2.0)))\n\
    \        return true;\n    return false;\n}\n</code>\nFor some reason it only\
    \ works for small powers\n<|/ a |>\n<| c |>\nYour code fails for is_simple_power(5L,\
    \ 3L) returns true. but your code returns false for it. i dont know why.\n<|/\
    \ c |>\n<| c |>\nYour code works as expected. Did you even run the code?\n<|/\
    \ c |>\n<| c |>\nYes. Your code returns true for both is_simple_power(5L, 3L)\
    \ and is_simple_power(2L, 2L) .\n<|/ c |>\n<| c |>\nYou can't just copy and paste\
    \ some code without understanding what it does. You should try to understand it\
    \ first. Try to understand how it is different from yours and why does it work.\n\
    <|/ c |>\n<| c |>\ni was just trying to understand the logic without copying it\
    \ from my code. But your code works. Thanks man\n<|/ c |>\n<| a |>\nYou might\
    \ not need any \"helpers\" to implement this function, but just using standard\
    \ library functions.\n<code>", "{\n    int res = (int)pow(n, (int)x);\n    return\
    \ res == x;\n}", "{\n    if (x == 0 || n == 0) {\n        return false;\n    }\n\
    \    long res = 1;\n    for (int i = 0; i < n; i++) {\n        res = res * x;\n\
    \    }\n    if (res == x) {\n        return true;\n    }\n    return false;\n\
    }\n</code>\n<|/ a |>\n<| a tags=math,algorithm,c++ |>\nThis is not efficient but\
    \ fast \n<code>\n#include <bits/stdc++.h>\nusing namespace std;", "{\n    if (n\
    \ < 0) return false;\n    long lx = x;\n    while ((n % lx == 0) && lx != 0)\n\
    \    {\n        lx *= x;\n        n--; \n    }\n    if (n == 0)\n        return\
    \ true;\n    return false;\n}", "{\n    long int i;\n    long int power = n *\
    \ x;\n    bool isSimple = false;\n    for(i = 1; i < power; i++ )\n    {\n   \
    \     if( power%i == 0 )\n        {\n            isSimple = true;\n          \
    \  break;\n        }\n    }\n    return isSimple;\n}\n</code>\n<|/ a |>\n<| a\
    \ tags=c++,math dscore=0 |>\nTry this function :\n<code>", "{\n    int result\
    \ = std.math.remainder((n*n), x);\n    if (result != 0) return false;\n    else\
    \ {\n        long p = std.math.div(n*n, x);\n        if (std.math.remainder(p,\
    \ x) == 0) return true;\n        else return false;\n    }\n}\n</code>\n<|/ a\
    \ |>\n<| a |>\nA simple recursive function could do it:\n<code>", "{\n    return\
    \ isPowerOf(x * n, n);\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n`isPowerOf` is\
    \ for integers, not longs, as requested by the OP. The question does not specify\
    \ whether `long` is 64-bit or 32-bit, so you should provide a more general answer.\
    \ Since you only check power of two, you do not need to take advantage of `isPowerOf`.\n\
    <|/ c |>\n<| c |>\n- I added a clarification regarding 32- vs 64-bit `long`.\n\
    <|/ c |>\n<| c |>\nThis does not work:\nis_simple_power(1, 0)\nreturns false\n\
    <|/ c |>\n<| a tags=c,c++,math,algorithm |>\nJust write some recursive function\
    \ is_simple_power(n) that will check this condition:\n<code>\nif (n==1) return\
    \ true;\nif (n==2) return false;\nif (n==n+1) return is_simple_power(n-1);\nreturn\
    \ is_simple_power(n-1) && is_simple_power(n-1);\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\nIn C++20 you can use the new constexpr function std::is_simple_power.\n\
    <code>\n#include <type_traits>", "{\n\tif (x == 1) \n\t\treturn true;\n\tif (n\
    \ % 2 == 0) \n\t{\n\t\treturn is_simple_power(x, n / 2);\n\t}\n\telse\n\t{\n\t\
    \tif (is_simple_power(x, n / 2)) return true;\n\t\treturn false;\n\t}\n}", "{\n\
    \   //TODO: your code here\n   return true;\n}\n</code>\n<|/ a tags=c++,function,c++11\
    \ |>\n<| c |>\nthanks bro but the answer is not correct in some case please try\
    \ to take case like 3L = 2L or 5L = 3L and 5L = 2L and so on... I do not know\
    \ if my question is clear or not but thanks for your effort\n<|/ c |>\n<| c |>\n\
    I edited the question and added the code for this case. thanks bro\n<|/ c |>\n\
    <| c |>\nNo need to use recursion. You can just use while and keep subtracting\
    \ 1 from n and testing whether n is zero or not.\n<|/ c |>\n<| c |>\nI agree,\
    \ but I wanted the solution to show recursion.\n<|/ c |>\n<| c |>\nI got this\
    \ error : main.cpp: In function 'bool is_simple_power(long long int, long long\
    \ int)':\nmain.cpp:16:28: error: no matching function for call to 'is_simple_power()'\n\
    \     return is_simple_power(x, n-1);\n                            ^\nmain.cpp:16:28:\
    \ note: candidate is:\nmain.cpp:4:8: note: static bool is_simple_power(long long\
    \ int, long long int)\n bool is_simple_power(long long x, long long n) \n    \
    \    ^\nmain.cpp:4:8: note:   candidate expects 2 arguments, 1 provided\n<|/ c\
    \ |>\n<| a tags=c++,function,c++11 dscore=0 |>\nTo find if n**int=x\n<code>",
  "{\n    long result = 1;\n    int count = 0;\n    while(n > 0)\n    {\n        n\
    \ /= 10;\n        count++;\n    }\n    for(int i = 0; i < count; i++)\n    {\n\
    \        result *= x;\n        x *= x;\n    }\n    return x == result;\n}\n</code>\n\
    <|/ a tags=function,math,c++,c++11 |>\n<| c |>\nWhile this is a simple answer,\
    \ this algorithm only works for certain powers of 10. You should start by finding\
    \ a solution that works for powers of 10.\n<|/ c |>\n<| a tags=function,math,c++,c++11\
    \ dscore=0 |>\nYou could start by dividing by powers of 10 (in your example, dividing\
    \ by 100 twice). Then if you have an odd number then it's an exact power of 2.\
    \ Add those numbers and compare to the original number.\n<code>", "{\n    // your\
    \ solution here\n    long temp = 1;\n    while(temp < n)\n    {\n        temp\
    \ *= x;\n    }\n    return temp == x;\n}\n</code>\nTest:\n<code>\nimport std.stdio;\n\
    import std.conv;", "{\n    if (x < 1) return false;\n    if (n < 1) return false;\n\
    \    long r = x;\n    bool check = true;\n    long max_step = 5;\n    while (!check)\
    \ {\n        long tmp = (r / n) * n;\n        if (tmp == r) {\n            check\
    \ = true;\n        }\n        else if (tmp < r) {\n            r = tmp;\n    \
    \        if (r == max_step * n) return false;\n            max_step *= n;\n  \
    \      }\n        else {\n            r = tmp;\n            if (r == max_step\
    \ * n) return false;\n            max_step *= n;\n            check = false;\n\
    \        }\n    }\n    return true;\n}", "{\n    if (x == 0) \n    {\n       \
    \ return true;\n    }\n    if (n == 1) \n    {\n        return true;\n    }\n\
    \    if (x == 1) \n    {\n        return false;\n    }\n    return is_simple_power(x\
    \ / 2, n) &&\n           is_simple_power(x % 2, n);\n}\n</code>\n<|/ a tags=c++,c++17\
    \ dscore=1 |>\n<| a |>\nHere is how you can get powers of 2 from the previous\
    \ answer.\n<code>", "{\n    if (x == 1) {\n        return true;\n    } else if\
    \ (n == 1) {\n        return false;\n    } else if (x % n == 0) {\n        if\
    \ (is_simple_power(x / n, n)) {\n            return true;\n        } else {\n\
    \            return false;\n        }\n    } else {\n        return false;\n \
    \   }\n}", "{\n    if (x==1 || n==1) return true;\n    if (x==0) return false;\n\
    \    if (n==0) return true;\n    if (n==1) return true;\n    return isOdd(n) &&\
    \ !( (isOdd(x)&&!isOdd(n)) || (!isOdd(x)&&isOdd(n)) );\n}", "{\n    if (n == 1L)\
    \ return true;\n    if (x == 0L) return false;\n    return std.math.isPowerOfTwo(n)\
    \ && std.typecons.isPowerOfTwo(x) &&\n           std.math.isPowerOfTwo(n * x);\n\
    }\n\"\"\"\n        self.compile_and_run(code, 2)", "{\n    bool result = true;\n\
    \    long c = n;\n    long r = x;\n    while (r != 0) {\n        c = c % r;\n\
    \        if (c != 0) {\n            result = false;\n            break;\n    \
    \    }\n        r = r;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c++\
    \ |>\n<| c |>\nThank you very much. I am new to programming, and am still confused\
    \ by some of the concepts such as types, and how they are to be used within functions.\n\
    <|/ c |>\n<| c |>\nThis is an example on how to write a function in C++ which\
    \ accepts two arguments (x and n). The function accepts a long and a long and\
    \ return a bool.\n<|/ c |>\n<| c |>\nThanks. I now understand it better.\n<|/\
    \ c |>\n<| a tags=c++ dscore=0 |>\n<code>\n#include <stdio.h>\n#include <stdlib.h>\n\
    #include <string.h>\n#include <math.h>", "{\n\tif(x==n)\n\t{\n\t\treturn true;\n\
    \t}\n\treturn is_simple_power(x, n/x);\n}", "{\n    if (n == 0)\n        return\
    \ true;\n    else if (n==1)\n        return (x==1);\n    else if (n%2 == 0 &&\
    \ is_simple_power(x, n/2))\n        return true;\n    else if (n%2 == 0 && is_simple_power(x,\
    \ n/2 + 1))\n        return false;\n    else\n        return (x%n == 0);\n}",
  "{\n    if (n==0)\n        return true;\n    \n    if (n==1)\n        return x ==\
    \ 1;\n    \n    long s = 1;\n    \n    while (n>1)\n    {\n        n=n/2;\n  \
    \      s=s*n;\n    }\n    \n    long res = 1;\n    \n    while (s>1)\n    {\n\
    \        res=res*x;\n        s--;\n    }\n    \n    return res==x;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=1 tags=c++,c++14,algorithm,math,bigint |>\nThe only thing\
    \ I can think of is converting your int to something larger (like double) and\
    \ then checking for an exact power of 2 with pow(). Of course, you may need to\
    \ handle overflow yourself.\n<code>", "{\n    if (n < 0) \n    {\n        // negatives\
    \ are not simple powers\n        return false;\n    }\n    else if (n == 0) \n\
    \    {\n        // 0 is simple power\n        return true;\n    }\n    else if\
    \ (x < 1) \n    {\n        // negative x is simple power\n        return false;\n\
    \    }\n    else if (n <= LONG_MAX && x >= LONG_MAX / (1LL << n)) \n    {\n  \
    \      // negative x is a simple power of n\n        return true;\n    }\n   \
    \ else if (n % 2 == 0) \n    {\n        // even, odd\n        return is_simple_power(x\
    \ / (1LL << 1), n / 2);\n    }\n    else \n    {\n        // odd, even\n     \
    \   return is_simple_power(x / (1LL << 1), n / 2) \n            || is_simple_power(x,\
    \ n / 2);\n    }\n}", "{\n    if (n==1) return true;\n    long xpow=1;\n    while\
    \ (xpow*n<=x) xpow=xpow*n;\n    return (xpow==x);\n}\n</code>\n<|/ a |>\n<| a\
    \ dscore=0 |>\nI came up with a solution that's not as efficient as some of the\
    \ other answers, but the idea is still there.  It uses a recursive function which\
    \ finds any power of 2 above x.  This can then be used to find the power of n\
    \ above a number x.\n<code>\nlong powerOfTwo(long x){\n    if(x == 1) return 1;\n\
    \    if(x == 2) return 2;\n    if(x == 0) return 0;\n    return powerOfTwo(x/2)\
    \ + 1;\n}", "{\n    long y = n;\n    while (y != 1) \n    {\n        if (x % y\
    \ == 0) \n            return false;\n        y--;\n    }\n    return true;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nWhat about negative powers? `-1L`? `-2L`?\
    \ `-3L`? `-4L`? `-5L`?\n<|/ c |>\n<| c |>\nHi, I edited my answer after I understood\
    \ what \"simple\" meant!\n<|/ c |>\n<| c |>\nThe problem is with powers of 2 like\
    \ `2L` being simple. `-1L`is also a power of 2. `-5L` would not be a power of\
    \ two but `-3L` would.\n<|/ c |>\n<| c |>\nWhat does that mean ?\n<|/ c |>\n<|\
    \ c |>\nI mean powers of 2 like 2L and so on (not power of n like 4L or 8L) that\
    \ do not require a remainder while doing division.\n<|/ c |>\n<| a dscore=2 tags=python,algorithm\
    \ |>\nThis works for simple powers. If you want complex powers, check out this\
    \ answer (not the accepted one)\n<code>\ndef is_simple_power(num, power):\n  \
    \  \"\"\"\n    Check if a number is a power of another number\n    \"\"\"\n  \
    \  if num < 0 or power < 0:\n        return False\n    if num == 0:\n        return\
    \ True\n    pow_list = []\n    while num > 0:\n        pow_list.append(num % 10)\n\
    \        num //= 10\n    pow_list.reverse()\n    pow_list_length = len(pow_list)\n\
    \    if pow_list_length == power:\n        return True\n    if pow_list_length\
    \ < power:\n        return False", "{\n    int i; \n    if (x<0 || n<0) return\
    \ false;\n    \n    // n is power of 1 \n    if (n==1) {\n        for (i=0; i<=x;\
    \ i++) {\n            if (i!=x) return false; \n        }\n        return true;\n\
    \    }\n    // n is power of 2 \n    if (n==2) {\n        for (i=0; i<=x; i++)\
    \ {\n            if (i!=x && i%2==0) return false; \n        }\n        return\
    \ true;\n    }\n    // n is power of 3 \n    if (n==3) {\n        for (i=0; i<=x;\
    \ i++) {\n            if (i!=x && i%2==0 && i%3==0) return false; \n        }\n\
    \        return true;\n    }\n    // n is power of 4 \n    if (n==4) {\n     \
    \   for (i=0; i<=x; i++) {\n            if (i!=x && i%2==0 && i%3==0 && i%5==0)\
    \ return false; \n        }\n        return true;\n    }\n    // n is power of\
    \ 5 \n    if (n==5) {\n        for (i=0; i<=x; i++) {\n            if (i!=x &&\
    \ i%2==0 && i%3==0 && i%5==0 && i%7==0) return false; \n        }\n        return\
    \ true;\n    }\n    // n is power of 6 \n    if (n==6) {\n        for (i=0; i<=x;\
    \ i++) {\n            if (i!=x && i%2==0 && i%3==0 && i%5==0 && i%7==0 && i%9==0)\
    \ return false; \n        }\n        return true;\n    }\n    // n is power of\
    \ 7 \n    if (n==7) {\n        for (i=0; i<=x; i++) {\n            if (i!=x &&\
    \ i%2==0 && i%3==0 && i%5==0 && i%7==0 && i%9==0 && i%11==0) return false; \n\
    \        }\n        return true;\n    }\n    // n is power of 8 \n    if (n==8)\
    \ {\n        for (i=0; i<=x; i++) {\n            if (i!=x && i%2==0 && i%3==0\
    \ && i%5==0 && i%7==0 && i%9==0 && i%11==0 && i%13==0) return false; \n      \
    \  }\n        return true;\n    }\n    // n is power of 9 \n    if (n==9) {\n\
    \        for (i=0; i<=x; i++) {\n            if (i!=x && i%2==0 && i%3==0 && i%5==0\
    \ && i%7==0 && i%9==0 && i%11==0 && i%13==0 && i%15==0) return false; \n     \
    \   }\n        return true;\n    }\n    // n is power of 10 \n    if (n==", "{\n\
    \    int int_x = int(x, 10);\n    int int_n = int(n, 10);\n    if (n%int_x!=0)\n\
    \    {\n        return false;\n    }\n    long div = div_pow(x, int_n, int_x);\n\
    \    if (div==1)\n    {\n        return true;\n    }\n    else\n    {\n      \
    \  return false;\n    }\n}", "{\n  // TODO: your code here\n  // return true;\n\
    }", "{\n    if(x < n)\n    {\n        return is_simple_power(x, n / x);\n    }\n\
    \    if(n == 2)\n    {\n        return true;\n    }\n    else if(n > 2)\n    {\n\
    \        if(n % 2 == 0)\n        {\n            return is_simple_power(x , n/2);\n\
    \        }\n        else\n        {\n            return false;\n        }\n  \
    \  }\n}", "{\n    if(n==1){\n        return true;\n    }\n    if(x==1L){\n   \
    \     return true;\n    }\n    if(n==0){\n        return false;\n    }\n    long\
    \ pow = n;\n    for(long i=2L;i<=x;i++){\n        pow = pow * i;\n    }\n    return\
    \ pow==x;\n}\n</code>\n<|/ a |>\n<| a |>\nYou can use the following code:\n<code>",
  "{\n    if (n==1L) return true;\n    if (x==0L) return false;\n    int exponent\
    \ = (int)math.log(n)/math.log(2);\n    if (exponent<=0) return false;\n    int\
    \ power = (int)math.pow(10, exponent);\n    int answer = (int)math.floor(power)==power;\n\
    \    return answer;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n/**\n * Determine\
    \ if a number is power of another\n * \n * num Number\n * power Power\n * true\
    \ if the num is a power of power\n */\nprivate boolean isPowerOf(double num, int\
    \ power) {\n    int powerToApply = 1 << power;\n    return (num == Math.pow(Math.pow(num,\
    \ powerToApply), powerToApply));\n}\n</code>\n<|/ a tags=java,algorithm |>\n<|\
    \ c |>\nI think this is good but I think there will be some corner cases, for\
    \ example what will happen if `power=3` and `num=7`?\n<|/ c |>\n<| c |>\nYes,\
    \ you are right. I didn't think about corner cases. I will try to fix it.\n<|/\
    \ c |>\n<| a tags=java,algorithm |>\nI solved this with help from this post https://codereview.stackexchange.com/questions/135945/check-if-a-number-is-power-of-n-using-logarithm\n\
    <code>\npublic static boolean isPower(long num, long power)\n{\n    long value\
    \ = Math.pow(Math.pow(num,power),power);\n    return value == num;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\n<code>\npublic static boolean isPower(int a, int b){\n\
    \    if(a%b==0 && a>0){\n        if(a != 0 && b % a == 0){\n            return\
    \ false;\n        }\n    }", "{\n    long long int pow = n;\n    while (pow)\n\
    \    {\n        if (x % pow == 0) return true;\n        pow--;\n    }\n    return\
    \ false;\n}", "{\n    if(n <= 0)\n        return false;\n    if(n >= std::numeric_limits<long>::max_exponent10)\n\
    \        return false;\n    if(std::abs(x) > std::numeric_limits<long>::max_exponent10)\n\
    \        return false;\n    long p = 1;\n    for(int i = 1; i < n; ++i) {\n  \
    \      p *= x;\n    }\n    long t = 1;\n    for(int i = 0; i < n; ++i) {\n   \
    \     t *= x;\n    }\n    for(int i = n - 2; i >= 0; --i) {\n        if(p > std::numeric_limits<long>::max_exponent10)\
    \ {\n            return false;\n        }\n        if(t > std::numeric_limits<long>::max_exponent10)\
    \ {\n            return false;\n        }\n        long q = p / t;\n        if(q\
    \ > std::numeric_limits<long>::max_exponent10) {\n            return false;\n\
    \        }\n        t /= p;\n        p /= q;\n    }\n    return true;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nFor `is_simple_power(2L, 2L)` it returns `true`, but\
    \ this is not true of `is_simple_power(2L, 3L)` because it returns `false`.\n\
    <|/ c |>\n<| c |>\nIt doesn't work for all cases. For example `is_simple_power(3L,\
    \ 1L)` returns true while it's false.\n<|/ c |>\n<| c |>\nCan you give me an example\
    \ where it does not work?\n<|/ c |>\n<| c |>\n`is_simple_power(1L, 3L)` returns\
    \ true while it's false.\n<|/ c |>\n<| c |>\nCan you give me an example where\
    \ it does not work?\n<|/ c |>\n<| a dscore=0 tags=math,algorithm,c++ |>\nJust\
    \ for fun I did this in Python:\n<code>\ndef is_simple_power(n: int, m: int) ->\
    \ bool:\n    return (m ** n) == (m // m if (n % 2 != 0 or m * m == 1) else 1)",
  "{\n    long result = x;\n    result *= x;\n    result /= n;\n    result %= n;\n\
    \    return result == x;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI have\
    \ tried this way and my answer is as following :\n<code>\n#include <iostream>\n\
    using namespace std;", "{\n    return std.typecons.power_of_n(n, x) == x;\n}",
  "{\n    return ((n>0) && ((x & (n-1))==0L));\n}\n</cell>\n<text>\nLet's test our\
    \ function:", "{\n    if (n==0) {\n        return true;\n    }\n    if (x==0)\
    \ {\n        return false;\n    }\n    if (x==1) {\n        return true;\n   \
    \ }\n    if (n==1) {\n        return is_simple_power(x, n-1);\n    }\n    long\
    \ y = (n-1)/2;\n    if (is_simple_power(x, y)==false) {\n        return is_simple_power(x,\
    \ n);\n    }\n    return is_simple_power(x, n);\n}", "{\n    return (x == n &&\n\
    \            n % 2 == 0 && \n            n % 4 != 0 &&\n            n % 8 != 0);\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nFor reference, `long double` has a much\
    \ larger exponent range.  Your function will return true for `is_simple_power(1L,\
    \ 3L)`.\n<|/ c |>\n<| c |>\nAlso, `1L` isn't a simple power of `3`.  It is a simple\
    \ power of `1`.  Thus your function would return true for `is_simple_power(3L,\
    \ 3L)`.  You would need to check for `n < 1`.\n<|/ c |>\n<| c |>\n, good catch.\
    \  I've updated my answer.  It was originally intended to test integers, but I\
    \ forgot about floating-point error.  I'll update my answer to fix that issue,\
    \ and to remind OP that `is_simple_power(1L, 3L)` returns `true` for `is_simple_power(1L,\
    \ 3L)`.\n<|/ c |>\n<| c |>\nAlso, `pow` is a floating-point function, so it may\
    \ produce incorrect results for certain inputs.  For example, `pow(3L, 1L)` returns\
    \ `1L`.  You would need to use `std::pow`.\n<|/ c |>\n<| a tags=math,python,c++,c#\
    \ |>\nYou can use the % operator like so:\n<code>\nif(num % n == 0)\n{\n  //...\n\
    }\n</code>\nWhere the % operator computes the remainder of num/n. Since both num\
    \ and n are integers, you only need to check the remainder. An example of this\
    \ would be like so:\n<code>", "{\n\tif (x==1)\n\t\treturn true;\n\tif (x==0)\n\
    \t\treturn false;\n\treturn (n>1)? pow(x, n) == x: is_simple_power(x,n);\n}",
  "{\n    long nint=(int)n;\n    long logx=log(x);\n    long lognint=log(n);\n   \
    \ long logxlognint=logx+lognint;\n    long res=logxlognint;\n    return res==0\
    \ || (res<logx && res<(logxlognint+lognint));\n}\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nYou can use logarithms to work out the largest power of two that is a multiple\
    \ of the number. \n<code>", "{\n    if (n == 0) \n        return true;\n    if\
    \ (n % 2 == 0) \n        return (is_simple_power(x, n / 2)) && (is_simple_power(x,\
    \ (n / 2)-1));\n    else\n        return (is_simple_power(x, n / 2)) && (is_simple_power(x,\
    \ (n / 2) - 1));\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nHere is a simple solution.\
    \ \n<code>\npublic bool isSimplePower(long x)\n    {\n        long t = 1;\n  \
    \      while (x < 1)\n        {\n            x *= 2;\n            if (x == 1)\n\
    \                return true;\n            if (x % 2 == 0)\n                t\
    \ *= x / 2;\n            else\n                t *= x / 2;\n        }\n      \
    \  return false;\n    }\n</code>\n<|/ a tags=c#,algorithm |>\n<| a dscore=1 tags=c#,algorithm\
    \ |>\nI have checked this problem and here is my solution. \n<code>\nusing System;",
  "{\n    // your code here\n    int r = 1;\n    for(int i = 1; i <=n; i++){\n   \
    \     if(x % i == 0){\n            r = 0;\n        }\n    }\n    return r;\n}",
  "{\n    if (x == 1L) {\n        return true;\n    }\n    else if (n == 1L) {\n \
    \       return x == n; // x must be a simple power of n\n    }\n    else {\n \
    \       return x == n * n;\n    }\n}", "{\n    long ans = 1;\n    while (n > 1)\
    \ {\n        if (x % n == 0) \n        {\n            x /= n;\n            ans\
    \ *= n;\n            n--;\n        }\n        else \n        {\n            break;\n\
    \        }\n    }\n    return (n == 0 && x != 1);\n}", "{\n\tif (n % x == 0) \n\
    \t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n</code>\n\
    <|/ a tags=c++,c++11 |>\n<| c |>\nThis doesn't work for negative numbers. `is_simple_power(-1L,\
    \ 2L)` returns true when it should return false.\n<|/ c |>\n<| c |>\nYour code\
    \ is incomplete, your function is_simple_power has one parameter, but you have\
    \ passed two arguments. Please check it once again.\n<|/ c |>\n<| c |>\nYes, this\
    \ has already been fixed. Thanks for pointing it out.\n<|/ c |>\n<| a tags=c++,c++11\
    \ |>\nThe most efficient way to determine if integer a is a power of b is to use\
    \ exponentiation by squaring and to check that the result is greater than a constant\
    \ value.\n<code>", "{\n    return (n>1) ? std.math.pow(n,x) == x : false;\n}",
  "{\n    return pow(10, n) == x;\n}", "{\n    long res = 0;\n    for(long i = 1;\
    \ i<=n; i++)\n    {\n        res = res*x + i;\n    }\n    if(res==x)\n    {\n\
    \        return true;\n    }\n    return false;\n}", "{\n    long y = (n<<1);\n\
    \    long result = power(x,y);\n    if (result==x)\n    {\n        return true;\n\
    \    }\n    return false;\n}\n</code>\n<|/ a tags=c++,algorithm dscore=1 |>\n\
    <| a dscore=0 tags=c++,algorithm |>\nI solved it using bitwise operators to check\
    \ if x ** y is even or odd.\n<code>\n#include <bits/stdc++.h>\nusing namespace\
    \ std;", "{\n    long y = x * n;\n    long power = 1;\n    int exponent = 0;\n\
    \    int diff = 0;\n    while(y != 1) {\n        int rem = (int)(y % 10);\n  \
    \      diff++;\n        if(rem == 1)\n            exponent++;\n        y /= 10;\n\
    \    }\n    while(power < diff) {\n        power *= n;\n    }\n    if(power !=\
    \ x) {\n        return false;\n    } else {\n        while(exponent > 0) {\n \
    \           if(n >= 1) {\n                if(x % n == 0) {\n                 \
    \   return true;\n                }\n                n /= n;\n            } else\
    \ {\n                return false;\n            }\n            exponent--;\n \
    \       }\n        return false;\n    }\n}\n</code>\n<|/ a tags=c++ |>\n<| a |>\n\
    You don't need to write an iterative algorithm to do this.  There is a simple\
    \ O(log(n)) solution, which can be found here.\n<|/ a tags=c++ dscore=2 |>\n<|\
    \ c |>\nThanks, but your link doesn't work for me, probably because I don't have\
    \ enough reputation. :( Do you have a link to an O(log(n)) solution? That is what\
    \ I am looking for.\n<|/ c |>\n<| c |>\n, it's an O(log(n)) solution.  It can\
    \ be found on the Wikipedia article I linked to.  There's also a link to the source\
    \ code on that page.  I posted the relevant code in this answer.\n<|/ c |>\n<|\
    \ c |>\nOh sorry, I missed it. But I still have the problem that the link does\
    \ not work for me. Maybe the problem is that I use Mac OS X and I have no access\
    \ to my home computer.\n<|/ c |>\n<| c |>\n, try the new link I just added to\
    \ the end of the answer.\n<|/ c |>\n<| c |>\nI tried both of your links. I now\
    \ get this error message: \"An error occurred while trying to fetch the URL: http://www.math.harvard.edu/~pat/code/pascal/fib/fib.html\"\
    . Do you know what that means?\n<|/ c |>\n<| a tags=c++ |>\nHere is my recursive\
    \ solution in Python. The key is to realize that x^n can be computed by multiplying\
    \ x by itself n times. I didn't want to go too far into the code, but it is easy\
    \ to see how this works for powers of 2 and even powers of 3.\n<code>\ndef powerof(x):\n\
    \    \"\"\"\n    Returns True if x is a power of 2.", "{\n    long r = log(x);\n\
    \    long p = (n - 1) / log(2);\n    long m = p - 1;\n    if((n % 2) == 0)\n \
    \       return (r == m);\n    else\n        return (r != m);\n}", "{\n    long\
    \ r = n;\n    while(r > 0 && n % r == 0) {\n        r = r/r;\n    }\n    return\
    \ r == 1;\n}\n</code>\n<|/ a tags=math,c++,integer-overflow |>\n<| c |>\n`is_simple_power(5L,\
    \ 3L)` will return true.\n<|/ c |>\n<| c |>\nI think it's `r == 1;` and not `r\
    \ == r;`.\n<|/ c |>\n<| a dscore=2 |>\nThis is my solution. Not as efficient as\
    \ Boris's but works for positive integers:\n<code>", "{\n    if(n==0) return true;\n\
    \    return ((long) x) == ((long) pow(x,n));\n}", "{\n    return ((n**int)==x);\n\
    }\n</code>\n<|/ a tags=c++,long-long |>\n<| c |>\n`long long int x = (long long\
    \ int) pow(l,l);` is this a typo ?\n<|/ c |>\n<| c |>\nYes, it is. I've fixed\
    \ it.\n<|/ c |>\n<| a |>\nI realize that this post is a bit old, but for anyone\
    \ who is trying to solve this problem and is not willing to install a library,\
    \ here is a solution using a loop:\n<code>\n#include <iostream>", "{\n    long\
    \ power = n;\n    while (n > 0)\n    {\n        power %= power;\n        if (power%x\
    \ == 0)\n            return true;\n        power *= n;\n    }\n    return false;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nMy code was correct but i had\
    \ to add a statement to my is_power function so it would not take as large of\
    \ a number as I wanted it to (since it is taking a long integer) \n<code>", "{\n\
    \    long result = x;\n    long factor = 1;\n    while(factor*factor < n) {\n\
    \        factor *= factor;\n    }\n    while (result != 1 && result != factor)\
    \ {\n        if (result % factor == 0) {\n            return false;\n        }\n\
    \        result *= factor;\n    }\n    return true;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
