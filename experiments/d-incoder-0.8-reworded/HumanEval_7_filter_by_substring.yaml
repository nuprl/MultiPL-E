name: HumanEval_7_filter_by_substring
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Filter an input array of strings\
  \ only for ones that contain given substring\n    >>> filter_by_substring([], \"\
  a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
  ], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
  \ strings, string substring) \n"
tests: "unittest\n{\n    alias candidate = filter_by_substring;\n\n    assert(candidate([],\
  \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
  , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"\
  xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\") == [\"xxx\"\
  , \"aaaxxy\", \"xxxAAA\", \"xxx\"]);\n    assert(candidate([\"grunt\", \"trumpet\"\
  , \"prune\", \"gruesome\"], \"run\") == [\"grunt\", \"prune\"]);\n}\nvoid main(){}"
completions: ["{\n    if (substring.length == 0) {\n        return strings;\n    }",
  "{\n    int index = -1;\n    for(int i=0;i<strings.length;i++)\n    {\n        index\
    \ = strings[i].indexOf(substring);\n        if (index != -1)\n        {\n    \
    \        strings[i] = strings[i].substring(index+substring.Length);\n        }\n\
    \    }\n    return strings;\n}", "{\n\tstring[] result = new string[strings.length];\n\
    \tfor(int i = 0; i < strings.length; i++)\n\t\tif(strings[i].contains(substring))\n\
    \t\t\tresult[i] = strings[i];\n\treturn result;\n}\n/*\n Sort an input array of\
    \ strings according to a function\n    >>> sort_by_function([\"c\", \"b\", \"\
    a\"])\n    [\"a\", \"b\", \"c\"]\n    \n*/\nstring[] sort_by_function(string[]\
    \ strings, Func1Of2Of2 func)\n{\n\tstring[] result = new string[strings.length];\n\
    \tfor(int i = 0; i < strings.length; i++)\n\t\tresult[i] = func(strings[i], i);\n\
    \t\n\tArray.Sort(result);\n\t\n\treturn result;\n}\n/*\n Sort an input array of\
    \ strings according to a function\n    >>> sort_by_function([\"c\", \"b\", \"\
    a\"], std.string.len.compare)\n    [\"a\", \"b\", \"c\"]\n    \n*/\nstring[] sort_by_function(string[]\
    \ strings, int func)\n{\n\tstring[] result = new string[strings.length];\n\tfor(int\
    \ i = 0; i < strings.length; i++)\n\t\tresult[i] = strings[i];\n\t\n\tArray.Sort(result,\
    \ 0, strings.length, func, func, std.compare);\n\t\n\treturn result;\n}", "{\n\
    \  string[] result=new string[];\n  foreach(i, s)\n  {\n    if (contains(s, substring))\n\
    \      result.add(s);\n  }\n  return result;\n}\n</code>\nAnd here's the implementation\
    \ of the contains function, for completeness\n<code>\nfunction bool contains(string\
    \ s, string pattern)\n{\n  var pos = s.indexOf(pattern);\n  if (pos < 0)\n   \
    \ return false;\n  else\n    return true;\n}\n</code>\n<|/ a dscore=3 |>\n<| a\
    \ |>\nSince no one here has given a solution with Python, I'm adding mine for\
    \ completeness. Hopefully it'll be helpful.\n<code>\nimport re", "{\n\tstring[]\
    \ result = new string[strings.length];\n\t\n\tfor(int i = 0; i < strings.length;\
    \ ++i)\n\t{\n\t\tif(strings[i].contains(substring))\n\t\t{\n\t\t\tresult[i] =\
    \ strings[i];\n\t\t}\n\t}\n\treturn result;\n}\n// END GENERATED CODE", "{\n \
    \   var re = new RegExp(\".*\" + substring + \".*\", \"i\");\n    return filter(strings,\
    \ function (string) {\n        return string.match(re);\n    });\n}\n/*\n Filter\
    \ an input array of strings only for ones that don't contain given substring\n\
    \    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"cde\", \"array\"]\n    \n\
    */\nstring[] filter_by_substring_reverse(string[] strings, string substring) \n\
    {\n    var re = new RegExp(\".*\" + substring + \".*\", \"i\");\n    return reverseFilter(strings,\
    \ function (string) {\n        return string.match(re);\n    });\n}\n/*\n Filter\
    \ an input array of strings only for ones that contain given substring\n    >>>\
    \ filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"abc\"\
    , \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n\
    \    \n*/\nstring[] filter_by_substring_and_substring(string[] strings, string\
    \ substring) \n{\n    var re = new RegExp(\".*\" + substring + \".*\", \"i\");\n\
    \    return filter(strings, function (string) {\n        return string.match(re);\n\
    \    }).reverse();\n}\n/*\n Filter an input array of strings only for ones that\
    \ don't contain given substring\n    >>> filter_by_substring([], \"a\")\n    []\n\
    \    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n\
    \    [\"cde\", \"array\"]\n    \n*/\nstring[] filter_by_substring_and_substring_reverse(string[]\
    \ strings, string substring) \n{\n    var re = new RegExp(\".*\" + substring +\
    \ \".*\", \"i\");\n    return reverseFilter(strings, function (string) {\n   \
    \     return string.match(re);\n    }).reverse();\n}\n/*\n Filter an input array\
    \ of strings only for ones that contain the given word\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_word_on_substring(string[]\
    \ strings, string word) \n{\n    return filter(strings, function (string) {\n\
    \        return string.indexOf(word) !== -1;\n    });\n}\n/*\n Filter an input\
    \ array of strings only for ones that don't contain the given word\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"cde\", \"array\"]\n    \n*/\nstring[] filter_by_word_on_substring_reverse(string[]\
    \ strings, string word) \n{\n    return reverseFilter(strings, function (string",
  "{\n  int len = strings.length;\n  int i = 0;\n  int j = 0;\n  string[] newStrings\
    \ = new string[len];", "{\n  var filtered = new List<string>();\n  foreach (string\
    \ s in strings) {\n    if (s.contains(substring)) filtered.Add(s);\n  }\n  return\
    \ filtered.ToArray();\n}", "{\n  ArrayList result = new ArrayList();\n  foreach\
    \ (string s in strings)\n  {\n    if (s.indexOf(substring) != -1) result.add(s);\n\
    \  }\n  return (string[])result.ToArray(typeof(string));\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThat is **not** JavaScript.\n<|/ c |>\n<| c |>\nThanks for reminding.\
    \ Edited to remove reference to JavaScript and replace with C# code.\n<|/ c |>\n\
    <| c |>\nThanks, your solution did work, I just needed to add the `using System.Collections.Generic;`\
    \ to the top. I was trying to do it in one line without adding more libraries/packages.\
    \ Now I have two questions though, why is the string comparison case sensitive\
    \ and why is the `string[] result = strings.ToArray();` not `return result.ToArray();`?\n\
    <|/ c |>\n<| c |>\n- I added the code I used to test your solution. `string` is\
    \ case sensitive by default, and `string[]` is an array of `string`s.\n<|/ c |>\n\
    <| c |>\nI see, thanks. I thought `ToArray` returned a reference to an array (an\
    \ `ArrayList`).\n<|/ c |>\n<| a dscore=2 tags=c#,arrays |>\nIf you have .NET 4\
    \ or higher you can use this method (which was taken from this SO answer):\n<code>\n\
    public static bool Contains<T>(this T[] array, T element)\n{\n    return array.Contains(element,\
    \ Comparer.OrdinalIgnoreCase);\n}\n</code>\nFor earlier versions you can use this\
    \ simple method:\n<code>\npublic static bool Contains(this T[] array, T element)\n\
    {\n    return array.Any(a => a.Equals(element, StringComparison.OrdinalIgnoreCase));\n\
    }\n</code>\n<|/ a |>\n<| a dscore=2 tags=c#,arrays |>\nYou can use the List<T>.Contains\
    \ method:\n<code>\nstring[] search = new string[] { \"string1\", \"string2\",\
    \ \"string3\" };", "{\n    string[] result = new string[strings.length];\n   \
    \ for (int i = 0; i < strings.length; i++)\n    {\n        if (strings[i].contains(substring))\n\
    \        {\n            result[i] = strings[i];\n        }\n    }\n    return\
    \ result;\n}", "{\n    list<string> filtered = new list<string>();", "{\n    if\
    \ (strings.length == 0)\n        return strings;\n    \n    foreach (string s\
    \ in strings) {\n        if (s.indexOf(substring) >= 0)\n            strings.remove(\"\
    string\");\n    }\n    return strings;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nThe simple way that doesn't require any libraries is to convert the list\
    \ to a set and check the membership of the substring using contains:\n<code>\n\
    public class Main{", "{\n    var filtered_strings = strings.Where(s => s.Contains(substring)).ToArray();\n\
    \    return filtered_strings;\n}\n</code>\n<|/ a tags=c#,string,arrays |>\n<|\
    \ a tags=c#,string,arrays dscore=0 |>\nTry this:\n<code>\npublic string[] filter_by_substring(string[]\
    \ strings, string substring)\n{\n    string[] filtered = strings.Where(s => s.Contains(substring)).ToArray();\n\
    \    return filtered;\n}\n</code>\n<|/ a |>\n<| c |>\n`public string[] filter_by_substring(string[]\
    \ strings, string substring)\n{\n    string[] filtered = strings.Where(s => s.Contains(substring)).ToArray();\n\
    \    return filtered;\n}` - I tested this out and it didn't work for me.\n<|/\
    \ c |>\n<| c |>\nOk, try this then: `public string[] filter_by_substring(string[]\
    \ strings, string substring)\n{\n    string[] filtered = strings.Where(s => s.Contains(substring)).ToArray();\n\
    \    return filtered;\n}`\n<|/ c |>\n<| c |>\nIt was my mistake - I put your method\
    \ inside my main method instead of outside it. Thank you so much!\n<|/ c |>\n\
    <| a |>\nThis should do it.\n<code>\nprivate static string[] filter_by_substring(string[]\
    \ strings, string substring)\n{\n    var filtered = strings.Where(s => s.Contains(substring)).ToArray();\n\
    \    return filtered;\n}\n</code>\n<|/ a tags=c#,string,arrays dscore=0 |>\n<|\
    \ a dscore=0 tags=c#,string,arrays |>\n<code>\nstring[] array = { \"asdsa\",\"\
    sdsa\",\"asdsa\",\"asdsa\",\"asdasd\" };\nstring valueToFind = \"sdsa\";", "{\n\
    \  int pos = 0;\n  string substringToTest = substring;\n  foreach (string s in\
    \ strings) {\n    if (s.IndexOf(substring, pos) != -1) {\n      string[] newSubstrings\
    \ = strings.Where((s) => s.IndexOf(substring, pos) != -1).ToArray();\n      string[]\
    \ newStrings = new string[newSubstrings.Length + 1];\n      for (int i = 0; i\
    \ < newSubstrings.Length; i++) {\n        newStrings[i] = newSubstrings[i];\n\
    \      }\n      newStrings[newStrings.Length - 1] = s;\n      string[] result\
    \ = newSubstrings.ToArray();\n      string[] newResult = result.Where((s) => s\
    \ !=  s).ToArray();\n      string[] finalResult = newResult.Where((s) => s.IndexOf(substringToTest)\
    \ == -1).ToArray();\n      return finalResult;\n    }\n    pos = pos + substring.Length;\n\
    \  }\n  return strings;\n}\n</code>\n<|/ a dscore=0 tags=string,c#,arrays |>\n\
    <| a tags=string,c#,arrays dscore=0 |>\nIf your array contains only strings and\
    \ you need to find all substrings of a given substring, then it would be better\
    \ to use a Dictionary<string, int> to store the positions of substrings. If you\
    \ need to find all substrings then you need to find all substrings starting from\
    \ a given position and store their positions in a list, then you can traverse\
    \ the dictionary and remove all values from the dictionary that are greater than\
    \ the given position and then check the rest of the dictionary for values greater\
    \ than the position the substring was removed from. You can then repeat this process\
    \ to get all substrings.\n<code>\npublic class Program\n{\n    public static void\
    \ Main(string[] args)\n    {\n        string input = \"abcabc\";\n        string\
    \ substring = \"ab\";", "{\n    string[] filter = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; ++i) {\n      if (strings[i].contains(substring))\
    \ {\n        filter[i] = strings[i];\n      }\n    }\n    return filter;\n}\n\
    </code>\n<|/ a dscore=0 tags=string,c# |>\n<| a dscore=0 tags=string,c# |>\nI\
    \ believe this solution should work:\n<code>\nList<string> filter = new List<string>();\n\
    var pattern = \"abc\";\nvar input = new List<string>() { \"a\", \"abc\", \"bacd\"\
    , \"cde\", \"array\" };\ninput.ForEach(p => pattern.ToLower().Contains(p) ? filter.Add(p)\
    \ : null);\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere's an algorithm I made from\
    \ scratch in JAVA. It's a recursive method which takes an array of strings and\
    \ a pattern as parameters. The algorithm is as follows: \nIf string array is empty\
    \ then return.\nIf the string array only has one element then return.\nIf the\
    \ pattern contains the string array element then return.\nIf the pattern does\
    \ not contain the string array element then search for the pattern and remove\
    \ the element from the string array and call the method recursively with the new\
    \ string array and the new pattern.\n<code>\npublic static ArrayList<String> removeElementFromArray(String\
    \ [] array,String pattern){\n        ArrayList<String> newArray = new ArrayList<>();\n\
    \        //if array is empty return it\n        if(array.length == 0){\n     \
    \       return newArray;\n        }\n        //if the array has only one element\
    \ then return\n        if(array.length == 1){\n            return newArray;\n\
    \        }\n        //if the pattern contains the string array element then return\n\
    \        if(Arrays.asList(array).contains(pattern)){\n            return newArray;\n\
    \        }\n        //if the pattern does not contain the string array element\
    \ then search for the pattern and remove the element from the string array and\
    \ call the method recursively with the new string array and the new pattern\n\
    \        else{\n            ArrayList<String> arrayWithoutElement = new ArrayList<>(Arrays.asList(array).subList(1,\
    \ array.length));\n            String newPattern = pattern;\n            arrayWithoutElement.forEach(a->\
    \ newPattern = newPattern.replaceAll(\"\\\\b\"+a+\"\\\\b\", \" \"));\n       \
    \     arrayWithoutElement.forEach(a-> newArray.add(newPattern+a));\n         \
    \   newArray.addAll(removeElementFromArray(arrayWithoutElement, pattern));\n \
    \           return newArray;\n        }\n    }\n</code>\n<|/ a tags=string,c#\
    \ |>\n<| a tags=string,c# |>\nYou can use LINQ for that :\n<code>\nstring str[]\
    \ = { \"a\", \"abc\", \"bacd\", \"cde\", \"array\" };\nstring pattern = \"abc\"\
    ;\n", "{\n  return strings.filter(s => s.indexOf(substring) > -1);\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI added an explanation of why this is not an appropriate\
    \ replacement for `contains()` because of the inherent problems it causes (and\
    \ an example of how to use this function in a different situation).\n<|/ c |>\n\
    <| c |>\nThe `substring` parameter has to be an exact match of the search string.\n\
    <|/ c |>\n<| c |>\nthat's correct. However, the OP did state that the string might\
    \ contain other characters, which is why `contains()` is unsuitable. I added a\
    \ suggestion to my answer to use `indexOf()`, which would allow for a regex match,\
    \ but it's still unclear whether that should be used.\n<|/ c |>\n<| c |>\nIt seems\
    \ that you're missing the point. OP's original code has `string[] strings` parameter.\
    \ He needs to use that. Your proposed solution does not solve the problem, because\
    \ it's not actually using that parameter. But if you were to change it to `string\
    \ strings` then it would.\n<|/ c |>\n<| a dscore=1 |>\nThe most efficient solution\
    \ is to convert the string to a HashSet, since a HashSet has a constant lookup\
    \ time. This solution is also very efficient for large strings. The solution is\
    \ as follows:\n<code>\npublic static boolean containsSubString(String s, String\
    \ substring) {\n    if (s == null || substring == null)\n        return false;\n\
    \    \n    char[] chars = s.toCharArray();\n    char[] charSub = substring.toCharArray();\n\
    \    Set<Character> subSet = new HashSet<>(charSub);\n    \n    return Arrays.stream(chars).anyMatch(ch\
    \ -> subSet.contains(ch));\n}\n</code>\nThe runtime of this code is O(n + m),\
    \ where n is the length of the string and m is the length of the substring.\n\
    <|/ a tags=string,algorithm,c++ |>\n<| c |>\nThat would be better if you used\
    \ a set instead of a list for the `Set<Character>`, since the `contains` method\
    \ for a set is `O(1)`.\n<|/ c |>\n<| c |>\nUsing a set would be an improvement,\
    \ yes, since `contains` for a set is `O(1)` instead of `O(n)`. For large strings,\
    \ however, this is quite inefficient, since it uses linear time for the string\
    \ and linear time for the substring.\n<|/ c |>\n<| c |>\nI actually don't think\
    \ this is what OP is looking for, but I could be mistaken.\n<|/ c |>\n<| c |>",
  "{\n    string[] result = new string[strings.length];\n    int count = 0;\n    for(int\
    \ i = 0; i < strings.length; i++)\n    {\n        if(strings[i].Contains(substring))\n\
    \        {\n            result[count++] = strings[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n Filter an input array of strings only for ones that do not\
    \ contain given substring\n    >>> filter_by_substring([], \"a\")\n    []\n  \
    \  >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"ab\")\n\
    \    []\n    \n*/\nstring[] filter_by_not_substring(string[] strings, string substring)\
    \ \n{\n    string[] result = new string[strings.length];\n    int count = 0;\n\
    \    for(int i = 0; i < strings.length; i++)\n    {\n        if(!strings[i].Contains(substring))\n\
    \        {\n            result[count++] = strings[i];\n        }\n    }\n    return\
    \ result;\n}", "{\n  List<string> result = new List<string>();\n  for (int i =\
    \ 0; i < strings.Length; i++)\n  {\n    if (strings[i].Contains(substring))\n\
    \    {\n      result.Add(strings[i]);\n    }\n  }\n  return result.ToArray();\n\
    }\n</code>\n<|/ a tags=c#,string,arrays |>\n<| c |>\nThe question was tagged `C#`;\
    \ your answer is for Java.\n<|/ c |>\n<| a |>\n<code>\nvar filterStrings = new\
    \ [] {\n  \"abcd\",\n  \"efgh\",\n  \"ijkl\",\n  \"mnop\",\n  \"qrst\",\n  \"\
    uvwx\",\n  \"yzab\"\n};", "{\n    \n    string[] filteredStrings = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; i++)\n    {\n        if (strings[i].Contains(substring))\n\
    \        {\n            filteredStrings[i] = strings[i];\n        }\n    }\n \
    \   \n    return filteredStrings;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhile\
    \ this code may solve the question, [including an explanation](https://meta.stackexchange.com/q/114762)\
    \ of how and why this solves the problem would really help to improve the quality\
    \ of your post, and probably result in more up-votes. Remember that you are answering\
    \ the question for readers in the future, not just the person asking now. Please\
    \ [edit] your answer to add explanations and give an indication of what limitations\
    \ and assumptions apply.\n<|/ c |>\n<| c |>\nThank you for the comments. I've\
    \ edited my answer.\n<|/ c |>\n<| a tags=c#,linq,algorithm |>\nIn case of string\
    \ search you can use Contains method of string class.\n<code>\nstring[] strings\
    \ = { \" the quick brown fox jumps over the lazy dog\", \n                   \"\
    \ the quick brown fox jumps over the lazy dog\", \n                   \" the quick\
    \ brown fox jumps over the lazy dog\" };", "{\n    int[] indices = new int[strings.length];\n\
    \    for(int i = 0; i < strings.length; i++) \n    {\n        string s = strings[i];\n\
    \        int offset = s.indexOf(substring);\n        if (offset != -1) {\n   \
    \         indices[i] = offset;\n        }\n    }\n    \n    Arrays.sort(indices);\n\
    \    \n    ArrayList al = new ArrayList();\n    for(int i = 0; i < indices.length;\
    \ i++)\n    {\n        if (indices[i] != 0)\n        {\n            al.add(strings[indices[i]]);\n\
    \        }\n    }\n    \n    return al.toArray(new string[al.size()]);\n}\n</code>\n\
    <|/ a |>\n<| a dscore=1 tags=string,sorting,arrays,c#,filter |>\nA slight improvement\
    \ on AxelH's answer which uses LINQ to Objects (which is available in C# 3.5 and\
    \ later). \n<code>\nprivate string[] FilterStrings(string[] strings, string filter)\n\
    {\n    var filtered = strings.Where((s, i) => s.IndexOf(filter, i) > -1).ToArray();\n\
    \    var sortedStrings = filtered.OrderBy(s => s).ToArray();\n    return sortedStrings;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI believe your sort should be on strings length\
    \ - I believe that's how String.IndexOf works too.\n<|/ c |>\n<| a tags=string,sorting,arrays,c#,filter\
    \ dscore=1 |>\nMy own version to sort any array (from any source) and remove any\
    \ not wanted.\n<code>\npublic static int[] removeDuplicates(int[] numbers, string[]\
    \ exclude)\n    {\n        int[] numbersSorted = numbers.OrderBy(n => n).ToArray();\n\
    \        int[] excludeSorted = exclude.OrderBy(s => s).ToArray();\n        int[]\
    \ uniqueNumbers = new int[numbersSorted.Length];\n        int[] uniqueExclude\
    \ = new int[excludeSorted.Length];\n        int unique = 0;\n        int count\
    \ = 0;", "{\n\tList<string> result = new List<string>();\n\tforeach(var item in\
    \ strings) \n\t{\n\t\tif(item.Contains(substring))\n\t\t{\n\t\t\tresult.Add(item);\n\
    \t\t}\n\t}\n\treturn result.ToArray();\n}\n/*\n Filter an input array of strings\
    \ only for ones that do not contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n\tList<string> result = new List<string>();\n\
    \tforeach(var item in strings) \n\t{\n\t\tif(!item.Contains(substring))\n\t\t\
    {\n\t\t\tresult.Add(item);\n\t\t}\n\t}\n\treturn result.ToArray();\n}", "{\n \
    \   string[] result = new string[strings.length];\n    int idx = 0;\n    for (idx\
    \ = 0; idx < strings.length; idx++)\n    {\n        if (strings[idx].contains(substring))\n\
    \            result[idx] = strings[idx];\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=5 tags=string,c#,filter |>\n<| a tags=string,c#,filter |>\nI haven't\
    \ yet tested this out, but you might want to look into the Regex class.  It allows\
    \ you to search for certain strings in the string.  It even comes with some nice\
    \ patterns for exactly what you need.\n<|/ a dscore=3 |>\n<| a |>\nI've got an\
    \ Extension method that does this for me:\n<code>\npublic static IEnumerable<string>\
    \ Filter(this IEnumerable<string> source, string filter){\n    return source.Where(x\
    \ => x.Contains(filter)).Distinct();\n}\n</code>\n<|/ a tags=string,c#,filter\
    \ dscore=3 |>\n<| a |>\n<code>\n  public class StringFilter\n  {\n    public bool\
    \ Contains(string value)\n    {\n      bool _Contains = false;", "{\n\tif (strings.length\
    \ == 0) {\n\t\treturn new string[0];\n\t}\n\tstring[] result = new string[strings.length];\n\
    \tfor (int i = 0; i < strings.length; ++i) {\n\t\tif (strings[i].Contains(substring))\
    \ {\n\t\t\tresult[i] = strings[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n Merge\
    \ two arrays\n    >>> merge([1,2], [2])\n    [1, 2]\n    >>> merge([2,3], [1,2])\n\
    \    [2, 3, 1, 2]\n    \n*/\nstatic int[] merge(int[] a, int[] b)\n{\n\tint[]\
    \ result = new int[a.Length + b.Length];\n\tSystem.Array.Copy(a, 0, result, 0,\
    \ a.Length);\n\tSystem.Array.Copy(b, 0, result, a.Length, b.Length);\n\treturn\
    \ result;\n}\n/*\n Find the intersection between two arrays\n    >>> intersect([1,2,3],[3,4,5])\n\
    \    [4, 5]\n    >>> intersect([2,3],[1,4])\n    []\n    \n*/\nstatic int[] intersect(int[]\
    \ a, int[] b)\n{\n\tif (a == null || b == null) {\n\t\treturn null;\n\t}\n\tint[]\
    \ result = new int[a.Length];\n\tfor (int i = 0; i < a.Length; ++i) {\n\t\tif\
    \ (Contains(b, a[i])) {\n\t\t\tresult[i] = a[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\n Convert a list of ints into a list of floats\n    >>> to_float([1,2,3])\n\
    \    [1.0,2.0,3.0]\n    \n*/\nstatic float[] to_float(int[] a)\n{\n\tfloat[] result\
    \ = new float[a.Length];\n\tfor (int i = 0; i < a.Length; ++i) {\n\t\tresult[i]\
    \ = (float)a[i];\n\t}\n\treturn result;\n}\n/*\n Create a function that calculates\
    \ the sum of a sequence of numbers.\n    >>> sum_of([1,2,3])\n    6\n    \n*/\n\
    static int sum_of(int[] a)\n{\n\tint result = 0, i;\n\tfor (i = 0; i < a.Length;\
    \ ++i) {\n\t\tresult += a[i];\n\t}\n\treturn result;\n}\n/*\n Create a function\
    \ that calculates the maximum of a sequence of numbers.\n    >>> max_of([1,2,3])\n\
    \    3\n    \n*/\nstatic int max_of(int[] a)\n{\n\tint result = 0, i;\n\tfor (i\
    \ = 0; i < a.Length; ++i) {\n\t\tif (result < a[i]) {\n\t\t\tresult = a[i];\n\t\
    \t}\n\t}\n\treturn result;\n}\n/*\n Create a function that calculates the minimum\
    \ of a sequence of numbers.\n    >>> min_of([1,2,3])\n    1\n    \n*/\nstatic\
    \ int min_of(int[] a)\n{\n\tint result = 0, i;\n\tfor (i = 0; i < a.Length; ++i)\
    \ {\n\t\tif (result > a[i]) {\n\t\t\tresult = a[i];\n\t\t}\n\t}\n\treturn ", "{\n\
    \  string[] result = new string[strings.length];\n  int i=0;\n  int j=0;\n  for(;i<strings.length;i++)\
    \ \n  {\n    for(;j<strings[i].length();j++) \n    {\n      if(strings[i].substr(j,substring.length())\
    \ == substring) \n      {\n        result[i] = strings[i];\n      }\n    }\n \
    \ }\n  return result;\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=c# |>\n<code>\n\
    var input = new[] {\n    \"some string\",\n    \"another string\",\n    \"third\
    \ string\",\n    \"fourth string\",\n    \"fifth string\",\n    \"sixth string\"\
    ,\n};", "{\n    if (strings == null || strings.length == 0)\n        return strings;\n\
    \    \n    string[] res = new string[strings.length];\n    int i;\n    for (i\
    \ = 0; i < strings.length; ++i)\n    {\n        if (strings[i].Contains(substring))\n\
    \            res[i] = strings[i];\n    }\n    return res;\n}", "{\n\tstring[]\
    \ res;\n\t\n\t// TODO: This is O(n^2), need to optimize \n\tres = new string[strings.length];\n\
    \t\n\tfor (uint i = 0; i < strings.length; i++)\n\t{\n\t\tif (strings[i].contains(substring))\n\
    \t\t{\n\t\t\tres[i] = strings[i];\n\t\t}\n\t}\n\t\n\treturn res;\n}", "{\n   var\
    \ ret = new List<string>();\n   foreach (string s in strings) \n   {\n      if\
    \ (s.Contains(substring)) ret.Add(s);\n   }\n   return ret.ToArray();\n}\n</code>\n\
    You can use this filter to get the strings you need:\n<code>\nstring[] myStrings\
    \ = {\"abc\", \"bacd\", \"cde\", \"array\"}; \nstring[] mySubstrings = {\"a\"\
    , \"ba\"}; \nstring[] filteredStrings = filter_by_substring(myStrings, mySubstrings);\n\
    </code>\nNote that mySubstrings contains 2 strings, not 3.\nYou can write an extension\
    \ method to make the code even shorter:\n<code>\nstatic class StringExt \n{\n\
    \   public static string[] FilterBySubstring(this string[] strings, string substring)\
    \ \n   {\n      return strings.Where(s => s.Contains(substring)).ToArray();\n\
    \   }\n}\n</code>\nNow you can call it like this:\n<code>\nstring[] myStrings\
    \ = {\"abc\", \"bacd\", \"cde\", \"array\"}; \nstring[] filteredStrings = myStrings.FilterBySubstring(\"\
    ba\");\n</code>\n<|/ a |>\n<| c |>\nThank you for the thorough answer. Since I'm\
    \ pretty sure I'm not doing anything too crazy, I went with the non-LINQ option\
    \ for simplicity.\n<|/ c |>\n<| c |>\n, I'm glad you liked it. I agree that the\
    \ non-LINQ option is easier, but sometimes you just have not an alternative for\
    \ that. I'll try to find a non-LINQ solution as well.\n<|/ c |>\n<| c |>\nI do\
    \ have a follow up question based on your comment. Do you know if there are any\
    \ performance implications when using the non-LINQ option?\n<|/ c |>\n<| c |>\n\
    , I'm afraid I don't. Maybe you should ask a separate question about that.\n<|/\
    \ c |>\n<| c |>\nThe non-LINQ solution doesn't work when you have a string that\
    \ contains \"ba\". For example, try the following `string[] myStrings = {\"abc\"\
    , \"bacd\", \"cde\", \"array\"};`. I would want `filteredStrings` to contain \"\
    abc\", \"bacd\", \"array\".\n<|/ c |>\n<| a tags=c#,string,linq dscore=2 |>\n\
    I believe that you can do this with String.Split and an ArrayList:\n<code>\nstring[]\
    \ myStrings = {\"abc\", \"bacd\", \"cde\", \"array\"};\nArrayList myList = new\
    \ ArrayList();\nmyList.AddRange( myStrings.Select(s=>s.Split('.')) );\n", "{\n\
    \tassert(strings.length > 0);\n\tassert(substring != null);\n\t\n\t\n\tstring[]\
    \ result = new string[strings.length];\n\tfor(int i = 0; i < strings.length; i++)\
    \ {\n\t\tstring str = strings[i];\n\t\tif(str.contains(substring)) {\n\t\t\tresult[i]\
    \ = str;\n\t\t}\n\t}\n\t\n\treturn result;\n}", "{\n    List <string> results\
    \ = new List <string> ();\n    for (string s : strings) \n    {\n        if (s.Contains(substring))\
    \ \n        {\n            results.append(s);\n        }\n    }\n    string[]\
    \ r = new string[results.size()];\n    results.copyTo (r);\n    return r;\n}",
  "{\n    int[] indices = new int[strings.length];\n    foreach(int i, strings) {\n\
    \        string value = strings[i];\n        int index = value.find(substring);\n\
    \        if (index != -1) {\n            indices[i] = index;\n        }\n    }\n\
    \    \n    int[] filtered = new int[indices.length];\n    foreach(int i, indices)\
    \ {\n        if (indices[i] != i) {\n            filtered[i - 1] = indices[i];\n\
    \        }\n    }\n    \n    string result = \"\";\n    foreach(string s, strings)\
    \ {\n        result += s;\n        if (filtered.length == 1) break;\n        if\
    \ (filtered.contains(i)) {\n            result += strings[i];\n        }\n   \
    \ }\n    return result.split(substring);\n}", "{\n    for(int i = 0; i < strings.length;\
    \ i++) \n    {\n        if (strings[i].indexOf(substring) != -1) \n        {\n\
    \            strings.RemoveAt(i);\n            i-=1;\n        }\n    }\n    return\
    \ strings;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your response.\
    \ I can see this has two loops iterating over the array. Can you please help me\
    \ in understanding how you came up with this solution without using standard library\
    \ functions?\n<|/ c |>\n<| c |>\nIt's just a different way to write `for(i = array.Length\
    \ - 1; i >= 0; i--)`. That's why you needed to remove the item from the array\
    \ as well. That's actually what the `RemoveAt` method does, so instead of using\
    \ `RemoveAt` I used the `Remove` method instead.\n<|/ c |>\n<| a |>\nI would go\
    \ for LINQ (as already answered). But just for fun I would also go with recursion.\n\
    <code>\nusing System;", "{\n   string[] result = new string[strings.length];\n\
    \   for (int i = 0; i < strings.length; ++i)\n   {\n      if (strings[i].Contains(substring))\n\
    \         result[i] = strings[i];\n   }\n   return result;\n}\n</code>\n<|/ a\
    \ tags=string,filtering,c#,list |>\n<| a tags=string,filtering,c#,list |>\nI wrote\
    \ this as a simple one-liner:\n<code>\nstring[] result = new string[]{\n  \"abc\"\
    , \"bacd\", \"cde\", \"array\",\n  \"ghij\", \"abc\", \"bcd\", \"cde\", \"array\"\
    ,\n  \"ijkl\", \"ghij\", \"bcd\", \"cde\", \"array\"\n}.SelectMany(s => s.Split(new[]\
    \ { \"abc\", \"cde\" }, StringSplitOptions.None)).ToArray();\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nFor fun, here's a solution that doesn't use LINQ:\n<code>\nstring[]\
    \ inputs = new string[] {\n  \"abc\", \"bacd\", \"cde\", \"array\",\n  \"ghij\"\
    , \"abc\", \"bcd\", \"cde\", \"array\",\n  \"ijkl\", \"ghij\", \"bcd\", \"cde\"\
    , \"array\"\n};", "{\n    int index = 0;\n    int count = 1;\n    int lastindex\
    \ = strings.length - 1;\n    \n    for(;index < lastindex; ++index)\n    {\n \
    \       if (strings[index] == substring)\n        {\n            count++;\n  \
    \      }\n        else\n        {\n            break;\n        }\n    }\n    \n\
    \    string[] result = new string[count];\n    \n    for(;index >= 0; --index)\n\
    \    {\n        if (strings[index] == substring)\n        {\n            result[count-1]\
    \ = strings[index];\n            count++;\n        }\n    }\n    \n    \n    return\
    \ result;\n}\n/*\n Filter an input array of strings only for ones that contain\
    \ given substring\n    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\"]\n    \n\
    */", "{\n    int minIndex = strings.length;\n    int maxIndex = 0;\n    for (int\
    \ i = 0; i < strings.length; ++i) {\n        if (strings[i].contains(substring))\
    \ {\n            if (minIndex > i) minIndex = i;\n            maxIndex++;\n  \
    \      }\n    }\n    string[] ret = new string[minIndex + 1];\n    for (int i\
    \ = 0; i < minIndex; ++i) {\n        if (strings[i].contains(substring)) {\n \
    \           ret[maxIndex] = strings[i];\n            maxIndex++;\n        }\n\
    \    }\n    ret[maxIndex] = strings[minIndex];\n    return ret;\n}", "{\n    int[]\
    \ indexes = new int[strings.length];\n    \n    for(int i = 0; i < strings.length;\
    \ i++) {\n        for(int j = 0; j < substring.length(); j++) {\n            if(strings[i].contains(substring.substring(0,\
    \ j))) {\n                indexes[i] = i;\n                break;\n          \
    \  }\n        }\n    }\n    \n    return toArray(strings[indexes]);\n}", "{\n\
    \    string[] results = new string[strings.length];\n    int i=0;\n    foreach(string=string\
    \ in strings)\n    {\n        if(string.Contains(substring))\n        {\n    \
    \        results[i++] = string;\n        }\n    }\n    return results;\n}", "{\n\
    \    var new_strings = new string[strings.length];\n    for(int i = 0; i < strings.length;\
    \ ++i)\n    {\n        if (strings[i].Contains(substring))\n        {\n      \
    \      new_strings[i] = strings[i];\n        }\n    }\n    return new_strings;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis could be improved by changing strings[i].Contains(substring)\
    \ to strings[i].IndexOf(substring, StringComparison.OrdinalIgnoreCase) >= 0\n\
    <|/ c |>\n<| c |>\nYou are right.  That is actually a much better comparison because\
    \ it doesn't need to check for case.  It also makes the code a little more readable\
    \ because it doesn't have that `if` statement and so it's more apparent where\
    \ all the conditions are being checked.\n<|/ c |>\n<| c |>\nAh, very nice!  I've\
    \ been using `Contains` and `IndexOf` as alternatives to the `foreach` construct\
    \ since `foreach` does not work in C#, unlike Python, but I hadn't considered\
    \ the case.  I've fixed it to use the `IndexOf` version, and it works much better.\
    \  Thanks for teaching me this new technique :)\n<|/ c |>\n<| c |>\nIt is not\
    \ really \"better\". It uses different data structure. First you create new array\
    \ with O(n). Then you go through that array and O(n^2). Finally you copy to another\
    \ array O(n) which is actually more complicated and less efficient. And you do\
    \ not check if substring is present in string at all. Your solution is simple\
    \ and efficient since it is O(n).\n<|/ c |>\n<| c |>\nIt's \"better\" in the sense\
    \ that it uses different data structures.  You start with an array, which you\
    \ then copy to a new array when you encounter a match.  That copy is O(n) because\
    \ you start at the beginning and copy every single character.  Your solution is\
    \ O(n^2) because you check each character in each string and copy those that match.\
    \  In your solution you have a double nested for loop, which is O(n^4).  I agree\
    \ that your solution is simpler, and more efficient, but it is not a better solution.\n\
    <|/ c |>\n<| a |>\n<code>\npublic static string GetWords(string input, string\
    \ pattern)\n{\n    Regex rgx = new Regex(pattern);\n    return rgx.Replace(input,\
    \ \"\");\n}\n</code>\n<|/ a tags=c#,string,arrays dscore=2 |>\n<| a dscore=1 tags=c#,string,arrays\
    \ |>\nThis can be done with LINQ as well:\n<code>\nstring[] result = words.Select(s\
    \ => s.Contains(\"cat", "{\n    foreach (string s in strings)\n    {\n       \
    \ if (s.contains(substring))\n        {\n            yield return s;\n       \
    \ }\n    }\n}", "{\n    List<string> result = new List<string>();\n    for(int\
    \ i = 0; i < strings.Length; i++)\n    {\n        if(strings[i].Contains(substring))\n\
    \            result.Add(strings[i]);\n    }\n    return result.ToArray();\n}\n\
    </code>\n<|/ a tags=list,arrays,c# |>\n<| a |>\nUsing LINQ:\n<code>\nvar filtered\
    \ = stringArray.Where(x => x.Contains(searchValue)).ToList();\n</code>\n<|/ a\
    \ tags=list,arrays,c# dscore=5 |>\n<| c |>\nToList() is redundant\n<|/ c |>\n\
    <| c |>\nIt depends on your implementation. If you don't need all the items then\
    \ yes it's redundant. On the other hand if you need all the items and you know\
    \ the length of the List then it's useful.\n<|/ c |>\n<| c |>\nNote that this\
    \ will return an `IEnumerable` instead of a `List`, which means it won't automatically\
    \ have all of the items in the list already in it.\n<|/ c |>\n<| c |>\nGood point.\
    \ But it also depends on if you're going to be using that list anywhere else and\
    \ if it will ever be modified.\n<|/ c |>\n<| c |>\nToList() is only necessary\
    \ if you need to enumerate the list to do further filtering and such. Removing\
    \ it means you just have access to that IEnumerable/IEnumerable<T> from your method.\n\
    <|/ c |>\n<| a tags=list,arrays,c# |>\nYou could also use Regex:\n<code>\nList<string>\
    \ list = new List<string>();\nRegex regex = new Regex(@\"^\\w*\" + search + \"\
    \\w*$\");", "{\n    int[] chars = toCharArray(strings);\n    int[] toRemove =\
    \ { -1, -1, -1, -1 };\n    \n    for(int i =0; i <strings.length; i++)\n    {\n\
    \        for(int j = 0; j < strings[i].length(); j++)\n        {\n           \
    \ if(strings[i].charAt(j) == substring.charAt(0))\n            {\n           \
    \     if(i == 0) toRemove[0] = j;\n                else if(j == 0) toRemove[1]\
    \ = i;\n                else if(j == strings[i].length() - 1) toRemove[2] = i;\n\
    \                else toRemove[3] = i;\n            }\n        }\n    }\n    \n\
    \    char[] toKeep = new char[strings.length];\n    for(int i =0; i< toRemove.length;\
    \ i++)\n    {\n        toKeep[toRemove[i]] = -1;\n    }\n    \n    return strings[toKeep];\n\
    }\n/*\n Filter an input array of strings only for ones that do not contain given\
    \ substring\n    >>> filter_by_substring([], \"b\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"b\")\n    [\"array\"]\n    \n*/\nstring[]\
    \ filter_by_not_substring(string[] strings, string substring) \n{\n    int[] chars\
    \ = toCharArray(strings);\n    int[] toRemove = { -1, -1, -1, -1 };\n    \n  \
    \  for(int i =0; i <strings.length; i++)\n    {\n        for(int j = 0; j < strings[i].length();\
    \ j++)\n        {\n            if(strings[i].charAt(j) != substring.charAt(0))\n\
    \            {\n                if(i == 0) toRemove[0] = j;\n                else\
    \ if(j == 0) toRemove[1] = i;\n                else if(j == strings[i].length()\
    \ - 1) toRemove[2] = i;\n                else toRemove[3] = i;\n            }\n\
    \        }\n    }\n    \n    char[] toKeep = new char[strings.length];\n    for(int\
    \ i =0; i< toRemove.length; i++)\n    {\n        toKeep[toRemove[i]] = -1;\n \
    \   }\n    \n    return strings[toKeep];\n}", "{\n  string[] results = new string[strings.length];\n\
    \  int i = 0;\n  int startIndex = 0;\n  while (startIndex < strings.length) \n\
    \  {\n    int currentIndex = startIndex + 1;\n    while (currentIndex < strings.length\
    \ && strings[currentIndex] == substring) \n    {\n      currentIndex++;\n    }\n\
    \    \n    if (currentIndex < strings.length)\n    {\n      results[i++] = strings[startIndex];\n\
    \      startIndex = currentIndex;\n    }\n  }\n  \n  return results;\n}\n</code>\n\
    <|/ a tags=algorithm,string,java dscore=1 |>\n<| c |>\nPlease note that this only\
    \ works when the substring is at the end of the array. When the substring was\
    \ in the middle of the array (e.g., \"a\"), this code would return \"bacd\".\n\
    <|/ c |>\n<| c |>\nYes. I was also curious about that. I'm going to fix that.\
    \ I will update this answer ASAP.\n<|/ c |>\n<| c |>\nI just realized that this\
    \ doesn't work when substring is not present at all in the strings. I.e. the substring\
    \ is `ab`. Then the code will return `[]`.\n<|/ c |>\n<| c |>\nI just fixed that\
    \ too. Check my answer now. Thank you!\n<|/ c |>\n<| a |>\nThis is similar to\
    \ the code suggested by Ashish Kumar (https://stackoverflow.com/users/514446/ashish-kumar),\
    \ but it doesn't use the 'indexOf()' method.\n<code>\nfunction findSubStr(inputStr,\
    \ subStr) {\n    var arr = inputStr.split('');\n    var newArray = [];\n    var\
    \ newSubStr;\n    var newStr;\n    for (var i = 0, len = arr.length; i < len;\
    \ i++) {\n        if (arr[i] == subStr) {\n            newSubStr = '' + arr[i];\n\
    \            newStr = '' + arr[i + 1];\n            newArray[i] = newSubStr;\n\
    \            newArray[i + 1] = newStr;\n        }\n    }\n    return newArray;\n\
    }", "{\n    var results = new List<string>();", "{\n    List<string> results =\
    \ new List<string>();\n    foreach(string s in strings)\n    {\n        if (s.Contains(substring))\n\
    \        {\n            results.Add(s);\n        }\n    }\n    return results.ToArray();\n\
    }\n</code>\nNow you can use it like this:\n<code>\nstring[] strings = new[]\n\
    \    {\n        \"abc\",\n        \"bacd\",\n        \"cde\",\n        \"array\"\
    ,\n        \"asdf\",\n        \"bacd\",\n        \"asdf\",\n        \"cde\",\n\
    \        \"asdf\",\n    };", "{\n    string[] result = new string[strings.length];\n\
    \    for(int i = 0; i < strings.length; ++i)\n    {\n        if(strings[i].Contains(substring))\n\
    \            result[i] = strings[i];\n    }\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nI think you should use LINQ for this, not for searching\
    \ but to filter the array.\n<code>\npublic string[] filter_by_substring(string[]\
    \ strings, string substring) {\n    return strings.Where(s => s.Contains(substring)).ToArray();\n\
    }\n</code>\n<|/ a tags=arrays,c#,substring,search |>\n<| c |>\nUsing LINQ for\
    \ this seems like a bad idea - `Contains` will have to loop through every string\
    \ in the array, and that will get unmanageable if the array is long.\n<|/ c |>\n\
    <| c |>\nYes, but this is the way to go, if you don't want to use RegEx, which\
    \ is better for this.\n<|/ c |>\n<| c |>\n`Contains` does loop through the whole\
    \ array. Or at least it will loop through it until it finds the needle - `Array.IndexOf`\
    \ will stop searching once it finds the needle.\n<|/ c |>\n<| c |>\nI mean `Contains`\
    \ has to loop through the entire array to check if any string contains the needle\n\
    <|/ c |>\n<| c |>\nYes, it does. I guess I should have been clearer with my comment.\
    \ `Array.IndexOf` does it by looping through the whole array, but it's still better\
    \ than LINQ, and you don't have to worry about getting stuck in an infinite loop\
    \ or getting an `OutOfMemoryException`.\n<|/ c |>\n<| a dscore=0 |>\nI wrote a\
    \ method with RegEx that works for me:\n<code>\nstatic string[] FilterBySubstring(string[]\
    \ values, string substring)\n{\n    Regex regex = new Regex(substring, RegexOptions.IgnoreCase);\n\
    \    return values.Where(x => regex.IsMatch(x)).ToArray();\n}\n</code>\n<|/ a\
    \ tags=arrays,c#,substring,search |>\n<| a dscore=0 |>\nMy solution is very similar\
    \ to others, however, I thought I would post it anyway, in case someone else is\
    \ looking for the same solution in Java. \n<code>\npublic String[] filterBySubstring(String[]\
    \ strings, String substring) {\n    List<String> stringList = new ArrayList<String>();\n\
    \    for (String string : strings) {\n        if (string.contains(substring))\
    \ {\n            stringList.add(string);\n        }\n    }\n    String[] stringArray\
    \ = stringList.toArray(new ", "{\n    // TODO: Implement me!\n    throw new UnsupportedOperationException(\"\
    Not implemented yet.\"); //To change body of generated methods, choose Tools |\
    \ Templates.\n}\n</code>\n<|/ a tags=string,python dscore=1 |>\n<| c |>\nIt works\
    \ but doesn't solve my problem. For example, `filter_by_substring([\"abc\", \"\
    bacd\", \"cde\", \"array\"], \"a\")` would return `[\"abc\"]` since it contains\
    \ `a` twice. I'm looking to only return strings that are unique in the array.\
    \ Thanks though.\n<|/ c |>\n<| c |>\n: You want to return any string that occurs\
    \ only once?\n<|/ c |>\n<| c |>\nYes, that is correct.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\ndef filter_by_substring(strings, substring):\n    strings_set =\
    \ set(strings)\n    for string in strings:\n        if substring in strings_set:\n\
    \            strings_set.remove(substring)\n    return list(strings_set)\n</code>\n\
    <|/ a tags=string,python |>\n<| a |>\nThis problem can be solved with a set data\
    \ structure, with the advantage that it has O(1) access time which can be useful\
    \ for filtering and sorting. \nThe code below creates the output you want.\n<code>\n\
    def filter_by_substring(strings, substring):\n    seen = set()\n    return [string\
    \ for string in strings if substring not in seen and seen.add(string)]", "{\n\
    \    List<string> ret = new List<string>();\n    \n    for (int i = 0; i < strings.Length;\
    \ i++)\n    {\n        if (strings[i].Contains(substring))\n        {\n      \
    \      ret.add(strings[i]);\n        }\n    }\n    return ret.ToArray();\n}\n\
    /*\n Filter an input array of strings only for those that begin with a given substring\n\
    \    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    []\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    List<string> ret = new List<string>();\n\
    \    \n    for (int i = 0; i < strings.Length; i++)\n    {\n        if (strings[i].StartsWith(substring))\n\
    \        {\n            ret.add(strings[i]);\n        }\n    }\n    return ret.ToArray();\n\
    }\n/*\n Filter an input array of strings only for those that end with a given\
    \ substring\n    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"array\"]\n    \n*/\nstring[]\
    \ filter_by_substring(string[] strings, string substring) \n{\n    List<string>\
    \ ret = new List<string>();\n    \n    for (int i = 0; i < strings.Length; i++)\n\
    \    {\n        if (strings[i].EndsWith(substring))\n        {\n            ret.add(strings[i]);\n\
    \        }\n    }\n    return ret.ToArray();\n}\n/*\n Filter an input array of\
    \ strings only for those that match a regular expression\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    List<string> ret = new List<string>();\n\
    \    \n    for (int i = 0; i < strings.Length; i++)\n    {\n        if (strings[i].Match(RegExp(substring)))\n\
    \        {\n            ret.add(strings[i]);\n        }\n    }\n    return ret.ToArray();\n\
    }\n/*\n Split an input array of strings into a smaller array by each string in\
    \ the input array \n    >>> split_by_substring([], \"a\")\n    []\n    >>> split_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"cde\"\
    , \"array\"]\n    \n*/\nstring[] split_by_substring(string[] strings, string substring)\
    \ \n{\n    List<string> ret = new List<string>();\n    \n    for (int i = 0; i\
    \ < strings.Length; i++)\n    {\n        string[] tmp = split_by_substring(strings[i].ToLower(),\
    \ substring);\n        \n        if (tmp.Length > 0)\n        {\n            foreach\
    \ (", "{\n   List<string> filtered = new List<string>();\n   for (int i = 0; i\
    \ < strings.Length; ++i)\n      if (strings[i].Contains(substring))\n        \
    \ filtered.Add(strings[i]);\n   return filtered.ToArray();\n}\n</code>\n<|/ a\
    \ tags=c#,linq,string |>\n<| a dscore=1 tags=c#,linq,string |>\nYou can use regex\
    \ as well.\n<code>\nstatic string[] filterBySubstring(string[] strings, string\
    \ substring)\n{\n    return strings.Where(s => Regex.IsMatch(s, \"(?i)\" + substring)).ToArray();\n\
    }\n</code>\n<|/ a |>\n<| c |>\nIt will be a little slow with larger arrays\n<|/\
    \ c |>\n<| c |>\nI tested with strings with 20000 elements before saying that\
    \ it was slow and that my approach was unusable :)\n<|/ c |>\n<| a |>\nMy answer\
    \ would be to use the extension method ToLookup from Linq, which is available\
    \ in any C# version. Since your input array is sorted, you can use the overload\
    \ of ToLookup which accepts a predicate to do the searching:\n<code>\nprivate\
    \ static string[] filterBySubstring(string[] strings, string substring)\n{\n \
    \   return strings.Where(s => s.ToLookup(c => c).Any(c => c[1] != substring)).ToArray();\n\
    }\n</code>\nThis approach should perform pretty well, since ToLookup does not\
    \ actually store the input array in memory but rather builds a hash table that\
    \ you can use to quickly check whether a character is contained in the input string.\n\
    <|/ a tags=c#,linq,string dscore=1 |>\n<| c |>\nIt will be a little slow with\
    \ larger arrays\n<|/ c |>\n<| c |>\nYeah, I did say \"probably\" :)\n<|/ c |>\n\
    <| a dscore=1 |>\nAnother approach - not necessarily faster - would be to sort\
    \ the input array alphabetically and then do the search:\n<code>\nprivate static\
    \ string[] filterBySubstring(string[] strings, string substring)\n{\n    var sortedStrings\
    \ = strings.OrderBy(s => s);", "{\n    string[] result = new string[strings.length];\n\
    \    int i = 0;\n    for (int j = 0; j < strings.length; j++) {\n        if (strings[i].Contains(substring))\n\
    \            result[i++] = strings[j];\n    }\n    return result;\n}", "{\n  \
    \  foreach (string s in strings) {\n        if (s.Contains(substring)) {\n   \
    \         yield return s;\n        }\n    }\n}", "{\n    string[] result = new\
    \ string[strings.length];\n    for(int i = 0; i < strings.length; i++){\n    \
    \    if (strings[i].Contains(substring)){\n            result[i] = strings[i];\n\
    \        }\n    }\n    return result;\n}", "{\n\tList<string> output = new List<string>();\n\
    \tfor (int i = 0; i < strings.Length; i++)\n\t{\n\t\tif (strings[i].Contains(substring))\n\
    \t\t\toutput.Add(strings[i]);\n\t}\n\treturn output.ToArray();\n}", "{\n\tstring[]\
    \ res = new string[strings.length];\n\tfor(int i = 0; i < strings.length; i++)\n\
    \t{\n\t\tif(!strings[i].contains(substring))\n\t\t{\n\t\t\tres[i] = strings[i];\n\
    \t\t}\n\t}\n\treturn res;\n}", "{\n\tstring[] results = new string[strings.length];\n\
    \tfor(int i = 0; i < strings.length; ++i)\n\t{\n\t\tif(strings[i].indexOf(substring)\
    \ != -1)\n\t\t\tresults[i] = strings[i];\n\t}\n\treturn results;\n}", "{\n   \
    \ string[] result = new string[strings.length];\n    for(int i = 0; i < strings.length;\
    \ ++i)\n    {\n        string s = strings[i];\n        if(s.Contains(substring))\n\
    \        {\n            result[i] = s;\n        }\n    }\n    return result;\n\
    }", "{\n    string[] result = new string[strings.length];\n    for (int i=0; i\
    \ < strings.length; i++)\n    {\n        if (strings[i].contains(substring))\n\
    \        {\n            result[i] = strings[i];\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a |>\n<| c |>\nThank you. I will try it out and get\
    \ back to you about it.\n<|/ c |>\n<| c |>\nIt would be nice to see some explanation\
    \ of what it is that makes this answer better than just \"try it\".\n<|/ c |>\n\
    <| c |>\nIt is a bit tricky, because it assumes that the function will be called\
    \ with the string in argument and it is also the case that it is called with the\
    \ string in position 0 and it will return a new string with the content of the\
    \ string. Of course the string in position 0 is used to fill the new string and\
    \ it will be the string in argument for the first time the function is called.\n\
    <|/ c |>\n<| c |>\nIt also assumes that the function will not have side effects.\
    \ If I understand the requirements, this is actually the best way to do it IMHO.\n\
    <|/ c |>\n<| c |>\nThe first part \"filter an input array of strings only for\
    \ ones that contain given substring\" is not entirely correct. It will return\
    \ an empty array if substring is not contained anywhere in any of the strings.\
    \ You would need to change it like so: `filter_by_substring([ \"a\", \"b\", \"\
    c\", \"d\"], \"a\")` => `[ \"a\" ]`\n<|/ c |>\n<| a |>\nHere is a simple one-liner\
    \ that does this.\n<code>\npublic static string[] filterBySubstring(string[] stringsToFilter,\
    \ string substring)\n{\n    return stringsToFilter.Where((s) => s.Contains(substring)).ToArray();\n\
    }\n</code>\nIt will return an array of substrings that contain the search string\
    \ as a sub-string. If, for instance, the array's contents are [ \"a\", \"b\",\
    \ \"c\", \"d\", \"e\", \"f\", \"g\", \"h\" ] and you search for \"a\", then it\
    \ will return an array of [ \"a\", \"b\", \"c\" ].\n<|/ a dscore=2 tags=arrays,c#,string,algorithm\
    \ |>\n<| a tags=arrays,c#,string,algorithm |>\n<code>\nstring[] filterBySubstring\
    \ = new string[4];\nfilterBySubstring[0] = \"a\";\nfilterBySubstring[1] = \"b\"\
    ;\nfilterBySubstring[2] = \"c\";\nfilterBySubstring[3] = \"d\";\nfilterBySubstring[4]\
    \ = \"e\";\nfilterBySubstring[5] = \"f\";\nfilterBySubstring[6] = \"g\";", "{\n\
    \    List<string> result = new List<string>();\n    foreach(string s in strings)\n\
    \    {\n        if(s.Contains(substring))\n        {\n            result.Add(s);\n\
    \        }\n    }\n    return result.ToArray();\n}\n</code>\n<|/ a tags=c# |>\n\
    <| a tags=c# |>\n<code>\n    public static string[] GetFileNames(string directoryPath,\
    \ string pattern)\n    {\n        string fullPath = Path.Combine(directoryPath,\
    \ pattern);\n        DirectoryInfo di = new DirectoryInfo(fullPath);\n       \
    \ FileInfo[] files = di.GetFiles();", "{\n    var result = [];\n    foreach (string\
    \ s in strings)\n        if (s.indexOf(substring) >= 0)\n            result.push(s);\n\
    \    return result;\n}", "{\n    // Your code here!\n    string[] results = new\
    \ string[strings.length];\n    for (int i = 0; i < strings.length; i++) {\n  \
    \      if (strings[i].Contains(substring)) {\n            results[i] = strings[i];\n\
    \        }\n    }\n    return results;\n}\n/*\n Count the number of times a character\
    \ appears in an input string\n    >>> count(\"ab\", \"b\")\n    1\n    >>> count(\"\
    ab\", \"a\")\n    0\n    \n*/", "{\n    string[] result = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; ++i) {\n        if (strings[i].contains(substring))\
    \ {\n            result[i] = strings[i];\n        }\n    }\n    return result;\n\
    }\n</code>\nYou can now do \n<code>\n/*\n Filter an input array of strings only\
    \ for ones that contain given substring\n    >>> filter_by_substring([], \"a\"\
    )\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; ++i) {\n        if (strings[i].contains(substring))\
    \ {\n            result[i] = strings[i];\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nBut `string` class does not have `contains`\
    \ method. So this wont compile.\n<|/ c |>\n<| c |>\n`string` class DOES have `contains`\
    \ method. Try `string[] result = new string[strings.length]; for (int i = 0; i\
    \ < strings.length; ++i) { if (strings[i].contains(substring)) { result[i] = strings[i];\
    \ } }`\n<|/ c |>\n<| c |>\n- yes, you are right, I missed the import in the OP's\
    \ code.  I updated the answer to use the full `string` class.  Thanks.\n<|/ c\
    \ |>\n<| c |>\nBut it also won't work. You need to use `contains(...)` not `find(...)`.\n\
    <|/ c |>\n<| c |>\n: yes, sorry, I missed that when I was writing the answer ...\
    \ and I should have double checked the documentation to make sure the `contains()`\
    \ method was available.  Thanks for pointing it out.\n<|/ c |>\n<| a dscore=1\
    \ |>\nTo extend Erik Siegfried's answer, you can make a method which takes a string\
    \ and a list of strings and returns the strings which contain each of the strings\
    \ in the list passed in as a parameter.\nI haven't used Dart's syntax much, but\
    \ here's my attempt:\n<code>\nclass StringUtils {\n  static List<String> containsInList(List<String>\
    \ list, String string) {\n    List<String> result = new List<String>();\n    for\
    \ (String s : list) {\n      if (string.contains(s)) {\n        result.add(s);\n\
    \      }\n    }\n    return result;\n  }\n}\n</code>\nIn Dart, you can call this\
    \ like so:\n<code>\nList<String> strings = [\n  \"apple\",\n  \"banana\",\n  \"\
    cat\",\n  \"dog\",\n  \"fish\"\n", "{\n    List<string> matchingList = new List<string>();\n\
    \    foreach(string s in strings)\n        if(s.Contains(substring))\n       \
    \     matchingList.Add(s);\n    return matchingList.ToArray();\n}\n/*\n Filter\
    \ an input array of strings only for ones that match a given regex\n    >>> filter_by_regex([],\
    \ \"\\\\w+\")\n    []\n    >>> filter_by_regex(\n    ...     [\"abc def\", \"\
    abc def\", \"bcd\", \"cde\"],\n    ...    \"abc def\"\n    ... )\n    [\"abc def\"\
    ]\n    \n*/\nstring[] filter_by_regex(string[] strings, string regex) \n{\n  \
    \  List<string> matchingList = new List<string>();\n    foreach(string s in strings)\n\
    \        if(Regex.IsMatch(s, regex))\n            matchingList.Add(s);\n    return\
    \ matchingList.ToArray();\n}\n/*\n Filter an input array of strings only for ones\
    \ that match a specific pattern\n    >>> filter_by_regex([], \"^[abc]+$\") =>\
    \ [\"abc\"]\n    >>> filter_by_regex(\n    ...    [\"abc def\", \"abc def\", \"\
    bcd\", \"cde\"],\n    ...    \"^[abc]+$\"\n    ... )\n    [\"abc def\", \"abc\
    \ def\"]\n    \n*/\nstring[] filter_by_regex(string[] strings, string pattern,\
    \ RegexOptions options = RegexOptions.None) \n{\n    List<string> matchingList\
    \ = new List<string>();\n    foreach(string s in strings)\n        if(Regex.IsMatch(s,\
    \ pattern, options))\n            matchingList.Add(s);\n    return matchingList.ToArray();\n\
    }\n/*\n Filter an input array of strings only for ones that match a specific pattern\
    \ with options\n    >>> filter_by_regex([], \"^[abc]+$\", \"IgnoreCase\") => [\"\
    abc\", \"abc \"]\n    >>> filter_by_regex(\n    ...    [\"abc def\", \"abc def\"\
    , \"bcd\", \"cde\"],\n    ...    \"^[abc]+$\",\n    ...    RegexOptions.IgnoreCase\n\
    \    ... )\n    [\"abc\", \"abc \"]\n    \n*/\nstring[] filter_by_regex(string[]\
    \ strings, string pattern, RegexOptions options, int count = 0) \n{\n    List<string>\
    \ matchingList = new List<string>();\n    foreach(string s in strings)\n     \
    \   if(Regex.IsMatch(s, pattern, options, count))\n            matchingList.Add(s);\n\
    \    return matchingList.ToArray();\n}\n/*\n Filter an input array of strings\
    \ only for ones that match a specific pattern with options and count\n    >>>\
    \ filter_by_regex([], \"^[abc]+$\", \"IgnoreCase\", ", "{\n\tstring[] res = new\
    \ string[strings.length];\n\tfor (int i = 0; i < strings.length; ++i)\n\t{\n\t\
    \tif (strings[i].Contains(substring))\n\t\t{\n\t\t\tres[i] = strings[i];\n\t\t\
    }\n\t}\n\treturn res;\n}\n/*\n Split a comma-separated list of strings into an\
    \ array\n \n TODO: Write unit tests for these\n*/\nstring[] split_list_string(string\
    \ s) \n{\n\tstring[] string_list = new string[s.Length];\n\tfor (int i = 0; i\
    \ < s.Length; ++i)\n\t{\n\t\tif (s[i] != ',')\n\t\t{\n\t\t\tstring_list[i] = s[i];\n\
    \t\t}\n\t}\n\treturn string_list;\n}\n/*\n Combine an array of strings together\
    \ with given string\n \n TODO: Write unit tests for these\n*/\nstring join_list_string(string[]\
    \ strings, string separator) \n{\n\tstring res = \"\";\n\tfor (int i = 0; i <\
    \ strings.Length; ++i)\n\t{\n\t\tif (i > 0)\n\t\t{\n\t\t\tres += separator;\n\t\
    \t}\n\t\tres += strings[i];\n\t}\n\treturn res;\n}\n/*\n Get a random integer\
    \ between min (inclusive) and max (inclusive)\n \n TODO: Write unit tests for\
    \ these\n*/", "{\n    var result = new string[strings.length];\n    for (int i\
    \ = 0; i < strings.length; i++) \n    {\n        if (strings[i].indexOf(substring)\
    \ > -1) \n        {\n            result[i] = strings[i];\n        }\n    }\n \
    \   return result;\n}", "{\n    foreach (string s in strings) {\n        if (s.contains(substring))\n\
    \            yield return s;\n    }\n}", "{\n\tstring[] result = [];\n\tforeach\
    \ (string s in strings) \n\tif (s.indexOf(substring) != -1) \n\t\tresult.add(s);\n\
    \treturn result;\n}", "{\n\tstring[] result = new string[strings.length];\n\t\
    for (int i = 0; i < strings.length; i++)\n\t{\n\t\tif (strings[i].contains(substring))\n\
    \t\t\tresult[i] = strings[i];\n\t}\n\treturn result;\n}", "{\n    string[] results\
    \ = new string[strings.length];\n    for(int i = 0; i < strings.length; ++i)\n\
    \    {\n        string s = strings[i];\n        int start = s.indexOf(substring);\n\
    \        if(start == -1) { results[i] = s; }\n        else { results[i] = s.substring(0,\
    \ start); }\n    }\n    return results;\n}", "{\n  int i = 0;\n  int j = 0;\n\
    \  int n = strings.length;\n  int k = 0;", "{\n    string[] result = new string[strings.length];\n\
    \    int j = 0;\n    foreach (string s in strings) {\n        if (s.IndexOf(substring,\
    \ StringComparison.OrdinalIgnoreCase) >= 0)\n            result[j++] = s;\n  \
    \  }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=0 |>\nI'm\
    \ a beginner, but I'll do my best to help you out with this.\nI find it easiest\
    \ to store each line in an array.  So if I were doing this in python, I would:",
  "{\n  var result = new string[strings.length];\n  var index = 0;\n  foreach (var\
    \ s in strings)\n    if (s.Contains(substring))\n      result[index++] = s;\n\
    \  return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYour function has quadratic\
    \ complexity. `Contains` has linear complexity and should be avoided.\n<|/ c |>\n\
    <| c |>\n, i added a linear solution at the end that should be faster.\n<|/ c\
    \ |>\n<| c |>\nThe solution you added is actually quadratic, which is worse than\
    \ the quadratic solution in the other answer (though it could maybe be improved\
    \ further by using `indexOf` instead of `Contains` because `indexOf` has a linear\
    \ time complexity too).\n<|/ c |>\n<| c |>\n, yes, it does have a linear time\
    \ complexity as well. I only added the linear solution because it was asked for\
    \ in the question and I thought that it would be nice to have it at the end of\
    \ a longer one. That's why I didn't add it in the second half of the answer. :)\n\
    <|/ c |>\n<| c |>\nThank you, it is really helpful and fast to read and understand.\n\
    <|/ c |>\n<| a dscore=0 |>\nYou can use Regex for this:\n<code>\nstring input\
    \ = \"This is a test of a string that contains the word 'a'.\";\nstring pattern\
    \ = \"a\";\nstring output = Regex.Replace(input, pattern, \"<b>$&</b>\");\n</code>\n\
    This gives:\n<code>\nThis is a test of a string that contains the word <b>a</b>.\n\
    </code>\nTo make it work for multiple strings, just replace the pattern variable\
    \ with something like this:\n<code>\nstring pattern = \"(\" + String.Join(\"|\"\
    , new string[] { \"a\", \"b\" }) + \")\";\n</code>\n<|/ a tags=c# |>\n<| c |>\n\
    This would replace all \"a\" in that string. This is the opposite of what was\
    \ asked.\n<|/ c |>\n<| c |>\nI thought that he only wanted to replace the first\
    \ occurrence of \"a\", so I used Regex.Replace. Now I see that he wants to replace\
    \ all occurrences. He can use Regex.Replace, that he can use regex.Replace to\
    \ replace, that he can use regex.Replace to replace.\n<|/ c |>\n<| c |>\nThat\
    \ was my point. Your function would replace all occurrences of \"a\" in the input\
    \ string where that was not the intended behaviour.\n<|/ c |>\n<| c |>\nI know,\
    \ but he also want", "{\n    if (strings == null || strings.length == 0) \n  \
    \      return strings;\n    else if (substring.Length == 0) \n        return strings;",
  "{\n\tstring[] result = new string[strings.length];\n\tfor (int i = 0; i < strings.length;\
    \ ++i)\n\t{\n\t\tstring str = strings[i];\n\t\tif (str.contains(substring))\n\t\
    \t\tresult[i] = str;\n\t}\n\t\n\treturn result;\n}", "{\n    \n    foreach(var\
    \ s in strings)\n        if(s.indexOf(substring) > -1)\n            strings.remove(s);\n\
    \    \n    return strings;\n    \n}\n/*\n Filter an input array of strings only\
    \ for ones that contain a given substring\n    >>> filter_by_substring([], \"\
    abc\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"bac\")\n    [\"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring, bool caseSensitive) \n{\n    \n    if(!caseSensitive)\n\
    \        strings = strings.toLowerInvariant();\n    \n    foreach(var s in strings)\n\
    \        if(s.indexOf(substring) > -1)\n            strings.remove(s);\n    \n\
    \    return strings;\n    \n}\n/*\n Filters the strings from an array of strings\
    \ so that only strings with one given substring in it are left in the output array.\n\
    \    >>> filter_by_substring([\"bacd\", \"array\", \"string\"], \"bac\")\n   \
    \ [\"bacd\"]\n    \n*/\nstring[] filter_by_substring(string[] strings, string[]\
    \ substrings) \n{\n    \n    foreach(var s in strings)\n        if(!contains(substrings,\
    \ s, false))\n            strings.remove(s);\n    \n    return strings;\n    \n\
    }\n/*\n Filters the strings from an array of strings so that only strings with\
    \ one given substring in it are left in the output array.\n    When caseSensitive\
    \ is true all strings are lower-cased.\n    >>> filter_by_substring([\"bacd\"\
    , \"array\", \"string\"], \"BAC\", true)\n    [\"bacd\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring, bool caseSensitive) \n{\n    \n    if(!caseSensitive)\n\
    \        strings = strings.toLowerInvariant();\n    \n    foreach(var s in strings)\n\
    \        if(s.indexOf(substring) > -1)\n            strings.remove(s);\n    \n\
    \    return strings;\n    \n}\n/*\n Filters the strings from an array of strings\
    \ so that only strings with one given substring in it are left in the output array.\n\
    \    When caseSensitive is true all strings are lower-cased.\n    >>> filter_by_substring([\"\
    bacd\", \"array\", \"string\"], \"BAC\", true)\n    [\"bacd\"]\n    \n*/\nstring[]\
    \ filter_by_substring(string[] strings, string[] substrings, bool caseSensitive)\
    \ \n{\n    \n    foreach(var s in strings)\n        if(!contains(substrings, s,\
    \ caseSensitive))\n            strings.remove(s);\n    \n    return strings;",
  "{\n    var result = new string[strings.length];\n    var i = 0;\n    for(i=0; i<strings.length;\
    \ i++)\n    {\n        if(strings[i].Contains(substring))\n        {\n       \
    \     result[i] = strings[i];\n        }\n    }\n    return result;\n}", "{\n\
    \    for(int i = 0; i < strings.length; i++)\n    {\n        if(strings[i].Contains(substring))\n\
    \        {\n            strings[i] = strings[i].Replace(substring, \"\");\n  \
    \      }\n    }\n    return strings;\n}", "{\n\treturn strings.Where(s => s.Contains(substring)).ToArray();\n\
    }", "{\n    int i;\n    \n    for(i = 0; i < strings.length; i++)\n    {\n   \
    \     if(strings[i].Contains(substring))\n        {\n            string toReturn\
    \ = strings[i];\n            \n            int startIndex = strings[i].IndexOf(substring);\n\
    \            int endIndex = startIndex + substring.Length;\n            \n   \
    \         toReturn.Remove(startIndex, endIndex - startIndex);\n            \n\
    \            strings[i] = toReturn;\n        }\n    }\n    \n    return strings;\n\
    }\n/*\n Convert an array to an array of structs\n    >>> to_struct([1,2,3,4])\n\
    \    [[1, 2, 3], [4]]\n*/\nIList< IList< T > > to_struct(T[][] items)\n{\n   \
    \ IList< IList< T > > result = new List<List<T>>();\n    \n    foreach(var item\
    \ in items)\n    {\n        result.Add(new List<T>(item));\n    }\n    \n    return\
    \ result;\n}\n</code>\n<|/ a |>\n<| c |>\nYour code is correct, I just want to\
    \ ask you if you can make it shorter. thanks.\n<|/ c |>\n<| c |>\nThank you for\
    \ your answer. Your code is correct, but I want to ask you if you can make it\
    \ shorter. I just want to use LINQ to do the same thing.\n<|/ c |>\n<| c |>\n\
    Sorry I don't know LINQ. I just know vb.net so it's hard to understand your question.\
    \ Maybe I can help you.\n<|/ c |>\n<| a tags=c#,linq,string |>\n<code>\n     \
    \   var input = new string[][] {\n            new string[] { \"abc\", \"bacd\"\
    , \"cde\", \"array\" }, \n            new string[] { \"aas\", \"aad\", \"ads\"\
    \ },\n            new string[] { \"abc\", \"cde\" },\n            new string[]\
    \ { \"abcc\", \"cde\", \"bbcc\", \"ccc\" },\n            new string[] { \"aas\"\
    , \"aad\", \"ads\", \"aadas\", \"adas\" }\n        };", "{\n    return strings.select_if(s\
    \ => s.contains(substring)).toArray();\n}\n</code>\n<|/ a tags=java,c#,linq,functional-programming,scala\
    \ dscore=2 |>\n<| a tags=java,c#,linq,functional-programming,scala |>\nHere's\
    \ a solution that does it all in one expression.  It also handles cases where\
    \ you have partial matches on any of the string parts.\n<code>\nstring[] filter_strings(string[]\
    \ strings, string substring)\n{\n    var matched = new bool[strings.length];\n\
    \    var matches = new string[strings.length];", "{\n    List<string> result =\
    \ new List<string>();\n    for (string str : strings) {\n        if (str.IndexOf(substring,\
    \ StringComparison.OrdinalIgnoreCase) != -1)\n            result.Add(str);\n \
    \   }\n    return result.ToArray();\n}\n</code>\n<|/ a tags=c#,string,contains,linq\
    \ |>\n<| c |>\nThanks this is very helpful. One question though, this only seems\
    \ to return the first character of the search string correct?\n<|/ c |>\n<| a\
    \ dscore=0 tags=c#,string,contains,linq |>\nIf you want to do this with LINQ,\
    \ you could use\n<code>\nvar result = \n    array.Where(x => x.Contains(searchString)).ToArray();\n\
    </code>\nBut this will not do a case-insensitive comparison. Since LINQ isn't\
    \ going to give you the exact number of results you want with the Contains function.\
    \ You could either create a custom extension to make this case-insensitive and\
    \ do a string compare with the Contains function.\n<code>\npublic static bool\
    \ ContainsCaseInsensitive(this string source, string value)\n{\n    return source.IndexOf(value,\
    \ StringComparison.OrdinalIgnoreCase) >= 0;\n}\n</code>\nThen you could use this\
    \ extension function like this:\n<code>\nvar result = \n    array.Where(x => x.ContainsCaseInsensitive(searchString)).ToArray();\n\
    </code>\nOr you could do something like this:\n<code>\nvar result = \n    array.Where(x\
    \ => x.Contains(searchString) || x.ToLower() == searchString.ToLower()).ToArray();\n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\nTo solve your problem of getting the exact\
    \ count of strings that contains another string, you can use this:\n<code>\nvar\
    \ stringArray = new[] {\"abc\",\"bacd\",\"cde\",\"array\"};\nstring[] test = new\
    \ string[] { \"a\" };", "{\n    if (strings == null || strings.length == 0)\n\
    \        return strings;\n    int pos = 0;\n    string[] result = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; i++) {\n        if (strings[i].contains(substring))\
    \ {\n            result[pos++] = strings[i];\n        }\n    }\n    return std.array.sort(result);\n\
    }", "{\n\tstring[] res = [strings];\n\tfor (int i = 0; i < res.length; ++i)\n\t\
    {\n\t\tstring s = res[i];\n\t\tfor (int j = 0; j < s.length(); ++j)\n\t\t{\n\t\
    \t\tif (s.find(substring, j) == j)\n\t\t\t\tres[i] = s.substr(0, j) + s.substring(j\
    \ + substring.Length());\n\t\t}\n\t}\n\treturn res;\n}\n/*\n Remove duplicates\
    \ from an input array of strings\n    >>> remove_duplicates([\"abc\", \"bacd\"\
    , \"array\"])\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] remove_duplicates(string[]\
    \ strings)\n{\n\tHashSet<string> stringSet = new HashSet<string>(strings);\n\t\
    string[] res = [stringSet.ToArray()];\n\treturn res;\n}", "{\n    string[] rs\
    \ = new string[strings.length];\n    int i = 0;\n    int j = 0;\n    while (i\
    \ < strings.length && j < substring.length) \n    {\n        if (strings[i].Contains(substring[j])\
    \ && j == substring.length - 1) \n        {\n            rs[j++] = strings[i];\n\
    \        }\n        i++;\n        j = 0;\n    }\n    return rs;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\n<code>\nusing System;", "{\n  // This code will compile\
    \ to about 30 instructions\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int l\
    \ = 0;\n  \n  // Keep going until we have done all the strings.\n  while (i <\
    \ strings.length)\n  {\n    // If the string doesn't contain the substring then\
    \ we skip it.\n    if (!contains(strings[i], substring))\n    {\n      i++;\n\
    \      continue;\n    }", "{\n    List<string> filtered = new List<string>();\n\
    \    \n    for (string s : strings) \n    {\n        if (s.Contains(substring))\
    \ filtered.Add(s);\n    }\n    \n    return filtered.ToArray();\n}", "{\n    //\
    \ Your code here\n    if (strings == null || strings.length == 0)\n        return\
    \ strings;\n    if (substring == null)\n        throw new RuntimeException(\"\
    No substring\");\n    \n    string[] res = new string[strings.length];\n    for\
    \ (int i = 0; i < res.length; i++)\n    {\n        if (strings[i].contains(substring))\n\
    \        {\n            res[i] = strings[i];\n        }\n    }\n    return res;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,arrays,filtering,java,substring\
    \ |>\nHere is my solution to this.\n<code>\n/**\n * Method to search a string\
    \ array for substrings\n * \n * searchString - string that needs to be found\n\
    \ * searchStringArray\n *\n */\npublic static String[] searchStringArray(String\
    \ searchString, String[] searchStringArray) {\n    String[] result = new String[searchStringArray.length];",
  "{\n    string[] results = strings;\n    foreach (string s in strings)\n    {\n\
    \        if (s.Contains(substring))\n        {\n            results.Remove(s);\n\
    \        }\n    }\n    return results;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ Steve, this is very helpful.  I've edited the question to reflect the code I'm\
    \ using.\n<|/ c |>\n<| c |>\n: I updated my answer with an example of how you\
    \ can solve this.\n<|/ c |>\n<| c |>\n: By the way, if you want to see my code\
    \ working in C# see my GitHub repo on GitHub and click the \"Fork\" button on\
    \ top to fork it into your own GitHub repo.\n<|/ c |>\n<| c |>\n: I'm glad I could\
    \ help! Since you're new to Stack Overflow, I'll recommend that you check out\
    \ [this great article](http://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work)\
    \ about accepting answers so you get the credit. Thanks again for asking your\
    \ first question! :)\n<|/ c |>\n<| a tags=algorithm,c#,search,string dscore=1\
    \ |>\n<code>\nstring[] splits = input.Split(' ');\nforeach (string s in splits)\n\
    {\n    if (s.Contains(substring))\n    {\n         //...\n    }\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThanks Eric, but how do I get the original input back from\
    \ this?\n<|/ c |>\n<| c |>\nIf it is the whole input, just use `splits` again,\
    \ if it is one word, use `splits[0]` again, and so on...\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\nvar str = \"this is my string to be searched for\";\nvar searchFor\
    \ = \"s\";\nvar words = str.Split(' ');", "{\n    int strings_size = strings.length;\n\
    \    int substring_size = substring.length;\n    int i;\n    \n    string[] filtered_strings\
    \ = new string[strings_size];\n    for(i = 0; i < strings_size; i++) {\n     \
    \   if(strings[i].contains(substring)) {\n            filtered_strings[i] = strings[i];\n\
    \        }\n    }\n    return filtered_strings;\n}\n</code>\n<|/ a tags=algorithm,string,java\
    \ dscore=1 |>\n<| a dscore=1 |>\nMy solution:\n<code>\n    public List<String>\
    \ filterStrings(String[] strings, String substring) {\n    List<String> result\
    \ = new ArrayList<>();\n    \n    for (String string : strings) {\n        if\
    \ (string.length() <= substring.size() || !string.regionMatches(true, 0, substring,\
    \ 0, substring.size())) {\n            continue;\n        }\n        \n      \
    \  if (string.contains(substring)) {\n            result.add(string);\n      \
    \  }\n    }\n    \n    return result;\n}\n</code>\n<|/ a tags=algorithm,string,java\
    \ |>\n<| a dscore=0 tags=algorithm,string,java |>\n<code>\npublic class FilterStrings\
    \ {\n    public static void main(String[] args) {\n        String input = \"hello\
    \ world hello world hello\";\n        String filter = \"l\";", "{\n    int index\
    \ = 0;\n    while(index < strings.length)\n    {\n        if(strings[index].Contains(substring))\n\
    \        {\n            return strings[index];\n        }\n        index++;\n\
    \    }\n    return strings;\n}\n</code>\n<|/ a |>\n<| c |>\nI love the use of\
    \ the `SubString` extension method - thanks for sharing!\n<|/ c |>\n<| a dscore=2\
    \ tags=c#,linq,.net,algorithm |>\nI know this thread is old, but for anyone else\
    \ finding this thread, I had a need for a solution to this so I came up with one\
    \ myself. I used the following extension methods to get what I needed:\n<code>\n\
    public static class StringExtensions\n{\n    public static string Substring(this\
    \ string s, int index)\n    {\n        return s.Substring(index, Math.Min(s.Length\
    \ - index, index));\n    }", "{\n    for(int i = 0; i< strings.length; i++)\n\
    \    {\n        if(strings[i].indexOf(substring) != -1)\n        {\n         \
    \   strings[i] = strings[i].substring(substring.length());\n        }\n    }\n\
    \    return strings;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,c# |>\n\
    <code>\nstring stringToFilter = ...\nstring filter = ...\nstring[] toFilter =\
    \ stringToFilter.Split(new[] {filter}, StringSplitOptions.None);\n</code>\n<|/\
    \ a dscore=0 |>\n<| a |>\nIf you have a string like this:\n<code>\nstring input\
    \ = \"abcd\";\n</code>\nYou can use this code:\n<code>\nvar strings = new List<string>();",
  "{\n    ArrayList list = new ArrayList();\n    for(int i = 0; i < strings.length;\
    \ i++)\n    {\n        if(strings[i].contains(substring))\n        {\n       \
    \     list.add(strings[i]);\n        }\n    }\n    return (string[])list.array;\n\
    }", "{\n\tstring[] ret = new string[strings.length];\n\tfor (int i = 0; i < strings.length;\
    \ ++i)\n\t{\n\t\tif (strings[i].indexOf(substring) != -1)\n\t\t{\n\t\t\tret[i]\
    \ = strings[i];\n\t\t}\n\t}\n\treturn ret;\n}", "{\n    int[] indexes = string_index_of(strings,\
    \ substring);\n    if (indexes == null) return strings;\n    \n    var ret = new\
    \ string[strings.length];\n    \n    for (int i=0; i<strings.length; i++) {\n\
    \        if (indexes[i] != -1) ret[i] = strings[i];\n    }\n    return ret;\n}",
  "{\n    foreach (string s in strings)\n    {\n        if (substring.IndexOf(s) ==\
    \ 0) \n        {\n            strings.Remove(s);\n        }\n    }\n    return\
    \ strings;\n}", "{\n    var ret: string[] = [];\n    \n    for (int i = 0; i <\
    \ strings.length; i++) {\n        if (strings[i].indexOf(substring) > -1) {\n\
    \            ret.push(strings[i]);\n        }\n    }\n    \n    return ret;\n\
    }\n</code>\n<|/ a tags=search,string,algorithm,java |>\n<| a tags=search,string,algorithm,java\
    \ |>\nI recommend you to use StringBuilder instead of String since String is immutable\
    \ while StringBuilder is mutable.  \nI used a HashMap to store the index of each\
    \ word.  \nHere is my code:\n<code>\npublic static void main(String[] args) {\n\
    \    String[] tests = {\"abc\", \"bacd\", \"cde\", \"array\", \"abs\", \"cd\"\
    , \"abc\", \"de\", \"ab\"};\n    String substring = \"a\";\n    Map<String, Integer>\
    \ map = new HashMap<String, Integer>();\n    for (int i = 0; i < tests.length;\
    \ i++) {\n        if (tests[i].contains(substring)) {\n            String temp[]\
    \ = tests[i].split(substring);\n            for (int j = 0; j < temp.length; j++)\
    \ {\n                if (temp[j] != null) {\n                    int index = map.get(temp[j]);\n\
    \                    if (index == -1) {\n                        index = map.put(temp[j],\
    \ i);\n                    }\n                }\n            }\n        }\n  \
    \  }\n    System.out.println(\"Result: \" + map.keySet());\n}\n</code>\n<|/ a\
    \ dscore=3 |>\n<| c |>\nI love how this works but I don't think it's very efficient,\
    \ since it iterates over every word in the string, and for each of those words\
    \ iterates over every word in `tests[i]`. If there's a lot of words in `tests[i]`\
    \ this could get very expensive.\n<|/ c |>\n<| c |>\nIt only iterates over words\
    \ in the first array. It doesn't even need to iterate over words in tests[i],\
    \ since it doesn't need to compare each word to every word in tests[i].\n<|/ c\
    \ |>\n<| a dscore=3 |>\nHere is an elegant solution:\n<code>\npublic static List<String>\
    \ findWordsInArray(String[] array, String keyword) {\n    return Arrays.asList(array).stream()\n\
    \            .filter(word -> word.contains(keyword))\n            .collect(Collectors.toList());\n\
    }\n</code>\nThis uses a single Java 8 Stream to filter the array and then collect\
    \ the filtered words into a new List object.\n<|/ a tags=search,string,algorithm,java\
    \ |>\n<| a |>\n<code>\npublic static boolean contains(String word, String str)\
    \ {\n  return str.contains(word);\n}", "{\n    int i = 0;\n    int j = 0;\n  \
    \  string[] result = new string[strings.length];\n    while ((i < strings.length)\
    \ && (j < substring.length)) {\n        if (strings[i].contains(substring[j]))\
    \ {\n            result[i] = strings[i];\n            ++i;\n        }\n      \
    \  ++j;\n    }\n    return result; \n}", "{\n    string[] filtered = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; ++i) {\n        if (strings[i].contains(substring))\n\
    \            filtered[i] = strings[i];\n    }\n    return filtered;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThank you, this was exactly what I was looking for.\
    \ Works perfectly\n<|/ c |>\n<| a dscore=4 |>\nA very simple way is to split your\
    \ string into a character array and loop through the array to find your pattern.\
    \ For example if your string is \"asdfasdfasdfasdfasdfasdfasdf\" then split it\
    \ into character array using char[] c = s.toCharArray(); and loop through the\
    \ character array to find your pattern. \nExample : \n<code>\nString s = \"asdfasdfasdfasdfasdfasdfasdf\"\
    ;\nchar[] c = s.toCharArray();\nfor(int i = 0; i < c.length; i++){\n    if(c[i]\
    \ == 's'){\n        //Your pattern is found\n    }\n}\n</code>\n<|/ a tags=java,string\
    \ |>\n<| c |>\nSimple and effective!\n<|/ c |>\n<| a dscore=4 tags=java,string\
    \ |>\nThe solution is to convert the String into a List and check if the list\
    \ contains your string\n<code>\npublic boolean containsString(String str,String\
    \ sub) {\n    List<String> list = new ArrayList<String>();\n    list.add(str);\n\
    \    for(String s:list) {\n        if(s.contains(sub)) return true;\n    }\n \
    \   return false;\n}\n</code>\n<|/ a |>\n<| c |>\nThis solution works fine if\
    \ the pattern you're looking for is a substring of the string.  If the substring\
    \ you're looking for is at the beginning, you're going to have to iterate through\
    \ the entire list of strings to find it.  If you're looking for it anywhere, you\
    \ can still use this.\n<|/ c |>\n<| c |>\nThis is by far the best solution. Just\
    \ call it with `str.containsString(sub)`, where `sub` is your search string. This\
    \ way it won't have to iterate the whole list of strings once you find a match\
    \ in a list of size 1.\n<|/ c |>\n<| c |>\nJust a note that this solution has\
    \ a caveat: if `str` is an empty `String`, it will return `false`, even if `sub`\
    \ itself is found.\n<|/ c |>\n<| a dscore=3 tags=java,string |>\nTo check if a\
    \ String is in a given String, you could use the .contains() method. \nFor example\
    \ \n<code>\nString example = \"asdfasdfasdfasdfasdfasdfasdf\";\nString search\
    \ = \"", "{\n    for(int index = 0; index < strings.length; index++) {\n     \
    \   if(strings[index].contains(substring)) {\n            strings.remove(index);\n\
    \        }\n    }\n    return strings;\n}", "{\n    List<string> newStrings =\
    \ new List<string>();\n    foreach(string s in strings) \n    {\n        if(s.Contains(substring))\
    \ newStrings.Add(s);\n    }\n    return newStrings.ToArray();\n}\n</code>\n<|/\
    \ a tags=algorithm,c# |>\n<| a dscore=0 |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;", "{\n\t\
    int len = 0;\n\tforeach(string s in strings)\n\t\tlen += s.length();\n\t\n\tif(substring\
    \ == \"\") return strings;\n\t\n\tint startIndex = 0;\n\tint endIndex = len;\n\
    \tbool found = false;\n\tforeach(string s in strings)\n\t{\n\t\tif(found)\n\t\t\
    {\n\t\t\tif(s.Contains(substring))\n\t\t\t{\n\t\t\t\tstartIndex = endIndex;\n\t\
    \t\t\tfound = false;\n\t\t\t}\n\t\t\telse\n\t\t\t\tendIndex += s.Length();\n\t\
    \t}\n\t\telse \n\t\t{\n\t\t\tif(s.Contains(substring))\n\t\t\t{\n\t\t\t\tstartIndex\
    \ = endIndex;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\telse\n\t\t\t\tendIndex +=\
    \ s.Length();\n\t\t}\n\t}\n\t\n\tif(startIndex == endIndex)\n\t\treturn strings;\n\
    \telse\n\t\treturn strings.Substring(startIndex, endIndex - startIndex);\n}\n\
    /*\n Filter an input array of strings only for ones that contain given substring\n\
    \    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"ac\")\n\
    \    []\n    \n*/\nstring[] filter_by_substring(string[] strings, string substring,\
    \ StringComparison comparison)\n{\n\tint len = 0;\n\tforeach(string s in strings)\n\
    \t\tlen += s.Length;\n\t\n\tif(substring == \"\") return strings;\n\t\n\tint startIndex\
    \ = 0;\n\tint endIndex = len;\n\tbool found = false;\n\tforeach(string s in strings)\n\
    \t{\n\t\tif(found)\n\t\t{\n\t\t\tif(s.Contains(substring, comparison))\n\t\t\t\
    {\n\t\t\t\tstartIndex = endIndex;\n\t\t\t\tfound = false;\n\t\t\t}\n\t\t\telse\n\
    \t\t\t\tendIndex += s.Length;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tif(s.Contains(substring,\
    \ comparison))\n\t\t\t{\n\t\t\t\tstartIndex = endIndex;\n\t\t\t\tfound = true;\n\
    \t\t\t}\n\t\t\telse\n\t\t\t\tendIndex += s.Length;\n\t\t}\n\t}\n\t\n\tif(startIndex\
    \ == endIndex)\n\t\treturn strings;\n\telse\n\t\treturn strings.Substring(startIndex,\
    \ endIndex - startIndex);\n}", "{\n    string[] result = new string[strings.length];\n\
    \    \n    int i = 0;\n    for (int j = 0; j < strings.length; j++)\n    {\n \
    \       if (strings[j].contains(substring))\n            result[i++] = strings[j];\n\
    \    }\n    \n    return result;\n}\n/*\n Filter an input array of strings only\
    \ for ones that contain given substring\n    >>> filter_by_substring([], \"a\"\
    )\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"bacd\"]\n    \n*/\n</code>\n<|/ a dscore=3 tags=c#\
    \ |>\n<| c |>\n`string[] result = new string[strings.length];\n        for (int\
    \ j = 0; j < strings.length; j++)\n        {\n            int i = 0;\n       \
    \     for (i = 0; i < strings[j].Length; i++)\n            {\n               \
    \ if (strings[j].Contains(substring))\n                {\n                   \
    \ result[i++] = strings[j];\n                }\n            }\n        }`\n<|/\
    \ c |>\n<| a |>\nHere is my simple solution:\n<code>\npublic static List<string>\
    \ FilterString(List<string> strings, string searchFor)\n{\n    var result = new\
    \ List<string>();\n    foreach (var str in strings)\n    {\n        if (str.IndexOf(searchFor)\
    \ != -1)\n            result.Add(str);\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=3 tags=c# |>\n<| c |>\nThe question is for filtering by substring,\
    \ not indexOf string\n<|/ c |>\n<| c |>\nIf you have a solution that only uses\
    \ `IndexOf()`, you should post it as an answer rather than as a comment.\n<|/\
    \ c |>\n<| c |>\nYou will probably get more answers if you post your own as a\
    \ separate answer instead of editing your question.\n<|/ c |>\n<| a |>\nThe simplest\
    \ way is to use a regular expression:\n<code>\nvar list = strings.Select(x =>\
    \ Regex.Replace(x, \"^.*a\", \"\")).ToList();\n</code>\nThis replaces every string\
    \ that starts with a and ends with a with a empty string.\n<|/ a tags=c# dscore=3\
    \ |>\n<| c |>\nThat would replace anything with `a` *anywhere* in the string\n\
    <|/ c |>\n<| c |>\nThis is also a nice way of doing it, but I would have to add\
    \ some regex and an additional string check because I only want those items that\
    \ contain the string \"a\". ", "{\n\tHashSet<string> filter;\n\tforeach(var s\
    \ in strings)\n\t\tfilter.Add(s);", "{\n    string lowerSubstring=substring.ToLower();\n\
    \    foreach (string str in strings)\n    {\n        if (!str.ToLower().Contains(lowerSubstring))\n\
    \        {\n            strings.Remove(str);\n        }\n    }\n    return strings;\n\
    }\n/*\n Filter an input array of strings only for ones that equal given substring\n\
    \    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n*/\nstring[]\
    \ filter_by_substring(string[] strings, string substring, bool caseSensitive=false)\n\
    {\n    string lowerSubstring=substring.ToLower();\n    if (caseSensitive)\n  \
    \  {\n        foreach (string str in strings)\n        {\n            if (str.ToLower().Contains(lowerSubstring))\n\
    \            {\n                strings.Remove(str);\n            }\n        }\n\
    \    }\n    else\n    {\n        foreach (string str in strings)\n        {\n\
    \            if (!str.ToLower().Contains(lowerSubstring))\n            {\n   \
    \             strings.Remove(str);\n            }\n        }\n    }\n    return\
    \ strings;\n}\n</code>\n<|/ a tags=c#,algorithm,arrays,.net,string |>\n<| c |>\n\
    Thank you, that's a much more thorough solution. I'm still curious why my solution\
    \ isn't working, but I'm going to keep trying things and see what happens. I'm\
    \ still wondering if there are better algorithms for doing this, but if not, I'm\
    \ going to mark this as my accepted answer. Thank you.\n<|/ c |>\n<| c |>\nYour\
    \ solution was buggy by design, though it did not fail to work in the case of\
    \ empty arrays. I updated the code to be a little more robust. The error was that\
    \ if a string was missing from the array after the first iteration (as was the\
    \ case in the OP's case), then it would not be removed from strings. I added a\
    \ check for that and it now passes all tests.\n<|/ c |>\n<| c |>\nThe error I\
    \ was trying to describe had to do with my solution failing to remove the first\
    \ occurrence of the substring from the array, not the first occurrence of the\
    \ substring **within** the string. Your solution fixed that, though I am still\
    \ wondering how you got it to work in the first place. Did you change something\
    \ else that was wrong?\n<|/ c |>\n<| c |>\nI changed your implementation to remove\
    \ all occurrences of the substring from the string and I got it to work. The test\
    \ case I used was `[\"abc\", \"bacd\", \"cde\", \"array\"]`, which was ", "{\n\
    \    // TODO: Implement\n    return null;\n}\n</code>\n<|/ a tags=performance,java,collections,arrays,string\
    \ dscore=1 |>\n<| c |>\nThe test array contains 1 million elements. Your solution\
    \ needs about 30 seconds to complete.\n<|/ c |>\n<| c |>\nI see. In that case\
    \ you are probably better off with the solution by Markov Chubbar, which uses\
    \ `indexOf` rather than a `for` loop to check all characters of a string.\n<|/\
    \ c |>\n<| c |>\nI updated the answer. Although I believe the `indexOf` is still\
    \ a more efficient than my solution.\n<|/ c |>\n<| a dscore=0 |>\nThis should\
    \ take about half a second (for 10e6 strings):\n<code>\nString[] words = new String[10e6];\n\
    for (int i = 0; i < words.length; i++)\n{\n    words[i] = new String(new char[]\
    \ { 'a' });\n}\n</code>\nYou don't need to worry about \"real\" time here, this\
    \ is just an example. If you want to measure the actual time, then you can run\
    \ this for different sizes.\n<|/ a tags=performance,java,collections,arrays,string\
    \ |>\n<| a |>\nHere are my two solutions. One uses Guava's SetMultimap to store\
    \ all the possible strings and how many times each one appears. The other uses\
    \ Guava's Multiset. It also has some performance optimizations. Both of these\
    \ use Java 8's streams and lambdas, but could easily be rewritten to use Java\
    \ 7's streams and lambdas if desired.\n<code>\nimport com.google.common.collect.Multimap;\n\
    import com.google.common.collect.Multiset;", "{\n\tbool found = false;\n\tfor\
    \ (int i = 0; i < strings.length && !found; i++) \n\t\tif (strings[i].Contains(substring))\n\
    \t\t{\n\t\t\tfound = true;\n\t\t}\n\tif (found)\n\t{\n\t\treturn strings;\n\t\
    }\n\telse\n\t{\n\t\treturn new string[0];\n\t}\n}", "{\n    \n    string[] ret\
    \ = new string[strings.length];\n    int counter = 0;\n    \n    for (int i =\
    \ 0; i < strings.length; ++i) {\n        if (strings[i].contains(substring)) {\n\
    \            ret[counter++] = strings[i];\n        }\n    }\n    \n    return\
    \ ret;\n}", "{\n    int foundCount = 0;\n    int i = 0;\n    for(i=0; i < strings.length;\
    \ i++) {\n        // if substring is in string at i...\n        if(strings[i].Contains(substring))\
    \ {\n            foundCount++;\n        }\n    }\n    string[] newStrings = new\
    \ string[strings.length-foundCount];\n    int j = 0;\n    for(i=0; i < strings.length\
    \ - foundCount; i++) {\n        if(strings[i].Contains(substring)) {\n       \
    \     newStrings[j++] = strings[i];\n        }\n    }\n    return newStrings;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\nstatic string[] FilterArray(string[]\
    \ arr, int n) \n{\n    List<string> result = new List<string>();", "{\n    //\
    \ TODO\n    \n    return strings;\n}\n/*\n Filter an input array of strings only\
    \ for ones that contain given substring\n    >>> filter_by_substring([], \"a\"\
    )\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring, bool caseSensitive = true) \n{\n    // TODO\n   \
    \ \n    return strings;\n}\n/*\n Filter an input array of strings only for ones\
    \ that contain given substring\n    >>> filter_by_substring([], \"a\")\n    []\n\
    \    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n\
    \    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring, bool caseSensitive, bool anyNonAlpha) \n{\n    //\
    \ TODO\n    \n    return strings;\n}\n/*\n Filter an input array of strings only\
    \ for ones that contain given substring\n    >>> filter_by_substring([], \"a\"\
    )\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring, bool caseSensitive, bool anyNonAlpha, bool anyNonNumeric)\
    \ \n{\n    // TODO\n    \n    return strings;\n}\n/*\n Filter an input array of\
    \ strings only for ones that contain given substring\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring, bool caseSensitive, bool anyNonAlpha, bool anyNonNumeric,\
    \ bool anyNonAlphanumeric) \n{\n    // TODO\n    \n    return strings;\n}\n/*\n\
    \ Filter an input array of strings only for ones that contain given substring\n\
    \    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"\
    ]\n    \n*/\nstring[] filter_by_substring(string[] strings, string substring,\
    \ bool caseSensitive, bool anyNonAlpha, bool anyNonNumeric, bool anyNonAlphanumeric,\
    \ bool anyAlpha) \n{\n    // TODO\n    \n    return strings;\n}\n/*\n Filter an\
    \ input array of strings only for ones that contain given substring", "{\n   \
    \ string[] result;\n    \n    int len = strings.length;\n    int[] indexes = new\
    \ int[len];\n    \n    for (int i = 0; i < len; i++)\n    {\n        if (strings[i].Contains(substring))\n\
    \        {\n            indexes[i] = i;\n        }\n    }\n    \n    result =\
    \ new string[indexes.Length];\n    for (int i = 0; i < indexes.Length; i++)\n\
    \    {\n        result[i] = strings[indexes[i]];\n    }\n    \n    return result;\n\
    }", "{\n    foreach (string s in strings) {\n        if (s.Contains(substring))\
    \ \n        {\n            string[] newstrings = new string[strings.Length-1];\n\
    \            for (int i = 0; i <= strings.Length-2; i++)\n                newstrings[i+1]\
    \ = strings[i];\n            return newstrings;\n        }\n    }\n    return\
    \ strings;\n}\n</code>\n<|/ a dscore=1 tags=c#,winforms |>\n<| c |>\nIt would\
    \ be nice to include some explanation. By the way, `string.Join` doesn't exist\
    \ in C#.\n<|/ c |>\n<| c |>\nThanks for catching the error. I added the explanation\
    \ as an edit to my answer.\n<|/ c |>\n<| a dscore=1 tags=c#,winforms |>\nThe LINQ\
    \ solution is rather long and complex, so I will provide an alternative using\
    \ lambda expressions, LINQ and extension methods (that require the namespace System.Linq)\n\
    <code>\nvar matches = input.Where(s => s.Contains(\"a\"));\nvar result = matches.ToArray();\n\
    </code>\nYou can achieve the same result by importing System.Linq and creating\
    \ a custom extension method\n<code>\npublic static class LinqExtensions\n{\n \
    \   public static IEnumerable<string> WhereContains(this IEnumerable<string> input,\
    \ string sub)\n    {\n        return input.Where(s => s.Contains(sub));\n    }\n\
    }\n</code>\nUsage:\n<code>\nvar result = input.WhereContains(\"a\").ToArray();\n\
    </code>\n<|/ a |>\n<| a tags=c#,winforms |>\nHere's my solution:\n<code>\nstatic\
    \ class Program\n{\n    static void Main()\n    {\n        Console.WriteLine(FilterBySubstring(\"\
    a b c\", \"a\"));\n    }", "{\n    string[] result = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; i++) \n    {\n        if (strings[i].Contains(substring))\
    \ \n        {\n            result[i] = strings[i];\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=arrays,c#,string dscore=0 |>\n<| c |>\n`System.Array`\
    \ doesn't have a `contains` method.\n<|/ c |>\n<| c |>\n, that's why I wrote `using\
    \ System;`, but thanks for pointing out that mistake\n<|/ c |>\n<| c |>\nThe `System.Array`\
    \ namespace doesn't have a `contains` method.\n<|/ c |>\n<| c |>\nThanks for the\
    \ fix. I'll update my answer\n<|/ c |>\n<| a |>\nHere's an alternative that doesn't\
    \ rely on LINQ, and that uses a helper function that is easy to read:\n<code>\n\
    string[] filter_by_substring(string[] strings, string substring)\n{\n    var result\
    \ = new List<string>();\n    foreach (string s in strings)\n    {\n        if\
    \ (s.Contains(substring))\n            result.Add(s);\n    }\n    return result.ToArray();\n\
    }\n</code>\n<|/ a dscore=0 tags=arrays,c#,string |>\n<| c |>\nWhy would you use\
    \ `List`? `List<string> result = new List<string>();` would be more efficient.\n\
    <|/ c |>\n<| c |>\nI like how you name the function so it shows up with intellisense,\
    \ so it's easy to remember.\n<|/ c |>\n<| c |>\n: I like how the name fits what\
    \ it is doing. :)\n<|/ c |>\n<| c |>\n: I was thinking about it more and I agree\
    \ that it doesn't matter. It's just a bit more readable. I'd use an `ArrayList`\
    \ myself, though.\n<|/ c |>\n<| c |>\nI prefer lists over arrays, because they\
    \ are easier to grow.  They are also more flexible in how you use them.  Lists\
    \ are very useful when you need to store things in a collection but you don't\
    \ need to keep track of how many things are in the collection, etc...  Arrays\
    \ are more useful in situations where the array is fixed length or you know you\
    \ won't need more than a certain number of entries.\n<|/ c |>\n<| a dscore=0 |>\n\
    This should do the trick:\n<code>\nstatic string[] filter_by_substring(string[]\
    \ strings, string substring)\n{\n    string[] result = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; i++)\n    {\n        if (", "{\n\tint\
    \ index = 0;\n\t\n\twhile (index < strings.length) \n\t{\n\t\tif (strings[index]\
    \ == substring)\n\t\t{\n\t\t\tstrings = strings[index + 1];\n\t\t\tindex = 0;\n\
    \t\t}\n\t\telse \n\t\t{\n\t\t\tindex += 1;\n\t\t}\n\t}", "{\n    string[] result;\n\
    \    size_t count = 0;\n    for (string string : strings) {\n        if ((string\
    \ = string.Trim()) != null) {\n            size_t found;\n            if ((found\
    \ = string.find(substring)) != -1) {\n                result[count++] = string;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*\n Filter an input\
    \ array of strings only for ones not containing given substring\n    >>> filter_by_substring2([],\
    \ \"a\")\n    []\n    >>> filter_by_substring2([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\")\n    [\"array\"]\n    \n*/\nstring[] filter_by_substring2(string[]\
    \ strings, string substring) \n{\n    string[] result;\n    size_t count = 0;\n\
    \    for (string string : strings) {\n        if ((string = string.Trim()) !=\
    \ null) {\n            size_t found;\n            if ((found = string.find(substring))\
    \ != -1) {\n                result[count++] = string;\n            }\n       \
    \ }\n    }\n    return result;\n}", "{\n    int start = 0;\n    int end = -1;\n\
    \    for (int i = 0; i < strings.length; i++)\n    {\n        if (strings[i].Contains(substring))\n\
    \        {\n            start = i;\n            end = i + 1;\n            break;\n\
    \        }\n    }\n    if (end == -1) \n        return strings;\n    return strings.Take(end).Concat(strings.Skip(start)).ToArray();\n\
    }\n</code>\nThis solution uses LINQ, but it works correctly in .NET Core, too.\n\
    <|/ a tags=string,c#,arrays,search,split |>\n<| a tags=string,c#,arrays,search,split\
    \ |>\n<code>\nvar inputArray = new string[] {\"a\",\"b\",\"c\"};\nvar inputArray\
    \ = new string[] {\"a\",\"b\",\"c\",\"d\",\"e\"};\nvar inputArray = new string[]\
    \ {\"a\",\"b\",\"c\",\"d\"};\nvar inputArray = new string[] {\"a\",\"b\",\"c\"\
    };\nvar inputArray = new string[] {\"a\",\"b\"};\nvar inputArray = new string[]\
    \ {\"a\",\"b\"};", "{\n    var filter = new List<string>();\n    for (int i =\
    \ 0; i < strings.length; i++) \n    {\n        if (strings[i].Contains(substring))\
    \ \n        {\n            filter.Add(strings[i]);\n        }\n    }\n    return\
    \ filter.ToArray();\n}\n</code>\n<|/ a tags=c#,string,linq |>\n<| a tags=c#,string,linq\
    \ |>\n<code>\nprivate static bool ContainsSubstring(string value, string substring)\n\
    {\n    int index = value.IndexOf(substring);", "{\n    string[] result = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; i++)\n    {\n        if (strings[i].Contains(substring))\n\
    \        {\n            result[i] = strings[i];\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=c#,linq |>\n<| a |>\n<code>\npublic static IEnumerable<string>\
    \ FindAllWords(string input, string word)\n{\n    Regex regex = new Regex(word);\n\
    \    MatchCollection matches = regex.Matches(input);", "{\n    for(string[] line\
    \ : strings)\n    {\n        if(line.contains(substring))\n        {\n       \
    \     return line;\n        }\n    }\n    return strings;\n}", "{\n\t\n\tforeach(string\
    \ s in strings) {\n\t\tif (s.contains(substring)) {\n\t\t\tyield return s;\n\t\
    \t}\n\t}\n}", "{\n    string[] result = new string[strings.length];\n    int i\
    \ = 0;\n    for (string string : strings)\n    {\n        if (string.Contains(substring))\n\
    \        {\n            result[i++] = string;\n        }\n    }\n    return result;\n\
    }", "{\n    string[] result = new string[strings.length];\n    \n    bool anyMatch\
    \ = false;\n    for(int i = 0; i < strings.length; i++){\n        if(strings[i].contains(substring)){\n\
    \            anyMatch = true;\n            result[i] = strings[i];\n        }\n\
    \    }\n    \n    if(!anyMatch)\n        return result;\n    \n    string[] temp\
    \ = new string[strings.length];\n    for(int i = 0; i < strings.length; i++)\n\
    \        temp[i] = strings[i];\n    \n    for(int i = 0; i < strings.length; i++)\n\
    \    {\n        string temp = strings[i];\n        for(int j = 0; j < temp.length();\
    \ j++)\n        {\n            if(temp.substring(j, j+substring.Length) == substring)\n\
    \            {\n                result[i] = temp;\n                temp = temp.substring(0,\
    \ j) + temp.substring(j+substring.Length);\n            }\n        }\n    }\n\
    \    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nYour solution doesn't work\
    \ if substring contains any of substring's characters.\n<|/ c |>\n<| c |>\n- That's\
    \ how it works.  If you have a string that contains \"ab\", and \"aa\", the substring\
    \ \"ab\" will match only at the first position.  The other \"aa\" will match only\
    \ at the second position, and so on.\n<|/ c |>\n<| c |>\n- I've updated the post\
    \ to fix the bug with that bug in my original code.\n<|/ c |>\n<| c |>\nThat bug\
    \ was my fault! But your solution doesn't work if string contains substring itself.\n\
    <|/ c |>\n<| c |>\n- You're right.  I updated the answer and the code accordingly.\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>\nstring[] filterBySubstring(string[] strings,\
    \ string substring)\n{\n    List<string> output = new List<string>();\n    foreach(string\
    \ s in strings)\n    {\n        if(s.Contains(substring))\n            output.Add(s);\n\
    \    }\n    return output.ToArray();\n}\n</code>\n<|/ a tags=c#,string |>\n<|\
    \ a dscore=3 |>\nI believe this is more efficient:\n<code>\nprivate static string[]\
    \ filterBySubstring(string[] strings, string substring)\n{\n    return strings.Where(s\
    \ => s.Contains(substring)).ToArray();\n}\n</code>\n<|/ a tags=c#,string |>\n\
    <| a tags=c#,string dscore=3 |>\nIf performance is important then you could also\
    \ use a StringBuilder:\n<code>\npublic static string[] filterBySubstring(string[]\
    \ strings, string substring)\n{\n    StringBuilder sb = new StringBuilder(strings.",
  "{\n\treturn filter_by_substring(strings, substring, false);\n}", "{\n    string[]\
    \ result = new string[strings.length];\n    for (int i = 0; i < strings.length;\
    \ i++){\n        if (strings[i].contains(substring)){\n            result[i] =\
    \ strings[i];\n        }\n    }\n    return result;\n}\n/*\n Reverse the input\
    \ array\n    >>> reverse([4, 5, 6])\n    [6, 5, 4]\n*/", "{\n    string[] result\
    \ = new string[strings.length];\n    int index = 0;\n    foreach (string s in\
    \ strings) {\n        if (s.Contains(substring)) {\n            result[index]\
    \ = s;\n            index++;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=c#,string,.net,arrays |>\n<| a dscore=0 tags=c#,string,.net,arrays\
    \ |>\nYou could use Linq for this:\n<code>\nvar s = \"some string with an array\
    \ inside\";\nvar array = s.Split(new[] {' '}, StringSplitOptions.RemoveEmptyEntries)\n\
    \             .Where(x => x.Contains(\"[\") && x.EndsWith(\"]\"))\n          \
    \   .Select(x => x.Substring(1, x.Length - 2))\n             .ToArray();\n</code>\n\
    Result:\n<code>\nstring [] array = {\n    \"string\",\n    \"with\",\n    \"array\"\
    \n};\n</code>\n<|/ a |>\n<| a tags=c#,string,.net,arrays dscore=0 |>\nThis should\
    \ do the job:\n<code>\nString input = \"some string with an array inside\";\n\
    String[] array = input.Split(' ');\nString[] result = new String[array.Length];",
  "{\n  List<string> results = new List<string>();\n  foreach (string str in strings)\
    \ {\n    if (str.Contains(substring)) {\n      results.Add(str);\n    }\n  }\n\
    \  return results.ToArray();\n}\n</code>\n<|/ a dscore=1 tags=string,c# |>\n<|\
    \ c |>\nthank you all for your help. I believe this is the most efficient way\n\
    <|/ c |>\n<| a dscore=0 tags=string,c# |>\nUse LINQ to XML.  It is a better option\
    \ than string manipulation. \n<code>\nvar filtered = \n    from ele in xDoc.Descendants(\"\
    File\")\n    where ele.Element(\"Item\").Attribute(\"Value\").Value.Contains(value)\n\
    \    select ele.Element(\"Item\").Attribute(\"Value\").Value;\n</code>\n<|/ a\
    \ |>\n<| c |>\nWhy LINQ to XML?  XML isn't really the right tool for the job,\
    \ as it sounds like it's a text file - and LINQ would involve parsing the XML\
    \ in a way that is both hard to read and error-prone (unless you used a dedicated\
    \ XML parser).\n<|/ c |>\n<| c |>\n, its not just about parsing xml, its about\
    \ querying.\n<|/ c |>\n<| c |>\n, there are a number of ways you can use LINQ\
    \ to XML, for example, if you wanted to filter by attribute or inner text.  Also,\
    \ its not hard to use LINQ to XML, its not hard to read XML, it's all about how\
    \ you parse it.  If you know XPath, then using LINQ to XML is easier because you\
    \ can write an XPath expression to do the same thing.  It also means you can use\
    \ the LINQ functions on an XML object that aren't available on XPath.  That's\
    \ a big reason to use LINQ to XML over XPath if you're writing new code.\n<|/\
    \ c |>\n<| c |>\n, LINQ to XML is about querying, it's about parsing XML and querying\
    \ it.  That doesn't make it \"hard to read\".  It's all about parsing, whether\
    \ that's with XPath or XML.  LINQ to XML uses a special syntax to query the XML,\
    \ so it's not hard to read.  Also, XPath is harder to read, but it's not hard\
    \ to write.\n<|/ c |>\n<| c |>\n, LINQ to XML uses XPath.  Its not hard to read\
    \ XML, its not hard to read.  Its easier to use LINQ to XML to query than XPath.\n\
    <|/ c |>\n<| a dscore=0 |>\nThis approach is more ", "{\n    string[] result =\
    \ new string[strings.length];\n    for (int i = 0; i < strings.length; ++i)\n\
    \    {\n        if (strings[i].contains(substring))\n        {\n            result[i]\
    \ = strings[i];\n        }\n    }\n    return result;\n}", "{\n  var results =\
    \ new List<string>();\n  foreach (var item in strings)\n  {\n    if (item.contains(substring))\n\
    \      results.Add(item);\n  }\n  return results.ToArray();\n}\n</code>\n<|/ a\
    \ dscore=1 tags=c#,string,substring |>\n<| c |>\nThis won't compile. `substring`\
    \ isn't in scope. Try `items.Where(item => item.Contains(substring));` instead.\n\
    <|/ c |>\n<| a tags=c#,string,substring |>\nYou can use a Regex for this.\n<code>\n\
    Regex r1 = new Regex(\"ab\");\nr1.IsMatch(\"ababa\"); // true\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nIt would probably be better to use a Regex for this: `\\\
    bab\\b`\n<|/ c |>\n<| a |>\n<code>\npublic static class StringExtension\n{\n \
    \   public static bool ContainsAll(this string source, string substring)\n   \
    \ {\n        var subset = source.Split(' ');\n        var sub = substring.Split('\
    \ ');\n        foreach (var s in subset)\n            if (sub.All(item => s ==\
    \ item))\n                return true;\n        return false;\n    }\n}\n</code>\n\
    <|/ a dscore=0 tags=c#,string,substring |>\n<| c |>\nThis does not provide an\
    \ answer to the question. To critique or request clarification from an author,\
    \ leave a comment below their post. - [From Review](/review/low-quality-posts/15046616)\n\
    <|/ c |>\n<| c |>\nHow is this not an answer? It provides working code. OP did\
    \ not ask for code, but for an explanation. Thus, it is an answer.\n<|/ c |>\n\
    <| c |>\nThis answer does provide code, but it's inefficient because it splits\
    \ the string multiple times. That's what the OP was asking for. Besides, it's\
    \ hardly readable, and since it splits the string multiple times, it won't work\
    \ with very large strings. A regex would work much better.\n<|/ c |>\n<| c |>\n\
    Why inefficient? It will be called each time the method is called. The code will\
    \ be translated to something like a loop over each character in the string. Also\
    \ I didn't see any inefficiency here.\n<|/ c |>\n<| c |>\nYou're right, I misread\
    \ that as \"efficient\" instead of \"working\". I did say it's inefficient because\
    \ it's a loop over each character in the string, and it uses up RAM. Your method\
    \ is more efficient because it only ", "{\n    int i = 0, found = 0, length =\
    \ 0;\n    while (i < strings.length) \n    {\n        length = strings[i].length();\n\
    \        if (length == substring.length()) \n        {\n            if (strings[i]\
    \ == substring) \n            {\n                found++;\n            }\n   \
    \         else \n            {\n                i++;\n            }\n        }\n\
    \        else\n        {\n            i++;\n        }\n    }\n    string[] result\
    \ = new string[found];\n    int j = 0;\n    while (i < strings.length)\n    {\n\
    \        length = strings[i].length();\n        if (length == substring.length())\
    \ \n        {\n            if (strings[i] == substring) \n            {\n    \
    \            result[j++] = strings[i];\n            }\n            else \n   \
    \         {\n                i++;\n            }\n        }\n        else\n  \
    \      {\n            i++;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=java,string dscore=0 |>\nYou can do it with streams:\n\
    <code>\npublic static void main(String[] args) {\n    String string1 = \"hello\"\
    ;\n    String string2 = \"hello\";\n    String string3 = \"hi\";\n    List<String>\
    \ strings = new ArrayList<>();\n    strings.add(string1);\n    strings.add(string2);\n\
    \    strings.add(string3);\n    List<String> stringsFiltered = strings.stream().filter(s\
    \ -> s.equals(string2)).collect(Collectors.toList());\n    System.out.println(stringsFiltered);\n\
    }\n</code>\nOr you can use a for loop:\n<code>\npublic static void main(String[]\
    \ args) {\n    String string1 = \"hello\";\n    String string2 = \"hello\";\n\
    \    String string3 = \"hi\";\n    List<String> strings = new ArrayList<>();\n\
    \    strings.add(string1);\n    strings.add(string2);\n    strings.add(string3);\n\
    \    List<String> stringsFiltered = new ArrayList<>();\n    for(String s: strings)\
    \ {\n        if(s.equals(string2)) {\n            stringsFiltered.add(s);\n  \
    \      }\n    }\n    System.out.println(stringsFiltered);\n}\n</code>\n<|/ a |>\n\
    <| a tags=java,string dscore=0 |>\n<code>\nString string1 = \"hello\";\nString\
    \ string2 = \"hello\";\nString string3 = \"hi\";\nList<String> strings = new ArrayList<>();\n\
    strings.add(string1);\nstrings.add(string2);\nstrings.add(string3);\nList<String>\
    \ stringsFiltered = new ArrayList<>();\nfor (String string : strings) {\n    if\
    \ (string.equals(string2)) {\n        stringsFiltered.add(string);\n    }\n}\n\
    System.out.println(stringsFiltered);\n</code>\n<|/ a |>\n<| c |>\nI think this\
    \ should be the accepted answer, as it is the simple", "{\n\tstring[] res = new\
    \ string[strings.length];\n\tint index = 0;\n\tfor(int i=0; i<strings.length;\
    \ i++)\n\t{\n\t\tstring s = strings[i];\n\t\tint len = s.length();\n\t\tif(s.find(substring)\
    \ != string::npos)\n\t\t\tres[index++] = s;\n\t}\n\treturn res;\n}", "{\n    foreach(string\
    \ s in strings) {\n        if(s.Contains(substring)) {\n            yield return\
    \ s;\n        }\n    }\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=algorithm,c#,string,filtering,sorting\
    \ |>\nA simple way to do it using LINQ could be\n<code>\nvar result = strings.Where(x\
    \ => x.Contains(\"a\")).ToArray();\n</code>\nThis way you don't have to import\
    \ System.Linq.\n<|/ a dscore=4 |>\n<| c |>\nThis should be the accepted answer.\
    \ Simple and efficient.\n<|/ c |>\n<| a dscore=3 tags=algorithm,c#,string,filtering,sorting\
    \ |>\nThe simplest thing that comes to mind would be a recursive function which\
    \ goes through each string and checks if the string contains the substring \"\
    a\" then either returns it or passes it to the next iteration.\n<|/ a |>\n<| c\
    \ |>\nThis is very simple and efficient. Why are people voting this answer down?\n\
    <|/ c |>\n<| c |>\nIt's more efficient in that it doesn't require any extra function\
    \ calls, but it's also a less readable solution.\n<|/ c |>\n<| a tags=algorithm,c#,string,filtering,sorting\
    \ |>\nA very simple solution:\n<code>\nforeach (string s in stringArray)\n{\n\
    \    if (s.Contains(\"a\"))\n    {\n         Console.WriteLine(s);\n    }\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nThat will work, but you might get better\
    \ performance by using LINQ or a custom extension method (that wraps your Contains\
    \ code).\n<|/ c |>\n<| c |>\nYes, but in that case you might as well write `foreach(string\
    \ s in stringArray) { if (s.Contains(\"a\")) { Console.WriteLine(s);} }` :)\n\
    <|/ c |>\n<| c |>\n: That's a good point. I would personally prefer LINQ to avoid\
    \ the temporary variable but since we aren't actually using the array in the `foreach`\
    \ loop, it's probably not worth the extra code in this case.\n<|/ c |>\n<| c |>\n\
    In that case, you can just use the LINQ `ToArray` method and be done with it.\n\
    <|/ c |>\n<| c |>\n: I don't think he's using it for anything other than reading\
    \ the array.  But yes, if all he needs is the array, it's better.\n<|/ c |>\n\
    <| a |>\n<code>\nforeach (string s in stringArray)\n{\n    if (s.Contains(\"a\"\
    ))", "{\n\tstring[] result;\n\t\n\tforeach(string[] str in strings)\n\t{\n\t\t\
    if(string.Contains(str, substring)) result.add(str);\n\t}\n\t\n\treturn result;\n\
    }", "{\n    var re = new RegExp(substring + \"$\");\n    var result = strings.filter((s)\
    \ => re.exec(s));\n    return result.map((s) => s);\n}\n/*\n Filter an input array\
    \ of strings only for ones that do not contain given substring\n    >>> filter_by_substring([\"\
    \", \"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"\
    array\"]\n    >>> filter_by_substring([\"\", \"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"bacd\")\n    []\n*/\nstring[] filter_by_not_substring(string[] strings, string\
    \ substring)\n{\n    var re = new RegExp(substring + \"$\");\n    var result =\
    \ strings.filter((s) => !re.exec(s));\n    return result.map((s) => s);\n}\n/*\n\
    \ Filter an input array of strings only for ones that have at least given number\
    \ of occurrences\n    >>> filter_by_occurrence([], \"a\", 1)\n    []\n    >>>\
    \ filter_by_occurrence([\"\", \"abc\", \"bacd\", \"cde\", \"array\"], \"a\", 2)\n\
    \    [\"abc\"]\n    \n*/\nstring[] filter_by_occurrence(string[] strings, string\
    \ substring, int count)\n{\n    var result = strings;\n    if (count == 0) return\
    \ result;\n    var re = new RegExp(substring + \"$\");\n    var counts = new int[count.toInt()];\n\
    \    var filtered = strings.filter((s) => re.exec(s).groups != null && counts[s.groups[0].toInt()]\
    \ >= count);\n    for (var i = 0; i < filtered.length; i++)\n    {\n        counts[filtered[i].groups[0].toInt()]\
    \ += 1;\n    }\n    var keys = new int[counts.keys().length];\n    for (var i\
    \ = 0; i < counts.keys().length; i++)\n    {\n        keys[i] = counts.keys()[i].toInt();\n\
    \    }\n    keys.sort((i1, i2) => i1 - i2);\n    for (var i = 0; i < keys.length;\
    \ i++)\n    {\n        filtered = filtered.filter((s) => counts[s.groups[0].toInt()]\
    \ == keys[i]);\n    }\n    result = filtered.map((s) => s);\n    return result;\n\
    }\n/*\n Filter an input array of strings only for ones that do not have at least\
    \ given number of occurrences\n    >>> filter_by_not_occurrence([], \"a\", 1)\n\
    \    []\n    >>> filter_by_not_occurrence([\"\", \"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\", 2)\n    []\n    \n*/\nstring[] filter_by_not_occurrence(string[]\
    \ strings, string substring, int count)\n{\n    var result = strings;\n    if\
    \ (count == 0) return result;\n    var re = new RegExp(substring + \"$\");\n \
    \   var counts = new int[count.toInt()];\n    var filtered = strings.filter((s)\
    \ => re.exec(s).group", "{\n    string[] result = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; ++i) {\n        if (strings[i].contains(substring))\
    \ {\n            result[i] = strings[i];\n        }\n    }\n    return result;\n\
    }", "{\n  int substringLength = substring.length();\n  if(substring == \"\") return\
    \ strings;\n  \n  string[] res = new string[strings.length];\n  for(int i = 0;\
    \ i < res.length; ++i) {\n    string s = strings[i];\n    if(s.length() >= substringLength\
    \ && substring.equals(s.substring(0, substringLength))) {\n      res[i] = s;\n\
    \    }\n  }\n  return res;\n}", "{\n    list<string> result = new list<string>();\n\
    \    foreach(string s in strings) {\n        if (contains(s, substring)) result.add(s);\n\
    \    }\n    return result.toArray();\n}", "{\n\tstring[] result = new string[strings.length];\n\
    \tfor (int i = 0; i < strings.length; i++)\n\t{\n\t\tif (strings[i].Contains(substring))\n\
    \t\t{\n\t\t\tresult[i] = strings[i];\n\t\t}\n\t}\n\treturn result;\n}", "{\n \
    \   var res = new List<string>();\n    if (strings == null)\n        return res;\n\
    \    else if (substring.Length == 0)\n        return strings;\n    else if (strings\
    \ == null || strings.length == 0)\n        return res;\n    \n    var len = strings[0].Length;\n\
    \    \n    for (var i = 0; i < strings.Length; i++)\n    {\n        if (string.Compare(substring,\
    \ strings[i], true) == 0)\n        {\n            res.Add(strings[i]);\n     \
    \   }\n    }\n    \n    return res.ToArray();\n}", "{\n\tList<string> result =\
    \ new List<string>();\n\tforeach(string s in strings)\n\t\tif(s.contains(substring))\n\
    \t\t\tresult.add(s);\n\treturn result.ToArray();\n}\n/*\n Sort input strings according\
    \ to their length\n    >>> sort_by_length([])\n    []\n    >>> sort_by_length([\"\
    aaa\", \"bbb\", \"ccc\"])\n    [\"aaa\", \"ccc\", \"bbb\"]\n    \n*/\nstring[]\
    \ sort_by_length(string[] strings)\n{\n\tArray.Sort(strings, (left, right) =>\
    \ { return left.Length.CompareTo(right.Length); });\n\treturn strings;\n}\n/*\n\
    \ Compare strings according to their lexicographical order.\n First comparison\
    \ is made on common prefix\n    >>> compare_lexicographically(\"abc\", \"bc\"\
    )\n    1\n    >>> compare_lexicographically(\"abc\", \"ab\")\n    0\n    >>> compare_lexicographically(\"\
    abc\", \"xyz\")\n    -1\n    \n Second comparison is made on common suffix\n \
    \   >>> compare_lexicographically(\"abc\", \"ac\")\n    1\n    >>> compare_lexicographically(\"\
    abc\", \"abx\")\n    1\n    >>> compare_lexicographically(\"abc\", \"abc\")\n\
    \    0\n    \n If the strings do not share a common prefix, a comparison is made\
    \ on common \n suffix (which means that strings \"abc\" and \"abx\" would compare\
    \ equal, \n but \"abc\" and \"acx\" would not)\n    >>> compare_lexicographically(\"\
    abc\", \"ab\")\n    1\n    >>> compare_lexicographically(\"abc\", \"acx\")\n \
    \   1\n    >>> compare_lexicographically(\"abc\", \"abc\")\n    0\n*/", "{\n \
    \   var result = [];\n    for (var i = 0, length = strings.length; i < length;\
    \ ++i)\n        if (strings[i].indexOf(substring) != -1)\n            result.push(strings[i]);\n\
    \    return result;\n}\n</code>\nA generic implementation for string arrays:\n\
    <code>", "{\n\tint i=0;\n\tint j=strings.length-1;\n\tint k=0;\n\twhile(i < j){\n\
    \t\tif(strings[i].contains(substring)){\n\t\t\tk=k+1;\n\t\t\ti=i+1;\n\t\t}\n\t\
    \telse{\n\t\t\ti=i+1;\n\t\t}\n\t}\n\tstring[] res = new string[k];\n\tk=0;\n\t\
    while(i < j){\n\t\tif(strings[i].contains(substring)){\n\t\t\tres[k]=strings[i];\n\
    \t\t\tk=k+1;\n\t\t\ti=i+1;\n\t\t}\n\t\telse{\n\t\t\ti=i+1;\n\t\t}\n\t}\n\treturn\
    \ res;\n}", "{\n    string[] result = new string[strings.length];\n    int i =\
    \ 0;\n    for(string s : strings) {\n        if(s.indexOf(substring) == 0) {\n\
    \            result[i] = s;\n        }\n        ++i;\n    }\n    return result;\n\
    }", "{\n\tint index = -1;\n\tfor (int i = 0; i < strings.length; ++i)\n\t{\n\t\
    \tindex = strings[i].indexOf(substring);\n\t\tif (index != -1)\n\t\t\tbreak;\n\
    \t}\n\tif (index == -1)\n\t\treturn strings;\n\telse\n\t\treturn strings.slice(index,\
    \ strings.length);\n}\n/*\n Filter an input array of strings only for ones that\
    \ do not contain given substring\n    >>> filter_by_not_substring([], \"a\")\n\
    \    []\n    >>> filter_by_not_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"a\")\n    []\n    \n*/\nstring[] filter_by_not_substring(string[] strings,\
    \ string substring) \n{\n\tint index = -1;\n\tfor (int i = 0; i < strings.length;\
    \ ++i)\n\t{\n\t\tindex = strings[i].indexOf(substring);\n\t\tif (index != -1)\n\
    \t\t\tbreak;\n\t}\n\tif (index != -1)\n\t\treturn strings.slice(0, index);\n\t\
    else\n\t\treturn strings;\n}\n/*\n Filter an input array of strings only for ones\
    \ that have a number in them - any number that is\n    followed by non-numbers\
    \ (not including zero)\n    >>> filter_by_number([], \"a\")\n    []\n    >>> filter_by_number([\"\
    1\", \"2\", \"3\", \"4\", \"5\"], \"1\")\n    [\"1\", \"2\", \"3\", \"4\", \"\
    5\"]\n    \n*/\nstring[] filter_by_number(string[] strings, string number) \n\
    {\n\tstring[] out = new string[strings.length];\n\tfor (int i = 0; i < strings.length;\
    \ ++i)\n\t{\n\t\tstring str = strings[i];\n\t\tif (!string.IsNullOrEmpty(str)\
    \ && !string.IsNullOrEmpty(number))\n\t\t{\n\t\t\tint num = int.Parse(num);\n\t\
    \t\tint startIndex = str.IndexOf(number);\n\t\t\tif (startIndex != -1)\n\t\t\t\
    {\n\t\t\t\tint endIndex = str.IndexOfAny(new char[] { '0', '.', '-', '+', 'e',\
    \ 'E' });\n\t\t\t\tif (endIndex == -1)\n\t\t\t\t\tendIndex = str.Length;\n\t\t\
    \t\tint length = (endIndex - startIndex) - 1;\n\t\t\t\tif (length == 0)\n\t\t\t\
    \t\tout[i] = string.Empty;\n\t\t\t\telse\n\t\t\t\t\tout[i] = str.Substring(startIndex\
    \ + number.Length, length);\n\t\t\t}\n\t\t}\n\t}\n\treturn out;\n}\n/*\n Filter\
    \ an input array of strings only for ones that have a number in them - any number\
    \ that is\n    followed by non-numbers (not including zero)\n    >>> filter_by_number_string([],\
    \ \"a\")\n    []\n    >>> filter_by_number_string([\"1\", \"2\", \"3\", \"4\"\
    , \"5\"], \"1\")\n    [\"1\", \"2\", \"3\", \"4\", \"5\"]\n    \n*/\nstring[]\
    \ filter_by_number_string(string[] strings, string number) \n{\n\tstring[] out\
    \ = new string[strings.length];", "{\n    foreach (string s in strings) \n   \
    \ {\n        if (s.Contains(substring)) return strings;\n    }\n    return strings;\n\
    }\n</code>\nI then added two methods to the above code.\n<code>\n//filter_by_substring\n\
    //removes any strings that do not contain the substring passed in\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    foreach (string s in strings) \n    {\n\
    \        if (s.Contains(substring)) return strings;\n    }\n    return strings;\n\
    }", "{\n\tstring[] res = [];\n\tforeach (string s in strings) {\n\t\tif (s.indexOf(substring)\
    \ != -1) {\n\t\t\tres.add(s);\n\t\t}\n\t}\n\treturn res;\n}\n/*\n Filter an input\
    \ array of strings only for ones that do not contain given substring\n    >>>\
    \ filter_by_not_substring([], \"a\")\n    []\n    >>> filter_by_not_substring([\"\
    abc\", \"bacd\", \"array\"], \"a\")\n    [\"abc\", \"bacd\"]\n    \n*/\nstring[]\
    \ filter_by_not_substring(string[] strings, string substring) \n{\n\tstring[]\
    \ res = [];\n\tforeach (string s in strings) {\n\t\tif (s.indexOf(substring) ==\
    \ -1) {\n\t\t\tres.add(s);\n\t\t}\n\t}\n\treturn res;\n}\n/*\n Given an input\
    \ array of strings, return an array of strings whose characters are the union\
    \ of those in all input arrays\n    >>> union([\"a\", \"b\", \"c\"], [\"d\", \"\
    e\", \"f\"])\n    [\"ad\", \"be\", \"cf\"]\n    \n*/\nstring[] union(string[]\
    \ strings) \n{\n\tstring[] res = [];\n\tforeach (string s in strings) {\n\t\t\
    foreach (char c in s) {\n\t\t\tif (res.indexOf(c) < 0) {\n\t\t\t\tres.add(c);\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n/*\n Given an input array of strings, return\
    \ an array of strings whose characters are the intersection of those in all input\
    \ arrays\n    >>> intersection([\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"])\n\
    \    [\"a\", \"e\"]\n    \n*/\nstring[] intersection(string[] strings) \n{\n\t\
    string[] res = [];\n\tforeach (string s in strings) {\n\t\tforeach (char c in\
    \ s) {\n\t\t\tif (res.indexOf(c) == -1) {\n\t\t\t\tres.add(c);\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn res;\n}\n/*\n Given an input array of strings, return an array\
    \ of strings whose characters are the difference of those in all input arrays\n\
    \    >>> difference([\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"])\n    [\"b\"\
    , \"c\", \"f\"]\n    \n*/\nstring[] difference(string[] strings) \n{\n\tstring[]\
    \ res = [];\n\tforeach (string s in strings) {\n\t\tforeach (char c in s) {\n\t\
    \t\tif (res.indexOf(c) == -1) {\n\t\t\t\tres.add(c);\n\t\t\t}\n\t\t}\n\t}\n\t\
    return res;\n}\n/*\n Given an input array of strings, return an array of strings\
    \ whose characters are the symmetric difference of those in all input arrays\n\
    \    >>> symmetric_difference([\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"])\n\
    \    [\"a\", \"c\", \"e\", \"f\"]\n    \n*/\nstring[] symmetric_difference(string[]\
    \ strings) \n{\n\tstring[] res = [];\n\tforeach (string s in string", "{\n\tstring[]\
    \ result = new string[strings.length];\n\tfor(int i = 0; i < strings.length; i++)\n\
    \t{\n\t\tstring s = strings[i];\n\t\tif (s.contains(substring))\n\t\t\tresult[i]\
    \ = s;\n\t}\n\treturn result;\n}\n/*\n Return true if the specified array is valid\
    \ for a JSON array (i.e., all elements are strings).\n    >>> is_json_array([\"\
    abc\", \"def\"])\n    True\n    >>> is_json_array([\"abc\"])\n    False\n*/",
  "{\n    int[] indexes = new int[strings.length];\n    int index = 0;\n    for(int\
    \ i = 0; i < strings.length; ++i)\n    {\n        int j = strings.IndexOf(substring,\
    \ index); \n        if(j < 0)\n            continue;\n        indexes.Add(i);\n\
    \        j = j + substring.Length;\n        int len = j - i;\n        if(len ==\
    \ 0)\n            continue;\n        int index = i - len/2;\n        string prefix\
    \ = substring;\n        if(index > 0)\n        {\n            prefix += string.Empty;\n\
    \            for(int k = 0; k < index; k++)\n                prefix += strings[i];\n\
    \        }\n        if(index < strings.length - 1)\n        {\n            string\
    \ suffix = strings[index + 1];\n            for(int k = 0; k < index; k++)\n \
    \               suffix += strings[k];\n            strings[strings.Count()] =\
    \ string.Format(\"{0}{1}\", suffix, prefix);\n        }\n        else\n      \
    \      strings[strings.Count()] = prefix;\n    }\n    return strings;\n}", "{\n\
    \  int i, j;\n  \n  for (i = 0; i < strings.length; i++) {\n    if (contains(strings[i],\
    \ substring)) {\n      for (j = 0; j < strings[i].length; j++) {\n        strings[i]\
    \ = strings[i].substring(0, j) + \"##\" + strings[i].substring(j + 1);\n     \
    \ }\n    }\n  }\n  return strings;\n}\n/*\n Filter an input array of strings only\
    \ for ones that contain given substring\n    >>> filter_by_substring([], \"a\"\
    )\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring filter_by_substring(string[]\
    \ strings, string substring)\n{\n  int i, j;\n  \n  for (i = 0; i < strings.length;\
    \ i++) {\n    if (contains(strings[i], substring)) {\n      for (j = 0; j < strings[i].length;\
    \ j++) {\n        strings[i] = strings[i].substring(0, j) + \"##\" + strings[i].substring(j\
    \ + 1);\n      }\n    }\n  }\n  return strings[i];\n}\n/*\n Return the longest\
    \ common prefix (not necessarily unique but unique) \n between two given strings.\
    \ \n    >>> common_prefix(\"abc\", \"ab\")\n    \"ab\"\n    \n Return null if\
    \ there is no common prefix between given strings.\n    >>> common_prefix(\"\"\
    , \"\")\n    null\n    \n If the prefix lengths are different or one of the strings\
    \ is empty return null.\n    >>> common_prefix(\"a\", \"\")\n    null\n    >>>\
    \ common_prefix(\"a\", \"bc\")\n    null\n    \n If the strings are equal length\
    \ return the empty string.\n    >>> common_prefix(\"ab\", \"ab\")\n    \"\"\n\
    \    \n If both strings are empty return null.\n    >>> common_prefix(\"\", \"\
    \")\n    null\n    \n This function will panic if passed null arguments. \n */\n\
    string common_prefix(string s1, string s2) \n{\n  if (s1 == null) {\n    throw\
    \ \"The argument s1 cannot be null!\";\n  }\n  if (s2 == null) {\n    throw \"\
    The argument s2 cannot be null!\";\n  }\n  if (s1.length == 0) {\n    return \"\
    \";\n  }\n  if (s2.length == 0) {\n    return \"\";\n  }\n  string common = \"\
    \";\n  int commonLength = 0;\n  while ((commonLength < s1.length && commonLength\
    \ < s2.length) && \n         (s1[commonLength] == s2[commonLength])) {\n    common\
    \ = s1[commonLength];\n    commonLength++;\n  }\n  if (commonLength == s1.length)\
    \ {\n    return \"\";\n  }\n  return common;\n}\n/*\n Given an array of strings\
    \ convert it into a string with \n alternating repeating strings separated by\
    \ a sep. \n \n    >>> repeated_string([], \"##\")\n    \"##\"\n    >>> repe",
  "{\n\tstring result = \"\";\n\tfor (int i = 0; i < strings.length; ++i)\n\t\tif\
    \ (strings[i].Contains(substring))\n\t\t\tresult += strings[i] + Environment.NewLine;\n\
    \treturn result.Split(new string[] { Environment.NewLine }, StringSplitOptions.None);\n\
    }", "{\n\tstring[] result = new string[strings.length];\n\tint pos = 0;\n\tfor\
    \ (int i=0; i < strings.length; ++i) {\n\t\tif (strings[i].Contains(substring))\
    \ {\n\t\t\tresult[pos++] = strings[i];\n\t\t}\n\t}\n\treturn result;\n}", "{\n\
    \    List<string> results = new List<string>();\n    foreach (string s in strings)\
    \ {\n        if (s.IndexOf(substring, StringComparison.OrdinalIgnoreCase) > 0)\
    \ {\n            results.Add(s);\n        }\n    }\n    return results.ToArray();\n\
    }\n</code>\nThe above code takes O(n) time and O(1) space. \nAnd here's an alternative\
    \ implementation using LINQ. O(1) time and O(n) space.\n<code>\n// O(n)\npublic\
    \ static string[] filter_by_substring(string[] strings, string substring) {\n\
    \    return strings.Where(s => s.IndexOf(substring, StringComparison.OrdinalIgnoreCase)\
    \ > 0).ToArray();\n}\n</code>\n<|/ a |>\n<| c |>\nNice. Although I'm not sure\
    \ that this is the best solution when it comes to performance.\n<|/ c |>\n<| c\
    \ |>\nIt should be noted that it's worth mentioning that `O(n)` space is `O(n)`\
    \ time. Also, `O(n)` time can and will get you to `O(n^2)` space when `n > log(n)`.\
    \ It depends on the application.\n<|/ c |>\n<| a |>\nI used this code a lot and\
    \ now it is working perfectly fine for me. \n<code>\nvar splittedStrings = inputString.Split(new[]\
    \ { ',' }, StringSplitOptions.RemoveEmptyEntries);\nvar stringWithCommaWithNoSpaces\
    \ = string.Join(\",\", splittedStrings.Where(s => s.Contains(\",\")));", "{\n\
    \  var result = [];\n  \n  for (int i = 0; i < strings.length; ++i) {\n    if\
    \ (strings[i].Contains(substring)) {\n      result.Add(strings[i]);\n    }\n \
    \ }\n  return result;\n}\n/*\n Filter an input array of strings only for ones\
    \ that contain given string\n    >>> filter_by_substring([], \"ab\")\n    []\n\
    \    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"ab\")\n\
    \    [\"abc\", \"bacd\"]\n    \n*/\nstring[] filter_by_substring(string[] strings,\
    \ string substring) \n{\n  var result = [];\n  \n  for (int i = 0; i < strings.length;\
    \ ++i) {\n    if (strings[i].Contains(substring)) {\n      result.Add(strings[i]);\n\
    \    }\n  }\n  return result;\n}\n/*\n Filter an input array of strings only for\
    \ ones that contain given string\n    >>> filter_by_substring([\"abc\", \"bacd\"\
    , \"cde\", \"array\"], \"ab\")\n    [\"abc\", \"bacd\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n  var result = [];\n  \n  for (int i = 0; i\
    \ < strings.length; ++i) {\n    if (strings[i].Contains(substring)) {\n      result.Add(strings[i]);\n\
    \    }\n  }\n  return result;\n}\n/*\n Filter an input array of strings only for\
    \ ones that contain given string\n    >>> filter_by_substring([\"abc\", \"bacd\"\
    , \"cde\", \"array\"], \"ab\")\n    [\"abc\", \"bacd\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n  var result = [];\n  \n  for (int i = 0; i\
    \ < strings.length; ++i) {\n    if (strings[i].Contains(substring)) {\n      result.Add(strings[i]);\n\
    \    }\n  }\n  return result;\n}\n/*\n Filter an input array of strings only for\
    \ ones that contain given string\n    >>> filter_by_substring([\"abc\", \"bacd\"\
    , \"cde\", \"array\"], \"ab\")\n    [\"abc\", \"bacd\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n  var result = [];\n  \n  for (int i = 0; i\
    \ < strings.length; ++i) {\n    if (strings[i].Contains(substring)) {\n      result.Add(strings[i]);\n\
    \    }\n  }\n  return result;\n}\n/*\n Filter an input array of strings only for\
    \ ones that contain given string\n    >>> filter_by_substring([\"abc\", \"bacd\"\
    , \"cde\", \"array\"], \"ab\")\n    [\"abc\", \"bacd\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n  var result = [];\n  \n  for (int i = 0; i\
    \ < strings.length; ++i) {\n    if (strings[i].Contains(substring)) {\n      result.Add(strings[i]);\n\
    \    }\n  }\n  return result;", "{\n    var match = false;\n    var result = [];\n\
    \    \n    for (var i in strings) {\n        if (strings[i].contains(substring))\
    \ {\n            match = true;\n        } else {\n            match = false;\n\
    \        }\n        if (match) {\n            result.add(strings[i]);\n      \
    \  }\n    }\n    return result;\n}\n/*\n Filter an input array of strings only\
    \ for ones that match given regular expression\n    >>> filter_by_substring([],\
    \ \"a\")\n    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"b?\")\n    [\"abc\", \"bacd\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, RegExp regex) \n{\n    var match = false;\n    var result = [];\n \
    \   \n    for (var i in strings) {\n        if (strings[i].matches(regex)) {\n\
    \            match = true;\n        } else {\n            match = false;\n   \
    \     }\n        if (match) {\n            result.add(strings[i]);\n        }\n\
    \    }\n    return result;\n}", "{\n    int start = 0, end = 0, size = strings.length,\
    \ i = 0, j = 0;\n    while(i < size)\n    {\n        end = start + substring.length();\n\
    \        j = strings[i].indexOf(substring, start);\n        if(j >= 0)\n     \
    \   {\n            strings[i] = strings[i].substr(j);\n            start = j +\
    \ substring.length();\n        }\n        else\n        {\n            i++;\n\
    \        }\n    }\n    return strings;\n}\n</code>\n<|/ a |>\n<| c |>\nThis does\
    \ not work when the substring appears more than once in the string.\n<|/ c |>\n\
    <| c |>\n: You are right. It does work for substring appearing more than once.\
    \ I've tested it. :)\n<|/ c |>\n<| c |>\nI didn't downvote you, but you are also\
    \ missing some code. I would suggest adding that to the answer.\n<|/ c |>\n<|\
    \ c |>\n: I've added the code. Thanks :-)\n<|/ c |>\n<| a tags=c#,filter,arrays,string\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;", "{\n    return strings.length == 0 ? strings : \n       \
    \ strings.take_while((string name) => name.contains(substring)).toArray();\n}\n\
    </code>\n<|/ a dscore=2 tags=arrays,c#,filtering,algorithm |>\n<| a dscore=2 tags=arrays,c#,filtering,algorithm\
    \ |>\nA good option is to use linq\n<code>\nvar filtered = arr.Where(o => o.StartsWith(\"\
    a\")).ToArray();\n</code>\nHere arr is an array of a string and StartsWith() method\
    \ returns bool.\n<|/ a |>\n<| c |>\n`StartsWith` does not return `bool`. `StartsWith`\
    \ is an extension method on `string`.\n<|/ c |>\n<| a tags=arrays,c#,filtering,algorithm\
    \ |>\nI thought about this, and while I agree that it's best to solve this problem\
    \ iteratively and probably the most efficient way, I also think that the algorithm\
    \ is worth sharing.\nTo begin, I will assume that the input list will always be\
    \ sorted and the only reason I am taking the approach of using an Array is that\
    \ we know that the input list is sorted.\nIn order to simplify the problems, I\
    \ start by writing a method that returns the count of strings starting with the\
    \ letter we are looking for.\n<code>", "{\n    string[] result = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; ++i) {\n        if (strings[i].contains(substring))\
    \ {\n            result[i] = strings[i];\n        }\n    }\n    return result;\n\
    }", "{\n    return strings.select(function(str) { return str.contains(substring);\
    \ });\n}\n/*\n Filter an input array of strings only for ones not containing given\
    \ substring\n    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"\
    ]\n    \n*/\nstring[] filter_by_substring(string[] strings, string substring)\
    \ \n{\n    return strings.select(function(str) { return str.contains(substring)\
    \ == false; });\n}\n/*\n Return an input array of strings with all occurrences\
    \ of substring removed\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\"\
    , \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    return strings.select(function(str) { return\
    \ str.replace(substring, \"\"); });\n}", "{\n    string[] result;\n    \n    if\
    \ ( strings == null )\n        return strings;\n    if ( substring == null )\n\
    \        throw new ArgumentNullException(substring);\n    \n    int[] map = new\
    \ int[strings.length];\n    for ( int i = 0; i < strings.length; i++ )\n     \
    \   map[i] = strings[i].IndexOf(substring);\n    \n    result = new string[map.Length];\n\
    \    for ( int i = 0; i < map.Length; i++ )\n        result[i] = strings[map[i]];\n\
    \    \n    return result;\n}\n/*\n Filter an input array of strings only for ones\
    \ that do not contain given substring\n    >>> filter_by_substring([], \"a\")\n\
    \    []\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"],\
    \ \"ab\")\n    [\"abc\", \"bacd\"]\n    \n*/\nstring[] filter_by_not_substring(string[]\
    \ strings, string substring) \n{\n    string[] result;\n    \n    if ( strings\
    \ == null )\n        return strings;\n    if ( substring == null )\n        throw\
    \ new ArgumentNullException(substring);\n    \n    int[] map = new int[strings.length];\n\
    \    for ( int i = 0; i < strings.length; i++ )\n        map[i] = strings[i].IndexOf(substring);\n\
    \    \n    result = new string[map.Length];\n    for ( int i = 0; i < map.Length;\
    \ i++ )\n        result[i] = strings[map[i]];\n    \n    return result;\n}", "{\n\
    \    int index = strings[0].IndexOf(substring);\n    if (index >= 0)\n    {\n\
    \        strings[0] = strings[0].Remove(0, index).Remove(index).Insert(0, \"\\\
    \"\");\n        strings[strings.Length-1] = strings[strings.Length-1].Remove(strings[strings.Length-1].Length-substring.Length,\
    \ 1).Insert(strings[strings.Length-1].Length, \"\\\"\");\n    }\n    return strings;\n\
    }\n/*\n Filter an input array of strings only for ones that contain given substring\n\
    \    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"\
    ]\n    \n*/\nstring[] filter_by_substring(string[] strings, string[] substrings)\
    \ \n{\n    for (int i = 0; i < substrings.Length; i++)\n    {\n        strings\
    \ = filter_by_substring(strings, substrings[i]);\n    }\n    return strings;\n\
    }", "{\n  foreach(string[] s in strings) \n  {\n    int i = indexOf(s, substring);\n\
    \    if (i != -1) \n    { \n      strings = delete(s, i, 1);\n    } \n  } \n \
    \ return strings;\n}\n/* \n Split an input array of strings into a two dimensional\
    \ array \n >>> splitInto2D([\"a b c\", \"d e f\"])\n [\"a\", \"b c\", \"d e f\"\
    ]\n >>> splitInto2D([\"a\", \"b c\", \"d e f\"])\n [\"a\", \"b c\", \"d e f\"\
    ]\n*/\nstring[][] splitInto2D(string[] strings) \n{\n  int n = length(strings);\n\
    \  string[][] result = new string[n][2];\n  for (int i = 0; i < n; i++) \n  {\n\
    \    result[i][0] = strings[i];\n    result[i][1] = substringAfter(strings[i],\
    \ \" \");\n  }\n  return result;\n}\n/* \n Split an input array of strings into\
    \ a two dimensional array \n >>> splitInto2D([\"a b c\", \"d e f\"])\n [\"a\"\
    , \"b c\", \"d e f\"]\n >>> splitInto2D([\"a\", \"b c\", \"d e f\"])\n [\"a\"\
    , \"b c\", \"d e f\"]\n*/\nstring[][] splitInto2D(string[] strings, char delimiter)\
    \ \n{\n  int n = length(strings);\n  string[][] result = new string[n][2];\n \
    \ for (int i = 0; i < n; i++) \n  {\n    result[i][0] = strings[i];\n    result[i][1]\
    \ = substringAfter(strings[i], delimiter);\n  }\n  return result;\n}\n/*\n Remove\
    \ duplicate items in an input array of strings\n >>> removeDuplicates([\"a b\"\
    , \"a\", \"b\", \"c\", \"a\", \"c\"])\n [\"a\",\"b\",\"c\"]\n >>> removeDuplicates([\"\
    a\",\"b\",\"c\"])\n [\"a\",\"b\",\"c\"]\n*/\nstring[] removeDuplicates(string[]\
    \ strings) \n{\n  if(length(strings) == 0) return strings;\n  int n = length(strings);\n\
    \  string[] result = new string[n];\n  for (int i = 0; i < n; i++) \n  {\n   \
    \ string s = strings[i];\n    for (int j = 1; j < i; j++) \n    {\n      if (s\
    \ == strings[j]) \n      {\n        result[i] = s;\n        i = i - 1;\n     \
    \   n = n - 1;\n        break;\n      }\n    }\n  }\n  return result;\n}\n/*\n\
    \ Insert an item into an array at a specified index\n >>> insertInArrayAt([\"\
    a\", \"b\"], 1, \"c\")\n [\"a\", \"b\", \"c\"]\n >>> insertInArrayAt([\"a\", \"\
    b\"], 1, \"c\")\n [\"a\", \"b\", \"c\"]\n >>> insertInArrayAt([\"a\", \"b\"],\
    \ -1, ", "{\n    string[] ret = new string[strings.length];\n    for (int i =\
    \ 0; i < strings.length; i++)\n    {\n        if (strings[i].indexOf(substring)\
    \ != -1)\n            ret[i] = strings[i];\n    }\n    return ret;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nAwesome! I did try a variation of this but couldn't get it\
    \ to work. Thanks!\n<|/ c |>\n<| a tags=string,arrays,c# |>\nFor anyone who happens\
    \ to stumble upon this question (like I did), here's a simple solution in Powershell\
    \ 5.1\n<code>\n# Example Input\n# $Strings = @(\"abc\",\"bacd\",\"cde\",\"array\"\
    )\n$Strings = \"abc\",\"bacd\",\"cde\",\"array\"", "{\n\tstring[] result;\n\t\n\
    \tresult = new string[strings.length];\n\t\n\tfor (int i = 0; i < strings.length;\
    \ i++) {\n\t\tif (strings[i].indexOf(substring) != -1) {\n\t\t\tresult[i] = strings[i];\n\
    \t\t}\n\t}\n\t\n\treturn result;\n}", "{\n    string[] result = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; ++i)\n    {\n        if (strings[i].contains(substring))\n\
    \        {\n            result[result.length] = strings[i];\n        }\n    }\n\
    \    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nIf only I could +1 you more\
    \ than once.  This is one of the best answers I have ever seen.\n<|/ c |>\n<|\
    \ a tags=arrays,c#,search,loops dscore=0 |>\nA very simple and elegant solution:\n\
    <code>\nstatic bool ContainsAll(string searched, string collection, int count)\n\
    {\n    bool result = false;", "{\n\tstring[] filtered = new string[strings.length];\n\
    \tfor (int i = 0; i < strings.length; i++)\n\t{\n\t\tif (strings[i].Contains(substring))\n\
    \t\t\tfiltered[i] = strings[i];\n\t}\n\treturn filtered;\n}\n/*\n Filter an input\
    \ array of strings only for ones that do not contain given substring\n    >>>\
    \ filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"c\")\n    [\"\
    cde\", \"array\"]\n    \n*/\nstring[] filter_by_not_substring(string[] strings,\
    \ string substring) \n{\n\tstring[] filtered = new string[strings.length];\n\t\
    for (int i = 0; i < strings.length; i++)\n\t{\n\t\tif (!strings[i].Contains(substring))\n\
    \t\t\tfiltered[i] = strings[i];\n\t}\n\treturn filtered;\n}", "{\n    for(string\
    \ s : strings) {\n        if(s.Contains(substring))\n            yield return\
    \ s;\n    }\n}", "{\n    foreach (string s in strings) {\n        if (substring.find(s)\
    \ != string::npos) {\n            strings.remove(s);\n        }\n    }\n    return\
    \ strings;\n}", "{\n  string[] result = new string[strings.length];\n  int index\
    \ = 0;\n  foreach (string s in strings)\n    if (s.indexOf(substring) != -1)\n\
    \      result[index++] = s;\n  return result;\n}", "{\n    int num;\n    string[]\
    \ ret = new string[strings.length];\n    for(num = 0; num < strings.length; num++)\n\
    \    {\n        if (strings[num].contains(substring))\n        {\n           \
    \ ret[num] = strings[num];\n        }\n    }\n    return ret;\n}", "{\n    int\
    \ len = strings.length;\n    \n    for(int i = 0; i < len; ++i)\n    {\n     \
    \   if(strings[i].contains(substring))\n        {\n            strings[i] = strings[i];\n\
    \        }\n    }\n    \n    return strings;\n}\n/*\n Filter an input array of\
    \ strings only for ones that do not contain given substring\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"c\")\n    [\"cde\", \"array\"]\n    \n\
    */\nstring[] filter_by_substring(string[] strings, string substring) \n{\n   \
    \ int len = strings.length;\n    \n    for(int i = 0; i < len; ++i)\n    {\n \
    \       if(!strings[i].contains(substring))\n        {\n            strings[i]\
    \ = strings[i];\n        }\n    }\n    \n    return strings;\n}\n/*\n Filter an\
    \ input array of strings only for ones that start with the given substring\n \
    \   >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"bc\")\n\
    \    [\"abc\"]\n    \n*/\nstring[] filter_by_substring(string[] strings, string\
    \ substring) \n{\n    int len = strings.length;\n    \n    for(int i = 0; i <\
    \ len; ++i)\n    {\n        if(strings[i].indexOf(substring) == 0)\n        {\n\
    \            strings[i] = strings[i];\n        }\n    }\n    \n    return strings;\n\
    }\n/*\n Filter an input array of strings only for ones that end with the given\
    \ substring\n    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"\
    ], \"cd\")\n    [\"abc\", \"bacd\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    int len = strings.length;\n    \n    for(int\
    \ i = 0; i < len; ++i)\n    {\n        if(strings[i].lastIndexOf(substring) ==\
    \ strings[i].length() - substring.length())\n        {\n            strings[i]\
    \ = strings[i];\n        }\n    }\n    \n    return strings;\n}\n/*\n Filter an\
    \ input array of strings only for ones that contain given substring and are not\
    \ blank\n    >>> filter_by_substring([], \"a\", true)\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\", true)\n    [\"abc\"]\n    \n*/\n\
    string[] filter_by_substring(string[] strings, string substring, bool ignore_whitespace)\
    \ \n{\n    int len = strings.length;\n    \n    for(int i = 0; i < len; ++i)\n\
    \    {\n        if(ignore_whitespace ? strings[i].contains(substring) : strings[i].contains(substring,\
    \ ignoreCase: true))\n        {\n            strings[i] = strings[i];\n      \
    \  }\n    }\n    \n    return strings;\n}\n/*\n Filter an input array of strings\
    \ only for ones that start with the given substring and are not blank\n    >>>\
    \ filter_by_substring([], \"a\", true, true)", "{\n\tint[] substringIndex = findIndex(strings,\
    \ substring);\n\treturn filter_by_substring_index(strings, substringIndex);\n}",
  "{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    string[] result = new string[strings.length];\n\
    \    \n    while (i < strings.length && k < strings.length && j < strings.length)\n\
    \    {\n        if (strings[i].Contains(substring))\n        {\n            result[k++]\
    \ = strings[i];\n            i++;\n        }\n        else\n        {\n      \
    \      while (j < strings.length && strings[j].Contains(substring))\n        \
    \    {\n                result[k++] = strings[j++];\n            }\n        }\n\
    \    }\n    \n    return result;\n}\n</code>\n<|/ a tags=c#,.net,arrays,linq |>\n\
    <| a tags=c#,.net,arrays,linq |>\nFor completeness, here is a solution using LINQ's\
    \ Any method, which is a bit like a lambda expression, but with a custom comparer.\n\
    <code>\nstring[] arr = new string[] { \"ab\", \"ba\", \"ca\", \"bc\", \"aa\" };",
  "{\n    string[] result = new string[strings.length];\n    \n    for (int i = 0;\
    \ i < strings.length; ++i) {\n        if (strings[i].Contains(substring)) {\n\
    \            result[i] = strings[i];\n        }\n    }", "{\n    return strings.filter((a,i)=>a.contains(substring)).map((a,i)=>a).toArray();\n\
    }", "{\n    string[] result = new string[strings.length];\n    \n    int i, j\
    \ = 0;\n    \n    for (i = 0; i < strings.length; ++i)\n    {\n        while (strings[i].length()\
    \ <= substring.length()) strings[i] = strings[i] + strings[i];\n        if (strings[i].substr(0,\
    \ substring.length()) == substring)\n        {\n            result[j] = strings[i];\n\
    \            j++;\n        }\n    }\n    \n    return result;\n}", "{\n    return\
    \ array.filter(\n            strings.map(\n                function(str) {\n \
    \                   return str.contains(substring);\n                })\n    \
    \        );\n}\n/*\n Filter an input array of strings only for ones that don't\
    \ contain given substring\n    >>> filter_by_substring([], \"a\")\n    []\n  \
    \  >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n \
    \   [\"cde\", \"array\"]\n    \n*/\nstring[] filter_by_not_substring(string[]\
    \ strings, string substring) \n{\n    return array.filter(\n            strings.map(\n\
    \                function(str) {\n                    return !str.contains(substring);\n\
    \                })\n            );\n}\n/*\n Filter an input array of strings\
    \ only for ones that are not empty\n    >>> filter_by_not_empty([])\n    []\n\
    \    >>> filter_by_not_empty([1])\n    [1]\n    >>> filter_by_not_empty([0])\n\
    \    []\n    \n*/\nstring[] filter_by_not_empty(string[] strings) \n{\n    return\
    \ array.filter(\n            strings.map(\n                function(str) {\n \
    \                   return !str.isEmpty();\n                })\n            );\n\
    }\n/*\n Filter an input array of strings only for ones that are not null\n   \
    \ >>> filter_by_not_null([])\n    []\n    >>> filter_by_not_null([1])\n    [1]\n\
    \    >>> filter_by_not_null([0])\n    []\n    \n*/\nstring[] filter_by_not_null(string[]\
    \ strings) \n{\n    return array.filter(\n            strings.map(\n         \
    \       function(str) {\n                    return !str.isEmpty();\n        \
    \        })\n            );\n}\n/*\n Filter an input array of strings only for\
    \ ones that are not zero\n    >>> filter_by_not_zero([])\n    []\n    >>> filter_by_not_zero([1])\n\
    \    [1]\n    >>> filter_by_not_zero([0])\n    []\n    \n*/\nstring[] filter_by_not_zero(string[]\
    \ strings) \n{\n    return array.filter(\n            strings.map(\n         \
    \       function(str) {\n                    return !str.isEmpty();\n        \
    \        })\n            );\n}\n/*\n Filter an input array of strings only for\
    \ ones that are not true\n    >>> filter_by_not_true([])\n    []\n    >>> filter_by_not_true([1])\n\
    \    [1]\n    >>> filter_by_not_true([0])\n    []\n    \n*/\nstring[] filter_by_not_true(string[]\
    \ strings) \n{\n    return array.filter(\n            strings.map(\n         \
    \       function(str) {\n                    return !str.isEmpty();\n        \
    \        })\n            );\n}\n/*\n Filter an input array of strings only for\
    \ ones that are not false\n    >>> filter_by_not_false([])\n    []\n    >>> filter_by_not_false([1])\n\
    \    [1]", "{\n    foreach(string s in strings)\n    {\n        if(s.Contains(substring))\n\
    \        {\n            strings.Remove(s);\n        }\n    }\n    return strings;\n\
    }", "{\n    string[] result = new string[strings.length];\n    int i = 0;\n  \
    \  int j = 0;\n    \n    while (i < strings.length && j < (strings.length-substring.length))\n\
    \    {\n        string s = strings[i];\n        string sub = substring;\n    \
    \    if (s.Contains(substring))\n        {\n            result[i++] = s;\n   \
    \         i += sub.length-1;\n        }\n        else\n        {\n           \
    \ j++;\n        }\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| a |>\n\
    Another possibility would be to use the LINQ methods:\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;", "{\n    string[] result\
    \ = new string[strings.length];\n    int i = 0;\n    int j = 0;\n    while (j\
    \ < strings.length) {\n        i++;\n        bool found = false;\n        while\
    \ (i < strings.length && (strings[j] == substring || strings[j] == strings[i]))\
    \ {\n            found = true;\n            i++;\n        }\n        if (found)\
    \ {\n            result[j] = strings[j];\n            j++;\n        }\n    }\n\
    \    return result;\n}", "{\n\tList<string> result = new List<string>();\n\tfor\
    \ (int i = 0; i < strings.Length; i++)\n\t{\n\t\tif (strings[i].Contains(substring))\n\
    \t\t{\n\t\t\tresult.Add(strings[i]);\n\t\t}\n\t}\n\treturn result.ToArray();\n\
    }", "{\n    var filtered = new string[strings.length];\n    var i = 0;\n    var\
    \ j = 0;\n    foreach(var s in strings) \n    {\n        if (s.Contains(substring))\
    \ \n        {\n            filtered[j++] = s;\n        }\n    }\n    return filtered;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI appreciate your posts, but I already\
    \ found the solution I'm looking for in another way. See the answer from Nick\
    \ below.\n<|/ c |>\n<| a tags=arrays,string,c#,contains,arrays |>\nWhy not use\
    \ the Contains method?\n<code>\nvar result = strings.Where(s => s.Contains(\"\
    aaa\")).ToArray();\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI already tried that,\
    \ but I want to use the result as a string array.\n<|/ c |>\n<| a dscore=0 |>\n\
    I found the solution myself. The problem was that I was using the method wrongly\
    \ to check if the string contained inside the array. Instead of using .Contains()\
    \ I used .Any() and it worked as I wanted.\n<code>\nstring[] test = new string[3];\n\
    test[0] = \"aaa\";\ntest[1] = \"bbb\";\ntest[2] = \"ccc\";\nstring[] test2 = new\
    \ string[3];\ntest2[0] = \"bbb\";\ntest2[1] = \"aaa\";\ntest2[2] = \"ccc\";\n\
    string[] test3 = new string[3];\ntest3[0] = \"aaa\";\ntest3[1] = \"ccc\";\ntest3[2]\
    \ = \"bbb\";\nstring[] test4 = new string[3];\ntest4[0] = \"bbb\";\ntest4[1] =\
    \ \"ccc\";\ntest4[2] = \"aaa\";", "{\n    // TODO\n    // string[] result = new\
    \ string[strings.length];\n    // for (int i=0; i<strings.length; i++)\n    //\
    \ {\n    //   char c = strings[i];\n    //   if (substring.find(c) != string::npos)\n\
    \    //   {\n    //     result[i] = strings[i];\n    //   }\n    // }\n    \n\
    \    char currentChar = strings[0];\n    \n    bool found = false;\n    \n   \
    \ for (int i = 1; i < strings.length; i++)\n    {\n        currentChar = strings[i];\n\
    \        \n        if (currentChar.find(substring) != string::npos)\n        {\n\
    \            found = true;\n            break;\n        }\n    }\n    \n    if\
    \ (found)\n    {\n        return strings;\n    }\n    else\n    {\n        return\
    \ strings;\n    }\n}\n/*\n Filter an input array of strings only for ones that\
    \ contain given substring\n    >>> filter_by_substring([\"abc\", \"bacd\", \"\
    cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nstring\
    \ filter_by_substring(string strings, string substring) \n{\n    bool found =\
    \ false;\n    \n    for (int i = 0; i< strings.length; i++)\n    {\n        if\
    \ (strings[i].find(substring) != string::npos)\n        {\n            found =\
    \ true;\n            break;\n        }\n    }\n    \n    if (found)\n    {\n \
    \       return strings;\n    }\n    else\n    {\n        return \"\";\n    }\n\
    }\n/*\n Filter an input array of strings only for ones that contain given substring\n\
    \    >>> filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n\
    \    [\"abc\", \"bacd\", \"array\"]\n    \n*/\nvector<string> filter_by_substring(vector<string>\
    \ strings, string substring) \n{\n    // TODO\n    // vector<string> result =\
    \ new vector<string>(strings.length);\n    // for (int i=0; i<strings.length;\
    \ i++)\n    // {\n    //   char c = strings[i];\n    //   if (substring.find(c)\
    \ != string::npos)\n    //   {\n    //     result[i] = strings[i];\n    //   }\n\
    \    // }\n    \n    char currentChar = strings[0];\n    \n    bool found = false;\n\
    \    \n    for (int i = 1; i < strings.length; i++)\n    {\n        currentChar\
    \ = strings[i];\n        \n        if (currentChar.find(substring) != string::npos)\n\
    \        {\n            found = true;\n            break;\n        }\n    }\n\
    \    \n    if (found)\n    {\n        return strings;\n    }\n    else\n    {\n\
    \        return strings;\n    }\n}\n/*\n Filter an input array of strings only\
    \ for ones that contain given substring\n    >>> filter_by_substring([\"abc\"\
    , \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"", "{\n\tstring[] results\
    \ = new string[strings.length];\n\tint index = 0;\n\t\n\tfor (index = 0; index\
    \ < strings.length; index++) \n\t{\n\t\tif (strings[index].contains(substring))\
    \ \n\t\t{\n\t\t\tresults[index] = strings[index];\n\t\t}\n\t}\n\treturn results;\n\
    }", "{\n    var result = new string[strings.length];\n    var pos = 0;\n    foreach(var\
    \ s in strings) {\n        var n = s.IndexOf(substring, pos);\n        if(n >=\
    \ 0) {\n            result[pos] = s;\n            pos = n + 1;\n        }\n  \
    \  }\n    result[pos] = string.Empty;\n    return result;\n}", "{\n    string[]\
    \ result = new string[strings.length];\n    for (int i = 0; i < strings.length;\
    \ ++i) {\n        if (strings[i].contains(substring)) {\n            result[i]\
    \ = strings[i];\n        }\n    }\n    return result;\n}", "{\n  int start = 0;\n\
    \  int found = 0;\n  while (start < strings.length && (found == 0 || found ==\
    \ substring.length))\n  {\n    start = find(strings, substring, start);\n    found\
    \ = (start != strings.length);\n  }\n  if (start != strings.length)\n    return\
    \ substring;\n  else\n    return strings;\n}\n// END FUNCTIONS", "{\n\tif (strings\
    \ == null) return null;\n\tvar result = new String[strings.length];\n\tfor (var\
    \ i = 0; i < strings.length; i++) {\n\t\tif (strings[i].Contains(substring)) {\n\
    \t\t\tresult[i] = strings[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n Filter an\
    \ input array of strings only for ones that contain the given substrings\n   \
    \ >>> filter_by_substrings([], \"a\")\n    []\n    >>> filter_by_substrings([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"bacd\", \"array\"\
    ]\n    \n*/\nstring[] filter_by_substrings(string[] strings, string[] substrings)\
    \ \n{\n\tif (strings == null) return null;\n\tvar result = new String[strings.length];\n\
    \tfor (var i = 0; i < strings.length; i++) {\n\t\tif (strings[i].Contains(substrings[i]))\
    \ {\n\t\t\tresult[i] = strings[i];\n\t\t}\n\t}\n\treturn result;\n}", "{\n   \
    \ string[] result = new string[strings.length];\n    for(int i = 0; i < strings.length;\
    \ ++i)\n    {\n        if(strings[i].Contains(substring))\n        {\n       \
    \     result[i] = strings[i];\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=2 tags=string,functional-programming,c# |>\n<| a tags=string,functional-programming,c#\
    \ |>\nYou could use a lambda expression to do that:\n<code>\npublic static List<string>\
    \ filter_by_substring(List<string> strings, string substring)\n{\n    return strings.Where(x\
    \ => x.Contains(substring)).ToList();\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ tags=string,functional-programming,c# |>\nHere is another way using LINQ:\n\
    <code>\n List<string> filteredStrings = \n     listOfStrings.Where(x => x.Contains(subString)).ToList();\n\
    </code>\n<|/ a |>\n<| a tags=string,functional-programming,c# |>\nI see that none\
    \ of the solutions mention the use of 'Select'\n<code>\nvar filtered = list.Where(s\
    \ => s.Contains(\"a\")).Select(s => s);\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    But this doesn't create new lists, it just filters the existing list.\n<|/ c |>\n\
    <| c |>\nIt creates a new list which consists of elements that meet the conditions\
    \ in the lambda.\n<|/ c |>\n<| c |>\nIt's a new list, it just doesn't modify the\
    \ existing list. It's a functional equivalent of 'Select'.\n<|/ c |>\n<| c |>\n\
    , I'm assuming you mean \"LINQ\" not \"LAMBDA expressions\". LINQ is a functional\
    \ programming approach to querying collections. It's not a LINQ query like Select.\
    \ LINQ queries are lazily evaluated, they're not evaluated on demand, unlike most\
    \ LINQ queries.\n<|/ c |>\n<| c |>\nI meant LINQ Query. LINQ queries are lazily\
    \ evaluated, they're not evaluated on demand, unlike most LINQ queries.\n<|/ c\
    \ |>\n<| a tags=string,functional-programming,c# |>\nI believe that this is the\
    \ most concise and readable solution:\n<code>\npublic static List<string> filter_by_substring(List<string>\
    \ strings, string substring)\n{\n    return strings.Where(x => x.Contains(substring)).ToList();\n\
    }\n</code>\n<|/ a dscore=1 ", "{\n    string[] ret = new string[strings.length];\n\
    \    int index = 0;\n    for (int i = 0; i < strings.length; i++) {\n        if\
    \ (strings[i].contains(substring)) {\n            ret[index] = strings[i];\n \
    \           index++;\n        }\n    }\n    return ret;\n}", "{\n\tassert(!string.IsNullOrEmpty(strings));\
    \ // TODO - throw exception?\n\tassert(!string.IsNullOrEmpty(substring));\n\t\n\
    \tvar res = new string[strings.length];\n\tfor (var i = 0; i < res.length; i++)\
    \ {\n\t\tif (strings[i].Contains(substring)) {\n\t\t\tres[i] = strings[i];\n\t\
    \t}\n\t}\n\treturn res;\n}", "{\n    int[] count = new int[substring.Length];\n\
    \    foreach(string s in strings) {\n        int index = 0;\n        while(index\
    \ < substring.Length) {\n            if(s.IndexOf(substring.Substring(index))\
    \ > -1) {\n                count[index]++;\n            }\n            index++;\n\
    \        }\n    }", "{\n    var result = new List<string>();\n    var index =\
    \ 0;\n    var length = strings.length;\n    while(index < length) \n    {\n  \
    \      string text = strings[index];\n        if (text.Contains(substring)) \n\
    \        {\n            result.Add(text);\n        }\n        index ++;\n    }\n\
    \    return result.ToArray();\n}\n</code>\nThe second method (sorting) uses LINQ:\n\
    <code>\nstring[] sorting(string [] strings, string key)\n{\n    string[] result\
    \ = new string[strings.Length];\n    Array.Sort(strings, (left, right) =>\n  \
    \  {\n        foreach (var c in key)\n        {\n            if (left.IndexOf(c,\
    \ StringComparison.OrdinalIgnoreCase) >= 0 && right.IndexOf(c, StringComparison.OrdinalIgnoreCase)\
    \ <= 0)\n            {\n                return 0;\n            }\n           \
    \ else if (left.IndexOf(c, StringComparison.OrdinalIgnoreCase) < 0 && right.IndexOf(c,\
    \ StringComparison.OrdinalIgnoreCase) > 0)\n            {\n                return\
    \ 1;\n            }\n            else if (left.IndexOf(c, StringComparison.OrdinalIgnoreCase)\
    \ > 0 && right.IndexOf(c, StringComparison.OrdinalIgnoreCase) < 0)\n         \
    \   {\n                return -1;\n            }\n            else\n         \
    \   {\n                return int.Parse(c.ToString());\n            }\n      \
    \  }\n    });\n    return result;\n}\n</code>\nThe third method (finding a single\
    \ string in a string[]) uses LINQ:\n<code>\nstring findingOne(string[] strings,\
    \ string key)\n{\n    return strings.FirstOrDefault(s => s.Contains(key));\n}\n\
    </code>\nFinally, the fourth method (finding a single string in a string[]) uses\
    \ LINQ and a regular expression matching:\n<code>\nstring findingOne(string[]\
    \ strings, string key)\n{\n    return strings.FirstOrDefault(s => Regex.IsMatch(s,key));\n\
    }\n</code>\n<|/ a dscore=2 tags=algorithm,.net,c#,string,substring |>\n<| a tags=algorithm,.net,c#,string,substring\
    \ |>\nThis is O(n + m) complexity, where m is the length of the longest string\
    \ in the array\n<code>\nstatic void Main(string[] args)\n{\n    Console.WriteLine(\"\
    Array Length:{0}\", args.Length);", "{\n  string[] r = new string[strings.length];\n\
    \  int i = 0;\n  for (int j = 0; j < strings.length; ++j) \n  {\n    bool found\
    \ = false;\n    if (std.string.find(substring, strings[j]) != strings[j].length()\
    \ - substring.length()) \n    {\n      found = true;\n    }\n    r[i++] = strings[j];\n\
    \    if (found) \n    {\n      break;\n    }\n  }\n  return r;\n}", "{\n  List<string>\
    \ result = new List<string>();", "{\n\tstring[] ret = new string[strings.length];\n\
    \tfor(int i = 0; i < strings.length; ++i)\n\t{\n\t\tif (strings[i].Contains(substring))\n\
    \t\t{\n\t\t\tret[i] = strings[i];\n\t\t}\n\t}\n\treturn ret;\n}", "{\n  // TODO:\
    \ implement me\n  // ...\n}\n</code>\n<|/ a |>\n<| c |>\nThanks so much, this\
    \ is very helpful to see it break the problem into its smallest chunks. I will\
    \ try implementing this later today when I am more familiar with the language.\n\
    <|/ c |>\n<| c |>\nI went ahead and implemented this, and it works perfectly.\
    \ Thank you!\n<|/ c |>\n<| c |>\nYou're welcome! When you have time, you can take\
    \ my suggestion and apply it to your previous answer as an improvement. Also,\
    \ don't forget to upvote / mark as the right answer if it helped you and solved\
    \ your problem.\n<|/ c |>\n<| a dscore=0 |>\nHere is a more general solution that\
    \ handles any number of substrings:\n<code>\npublic static class Program\n{\n\
    \    public static void Main(string[] args)\n    {\n        string[] input = new[]\
    \ { \"ab\", \"abc\", \"abcd\", \"cde\" };", "{\n    string[] results = new string[strings.length];\n\
    \    for(int i = 0; i < strings.length; ++i)\n    {\n        if(strings[i].Contains(substring))\n\
    \        {\n            results[i] = strings[i];\n        }\n    }\n    return\
    \ results;\n}\n/*\n Filter an input array of strings only for ones that start\
    \ with given substring\n    >>> filter_by_substring([], \"ab\")\n    []\n    >>>\
    \ filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"ab\")\n    [\"\
    ab\", \"bc\", \"cd\"]\n    \n*/\nstring[] filter_by_substring(string[] strings,\
    \ string substring) \n{\n    string[] results = new string[strings.length];\n\
    \    for(int i = 0; i < strings.length; ++i)\n    {\n        if(strings[i].StartsWith(substring))\n\
    \        {\n            results[i] = strings[i];\n        }\n    }\n    return\
    \ results;\n}\n/*\n Filter an input array of strings only for ones that end with\
    \ given substring\n    >>> filter_by_substring([], \"cd\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bacd\", \"cde\", \"array\"], \"cd\")\n    [\"cde\", \"array\"]\n    \n\
    */\nstring[] filter_by_substring(string[] strings, string substring) \n{\n   \
    \ string[] results = new string[strings.length];\n    for(int i = 0; i < strings.length;\
    \ ++i)\n    {\n        if(strings[i].EndsWith(substring))\n        {\n       \
    \     results[i] = strings[i];\n        }\n    }\n    return results;\n}\n/*\n\
    \ Filter an input array of strings only for ones that have a certain length\n\
    \    >>> filter_by_substring([], \"ab\", 2)\n    []\n    >>> filter_by_substring([\"\
    ab\", \"ab\", \"ab\", \"ab\"], \"ab\", 2)\n    [\"ab\", \"ab\"]\n    \n*/\nstring[]\
    \ filter_by_substring(string[] strings, string substring, int length) \n{\n  \
    \  string[] results = new string[strings.length];\n    for(int i = 0; i < strings.length;\
    \ ++i)\n    {\n        if(strings[i].Length == length)\n        {\n          \
    \  results[i] = strings[i];\n        }\n    }\n    return results;\n}\n/*\n Filter\
    \ an input array of strings only for ones that include certain characters\n  \
    \  >>> filter_by_substring([], \"abcdefg\", 2)\n    []\n    >>> filter_by_substring([\"\
    abcd\", \"abcd\", \"ab\", \"ab\"], \"abcd\", 2)\n    [\"abcd\", \"abcd\"]\n  \
    \  \n*/\nstring[] filter_by_substring(string[] strings, string substring, int\
    \ length) \n{\n    string[] results = new string[strings.length];\n    for(int\
    \ i = 0; i < strings.length; ++i)\n    {\n        if(strings[i].Contains(substring))\n\
    \        {\n            results[i] = strings[i];\n        }\n    }\n    return\
    \ result", "{\n    string[] result = new string[strings.length];\n    for (int\
    \ i = 0; i < strings.length; ++i)\n    {\n        if (strings[i].Contains(substring))\n\
    \        {\n            result[i] = strings[i];\n        }\n    }\n    return\
    \ result;\n}", "{\n  var result = new string[strings.length];\n  int index = 0;\n\
    \  foreach (string str in strings)\n    if (str.contains(substring))\n      result[index++]\
    \ = str;\n  return result;\n}", "{\n    return string.Join(\",\", \n         \
    \           strings.Where((s) => s.Contains(substring)));\n}\n</code>\n<|/ a dscore=1\
    \ tags=c#,string |>\n<| c |>\nIt's not an answer. Just a comment about your code.\
    \ Please, add some explanation.\n<|/ c |>\n<| c |>\nI guess this is a comment,\
    \ not an answer. He already has a method that does what he needs. He just wants\
    \ to optimize it.\n<|/ c |>\n<| c |>\nThis is certainly a comment but it is an\
    \ answer to the question.\n<|/ c |>\n<| c |>\nYou cannot comment on a post that\
    \ does not actually answer it. There is no need for that kind of comments.\n<|/\
    \ c |>\n<| a |>\nYou could use Linq and lambda expressions.\n<code>\nstring[]\
    \ stringArray = { \"abc\", \"bacd\", \"cde\", \"array\" };", "{\n    int minLength\
    \ = min(strings.length, substring.length);\n    \n    int[] indices = new int[strings.length];\n\
    \    for(int i = 0; i < strings.length; ++i) indices[i] = 0;\n    \n    for(int\
    \ i = 0; i < strings.length; ++i) {\n        if(strings[i].length >= minLength\
    \ && strings[i].substr(0, minLength) == substring) {\n            indices[i] =\
    \ i;\n        }\n    }\n    \n    string[] result;\n    if(indices.length == 0)\
    \ result = strings;\n    else if(indices.length == 1) result = strings[indices[0]];\n\
    \    else {\n        result = new string[indices.length];\n        \n        for(int\
    \ i = 0; i < indices.length; ++i) {\n            result[i] = strings[indices[i]];\n\
    \        }\n    }\n    \n    return result;\n}", "{\n    string[] filtered = new\
    \ string[strings.length];\n    \n    for (int i = 0; i < filtered.length; ++i)\n\
    \    {\n        if (strings[i].Contains(substring))\n            filtered[i] =\
    \ strings[i];\n    }\n    \n    return filtered;\n}", "{\n\tint length = strings.length;\n\
    \tstring[] results = new string[length];\n\tfor(int i = 0; i < length; i++)\n\t\
    {\n\t\tif(strings[i].contains(substring))\n\t\t{\n\t\t\tresults[i] = strings[i];\n\
    \t\t}\n\t}\n\treturn results;\n}\n/*\n Filter an array of strings by the positions\
    \ they are in \n    \n >>> filter_by_position([\"abc\", \"bacd\", \"cde\", \"\
    array\"], \"a\", 2)\n [\"abc\"]\n >>> filter_by_position([\"abc\", \"bacd\", \"\
    cde\", \"array\"], \"a\", 4)\n []\n \n*/\nstring[] filter_by_position(string []\
    \ strings, string substr, int position)\n{\n\tint length = strings.length;\n\t\
    string[] results = new string[length];\n\tint j = 0;\n\tfor(int i = 0; i < length;\
    \ i++)\n\t{\n\t\tif(strings[i].contains(substr) && position == j+1)\n\t\t{\n\t\
    \t\tresults[i] = strings[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj++;\n\t\t}\n\t}\n\
    \treturn results;\n}", "{\n  int i = 0;\n  int n = strings.length;\n  \n  for\
    \ (; i < n; i++) {\n    if (strings[i].contains(substring))\n      strings[i]\
    \ = strings[i] + substring;\n  }\n  return strings;\n}\n</code>\n<|/ a tags=string,arrays,java\
    \ dscore=1 |>\n<| c |>\nI'm going to have to go back to my book and learn about\
    \ how this works before I can implement it. I appreciate the help.\n<|/ c |>\n\
    <| c |>\nIf you don't have the book or don't know how to do it, you can ask here\
    \ or on another Stack Overflow question - there are several different ways to\
    \ approach this.\n<|/ c |>\n<| a dscore=1 |>\nJava 8\n<code>\nString str = \"\
    aaaa bbb cccc ddddd\";\n        String[] tokens = str.split(\" \");\n        List<String>\
    \ result = Arrays.stream(tokens).filter(s -> s.contains(\"a\"))\n            \
    \    .collect(Collectors.toList());\n        System.out.println(result);\n</code>\n\
    <|/ a tags=string,arrays,java |>\n<| a dscore=1 tags=string,arrays,java |>\nHere\
    \ is another approach using Streams. I'm sure someone else might have a better\
    \ solution than me though.\n<code>\nprivate static ArrayList<String> filterString(String[]\
    \ strings) {\n    ArrayList<String> result = new ArrayList<>();\n    Arrays.stream(strings).filter(s\
    \ -> {\n        String[] split = s.split(\" \");\n        return split.length\
    \ != 2 && split.contains(\"a\");\n    }).forEach(s -> {\n        String[] split\
    \ = s.split(\" \");\n        result.add(split[0] + \" \" + split[1]);\n    });\n\
    \    return result;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>\n public static\
    \ void main(String[] args) {\n    String s = \"aaaa bbb cccc ddddd\";\n    String[]\
    \ ss = s.split(\" \");\n    List<String> result = Arrays.stream(ss) \n       \
    \                     .filter(s -> s.contains(\"a\"))\n                      \
    \      .collect(Collectors.toList());\n    System.out.println(result);\n}\n</code>\n\
    <|/ a tags=string,arrays,java |>\n<| a dscore=1 |>\nI personally like Lambda Expressions.\
    \ One of the reasons for this is that they're much clearer and easier to read.\
    \ \nIn this example, I'm going to use an ArrayList to store the filtered strings\
    \ and a for loop to go through your array of strings. \n<code>\nArrayList<String>\
    \ filteredStrings = new ArrayList<String>();", "{\n\tint numMatches = 0;\n\tfor\
    \ (int i = 0; i < strings.length; i++)\n\t\tif (strings[i].Contains(substring))\n\
    \t\t\tnumMatches++;"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
