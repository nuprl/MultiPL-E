name: HumanEval_18_how_many_times
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
  \ substring can be found in the original string. Count overlaping cases.\n    >>>\
  \ how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n\
  \    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string\
  \ string, string substring) \n"
tests: "unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
  \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
  cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n\
  }\nvoid main(){}"
completions: ["{\n\tlong count_string = 0;\n\tlong count_substring = 0;\n\t\n\t//\
    \ We must convert both strings to lower case before we begin\n\tstring lowercase_string\
    \ = string;\n\t\n\t// Iterate over the first string, converting it into a set\
    \ of lower case characters\n\t// and adding them to the set of possible matches\
    \ (if they don't already exist)\n\tfor (string i = 0; i < lowercase_string; i++)\
    \ {\n\t\tchar c = lowercase_string[i];\n\t\t\n\t\tif (set_contains(substrings,\
    \ c) == false) {\n\t\t\tset_add(substrings, c);\n\t\t\tcount_substring++;\n\t\t\
    }\n\t}\n\t\n\t// Iterate over the second string, converting it into a set of lower\
    \ case characters\n\t// and adding them to the set of possible matches (if they\
    \ don't already exist)\n\tfor (string j = 0; j < lowercase_string; j++) {\n\t\t\
    char c = lowercase_string[j];\n\t\t\n\t\tif (set_contains(substrings, c) == false)\
    \ {\n\t\t\tset_add(substrings, c);\n\t\t\tcount_substring++;\n\t\t}\n\t}\n\t\n\
    \t// Iterate over the first string, converting it into a set of lower case characters\n\
    \t// and adding them to the set of possible matches (if they don't already exist)\n\
    \tfor (long i = 0; i < string.len; i++) {\n\t\tchar c = string[i];\n\t\t\n\t\t\
    if (set_contains(substrings, c) == false) {\n\t\t\tset_add(substrings, c);\n\t\
    \t\tcount_string++;\n\t\t}\n\t}\n\t\n\t// Iterate over the second string, converting\
    \ it into a set of lower case characters\n\t// and adding them to the set of possible\
    \ matches (if they don't already exist)\n\tfor (long j = 0; j < string.len; i++)\
    \ {\n\t\tchar c = string[j];\n\t\t\n\t\tif (set_contains(substrings, c) == false)\
    \ {\n\t\t\tset_add(substrings, c);\n\t\t\tcount_string++;\n\t\t}\n\t}\n\t\n\t\
    // Now that we have converted both strings to lower case, we can do the actual\
    \ search\n\tfor (long i = 0; i < substrings.len(); i++) {\n\t\tset_remove(substrings,\
    \ substrings[i]);\n\t\tcount_substring--;\n\t}\n\t\n\t// Return the total count\
    \ of overlapping matches between the two strings\n\treturn count_string + count_substring;\n\
    }", "{\n\tint start = 0, end = string.length() - substring.length();\n\tstring\
    \ search;\n\tint count = 0;\n\t\n\twhile(start < end) {\n\t\tsearch = string.substr(start,\
    \ substring.length());\n\t\tif(string.find(search, start) == start) {\n\t\t\t\
    start = string.find(search, start) + 1;\n\t\t\t++count;\n\t\t} else {\n\t\t\t\
    start++;\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n    bool first\
    \ = true;\n    for(auto it = string.begin(); it != string.end(); ++it) {\n   \
    \     auto next = find(substring.begin(), substring.end(), *it);\n        if(first\
    \ || (next != string.end() && next != it)) {\n            first = false;\n   \
    \         ++count;\n        }\n    }\n    return count;\n}", "{\n\tlong result\
    \ = 0;\n\t\n\tfor (int i = 0; i < string.length(); i++) \n\t{\n\t\tif (string.substr(i,\
    \ substring.length()).compare(substring) == 0) \n\t\t{\n\t\t\tresult += 1;\n\t\
    \t}\n\t}\n\t\n\treturn result;\n}", "{\n    size_t substring_length, string_length;\n\
    \    size_t total_matches;\n    \n    substring_length = substring.length();\n\
    \    string_length = string.length();", "{\n\tlong ret = 0;\n\tfor(var i = 0;\
    \ i < string.length; i++) \n\t{\n\t\tret += string.IndexOf(substring, i) != -1\
    \ ? 1 : 0;\n\t}\n\treturn ret;\n}", "{\n\tif (string.len() < substring.len())\
    \ {\n\t\treturn 0;\n\t} else {\n\t\tint n = 0;\n\t\tfor (long i = string.len()-1;\
    \ i >= 0; i--) {\n\t\t\tbool found = false;\n\t\t\tfor (long j = substring.len();\
    \ j >= 0; j--) {\n\t\t\t\tif (string[i] == substring[j]) {\n\t\t\t\t\tfound =\
    \ true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tn++;\n\
    \t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n}", "{\n    map<string, long> m;\n    for\
    \ (long i = 0; i < string.length(); i++) {\n        string s = string.substr(i,\
    \ substring.length());\n        if (m.containsKey(s)) {\n            m[s]++;\n\
    \        } else {\n            m[s] = 1;\n        }\n    }\n    return m[substring];\n\
    }\n'''", "{\n    long count = 0;\n    for (auto c : string)\n    {\n        if\
    \ (c.equals(substring)) \n        {\n            count++;\n        }\n    }\n\
    \    return count;\n}", "{\n    long start = 0;\n    long end = string.find_first_of(substring);\n\
    \    while (end != string.length()) \n    {\n        if (string[end] == substring[0])\
    \ \n        {\n            if (end < start) \n                start = end;\n \
    \           else\n                end ++;\n        } \n        else \n       \
    \ {\n            if (string[end] == substring[substring.length() - 1]) \n    \
    \        {\n                if (end < start) \n                    start = end;\n\
    \                else\n                    end++;\n            }\n           \
    \ else \n                end++;\n        }\n    }\n    \n    return end - start;\n\
    }\n</code>\n<|/ a tags=string,c++,algorithm,c dscore=0 |>\n<| c |>\n`int count=0;\
    \ for (auto c : string) { if (c == substring[0]) { count++; } else { count--;\
    \ } }`\n<|/ c |>\n<| a tags=string,c++,algorithm,c |>\nJust in case anyone needs\
    \ it in python. \n<code>\ndef count_sub_string( string, substring ):\n    start\
    \ = 0\n    end = len( string )\n    count = 0", "{\n    long count = 0;\n    int\
    \ string_length = string.length();\n    int substring_length = substring.length();\n\
    \    \n    for (int i = 0; i < string_length; ++i)\n    {\n        if (string.compare(i,\
    \ substring_length) == 0)\n        {\n            count += substring_length;\n\
    \        }\n        else if (string.compare(i, substring_length) == 0)\n     \
    \   {\n            count += 1;\n        }\n    }\n    \n    return count;\n}\n\
    </code>\n<|/ a tags=string,algorithm,python |>\n<| c |>\nThank you for this very\
    \ complete answer. In the original problem, the strings are really long (1000x1000\
    \ characters) which means that this is very memory hungry, but for this problem,\
    \ it works perfectly!\n<|/ c |>\n<| a |>\n<code>\ndef count_substring(string,\
    \ sub_string):\n    count = 0\n    for i in range(len(string)-len(sub_string)+1):\n\
    \        if(string[i:i+len(sub_string)] == sub_string):\n            count +=\
    \ 1\n    return count\n</code>\n<|/ a tags=string,algorithm,python dscore=3 |>\n\
    <| a dscore=3 |>\nThis is a solution in C#:\n<code>", "{\n    size_t start = string.find(substring);\n\
    \    if(start == string.length())\n    {\n        return 0;\n    }\n    else\n\
    \    {\n        string left_sub = string.substr(0, start);\n        string right_sub\
    \ = string.substr(start + substring.length());\n        return left_sub.length()\
    \ + how_many_times(left_sub, substring) + how_many_times(right_sub, substring);\n\
    \    }\n}", "{\n\tint i = 0;\n\tlong count = 0;\n\tfor(i = 0; i < string.length;\
    \ i++)\n\t{\n\t\tstring substring2 = substring.substring(i);\n\t\tif(string.startsWith(substring2))\n\
    \t\t{\n\t\t\tstring substring3 = substring2.substring(substring.length());\n\t\
    \t\tcount += how_many_times(string.substring(i + 1), substring3);\n\t\t}\n\t}\n\
    \treturn count;\n}", "{\n    long substringLength=substring.length();\n    long\
    \ result=0L;\n    for(long i=1L; i<string.length(); i=(i+substringLength))\n \
    \   {\n        if(string.substr(i-1,substringLength)==substring)\n        {\n\
    \            result+=substringLength;\n        }\n    }\n    return result;\n}",
  "{\n    long count = 0;\n    for(auto &c: substring) \n        if (string.find(c)\
    \ != string::npos) count++;\n    return count;\n}\n</code>\n<|/ a tags=string,c++\
    \ |>\n<| c |>\nOh my god this works perfectly. I never used the string class before\
    \ so this is very helpful\n<|/ c |>\n<| c |>\nThis can be made slightly more efficient\
    \ by calculating `string.find(c)` in a loop instead of calling `std::string::find()`\
    \ multiple times.\n<|/ c |>\n<| c |>\n: This is more efficient because `string.find()`\
    \ does not need to scan through the entire string looking for an occurrence of\
    \ the substring.\n<|/ c |>\n<| c |>\n: Thanks.  I fixed my answer.\n<|/ c |>\n\
    <| c |>\n: You should use [`std::find_first_of()`](http://en.cppreference.com/w/cpp/string/basic_string/find_first_of)\
    \ instead of `std::find_first_not_of()`\n<|/ c |>\n<| a tags=string,c++ |>\nHere\
    \ is some test code that works for me, and is faster than the other solutions\
    \ above. It also handles consecutive characters that need to be counted multiple\
    \ times.\n<code>\n#include <stdio.h>\n#include <iostream>\n#include <string>",
  "{\n    if (string == \"\")\n        return 0;", "{\n\tstringstream ss;\n\tss <<\
    \ string;\n\tstring substring_copy = substring;\n\tfor(long i = 0; i < how_many_times(substring,\
    \ substring_copy); i++)\n\t{\n\t\tstring old_substring_copy = substring_copy;\n\
    \t\tss >> substring_copy;\n\t\tif((ss >> string) != stringstream::eof())\n\t\t\
    \treturn i;\n\t}\n\treturn 0L;\n}", "{\n\tlong len = string.length();\n\tint count\
    \ = 0;\n\tint i = 0;\n\tint j = 0;\n\t\n\twhile (i < len && j < substring.length())\
    \ {\n\t\tint k = i + 1;\n\t\tint m = j + 1;\n\t\t\n\t\tint min = Math.min(k, m);\n\
    \t\tif (min == i) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (string.substr(min, 1).equals(substring.substr(j,\
    \ substring.length()))) {\n\t\t\tcount += 1;\n\t\t\ti += substring.length() -\
    \ 1;\n\t\t\tj += 1;\n\t\t}\n\t\telse if ((string.substr(i, 1).equals(substring.substr(j,\
    \ substring.length()))) && (i == k)) {\n\t\t\tcount += 1;\n\t\t\ti += substring.length()\
    \ - 1;\n\t\t\tj += 1;\n\t\t}\n\t\telse {\n\t\t\ti = k;\n\t\t\tj += 1;\n\t\t}\n\
    \t}\n\t\n\treturn count;\n}", "{\n    long count = 0;\n    int len = substring.length();\n\
    \    for(int i = 0; i < string.length(); i++) \n    {\n        if(string[i] ==\
    \ substring[0]) \n        {\n            if((string[i+1] == substring[0] || string[i+1]\
    \ == substring[len-1]) && i != len-1) \n            {\n                count++;\n\
    \            }\n        }\n    }\n    return count;\n}\n/*\n Remove consecutive\
    \ duplicates in the original string. Return new string.\n    >>> how_many_times(\"\
    aaa\", \"aa\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n   \
    \ >>> how_many_times(\"aaaa\", \"aab\")\n    3L\n    \n*/\nstring remove_consecutives(string\
    \ string) \n{\n    string new_string = string;\n    for(int i = 1; i < new_string.length();\
    \ i++)\n    {\n        if(new_string[i] == new_string[i-1]) \n        {\n    \
    \        new_string = new_string.substr(0, i) + \"_\" + new_string.substr(i +\
    \ 1, new_string.length());\n        }\n    }\n    return new_string;\n}", "{\n\
    \    long count = 0;\n    bool found = false;\n    for (int i = 0; i < string.length;\
    \ i++)\n    {\n        found = string.IndexOf(substring, i) != -1;\n        if\
    \ (found)\n        {\n            count++;\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a tags=string-matching,c#,string dscore=1 |>\n<| a tags=string-matching,c#,string\
    \ |>\nHere's a function that counts the number of times any substring appears\
    \ in a string in O(N) time. It also handles overlapping matches by adding the\
    \ count of overlapping matches:\n<code>\npublic static long CountSubstring(string\
    \ text, string substring)\n{\n    var position = 0;\n    var count = 0;", "{\n\
    \    string pattern = substring;\n    int pos = 0;\n    long count = 0;\n    while\
    \ ((pos = string.find(pattern, pos)) != string.length())\n    {\n        ++count;\n\
    \        pos += pattern.length();\n    }\n    return count;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring) \n{\n    string pattern\
    \ = substring;\n    int pos = 0;\n    long count = 0;\n    while ((pos = string.find(pattern,\
    \ pos)) != string.length())\n    {\n        ++count;\n        pos += pattern.length();\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring)\
    \ \n{\n    string pattern = substring;\n    int pos = 0;\n    long count = 0;\n\
    \    while ((pos = string.find(pattern, pos)) != string.length())\n    {\n   \
    \     ++count;\n        pos += pattern.length();\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring)\
    \ \n{\n    string pattern = substring;\n    int pos = 0;\n    long count = 0;\n\
    \    while ((pos = string.find(pattern, pos)) != string.length())\n    {\n   \
    \     ++count;\n        pos += pattern.length();\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_", "{\n\tint count = 0;\n\tint start =\
    \ 0;\n\t\n\tfor (int i = 0; i < string.length() - substring.length() + 1; i++)\n\
    \t{\n\t\tif (string.startsWith(substring, start, substring.length()))\n\t\t{\n\
    \t\t\tstart++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcount++;\n\t\t\tstart = i + 1;\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find the index in the original string of\
    \ a given substring. Case sensitivity is ignored.\n    >>> how_many_times_index(\"\
    \", \"a\")\n    0L\n    >>> how_many_times_index(\"aaa\", \"a\")\n    1L\n   \
    \ >>> how_many_times_index(\"aaaa\", \"a\")\n    2L\n    \n*/\nlong how_many_times_index(string\
    \ string, string substring) \n{\n\tint count = 0;\n\tint start = 0;\n\t\n\tfor\
    \ (int i = 0; i < string.length() - substring.length() + 1; i++)\n\t{\n\t\tif\
    \ (string.equals(substring, start, substring.length()))\n\t\t{\n\t\t\tstart++;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tcount++;\n\t\t\tstart = i + 1;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\n/*\n Find the index in the original string of a given substring.\
    \ Case sensitivity is ignored.\n    >>> how_many_times_index(\"a\", \"\") \n \
    \   1L\n    >>> how_many_times_index(\"a\", \"a\") \n    1L\n    >>> how_many_times_index(\"\
    a\", \"b\") \n    0L\n    \n*/\nlong how_many_times_index(string string, string\
    \ substring, bool ignoreCase) \n{\n\tint count = 0;\n\tint start = 0;\n\t\n\t\
    for (int i = 0; i < string.length() - substring.length() + 1; i++)\n\t{\n\t\t\
    if (!ignoreCase)\n\t\t{\n\t\t\tif (string.charAt(i) == substring.charAt(0))\n\t\
    \t\t{\n\t\t\t\tif (string.startsWith(substring, start, substring.length()))\n\t\
    \t\t\t{\n\t\t\t\t\tstart++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\
    \t\t\t\t\tstart = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif\
    \ (string.equals(substring, start, substring.length()))\n\t\t\t\t{\n\t\t\t\t\t\
    start++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\tstart\
    \ = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (string.charAt(i)\
    \ == substring.charAt(0))\n\t\t\t{\n\t\t\t\tif (string.startsWith(substring, start,\
    \ substring.length()))\n\t\t\t\t{\n\t\t\t\t\tstart++;\n\t\t\t\t}\n\t\t\t\telse\n\
    \t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\
    \t\telse\n\t\t\t{\n\t\t\t\tif (string.equalsIgnoreCase(substring, start, substring.length()))\n\
    \t\t\t\t{", "{\n  // Make sure that we have the same type for this call and all\
    \ string literals (string literals have type string).\n  typedef string::const_iterator\
    \ iter;\n  assert(string::traits_type::length == string.size());\n  assert(string::traits_type::length\
    \ == substring.size());\n  assert(string::traits_type::compare(string, substring,\
    \ iter(string)) != string::npos && string::traits_type::compare(substring, string,\
    \ iter(string)) == 0);\n  \n  long result = 0;\n  \n  // Iterate over the substring\n\
    \  iter sub_pos = substring.begin();\n  iter sub_end = substring.end();\n  iter\
    \ pos = string.begin();\n  iter end = string.end();\n  \n  while (pos != end &&\
    \ sub_pos != sub_end)\n  {\n    // If the current character matches the substring\
    \ go ahead and increase the counter\n    if (string::traits_type::compare(string,\
    \ pos, iter(string)) == 0)\n    {\n      ++result;\n      \n      // Move the\
    \ iterator to the next position\n      ++pos;\n    }\n    // If the current character\
    \ does not match the substring move the iterator to the next position\n    else\
    \ if (string::traits_type::compare(string, pos, iter(string)) != 0)\n    {\n \
    \     ++pos;\n    }\n    // If the substring ends and the current character matches\
    \ the substring go ahead and increase the counter\n    else if (string::traits_type::compare(substring,\
    \ sub_pos, iter(substring)) == 0)\n    {\n      ++result;\n      \n      // Move\
    \ the iterator to the next position\n      ++sub_pos;\n    }\n    // If the substring\
    \ ends and the current character does not match the substring move the iterator\
    \ to the next position\n    else if (string::traits_type::compare(substring, sub_pos,\
    \ iter(substring)) != 0)\n    {\n      ++sub_pos;\n    }\n  }\n  \n  return result;\n\
    }\n</code>\n<|/ a tags=stl,string,c++ |>\n<| a dscore=1 tags=stl,string,c++ |>\n\
    The best performance is to use a std::unordered_map to count the occurrences of\
    \ a substring, where the substring is the std::string and the std::string is the\
    \ input string.\nAn unordered_map has O(1) access. std::count is O(N) because\
    \ count goes through every element in the string to check if it matches the substring.\
    \ Here is an example using unordered_map to count the number of occurrences of\
    \ substrings in a string.\n<code>\n#include <iostream>\n#include <unordered_map>",
  "{\n  int counter = 0;\n  int i = 0;\n  int j = 0;\n  int n = string.length();\n\
    \  int m = substring.length();\n  \n  for (i=0; i<n; ++i)\n    for (j=0; j<m;\
    \ ++j)\n      if (string.at(i) == substring.at(j))\n        ++counter;\n  \n \
    \ return counter;\n}", "{\n    long count = 0;\n    string current_substring =\
    \ string;", "{\n    size_t pos = 0;\n    size_t start_pos = 0;\n    size_t end_pos\
    \ = 0;\n    size_t count = 0;\n    \n    start_pos = 0;\n    end_pos = string.length()\
    \ - substring.length();\n    while ((pos = string.find(substring, start_pos))\
    \ != string.length())\n    {\n        count += 1;\n        start_pos = pos + 1;\n\
    \    }\n    \n    return count;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThanks\
    \ for sharing this solution. It is great but does not work for overlapping cases.\n\
    <|/ c |>\n<| a tags=python,string,algorithm |>\nHow about a regex?\n<code>\nIn\
    \ [1]: import re", "{\n    long count = 0;\n    int i;\n    \n    for (i = 0;\
    \ i < (int)(string.length() - substring.length()); i++)\n    {\n        if (string.startsWith(substring,\
    \ i) && (string.length() - substring.length()) <= i) {\n            count += 1;\n\
    \        }\n    }\n    \n    return count;\n}", "{\n\tlong counter = 0;\n\tsize_t\
    \ size = string.length();\n\tsize_t substring_size = substring.length();\n\tfor\
    \ (size_t i = 0; i < size; i++) {\n\t\tif (string[i] == substring[0]) {\n\t\t\t\
    if (substring[0] == substring[substring_size-1]) {\n\t\t\t\tcounter++;\n\t\t\t\
    }\n\t\t\tif (substring[0] != string[i+1]) {\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\
    \tif (string[i+1] == substring[substring_size-1]) {\n\t\t\t\tcounter++;\n\t\t\t\
    }\n\t\t\tif (substring[0] != string[i+2]) {\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\
    \tif (string[i+1] != substring[substring_size-1]) {\n\t\t\t\tcounter++;\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn counter;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlapping cases.\n    >>> how_many_times(\"\
    a\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    1L\n    >>> how_many_times(\"\
    aaaa\", \"a\")\n    2L\n*/\nlong how_many_times(string string, string substring,\
    \ string substring2) \n{\n\tlong counter = 0;\n\tsize_t size = string.length();\n\
    \tsize_t substring_size = substring.length();\n\tsize_t substring2_size = substring2.length();\n\
    \tfor (size_t i = 0; i < size; i++) {\n\t\tif (string[i] == substring[0]) {\n\t\
    \t\tif (substring[0] == substring[substring_size-1]) {\n\t\t\t\tcounter++;\n\t\
    \t\t}\n\t\t\tif (substring[0] != string[i+1]) {\n\t\t\t\tcounter++;\n\t\t\t}\n\
    \t\t\tif (string[i+1] == substring[substring_size-1]) {\n\t\t\t\tcounter++;\n\t\
    \t\t}\n\t\t\tif (substring[0] != string[i+2]) {\n\t\t\t\tcounter++;\n\t\t\t}\n\
    \t\t\tif (string[i+1] != substring[substring_size-1]) {\n\t\t\t\tcounter++;\n\t\
    \t\t}\n\t\t}\n\t\tif (string[i] == substring2[0]) {\n\t\t\tif (substring2[0] ==\
    \ substring2[substring2_size-1]) {\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\tif (substring2[0]\
    \ != string[i+1]) {\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\tif (string[i+1] == substring2[substring2_size-1])\
    \ {\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\tif (substring2[0] != string[i+2]) {\n\t\
    \t\t\tcounter++;\n\t\t\t}\n\t\t\tif (string[i+1] != substring2[substring2_size-1])\
    \ {\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t}\n\treturn counter;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlapping cases.\n    >>> how_many_times(\"a\", \"a\", \"a\")\n    1L\n  \
    \  >>> how_many_times(\"aaa\", \"a\", \"a\")\n    2L\n    >>> how_many_times(\"\
    aaaa\", \"a\", \"a\")\n    2L\n    \n*/\nlong how_many_times(string string, string\
    \ substring, string substring2, string ", "{\n    long count = 0;\n    int string_length\
    \ = string.size();\n    int substring_length = substring.size();\n    int i =\
    \ 0;\n    for(i = 0 ; i < string_length - substring_length ; ++i)\n    {\n   \
    \     if((string.at(i) == substring.at(i)) && (string.at(i + substring_length)\
    \ == substring.at(i + substring_length)))\n        {\n            ++count;\n \
    \           i += substring_length;\n        }\n    }\n    return count;\n}", "{\n\
    \    if(string.size() <= substring.size())\n    {\n        long count = string.count(substring);\n\
    \        while(string.size() > substring.size())\n        {\n            string\
    \ newString = string.substr(0, string.size() - substring.size());\n          \
    \  count += newString.count(substring);\n            string = newString;\n   \
    \     }\n        return count;\n    }\n    else\n    {\n        long count = 0;\n\
    \        string newString = string;\n        while(string.size() > substring.size())\n\
    \        {\n            string newSubString = string.substr(0, string.size() -\
    \ substring.size());\n            count += newString.count(newSubString);\n  \
    \          newString = string.substr(string.size() - substring.size(), string.size());\n\
    \        }\n        return count;\n    }\n}\n</code>\n<|/ a tags=java,string,algorithm,substring\
    \ |>\n<| c |>\nThanks, this is really helpful.\n<|/ c |>\n<| c |>\nThis is still\
    \ O(n^2). At least in Java string.substring returns a view of the original string\
    \ which means that all it does is increment the internal pointer of the original\
    \ string until it hits the last character of the substring. Nothing fancy.\n<|/\
    \ c |>\n<| c |>\nThis is wrong if you need to count overlapping occurrences. I\
    \ believe that `string.count` counts overlapping occurrences.\n<|/ c |>\n<| a\
    \ dscore=5 |>\nI recently worked out a solution that only counts non-overlapping\
    \ occurrences of a given substring within a given string:\n<code>\npublic static\
    \ int countNonOverlappingOccurrences(String str, String substring) {\n    StringBuilder\
    \ sb = new StringBuilder(str);\n    int count = 0;\n    while (true) {\n     \
    \   boolean found = false;\n        for (int i = sb.indexOf(substring); i >= 0;\
    \ i = sb.indexOf(substring, i + 1)) {\n            if (found)\n              \
    \  sb.setCharAt(i, (char) 0);\n            else\n                found = true;\n\
    \        }\n        if (found)\n            count++;\n        else\n         \
    \   break;\n    }\n    return count;\n}\n</code>\n<|/ a tags=java,string,algorithm,substring\
    \ |>\n<| c |>\nThis is O(n^2). At least in Java string.substring returns a view\
    \ of the original string which means that all it does is increment the internal\
    \ pointer of the original string until it hits the last character of the substring.\
    \ Nothing fancy.\n<|/ c |>\n<| a dscore=4 |>\nIf you need to find occurrences\
    \ of substrings in string, then you could use regex expressions. I suggest using\
    \ Pattern (Java Doc), Matcher classes (Java Doc).\nIf you need to check whether\
    \ a string contains a substring ", "{\n    long count = 0;\n    size_t pos = 0;\n\
    \    long len = (long) string.length();\n    long substrLen = (long) substring.length();\n\
    \    \n    for(;pos<len;pos++) {\n        if(string.at(pos)==substring.at(pos))\
    \ count++;\n    }\n    return count;\n}", "{\n\tint startIndex=string.find(substring);\n\
    \tif (startIndex!=string.length()-1)\n\t{\n\t\tint endIndex=string.find(substring,\
    \ startIndex+1);\n\t\tif (endIndex!=-1)\n\t\t{\n\t\t\treturn endIndex-startIndex+1;\n\
    \t\t}\n\t}\n\treturn 0L;\n}\n/* \n Remove all the occurrences of a substring from\
    \ a string.\n    >>> remove_substring(\"aabbaab\", \"ab\")\n    'aabb'\n    >>>\
    \ remove_substring(\"aaaabbb\", \"ab\")\n    'aaa'\n    >>> remove_substring(\"\
    aaaabbb\", \"ab\", 3)\n    'aabb'\n*/\nstring remove_substring(string string,\
    \ string substring, int occurrence)\n{\n\tstring result;\n\tint startIndex=string.find(substring);\n\
    \tif (startIndex!=-1)\n\t{\n\t\tstring temp=string.substr(0, startIndex);\n\t\t\
    int endIndex=string.find(substring, startIndex+1);\n\t\tif (endIndex!=-1)\n\t\t\
    {\n\t\t\tresult=temp+string.substr(startIndex+1, endIndex-occurrence+1);\n\t\t\
    }\n\t\telse\n\t\t{\n\t\t\tresult=temp+string;\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\n Extract a substring from a string at the given start index and end index.\
    \ \n If the end index is omitted, the substring starts from the end of the string.\n\
    \    >>> substring(\"aaaabbb\", \"a\", 2, 3)\n    'b'\n    >>> substring(\"aaaabbb\"\
    , \"a\", 2)\n    'b'\n    >>> substring(\"aaaabbb\", \"a\")\n    ''\n*/\nstring\
    \ substring(string string, string substring, int startIndex, int endIndex)\n{\n\
    \tstring result;\n\tint startIndex=string.find(substring);\n\tif (startIndex!=-1)\n\
    \t{\n\t\tif (endIndex==-1)\n\t\t{\n\t\t\tresult=string.substr(startIndex);\n\t\
    \t}\n\t\telse\n\t\t{\n\t\t\tresult=string.substr(startIndex, endIndex-startIndex);\n\
    \t\t}\n\t}\n\treturn result;\n}\n/*\n Convert a string to a number \n    \n  \
    \  >>> string_to_number(\"123\")\n    123L\n    >>> string_to_number(\"1.3\")\n\
    \    13L\n    >>> string_to_number(\"-1.3\")\n    13L\n    >>> string_to_number(\"\
    123e45\")\n    123e45L\n    >>> string_to_number(\"123e-7\")\n    123.0e-07L\n\
    \    \n*/\nlong string_to_number(string string)\n{\n\tlong result;\n\tstringstream\
    \ ss(string);\n\tss >> result;\n\treturn result;\n}\n/*\n Convert a string to\
    \ a float\n    \n    >>> string_to_float(\"123\")", "{\n    long count = 0;\n\
    \    if (string.length <= substring.length)\n    {\n        count = 0;\n    }\n\
    \    else\n    {\n        string substrings = substring(string, substring);\n\
    \        string strings = substring(string, \"\");\n        long i;\n        for\
    \ (i = 0; i < substrings.length; i++)\n        {\n            count+=strings.length-substrings.length+i;\n\
    \            if (substrings[i] == strings[i])\n            {\n               \
    \ count+=strings.length-substrings.length+i;\n            }\n        }\n    }\n\
    \    return count;\n}\n/*\n Convert a string to lower case\n \n >>> convert_lower_case(\"\
    abcd\")\n \"abcd\"\n >>> convert_lower_case(\"aBcDe\")\n \"aBcDe\"\n >>> convert_lower_case(\"\
    A2B3c4\")\n \"a2b3c4\"\n \n */\nstring convert_lower_case(string string)\n{\n\
    \    string newString = \"\";\n    for (int i = 0; i < string.length; i++)\n \
    \   {\n        if (string[i] < 'A' || string[i] > 'Z')\n        {\n          \
    \  newString += string[i];\n        }\n    }\n    return newString;\n}\n/*\n Convert\
    \ a string to upper case\n \n >>> convert_upper_case(\"abcd\")\n \"ABCD\"\n >>>\
    \ convert_upper_case(\"aBcDe\")\n \"A_BcDe\"\n >>> convert_upper_case(\"A2B3c4\"\
    )\n \"A_2B_3C4\"\n \n */\nstring convert_upper_case(string string)\n{\n    string\
    \ newString = \"\";\n    for (int i = 0; i < string.length; i++)\n    {\n    \
    \    if (string[i] < 'a' || string[i] > 'z')\n        {\n            newString\
    \ += string[i];\n        }\n    }\n    return newString;\n}\n/*\n Find a substring\
    \ in a string that has at most n repetitions.\n \n >>> find_substring(\"abcabc\"\
    , \"abc\", 2)\n \"abc\"\n >>> find_substring(\"abcabc\", \"abc\", 1)\n \"a\"\n\
    \ >>> find_substring(\"abcabc\", \"ab\", 2)\n \"ab\"\n >>> find_substring(\"abcabc\"\
    , \"ab\", 3)\n \"abcabc\"\n >>> find_substring(\"abcabc\", \"bc\", 2)\n \"bc\"\
    \n >>> find_substring(\"abcabc\", \"bc\", 3)\n \"abcabc\"\n >>> find_substring(\"\
    abcabc\", \"bca\", 3)\n \"abcabc\"\n \n */\nstring find_substring(string string,\
    \ string substring, long n)\n{\n    string newString = \"\";\n    for (int i =\
    \ 0; i < string.length; i++)\n    {\n        if (string[i] != substring[0])\n\
    \        {", "{\n\tlong result = long(0);\n\t\n\tfor(int i = 0;i < string.size()\
    \ - substring.length();i++)\n\t{\n\t\tif(string.substring == substring)\n\t\t\
    {\n\t\t\tresult += 1;\n\t\t}\n\t}\n\treturn result;\n}", "{\n    long result =\
    \ 0;\n    int i = 0;\n    int j = 0;\n    \n    while(i < string.length())\n \
    \   {\n        // If we found the substring then add 1 to the result.\n      \
    \  if (string.substr(i, j) == substring)\n            result += 1;\n        \n\
    \        // Check if the substring is at the beginning of the string.\n      \
    \  if (i == 0)\n        {\n            if (string.substr(i, j) == substring)\n\
    \                result += 1;\n        }\n        \n        // Check if the substring\
    \ is at the end of the string.\n        if (i == string.length())\n        {\n\
    \            if (string.substr(i, j) == substring)\n                result +=\
    \ 1;\n        }\n        \n        // If we didn't find the substring then move\
    \ to the next character.\n        i += 1;\n        \n        // If the substring\
    \ is longer than the string then continue searching for the next substring.\n\
    \        if (string.length() < substring.length())\n        {\n            i =\
    \ j;\n            j += 1;\n        }\n    }\n    \n    return result;\n}", "{\n\
    \    int pos;\n    int len = (int) string.length();\n    string substring2 = substring;\n\
    \    long result = 0;\n    int index = 0;\n    \n    // If substring is the same\
    \ length\n    if(len == (int)substring.length())\n    {\n        string substring2\
    \ = substring;\n        string str = string;\n        index = -1;\n        \n\
    \        for(int i = 0; i < len; i++)\n        {\n            if(str.charAt(i)\
    \ == substring2.charAt(i))\n            {\n                index++;\n        \
    \    }\n        }\n        \n        if(index == 0)\n        {\n            result\
    \ = 0;\n        }\n        else\n        {\n            result = index;\n    \
    \    }\n    }\n    \n    // Substring is the same length, case insensitive\n \
    \   else\n    {\n        string substring2 = substring.toLower();\n        string\
    \ str = string.toLowerCase();\n        index = -1;\n        \n        for(int\
    \ i = 0; i < len; i++)\n        {\n            if(str.charAt(i) == substring2.charAt(i))\n\
    \            {\n                index++;\n            }\n        }\n        \n\
    \        if(index == 0)\n        {\n            result = 0;\n        }\n     \
    \   else\n        {\n            result = index;\n        }\n    }", "{\n    int\
    \ count = 0;\n    int current = 0;\n    int end = string.length();\n    while(current\
    \ <= end){\n        current = (string[current - 1] == substring[end - 1])?current:current+1;\n\
    \        while(current <= end){\n            if (string[current] == substring[end\
    \ - 1]){\n                count++;\n                current = current+1;\n   \
    \             end--;\n            }\n            else{\n                current\
    \ = (string[current - 1] == substring[end - 1])?current:current+1;\n         \
    \   }\n        }\n    }\n    return count;\n}", "{\n    long count = 0;\n    \n\
    \    auto it = string.find(substring);\n    if(it!=string.npos)\n    {\n     \
    \   count++;\n        while(it!=string.npos)\n        {\n            count = overlaps(string,\
    \ it) ? count + 1 : count;\n            it = string.find(substring, it+1);\n \
    \       }\n    }\n    \n    return count;\n}", "{\n\tlong count = 0;\n\tfor(int\
    \ i = string.find(substring) + substring.length(); i < string.length(); i++) {\n\
    \t\tif(string[i] != string[i - 1]) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    2L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2) \n{\n\tlong count = 0;\n\tfor(int i = string.find(substring)\
    \ + substring.length(); i < string.length(); i++) {\n\t\tif(string[i] == substring[0])\
    \ {\n\t\t\tcount += how_many_times(string.substring(i), substring, substring2);\n\
    \t\t}\n\t\tif(string[i] == substring2[0]) {\n\t\t\tcount += how_many_times(string.substring(i),\
    \ substring, substring2);\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    2L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2, string\
    \ substring3) \n{\n\tlong count = 0;\n\tfor(int i = string.find(substring) + substring.length();\
    \ i < string.length(); i++) {\n\t\tif(string[i] == substring[0]) {\n\t\t\tcount\
    \ += how_many_times(string.substring(i), substring, substring2, substring3);\n\
    \t\t}\n\t\tif(string[i] == substring2[0]) {\n\t\t\tcount += how_many_times(string.substring(i),\
    \ substring, substring2, substring3);\n\t\t}\n\t\tif(string[i] == substring3[0])\
    \ {\n\t\t\tcount += how_many_times(string.substring(i), substring, substring2,\
    \ substring3);\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    2L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, string substring2, string substring3,\
    \ string substring4) \n{\n\tlong count = 0;", "{\n\tstring s0 = string;\n\tstring\
    \ s1 = substring;\n\tif (s0 == \"\" || s1 == \"\") return 0L;\n\tlong count =\
    \ 0;\n\tfor (int i = 0; i < s0.length(); i++) {\n\t\tif (s1.indexOf(s0[i]) >=\
    \ 0) {\n\t\t\tcount += 1;\n\t\t\ts0 = s0.substring(i);\n\t\t}\n\t}\n\treturn count;\n\
    }", "{\n  long count = 0;\n  int i = 0;\n  \n  for (; i < string.length; i++)\n\
    \  {\n    if (string.compare(i, substring.length, substring, 0, substring.length)\
    \ == 0)\n    {\n      count++;\n    }\n  }\n  return count;\n}", "{\n    auto\
    \ iter = string.find(substring);\n    if (iter == string.length()) \n        return\
    \ 0;\n    else \n        return 1 + how_many_times(string.substr(iter+1), substring);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nPlease add some explanation to your answer. While\
    \ it might not be as clever as some other answers, this one was extremely helpful\
    \ to me!\n<|/ c |>\n<| c |>\nThanks for your answer! It works, but I got this\
    \ warning: \" warning: implicit conversion loses integer precision: 'std::__1::__wrap_iter<char\
    \ const *>' {aka 'const char *'} to 'int' [-Wshorten-64-to-32]\" when I tried\
    \ to compile my code (which I wrote in my first post). Do you have any idea?\n\
    <|/ c |>\n<| c |>\nThe warning should be fixed. Make sure your compiler supports\
    \ C++17 (`-std=c++17`). Otherwise, just use `__builtin_ctzl` instead (this is\
    \ an intrinsic function from GCC 4.9+)\n<|/ c |>\n<| c |>\nThank you. Unfortunately,\
    \ it didn't work. I get this warning:\n<|/ c |>\n<| c |>\n\"error: \u2018__builtin_ctzl\u2019\
    \ was not declared in this scope\"\n<|/ c |>\n<| a |>\nI implemented a solution\
    \ based on answers, but it needs some optimizations on it. \nIt works well for\
    \ all cases, but some cases are not handled properly\nFor example for the string\
    \ \"a\" and \"aaaa\" it returns \"1\" for \"a\" and \"0\" for \"aaaa\" but \"\
    3\" for \"aaa\" and for \"a\" it returns \"1\" \n<code>\n#include <iostream>\n\
    #include <string>", "{\n    long count = 0;\n    long l = 0;\n    long r = string.length()\
    \ - substring.length;\n    while(r > 0) {\n        if (string[l] == substring[r])\n\
    \            count++;\n        l++;\n        r--;\n    }\n    return count;\n\
    }\n</code>\n<|/ a tags=string,python,c#,algorithm,c++ |>\n<| a tags=string,python,c#,algorithm,c++\
    \ |>\n<code>\ndef count(s, t):\n    i = j = 0\n    if s == \"\": return 0\n  \
    \  while i < len(s) and j < len(t):\n        if s[i:j+1] == t:\n            i\
    \ += j+1\n            j += 1\n        else:\n            i += 1\n    return j\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nWhy did you change this from counting overlapping\
    \ characters to counting overlapping strings?\n<|/ c |>\n<| a |>\nPython solution:\n\
    <code>\ndef count(s, t):\n    i = 0\n    while i < len(s) and i < len(t):\n  \
    \      if s[i] != t[i]:\n            i += 1\n        else:\n            i += 1\n\
    \    return i\n</code>\n<|/ a dscore=1 tags=string,python,c#,algorithm,c++ |>\n\
    <| a dscore=1 tags=string,python,c#,algorithm,c++ |>\nC# Solution:\n<code>\nclass\
    \ Program\n{\n    public static void Main(string[] args)\n    {\n        string\
    \ myString = \"Hello\";\n        string mySubString = \"llo\";\n        int count\
    \ = 0;", "{\n\tlong count = 0;\n\tint i, j;\n\tbool found = false;\n\t\n\tfor(i=string.length()-1;\
    \ (i>=0) && (!found); i--)\n\t{\n\t\tfound = false;\n\t\tfor(j=0; !found && (j<substring.length())\
    \ && (i>=0); j++)\n\t\t{\n\t\t\tfound = string[i+j] == substring[j];\n\t\t}\n\t\
    \tif(found)\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "{\n    long counter =\
    \ 0;\n    int start = 0;\n    int end = 0;\n    while(start < string.length())\n\
    \    {\n        end = string.length();\n        while(end > start && string.find(substring,\
    \ start) > 0) \n        {\n            end = string.find(substring, end);\n  \
    \      }\n        counter += end - start;\n        start = end + 1;\n    }\n \
    \   return counter;\n}", "{\n\tlong count = 0;\n\t\n\tif (string.empty() == false\
    \ && substring.empty() == false) \n\t{\n\t\tsize_t s_len = string.size();\n\t\t\
    size_t s_start = 0, s_end = 0;\n\t\tsize_t e_len = substring.size();\n\t\tsize_t\
    \ e_start = 0, e_end = 0;\n\t\t\n\t\tfor (size_t i = 0; i < s_len && i < e_len;\
    \ i++) \n\t\t{\n\t\t\tstring substring2;\n\t\t\t\n\t\t\tif (i >= e_start) \n\t\
    \t\t{\n\t\t\t\tsubstring2 = substring.substr(e_start-s_start,e_end-s_start);\n\
    \t\t\t\te_start = e_end+e_len;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsubstring2\
    \ = substring.substr(s_start-e_start,s_end-e_start);\n\t\t\t\ts_start = s_end+s_len;\n\
    \t\t\t}\n\t\t\t\n\t\t\tif (string[i] == substring2[0]) \n\t\t\t{\n\t\t\t\tcount\
    \ += 1;\n\t\t\t\tif (substring2 == \"aa\") \n\t\t\t\t{\n\t\t\t\t\tcount += 2;\n\
    \t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (substring2 == \"aaaa\") \n\t\
    \t\t\t\t{\n\t\t\t\t\t\tcount += 4;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\
    \t\t\t\t\t\tcount += 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif\
    \ (e_start < e_len) \n\t\t{\n\t\t\tstring substring2;\n\t\t\tif (e_end > s_start)\
    \ \n\t\t\t{\n\t\t\t\tsubstring2 = substring.substr(e_start-s_start,e_end-s_start);\n\
    \t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsubstring2 = substring.substr(s_start-e_start,s_end-e_start);\n\
    \t\t\t}\n\t\t\t\n\t\t\tif (string[s_end] == substring2[0]) \n\t\t\t{\n\t\t\t\t\
    count += 1;\n\t\t\t\tif (substring2 == \"aa\") \n\t\t\t\t{\n\t\t\t\t\tcount +=\
    \ 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (substring2 == \"aaaa\"\
    ) \n\t\t\t\t\t{\n\t\t\t\t\t\tcount += 4;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\
    \t{\n\t\t\t\t\t\tcount += 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\
    \treturn count;\n}", "{\n    long count = 0, index = 0;\n    while ((index = string.find(substring,\
    \ index)) != string::npos) \n    {\n        index = string.find(substring, index\
    \ + 1);\n        count++;\n    }\n    return count;\n}", "{\n    long count =\
    \ 0;\n    size_t pos = 0;\n    while(string[pos] == substring[pos] && pos < string.size())\
    \ \n    {\n        count++;\n        pos++;\n    }\n    return count;\n}", "{\n\
    \    if (string.length() < substring.length())\n        throw new Exception(\"\
    String length must be greater than substring length.\");", "{\n  // convert from\
    \ string to char* so we don't have to worry about unicode\n  char[] char_str =\
    \ string.ToCharArray();\n  // convert substring to char* so we don't have to worry\
    \ about unicode\n  char[] char_sub = substring.ToCharArray();\n  long num_times\
    \ = 0L;\n  long i = 1;\n  while(i < char_str.length)\n  {\n    if (char_str[i]\
    \ == char_sub[0])\n    {\n      i++;\n      if (i < char_str.length && char_str[i]\
    \ == char_sub[0]) // check for overlapping cases\n      {\n        char c = char_str[i];\n\
    \        while(i + 1 < char_str.length && char_str[i + 1] == c) // check for overlapping\
    \ cases\n        {\n          i++;\n        }\n      }\n      num_times += 1;\n\
    \    }\n    else \n    {\n      i++;\n    }\n  }\n  return num_times;\n}\n</code>\n\
    <|/ a dscore=1 tags=c#,algorithm,string |>\n<| c |>\nThis is pretty good, but\
    \ it is not exactly what the OP is asking for. I think he wants to count overlapping\
    \ sub-strings within the entire string.\n<|/ c |>\n<| c |>\nI suspect that overlapping\
    \ sub-strings is the desired output, but it may be misinterpreted.\n<|/ c |>\n\
    <| c |>\nI guessed that too, but the problem statement says: \"count overlaping\
    \ cases\" which could be interpreted to mean overlapping sub-strings.\n<|/ c |>\n\
    <| c |>\nThis solution is good enough, but in addition to this, there should be\
    \ an algorithm to detect the overlap with other string. For example, if we have\
    \ the strings aaa and bbb, the overlapping string is ab where ab should be counted\
    \ 4 times.\n<|/ c |>\n<| a tags=c#,algorithm,string dscore=0 |>\nI used a dictionary\
    \ to store the counts of each sub-string in the original string. I then iterated\
    \ through the dictionary to find the maximum value and the sub-string with that\
    \ max value.\n<code>\nusing System;\nusing System.Collections.Generic;\nusing\
    \ System.Linq;", "{\n    string result = \"\";\n    long index = 0;\n    for(int\
    \ i=0; i < string.length(); i++) \n    {\n        if(string[i] == substring[index])\
    \ \n        {\n            string sub = string.substr(index, substring.length());\n\
    \            \n            for(int j=i+1; j < string.length(); j++) \n       \
    \     {\n                if(string[j] != sub[j] && string[i] != sub[j]) \n   \
    \             {\n                    break;\n                }\n            }\n\
    \            \n            if(string[i] == sub[j] && string.length() > substring.length())\
    \ \n            {\n                result += j - i + 1;\n            }\n     \
    \       index++;\n        }\n    }\n    return result;\n}", "{\n    long count\
    \ = 0;\n    int index1 = 0;\n    int index2 = 0;\n    int i = string.find(substring);\n\
    \    while (i != -1)\n    {\n        i += substring.find(string[index1], i);\n\
    \        i += substring.find(string[index2], i);\n        count++;\n        index1++;\n\
    \        index2++;\n        i = string.find(substring, i);\n    }\n    return\
    \ count;\n}", "{\n  // TODO: Write a better version\n  long count = 0;\n  foreach(char\
    \ c in string){\n    bool is_substring = contains(substring, c);\n    count +=\
    \ (is_substring);\n  }\n  return count;\n}\n// Test it out\nstring str = \"aaaaaabcde\"\
    ;\nstring sub = \"aa\";\nlong result = how_many_times(str, sub);\nprintln(result);\n\
    </code>\n<|/ a tags=string,algorithm,c++ |>\n<| c |>\nI haven't read the question\
    \ closely, but this is definitely a good improvement.  I didn't notice that `how_many_times`\
    \ didn't return `long`.\n<|/ c |>\n<| c |>\n: Yeah, this was a quick test and\
    \ I forgot about `long` truncation. Added the `long long` version now.\n<|/ c\
    \ |>\n<| c |>\nThe return type was specified as `long`, but it seems it's actually\
    \ supposed to be `long long`. Also, what if the string is very long and the substring\
    \ is very short? It would be better if your function took a `long` instead of\
    \ a `long long`. If the string is very long, the time complexity will be O(n^2),\
    \ which is not good!\n<|/ c |>\n<| c |>\n: Yeah, I realized that too late and\
    \ fixed it. Also fixed the typo in the return type, now it returns a `long long`.\n\
    <|/ c |>\n<| a dscore=3 |>\nUsing regular expressions in Boost.Regex:\n<code>",
  "{\n   long count = 0;\n   for (int i=0;i<string.length()-1;i++) {\n      bool found\
    \ = true;\n      for (int j=0;j<substring.length();j++) {\n         if (string[i+j]\
    \ != substring[j]) {\n            found = false;\n            break;\n       \
    \  }\n      }\n      if (found)\n         count++;\n   }\n   return count;\n}\n\
    /*\n Given a string, find out what kind of string it is (letter, number, symbol,\
    \ none)\n    \n >>> find_type(\"\")\n    'None'\n >>> find_type(\"a\")\n    'Letter'\n\
    \ >>> find_type(\"1aaa\")\n    'Number'\n >>> find_type(\"1aaa\")\n    'Number'\n\
    \ >>> find_type(\"a\")\n    'Letter'\n >>> find_type(\"1a\")\n    'Letter'\n >>>\
    \ find_type(\"1aa\")\n    'Letter'\n >>> find_type(\"1aa\")\n    'Letter'\n >>>\
    \ find_type(\"1aa\")\n    'Letter'\n >>> find_type(\"1a1a\")\n    'Letter'\n >>>\
    \ find_type(\"1aa1\")\n    'Letter'\n >>> find_type(\"1aa1\")\n    'Letter'\n\
    \ >>> find_type(\"1aaaaaa\")\n    'Symbol'\n >>> find_type(\"1aaaaaa\")\n    'Symbol'\n\
    \ >>> find_type(\"1aaaaaa\")\n    'Symbol'\n >>> find_type(\"1aaaaaaa\")\n   \
    \ 'Symbol'\n >>> find_type(\"1aaaaaaa\")\n    'Symbol'\n >>> find_type(\"1aaaaaaa\"\
    )\n    'Symbol'\n >>> find_type(\"1aaaaaaaa\")\n    'Symbol'\n >>> find_type(\"\
    1aaaaaaaa\")\n    'Symbol'\n >>> find_type(\"1aaaaaaaa\")\n    'Symbol'\n >>>\
    \ find_type(\"1aaaaaaaa\")\n    'Symbol'\n >>> find_type(\"1aaaaaaa1\")\n    'Symbol'\n\
    \ >>> find_type(\"1aaaaaaa1\")\n    'Symbol'\n >>> find_type(\"1aaaaaaa1\")\n\
    \    'Symbol'\n >>> find_type(\"1aaaaaaa11\")\n    'Symbol'\n >>> find_type(\"\
    1aaaaaaa11\")\n    'Symbol'\n >>> find_type(\"1aaaaaaa11\")\n    'Symbol'\n >>>\
    \ find_type(\"1aaaaaaa11\")\n    'Symbol'\n >>> find_type(\"1aaaaaaa1111\")\n\
    \    'Symbol'\n >>> find_type", "{\n    return string.length() - string.find(substring)\
    \ -\n    (string.find(substring, string.length()) != string.length()) ? 1 : 0;\n\
    }", "{\n    long count = 0;\n    int i = string.find(substring);\n    while( i\
    \ != string.length() - substring.length() )\n    {\n        count++;\n       \
    \ i = string.find(substring, i + 1);\n    }\n    return count;\n}", "{\n  long\
    \ result = 0;\n  if(string.find(substring) == string.npos) \n    return 0L;\n\
    \  long len = string.length();\n  long sublen = substring.length();\n  long mid\
    \ = string.length() / 2;\n  string sub = substring;\n  while(string.find(sub)\
    \ != string::npos) \n  {\n    if(string.find(sub, mid) != string::npos) \n   \
    \   result++;\n    sub = substring(mid);\n  }\n  return result;\n}\n/*\n Find\
    \ the first occurrence of a substring in a string.\n    >>> find_substring(\"\"\
    , \"a\")\n    0L\n    >>> find_substring(\"a\", \"aaaa\")\n    2L\n    \n*/\n\
    long find_substring(string string, string substring) \n{\n  long result = 0;\n\
    \  if(string.find(substring) == string::npos) \n    return -1L;\n  while(string.find(substring)\
    \ != string::npos) \n  {\n    result++;\n    string = substring(string.find(substring));\n\
    \  }\n  return result;\n}\n/*\n Find the first occurrence of a substring in a\
    \ string in a specific range.\n    >>> find_substring(\"\", \"a\", \"b\")\n  \
    \  -1L\n    >>> find_substring(\"a\", \"b\", \"c\");\n    -1L\n    \n*/\nlong\
    \ find_substring(string string, string substring, long offset1, long offset2)\
    \ \n{\n  if(offset1 < 0 || offset2 < 0) \n    return -1L;\n  string str = string;\n\
    \  if(string.find(substring) == string::npos)\n    return -1L;\n  long result\
    \ = 0;\n  string sub = substring(offset1);\n  while(string.find(sub) != string::npos)\n\
    \  {\n    if(string.find(sub, offset2) != string::npos) \n      result++;\n  \
    \  str = substring(str.find(sub));\n    sub = substring(offset1);\n  }\n  return\
    \ result;\n}\n/*\n Find the last occurrence of a substring in a string.\n    >>>\
    \ find_substring(\"\", \"a\")\n    0L\n    >>> find_substring(\"a\", \"aaaa\"\
    )\n    2L\n    \n*/\nlong find_last_substring(string string, string substring)\
    \ \n{\n  long result = 0;\n  if(string.find(substring) == string::npos)\n    return\
    \ -1L;\n  while(string.find(substring) != string::npos)\n  {\n    result++;\n\
    \    string = substring(string.find(substring));\n  }\n  return result;\n}\n/*\n\
    \ Find the last occurrence of a substring in a string in a specific range.\n \
    \   >>> find_last_substring(\"\", \"a\", \"b\")\n    1L\n    >>> find_last_substring(\"\
    a\", \"b\", \"c\");\n    1L\n    \n*/\nlong find_last_substring(string string, ",
  "{\n    long pos = 0;\n    long count = 0;\n    long l1 = string.length();\n   \
    \ long l2 = substring.length();\n    while(pos < l1)\n    {\n        while(pos\
    \ < l1 && !(string[pos] == substring[pos]) && pos < l1)\n        {\n         \
    \   pos++;\n        }\n        if(pos < l1)\n        {\n            string temp;\n\
    \            temp = string.substr(pos, l1);\n            string temp2;\n     \
    \       temp2 = substring.substr(0, l2);\n            if(temp == temp2)\n    \
    \            count++;\n        }\n        pos++;\n    }\n    return count;\n}",
  "{\n  // TODO consider using a different algorithm to count overlaps\n  long count\
    \ = 0L;\n  long pos = 0;\n  string last = \"\";\n  string current;\n  string current2;\n\
    \  string current3;\n  string substring_2;\n  \n  while ((pos = string.find(substring,\
    \ pos)) != string::npos) {\n    current = string.substr(0, pos);\n    last = current;\n\
    \    current2 = string.substr(pos);\n    current3 = string.substr(pos + substring.length());\n\
    \    \n    if (current.length() <= substring.length()) {\n      substring_2 =\
    \ substring;\n    } else {\n      substring_2 = current.substr(0, substring.length());\n\
    \    }\n    \n    count += count_overlaps(last, current2, substring_2);\n    count\
    \ += count_overlaps(last, current3, substring_2);\n    pos += substring.length();\n\
    \    \n  }\n  \n  return count;\n}", "{\n\tlong count = 0;\n\tfor (auto it = string.begin();\
    \ it != string.end(); it++)\n\t{\n\t\tlong start = 0;\n\t\tfor (auto it2 = substring.begin();\
    \ it2 != substring.end(); it2++)\n\t\t{\n\t\t\tif ((*it) == (char)it2[0])\n\t\t\
    \t{\n\t\t\t\tstart = it2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (start != 0)\n\
    \t\t{\n\t\t\tstring substring_start = string.substr(start, substring.size());\n\
    \t\t\tif (substring_start.compare(substring) == 0)\n\t\t\t{\n\t\t\t\tcount++;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count all cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring)\n\
    {\n\tlong count = 0;\n\tfor (auto it = string.begin(); it != string.end(); it++)\n\
    \t{\n\t\tlong start = 0;\n\t\tfor (auto it2 = substring.begin(); it2 != substring.end();\
    \ it2++)\n\t\t{\n\t\t\tif ((*it) == (char)it2[0])\n\t\t\t{\n\t\t\t\tstart = it2;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (start != 0)\n\t\t{\n\t\t\tstring substring_start\
    \ = string.substr(start, substring.size());\n\t\t\tif (substring_start == substring)\n\
    \t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlapping cases in reverse order.\n    >>> how_many_times_reverse(\"\", \"\
    a\")\n    0L\n    >>> how_many_times_reverse(\"aaa\", \"a\")\n    3L\n    >>>\
    \ how_many_times_reverse(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times_reverse(string\
    \ string, string substring) \n{\n\tlong count = 0;\n\tfor (auto it = string.rbegin();\
    \ it != string.rend(); it++)\n\t{\n\t\tlong start = 0;\n\t\tfor (auto it2 = substring.rbegin();\
    \ it2 != substring.rend(); it2++)\n\t\t{\n\t\t\tif ((*it) == (char)it2[0])\n\t\
    \t\t{\n\t\t\t\tstart = it2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (start !=\
    \ 0)\n\t\t{\n\t\t\tstring substring_start = string.substr(start, substring.size());\n\
    \t\t\tif (substring_start.", "{\n    long count = 0;\n    size_t index = string.find(substring);\n\
    \    while ((index != string::npos) && (index < string.length()-1))\n    {\n \
    \       count += 1;\n        index = string.find(substring, index+1);\n    }\n\
    \    return count;\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i <= string.length()\
    \ - substring.length(); ++i) \n\t{\n\t\tif (string[i] == substring[0] && string[i\
    \ + substring.length()] == substring[substring.length() - 1]) \n\t\t{\n\t\t\t\
    ++count;\n\t\t\ti += substring.length();\n\t\t}\n\t}\n\treturn count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases in different directions.\n    >>> how_many_times(\"\", \"a\"\
    , -1)\n    0L\n    >>> how_many_times(\"aaa\", \"a\", -1)\n    1L\n    >>> how_many_times(\"\
    aaaa\", \"aa\", -1)\n    1L\n    \n*/\nlong how_many_times(string string, string\
    \ substring, int direction)\n{\n\tlong count = 0;\n\tfor (int i = direction ==\
    \ 0? string.length() - substring.length(): 0; i < string.length() - substring.length()\
    \ + direction; ++i)\n\t{\n\t\tif (string[i] == substring[0] && string[i + substring.length()]\
    \ == substring[substring.length() - 1]) \n\t\t{\n\t\t\t++count;\n\t\t\ti += substring.length();\n\
    \t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlaping cases in different directions.\n\
    \    >>> how_many_times(\"\", \"a\", 2)\n    0L\n    >>> how_many_times(\"aaa\"\
    , \"a\", 2)\n    2L\n    >>> how_many_times(\"aaaa\", \"aa\", 2)\n    2L\n   \
    \ \n*/\nlong how_many_times(string string, string substring, int direction, bool\
    \ search_backwards)\n{\n\tlong count = 0;\n\tfor (int i = direction == 0? string.length()\
    \ - substring.length(): 0; i < string.length() - substring.length() + direction;\
    \ ++i)\n\t{\n\t\tif (string[i] == substring[0] && string[i + substring.length()]\
    \ == substring[substring.length() - 1]) \n\t\t{\n\t\t\t++count;\n\t\t\ti += substring.length();\n\
    \t\t}\n\t}\n\tif (search_backwards) \n\t{\n\t\tfor (int i = direction == 0? 0:\
    \ string.length() - substring.length(): 0; i < string.length() - substring.length()\
    \ + direction; ++i)\n\t\t{\n\t\t\tif (string[string.length() - i - 1] == substring[0]\
    \ && string[string.length() - i - substring.length() - 1] == substring[substring.length()\
    \ - 1]) \n\t\t\t{\n\t\t\t\t++count;\n\t\t\t\ti -= substring.length();\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases in different directions.\n\
    \    >>> how_many_times(\"\", \"a\", 3, False)\n", "{\n    string result = \"\"\
    ;\n    int i = 0;\n    int j = 0;\n    int counter = 0;\n    size_t len = string.length();\n\
    \    size_t lensub = substring.length();\n    for(;i<len;i++)\n    {\n       \
    \ for(;j<lensub;j++)\n        {\n            if(string[i]==substring[j])\n   \
    \         {\n                counter++;\n                j++;\n            }\n\
    \            else\n            {\n                counter = 0;\n             \
    \   break;\n            }\n        }\n        if(counter==lensub)\n        {\n\
    \            result+=string[i];\n            counter = 0;\n        }\n       \
    \ \n    }\n    return string.length() - result.length();\n}", "{\n    long count\
    \ = 0;\n    int pos = 0;\n    while(pos < string.length()) {\n        int pos_next\
    \ = string.find(substring, pos);\n        if(pos_next == string.length())\n  \
    \          break;\n        if(pos_next == pos) {\n            count++;\n     \
    \   }\n        pos = pos_next;\n    }\n    return count;\n}", "{\n    int count\
    \ = 0;\n    int endindex = string.find(substring);\n    while (endindex != string.length()\
    \ - 1)\n    {\n        if ((string.find(substring, endindex) != string.length()\
    \ - 1) && (endindex > 0))\n        {\n            count++;\n        }\n      \
    \  endindex = string.find(substring, endindex + 1);\n    }\n    return count;\n\
    }", "{\n\tlong count = 0;\n\tlong len = string.length();\n\tlong i = len-1;\n\t\
    while(i >= 0) {\n\t\tlong ls = string.find_first_of(substring, i);\n\t\tif (ls\
    \ == -1) {\n\t\t\tbreak;\n\t\t}\n\t\ti += ls + 1;\n\t\t++count;\n\t}\n\treturn\
    \ count;\n}\n//#include \"std.string\"\n/*\n Given a string, return an array of\
    \ integers containing the number of occurrences of each character in the string.\
    \ \n    >>> char_count(\"a\")\n    [0, 0, 0]\n    >>> char_count(\"ab\")\n   \
    \ [2, 0]\n    >>> char_count(\"aba\")\n    [3, 2, 1]\n*/", "{\n    if(string ==\
    \ substring) return 0L;\n    string search = substring;\n    search = replace(search,\
    \ \"a\", \"\");\n    search = replace(search, \"b\", \"\");\n    search = replace(search,\
    \ \"c\", \"\");\n    search = replace(search, \"d\", \"\");\n    search = replace(search,\
    \ \"e\", \"\");\n    search = replace(search, \"f\", \"\");\n    search = replace(search,\
    \ \"g\", \"\");\n    search = replace(search, \"h\", \"\");\n    search = replace(search,\
    \ \"i\", \"\");\n    search = replace(search, \"j\", \"\");\n    search = replace(search,\
    \ \"k\", \"\");\n    search = replace(search, \"l\", \"\");\n    search = replace(search,\
    \ \"m\", \"\");\n    search = replace(search, \"n\", \"\");\n    search = replace(search,\
    \ \"o\", \"\");\n    search = replace(search, \"p\", \"\");\n    search = replace(search,\
    \ \"q\", \"\");\n    search = replace(search, \"r\", \"\");\n    search = replace(search,\
    \ \"s\", \"\");\n    search = replace(search, \"t\", \"\");\n    search = replace(search,\
    \ \"u\", \"\");\n    search = replace(search, \"v\", \"\");\n    search = replace(search,\
    \ \"w\", \"\");\n    search = replace(search, \"x\", \"\");\n    search = replace(search,\
    \ \"y\", \"\");\n    search = replace(search, \"z\", \"\");\n    search = replace(search,\
    \ \"0\", \"\");\n    search = replace(search, \"1\", \"\");\n    search = replace(search,\
    \ \"2\", \"\");\n    search = replace(search, \"3\", \"\");\n    search = replace(search,\
    \ \"4\", \"\");\n    search = replace(search, \"5\", \"\");\n    search = replace(search,\
    \ \"6\", \"\");\n    search = replace(search, \"7\", \"\");\n    search = replace(search,\
    \ \"8\", \"\");\n    search = replace(search, \"9\", \"\");\n    search = replace(search,\
    \ \"+\", \"\");\n    search = replace(search, \"-\", \"\");\n    search = replace(search,\
    \ \".\", \"\");\n    search = replace(search, \"/\", \"\");\n    search = replace(search,\
    \ \";\", \"\");\n    search = replace(search, \"%\", \"\");\n    search = replace(search,\
    \ \"\\\\\", \"\");\n    search = replace(search, \"'\", \"\");\n    search = replace(search,\
    \ \" \", \"\");\n    search = replace(search, \"[\", \"\");\n    search = replace(search,\
    \ \"]\", \"\");\n    search = replace(search, \"{\", \"\");\n    search = replace(search,\
    \ \"}\", \"\");\n    search = replace(search, \"(\"", "{\n    long number_of_times\
    \ = 0L;\n    int string_length = string.length();\n    for(int i = 0; i < string_length;\
    \ i++)\n    {\n        int string_pos = i;\n        int substring_length = substring.length();\n\
    \        for(int j = 0; j < substring_length; j++)\n        {\n            if(string[string_pos]\
    \ == substring[j])\n            {\n                string_pos++;\n           \
    \     j++;\n            }\n            else\n            {\n                break;\n\
    \            }\n        }\n        if(string_pos == string_length && i == string_length\
    \ - 1)\n        {\n            number_of_times++;\n        }\n    }\n    return\
    \ number_of_times;\n}\n</code>\n<|/ a dscore=2 tags=string,c++,search,algorithm\
    \ |>\n<| c |>\nWhy do you declare string_length at every iteration? You redefine\
    \ string_length at every iteration of the loop. Also, your code doesn't work because\
    \ string_pos will never reach string_length.\n<|/ c |>\n<| c |>\nThe code does\
    \ work. I ran it before answering. It doesn't matter if the declaration is in\
    \ or outside the loop.\n<|/ c |>\n<| c |>\nI edited it because I forgot to change\
    \ the string_length inside the loop.\n<|/ c |>\n<| c |>\nI still think it's a\
    \ bad idea to change the length of string inside the loop. You should use an additional\
    \ variable to store the length of the original string and increment it instead\
    \ of changing the length of the string inside the loop.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing out the mistake. I have edited my code to reflect that.\n<|/ c\
    \ |>\n<| a dscore=2 tags=string,c++,search,algorithm |>\nThis code will perform\
    \ better and is also a bit more readable (although not as pretty as other answers):\n\
    <code>\n#include <string>\n#include <iostream>\n#include <algorithm>", "{\n\t\
    long count = 0;\n\tint len = string.length();\n\tfor(int i = 0; i < len; ++i)\n\
    \t{\n\t\tint j = string.find(substring, i);\n\t\tif((j >= 0) && ((j + substring.length())\
    \ == len))\n\t\t\tcount++;\n\t\ti += substring.length();\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count all cases.\n    >>> how_many_times_all(\"a\", \"\")\n    0L\n    >>> how_many_times_all(\"\
    a\", \"a\")\n    1L\n    >>> how_many_times_all(\"aa\", \"a\")\n    1L\n    >>>\
    \ how_many_times_all(\"aaa\", \"a\")\n    2L\n*/\nlong how_many_times_all(string\
    \ string, string substring) \n{\n\tlong count = 0;\n\tint len = string.length();\n\
    \tfor(int i = 0; i < len; ++i)\n\t{\n\t\tint j = string.find(substring, i);\n\t\
    \tif((j >= 0) && ((j + substring.length()) == len))\n\t\t\tcount++;\n\t}\n\treturn\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count all cases including overlaping cases.\n    >>> how_many_times_all_overlap(\"\
    a\", \"\")\n    0L\n    >>> how_many_times_all_overlap(\"a\", \"a\")\n    1L\n\
    \    >>> how_many_times_all_overlap(\"aa\", \"a\")\n    1L\n    >>> how_many_times_all_overlap(\"\
    aaa\", \"a\")\n    2L\n*/\nlong how_many_times_all_overlap(string string, string\
    \ substring) \n{\n\tlong count = 0;\n\tint len = string.length();\n\tfor(int i\
    \ = 0; i < len; ++i)\n\t{\n\t\tint j = string.find(substring, i);\n\t\tif((j >=\
    \ 0) && ((j + substring.length()) == len))\n\t\t\tcount++;\n\t\ti++;\n\t}\n\t\
    return count;\n}\n/*\n Find how many times a given substring can be found in the\
    \ original string. Count all cases including overlaping cases.\n    >>> how_many_times_all_overlap_overlap(\"\
    a\", \"\")\n    0L\n    >>> how_many_times_all_overlap_overlap(\"a\", \"a\")\n\
    \    1L\n    >>> how_many_times_all_overlap_overlap(\"aa\", \"a\")\n    1L\n \
    \   >>> how_many_times_all_overlap_overlap(\"aaa\", \"a\")\n    2L\n*/\nlong how_many_times_all_overlap_overlap(string\
    \ string, string substring) \n{\n\tlong count = 0;\n\tint len = string.length();\n\
    \tfor(int i = 0; i < ", "{\n  int lenSubstring = string.length();\n  int lenString\
    \ = string.length();\n  int currentIndex = 0;\n  long count = long.MaxValue;",
  "{\n\tint count = 0;\n\tint length = string.Length;\n\tint substringLength = substring.Length;\n\
    \tint i;\n\tint j;", "{\n\tint i, j, c=0, m=0;\n\tlong count = 0;\n\tfor(i = 0;\
    \ i < string.length(); i++)\n\t{\n\t\tfor(j = 0; j < substring.length(); j++)\n\
    \t\t{\n\t\t\tif(i == 0 && j == 0)\n\t\t\t\tcontinue;\n\t\t\telse if(i == 0)\n\t\
    \t\t\tbreak;\n\t\t\telse if(i == string.length() - 1 && j == substring.length()\
    \ - 1)\n\t\t\t\tbreak;\n\t\t\telse if(string[i-1] == substring[j-1])\n\t\t\t\t\
    c++;\n\t\t}\n\t\tif(c == substring.length())\n\t\t{\n\t\t\tm++;\n\t\t\tc = 0;\n\
    \t\t}\n\t}\n\tcount = substring.length() * m;\n\treturn count;\n}\n/*\n Remove\
    \ all spaces from a string\n    >>> remove_spaces(\"\")\n    ''\n    >>> remove_spaces(\"\
    \  \")\n    ''\n    >>> remove_spaces(\"a b c\")\n    'abc'\n*/\nstring remove_spaces(string\
    \ string) \n{\n\tstring t = string;\n\tsize_t pos = 0;\n\twhile(pos < t.length()\
    \ && t[pos] == ' ') pos++;\n\tif(pos < t.length()) \n\t\tt.erase(pos, t.length()\
    \ - pos);\n\treturn t;\n}\n/*\n Get the index of the first occurrence of the substring\
    \ in string, or -1 if none is found.\n    >>> get_substring_index(\"\", \"\")\n\
    \    0L\n    >>> get_substring_index(\"\", \"a\")\n    0L\n    >>> get_substring_index(\"\
    \", \"b\")\n    1L\n    >>> get_substring_index(\"\", \"aa\")\n    2L\n    >>>\
    \ get_substring_index(\"\", \"ab\")\n    -1L\n    >>> get_substring_index(\"a\"\
    , \"ab\")\n    0L\n    \n*/\nlong get_substring_index(string string, string substring)\
    \ \n{\n\tint i, pos = 0;\n\tlong count = 0;\n\tfor(i = 0; i < string.length();\
    \ i++)\n\t{\n\t\tpos = string.find(substring, pos);\n\t\tif(pos == -1)\n\t\t\t\
    break;\n\t\tpos++;\n\t}\n\treturn pos;\n}\n/*\n Get the last index of the first\
    \ occurrence of the substring in string, or -1 if none is found.\n    >>> get_last_substring_index(\"\
    \", \"\")\n    0L\n    >>> get_last_substring_index(\"\", \"a\")\n    0L\n   \
    \ >>> get_last_substring_index(\"\", \"b\")\n    1L\n    >>> get_last_substring_index(\"\
    \", \"aa\")\n    2L\n    >>> get_last_substring_index(\"\", \"ab\")\n    -1L\n\
    \    >>> get_last_substring_index(\"a\", \"ab\")\n    0L\n    \n*/\nlong get_last_substring_index(string\
    \ string, string substring) \n{\n\tint i, pos = 0;\n\tlong count = 0;\n\tfor(i\
    \ = 0; i < string.length(); i++)\n\t{\n\t\tpos = ", "{\n    if(string.length()\
    \ <= substring.length()){\n        return 0;\n    }\n    string result = string;\n\
    \    int i = 1;\n    int n = string.length();\n    while(i < n)\n    {\n     \
    \   i++;\n        int j = i;\n        int k = 0;\n        while(j < n && k < substring.length())\n\
    \        {\n            if(string[j] == substring[k])\n            {\n       \
    \         k++;\n                j++;\n            }\n            else\n      \
    \      {\n                k = 0;\n            }\n        }\n        if(k == substring.length())\n\
    \        {\n            result += string[i];\n        }\n    }\n    return result;\n\
    }", "{\n    long count = 0;\n    long index = 0;\n    for (index = 0; string[index];\
    \ ++index)\n        if (string[index] == substring[0]) \n            count++;\n\
    \        else if (string[index] == substring[1])\n        {\n            if (++index\
    \ >= string.length) \n                break;\n            count += how_many_times(string.substr(index),\
    \ substring);\n        }\n    return count;\n}", "{\n    long n = 0;\n    for\
    \ (int i = 0; i < string.length(); i++)\n    {\n        if (string.compare(string[i],\
    \ substring) == 0)\n            ++n;\n    }\n    return n;\n}", "{\n    int n\
    \ = string.length();\n    if (substring.length() <= n) return 0;\n    long count\
    \ = 0;\n    bool isFound = false;\n    for (int i = 0, imax = string.length()\
    \ - substring.length() + 1; i < imax; ++i) {\n        if (string.substring(i,\
    \ i + substring.length()) == substring) {\n            count += 1;\n         \
    \   isFound = true;\n            break;\n        }\n    }\n    if (!isFound) {\n\
    \        string reverseString = string;\n        reverseString.reverse();\n  \
    \      for (int i = 0, imax = substring.length() - 1; i < imax; ++i) {\n     \
    \       if (reverseString.substring(i, i + substring.length()) == substring) {\n\
    \                count += 1;\n                break;\n            }\n        }\n\
    \    }\n    return count;\n}\n</code>\n<|/ a tags=c#,python |>\n<| c |>\nThis\
    \ does not answer the question. The OP asked how to count overlapping occurrences\
    \ of characters, not how often a substring exists in a string.\n<|/ c |>\n<| a\
    \ |>\nAnother approach is using the String.IndexOfAny() method to find all matches\
    \ of the substring then increment the counter if it exists in a string. \n<code>\n\
    string str = \"aaabbbccd\";\nstring substring = \"aa\";", "{\n\tlong howmany =\
    \ 0;\n\tint len = string.length() - substring.length();\n\tfor (int i = 0; i <\
    \ len; i++)\n\t{\n\t\tif (string.charAt(i) == substring.charAt(i))\n\t\t{\n\t\t\
    \thowmany++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (string.charAt(i) == substring.charAt(len\
    \ - (i + 1)))\n\t\t\t{\n\t\t\t\thowmany++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\
    \t\tif (string.charAt(i) == substring.charAt(0))\n\t\t\t\t{\n\t\t\t\t\thowmany++;\n\
    \t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (string.charAt(i) == substring.charAt(len\
    \ - (len - (i - 1))))\n\t\t\t\t\t{\n\t\t\t\t\t\thowmany++;\n\t\t\t\t\t}\n\t\t\t\
    \t}\n\t\t\t}\n\t\t}\n\t}\n\treturn howmany;\n}\n/*\n Given a substring and a string,\
    \ return a new string in which all characters have been repeated the exact number\
    \ of times.\n    >>> repeat_string(\"ab\", \"ababab\")\n    \"abababababababababababababab\"\
    \n*/\nstring repeat_string(string substring, string string)\n{\n\tint length =\
    \ 0;\n\tbool found = false;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\
    \t\tif (string.charAt(i) == substring.charAt(0))\n\t\t{\n\t\t\tfound = true;\n\
    \t\t\tlength = 1;\n\t\t}\n\t\telse if (string.charAt(i) == substring.charAt(1))\n\
    \t\t{\n\t\t\tlength++;\n\t\t}\n\t\telse if (string.charAt(i) == substring.charAt(length))\n\
    \t\t{\n\t\t\tlength++;\n\t\t}\n\t\telse if (!found)\n\t\t{\n\t\t\treturn string\
    \ + string;\n\t\t}\n\t}\n\treturn string;\n}\n/*\n Given two strings, return a\
    \ new string in which all characters from string have been repeated the exact\
    \ number of times.\n    >>> repeat_string(\"ab\", \"ababab\")\n    \"abababababababababababababab\"\
    \n*/\nstring repeat_string2(string substring, string string)\n{\n\tint length\
    \ = 0;\n\tbool found = false;\n\tfor (int i = 0; i < string.length(); i++)\n\t\
    {\n\t\tif (string.charAt(i) == substring.charAt(length))\n\t\t{\n\t\t\tlength++;\n\
    \t\t}\n\t\telse if (string.charAt(i) == substring.charAt(0))\n\t\t{\n\t\t\tlength\
    \ = 1;\n\t\t\tfound = true;\n\t\t}\n\t\telse if (!found)\n\t\t{\n\t\t\treturn\
    \ string + string;\n\t\t}\n\t}\n\treturn string;\n}\n/*\n Given a string and a\
    \ number, return a new string in which all characters have been repeated the exact\
    \ number of times.\n    >>> repeat_string(\"ab\", 2)\n    \"ababab\"\n*/\nstring\
    \ repeat_string3(string string, int number)\n{\n\tstring result = \"\";\n\tint\
    \ length = 0;\n\tbool found = false;\n\tfor (int i = 0; i < string.length(); i++)\n\
    \t{\n\t\tif (string.charAt(", "{\n    long count = 0, i = string.find(substring);\n\
    \    while (i>=0) {\n        count++;\n        i = string.find(substring, i+1);\n\
    \    }\n    return count;\n}", "{\n    int count = 0;\n    string p = string;\n\
    \    long len = string.length();\n    \n    while (p != substring) {\n       \
    \ p = p.substr(0, p.length() - 1);\n        len--;\n    }\n    \n    while (p\
    \ != string) {\n        p = p.substr(0, p.length() - 1);\n        count++;\n \
    \   }\n    return count;\n}\n</code>\n<|/ a tags=algorithm |>\n<| c |>\nI'm a\
    \ bit confused -- why `string.length() - 1` instead of just `string.length()`?\n\
    <|/ c |>\n<| c |>\nBecause if the string was the empty string then `string.length()`\
    \ is 0.\n<|/ c |>\n<| a tags=algorithm |>\nThis works by checking every substring\
    \ against the entire string and adding 1 each time that string occurs.\n<code>",
  "{\n    long count = 0;\n    size_t pos = 0;\n    while(pos < string.length())\n\
    \    {\n        size_t endpos = string.find(substring, pos);\n        if(endpos\
    \ != string.length())\n        {\n            count += 1;\n            pos = endpos\
    \ + substring.length();\n        }\n        else\n        {\n            pos =\
    \ string.length();\n        }\n    }\n    return count;\n}\n/*\n Find if one string\
    \ is contained in another. Case insensitive.\n    >>> contains_substring(\"abcdefg\"\
    , \"abc\")\n    True\n    >>> contains_substring(\"abcdefg\", \"bcd\")\n    False\n\
    \    \n*/", "{\n    size_t len = string.length();\n    size_t n1 = substring.length();\n\
    \    size_t n2 = substring.length();\n    long count = 0;\n    \n    size_t start\
    \ = 0, end = 0;\n    while(start < len) {\n        end = string.find(substring,\
    \ start);\n        \n        if(end == string::npos) {\n            return count;\n\
    \        }\n        \n        count += end - start;\n        start = end + n2;\n\
    \    }\n    return count;\n}\n</code>\n<|/ a |>\n<| c |>\nThat doesn't do overlapped\
    \ cases.\n<|/ c |>\n<| c |>\n: I didn't look at the example cases, but I suspect\
    \ that they were all covered.\n<|/ c |>\n<| c |>\nYou're right, I missed the overlapped\
    \ cases.  I edited my answer.\n<|/ c |>\n<| c |>\nOh that is really nice. I will\
    \ try this one. Thanks\n<|/ c |>\n<| c |>\nYou don't have to make a new string\
    \ if you just want to increment a variable. `count++;` will do fine and I believe\
    \ that the compiler would optimize that even further.\n<|/ c |>\n<| a tags=c++,algorithm,python\
    \ |>\nThis seems to work quite well - it's fast and doesn't do all the complicated\
    \ logic for the edge cases (it finds the overlapping substrings twice).\n<code>\n\
    >>> def how_many_times(string, substring):\n...     count = 0\n...     for c in\
    \ string:\n...         if substring in string:\n...             count = string.count(substring)\n\
    ...             break\n...         elif c in substring:\n...             count\
    \ += 1\n...             substring = substring.replace(c, \"\")\n...     return\
    \ count\n... \n>>> how_many_times(\"ab\", \"bc\")\n2\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nOh that is really nice. I will try this one. Thanks\n<|/ c |>\n\
    <| c |>\nThis is not an efficient way to do it.  It will take O(n^2) time in the\
    \ worst case.\n<|/ c |>\n<| c |>\n- What do you suggest as an improvement?\n<|/\
    \ c |>\n<| c |>\nThe best answer would be to give a correct answer with O(n) runtime\
    \ and O(n) space.  I doubt it's possible to get better than that.\n<|/ c |>\n\
    <| c |>\n: In that case, my answer below should be used.\n<|/ c |>\n<| a dscore=1\
    \ |>\n", "{\n    long count;\n    if (string.empty())\n        return 0;\n   \
    \ if (substring.empty())\n        return string.count(substring);\n    string\
    \ first_half = string.substr(0, string.find(substring));\n    string last_half\
    \ = string.substr(string.find(substring) + substring.length());\n    count = first_half.count(substring);\n\
    \    if (first_half.empty())\n        return count;\n    count = first_half.count(substring)\
    \ + count;\n    return count + how_many_times(last_half, substring);\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nNice idea but the OP said he wanted the result to\
    \ be a `long` which doesn't allow for multiple occurrences.\n<|/ c |>\n<| c |>\n\
    - Yes, I realized that, and updated the solution. Thanks for the suggestion!\n\
    <|/ c |>\n<| a tags=algorithm,string,search,java,data-structures dscore=1 |>\n\
    The OP asked for a solution that doesn't use regex. Here is a solution using String\
    \ methods and some simple recursion.\n<code>\npublic long howManyTimes(String\
    \ s, String p)\n{\n    if (s == null || s == p)\n        return 1;", "{\n\tint\
    \ result = 0;\n\tint l1 = string.find(substring);\n\tif(l1 != -1){\n\t\tint l2\
    \ = string.find(substring, l1+1);\n\t\twhile(l2 != -1 && l2 != l1){\n\t\t\tl1++;\n\
    \t\t\tl2++;\n\t\t\tresult++;\n\t\t}\n\t}\n\treturn result;\n}", "{\n    return\
    \ string.length() - string.toLowerCase().indexOf(substring.toLowerCase()) - string.toLowerCase().indexOf(string.toLowerCase(),\
    \ string.toLowerCase().indexOf(substring) + substring.length());\n}\n</code>\n\
    <|/ a tags=algorithm,c++ |>\n<| c |>\nYour solution assumes case-insensitivity,\
    \ which may not be the case. See my answer.\n<|/ c |>\n<| c |>\nI edited the answer\
    \ to include a case insensitive search. Thanks.\n<|/ c |>\n<| c |>\nI appreciate\
    \ the effort put into this, but in practice, this solution is both slow (because\
    \ you are converting to lowercase and searching), and even slower because you\
    \ are iterating over the string twice.\n<|/ c |>\n<| c |>\nIt's not the iterating\
    \ twice.  Both indexOf and toLowerCase will iterate over the string twice per\
    \ call.  The slow part is actually the lowercasing.  The other part is iterating\
    \ over the string once and storing the start index of each substring so you can\
    \ count how many of each it found at one time.\n<|/ c |>\n<| a tags=algorithm,c++\
    \ dscore=2 |>\nHere's a Python implementation of Christopher Taylor's algorithm:\n\
    <code>\ndef how_many_times(string, substring):\n    pos = 0\n    while pos < len(string):\n\
    \        pos = string.index(substring, pos)\n        pos += 1\n        if pos\
    \ == len(string):\n            return 1\n    return 0\n</code>\n<|/ a |>\n<| c\
    \ |>\nI thought I did the same in C++.  I guess not.  It was more or less the\
    \ exact same thing.\n<|/ c |>\n<| a dscore=2 |>\nThis solution uses only standard\
    \ library functions. It works with case-insensitive searches only.\n<code>\n#include\
    \ <string>", "{\n\tlong count = 0;\n\t\n\tstring temp_substring = substring;\n\
    \t\n\tdo\n\t{\n\t\tlong substring_index = string.find(temp_substring);\n\t\t\n\
    \t\tif (substring_index == string.length() - temp_substring.length())\n\t\t\t\
    return count;\n\t\t\n\t\tcount += substring_index;\n\t\t\n\t\ttemp_substring +=\
    \ \"a\";\n\t} while (temp_substring.length() < substring.length());\n\t\n\treturn\
    \ count;\n}", "{\n    long length = 0;\n    long count = 0;\n    string tmp =\
    \ \"\";\n    \n    for (int i = 0; i < string.size(); ++i)\n    {\n        if\
    \ (string[i] == substring[0]) \n        {\n            tmp = substring;\n    \
    \        \n            for (int j = 1; j < substring.length(); ++j)\n        \
    \    {\n                if (string[i + j] != substring[j])\n                {\n\
    \                    tmp += string[i + j];\n                    break;\n     \
    \           }\n                tmp += string[i + j];\n            }\n        \
    \    \n            count++;\n            \n            tmp = tmp.substr(0, tmp.length()\
    \ - 1);\n            \n            if (tmp == substring)\n                length\
    \ += (substring.length() - 1);\n        }\n    }\n    \n    return count;\n}\n\
    /*\n Find the longest substring that begins with a given substring.\n    >>> longest_substring(\"\
    \", \"a\")\n    \"\"\n    >>> longest_substring(\"\", \"ab\")\n    \"b\"\n   \
    \ >>> longest_substring(\"ab\", \"c\")\n    \"bc\"\n    >>> longest_substring(\"\
    ab\", \"bc\")\n    \"bc\"\n    \n*/\nstring longest_substring(string string, string\
    \ substring) \n{\n    long len = 0;\n    string result = \"\";\n    \n    for\
    \ (int i = 0; i < string.size(); ++i)\n    {\n        if (string[i] == substring[0])\
    \ \n        {\n            result = substring;\n            \n            for\
    \ (int j = 1; j < substring.length(); ++j)\n            {\n                if\
    \ (string[i + j] != substring[j])\n                {\n                    result\
    \ += string[i + j];\n                    break;\n                }\n         \
    \       result += string[i + j];\n            }\n            \n            len\
    \ += (substring.length() - 1);\n        }\n    }\n    \n    return result.substr(0,\
    \ len);\n}\n/*\n Reverse a string\n    >>> reverse_string(\"hello\")\n    \"olleh\"\
    \n    \n*/\nstring reverse_string(string string) \n{\n    string reverse = \"\"\
    ;\n    \n    for (int i = 0; i < string.size(); ++i)\n    {\n        reverse +=\
    \ string[string.size() - 1 - i];\n    }\n    \n    return reverse;\n}\n/*\n Convert\
    \ an IP address string into four integers.\n    >>> ip_to_int(\"127.0.0.1\")\n\
    \    (127, 0, 0, 1)\n    >>> ip_to_int(\"255.255.255.255\")\n    (255, 255, 255,\
    \ 255)\n    \n*/\nvector<int> ip_to_int(string ip) \n{\n    vector<int> values;\n\
    \    \n    for (int i = ip.find(\".\") - 1; i <= ip.length(); ++i)\n    {\n  \
    \      if (i == 0)\n        {\n            values.push_back(0);\n        }\n \
    \       else\n        {\n            values.push_back(ip - ip.substr(0, i));\n\
    \        }\n    }\n    \n    return values;\n}\n", "{\n    long len = string.length();\n\
    \    if(len == 0) return 0L;\n    long pos = string[len - substring.lenght()].indexOf(substring);\n\
    \    if(pos == -1) return 0L;\n    long start = 0; \n    long end = len;\n   \
    \ while(end > start) {\n        long mid = (end - start) / 2 + start;\n      \
    \  if(string[mid].equals(substring)) {\n            return mid - start;\n    \
    \    }\n        if(string[mid].compareEndsWith(substring) == 1) {\n          \
    \  end = mid;\n        } else {\n            start = mid;\n        }\n    }\n\
    \    return len;\n}", "{\n    // count overlaping cases by summing up each substring\
    \ with each substring in the string\n    long sum = 0;\n    for(int i = 0; i <\
    \ string.length(); i++) {\n        for(int j = i; j < string.length(); j++) {\n\
    \            sum += how_many_times(string.substr(i, j+1), substring);\n      \
    \  }\n    }\n    return sum;\n}\n</code>\nThe function how_many_times() takes\
    \ substrings in two string parameters and returns the number of substrings within\
    \ the first string that are also found within the second string. For example,\
    \ how_many_times(\"abra\", \"bra\") returns 1, because the first substring \"\
    bra\" contains itself within \"abra\".\n<|/ a dscore=2 |>\n<| a tags=algorithm,string\
    \ |>\nThis is an old thread but I am new to python and I hope this helps.\nHere\
    \ is code using python 3.7.1.\n<code>\ndef overlapping_substring(text1, text2):\n\
    \    temp = []\n    count = 0\n    for index in range(len(text1)):\n        temp.extend([text1[i:i\
    \ + len(text2)] for i in range(len(text1) - index + 1)])\n    for substring in\
    \ temp:\n        if substring[::-1] in text2:\n            count += 1\n    return\
    \ count", "{\n\tstring substr;\n\tsize_t substrLen = substring.Length;\n\tlong\
    \ times = 0;\n\tstring str;\n\t\n\tstr = string;\n\twhile (str.Length > 0)\n\t\
    {\n\t\tsubstr = str.Substring(0,substrLen);\n\t\tif (string.StartsWith(substring))\n\
    \t\t{\n\t\t\t++times;\n\t\t}\n\t\tstr = str.Substring(substrLen);\n\t}\n\treturn\
    \ times;\n}\n'''", "{\n  // Count all occurrences first\n  long total = 0;\n \
    \ long substringLen = string.length();\n  long i = string.length() - substringLen;\n\
    \  while(i >= 0) \n  {\n    while(i >= 0 && !string[i] == substring[0]) {\n  \
    \    i -= 1;\n    }\n    \n    if(i < 0) break;\n    \n    total += 1;\n    \n\
    \    string subStringWithAtLeastOneMore = string.substr(0, i);\n    total += how_many_times(subStringWithAtLeastOneMore,\
    \ substring);\n    \n    string subStringWithAtMostOneMore = string.substr(i);\n\
    \    total += how_many_times(subStringWithAtMostOneMore, substring);\n    \n \
    \   i -= 1;\n  }\n  \n  // Now subtract from total those that don't match\n  long\
    \ subStringLen = substring.length();\n  long j = 0;\n  string subStringWithAtLeastOneLess\
    \ = substring;\n  while(j < substringLen) {\n    if(!string[j] == subStringWithAtLeastOneLess[j])\
    \ {\n      total -= 1;\n      subStringWithAtLeastOneLess = string.substr(j +\
    \ 1);\n    }\n    \n    j ++;\n  }\n  \n  return total;\n}", "{\n    if (string.empty())\
    \ return 0;\n    if (substring.empty()) return 0;", "{\n    string lower_string\
    \ = string;\n    string upper_string = string;\n    string lower_substring = substring;\n\
    \    string upper_substring = substring;", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        for(int j = 0; j < substring.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count++;\n                break;\n            }\n        }\n\
    \    }\n    return count;\n}\n/*\n Split a string into substrings of size size\
    \ chars.\n    Each substring will be of length size-1 and the substring before\
    \ the last will be of size size\n    Each substring will be of length size-1 and\
    \ the substring after the first will be of size size\n    >>> how_many_times(\"\
    aaabccabdaa\", \"ab\", 2)\n    5L\n    >>> how_many_times(\"aaabccabdaa\", \"\
    ab\", 1)\n    4L\n*/\ntuple<string, string, int> how_many_times(string string,\
    \ string substring, int size) \n{\n    for(int i = 0; i < string.length(); i +=\
    \ size)\n    {\n        if(how_many_times(string.substr(i, size), substring, size)\
    \ == 1)\n        {\n            if(how_many_times(string.substr(i, size - 1),\
    \ substring, size) == 0)\n            {\n                return make_pair(string.substr(i,\
    \ size), string.substr(i + 1, size), size);\n            }\n        }\n    }\n\
    \    throw runtime_error(\"Substring not found\");\n}", "{\n    size_t pos = string.find(substring);\n\
    \    if(pos == string.length() - substring.length())\n        return 0L;\n   \
    \ \n    long result = 0L;\n    \n    for(size_t i = 1; i < substring.length();\
    \ ++i)\n    {\n        string substring_copy = substring;\n        \n        while(string.find(substring_copy)\
    \ != string.length() - substring.length())\n            substring_copy += substring;\n\
    \        \n        result += string.find(substring_copy, pos + substring.length())\
    \ - pos;\n    }\n    \n    return result;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlapping cases and keep\
    \ only the first occurrence.\n    >>> how_many_times(\"\", \"a\")\n    0L\n  \
    \  >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    2L\n    \n*/\nlong how_many_times_keep_first_occurrence(string\
    \ string, string substring)\n{\n    size_t pos = string.find(substring);\n   \
    \ if(pos == string.length() - substring.length())\n        return 0L;\n    \n\
    \    long result = 0L;\n    \n    for(size_t i = 1; i < substring.length(); ++i)\n\
    \    {\n        string substring_copy = substring;\n        \n        while(string.find(substring_copy)\
    \ != string.length() - substring.length())\n            substring_copy += substring;\n\
    \        \n        if(string.find(substring_copy, pos + substring.length()) !=\
    \ string.length() - substring.length())\n            continue;\n        \n   \
    \     result += string.find(substring_copy, pos + substring.length()) - pos;\n\
    \        \n        break;\n    }\n    \n    return result;\n}", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < string.size(); i++)\n\t{\n\t\tif (string[i] == substring[0]\
    \ && string[i + 1] == substring[1])\n\t\t{\n\t\t\tcount++;\n\t\t\ti += 2;\n\t\t\
    }\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn count;\n}\n//#include <Python.h>", "{\n\
    \tlong count = 0;\n\tbool found = false;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string.substring(i, i + substring.length()) == substring) {\n\
    \t\t\tfound = true;\n\t\t\tcount++;\n\t\t}\n\t\telse if (found) {\n\t\t\treturn\
    \ count;\n\t\t}\n\t}\n\treturn count;\n}", "{\n\tlong length_string = string.length();\n\
    \tlong length_substring = substring.length();\n\tint count_substr = 0;\n\tfor(int\
    \ i = 0; i < length_string; i++)\n\t{\n\t\tfor(int j = 0; j < length_substring;\
    \ j++)\n\t\t{\n\t\t\tif(string[i] == substring[j])\n\t\t\t{\n\t\t\t\tcount_substr++;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count_substr;\n}", "{\n    if(string.length()\
    \ <= substring.length())\n        return 0;\n    if(string.compare(0, substring.length(),\
    \ substring) == 0)\n        return 1;\n    int index = string.find(substring);\n\
    \    while(index != -1) {\n        int startIndex = index;\n        index = string.find(substring,\
    \ index + 1);\n        if(startIndex < index)\n            index -= index - startIndex\
    \ + 1;\n        else\n            index -= startIndex;\n    }\n    return 1;\n\
    }\n</code>\n<|/ a tags=string,substring,c# |>\n<| a dscore=4 |>\nI have written\
    \ a generic function which you can use to count how many times a substring can\
    \ be found in a string. \n<code>\nstring word = \"hello\";\nstring sub = \"l\"\
    ;", "{\n    if (string.find(substring) == string.length())\n    {\n        return\
    \ 0;\n    }\n    \n    string substring1 = substring;\n    \n    size_t start\
    \ = 0;\n    size_t end = string.length();\n    size_t pos;\n    \n    string result=substring1;\n\
    \    \n    while(start < string.length() && end > 0)\n    {\n        pos = string.find(substring1,\
    \ start);\n        if (pos != string.length())\n        {\n            result\
    \ = substring1 + result;\n            start = pos+1;\n        }\n        else\n\
    \        {\n            start = end-1;\n            end = 0;\n        }\n    }\n\
    \    \n    if (end == 0)\n    {\n        result = substring1 + result;\n    }\n\
    \    \n    return string.length() - result;\n}", "{\n    long count = 0;\n   \
    \ for (auto it = string.begin(); it != string.end(); ++it) {\n        if (it==string.length())\
    \ break;\n        if (string[it] == substring[0]) {\n            count++;\n  \
    \          if (it == string.length() || (string[it+1] == substring[1])) {\n  \
    \              count++;\n                if (it == string.length() || (string[it+2]\
    \ == substring[2])) {\n                    count++;\n                }\n     \
    \       }\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0 tags=string,algorithm\
    \ |>\n<| a tags=string,algorithm |>\nI created this function for c++\n<code>\n\
    #include<bits/stdc++.h>\nusing namespace std;", "{\n    size_t string_len = string.length();\n\
    \    size_t substring_len = substring.length();\n    size_t counter = 0;\n   \
    \ size_t i = 0, j = 0;\n    while (i < string_len) {\n        while (j < substring_len)\
    \ {\n            if (string[i] == substring[j])\n                counter++;\n\
    \            else\n                break;\n            j++;\n        }\n     \
    \   i = i + 1;\n        j = 0;\n    }\n    return counter;\n}", "{\n\tlong length\
    \ = (string.length()+substring.length()) - 1;\n\tfor(int i = 0; i <= length; i++)\
    \ \n\t{\n\t\tint j;\n\t\tfor (j = 0; j < substring.length(); j++) \n\t\t{\n\t\t\
    \tif (string[i+j] != substring[j])\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\
    \tif (j == substring.length())\n\t\t{\n\t\t\treturn i+1;\n\t\t}\n\t}\n\treturn\
    \ 0L;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int startIndex, int endIndex) \n{\n\tlong length = (string.length()+substring.length())\
    \ - 1;\n\tfor(int i = startIndex; i <= endIndex; i++) \n\t{\n\t\tint j;\n\t\t\
    for (j = 0; j < substring.length(); j++) \n\t\t{\n\t\t\tif (string[i+j] != substring[j])\n\
    \t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == substring.length())\n\t\t\
    {\n\t\t\treturn i+1;\n\t\t}\n\t}\n\treturn 0L;\n}\n/*\n Find how many times a\
    \ given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int startIndex) \n{\n\tlong\
    \ length = (string.length()+substring.length()) - 1;\n\tfor(int i = startIndex;\
    \ i <= length; i++) \n\t{\n\t\tint j;\n\t\tfor (j = 0; j < substring.length();\
    \ j++) \n\t\t{\n\t\t\tif (string[i+j] != substring[j])\n\t\t\t{\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t\tif (j == substring.length())\n\t\t{\n\t\t\treturn i+1;\n\t\
    \t}\n\t}\n\treturn 0L;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, ", "{\n\
    \    string result = \"\";\n    string tmp = string;\n    long count = 0;\n  \
    \  int len = substring.length;\n    int i;\n    \n    for(i = 0; i < tmp.length();\
    \ ++i) {\n        string t = tmp[i];\n        if(t.length() == len)\n        \
    \    if(t == substring) {\n                count ++;\n            } else {\n \
    \               if(count == 0) {\n                    result = tmp;\n        \
    \            break;\n                }\n                if(count > 1) {\n    \
    \                result = \"(\" + result + \")\";\n                }\n       \
    \         result = \"(\" + tmp + \")\";\n                count = -1;\n       \
    \     }\n    }", "{\n\tlong counter = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++) \n\t{\n\t\tif (string[i] == substring[0]) \n\t\t{\n\t\t\tfor (int j = 1;\
    \ j < substring.length(); j++) \n\t\t\t{\n\t\t\t\tif (string[i + j] != substring[j])\
    \ \n\t\t\t\t{\n\t\t\t\t\t++counter;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn counter;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string pattern) \n{\n\tlong counter = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++) \n\t{\n\t\tif (string[i] == substring[0]) \n\t\t{\n\t\t\tfor (int j = 1;\
    \ j < substring.length(); j++) \n\t\t\t{\n\t\t\t\tif (string[i + j] != substring[j])\
    \ \n\t\t\t\t{\n\t\t\t\t\tif (string.find(pattern, i) == string.find(pattern, i)\
    \ + pattern.length())\n\t\t\t\t\t\t++counter;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn counter;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string pattern, int start) \n{\n\tlong counter = 0;\n\tfor (int i = start; i\
    \ < string.length(); i++) \n\t{\n\t\tif (string[i] == substring[0]) \n\t\t{\n\t\
    \t\tfor (int j = 1; j < substring.length(); j++) \n\t\t\t{\n\t\t\t\tif (string[i\
    \ + j] != substring[j]) \n\t\t\t\t{\n\t\t\t\t\tif (string.find(pattern, i) ==\
    \ string.find(pattern, i) + pattern.length())\n\t\t\t\t\t\t++counter;\n\t\t\t\t\
    \tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn counter;\n}", "{\n\tsize_t\
    \ offset = 0;\n\tsize_t substringLen = substring.length();\n\tsize_t stringLen\
    \ = string.length();\n\tsize_t count = 0;\n\tsize_t maxCount = 0;\n\tfor (size_t\
    \ i = 0; i < stringLen; ++i)\n\t{\n\t\tsize_t j;\n\t\tfor (j = 0; j < substringLen;\
    \ ++j)\n\t\t{\n\t\t\tif (string[i] == substring[j]) \n\t\t\t{\n\t\t\t\tcount +=\
    \ 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (count == substringLen)\n\t\t{\n\t\
    \t\tmaxCount = count;\n\t\t\tcount = 0;\n\t\t\t++i;\n\t\t}\n\t\telse if (count\
    \ > maxCount)\n\t\t{\n\t\t\tmaxCount = count;\n\t\t}\n\t}\n\treturn maxCount;\n\
    }", "{\n\tlong num_occurrences = 0;\n\tfor (auto i = 0; i < string.length(); ++i)\
    \ {\n\t\tfor (auto j = 0; j < substring.length(); ++j) {\n\t\t\tif (string.substr(i,\
    \ j) == substring) {\n\t\t\t\t++num_occurrences;\n\t\t\t}\n\t\t\tif (string.substr(i,\
    \ j + 1) != substring) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn num_occurrences;\n\
    }", "{\n\tstring s = string;\n\tlong count = 0;\n\tfor (int i = 0; i < s.length();\
    \ i++)\n\t{\n\t\tint found = 0;\n\t\tfor (int j = 0; j < substring.length(); j++)\n\
    \t\t{\n\t\t\tif (s[i] == substring[j])\n\t\t\t{\n\t\t\t\tfound++;\n\t\t\t}\n\t\
    \t}\n\t\tif (found == substring.length())\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\
    \treturn count;\n}", "{\n    int i=0;\n    while(string[i]!='\\0')\n    {\n  \
    \      int j=0;\n        while(substring.compare(string,j,i+1,1)==0)\n       \
    \ {\n            j++;\n        }\n        if(j==string.length())\n        {\n\
    \            return i;\n        }\n        i++;\n    }\n    return -1L;\n}", "{\n\
    \  long result = 0;\n  for (int i = 0; i < string.length(); i++) {\n    int len\
    \ = substring.size();\n    if (len > string.length() - i)\n      len = string.length()\
    \ - i;\n    for (int j = 0; j < len; j++) {\n      if (string.substr(i, j+len)\
    \ == substring) {\n        result++;\n        i += len;\n        continue;\n \
    \     }\n      if (string.substr(i, j) == substring) {\n        result += 1;\n\
    \      }\n    }\n  }\n  return result;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool allow_overlap) \n{\n  long result = 0;\n  for (int i = 0; i < string.length();\
    \ i++) {\n    int len = substring.size();\n    if (len > string.length() - i)\n\
    \      len = string.length() - i;\n    for (int j = 0; j < len; j++) {\n     \
    \ if (string.substr(i, j+len) == substring) {\n        result++;\n        i +=\
    \ len;\n        continue;\n      }\n      if (string.substr(i, j) == substring)\
    \ {\n        result += 1;\n      }\n    }\n  }\n  if (allow_overlap && result\
    \ > 0) {\n    return result - 1;\n  }\n  return result;\n}", "{\n    size_t i,\
    \ size = string.length();\n    long count = 0;\n    for(i = 0; i < size; ++i)\
    \ {\n        if(string[i] == substring[0]) {\n            string substring_no_0\
    \ = substring.substr(1, substring.length());\n            if(how_many_times(string.substr(1,\
    \ i), substring_no_0) > 0) ++count;\n        }\n    }\n    return count;\n}\n\
    </cell>\n<cell>\n%timeit how_many_times(\"\", \"a\")\n</cell>\n<cell>\n%timeit\
    \ how_many_times(\"aaa\", \"a\")\n</cell>\n<cell>\n%timeit how_many_times(\"aaaa\"\
    , \"aa\")\n</cell>\n<cell>\n%timeit how_many_times(\"aaaaa\", \"a\")\n</cell>\n\
    <cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"a\"\
    )\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"b\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"c\") # c is not present in the input\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"d\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"e\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"f\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"g\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"h\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"i\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"j\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"k\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"l\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"m\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"n\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
  "{\n    long count = 0;\n    for(auto iter: string) \n    {\n        if(iter.find(substring)\
    \ != string::npos) \n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}", "{\n    string substring_lowercase, result_lowercase, how_many_times_lowercase,\
    \ result;", "{\n    long count_matches = 0;\n    size_t pos = 0;\n    size_t start_pos\
    \ = 0;\n    string search_string = substring;\n    if (string.length() == 0) \n\
    \        return 0L;\n    \n    for(size_t i = 1; i < string.length(); i++) \n\
    \    {\n        while ( search_string.length() > 0 && search_string[pos] == string[i]\
    \ ) \n        {\n            pos++;\n            search_string = search_string.substr(1);\n\
    \            count_matches += (pos - start_pos);\n        }\n        start_pos\
    \ = pos;\n        pos = 0;\n    }\n    return count_matches;\n}", "{\n\tlong count\
    \ = 0;\n\tif (string == substring)\n\t{\n\t\treturn 1;\n\t}\n\t\n\tif (string.Length\
    \ > substring.Length)\n\t{\n\t\treturn 0;\n\t}\n\t\n\tfor (int i = 0; i < string.Length;\
    \ i++)\n\t{\n\t\tfor (int j = 0; j < substring.Length; j++)\n\t\t{\n\t\t\tif (string[i]\
    \ == substring[j])\n\t\t\t{\n\t\t\t\tcount += how_many_times(string.Substring(i\
    \ + 1, string.Length - i), substring);\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }", "{\n    long count = 0; //keep count of how many times the substring was found\n\
    \    for(int i = 0; i < string.length(); i++) //go through each letter in the\
    \ string\n    {\n        //if current letter is equal to or smaller than the substring,\
    \ then we're done searching\n        if(string[i] < substring.size() || string[i]\
    \ == substring.size())\n        {\n            count++; //increment the counter\
    \ by 1\n            continue; //skip the rest of the loop\n        }\n       \
    \ string substring_copy = substring; //make a new substring from our substring\n\
    \        //remove the first letter from the substring\n        substring_copy.erase(0,\
    \ 1); \n        //if the current letter is equal to the substring, then increment\
    \ the counter by 1\n        if(string[i] == substring_copy[0])\n            count++;\
    \ \n    }\n    return count;\n}", "{\n   long count = 0;\n   for (int i = 0; i\
    \ < string.length(); i++)\n   {\n      if (string.substr(i, substring.length())\
    \ == substring)\n         count++;\n   }\n   return count;\n}", "{\n\tint i, j,\
    \ k, l, found=0;\n\tfor(i=0, j=string.length()-1; i<j; i++,j--)\n\t{\n\t\tfor(l=0;\
    \ l<substring.length(); l++)\n\t\t{\n\t\t\tif (string[i+l] == substring[l])\n\t\
    \t\t{\n\t\t\t\tfound++;\n\t\t\t\tif (found>1) return found;\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn 0;\n}\n/*\n Find the longest substring which is all zeros in the original\
    \ string.\n    >>> find_longest_zeros(\"00001110010000000\")\n    '0'\n    >>>\
    \ find_longest_zeros(\"1110010000000\")\n    '111001000000'\n    \n*/\nstring\
    \ find_longest_zeros(string string) \n{\n\tlong max_len=string.length();\n\tint\
    \ i, j, k;\n\tfor(j=max_len-1, i=string.length()-1; j>0; i--,j--)\n\t{\n\t\tif\
    \ (string[j]=='0') break;\n\t}\n\tk=j;\n\tfor(j=max_len-1, i=string.length()-1;\
    \ j>0; i--,j--)\n\t{\n\t\tif (string[j]!='0') break;\n\t}\n\t\n\tstring ret=string.substr(k,\
    \ j);\n\t\n\treturn ret;\n}\n/*\n Find the number of occurrences of any substring\
    \ in the original string.\n    >>> find_substring_occurrences(\"abcabc\", \"abc\"\
    )\n    2\n    >>> find_substring_occurrences(\"abcabc\", \"cba\")\n    1\n   \
    \ \n*/\nlong find_substring_occurrences(string string, string substring) \n{\n\
    \tint i, j, k, found=0;\n\tfor(i=0, j=string.length()-1; i<j; i++,j--)\n\t{\n\t\
    \tfor(l=0; l<substring.length(); l++)\n\t\t{\n\t\t\tif (string[i+l] == substring[l])\n\
    \t\t\t{\n\t\t\t\tfound++;\n\t\t\t\tif (found>1) return found;\n\t\t\t}\n\t\t}\n\
    \t}\n\treturn 0;\n}\n/*\n Find the number of occurrences of any substring in the\
    \ original string in reverse order.\n    >>> find_substring_occurrences_reverse(\"\
    abcabc\", \"abc\")\n    2\n    >>> find_substring_occurrences_reverse(\"abcabc\"\
    , \"cba\")\n    1\n    \n*/\nlong find_substring_occurrences_reverse(string string,\
    \ string substring) \n{\n\tint i, j, k, found=0;\n\tfor(i=string.length()-1, j=0;\
    \ i>j; i--,j++)\n\t{\n\t\tfor(l=0; l<substring.length(); l++)\n\t\t{\n\t\t\tif\
    \ (string[i+l] == substring[l])\n\t\t\t{\n\t\t\t\tfound", "{\n    long count =\
    \ 0;\n    long current = 0;\n    \n    for( int i = 0; i < string.length(); i++\
    \ )\n    {\n        if( string[i] == substring[0] )\n        {\n            if(\
    \ current == 0 )\n            {\n                current = i;\n            }\n\
    \        }\n        else if( string[i] == substring[1] && current > 0 )\n    \
    \    {\n            current = 0;\n        }\n        else if( string[i] == substring[2]\
    \ && current > 0 )\n        {\n            current = i;\n        }\n        else\n\
    \        {\n            current = 0;\n        }\n        \n        count++;\n\
    \    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count non-overlapping cases.\n    >>> how_many_times_nooverlap(\"\
    \", \"\")\n    0L\n    >>> how_many_times_nooverlap(\"a\", \"\") \n    0L\n  \
    \  >>> how_many_times_nooverlap(\"aaa\", \"a\") \n    1L\n    >>> how_many_times_nooverlap(\"\
    aaaa\", \"aa\") \n    0L\n    \n*/\nlong how_many_times_nooverlap(string string,\
    \ string substring) \n{\n    long count = 0;\n    long current = 0;\n    \n  \
    \  for( int i = 0; i < string.length(); i++ )\n    {\n        if( string[i] ==\
    \ substring[0] )\n        {\n            if( current == 0 )\n            {\n \
    \               current = i;\n            }\n        }\n        else if( string[i]\
    \ == substring[1] && current > 0 )\n        {\n            current = 0;\n    \
    \    }\n        else if( string[i] == substring[2] && current > 0 )\n        {\n\
    \            current = i;\n        }\n        else\n        {\n            current\
    \ = 0;\n        }\n        \n        count++;\n    }\n    \n    return count;\n\
    }\n/*\n Return a list of substring occurrences from the original string in a list.\n\
    \    >>> find_occurrences_list(\"\", \"a\")\n    []\n    >>> find_occurrences_list(\"\
    a\", \"a\")\n    [(0, 0)]\n    >>> find_occurrences_list(\"aaa\", \"a\")\n   \
    \ [(0, 0)]\n    >>> find_occurrences_list(\"aaa\", \"a\")\n    [(0, 0), (1, 1)]\n\
    \    >>> find_occurrences_list(\"aaaa\", \"aa\")\n    [(0, 0)]\n    >>> find_occurrences_list(\"\
    aaaa\", \"aa\")\n    [(0, 0), (1, 1)]\n    \n*/\nvector< pair<long, long> > find_occurrences_list(string\
    \ string, string substring) \n{\n    vector< pair<long, long> > occurrences;\n\
    \    \n    for( int i = 0; i < string.length(); i++ )\n    {\n        if( string[i]\
    \ == substring[0] )\n        {\n            occurrences.push_back( make_pair(i,\
    \ 0) );\n        }\n        else if( string[i] == substring", "{\n    long counter\
    \ = 0;\n    string temp = \"\";\n    for (int i = 0; i < string.length(); i++)\
    \ \n    {\n        for (int j = 0; j < substring.length(); j++)\n        {\n \
    \           if (string[i] == substring[j]) \n            {\n                if\
    \ (temp == \"\")\n                {\n                    temp = string[i];\n \
    \                   counter++;\n                }\n                else\n    \
    \            {\n                    temp = temp + string[i];\n               \
    \     counter++;\n                }\n                temp = \"\";\n          \
    \  }\n        }\n    }\n    return counter;\n}\n</code>\n<|/ a tags=java,algorithm,string,substring,dynamic-programming\
    \ |>\n<| c |>\nwhat about `how_many_times(\"aaaa\",\"aa\")` this should return\
    \ 2 but your function returns 3 !! .. i think there is some logical error !\n\
    <|/ c |>\n<| c |>\nAha yes, you are right. Corrected it\n<|/ c |>\n<| a |>\nThis\
    \ is an alternative solution using regex. Just my 2ct: \n<code>\npublic class\
    \ Test {", "{\n    long result = 0;\n    int len_s = string.length();\n    int\
    \ len_p = substring.length();\n    int len_sub = len_p;\n    string prefix = string.substr(0,len_s-len_p);\n\
    \    string suffix = string.substr(len_s-len_p);\n    int i = 0;\n    while ((i\
    \ < len_p) && (string.find(substring, i) != string::npos))\n    {\n        if\
    \ (string.find(substring, i) == 0)\n        {\n            result += 1;\n    \
    \        i += len_sub - 1;\n        }\n        else\n            i += 1;\n   \
    \ }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI used\
    \ a for loop for this\n<code>\npackage algorithms;", "{\n\tstring p1 = substring,\
    \ p2 = substring;\n\tfor (auto c: string)\n\t{\n\t\tif (c == p1) p2++;\n\t\telse\
    \ p1++;\n\t\tstring partial = string.substr(0, p2);\n\t\tif (string.find(partial)\
    \ == string::npos)\n\t\t\treturn 0L;\n\t\tp1 = p2;\n\t\tp2 = partial;\n\t}\n\t\
    return string.size() - p2.size();\n}", "{\n\tassert(!string.IsNullOrEmpty());\n\
    \tassert(!substring.IsNullOrEmpty());\n\t\n\tif (string.length() == 0) return\
    \ 0L;\n\tif (string.length() < substring.length()) return 0L;\n\tif (string.length()\
    \ == substring.length()) return 1L;\n\t\n\tint i = 0, j = 0;\n\t\n\twhile ((i\
    \ < string.length()) && (string.at(i) == substring.at(j))) {\n\t\ti++;\n\t\tj++;\n\
    \t}\n\t\n\treturn (j == substring.length() ? 0L : j - i + 1);\n}", "{\n    long\
    \ count = 0;\n    for (long i = 0; i < string.length(); i++) {\n        if (string.at(i)\
    \ == substring.at(0)) {\n            count++;\n            for (long j = i; j\
    \ < string.length(); j++) {\n                if (string.at(j) == substring.at(0))\
    \ {\n                    count++;\n                }\n                else {\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     else {\n            break;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nThis simple python code solves the problem in a single\
    \ line.\n<code>\nlen(re.findall('a|b', your_string))\n</code>\n<|/ a tags=python,string,substring\
    \ |>\n<| c |>\n`re.findall('a|b', your_string)` would be much more efficient than\
    \ `your_string.count('a') + your_string.count('b')`.\n<|/ c |>\n<| a |>\nTry this\
    \ in C++\n<code>", "{\n    int count = 0, end = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        end = string.length();\n        while (end > 0 && (string[end\
    \ - 1] == substring[end]))\n            end--;\n        if (string[i] == substring[end])\n\
    \            count++;\n    }\n    return count;\n}", "{\n\tlong i = 0;\n\tsize_t\
    \ pos = 0;\n\tsize_t length = string.length();\n\twhile(pos < length) \n\t{\n\t\
    \tpos = string.find(substring, pos);\n\t\tif (pos == string::npos)\n\t\t\treturn\
    \ i; // Not found (returns 0 on failure)\n\t\ti = i + 1;\n\t\tpos = pos + substring.length();\n\
    \t}\n\treturn i;\n}\n/*\n Convert a string to a floating point type\n \n    >>>\
    \ string_to_float(\"1.0\")\n    1.0\n    >>> string_to_float(\"1.0e1\")\n    1.0e1\n\
    \    >>> string_to_float(\"1.0e-1\")\n    1.0e-1\n    \n*/\nfloat string_to_float(string\
    \ string) \n{\n\tdouble retVal = 0;\n\tsize_t pos = 0;\n\tpos = string.find(\"\
    .\");\n\tif (pos == string::npos)\n\t\treturn 0.0f;\n\tstring endString = string.substr(pos\
    \ + 1);\n\tretVal = std.convert.strtonum(string);\n\tretVal = std.convert.strtonum(endString);\n\
    \treturn retVal;\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string.compare(i, substring.length(), substring) == 0) {\n\t\
    \t\tcount += 1;\n\t\t}\n\t\telse {\n\t\t\tif (string.compare(i, substring.length(),\
    \ substring) == 0) {\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t\telse if (string.compare(i,\
    \ substring.length(), substring) > 0) {\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\
    \t}\n\treturn count;\n}", "{\n\tlong  count = 0;\n\tfor (int i = 0; i < string.size();\
    \ i++) {\n\t\tfor (int j = 0; j < substring.size(); j++) {\n\t\t\tif (string[i]\
    \ == substring[j])\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find\
    \ how many times this substring can be found in this string. Count overlapping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string pattern) \n{\n\
    \tlong  count = 0;\n\tfor (int i = 0; i < string.size(); i++) {\n\t\tfor (int\
    \ j = 0; j < pattern.size(); j++) {\n\t\t\tif (string[i] == pattern[j] && pattern[j]\
    \ != substring[j])\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find\
    \ the number of occurrences of this substring in this string. Count overlapping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string pattern, bool\
    \ ignore_case) \n{\n\tlong  count = 0;\n\tfor (int i = 0; i < string.size(); i++)\
    \ {\n\t\tfor (int j = 0; j < pattern.size(); j++) {\n\t\t\tif (string[i] == pattern[j]\
    \ && pattern[j] != substring[j]) {\n\t\t\t\tif (ignore_case)\n\t\t\t\t\tcount++;\n\
    \t\t\t\telse\n\t\t\t\t\tcount += 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\
    /*\n Find the number of occurrences of this substring in this string.\n    >>>\
    \ how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n\
    \    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, string pattern, bool ignore_case, bool ignore_newline)\
    \ \n{\n\tlong  count = 0;\n\tfor (int i = 0; i < string.size(); i++) {\n\t\tfor\
    \ (int j = 0; j < pattern.size(); j++) {\n\t\t\tif (string[i] == pattern[j] &&\
    \ pattern[j] != substring[j]) {\n\t\t\t\tif (ignore_case)\n\t\t\t\t\tcount++;\n\
    \t\t\t\telse\n\t\t\t\t\tcount += 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\
    /*\n Find the number of occurrences of this substring in this string.\n    >>>\
    \ how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n\
    \    3L\n    >>> how_many_times(\"aaaa", "{\n\tstring[] char_array = string.to_char_array();\n\
    \tint[] char_array_length = std.array.length(char_array);\n\tstring[] substring_array\
    \ = substring.to_char_array();\n\tint[] substring_array_length = std.array.length(substring_array);\n\
    \t\n\tint substring_index_start = 0;\n\tint substring_index_end = substring_index_start\
    \ + std.array.length(substring_array);\n\tint char_index_start = 0;\n\tint char_index_end\
    \ = char_index_start + std.array.length(char_array);\n\tint index = 0;\n\t\n\t\
    long count = 0;\n\twhile (char_index_start < char_index_end) {\n\t\tif (substring_array_length\
    \ == 0) {\n\t\t\treturn count;\n\t\t}\n\t\tif (substring_array[substring_index_end]\
    \ == char_array[char_index_end]) {\n\t\t\tsubstring_index_end++;\n\t\t\tchar_index_end++;\n\
    \t\t\tcount++;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// Find first character that\
    \ does not match.\n\t\twhile (char_index_start < char_index_end && char_array[char_index_start]\
    \ == substring_array[substring_index_start]) {\n\t\t\tsubstring_index_start++;\n\
    \t\t\tchar_index_start++;\n\t\t}\n\t\t\n\t\tint current_index = substring_index_start;\n\
    \t\twhile (current_index < substring_index_end) {\n\t\t\tif (char_array[char_index_end]\
    \ == substring_array[current_index]) {\n\t\t\t\tchar_index_end++;\n\t\t\t\tcount++;\n\
    \t\t\t\tcurrent_index++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (current_index\
    \ == substring_index_end - 1) {\n\t\t\t\treturn count;\n\t\t\t}\n\t\t\tcurrent_index++;\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n    auto pos = string.find(substring);\n\
    \    if (pos != string::npos)\n        return string.length() - pos;\n    else\n\
    \        return 0L;\n}\n/*\n Split a substring into a list of substrings in O(n).\n\
    \    >>> split_in_O(\"\", \"a\", \"b\")\n    [\"\"]\n    >>> split_in_O(\"a\"\
    , \"a\", \"b\")\n    [\"a\"]\n    >>> split_in_O(\"a\", \"a\", \"c\")\n    Traceback\
    \ (most recent call last):\n        ...\n    ValueError: Substring must not be\
    \ an empty string.\n*/", "{\n    long count = 0;\n    \n    for(string::iterator\
    \ i = string.begin();i!= string.end();i++)\n    {\n        if(substring == *i)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string,substr,c dscore=1 |>\n<| c |>\nWhat about overlapping cases\
    \ (`aaa` vs `aa`)?\n<|/ c |>\n<| c |>\nThe OP wrote in the question that he was\
    \ using C. Also, the question states that it is written in Python.\n<|/ c |>\n\
    <| c |>\nI know, sorry for that. I just wanted to point out a common pitfall for\
    \ the OP who is probably not aware of it (maybe he was just looking for a Python\
    \ answer because he wanted to use Python and didn't know that C was also a supported\
    \ language).\n<|/ c |>\n<| a |>\nI think you're looking for a C solution and so\
    \ I went ahead and converted it to C++.\nAs far as I know, there's no way to count\
    \ characters (substrings) in a string without iterating through the string and\
    \ counting characters individually, so this algorithm is going to be O(n).\n<code>\n\
    long how_many_times(string string, string substring) \n{\n    long count = 0;\n\
    \    \n    for(string::iterator i = string.begin();i!= string.end();i++)\n   \
    \ {\n        if(substring == *i)\n        {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n</code>\nI didn't convert this to C, but it should\
    \ still be pretty easy to do.\n<|/ a tags=string,substr,c dscore=0 |>\n<| a |>\n\
    I believe that for efficiency, a better algorithm would be:\n<code>\nlong howMany(const\
    \ std::string &str, const std::string &sub) {\n  std::string s = str;\n  for (auto\
    \ iter = s.begin(); iter != s.end(); ) {\n    if (s.find(sub, iter) != iter) {\n\
    \      return 0;\n    }\n    iter += sub.size();\n  }\n  return s.size();\n}\n\
    </code>\n<|/ a dscore=0 tags=string,substr,c |>\n<| a |>\n<code>\n#include<iostream>\n\
    #include<string>\nusing namespace std;", "{\n    long count = 0;\n    for(int\
    \ i = 1; i < string.size(); ++i)\n    {\n        if(string.substr(0, i) == substring)\n\
    \        {\n            ++count;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"a\", \"a\")\n    1L\n    >>> how_many_times(\"\
    aaa\", \"aa\")\n    2L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    1L\n*/\n\
    long how_many_times_2(string string, string substring) \n{\n    string substring_2\
    \ = substring + substring;\n    string substring_3 = substring + substring + substring;\n\
    \    \n    long count = 0;\n    for(int i = 1; i < string.size(); ++i)\n    {\n\
    \        string sub_i = string.substr(0, i);\n        if(sub_i == substring_1\
    \ || sub_i == substring_2 || sub_i == substring_3)\n        {\n            ++count;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    a\", \"a\")\n    1L\n    >>> how_many_times(\"aaa\", \"a\")\n    2L\n    >>> how_many_times(\"\
    aaaa\", \"a\")\n    1L\n*/\nlong how_many_times_3(string string, string substring)\
    \ \n{\n    string substring_2 = substring + substring;\n    string substring_3\
    \ = substring + substring + substring;\n    \n    long count = 0;\n    for(int\
    \ i = 1; i < string.size(); ++i)\n    {\n        string sub_i = string.substr(0,\
    \ i);\n        if(sub_i == substring || sub_i == substring_2 || sub_i == substring_3)\n\
    \        {\n            ++count;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"a\", \"a\")\n    1L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    2L\n    >>> how_many_times(\"aaaa\", \"a\")\n    1L\n*/\nlong\
    \ how_many_times_4(string string, string substring) \n{\n    string substring_2\
    \ = substring + substring;\n    string substring_3 = substring + substring + substring;\n\
    \    \n    long count = 0;\n    for(int i = 1; i < string.size(); ++i)\n    {\n\
    \        string sub_i = string.substr(0, i);\n        if(sub_i == substring ||\
    \ sub_i == sub", "{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    \n\
    \    while(i < string.length() && j<substring.length())\n    {\n        switch(tolower(string[i]))\n\
    \        {\n            switch(tolower(substring[j]))\n            {\n       \
    \         case (tolower(substring[j])):\n                {\n                 \
    \   count++;\n                    break;\n                }\n                case\
    \ (tolower(substring[j+1])):\n                {\n                    count++;\n\
    \                    j++;\n                }\n                case (tolower(substring[j+2])):\n\
    \                {\n                    count++;\n                    j++;\n \
    \                   i++;\n                }\n                default:\n      \
    \          {\n                    i++;\n                    j++;\n           \
    \     }\n            }\n        }\n    }\n    \n    return count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlaping cases. Cases in middle of substring.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    1L\n    >>> how_many_times(\"\
    aaaa\", \"a\")\n    2L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    2L\n   \
    \ >>> how_many_times(\"aaaa\", \"aaa\")\n    2L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, int startIndex, int endIndex)\n{\n    int i = 0;\n\
    \    int j = 0;\n    int count = 0;\n    \n    while(i < string.length() && j<substring.length())\n\
    \    {\n        switch(tolower(string[i]))\n        {\n            switch(tolower(substring[j]))\n\
    \            {\n                case (tolower(substring[j])):\n              \
    \  {\n                    count++;\n                    break;\n             \
    \   }\n                case (tolower(substring[j+1])):\n                {\n  \
    \                  count++;\n                    j++;\n                }\n   \
    \             case (tolower(substring[j+2])):\n                {\n           \
    \         count++;\n                    j++;\n                    i++;\n     \
    \           }\n                default:\n                {\n                 \
    \   i++;\n                    j++;\n                }\n            }\n       \
    \ }\n        if(startIndex < i && endIndex > j)\n            return count;\n \
    \       i++;\n        j++;\n    }\n    \n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases. Cases in middle of substring.\n    >>> how_many_times(\"\", \"a\", 1,\
    \ 1)\n    0L\n    >>> how_many_times(\"aaa\", \"a\", 1, 1)\n    0L\n    >>> how_many_times(\"\
    aaaa\", \"a\", 1, 1)\n    0L\n    >>> how_many_times(\"aaaa\", \"a\", 1, 2)\n",
  "{\n    \n    long count = 0;\n    for(int i = 0; i < string.length(); i++)\n  \
    \  {\n        for(int j = 0; j < substring.length(); j++)\n        {\n       \
    \     if(string.sub(i,1) == substring.subj)\n            {\n                count++;\n\
    \                break;\n            }\n        }\n    }\n    \n    return count;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,c# |>\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing\
    \ System.Text.RegularExpressions;", "{\n    int pos = 0;\n    for(int i = 0; i\
    \ < string.length(); i++) {\n        if(string.at(i) == substring.at(i)) {\n \
    \           pos++;\n        } else {\n            if(pos > 0) return pos;\n  \
    \          pos = 0;\n        }\n    }\n    return pos;\n}\n/*\n Return True if\
    \ the substring has exactly one occurrence in the original string. \n    \n  \
    \  >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    1L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    1L\n    \n*/", "{\n\
    \    int i = 0, j = 0;\n    int count = 0;\n    string result = \"\";", "{\n\t\
    long cnt = 0;\n\tsize_t pos = 0;\n\tsize_t last = 0;\n\twhile(pos < string.size())\
    \ {\n\t\tif (string.find_first_of(substring, pos) == string::npos)\n\t\t\tbreak;\n\
    \t\tcnt += string.find_first_not_of(substring, pos) - last;\n\t\tlast = string.find_first_of(substring,\
    \ pos);\n\t\tpos++;\n\t}\n\treturn cnt;\n}", "{\n   long count = 0L;\n   char\
    \ c = string.at(0);\n   for (long i = 0; i < string.size(); i++) \n   {\n    \
    \  if (c == substring.at(i)) \n      {\n         count++;\n         while (i <\
    \ string.size() && c == substring.at(i)) i++;\n         \n         if (i >= string.size())\
    \ break;\n         \n         c = string.at(i);\n         \n      }\n   }\n  \
    \ return count;\n}", "{\n    long count = 0L;\n    for (auto it = string.begin();\
    \ it != string.end(); ++it) {\n        if (*it == substring[0]) {\n          \
    \  string substring_without = substring;\n            substring_without.erase(substring_without.begin(),\
    \ substring_without.end());\n            if (string.find(substring_without, it\
    \ + 1) != string::npos) {\n                count = count + 1L;\n            }\n\
    \        }\n    }\n    return count;\n}", "{\n    long count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        for (int j = 0; j < substring.length();\
    \ j++) {\n            if (string[i] == substring[j]) count++;\n        }\n   \
    \ }\n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count non-overlaping cases.\n    >>> how_many_times_ns(\"\
    \", \"a\")\n    0L\n    >>> how_many_times_ns(\"aaa\", \"a\")\n    3L\n    >>>\
    \ how_many_times_ns(\"aaaa\", \"aa\")\n    0L\n    \n*/\nlong how_many_times_ns(string\
    \ string, string substring) \n{\n    long count = 0;\n    for (int i = 0; i <\
    \ string.length(); i++) {\n        for (int j = 0; j < substring.length(); j++)\
    \ {\n            if (string[i] == substring[j] && i != j) count++;\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count non-overlaping cases.\n    >>> how_many_times_n_ss(\"\
    \", \"a\")\n    0L\n    >>> how_many_times_n_ss(\"aaa\", \"a\")\n    3L\n    >>>\
    \ how_many_times_n_ss(\"aaaa\", \"aa\")\n    0L\n    \n*/\nlong how_many_times_n_ss(string\
    \ string, string substring) \n{\n    long count = 0;\n    for (int i = 0; i <\
    \ string.length(); i++) {\n        for (int j = 0; j < substring.length(); j++)\
    \ {\n            if (string[i] == substring[j] && i != j) count++;\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times_nt(\"\
    \", \"a\")\n    0L\n    >>> how_many_times_nt(\"aaa\", \"a\")\n    3L\n    >>>\
    \ how_many_times_nt(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times_nt(string\
    \ string, string substring) \n{\n    long count = 0;\n    for (int i = 0; i <\
    \ string.length(); i++) {\n        for (int j = 0; j < substring.length(); j++)\
    \ {\n            if (string[i] == substring[j] && i != j) count++;\n        }\n\
    \    }\n    return count;\n}", "{\n    int i = 0;\n    int j = 0;\n    int count\
    \ = 0;\n    while (i < string.Length - substring.length) \n    {\n        if (string.Substring(i,\
    \ substring.length).Equals(substring))\n        {\n            count++;\n    \
    \    }\n        i += substring.length + 1;\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ non-overlapping cases.\n    >>> how_many_times_no_overlap(\"\", \"a\")\n   \
    \ 0L\n    >>> how_many_times_no_overlap(\"aaa\", \"a\")\n    2L\n    >>> how_many_times_no_overlap(\"\
    aaaa\", \"aa\")\n    2L\n*/\nlong how_many_times_no_overlap(string string, string\
    \ substring) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while\
    \ (i < string.Length - substring.length) \n    {\n        if (string.Substring(i,\
    \ substring.length).Equals(substring))\n        {\n            count++;\n    \
    \    }\n        i += substring.length + 1;\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases. \n    >>> how_many_times_no_overlap(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times_no_overlap(\"aaa\", \"a\")\n    2L\n    >>> how_many_times_no_overlap(\"\
    aaaa\", \"aa\")\n    2L\n*/\nlong how_many_times_no_overlap_v2(string string,\
    \ string substring) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n\
    \    while (i < string.Length - substring.length) \n    {\n        if (string.Substring(i,\
    \ substring.length).Equals(substring))\n        {\n            count++;\n    \
    \    }\n        i += substring.length + 1;\n    }\n    return count;\n}\n/*\n\
    \ Return the string with the longest common prefix with the given suffix.\n >>>\
    \ longest_common_prefix(\"hello\", \"lo\")\n 'he'\n >>> longest_common_prefix(\"\
    hello\", \"he\")\n 'h'\n*/\nstring longest_common_prefix(string s1, string s2)\n\
    {\n    int i = 0;\n    int j = 0;\n    string prefix = string.Empty;\n    while\
    \ (i < s1.Length - s2.Length + 1 && j < s2.Length) \n    {\n        if (s1.Substring(i,\
    \ s2.Length).Equals(s2))\n        {\n            prefix = s2.Substring(0, j);\n\
    \            break;\n        }\n        if (s1.Substring(i, s2.Length).Equals(s2))\n\
    \        {\n            prefix = s2.Substring(0, j);\n            break;\n   \
    \     }\n        i += s1.Length - s2.Length + 1;\n        j = s2.Length;\n   \
    \ }\n", "{\n\tlong count = 0;\n\t\n\tint i = 0;\n\t\n\twhile (i < string.length())\
    \ {\n\t\tint end = i + substring.length();\n\t\t\n\t\tif (end > string.length())\
    \ end = string.length();\n\t\t\n\t\tif (string.compare(i, end, substring, 0, substring.length())\
    \ == 0) {\n\t\t\tcount++;\n\t\t\ti = end;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\t\t\
    }\n\t}\n\treturn count;\n}", "{\n    if(string.size() < substring.size())\n  \
    \      return 0;\n    \n    long count = 0;\n    \n    for(int i = 0; i < string.size();\
    \ ++i)\n    {\n        if(string.at(i) == substring.at(i))\n            count++;\n\
    \    }\n    \n    return count;\n}\n    \n//#include <iostream>", "{\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < (int)string.length(); i++) {\n\t\tif (string[i]\
    \ == substring[0]) {\n\t\t\tfor (int j = 1; j < substring.length(); j++) {\n\t\
    \t\t\tif (string[i + j] != substring[j]) {\n\t\t\t\t\tcount = count + 1;\n\t\t\
    \t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = substring.length() - 1; j\
    \ >= 0; j--) {\n\t\t\t\tif (string[i + j] != substring[j]) {\n\t\t\t\t\tcount\
    \ = count + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find a substring in a string and replace it with a new one. \n    >>>\
    \ replace(\"Hello!\", \"!\", \"X\")\n    'HelloX'\n*/\nstring replace(string string,\
    \ string substring, string replacement) \n{\n\tstring result = string;\n\tfor\
    \ (int i = 0; i < (int)string.length(); i++) {\n\t\tif (string[i] == substring[0])\
    \ {\n\t\t\tfor (int j = 1; j < substring.length(); j++) {\n\t\t\t\tif (string[i\
    \ + j] != substring[j]) {\n\t\t\t\t\tresult = result + replacement;\n\t\t\t\t\t\
    break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = substring.length() - 1; j >= 0;\
    \ j--) {\n\t\t\t\tif (string[i + j] != substring[j]) {\n\t\t\t\t\tresult = result\
    \ + replacement;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\n Return an int array containing two elements. \n    >>> \"1,2,3\".split(\"\
    ,\")\n    [1, 2, 3]\n*/\nstring split(string string, string delimiter) {\n\tstring\
    \ array[] = string.split(delimiter);\n\tstring result = \"\";\n\tfor (int i =\
    \ 0; i < array.length; i++) {\n\t\tif (i == array.length - 1) {\n\t\t\tresult\
    \ += array[i];\n\t\t} else {\n\t\t\tresult += array[i] + \",\";\n\t\t}\n\t}\n\t\
    return result;\n}\n/*\n Create a string of a given size filled with spaces\n \
    \   >>> make_str(10)\n    '    '\n*/\nstring make_str(long n) {\n\tstring result\
    \ = \"\";\n\tfor (int i = 0; i < (int)n; i++) {\n\t\tresult += \" \";\n\t}\n\t\
    return result;\n}", "{\n  if (string.Length == 0) \n  {\n    return 0;\n  }\n\
    \  \n  return \n  string.length() - string.find(substring, 0) \n  - string.length()\
    \ + string::find(string, substring, string::npos);\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nYou can use Regex\n<code>", "{\n    long count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++)\n    {\n        for(int j = i; j < string.length();\
    \ j++)\n        {\n            if(string[i] == substring[j])\n            {\n\
    \                count += 1;\n                break;\n            }\n        }\n\
    \    }\n    return count;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks a lot, this was\
    \ really helpful. I did some testing and it seems that your code is faster than\
    \ the other answers by about 3%.\n<|/ c |>\n<| a tags=string,python,search,algorithm,performance\
    \ |>\nUsing list comprehension\n<code>\ndef how_many_times(s, x):\n    return\
    \ sum(1 for i,j in enumerate(s) if (j==x) and (i<len(s) and s[i:i+len(x)]==x))\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=string,python,search,algorithm,performance\
    \ |>\nHere's a simple implementation, which can work with repeated substrings,\
    \ not just single characters:\n<code>\ndef how_many_times(s, sub):\n    ans =\
    \ 0\n    for start in range(len(s)):\n        for end in range(start+1, len(s)):\n\
    \            if s[start:end] == sub:\n                ans += 1\n    return ans\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\ndef how_many_times(string,\
    \ substring):\n    count = 0\n    i = 0\n    while True:\n        if string[i:i+len(substring)]\
    \ == substring:\n            count += 1\n            i += len(substring)\n   \
    \     else:\n            i = 0\n        if i == len(string):\n            return\
    \ count\n</code>\n<|/ a tags=string,python,search,algorithm,performance |>\n<|\
    \ c |>\nThis doesn't work for repeated substrings. For example, how_many_times(\"\
    aba\", \"a\") returns 2, but how_many_times(\"aba\", \"aa\") returns 3.\n<|/ c\
    \ |>\n<| c |>\nThanks, this works. However it seems slow for larger substrings.\n\
    <|/ c |>\n<| a tags=string,python,search,algorithm,performance dscore=1 |>\nTry\
    \ this :\n<code>\ndef how_many_times(string, substring):\n    count = 0\n    i\
    \ = 0\n    while i < len(string):\n        if string[i:i+len(substring)] == substring:\n\
    \            count += 1\n            i += len(substring)\n        else:\n    \
    \        i = i\n    return count\n</code>\n<|/ a |>\n<| c |>\nThanks. I edited\
    \ your answer to fix the indentation. :)\n<|/ c |>\n<| c |>\nThanks. In", "{\n\
    \    // find the number of matches\n    long n = 0;\n    int i = 0, j = 0;\n \
    \   while (j < string.size()) {\n        if ((i < string.size()) && (string[i]\
    \ == substring[j])) {\n            i++;\n            j++;\n            n++;\n\
    \        }\n        else if ((i >= string.size()) || (string[i] == substring[j]))\
    \ {\n            break;\n        }\n        else {\n            i = 0;\n     \
    \       j = 0;\n        }\n    }\n    \n    return n;\n}\n</code>\nThis code is\
    \ easy to understand, and doesn't have to be a function. It can just be at the\
    \ top level of a program file.\n<|/ a |>\n<| a tags=string,java |>\nThis can be\
    \ done by simply converting both strings to character array and iterating through\
    \ each characters. Once we see that character is same for both strings then increment\
    \ the count else continue with the iteration.\n<|/ a dscore=0 |>\n<| c |>\nYes.\
    \ But converting them to char[] is not a solution, only a workaround. I suggest\
    \ that the OP researchs methods to do this with Strings.\n<|/ c |>\n<| c |>\n\
    It is not a workaround, it is **the solution**.  String has a method `toCharArray`.\n\
    <|/ c |>\n<| c |>\n: If you want help with your code, post it.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nThis can be done by converting both strings to character array\
    \ and iterating through each characters. Once we see that character is same for\
    \ both strings then increment the count else continue with the iteration\n<|/\
    \ a tags=string,java |>\n<| c |>\nWelcome to Stack Overflow! While this code snippet\
    \ may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a tags=string,java |>\n<code>\nimport java.util.*;\n\
    class StringLength {\n    public static void main(String[] args) {\n        Scanner\
    \ scanner = new Scanner(System.in);\n        int firstValue = scanner.nextInt();\n\
    \        int secondValue = scanner.nextInt();\n        System.out.println(\"first\
    \ String is \"+firstValue+\" chars long\");\n        System.out.println(\"second\
    \ String is \"+secondValue+\" chars long\");\n        int firstStringLength =\
    \ firstValue+1;\n        int secondStringLength = secondValue+1;\n        int\
    \ maxString", "{\n    int pos = 0;\n    for (auto it = string.begin(); (it !=\
    \ string.end()) && (pos < substring.size()); ++it, ++pos) {\n        if (*it ==\
    \ substring[pos])\n            ++count;\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string,c++ dscore=1 |>\n<| c |>\nPlease don't post only code as an\
    \ answer, but also provide an explanation what your code does and how it solves\
    \ the problem of the question. Answers with an explanation are usually more helpful\
    \ and of better quality, and are more likely to attract upvotes.\n<|/ c |>\n<|\
    \ c |>\nI don't think this really answers the question. While it might get OP\
    \ started, it doesn't really answer the question in any way. I think your answer\
    \ should have been a comment...\n<|/ c |>\n<| c |>\nThe code is not intended to\
    \ be complete.\n<|/ c |>\n<| c |>\nI edited the question for clarity and added\
    \ an explanation that hopefully helps.\n<|/ c |>\n<| c |>\nThe code *does* compile\
    \ and work though.\n<|/ c |>\n<| a dscore=1 tags=string,c++ |>\nA simple and straightforward\
    \ solution would be to start off with the longest possible sub string, scan the\
    \ whole string and see if every character is equal to the sub string.\nThe complexity\
    \ would be O(n) where n is the length of the sub string, while counting the number\
    \ of overlapping occurrences would be O(n).\nThe idea of doing it this way is\
    \ by making the code more general so that it can be used regardless of the sub\
    \ string length. For example, if you only had the sub string to be \"a\" and wanted\
    \ to find out how many times the string \"abacaba\" occurred (counting overlapping\
    \ occurrences), you could just use the code above with a slight modification so\
    \ that it checks for an occurrence of the sub string in the rest of the string\
    \ and doesn't do so for the first character of the sub string.\n<|/ a |>\n<| c\
    \ |>\nThis is an O(n) algorithm, not O(n log n).\n<|/ c |>\n<| c |>\nHow is this\
    \ an O(n) algorithm? Am I missing something?\n<|/ c |>\n<| c |>\n`O(n log n)`\
    \ means \"worst case\". So the best case is `O(n)` (no time complexity given).\
    \ But in the worst case you have to look at every character in the string for\
    \ every character, so it's `O(n)` also.\n<|/ c |>", "{\n    if (string == substring)\n\
    \        return 1L;\n    return string.length() - string.indexOf(substring) +\
    \ how_many_times(string.substr(string.indexOf(substring) + substring.length()),\
    \ substring);\n}", "{\n    long n = string.length();\n    long m = substring.length();\n\
    \    long count = 0;\n    for (long i = 0; i < n; i++) {\n        if (string.charAt(i)\
    \ == substring.charAt(0)) {\n            for (long j = i; j < m; j++) {\n    \
    \            if (string.charAt(j) == substring.charAt(1)) {\n                \
    \    count += 2;\n                    if (j == m-1) {\n                      \
    \  break;\n                    }\n                }\n            }\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times each given substring can\
    \ be found in a string of given length.\n    >>> how_many_times(\"abcde\", \"\
    abc\")\n    (1, 1, 1)\n    >>> how_many_times(\"abcde\", \"ac\")\n    (0, 0)\n\
    \    >>> how_many_times(\"abcde\", \"ae\")\n    (0, 1)\n    \n*/\ntuple<int,int,int>\
    \ how_many_times(string string, string substring, int length) \n{\n    long n\
    \ = string.length();\n    long m = substring.length();\n    int counts[2] = {\
    \ 0, 0 };\n    for (long i = 0; i < n; i++) {\n        if (string.charAt(i) ==\
    \ substring.charAt(0)) {\n            for (long j = i; j < m; j++) {\n       \
    \         if (string.charAt(j) == substring.charAt(1)) {\n                   \
    \ counts[0]++;\n                    if (j == m-1) {\n                        break;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   \n    for (long i = m-2; i >= 0; i--) {\n        counts[1] += counts[0];\n\
    \        if (string.length() < i-1 || string.charAt(i) != string.charAt(i+1))\
    \ {\n            break;\n        }\n    }\n    \n    return tuple<int, int, int>(counts[0],\
    \ counts[1], counts[0] + counts[1]);\n}\n/*\n Find the minimum number of times\
    \ each substring can be found in a string of given length.\n    >>> how_many_times_min(\"\
    abcde\", \"abc\")\n    (1, 1, 1)\n    >>> how_many_times_min(\"abcde\", \"ac\"\
    )\n    (1, 0)\n    >>> how_many_times_min(\"abcde\", \"ae\")\n    (0, 0)\n   \
    \ \n*/\ntuple<int,int,int> how_many_times_min(string string, string substring,\
    \ int length) \n{\n    long n = string.length();\n    long m = substring.length();\n\
    \    int counts[2] = { 0, 0 };\n    for (long i = 0; i < n; i++) {\n        if\
    \ (string.charAt(i) == substring.charAt(0)) {\n            for (long j = i; j\
    \ < m; j++) {\n                if (string.charAt(j) == substring.charAt(1)) {\n\
    \                    counts[0]++;\n                    if (j == m-1) {\n     \
    \                   break;\n                    }\n                }\n       \
    \     }\n        }\n    }\n    \n    for (long ", "{\n    long count=0;\n    string\
    \ temp=string;\n    bool flag=false;\n    \n    while(string!=\"\" && string!=substring){\n\
    \        if(string.find(substring,0,string.length())!=string.length()){\n    \
    \        flag=true;\n            count=count+1;\n        }\n        else{\n  \
    \          flag=false;\n        }\n        string=string.substr(string.length()-1);\n\
    \    }\n    \n    if(flag){\n        return count;\n    }\n    else{\n       \
    \ return -1;\n    }\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++)\n\t{\n\t\tif (string[i] == substring[0] && string[i + 1] == substring[1])\n\
    \t\t{\n\t\t\tif (i + substring.length() == string.length())\n\t\t\t{\n\t\t\t\t\
    count++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcount += how_many_times(string.substring(i\
    \ + 1), substring);\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}", "{\n    long count\
    \ = 0;\n    \n    for(auto c: string){\n        if(string.find(substring) != string::npos){\n\
    \            count += 1;\n            \n            string sub_sub = string.substr(string.find(substring),\
    \ substring.length());\n            \n            string sub_sub_lastpart = string.substr(string.find(substring)\
    \ + substring.length());\n            \n            string sub_sub_midpart = string.substr(string.find(substring),\
    \ substring.length() - substring.length());\n            \n            string\
    \ sub_sub_midpart_lastpart = string.substr(string.find(substring) + substring.length(),\
    \ substring.length());\n            \n            count += how_many_times(sub_sub,\
    \ substring);\n            count += how_many_times(sub_sub_midpart, substring);\n\
    \            count += how_many_times(sub_sub_midpart_lastpart, substring);\n \
    \       }\n        \n    }\n    return count;\n}", "{\n    if(string.size() <=\
    \ substring.length())\n        return 0;\n    \n    long count = 0;\n    string\
    \ temp = string;\n    for(int i = 0; i < string.length(); i++)\n    {\n      \
    \  for(int j = 0; j < substring.length(); j++)\n        {\n            if(temp.at(j)\
    \ == substring.at(j))\n                count++;\n        }\n        temp = temp\
    \ + string.at(i);\n    }\n    return count;\n}\n</code>\n<|/ a dscore=4 |>\n<|\
    \ a |>\nI'm a bit late to the party, but I had to do this myself recently so I\
    \ wrote this in Haskell. It uses the standard Data.Text package which has a number\
    \ of functions for string manipulation. I believe that the code is pretty self\
    \ explanatory.\n<code>\nimport qualified Data.Text as T", "{\n    size_t length\
    \ = string.length();\n    size_t stringLength = string.length();\n    size_t substringLength\
    \ = substring.length();\n    size_t count = 0;", "{\n\tlong count = 0;\n\tstring\
    \ temp_str = string;\n\tlong max_count = 0; \n\twhile(temp_str.size() > substring.size())\
    \ {\n\t\ttemp_str = temp_str.erase(substring.size() - 1);\n\t\tcount ++;\n\t}\n\
    \tfor(int i = 0; i < temp_str.size(); i++) {\n\t\tif(temp_str[i] == substring[0])\
    \ {\n\t\t\tstring temp_sub = temp_str.substr(0, i);\n\t\t\tstring temp_sub2 =\
    \ temp_str.substr(i);\n\t\t\tif(temp_sub.size() == substring.size() && how_many_times(temp_sub,\
    \ substring) > 0) {\n\t\t\t\tcount += how_many_times(temp_sub, substring);\n\t\
    \t\t\tif(how_many_times(temp_sub2, substring) == 0) {\n\t\t\t\t\tcount += how_many_times(temp_sub2,\
    \ substring);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcount += how_many_times(temp_sub,\
    \ substring);\n\t\t\t}\n\t\t}\n\t}\n\t/*if(count > max_count) {\n\t\tmax_count\
    \ = count;\n\t}*/\n\treturn count;\n}\n/*\n Find the first instance of a substring\
    \ in a string. Return -1 in case that the substring is not found.\n    >>> find_first_instance(\"\
    aaaaaa\", \"a\")\n    2\n    >>> find_first_instance(\"aaaaaa\", \"bb\")\n   \
    \ -1\n*/\nlong find_first_instance(string string, string substring) \n{\n\tstring\
    \ temp_str = string;\n\tlong count = 0;\n\twhile(temp_str.size() > substring.size())\
    \ {\n\t\ttemp_str = temp_str.erase(substring.size() - 1);\n\t\tcount ++;\n\t}\n\
    \tfor(int i = 0; i < temp_str.size(); i++) {\n\t\tif(temp_str[i] == substring[0])\
    \ {\n\t\t\tstring temp_sub = temp_str.substr(0, i);\n\t\t\tif(temp_sub.size()\
    \ == substring.size() && find_first_instance(temp_sub, substring) > 0) {\n\t\t\
    \t\treturn count;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n/*\n Find the last instance\
    \ of a substring in a string. Return -1 in case that the substring is not found.\n\
    \    >>> find_last_instance(\"aaaaaa\", \"a\")\n    3\n    >>> find_last_instance(\"\
    aaaaaa\", \"bb\")\n    -1\n*/\nlong find_last_instance(string string, string substring)\
    \ \n{\n\tstring temp_str = string;\n\tlong count = 0;\n\twhile(temp_str.size()\
    \ > substring.size()) {\n\t\ttemp_str = temp_str.erase(substring.size() - 1);\n\
    \t\tcount ++;\n\t}\n\tfor(int i = 0; i < temp_str.size(); i++) {\n\t\tif(temp_str[i]\
    \ == substring[0]) {\n\t\t\tstring temp_sub = temp_str.substr(0, i);\n\t\t\tif(temp_sub.size()\
    \ == substring.size() && find_last_instance(temp_sub, substring) > 0) {\n", "{\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tfor\
    \ (int j = 0; j < substring.length(); j++) {\n\t\t\tif (string.charAt(i) == substring.charAt(j))\
    \ {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn count;\n\
    }", "{\n    if (string == substring)\n        return 1;\n    if (string.find(substring)\
    \ == string.length()-1)\n        return 1;\n    long count = 1;\n    int substring_index\
    \ = 0;\n    for (int i = 0; i < string.length()-1; ++i) {\n        if (string.compare(i,\
    \ substring_index, substring.length(), 0, substring.length()) == 0)\n        \
    \    ++count;\n        substring_index += 1;\n    }\n    return count;\n}", "{\n\
    \    size_t start = 0;\n    size_t index = string.find(substring, start);\n  \
    \  long count = string.size() - index;\n    if (index != string::npos) \n    \
    \    count += how_many_times(string.substr(start, index + 1), substring);\n  \
    \  return count;\n}\n</code>\n<|/ a tags=c++,algorithm,string |>\n<| a tags=c++,algorithm,string\
    \ dscore=1 |>\nI came up with this solution:\n<code>\n long HowManyTimes(string\
    \ searchFor, string myString)\n    {\n        string str1 = \"\";\n        string\
    \ str2 = \"\";", "{\n    long count = 0;\n    int i, j;\n    \n    for(i = 0;\
    \ i < string.Length; i++)\n    {\n        if(string[i] == substring[0]) {\n  \
    \          for(j = i; j < string.Length; j++) {\n                if(string[j]\
    \ == substring[1]) {\n                    count++;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    return count;\n}", "{\n\
    \    if(string.length == substring.length) return 0;\n    if(string.length ==\
    \ 0 || substring.length == 0) return 0;\n    \n    long n = string.length();\n\
    \    long m = substring.length();\n    long count = 0;\n    \n    for(long i =\
    \ 0; i < n; ++i) {\n        for(long j = 0; j < m; ++j) {\n            if(string[i]\
    \ == substring[j])\n                count++;\n        }\n    }\n    return count;\n\
    }\n</code>\n<|/ a tags=string-matching,python,string,pattern-matching |>\n<| c\
    \ |>\nThis was the fastest and easiest to understand solution for me. Great job!\n\
    <|/ c |>\n<| a dscore=5 |>\nPython has a number of string methods for searching\
    \ text.", "{\n    // TODO Optimize by counting the overlaps instead of doing a\
    \ linear scan\n    long total = 0;\n    \n    // Iterate over the string until\
    \ we find the substring\n    for(string::iterator ii = string.begin(); ii != string.end();\
    \ ++ii)\n    {\n        for(string::iterator si = substring.begin(); si != substring.end();\
    \ ++si) \n        {\n            string a = *ii;\n            string b = *si;\n\
    \            if(a.find(b) != string::npos) \n            {\n                ++total;\n\
    \            }\n        }\n    }\n    \n    return total;\n}", "{\n  int len =\
    \ substring.length();\n  int count = 0;\n  if (string == substring) return count;\
    \ // 0 matches\n  if (string.length() == 0) return count; // empty string\n  for\
    \ (int i = 0; i < string.length(); i++) {\n    if (string[i] == substring[0])\n\
    \      if (substring.length() == 1) return count; // single match\n      else\
    \ count += how_many_times(string.substring(i + 1), substring);\n  }\n  return\
    \ count;\n}\n</code>\nNote that this implementation is O(n). You can find other\
    \ efficient algorithms for finding substring occurrences here.\n<|/ a |>\n<| c\
    \ |>\nThis only works if the substring is at the beginning of the string. I'm\
    \ pretty sure this is what OP is looking for though.\n<|/ c |>\n<| c |>\nYou're\
    \ right, good catch. The OP should clarify what the expected behaviour is.\n<|/\
    \ c |>\n<| a tags=algorithm,string,c++ dscore=2 |>\nO(N) solution, also with C++\n\
    <code>", "{\n    long count = 0;\n    if (string.Length <= substring.Length) return\
    \ 0;\n    for (int i = 0; i < string.Length; i++)\n    {\n        if (string[i]\
    \ != substring[i]) break;\n        count++;\n    }\n    return count;\n}", "{\n\
    \    long count = 0;\n    \n    bool start = true;\n    for(int i = 0; i < string.length();\
    \ i++)\n    {\n        if(string.at(i) == substring.at(0))\n        {\n      \
    \      if(start)\n                start = false;\n            else\n         \
    \       count++;\n        }\n        else if(string.at(i) == substring.at(1))\n\
    \        {\n            if(start)\n                count++;\n        }\n     \
    \   else\n            count = 0;\n    }\n    return count;\n}\n/*\n Write a function\
    \ to find all substrings that occur in a given string. \n Examples:\n    >>> find_substrings(\"\
    a\", \"bcdaefiklnmoprstuwxy\")\n    [\"bcda\", \"ef\", \"kl\", \"mo\", \"pr\"\
    , \"stu\", \"wxy\"]\n    >>> find_substrings(\"asdfjkl;\", \";\")\n    []\n  \
    \  >>> find_substrings(\"asdfjkl;\", \"asdfjkl;\")\n    [\"asdfjkl;\"]\n*/\nvector<string>\
    \ find_substrings(string string, string substring)\n{\n    vector<string> substrings;\n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        for(int j = 0; j\
    \ < substring.length(); j++)\n        {\n            if(string.at(i) == substring.at(j))\n\
    \            {\n                substrings.push_back(string.substr(i, substring.length()));\n\
    \            }\n        }\n    }\n    return substrings;\n}\n/*\n Write a function\
    \ to remove all occurrences of substrings that occur in a given string. \n Examples:\n\
    \    >>> remove_substrings(\"a\", \"bcdaefiklnmoprstuwxy\")\n    \"bcdacdefiklnmoprstuwxy\"\
    \n    >>> remove_substrings(\"asdfjkl;\", \";\")\n    \"asdfjkl;\"\n*/\nstring\
    \ remove_substrings(string string, string substring)\n{\n    string out = string;\n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        for(int j = 0; j\
    \ < substring.length(); j++)\n        {\n            if(string.at(i) == substring.at(j))\n\
    \            {\n                out = out.substr(0, i) + out.substr(i + substring.length(),\
    \ string.length() - i - substring.length());\n            }\n        }\n    }\n\
    \    return out;\n}\n/*\n Write a function that accepts a string and two functions\
    \ as parameters. \n The first function will be used to generate all possible substrings\
    \ of a given string. \n The second function will be used to compare a given substring\
    \ to a given string. \n If the given substring matches a substring in the given\
    \ string, then the given function will be called with the substring. \n Otherwise\
    \ the given function will be called without parameters. \n Examples:\n    >>>\
    \ generate_substrings(\"asdfjkl;\", \";\")\n    [\"asdfjkl;\"]\n", "{\n    long\
    \ cnt = 0;\n    int minlen = substring.size();\n    if (string.empty()) {\n  \
    \      return 0;\n    }\n    if (string.size() <= minlen) {\n        return 0;\n\
    \    }\n    int pos = string[minlen];\n    int start = 0;\n    while (pos != 0)\
    \ {\n        if (string.compare(minlen, minlen + pos) == 0) {\n            cnt++;\n\
    \            pos += 1;\n        } else {\n            if (string.compare(minlen,\
    \ minlen + pos) > 0) {\n                cnt++;\n                pos += 1;\n  \
    \          } else if (string.compare(minlen, minlen + pos) < 0) {\n          \
    \      pos += 1;\n            } else {\n                break;\n            }\n\
    \        }\n    }\n    return cnt;\n}", "{\n\tlong count = 0;\n\tint len1 = string.length();\n\
    \tint len2 = substring.length();\n\tfor(int i = 0; i < len1; i++)\n\t{\n\t\tfor(int\
    \ j = 0; j < len2; j++)\n\t\t{\n\t\t\tif(string[i] == substring[j])\n\t\t\t{\n\
    \t\t\t\tcount++;\n\t\t\t\tif(i == len1 - 1 || j == len2 - 1 || string[i+1] !=\
    \ substring[j+1]) count++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find the index of a substring in a string.\n    >>> indexof(\"apple\"\
    , \"apple\")\n    0L\n    >>> indexof(\"apple\", \"aple\")\n    0L\n    >>> indexof(\"\
    apple\", \"aplle\")\n    1L\n*/\nlong indexof(string string, string substring)\
    \ \n{\n\tlong index = string.length();\n\tint len1 = string.length();\n\tint len2\
    \ = substring.length();\n\tfor(int i = 0; i < len1; i++)\n\t{\n\t\tif(string[i]\
    \ == substring[0]) index--;\n\t\tfor(int j = 0; j < len2; j++)\n\t\t{\n\t\t\t\
    if(string[i+j] != substring[j]) break;\n\t\t\tif(j == len2-1) index++;\n\t\t}\n\
    \t\tif(index == 0) break;\n\t}\n\treturn index;\n}\n/*\n Find the last index of\
    \ a substring in a string.\n    >>> lastindexof(\"apple\", \"apple\")\n    0L\n\
    \    >>> lastindexof(\"apple\", \"aple\")\n    4L\n    >>> lastindexof(\"apple\"\
    , \"aplle\")\n    4L\n*/\nlong lastindexof(string string, string substring) \n\
    {\n\tlong index = string.length();\n\tint len1 = string.length();\n\tint len2\
    \ = substring.length();\n\tfor(int i = len1-1; i >= 0; i--)\n\t{\n\t\tif(string[i]\
    \ == substring[0]) index--;\n\t\tfor(int j = 0; j < len2; j++)\n\t\t{\n\t\t\t\
    if(string[i+j] != substring[j]) break;\n\t\t\tif(j == len2-1) index--;\n\t\t}\n\
    \t\tif(index == 0) break;\n\t}\n\treturn index;\n}\n/*\n Search the string for\
    \ the first occurrence of a substring\n    >>> findin(\"apple\", \"apple\")\n\
    \    3L\n    >>> findin(\"apple\", \"aple\")\n    1L\n    >>> findin(\"apple\"\
    , \"aplle\")\n    6L\n*/\nlong findin(string string, string substring) \n{\n\t\
    long index = string.length();\n\tint len1 = string.length();\n\tint len2 = substring.length();\n\
    \tfor(int i = 0; i < len1; i++)\n\t{\n\t\tif(string[i] == substring[0]) index--;\n\
    \t\tfor(int j = 0; j < len2; j++)\n\t\t{\n\t\t\tif(string[i+j] != substring[j]",
  "{\n    long count = 0;\n    for(int i = 0, j = string.length() - substring.length();\
    \ i < string.length() - substring.length(); i++, j++)\n    {\n        if(string.charAt(i)\
    \ == substring.charAt(j))\n        {\n            count++;\n            i += substring.length();\n\
    \        }\n        else\n        {\n            break;\n        }\n    }\n  \
    \  return count;\n}\n</code>\nAnd here is the new version of the function, now\
    \ it counts overlapped cases:\n<code>\n#include <stdio.h>\n#include <string.h>\n\
    #include <stdlib.h>", "{\n    long i = 0;\n    size_t len = string.size();\n \
    \   size_t s_len = substring.size();\n    string sub = substring;\n    if(s_len\
    \ == 0)\n        return 0;\n    while(i < len) {\n        size_t j = string.find(sub);\n\
    \        if(j == string::npos)\n            return 0L;\n        if(i < j) \n \
    \           i++;\n        else {\n            i += s_len+1;\n            ++j;\n\
    \            if(j == len)\n                break;\n            else\n        \
    \        sub += substring[j];\n        }\n    }\n    return i - string.find(sub);\n\
    }\n/*\n Return true if the string starts with substring. Otherwise, return false.\n\
    \ Note: This function is not case sensitive. \n*/", "{\n\tstring s_dup = string;\n\
    \tstring substr_dup = substring;\n\tbool found;\n\tlong count = 0;\n\t\n\tfor\
    \ (int i = 0; i < substr_dup.length(); i++)\n\t{\n\t\tfound = false;\n\t\tfor\
    \ (int j = 0; j < s_dup.length(); j++)\n\t\t{\n\t\t\tif (s_dup[j] == substr_dup[i])\n\
    \t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\
    \t\t\tbreak;\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count only the first occurrences.\n   \
    \ >>> how_many_times_first(\"aaa\", \"a\")\n    1L\n    >>> how_many_times_first(\"\
    aaaa\", \"a\")\n    0L\n*/\nlong how_many_times_first(string string, string substring)\
    \ \n{\n\tstring s_dup = string;\n\tstring substr_dup = substring;\n\tbool found;\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < substr_dup.length(); i++)\n\t{\n\t\
    \tfound = false;\n\t\tfor (int j = 0; j < s_dup.length(); j++)\n\t\t{\n\t\t\t\
    if (s_dup[j] == substr_dup[i])\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\treturn count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ only the last occurrences.\n    >>> how_many_times_last(\"aaa\", \"a\")\n  \
    \  1L\n    >>> how_many_times_last(\"aaaa\", \"a\")\n    0L\n*/\nlong how_many_times_last(string\
    \ string, string substring) \n{\n\tstring s_dup = string;\n\tstring substr_dup\
    \ = substring;\n\tbool found;\n\tlong count = 0;\n\t\n\tfor (int i = 0; i < substr_dup.length();\
    \ i++)\n\t{\n\t\tfound = false;\n\t\tfor (int j = s_dup.length(); j > 0; j--)\n\
    \t\t{\n\t\t\tif (s_dup[j-1] == substr_dup[i])\n\t\t\t{\n\t\t\t\tfound = true;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\treturn count;\n\
    }\n/*\n Find the first occurrence of a given substring in the original string.\
    \ Return index if found or -1 if not found.\n    >>> how_many_times(\"aaa\", \"\
    aa\")\n    1L\n    >>> how_many_times(\"aaaa\", \"a\")\n    1L\n    >>> how_many_times(\"\
    aaaa\", \"b\")\n    -1L\n*/\nlong how_many_times(string string, string substring,\
    \ bool from_start) ", "{\n    int pos = 0;\n    long count = 0L;\n    string sub;\n\
    \    \n    while (pos < string.length()) {\n        sub = string.substr(pos, substring.length());\n\
    \        if (sub == substring)\n            count++;\n        pos = pos + substring.length();\n\
    \    }\n    \n    return count;\n}", "{\n    long length = 0;\n    for(int i =\
    \ 0; i < string.length(); i++)\n    {\n        if(string.substring_of(i, string.length()\
    \ - substring.length()) == substring)\n            length++;\n    }\n    return\
    \ length;\n}", "{\n\tif (string == \"\") return 0;\n\tif (string.length == 0)\
    \ return 0;\n\tlong count = 0, i = 0;\n\twhile (i<string.length && string[i] ==\
    \ substring[0])\n\t{\n\t\tif (string[i] == substring[0] && substring[0] == string.substr(i+1,\
    \ substring.length).c_str()[0]) \n\t\t\ti++;\n\t\telse i++;\n\t\tcount++;\n\t\
    }\n\treturn count;\n}", "{\n    int j = 0;\n    long count = 0;\n    string tmp\
    \ = string;\n    while(tmp[j] != substring[j])\n    {\n        if(j == string.length()-1)\n\
    \            break;\n        j++;\n    }\n    int endj = j;\n    for(int i = j+1;i\
    \ < string.length(); i++)\n    {\n        if(string[i] == substring[j])\n    \
    \        count++;\n        else\n            break;\n        j++;\n    }\n   \
    \ return count;\n}\n</code>\n<|/ a |>\n<| c |>\nThis code has two bugs: 1) It\
    \ miscounts overlapping occurrences of substring.  2) It miscounts occurrences\
    \ of substring at the first position of the string.  You need to fix these bugs.\
    \  Also, it would be better to use `int j = 0, i = 0` to avoid these problems.\n\
    <|/ c |>\n<| c |>\n: Thanks Jason. I didn't know these issues. I have edited my\
    \ answer.\n<|/ c |>\n<| c |>\n: Thanks, I didn't know that Jason mentions them.\
    \ Edited my answer.\n<|/ c |>\n<| a dscore=1 |>\nYou can try the following:\n\
    <code>\n// Count the number of substrings in a string\n// by looking for the next\
    \ occurrence of a substring", "{\n    int i = 0;\n    int j = 0;\n    while(i\
    \ < string.len) {\n        j = string.find(substring, j);\n        if(j >= 0)\n\
    \            i += j - i;\n        ++j;\n    }\n    return i;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=string,c++,performance |>\nI needed a function that\
    \ takes a string as input and gives a map of substrings to the number of times\
    \ they occur.  My solution turned out to be fairly simple - I just needed an if-statement\
    \ and a loop.  \n<code>\n#include <string>\n#include <map>\n#include <stdio.h>",
  "{\n    long count;\n    for (count = 0L; count < string.length(); count++) \n \
    \   {\n        if ((string.indexOf(string[count], substring) == 0L) \n       \
    \   && (string.indexOf(string[count+1]) == string.length()-1))\n        {\n  \
    \          count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,performance,python\
    \ |>\n<| c |>\n+1 Good job (but you made it even more confusing by naming the\
    \ method `how_many_times`). But I still prefer your `search` solution (even if\
    \ it is a little bit longer :).\n<|/ c |>\n<| c |>\nAgreed. `search` may look\
    \ a little easier to understand when you are coming from other languages. In Python\
    \ `search` isn't that great either, but if one was to write it in C, the `for`\
    \ loop would look very similar. :) The `search` method is pretty simple and intuitive\
    \ to understand though. :P\n<|/ c |>\n<| c |>\n`search` is better because it doesn't\
    \ require a `for` loop. But the `for` loop is probably going to be the fastest\
    \ solution, because you are only searching a short substring in a longer string.\n\
    <|/ c |>\n<| a tags=string,performance,python dscore=2 |>\nSince this is a common\
    \ problem with a common solution, I'll give you a little perspective on how it\
    \ can be solved:\nPython has a built-in method called \"in\" that can tell you\
    \ if a substring is inside a string:\n<code>\nif \"foo\" in \"foobar\":\n    print\
    \ \"foo is in foobar\"\nelse:\n    print \"foo is not in foobar\"\n</code>\nThis\
    \ code is also extremely concise and clearly shows the intent of the solution.\
    \ Notice that Python has built-in functions for many common tasks such as this\
    \ one. So, why write your own solution? You probably know this already, but you\
    \ might want to look into the string methods available in the stdlib module. Think\
    \ of this module as your \"language\" of choice for doing string manipulation.\
    \ \nNow, you might want to do something really cool with the string you find,\
    \ such as remove duplicates, replace characters, or maybe even replace them with\
    \ a different character. Perhaps you could get fancy with your code, but the built-in\
    \ string methods are a great place to start. \nIn conclusion, yes, it would be\
    \ great to be able to use these built-in functions, and it's perfectly fine to\
    \ do so. But don't bother with the complexity of implementing your own \"string\"\
    \ class. Use Python's string methods. \nHope that ", "{\n    int index = substring.find(string);\n\
    \    if (index == string.length()) {\n        return 0;\n    }\n    return ((string.length\
    \ - index) * long(substring.length())) + how_many_times(string.substr(index),\
    \ substring);\n}", "{\n  long count = 0;\n  int i;\n  for(i = 0; i < string.length;\
    \ ++i)\n  {\n    if(string[i] == substring[0])\n    {\n      ++count;\n      for(int\
    \ j = 1; j < substring.length; ++j)\n        if(string[i + j] != substring[j])\
    \ break;\n      if(j == substring.length) \n        ++count;\n    }\n  }\n  return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in a string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"aba\", \"b\")\n    2L\n  \
    \  >>> how_many_times(\"aba\", \"ba\")\n    2L\n    \n*/\nlong how_many_times(string\
    \ string, string substring) \n{\n  long count = 0;\n  int i;\n  for(i = 0; i <\
    \ string.length; ++i)\n  {\n    if(string[i] == substring[0])\n    {\n      int\
    \ j;\n      for(j = 1; j < substring.length; ++j)\n        if(string[i + j] !=\
    \ substring[j]) break;\n      if(j == substring.length) \n        ++count;\n \
    \   }\n  }\n  return count;\n}", "{\n\tint i = 0;\n\tint j = 0;\n\tint count =\
    \ 0;\n\tlong max = 0;\n\twhile(i < string.size() && j < substring.size()) {\n\t\
    \tif(string[i] == substring[j]) {\n\t\t\ti++;\n\t\t\tj++;\n\t\t\tcount++;\n\t\t\
    \tif(count > max)\n\t\t\t\tmax = count;\n\t\t\telse {\n\t\t\t\tcount = 0;\n\t\t\
    \t}\n\t\t}\n\t\telse if(i == string.size()) {\n\t\t\tj++;\n\t\t\tif(j >= substring.size())\n\
    \t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tcount++;\n\t\t\tif(count > max)\n\t\t\t\t\
    max = count;\n\t\t\telse {\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\
    \t\tj++;\n\t\t\tcount = 0;\n\t\t}\n\t}\n\treturn max;\n}\n\t\n/*\n Return the\
    \ longest substring that occurs in \"substring\".\n */\nstring longest_substring(string\
    \ substring, string haystack)\n{\n\tassert(haystack.size() >= substring.size());\n\
    \tint i = 0;\n\tint j = 0;\n\tstring result = \"\";\n\tstring temp = \"\";\n\t\
    while(i < haystack.size() && j < substring.size()) {\n\t\tif(haystack[i] == substring[j])\
    \ {\n\t\t\tresult += haystack[i];\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\telse if(i\
    \ == haystack.size()) {\n\t\t\tresult += haystack[i];\n\t\t\ti++;\n\t\t\tj++;\n\
    \t\t}\n\t\telse {\n\t\t\tj++;\n\t\t\tresult = haystack[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}", "{\n    int start = string.find(substring);\n    if(start != string.length()-1)\
    \ {\n        return 1 + how_many_times(string.substr(start+1), substring);\n \
    \   }\n    return 0;\n}\n</code>\n<|/ a tags=string,c++ |>\n<| c |>\nI don't want\
    \ to import any libraries, just standard c++.\n<|/ c |>\n<| c |>\nAh, I didn't\
    \ even realize you were not allowed to import a library (as evidenced by your\
    \ question).\n<|/ c |>\n<| c |>\nThis code has some problems though: what happens\
    \ if `string` is an empty string and a substring to be found in that string? The\
    \ solution will not consider that. I suggest adding `if (string != \"\" && substring\
    \ != \"\")` to the start of the `how_many_times` function and it should solve\
    \ the problem.\n<|/ c |>\n<| a tags=string,c++ |>\nHere's a solution using strstr().\
    \ The downside of strstr() is that the search string must be present in the entire\
    \ string, which is not always true.\n<code>\n#include <iostream>\n#include <cstring>\n\
    using namespace std;", "{\n    int count = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        for (int j = i; j < string.length(); j++) {\n            if\
    \ (string.substring(i, j).equals(substring)) {\n                count++;\n   \
    \             break;\n            }\n        }\n    }\n    return count;\n}\n\
    </code>\n<|/ a tags=c++,string |>\n<| c |>\nThat seems a bit too much effort just\
    \ to get the number of occurrences of a substring.\n<|/ c |>\n<| c |>\nIt works,\
    \ I wouldn't want to do that in production code, I used it here for illustrative\
    \ purposes only.\n<|/ c |>\n<| c |>\nHmm... that `break` is going to break the\
    \ inner loop. That's not going to get you the right answer. Maybe I misunderstood\
    \ the question?\n<|/ c |>\n<| c |>\nyeah, it breaks out of that inner loop, but\
    \ that's not what he wants. He wants the number of *unique* occurrences of the\
    \ substring within the string, which can be done by removing the inner `break`\
    \ statement.\n<|/ c |>\n<| c |>\nOk, I see what you mean, but `break` will break\
    \ the inner loop anyway. My mistake.\n<|/ c |>\n<| a dscore=1 tags=c++,string\
    \ |>\nHere's a quick and dirty way that I think is faster than the other suggestions.\
    \ I haven't tested it though:\n<code>\n#include <iostream>\n#include <string>\n\
    #include <vector>\n#include <algorithm>\nusing namespace std;", "{\n    long count\
    \ = 0;\n    if(string.find(substring) == string.length())\n        return count;\n\
    \    \n    int start = 0;\n    int end = string.length();\n    int index = string.find(substring);\n\
    \    while(index != -1)\n    {\n        \n        if(string.find(substring, index)\
    \ == index)\n        {\n            if(start < index)\n                start =\
    \ index;\n            if(end < index)\n                end = index;\n        }\n\
    \        index = string.find(substring, index+1);\n        count++;\n    }\n \
    \   \n    return count;\n}", "{\n   long count = 0;\n   for(int i = 0; i < string.length()\
    \ - substring.length(); i++) {\n      for(int j = 0; j < substring.length(); j++)\
    \ {\n         if(string.substr(i, substring.length()) == substring)\n        \
    \    count++;\n         else\n            break;\n      }\n   }\n   return count;\n\
    }", "{\n    int n = 0;\n    for(int i = 0; i < string.length(); i++) {\n     \
    \   for(int j = 0; j < substring.length(); j++) {\n            if(i == string.length()\
    \ - 1) {\n                n = n + string.find_first_not_of(substring[j], 0, j);\n\
    \            } else {\n                n = n + string.find_first_not_of(substring[j],\
    \ i, string.length());\n            }\n        }\n    }\n    return n;\n}\n</code>\n\
    <|/ a tags=string,substring dscore=1 |>\n<| a |>\nThis is a C++ answer that uses\
    \ the standard library (std::search, std::find_first_of, std::find_first_not_of,\
    \ and std::count_if - and some algorithms from <algorithm> that you may not have\
    \ seen yet):\n<code>", "{\n    // Count overlaping cases.\n    long count = 0;\n\
    \    \n    // Find the first occurrence of the substring.\n    int pos = string.find(substring);\n\
    \    while (pos != string::npos) \n    {\n        count++;\n        // Find the\
    \ next occurrence of the substring.\n        pos = string.find(substring, pos\
    \ + substring.length());\n    }\n    return count;\n}", "{\n    map<long, string>\
    \ m;\n    for(long i = 0; i < string.length(); i++)\n    {\n        m[count(substring,\
    \ string[i])] = string[i];\n    }\n    return m[substring.size()];\n}\n</code>\n\
    <|/ a tags=string,c++,algorithm dscore=0 |>\n<| c |>\nHmm.. i don't think that\
    \ is a valid solution for `\"aaaaa\"` and `\"a\"`. Your algorithm would give `1`\
    \ for `\"aaa\"`\n<|/ c |>\n<| c |>\nOops, yeah you're right. Fixed the algorithm.\n\
    <|/ c |>\n<| c |>\nThis solution only works if the string is a prefix of the search\
    \ string.  If the string is a suffix the results won't be as expected.\n<|/ c\
    \ |>\n<| c |>\nIt's a good solution but doesn't take in to account the fact that\
    \ you can have multiple times the same character in a string. E.g. `how_many_times(\"\
    aaaabbb\", \"a\")` would return `3` and not `2`.\n<|/ c |>\n<| c |>\n, good point.\
    \ I have edited the answer to take account of multiple instances of the substring\
    \ as well. Thanks.\n<|/ c |>\n<| a |>\nIf you want a c++ solution here's mine:\n\
    <code>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n\
    using namespace std;", "{\n    long count = 0;\n    for(int i = 0; i < string.size();\
    \ ++i)\n    {\n        if(string.at(i) == substring[0])\n        {\n         \
    \   for(int j = i; j < string.size(); ++j)\n            {\n                if(string.at(j)\
    \ == substring.at(0))\n                {\n                    if(string.at(j +\
    \ 1) != substring.at(1))\n                        break;\n                   \
    \ else\n                        ++count;\n                }\n                else\n\
    \                    break;\n            }\n            \n        }\n    }\n \
    \   \n    return count;\n}", "{\n\tlong result = 0;\n\tsize_t pos;\n\tfor(pos=string.find(substring);pos!=string::npos;pos=string.find(substring))\n\
    \t{\n\t\tif(string[pos]!=substring[0]) \n\t\t{\n\t\t\tif((pos+1)==string.size())\
    \ \n\t\t\t\tresult += 1;\n\t\t\telse \n\t\t\t\tresult += how_many_times(string.substr(pos+1),substring);\n\
    \t\t}\n\t}\n\treturn result;\n}\n/*\n Get how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times_case_insensitive(\"\
    \", \"A\")\n    0L\n    >>> how_many_times_case_insensitive(\"aaa\", \"A\")\n\
    \    3L\n    >>> how_many_times_case_insensitive(\"aaaa\", \"A\")\n    3L\n  \
    \  \n*/\nlong how_many_times_case_insensitive(string string, string substring)\
    \ \n{\n\tlong result = 0;\n\tsize_t pos;\n\tfor(pos=string.find(substring);pos!=string::npos;pos=string.find(substring))\n\
    \t{\n\t\tif(string[pos]==substring[0]) \n\t\t{\n\t\t\tif((pos+1)==string.size())\
    \ \n\t\t\t\tresult += 1;\n\t\t\telse \n\t\t\t\tresult += how_many_times_case_insensitive(string.substr(pos+1),substring);\n\
    \t\t}\n\t}\n\treturn result;\n}", "{\n\tlong start = 0;\n\tlong end = 0;\n\tlong\
    \ overlaps = 0;\n\tlong n = 0;\n\tlong substring_index = 0;\n\t\n\twhile(end <\
    \ string.size())\n\t{\n\t\tsubstring_index = string.find(substring, end);\n\t\t\
    if(substring_index == string::npos)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tstart\
    \ = end - substring_index;\n\t\tend = start + 1;\n\t\t\n\t\toverlaps += (end -\
    \ start);\n\t\t\n\t\t++n;\n\t}\n\t\n\treturn overlaps;\n}", "{\n    long count\
    \ = 0;\n    for (int i=0; i < string.length(); i++) \n    {\n        if ( string.find(substring,\
    \ i, string.length()) == string.length() ) \n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,search,algorithm,c++\
    \ |>\n<| c |>\nThis answer is very similar to the one by user348711.\n<|/ c |>\n\
    <| c |>\nActually, this one avoids creating intermediate strings, which is good\
    \ if memory is a concern.\n<|/ c |>\n<| a tags=string,search,algorithm,c++ |>\n\
    Here is an example in Javascript of a function that returns a count of characters\
    \ in a string that match a pattern. Using regular expressions makes it easy to\
    \ find patterns in strings and it takes care of overlaps.\nThe pattern can be\
    \ a substring of a string you are searching. It works by using a RegExp object\
    \ to find each of the patterns in the given string. Each pattern is matched to\
    \ a different capture group. Once all patterns are found the function checks to\
    \ see if the first capture group has anything in it. If so, it returns true. If\
    \ not, it returns false.\nThe pattern is written so that it uses two capture groups.\
    \ One group is for the entire pattern, and the other group is for the characters\
    \ that match the pattern.\n<code>\nfunction checkPattern(pattern, string){\n \
    \   if(!pattern)\n        return false;\n    pattern = new RegExp(pattern);\n\
    \    let totalMatches = 0;\n    let totalChars = 0;\n    let captureGroupMatches\
    \ = true;\n    while(captureGroupMatches){\n        captureGroupMatches = false;\n\
    \        let matchArray = string.match(pattern);\n        if(matchArray){\n  \
    \          for(let i = 0; i < matchArray.length; i++){\n                let match\
    \ = matchArray[i];\n                if(i === 0){\n                    totalChars\
    \ += matchArray[i].length;\n                    totalMatches += 1;\n         \
    \       }\n                else{\n                    let char = match.slice(-1);\n\
    \                    totalChars += char.length;\n                    if(char ===\
    \ matchArray[i-1].slice(-1)){\n                        totalMatches += 1;\n  \
    \                  }\n                }\n            }\n        }\n    }\n   \
    \ return totalMatches === totalChars;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    What if pattern = \"^.*a\" where you want to get count of number of times \"a\"\
    \ appears in string \"aab\"?\n<|/ c |>\n<| c |>\nThis is pretty much what I was\
    \ trying to do with my code above. `pattern` is `^.*a` and I was checking that\
    \ the count of chars was the same as the number of matches.\n<|/ c |>\n<| c |>\n\
    I think this could be ", "{\n    int i, j;\n    \n    int l = min(string.size(),\
    \ substring.length());\n    for (i = 0; i < l; ++i)\n    {\n        if (string[i]\
    \ == substring[i])\n        {\n            continue;\n        }\n        for (j\
    \ = i + 1; j < l; ++j)\n        {\n            if (string[j] == substring[j])\n\
    \            {\n                return j - i;\n            }\n        }\n    }\n\
    \    return 0L;\n}", "{\n  long count = 0;\n  long length_string = string.length;\n\
    \  long length_substring = substring.length;\n  if (length_substring == 0) {\n\
    \    return count;\n  }", "{\n    auto count = string.length();\n    for(long\
    \ i = 0; i < string.length(); i++)\n    {\n        size_t j = 0;\n        while(string[j]\
    \ == substring[j])\n        {\n            j++;\n        }\n        bool overlap\
    \ = j > 1 && string[i...j] == substring[1...j];\n        if(overlap)\n       \
    \ {\n            count += (i - j);\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string,java dscore=2 |>\n<| a tags=string,java |>\nJava 8 solution:\n\
    <code>\nlong how_many_times(String string, String substring) {\n    return string.chars()\n\
    \                 .filter(c -> c == substring.charAt(0))\n                 .count()\
    \ + string.chars()\n                                 .filter(c -> c == substring.charAt(substring.length()\
    \ - 1))\n                                 .count();\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\n<code>\npublic static void main(String[] args)\n{\n        String\
    \ string = \"abcde\";\n        String subString = \"bc\";\n        int count =\
    \ 0;", "{\n    long count = 0;\n    for (char c : string) \n    {\n        if\
    \ (c == substring[0]) \n        {\n            count += how_many_times(string.substring(1));\n\
    \        }\n        if (c == substring[1]) \n        {\n            count += how_many_times(string.substring(1));\n\
    \        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=python\
    \ |>\n<code>\ndef countChar(string, char):\n    counter = 0\n    for i in range(len(string)):\n\
    \        if string[i] == char:\n            counter += 1\n    return counter\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nThis will work but will take longer if you\
    \ have to do this several times (once for each character). Also it will not work\
    \ if you want to know how many times any two characters occur in the string. This\
    \ is because you are only counting when `string[i]==char` but you need to count\
    \ it for two characters.\n<|/ c |>\n<| a tags=python |>\n<code>\n>>> from collections\
    \ import Counter\n>>> s = \"aaaaaa\"\n>>> c = Counter()\n>>> for i,c in enumerate(s):\n\
    ...     c[c]+=1\n...     if i > 0 and c == s[i-1]:\n...         c[c]+=1\n... \n\
    >>> c\nCounter({'a': 3, 'b': 2, 'c': 1})\n</code>\n<|/ a dscore=3 |>\n<| a |>\n\
    I believe this solution is O(n) complexity (it uses recursion):\n<code>\ndef count(string,\
    \ char):\n    res = 0\n    for i in range(len(string)):\n        if string[i]\
    \ == char:\n            res += count(string[:i], char) + count(string[i+1:], char)\n\
    \    return res\n</code>\n<|/ a dscore=3 tags=python |>\n<| c |>\nThis solution\
    \ is O(n^2) (it uses two recursions)\n<|/ c |>\n<| a dscore=2 |>\nHere's a short\
    \ and simple solution for python 2.6+ using generator expression:\n<code>\ndef\
    \ count_char(text, c):\n    return (c for c in text if c == c)\n</code>\n<|/ a\
    \ tags=python |>\n<| a tags=python dscore=2 |>\n<code>\ndef count_char(string,\
    \ char):\n  count = 0\n  for i in range(len(string)):\n    if string[i] == char:\n\
    \      count += 1\n  return count\n</code>\n<|/ a |>\n<| a dscore=2 tags=python\
    \ |>\n<code>\ndef count_char(string, char):\n    count = 0\n    for i in range(len(string)):\n\
    \        if string[i] == char:\n            count += 1\n    return count\n</code>\n\
    <|/ a |>\n<| c |>\nWhile this code may ", "{\n\tsize_t length = (size_t) string.length();\n\
    \tsize_t foundLength = 0;\n\tsize_t count = 0;\n\t\n\tif (substring == string)\n\
    \t\treturn 0;\n\t\n\tfor (size_t i = 0; i <= length; i++)\n\t{\n\t\tif (string.find(substring,\
    \ i) != string::npos) \n\t\t{\n\t\t\tfoundLength++;\n\t\t\tcount += length - (i\
    \ - foundLength);\n\t\t}\n\t}\n\treturn count;\n}", "{\n\tlong count = 0;\n\t\
    int i = 0;\n\tfor (;; string[i] = 0)\n\t{\n\t\ti++;\n\t\tif (string[i] == 0 ||\
    \ string[i] == substring[0])\n\t\t\tbreak;\n\t\tif (string[i] == substring[0]\
    \ && string[i+1] == substring[1])\n\t\t\tcount++;\n\t\tif (string[i] == substring[0])\n\
    \t\t\tbreak;\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlapping cases.\n    >>> how_many_times(\"\
    aaa\", \"bb\")\n    3L\n*/\nlong how_many_times(string string, string substring,\
    \ int offset) \n{\n\tlong count = 0;\n\tint i = 0;\n\tfor (;; string[i] = 0)\n\
    \t{\n\t\ti++;\n\t\tif (string[i] == 0)\n\t\t\tbreak;\n\t\tif (string[i] == substring[offset])\n\
    \t\t\tcount++;\n\t\tif (string[i] == substring[offset] && string[i+1] == substring[offset+1])\n\
    \t\t\tcount++;\n\t\tif (string[i] == substring[offset])\n\t\t\tbreak;\n\t}\n\t\
    return count;\n}\n/*\n Find how many times a given substring can be found in the\
    \ original string. Count overlapping cases. Add offset to result.\n    >>> how_many_times(\"\
    aaa\", \"bb\", 3)\n    3L\n*/\nlong how_many_times(string string, string substring,\
    \ int offset) \n{\n\tlong count = 0;\n\tint i = 0;\n\tfor (;; string[i] = 0)\n\
    \t{\n\t\ti++;\n\t\tif (string[i] == 0)\n\t\t\tbreak;\n\t\tif (string[i] == substring[offset])\n\
    \t\t\tcount++;\n\t\tif (string[i] == substring[offset] && string[i+1] == substring[offset+1])\n\
    \t\t\tcount++;\n\t\tif (string[i] == substring[offset])\n\t\t\tbreak;\n\t}\n\t\
    return count + offset;\n}\n/*\n Count how many times a given substring can be\
    \ found in the original string. Add offset to result.\n    >>> how_many_times(\"\
    aba\", \"ca\")\n    3L\n*/\nlong how_many_times(string string, string substring,\
    \ int offset) \n{\n\tlong count = 0;\n\tint i = 0;\n\tfor (;; string[i] = 0)\n\
    \t{\n\t\ti++;\n\t\tif (string[i] == 0)\n\t\t\tbreak;\n\t\tif (string[i] == substring[offset])\n\
    \t\t\tcount++;\n\t\tif (string[i] == substring[offset] && string[i+1] == substring[offset+1])\n\
    \t\t\tcount++;\n\t\tif (string[i] == substring[offset])\n\t\t\tbreak;\n\t}\n\t\
    return count + offset;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Add offset to result.\n    >>> how_many_times(\"aba\"\
    , \"ca\", ", "{\n    int len = string.length();\n    for(int i = 0; i < len; ++i)\n\
    \    {\n        if(string.charAt(i) == substring.charAt(0))\n        {\n     \
    \       int start = i + 1;\n            while(string.charAt(start) == substring.charAt(0))\n\
    \                ++start;\n            long num = 1;\n            for(int j =\
    \ start; j < len; ++j)\n            {\n                if(string.charAt(j) ==\
    \ substring.charAt(1))\n                    ++num;\n            }\n          \
    \  return num;\n        }\n    }\n    return 0L;\n}", "{\n    long count = 0;\
    \ \n    long position = 0; \n    \n    while(position != string.Length) \n   \
    \ {\n        position = string.IndexOf(substring, position, position+1); \n  \
    \      \n        if(position != -1) \n        { \n            count++; \n    \
    \        position = string.IndexOf(substring, position+1, position+2); \n    \
    \    } \n        else\n        {\n            break;\n        }\n    }\n    return\
    \ count; \n}", "{\n    long count = 0;\n    string current = string;\n    while\
    \ (current.length() > substring.length()) {\n        current = current.substr(0,\
    \ current.length()-1);\n        if (current.length() != substring.length()) {\
    \ count++; };\n    }\n    current = string;\n    while (current.length() < substring.length())\
    \ {\n        current = current + substring;\n        count++;\n    }\n    return\
    \ count;\n}\n/*\n Find the longest common substring in a string\n    \n This function\
    \ uses dynamic programming to calculate the longest common substring of a string.\n\
    \    \n It was a challenge that I had to solve and I thought it would be interesting\
    \ to see how long it takes to calculate.\n    \n It took about 50 seconds to calculate\
    \ the longest common substring of a string with 1000 characters.\n    \n It is\
    \ also interesting to see how long it takes to calculate the longest common substring\
    \ of a string with millions of characters.\n    \n The code was quite straightforward,\
    \ so I didn't optimize it. You can optimize it by writing a custom version of\
    \ find_lcs. You would have to write it in a very simple language that doesn't\
    \ have any looping or recursion. One could even use a simple language like Fortran.\
    \ \n    \n I wrote the function so that it would be easy to follow along with\
    \ an explanation of how it works. To read it, think of it as a function with two\
    \ arguments: a string, and a substring. The function returns the number of times\
    \ that the substring can be found in the string. There is also a third argument,\
    \ a minimum length that is allowed between the two strings. So if you want it\
    \ to return 3 for \"aaa\" and \"aa\", you would set the minimum length to 2.\n\
    \    \n I wrote the function so that it would return the longest common substring\
    \ in a string and the minimum length of the substring between the two strings.\
    \ It would return (0,0,0) if the minimum length argument is greater than the length\
    \ of the strings. The function returns a tuple of the two values (the longest\
    \ common substring and the minimum length of the substring). \n    \n For example,\
    \ how_many_times(\"aaa\", \"a\") would return (2L, 0L, 0L) and how_many_times(\"\
    aaaa\", \"aa\") would return (3L, 3L, 0L).\n    \n A final note: the code is not\
    \ very efficient or elegant. There might be better ways to do this, but it should\
    \ be very easy to read and understand.\n*/\n(string, string, long, long) -> long\n\
    how_many_times(string string, string substring, long min_length)\n{\n    if (string.length()\
    \ < min_length) { return (0, 0, 0L); };\n    int max_l = min(string.length(),\
    \ substring.length());\n    string substring2 = substring.substr(0, max_l);",
  "{\n    long count = 0;\n    int size = string.size();\n    int offset = substring.size();",
  "{\n    string result;\n    long count = 1;\n    long lastindex = 0;"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
