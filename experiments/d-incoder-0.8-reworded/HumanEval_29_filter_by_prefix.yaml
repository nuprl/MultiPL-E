name: HumanEval_29_filter_by_prefix
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Filter an input array of strings\
  \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([], \"\
  a\")\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"\
  a\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_prefix(string[] strings,\
  \ string prefix) \n"
tests: "unittest\n{\n    alias candidate = filter_by_prefix;\n\n    assert(candidate([],\
  \ \"john\") == []);\n    assert(candidate([\"xxx\", \"asd\", \"xxy\", \"john doe\"\
  , \"xxxAAA\", \"xxx\"], \"xxx\") == [\"xxx\", \"xxxAAA\", \"xxx\"]);\n}\nvoid main(){}"
completions: ["{\n\tint i,\n\t\tj,\n\t\tlen = strings.length;\n\tfor (i = 0; i < len;\
    \ i++) {\n\t\tfor (j = 0; j < prefix.length; j++) {\n\t\t\tif (strings[i].compare(0,\
    \ prefix.length * j, prefix) == 0) {\n\t\t\t\treturn strings;\n\t\t\t}\n\t\t}\n\
    \t}\n\treturn strings;\n}\n/*\n Filter an input array of strings only for those\
    \ which end with the given suffix.\n    >>> filter_by_suffix([], \"c\")\n    []\n\
    \    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"c\")\n   \
    \ [\"abc\"]\n    \n*/\nstring[] filter_by_suffix(string[] strings, string suffix)\
    \ \n{\n\tint i,\n\t\tj,\n\t\tlen = strings.length;\n\tfor (i = 0; i < len; i++)\
    \ {\n\t\tfor (j = 0; j < suffix.length; j++) {\n\t\t\tif (strings[i].compare(len\
    \ - suffix.length * j, suffix.length * j) == 0) {\n\t\t\t\treturn strings;\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn strings;\n}\n/*\n Filter an input array of strings\
    \ only for those which have all characters in chars.\n    >>> filter_by_all([],\
    \ \"bc\")\n    []\n    >>> filter_by_all([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"bc\")\n    [\"bcd\"]\n    \n*/\nstring[] filter_by_all(string[] strings,\
    \ string chars) \n{\n\tint i,\n\t\tj,\n\t\tlen = strings.length;\n\tfor (i = 0;\
    \ i < len; i++) {\n\t\tfor (j = 0; j < chars.length; j++) {\n\t\t\tif (strings[i].contains(chars.chars[j]))\
    \ {\n\t\t\t\treturn strings;\n\t\t\t}\n\t\t}\n\t}\n\treturn strings;\n}", "{\n\
    \    if (strings.length == 0) {\n        return strings;\n    }\n    \n    if\
    \ (strings.length == 1) {\n        return strings.Where((string s) => s.StartsWith(prefix));\n\
    \    }\n    \n    return strings.Where((string s) => s.StartsWith(prefix)).SelectMany(filter_by_prefix);\n\
    }\n</code>\nAnd here is the version that uses LINQ (it also has the benefit of\
    \ being more efficient because it doesn't redo all the string processing when\
    \ there is nothing to do). It also has more verbose error handling and a version\
    \ that does not require a prefix argument.\n<code>\npublic static string[] filter_by_prefix(IEnumerable<string>\
    \ strings, string prefix = null)\n{\n    IEnumerable<string> stringSequence =\
    \ null;\n    bool prefixIsNullOrEmpty = prefix == null ||\n                  \
    \              string.IsNullOrEmpty(prefix) ||\n                             \
    \   string.IsNullOrEmpty(strings.FirstOrDefault());\n    \n    if (prefixIsNullOrEmpty)\
    \ {\n        stringSequence = strings.Select(s => s);\n    }\n    else {\n   \
    \     stringSequence = strings.Where((string s) => s.StartsWith(prefix));\n  \
    \  }\n    \n    string[] filteredResults = stringSequence.Select(s => filter_by_prefix(s,\
    \ prefix)).ToArray();\n    \n    if (prefixIsNullOrEmpty) {\n        return filteredResults;\n\
    \    }\n    \n    string[] results = filteredResults.SelectMany(filter_by_prefix).ToArray();\n\
    \    \n    return results;\n}", "{\n  string start = prefix;\n  string end = strings[0];\n\
    \  for(int i=1; i<strings.length; i++){\n    if(!strings[i].startsWith(start))\
    \ continue;\n    end = strings[i];\n  }\n  return strings;\n}", "{\n  List<string>\
    \ result = [];\n  foreach (string s in strings) {\n    if(s.StartsWith(prefix))\
    \ {\n      result.Add(s);\n    }\n  }\n  return result.ToArray();\n}\n</code>\n\
    <|/ a tags=c#,linq,algorithm,c#-7.0 dscore=5 |>\n<| c |>\nThis is pretty amazing!\
    \ It works like a charm and I even learned about it. I will accept this as the\
    \ answer since this is the \"official\" way in C#. I had never heard of C#7 until\
    \ now. Thanks!\n<|/ c |>\n<| c |>\nIt's amazing! Just the right way to do it.\
    \ Thank you!\n<|/ c |>\n<| c |>\nWhy do you need the list to be a parameter? Why\
    \ not just pass strings and get the same result?\n<|/ c |>\n<| a tags=c#,linq,algorithm,c#-7.0\
    \ |>\nFor all those that need some simple LINQ solution, here is another one using\
    \ string methods:\n<code>\nvar strings = new List<string>();\nstrings.Add(\"abc\"\
    );\nstrings.Add(\"def\");\nstrings.Add(\"ghi\");\nstrings.Add(\"jkl\");", "{\n\
    \tstring[] result = new string[strings.length];\n\tfor (int i = 0; i < strings.length;\
    \ ++i) {\n\t\tif (strings[i].StartsWith(prefix)) {\n\t\t\tresult[i] = strings[i];\n\
    \t\t}\n\t}\n\treturn result;\n}", "{\n    for (int i = 0; i < strings.length;\
    \ i++)\n    {\n        if (strings[i].StartsWith(prefix))\n        {\n       \
    \     strings[i] = strings[i].Substring(prefix.Length);\n        }\n    }", "{\n\
    \    \n    int prefix_length = prefix.length;\n    \n    for (int i = 0; i < strings.length;\
    \ i++) \n    {\n        if (strings[i].StartsWith(prefix, prefix_length)) \n \
    \       {\n            strings[i] = strings[i].Substring(prefix_length);\n   \
    \     }\n    }\n    \n    return strings;\n}\n/*\n Filter an input array of strings\
    \ only for ones that end with a given suffix.\n    >>> filter_by_suffix([], \"\
    a\")\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"],\
    \ \"e\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_suffix(string[]\
    \ strings, string suffix) \n{\n    \n    int suffix_length = suffix.length;\n\
    \    \n    for (int i = 0; i < strings.length; i++) \n    {\n        if (strings[i].EndsWith(suffix,\
    \ suffix_length)) \n        {\n            strings[i] = strings[i].Substring(0,\
    \ strings[i].Length - suffix_length);\n        }\n    }\n    \n    return strings;\n\
    }\n/*\n Convert an input array of strings to a dictionary of strings (key-value\
    \ pairs)\n    where the keys start with the prefix (as given in prefix) and the\
    \ values\n    are arrays of strings (the original strings).\n    \n    >>> array_to_dict([],\
    \ prefix, prefix)\n    {}\n    >>> array_to_dict([\"abc\", \"array\", \"bcd\"\
    , \"cde\"], prefix, \"-\")\n    {\n        \"a-array\" : [ \"abc\", \"array\"\
    \ ],\n        \"b-cd\"   : [ \"bcd\", \"cde\" ]\n    }\n    \n*/\nDictionary<string,\
    \ string[]> array_to_dict(string[] strings, string prefix, string separator)\n\
    {\n    Dictionary<string, string[]> dict = new Dictionary<string, string[]>();",
  "{\n    string[] result = new string[0];\n    if (strings.length == 0) return result;",
  "{\n    List<string> res = new List<string>();\n    foreach(string str in strings)\
    \ {\n        if(str.StartsWith(prefix)) {\n            res.Add(str);\n       \
    \ }\n    }\n    return res.ToArray();\n}\n</code>\n<|/ a |>\n<| c |>\n`string[]\
    \ filtered = strings.Where(str => str.StartsWith(prefix)).ToArray();` returns\
    \ `string[]`.\n<|/ c |>\n<| c |>\n: Yeah, that would work too. I'll edit my answer\
    \ to include that.\n<|/ c |>\n<| a dscore=2 tags=c#,string |>\nYou can use LINQ\
    \ to solve this problem very easily:\n<code>\nIEnumerable<string> filterStrings(IEnumerable<string>\
    \ strings, string prefix)\n{\n    return strings.Where(s => s.StartsWith(prefix));\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThat would return an `IEnumerable<string>`\n<|/\
    \ c |>\n<| c |>\n: Yeah, it would. Fixed.\n<|/ c |>\n<| a |>\nYou could use a\
    \ regular expression for this:\n<code>\npublic bool isPrefix(string str, string\
    \ prefix)\n{\n    return Regex.IsMatch(str, Regex.Escape(prefix));\n}\n</code>\n\
    <|/ a tags=c#,string dscore=2 |>\n<| c |>\nThis would return false positives,\
    \ e.g. \"aaafoobar\".StartsWith(\"foob\") would return true, but should return\
    \ false.\n<|/ c |>\n<| a |>\nYou can use the StartsWith and Contains methods of\
    \ a string object.\n<code>\nvar prefix = \"a\";\nvar strings = new List<string>();\n\
    strings.Add(\"a\");\nstrings.Add(\"ab\");\nstrings.Add(\"ac\");\nstrings.Add(\"\
    ad\");\nstrings.Add(\"aa\");\nstrings.Add(\"abba\");\nstrings.Add(\"ads\");\n\
    strings.Add(\"a\");\nstrings.Add(\"aaa\");\nstrings.Add(\"bbb\");\nstrings.Add(\"\
    aaab\");\nstrings.Add(\"ccc\");", "{\n  int i;\n  int len = strings.length;\n\
    \  string[] results = new string[len];\n  for (i = 0; i < len; ++i) {\n    if\
    \ (strings[i].Length > 0) {\n      if (strings[i].StartsWith(prefix))\n      \
    \  results[results.Length] = strings[i];\n    }\n  }\n  return results;\n}\n/*\n\
    \ Filter an input array of strings only for ones that end with a given suffix.\n\
    \    >>> filter_by_suffix([], \"array\")\n    []\n    >>> filter_by_suffix([\"\
    abc\", \"bcd\", \"cde\"], \"array\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[]\
    \ filter_by_suffix(string[] strings, string suffix) \n{\n  int i;\n  int len =\
    \ strings.length;\n  string[] results = new string[len];\n  for (i = 0; i < len;\
    \ ++i) {\n    if (strings[i].Length > 0) {\n      if (strings[i].EndsWith(suffix))\n\
    \        results[results.Length] = strings[i];\n    }\n  }\n  return results;\n\
    }\n/*\n Filter an input array of strings only for ones that contain a given suffix.\n\
    \    >>> filter_by_contains([], \"bcd\")\n    []\n    >>> filter_by_contains([\"\
    abc\", \"bcd\", \"cde\"], \"bcd\")\n    [\"bcd\"]\n    \n*/\nstring[] filter_by_contains(string[]\
    \ strings, string suffix) \n{\n  int i;\n  int len = strings.length;\n  string[]\
    \ results = new string[len];\n  for (i = 0; i < len; ++i) {\n    if (strings[i].Length\
    \ > 0) {\n      if (strings[i].Contains(suffix))\n        results[results.Length]\
    \ = strings[i];\n    }\n  }\n  return results;\n}\n/*\n Filter an input array\
    \ of strings only for ones that match a regex.\n    >>> filter_by_regex([], \"\
    ^a\")\n    []\n    >>> filter_by_regex([\"abc\", \"bcd\", \"cde\"], \"^a\")\n\
    \    [\"abc\"]\n    \n*/\nstring[] filter_by_regex(string[] strings, string regex)\
    \ \n{\n  int i;\n  int len = strings.length;\n  string[] results = new string[len];\n\
    \  for (i = 0; i < len; ++i) {\n    if (strings[i].Length > 0) {\n      if (Regex.IsMatch(strings[i],\
    \ regex))\n        results[results.Length] = strings[i];\n    }\n  }\n  return\
    \ results;\n}\n/*\n Sort an array by one or multiple keys. \n    >>> sort_by_key([\"\
    c\", \"a\", \"b\"], \"a\")\n    [\"a\", \"b\", \"c\"]\n    >>> sort_by_key([\"\
    c\", \"a\", \"b\"], \"b\", \"a\")\n    [\"a\", \"b\", \"c\"]\n    >>> sort_by_key([\"\
    c\", \"a\", \"b\"], \"c\")\n    [\"c\", \"a\", \"b\"]\n    \n*/\nstring[] sort_by_key(string[] ",
  "{\n    List<string> filtered = new List<string>();\n    foreach (string s in strings)\
    \ {\n        if (s.StartsWith(prefix)) {\n            filtered.Add(s);\n     \
    \   }\n    }\n    return filtered.ToArray();\n}", "{\n\tstring[] result = new\
    \ string[strings.length];\n\tfor(int i = 0; i < strings.length; ++i) {\n\t\tif(strings[i].StartsWith(prefix))\
    \ {\n\t\t\tresult[i] = strings[i];\n\t\t}\n\t}\n\treturn result;\n}", "{\n   \
    \ string[] result = new string[strings.length];\n    for (int i = 0; i < strings.length;\
    \ ++i)\n    {\n        if (strings[i].StartsWith(prefix))\n        {\n       \
    \     result[i] = strings[i];\n        }\n    }\n    return result;\n}", "{\n\t\
    // TODO: Optimize this to use std.algorithms iterators\n\tfor (int i=0; i<strings.length;\
    \ i++)\n\t{\n\t\tif (strings[i].StartsWith(prefix))\n\t\t{\n\t\t\tstrings[i] =\
    \ strings.Remove(0, prefix.length);\n\t\t}\n\t}\n\treturn strings;\n}", "{\n \
    \ List<string> res = new List<string>();\n  foreach (string s in strings) {\n\
    \    if (string.Compare(s, prefix, true, System.Globalization.CultureInfo.InvariantCulture)\
    \ == 0) {\n      res.Add(s);\n    }\n  }\n  return res.ToArray();\n}", "{\n  \
    \  int length = strings.length; \n    int i = 0; \n    while(i < length) \n  \
    \  {\n        if (strings[i].startsWith(prefix)) \n        {\n            strings[i]\
    \ += strings[i].substring(prefix.length());\n        }\n        ++i;\n    }\n\
    \    return strings;\n}", "{\n    var r = [];\n    foreach (string s in strings)\
    \ {\n        if (s.StartsWith(prefix))\n            r.Add(s);\n    }\n    return\
    \ r;\n}", "{\n    for(string s : strings)\n        if(s.StartsWith(prefix))\n\
    \            yield return s;\n}\n/*\n Filter an input array of strings only for\
    \ ones that end with a given suffix.\n    >>> filter_by_suffix([], \"ab\")\n \
    \   []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\"], \"ab\")\n    [\"\
    abc\"]\n    \n*/\nstring[] filter_by_suffix(string[] strings, string suffix) \n\
    {\n    for(string s : strings)\n        if(s.EndsWith(suffix))\n            yield\
    \ return s;\n}", "{\n    string[] result = new string[0];\n    for (int i = 0;\
    \ i < strings.length; i++){\n        if (strings[i].StartsWith(prefix)){\n   \
    \         result += strings[i];\n        }\n    }\n    return result;\n}\n/*\n\
    \ Filter an input array of strings only for ones that end with a given suffix.\n\
    \    >>> filter_by_suffix([], \"ed\")\n    []\n    >>> filter_by_suffix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"ed\")\n    [\"abc\", \"array\"]\n    \n*/\n\
    string[] filter_by_suffix(string[] strings, string suffix) \n{\n    string[] result\
    \ = new string[0];\n    for (int i = 0; i < strings.length; i++){\n        if\
    \ (strings[i].EndsWith(suffix)){\n            result += strings[i];\n        }\n\
    \    }\n    return result;\n}\n/*\n Filter an input array of strings only for\
    \ ones that contain a given substring.\n    >>> filter_by_substring([], \"c\"\
    )\n    []\n    >>> filter_by_substring([\"abc\", \"bcd\", \"cde\", \"array\"],\
    \ \"c\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result = new string[0];\n    for\
    \ (int i = 0; i < strings.length; i++){\n        if (strings[i].Contains(substring)){\n\
    \            result += strings[i];\n        }\n    }\n    return result;\n}\n\
    /*\n Remove all empty strings from an array of strings.\n    >>> remove_empty([])\n\
    \    []\n    >>> remove_empty([\"a\", \"\", \"\", \"b\"])\n    [\"a\", \"b\"]\n\
    \    \n*/\nstring[] remove_empty(string[] strings) \n{\n    List<string> result\
    \ = new List<string>();\n    for (int i = 0; i < strings.length; i++){\n     \
    \   if (strings[i] != \"\"){\n            result += strings[i];\n        }\n \
    \   }\n    return result.toArray();\n}\n/*\n Remove all instances of a string\
    \ from an array of strings.\n    >>> remove_instance([], \"a\")\n    []\n    >>>\
    \ remove_instance([\"a\", \"b\", \"c\"], \"a\")\n    [\"b\", \"c\"]\n    \n*/\n\
    string[] remove_instance(string[] strings, string instance) \n{\n    List<string>\
    \ result = new List<string>();\n    for (int i = 0; i < strings.length; i++){\n\
    \        if (strings[i] != instance){\n            result += strings[i];\n   \
    \     }\n    }\n    return result.toArray();\n}\n/*\n Remove all instances of\
    \ a set of strings from an array of strings.\n    >>> remove_instances([], \"\
    a\")\n    []\n    >>> remove_instances([\"a\", \"b\", \"c\"], \"a\")\n    [\"\
    b\", \"c\"]\n    \n*/\nstring[] remove_instances(string[] strings, string[] instances)\
    \ \n{\n    List<string> result = new List<string>();\n    for (int i = 0; i <\
    \ strings.length", "{\n\tint n = strings.length;\n\tint i = 0;\n\t\n\twhile (i\
    \ < n) {\n\t\tif (strings[i].startsWith(prefix)) {\n\t\t\tstrings[i - n] = strings[i];\n\
    \t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn strings;\n}", "{\n\tint i;\n\t\
    string[] res = new string[strings.length];\n\tfor(i = 0; i < strings.length; ++i)\n\
    \t{\n\t\tif(strings[i].startsWith(prefix))\n\t\t{\n\t\t\tres[i] = strings[i];\n\
    \t\t}\n\t}\n\treturn res;\n}\n/*\n Filter an input array of strings only for ones\
    \ that start with a given prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n\
    \    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n   \
    \ [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_prefix(string[] strings,\
    \ string prefix, int start, int end) \n{\n\tint i;\n\tstring[] res = new string[strings.length];\n\
    \tfor(i = 0; i < strings.length; ++i)\n\t{\n\t\tif(strings[i].startsWith(prefix,\
    \ start, end))\n\t\t{\n\t\t\tres[i] = strings[i];\n\t\t}\n\t}\n\treturn res;\n\
    }\n/*\n Filter an input array of strings only for ones that start with a given\
    \ prefix and have some suffix after it.\n    >>> filter_by_prefix([], \"a\")\n\
    \    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\"\
    )\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_prefix(string[] strings,\
    \ string prefix, int start, int end, int suffix_length) \n{\n\tint i;\n\tstring[]\
    \ res = new string[strings.length];\n\tfor(i = 0; i < strings.length; ++i)\n\t\
    {\n\t\tif(strings[i].startsWith(prefix, start, end, suffix_length))\n\t\t{\n\t\
    \t\tres[i] = strings[i];\n\t\t}\n\t}\n\treturn res;\n}\n/*\n Filter an input array\
    \ of strings only for ones that start with a given prefix and have some suffix\
    \ after it.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n\
    */\nstring[] filter_by_prefix(string[] strings, string prefix, int start, int\
    \ end, int suffix_length, bool caseSensitive) \n{\n\tint i;\n\tstring[] res =\
    \ new string[strings.length];\n\tfor(i = 0; i < strings.length; ++i)\n\t{\n\t\t\
    if(strings[i].startsWith(prefix, start, end, suffix_length, caseSensitive))\n\t\
    \t{\n\t\t\tres[i] = strings[i];\n\t\t}\n\t}\n\treturn res;\n}\n/*\n Filter an\
    \ input array of strings only for ones that start with a given prefix and have\
    \ some suffix after it.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>>\
    \ filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc",
  "{\n    int idx = strings.length - 1;\n    while (idx >= 0) {\n        if (strings[idx].StartsWith(prefix))\
    \ {\n            return strings[idx].Substring(1)\n        }\n        idx -= 1;\n\
    \    }\n    return strings;\n}\n</code>\n<|/ a tags=c# |>\n<| a dscore=3 tags=c#\
    \ |>\n<code>\nstatic string[] RemoveDuplicates(string[] source)\n{\n    var seen\
    \ = new HashSet<string>();\n    return source.Where(s => !seen.Add(s)).ToArray();\n\
    }\n</code>\n<|/ a |>\n<| a tags=c# |>\nFor those who are still using C# 3.5:\n\
    <code>\nstring[] stringsToRemove = new string[]\n{\n    \"someString1\",\n   \
    \ \"someString2\",\n    \"someString3\"\n};", "{\n    int index = 0;\n    string\
    \ last = \"\";\n    while (strings[index] != null)\n    {\n        if (strings[index].StartsWith(prefix))\n\
    \        {\n            last = strings[index];\n        }\n        index++;\n\
    \    }\n    strings = strings.Where(s => s.StartsWith(prefix)).ToArray();\n  \
    \  strings[strings.length - 1] = last;\n    return strings;\n}\n</code>\nThe usage\
    \ would be:\n<code>\nstring prefix = \"a\";\nstring[] array = { \"a\", \"b\",\
    \ \"c\", \"d\", \"e\", \"array\" };\nstring[] filteredArray = filter_by_prefix(array,\
    \ prefix);\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhy would you suggest the use\
    \ of `StringBuilder` rather than concatenation? `Append` doesn't have to allocate\
    \ memory for all the intermediate strings.\n<|/ c |>\n<| c |>\n`Append` is slower\
    \ than `+=`. [Check this answer to see the difference between them](https://stackoverflow.com/a/375938/107625),\
    \ but for concatenation, `StringBuilder` is faster.\n<|/ c |>\n<| c |>\nHow do\
    \ you know that concatenation is faster than string concatenation? `StringBuilder`\
    \ is optimized for appending string in one shot.\n<|/ c |>\n<| c |>\nI did not\
    \ say that concatenation was faster than string concatenation. My point is that\
    \ using `Append` when working with strings is not faster than using it when working\
    \ with arrays (like your solution), since `Append` is basically calling a `.ToArray()`\
    \ on each element.\n<|/ c |>\n<| c |>\nWell, that's just an assumption. If concatenating\
    \ is expensive, `StringBuilder` will be, while `string` will be slower, and `Append`\
    \ will be faster. Concatenation will be cheaper in `StringBuilder`, but `Append`\
    \ will be cheaper in `string`, which makes no sense. I can see that `Append` is\
    \ cheaper than `+=`, but that makes no sense as well.\n<|/ c |>\n<| a dscore=1\
    \ |>\nOne more simple solution:\n<code>\nfunction filterByPrefix(array, prefix){\n\
    \  return array.filter(e => e.startsWith(prefix));\n}\n</code>\n<|/ a tags=c#,arrays\
    \ |>\n<| c |>\nThis will not return an array with those strings (`[]`).\n<|/ c\
    \ |>\n<| a dscore=1 |>\nHere's another solution that doesn't use LINQ (although\
    \ it's very close to that):\n<code>\npublic static class ArrayExtensions\n{\n",
  "{\n    // write your function here!\n    return null;\n}\n</cell>\n<text>\nExercise\
    \ 4\nIn the following cell, implement a function that filters an array of strings\
    \ for ones that end with a given suffix.", "{\n    foreach (string s in strings)\
    \ {\n        if (s.StartsWith(prefix)) {\n            yield return s;\n      \
    \  }\n    }\n}", "{\n\tint i = 0;\n\twhile(strings[i] != null) {\n\t\tif(strings[i].length\
    \ == prefix.length && strings[i].substring(0, prefix.length) == prefix) {\n\t\t\
    \ti++;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn strings;\n}\n/* \n Extract\
    \ and split a string at the specified delimiter.  \n \n    >>> \"a,b,c\".split(\"\
    ,\")\n    [\"a\", \"b\", \"c\"]\n    \n*/\nString[] split(String string, String\
    \ delimiter)\n{\n\tString[] splitArray = new String[1000];\n\tfor(int i = 0; i\
    \ < splitArray.length; i++) {\n\t\tsplitArray[i] = string.substring(i, i+delimiter.length());\n\
    \t}\n\treturn splitArray;\n}\n/* \n Find all matches of str in strArray\n \n Returns\
    \ array of all matches of str in strArray.  ", "{\n\tvar list = new List<string>();\n\
    \tforeach (var s in strings)\n\t{\n\t\tif (s.StartsWith(prefix))\n\t\t\tlist.Add(s);\n\
    \t}\n\treturn list.ToArray();\n}", "{\n    int[] arr = new int[strings.length];\n\
    \    Arrays.setAll(arr, i => i < strings.length && strings[i].startsWith(prefix));\n\
    \    return strings[arr];\n}\n// end Filter an input array of strings only for\
    \ ones that start with a given prefix.", "{\n  foreach (string s in strings) {\n\
    \    if (!s.StartsWith(prefix)) {\n      continue;\n    }\n    \n    string result\
    \ = s;\n    \n    for (int i = 0; i < prefix.length; i++) {\n      result += s[i];\n\
    \    }\n    \n    string[] rest = filter_by_prefix(strings, result);\n    \n \
    \   if (rest.Length > 0) {\n      yield return result;\n    }\n  }\n  \n  // We\
    \ don't yield any results because we didn't find any!\n}\n</code>\nNow we can\
    \ write a little test:\n<code>", "{\n  int i;\n  for (i = 0; i < strings.length;\
    \ ++i) {\n    if (strings[i].StartsWith(prefix)) {\n      return strings[i];\n\
    \    }\n  }\n  return strings[strings.length-1];\n}\n</cell>\n<text>\nExercise\
    \ 5\nWrite a function is_odd(number) that returns true if number is odd, false\
    \ otherwise. Test it on every integer from 0 to 20.", "{\n    size_t pos = 0;\n\
    \    for (size_t i = 0; i < strings.length; ++i)\n        if (strings[i].substr(0,\
    \ prefix.length) == prefix)\n            strings[i] = strings[i].substr(prefix.length);\n\
    \    return strings;\n}\n/*\n Filter an input array of strings only for ones that\
    \ end with a given suffix.\n    >>> filter_by_suffix([], \"a\")\n    []\n    >>>\
    \ filter_by_suffix([\"abc\", \"bcd\", \"cde\"], \"d\")\n    [\"abc\", \"bcd\"\
    ]\n    \n*/\nstring[] filter_by_suffix(string[] strings, string suffix) \n{\n\
    \    size_t pos = strings.length - 1;\n    for (size_t i = 0; i < strings.length;\
    \ ++i)\n        if (strings[i].substr(strings[i].length - suffix.length, suffix.length)\
    \ == suffix)\n            strings[i] = strings[i].substr(0, strings[i].length\
    \ - suffix.length);\n    return strings;\n}", "{\n    string[] result = new string[strings.length];\n\
    \    int i = 0;\n    foreach (string s in strings) {\n        if (s.StartsWith(prefix))\n\
    \            result[i++] = s;\n    }\n    return result;\n}\n</code>\n<|/ a tags=.net,c#,algorithm\
    \ dscore=3 |>\n<| c |>\nthank you.  I actually had to change the code a little\
    \ bit to get it working (my original question was misleading, but I updated it\
    \ with the changes I needed to make).  This answer was great to see it solved\
    \ my problem and help someone else who was having a similar issue.\n<|/ c |>\n\
    <| c |>\nAwesome, glad it helped! I learned something from this code snippet as\
    \ well!\n<|/ c |>\n<| c |>\nIn case anyone else is wondering where I got this\
    \ algorithm from - it was from http://www.codeproject.com/KB/cs/FilterList.aspx\
    \ - I used their method of using a list as your \"set\" (which is what I was trying\
    \ to do initially), and their method of searching through each string in the list\
    \ to see if it started with a specific prefix.\n<|/ c |>\n<| a tags=.net,c#,algorithm\
    \ |>\n<code>\n        using System;\n        using System.Collections.Generic;\n\
    \        using System.Linq;", "{\n    string[] result = new string[strings.length];\n\
    \    for(int i = 0; i < strings.length; i++){\n        if(strings[i].StartsWith(prefix))\n\
    \            result[i] = strings[i];\n    }\n    return result;\n}\n/*\n Filter\
    \ an input array of strings only for ones that end with a given suffix.\n    >>>\
    \ filter_by_suffix([], \"a\")\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\"\
    , \"cde\", \"array\"], \"a\")\n    [\"abc\"]\n    \n*/\nstring[] filter_by_suffix(string[]\
    \ strings, string suffix) \n{\n    string[] result = new string[strings.length];\n\
    \    for(int i = 0; i < strings.length; i++){\n        if(strings[i].EndsWith(suffix))\n\
    \            result[i] = strings[i];\n    }\n    return result;\n}\n/*\n Filter\
    \ an input array of strings only for ones that contain a given substring.\n  \
    \  >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"b\")\n    []\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string substring) \n{\n    string[] result = new string[strings.length];\n\
    \    for(int i = 0; i < strings.length; i++){\n        if(strings[i].Contains(substring))\n\
    \            result[i] = strings[i];\n    }\n    return result;\n}\n/*\n Filter\
    \ an input array of strings only for ones that are all uppercase.\n    >>> filter_by_upper([])\n\
    \    []\n    >>> filter_by_upper([\"abc\", \"bcd\", \"cde\", \"array\"])\n   \
    \ [\"ABC\", \"ARRAY\"]\n    \n*/\nstring[] filter_by_upper(string[] strings)\n\
    {\n    string[] result = new string[strings.length];\n    for(int i = 0; i < strings.length;\
    \ i++){\n        if(Char.IsUpper(strings[i]))\n            result[i] = strings[i];\n\
    \    }\n    return result;\n}\n/*\n Filter an input array of strings only for\
    \ ones that are all lowercase.\n    >>> filter_by_lower([])\n    []\n    >>> filter_by_lower([\"\
    abc\", \"bcd\", \"cde\", \"array\"])\n    [\"abc\", \"bcd\", \"cde\"]\n    \n\
    */\nstring[] filter_by_lower(string[] strings)\n{\n    string[] result = new string[strings.length];\n\
    \    for(int i = 0; i < strings.length; i++){\n        if(Char.IsLower(strings[i]))\n\
    \            result[i] = strings[i];\n    }\n    return result;\n}\n/*\n Filter\
    \ an input array of strings only for ones that are all digit.\n    >>> filter_by_digit([])\n\
    \    []\n    >>> filter_by_digit([\"abc\", \"bcd\", \"cde\", \"array\"])\n   \
    \ [\"ab\", \"cd\", \"de\"]\n    \n*/", "{\n    for(int i = 0; i < strings.length;\
    \ i++)\n    {\n        if(strings[i].StartsWith(prefix))\n        {\n        \
    \    strings[i] = strings[i].Substring(prefix.length);\n            break;\n \
    \       }\n    }", "{\n  if(!std.typecons.isstring(prefix))\n    throw Error(\"\
    prefix is not a string\");\n  int index = 0;\n  int last = 0;\n  while(index <\
    \ strings.length)\n  {\n    string s = strings[index];\n    if(!std.typecons.isstring(s))\n\
    \      throw Error(\"elements are not strings\");\n    string p = s;\n    if(std.typecons.prefixof(prefix,\
    \ p) == 0)\n    {\n      last = index;\n    }\n    index++;\n  }\n  strings[last]\
    \ = \"\";\n  return strings;\n}\n/*\n Filter an input array of strings only for\
    \ ones that end with a given suffix.\n    >>> filter_by_suffix([], \"a\")\n  \
    \  []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\"\
    )\n    [\"abc\"]\n    \n*/\nstring[] filter_by_suffix(string[] strings, string\
    \ suffix) \n{\n  if(!std.typecons.isstring(suffix))\n    throw Error(\"suffix\
    \ is not a string\");\n  int index = 0;\n  int last = 0;\n  while(index < strings.length)\n\
    \  {\n    string s = strings[index];\n    if(!std.typecons.isstring(s))\n    \
    \  throw Error(\"elements are not strings\");\n    string p = s;\n    if(std.typecons.suffixof(suffix,\
    \ p) == 0)\n    {\n      last = index;\n    }\n    index++;\n  }\n  strings[last]\
    \ = \"\";\n  return strings;\n}\n/*\n Filter an input array of strings only for\
    \ the ones that match a given regex.\n    >>> filter_by_regex([], \"/abc/i\")\n\
    \    []\n    >>> filter_by_regex([\"abc\", \"bcd\", \"cde\", \"array\"], \"/abc/i\"\
    )\n    [\"abc\"]\n    \n*/\nstring[] filter_by_regex(string[] strings, string\
    \ regex) \n{\n  if(!std.typecons.isstring(regex))\n    throw Error(\"regex is\
    \ not a string\");\n  int index = 0;\n  int last = 0;\n  while(index < strings.length)\n\
    \  {\n    string s = strings[index];\n    if(!std.typecons.isstring(s))\n    \
    \  throw Error(\"elements are not strings\");\n    string p = s;\n    if(!std.regex.match(regex,\
    \ p))\n    {\n      last = index;\n    }\n    index++;\n  }\n  strings[last] =\
    \ \"\";\n  return strings;\n}\n/*\n Sort an array of strings by length, from long\
    \ to short.\n    >>>sort_by_length([])\n    []\n    >>> sort_by_length([\"c\"\
    , \"a\", \"b\", \"x\"])\n    [\"a\", \"b\", \"c\", \"x\"]\n    \n*/", "{\n\tint\
    \ pos = 0;\n\tint len = strings.length;\n\twhile (pos < len)\n\t{\n\t\tif (strings[pos].startsWith(prefix))\n\
    \t\t{\n\t\t\tstrings[pos] = strings[pos].substring(prefix.length());\n\t\t}\n\t\
    \telse\n\t\t{\n\t\t\tpos++;\n\t\t}\n\t}\n\treturn strings;\n}", "{\n    var result\
    \ = new string[strings.length];\n    for(int i = 0; i < strings.length; ++i) {\n\
    \        if(strings[i].StartsWith(prefix))\n            result[i] = strings[i];\n\
    \    }\n    return result;\n}", "{\n    for(int i = 0; i < strings.length; ++i)\n\
    \    {\n        if (strings[i].StartsWith(prefix))\n        {\n            yield\
    \ return strings[i];\n        }\n    }\n}\n/*\n Filter an input array of strings\
    \ only for ones that end with a given suffix.\n    >>> filter_by_suffix([], \"\
    a\")\n    []\n    >>> filter_by_suffix([\"abca\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abca\"]\n    \n*/\nstring[] filter_by_suffix(string[] strings,\
    \ string suffix) \n{\n    for(int i = 0; i < strings.length; ++i)\n    {\n   \
    \     if (strings[i].EndsWith(suffix))\n        {\n            yield return strings[i];\n\
    \        }\n    }\n}", "{\n\t// Return early if there are no strings to process\n\
    \tif (strings.length == 0)\n\t\treturn strings;\n\t\n\t// Get the length of the\
    \ prefix we're looking for\n\tint prefixLength = prefix.length;\n\t\n\t// If there\
    \ are no characters in the prefix, return the string unmodified\n\tif (prefixLength\
    \ == 0)\n\t\treturn strings;\n\t\n\t// Create an empty array for the output strings\n\
    \tstring[] output = new string[strings.length];\n\t\n\t// Iterate through the\
    \ input strings, and for each string add it to the output array if the string\
    \ starts with the prefix\n\tfor (int i = 0; i < strings.length; i++)\n\t{\n\t\t\
    if (strings[i].startsWith(prefix))\n\t\t\toutput[output.length-1] = strings[i];\n\
    \t}\n\t\n\t// Return the output array\n\treturn output;\n}", "{\n    // TODO Optimize\
    \ this, because this function is quite inefficient.\n    for(int i = 0; i < strings.length;\
    \ i++)\n    {\n        if(strings[i].StartsWith(prefix))\n        {\n        \
    \    strings[i] = strings[i].Substring(prefix.length);\n            break;\n \
    \       }\n    }\n    return strings;\n}\n/*\n Filter an input array of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ \"a\")\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\", \"array\"]\n    \n*/\nstring filter_by_prefix(string\
    \ strings, string prefix) \n{\n    // TODO Optimize this, because this function\
    \ is quite inefficient.\n    for(int i = 0; i < strings.length; i++)\n    {\n\
    \        if(strings[i].StartsWith(prefix))\n        {\n            strings[i]\
    \ = strings[i].Substring(prefix.length);\n            break;\n        }\n    }\n\
    \    return strings;\n}", "{\n    if (strings == null) {\n        strings = new\
    \ string[0];\n    }\n    \n    string prefix = prefix + \".\";\n    \n    var\
    \ newStrings = new string[strings.length];\n    for (int i = 0; i < strings.length;\
    \ ++i) {\n        if (strings[i].StartsWith(prefix)) {\n            newStrings[newStrings.Length-1]\
    \ += strings[i];\n        } else {\n            newStrings[i] = strings[i];\n\
    \        }\n    }\n    return newStrings;\n}\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ dscore=1 tags=algorithm,arrays,c# |>\nI tried to solve it in C#:\n<code>\nstatic\
    \ void Main(string[] args)\n{\n    string[] source = new string[] { \"A\", \"\
    B\", \"C\", \"D\", \"E\", \"F\" };\n    string[] result = new string[source.Length];\n\
    \    int lastIndex = 0;\n    int lastIndex2 = source.Length - 1;\n    while (lastIndex2\
    \ >= 0)\n    {\n        if (source[lastIndex2].StartsWith(\"A\"))\n        {\n\
    \            source[lastIndex2++] = \"\";\n        }\n        else if (source[lastIndex2].StartsWith(\"\
    B\"))\n        {\n            source[lastIndex2--] = \"\";\n        }\n      \
    \  else\n        {\n            lastIndex2 = lastIndex;\n            lastIndex\
    \ = lastIndex2;\n        }\n    }\n    result.CopyTo(source, 0);\n}\n</code>\n\
    <|/ a |>\n<| a tags=algorithm,arrays,c# |>\n<code>\nvar array = new string[] {\
    \ \"AA\", \"BB\", \"CC\", \"DD\", \"EE\", \"FF\", \"GG\", \"HG\", \"II\", \"JJ\"\
    , \"KK\", \"LL\", \"MM\", \"NN\", \"OO\", \"PP\", \"QQ\", \"RR\", \"SS\", \"TT\"\
    , \"WW\", \"XX\", \"YY\", \"ZZ\" };\nvar result = new List<string>(array.Where(i\
    \ => i.StartsWith(\"A\")).Count());\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI do\
    \ not want to create a new list of string I want to return a new array with the\
    \ filtered values\n<|/ c |>\n<| c |>\n`var result = array.Where(i => i.StartsWith(\"\
    A\")).ToArray();`\n<|/ c |>\n<| c |>\nI do not want to create a new list of string\
    \ I want to return a new array with the filtered values\n<|/ c |>\n<| c |>\n`var\
    \ result = array.Where(i => i.StartsWith(\"A\")).ToArray();` will return an array\
    \ with all the items that start with a \"A\". Now you can do whatever you want\
    \ with that array: remove duplicates, keep only the first \"A\", etc.\n<|/ c |>\n\
    <| c |>\nI ", "{\n    string[] result = [];\n    for (string s : strings) {\n\
    \        if (s.StartsWith(prefix)) {\n            result.Add(s);\n        }\n\
    \    }\n    return result;\n}", "{\n    string[] result;\n    for (int i = 0;\
    \ i < strings.length; i++) \n    {\n        if (strings[i].StartsWith(prefix))\
    \ \n        {\n            result.Add(strings[i]);\n        }\n    }\n    return\
    \ result;\n}\n/*\n Filter an input array of strings only for ones that end with\
    \ a given suffix.\n    >>> filter_by_suffix([], \"a\")\n    []\n    >>> filter_by_suffix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"d\")\n    [\"bcd\", \"cde\"]\n    \n*/\n\
    string[] filter_by_suffix(string[] strings, string suffix) \n{\n    string[] result;\n\
    \    for (int i = 0; i < strings.length; i++) \n    {\n        if (strings[i].EndsWith(suffix))\
    \ \n        {\n            result.Add(strings[i]);\n        }\n    }\n    return\
    \ result;\n}\n/*\n Filter an input array of strings only for ones that contain\
    \ a given prefix.\n    >>> filter_by_substring([], \"a\")\n    []\n    >>> filter_by_substring([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"abc\")\n    [\"abc\"]\n    \n*/\nstring[]\
    \ filter_by_substring(string[] strings, string substring) \n{\n    string[] result;\n\
    \    for (int i = 0; i < strings.length; i++) \n    {\n        if (strings[i].Contains(substring))\
    \ \n        {\n            result.Add(strings[i]);\n        }\n    }\n    return\
    \ result;\n}\n/*\n Filter an input array of strings only for ones that contain\
    \ a given suffix.\n    >>> filter_by_substring2([], \"a\")\n    []\n    >>> filter_by_substring2([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"c\")\n    [\"abc\", \"bcd\"]\n    \n*/\n\
    string[] filter_by_substring2(string[] strings, string substring) \n{\n    string[]\
    \ result;\n    for (int i = 0; i < strings.length; i++) \n    {\n        if (strings[i].EndsWith(substring))\
    \ \n        {\n            result.Add(strings[i]);\n        }\n    }\n    return\
    \ result;\n}\n/*\n Remove an input array of strings only for ones that start with\
    \ a given prefix.\n    >>> remove_prefix([], \"a\")\n    []\n    >>> remove_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"bcd\", \"cde\", \"array\"\
    ]\n    \n*/\nstring[] remove_prefix(string[] strings, string prefix) \n{\n   \
    \ string[] result;\n    for (int i = 0; i < strings.length; i++) \n    {\n   \
    \     if (!strings[i].StartsWith(prefix)) \n        {\n            result.Add(strings[i]);\n\
    \        }\n    }\n    return result;\n}\n/*\n Remove an input array of strings\
    \ only for ones that end with a given suffix.\n    >>> remove_suffix([], \"a\"\
    )\n    []\n    >>> remove_suffix([\"abc\", \"bcd\", \"cde", "{\n    string[] result\
    \ = new string[strings.length];\n    for(int i = 0; i < strings.length; ++i) {\n\
    \        if(strings[i].StartsWith(prefix)) \n            result[i] = strings[i];\n\
    \    }\n    return result;\n}", "{\n    string[] newStrings = strings.filter(s\
    \ => s.startsWith(prefix));\n    return newStrings;\n}", "{\n    string[] result\
    \ = new string[strings.length];\n    int i = 0;\n    for (;i < strings.length;\
    \ ++i) {\n        if (strings[i].startsWith(prefix)) {\n            result[i]\
    \ = strings[i];\n        }\n    }\n    return result;\n}\n/*\n Filter an input\
    \ array of strings only for ones that end with a given suffix.\n    >>> filter_by_suffix([],\
    \ \"e\")\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"e\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_suffix(string[]\
    \ strings, string suffix) \n{\n    string[] result = new string[strings.length];\n\
    \    int i = 0;\n    for (;i < strings.length; ++i) {\n        if (strings[i].endsWith(suffix))\
    \ {\n            result[i] = strings[i];\n        }\n    }\n    return result;\n\
    }", "{\n    foreach(string|string str in strings) {\n        if(str.startsWith(prefix))\
    \ {\n            yield str;\n        }\n    }\n}", "{\n    Arrays.sort(strings);\n\
    \    bool match = false;\n    foreach (string s in strings) {\n        if (s.StartsWith(prefix))\
    \ {\n            match = true;\n            break;\n        }\n    }\n    return\
    \ match ? strings.Where((s) => s.StartsWith(prefix)).ToArray() : new string[]\
    \ { };\n}\n</code>\n<|/ a tags=c#,arrays,string,linq,prefix |>\n<| a tags=c#,arrays,string,linq,prefix\
    \ dscore=0 |>\nIf you're looking for a case insensitive prefix match, I suggest\
    \ you use:\n<code>\nstring prefix = words[wordIndex].StartsWith(prefixToMatch,\
    \ StringComparison.OrdinalIgnoreCase)\n</code>\n<|/ a |>\n<| c |>\nIf you're going\
    \ to suggest using a case insensitive comparison you should probably also give\
    \ a more detailed explanation.\n<|/ c |>\n<| a |>\nUsing Linq you can easily get\
    \ the prefix matches as follows:\n<code>\nvar prefixes = from word in words\n\
    \                where word.StartsWith(prefix)\n                select word;\n\
    </code>\nThe above will return all words in the words collection starting with\
    \ the prefix. You can then get all words by using a Where clause:\n<code>\nvar\
    \ matches = from word in words\n              where word.StartsWith(prefix)\n\
    \              select word;\n</code>\nAnd then you can simply convert the enumerable\
    \ to an array as follows:\n<code>\nvar prefixMatchesArray = prefixes.ToArray();\n\
    </code>\n<|/ a tags=c#,arrays,string,linq,prefix dscore=0 |>\n<| a |>\nIf you're\
    \ looking for case-insensitive prefix match, you can try using the String.StartsWith(StringComparison.OrdinalIgnoreCase)\
    \ overload which takes StringComparison enum to specify how the comparison should\
    \ be performed.\n<|/ a tags=c#,arrays,string,linq,prefix dscore=0 |>\n<| a dscore=0\
    \ |>\nI think this is what you want.\n<code>\nstring[] words = new string[] {\
    \ \"abc\", \"abcd\", \"abcde\" };\nstring prefix = \"ab\";\nvar results = words.Where(x\
    \ => x.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))\n             \
    \      .Select(x => x);\n</code>\n<|/ a tags=c#,arrays,string,linq,prefix |>\n\
    <| a tags=c#,arrays,string,linq,prefix dscore=0 |>\nTry this (Linq).\n<code>\n\
    var words = new string[] { \"abc\", \"abcd\", \"abcde\" };\nstring prefix = \"\
    ab\";\nvar results = words.Where(x => x.Star", "{\n\tstring[] result = new string[0];\n\
    \tforeach(string[] s in strings)\n\t\tif (s.StartsWith(prefix))\n\t\t\tresult\
    \ = append(result, s);\n\treturn result;\n}", "{\n  \n  return filter(strings,\
    \ (string s) => s.startsWith(prefix));\n}", "{\n  if(prefix == \"\") return strings;\n\
    \  var re = new RegExp('^'+prefix);\n  return strings.filter(function(s) { return\
    \ re.test(s); });\n}", "{\n    int index = 0;\n    int i = 0;\n    int count =\
    \ 0;\n    string[] result = new string[strings.length];\n    while (index < strings.length\
    \ && i < strings[index].length()) {\n        if (strings[index].charAt(i) == prefix.charAt(0))\
    \ {\n            count++;\n        }\n        i++;\n    }\n    while (index <\
    \ strings.length && i < strings[index].length()) {\n        if (strings[index].charAt(i)\
    \ != prefix.charAt(0)) {\n            result[index] = strings[index];\n      \
    \  }\n        i++;\n        index++;\n    }\n    while (i < strings[index].length())\
    \ {\n        result[index] = strings[index];\n        index++;\n        i++;\n\
    \    }\n    while (index < strings.length) {\n        result[index] = strings[index];\n\
    \        index++;\n    }\n    return result;\n}", "{\n    foreach(string)strings\
    \ as string {\n        if (string.startsWith(prefix)) {\n            yield return\
    \ string;\n        }\n    }\n}\n</code>\n<|/ a tags=c#,optimization,arrays |>\n\
    <| a |>\nThe best way I've found so far to filter an array by another array is\
    \ to use the .Contains method:\n<code>\nstring[] stringsToCheck = { \"a\", \"\
    b\", \"c\" };\nstring[] stringsToCheckAgainst = { \"a\", \"c\" };", "{\n    string[]\
    \ ret = new string[strings.length];\n    int i = 0;\n    for (string s : strings)\
    \ {\n        if (s.StartsWith(prefix)) {\n            ret[i] = s;\n          \
    \  ++i;\n        }\n    }\n    return ret;\n}\n</code>\n<|/ a tags=c#,arrays |>\n\
    <| a |>\nThe solution is quite simple\n<code>\npublic static string[] FilterByPrefix(this\
    \ string[] input, string prefix)\n{\n    if (input != null && prefix != null)\n\
    \    {\n        return input.Where(s => s.StartsWith(prefix)).ToArray();\n   \
    \ }\n    return null;\n}\n</code>\n<|/ a dscore=5 tags=c#,arrays |>\n<| c |>\n\
    You don't need to check if the array is null before calling the `Where` method,\
    \ because the `Where` method is a static method and doesn't throw any exception\
    \ if the source array is null.\n<|/ c |>\n<| c |>\n`input.Where(s => s.StartsWith(prefix)).ToArray()`\
    \ will throw an exception if `input` is null (`Where` will throw an `ArgumentNullException`).\
    \ To avoid this you should do `input.Where(s => s.StartsWith(prefix)).ToArray()??\
    \ new string[0];`\n<|/ c |>\n<| c |>\nGood point. I guess the best solution is\
    \ to just check for null before calling the extension method and throw an exception\
    \ yourself.\n<|/ c |>\n<| a tags=c#,arrays |>\n<code>\nvar newArray = oldArray.Where(x\
    \ => x.StartsWith(\"somestring\")).ToArray();\n</code>\n<|/ a dscore=5 |>\n<|\
    \ c |>\nWhy not use `ToArray()` before `Where`?\n<|/ c |>\n<| a dscore=4 |>\n\
    <code>\npublic static string[] FilterByPrefix(this string[] input, string prefix)\n\
    {\n    List<string> ret = new List<string>();\n    foreach(string s in input)\n\
    \    {\n        if (s.StartsWith(prefix))\n        {\n            ret.Add(s);\n\
    \        }\n    }\n    return ret.ToArray();\n}\n</code>\n<|/ a tags=c#,arrays\
    \ |>\n<| a |>\n<code>\nstring[] result = new string[oldArray.Length];", "{\n \
    \   if (strings.length == 0) return strings;\n    \n    // search the first string\
    \ in the array that does not start with the prefix\n    int i = strings.length\
    \ - 1;\n    while (i >= 0 && strings[i].startsWith(prefix))\n    {\n        i--;\n\
    \    }\n    \n    // if no prefix matched, return all strings\n    if (i < 0)\
    \ return strings;", "{\n    if (strings.length == 0) return strings;\n    if (strings[0].length\
    \ <= prefix.length) return strings;\n    \n    int low = 0;\n    int high = strings.length\
    \ - 1;\n    string middle = strings[high];\n    bool found = false;\n    \n  \
    \  while (low <= high && middle == prefix[low]) low++;\n    while (low <= high\
    \ && middle != prefix[low]) low++;\n    while (low <= high && middle == prefix[low])\
    \ low++;\n    while (low <= high && middle != prefix[low]) low++;\n    \n    while\
    \ (low <= high && middle != prefix[low]) low++;\n    \n    while (low <= high\
    \ && middle == prefix[low]) low++;\n    \n    while (low <= high && middle !=\
    \ prefix[low]) low++;\n    \n    while (low <= high && middle == prefix[low])\
    \ low++;\n    \n    while (low <= high && middle != prefix[low]) low++;\n    \n\
    \    while (low <= high && middle == prefix[low]) low++;\n    \n    while (low\
    \ <= high && middle != prefix[low]) low++;\n    \n    while (low <= high && middle\
    \ == prefix[low]) low++;\n    \n    while (low <= high && middle != prefix[low])\
    \ low++;\n    \n    while (low <= high && middle == prefix[low]) low++;\n    \n\
    \    while (low <= high && middle != prefix[low]) low++;\n    \n    while (low\
    \ <= high && middle == prefix[low]) low++;\n    \n    while (low <= high && middle\
    \ != prefix[low]) low++;\n    \n    while (low <= high && middle == prefix[low])\
    \ low++;\n    \n    while (low <= high && middle != prefix[low]) low++;\n    \n\
    \    while (low <= high && middle == prefix[low]) low++;\n    \n    while (low\
    \ <= high && middle != prefix[low]) low++;\n    \n    while (low <= high && middle\
    \ == prefix[low]) low++;\n    \n    while (low <= high && middle != prefix[low])\
    \ low++;\n    \n    while (low <= high && middle == prefix[low]) low++;\n    \n\
    \    while (low <= high && middle != prefix[low]) low++;\n    \n    while (low\
    \ <= high && middle == prefix[low]) low++;\n    \n    while (low <= high && middle\
    \ != prefix[low]) low++;\n    \n    while (low <= high && middle == prefix[low])\
    \ low++;\n    \n    while (low <= high && middle != prefix[low]) low++;\n    \n\
    \    while (low ", "{\n\tList<string> result = new List<string>();\n\t\n\tforeach\
    \ (string s in strings)\n\t{\n\t\tif (string.Compare(prefix, s, true) == 0)\n\t\
    \t{\n\t\t\tresult.Add(s);\n\t\t}\n\t}\n\t\n\treturn result.ToArray();\n}", "{\n\
    \    string[] result = new string[strings.length];\n    int i = 0;\n    for(i\
    \ = 0; i<strings.length; i++)\n        if(strings[i].StartsWith(prefix))\n   \
    \         result[i++] = strings[i];\n    return result;\n}\n</code>\n<|/ a tags=algorithm,c#\
    \ |>\n<| a dscore=2 |>\nUsing Linq's GroupBy:\n<code>\nstring[] originalArray\
    \ = new string[] { \"abc\", \"bcd\", \"cde\", \"array\", \"def\", \"ghi\", \"\
    jkl\" };\nvar filtered = originalArray.GroupBy(x => x.StartsWith(\"a\")).Select(x\
    \ => x.First()).ToArray();\n</code>\n<|/ a tags=algorithm,c# |>\n<| a tags=algorithm,c#\
    \ |>\nHere's a solution that takes advantage of the fact that the length of the\
    \ filtered set is the same as the length of the original set and does not require\
    \ any extra memory.\nIt also avoids having to use a dictionary at all.\n<code>\n\
    var originalArray = new string[] { \"abc\", \"bcd\", \"cde\", \"array\", \"def\"\
    , \"ghi\", \"jkl\" };\nvar filteredArray = originalArray\n    .Select(s => new\
    \ { s = s, first = s.FirstOrDefault() })\n    .Where(x => x.first != null)\n \
    \   .Select(x => x.first)\n    .ToArray();\n</code>\nThis uses the fact that FirstOrDefault()\
    \ will return null if the value is not present in the original array, which makes\
    \ it possible to use the conditional operator in Where() to only select those\
    \ elements which do have a first value.\n<|/ a dscore=1 |>\n<| c |>\nIt also doesn't\
    \ require any extra memory. Your solution creates three new `string[]` objects\
    \ `originalArray`, `s` and `first`. The original array and the array returned\
    \ by the `Select` call are never discarded. The `Where` call also creates a new\
    \ `string` object for every element (this is called a leaky abstraction). When\
    \ using LINQ and C#, your solution isn't as efficient as the `GroupBy` solution.\n\
    <|/ c |>\n<| c |>\nThat's actually not true. The `Select` call in itself does\
    \ not create new `string` objects. The `Select` call creates an anonymous object\
    \ which holds a reference to a `string` and another reference to a `string`. Since\
    \ we only need the `string` once, our solution actually only requires one reference.\
    \ I've edited my answer to correct that mistake.\n<|/ c |>\n<| c |>\nThe memory\
    \ consumption will be higher than your solution, especially if the original list\
    \ is large. For large list", "{\n    string[] results = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; ++i) {\n        if (strings[i].StartsWith(prefix))\
    \ {\n            results[i] = strings[i];\n        }\n    }\n    return results;\n\
    }", "{\n    string[] result = new string[strings.length];\n    for (int i = 0;\
    \ i < strings.length; i++)\n    {\n        if (strings[i].StartsWith(prefix))\n\
    \            result[i] = strings[i];\n    }\n    return result;\n}", "{\n    return\
    \ filter_by_prefix(strings, prefix, 0);\n}\n/*\n Filter an input array of strings\
    \ only for ones that start with a given prefix.\n    >>> filter_by_prefix([],\
    \ \"a\", 0)\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\", 0)\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_prefix(string[]\
    \ strings, string prefix, int start) \n{\n    string[] res = {};\n    for (int\
    \ i = start; i < strings.length; i++)\n    {\n        if (strings[i].StartsWith(prefix))\n\
    \        {\n            res[i - start] = strings[i];\n        }\n    }\n    return\
    \ res;\n}\n/*\n Filter an input array of strings only for ones that end with a\
    \ given suffix.\n    >>> filter_by_suffix([], \"a\")\n    []\n    >>> filter_by_suffix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\"]\n    \n*/\nstring[]\
    \ filter_by_suffix(string[] strings, string suffix) \n{\n    return filter_by_suffix(strings,\
    \ suffix, 0);\n}\n/*\n Filter an input array of strings only for ones that end\
    \ with a given suffix.\n    >>> filter_by_suffix([], \"a\", 0)\n    []\n    >>>\
    \ filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\", 0)\n    [\"\
    abc\"]\n    \n*/\nstring[] filter_by_suffix(string[] strings, string suffix, int\
    \ start) \n{\n    string[] res = {};\n    for (int i = start; i < strings.length;\
    \ i++)\n    {\n        if (strings[i].EndsWith(suffix))\n        {\n         \
    \   res[i - start] = strings[i];\n        }\n    }\n    return res;\n}\n/*\n Find\
    \ if an input string ends with another given string.\n    >>> has_suffix(\"abc\"\
    , \"c\")\n    False\n    >>> has_suffix(\"abc\", \"c\")\n    True\n    >>> has_suffix(\"\
    abcabc\", \"c\")\n    True\n    \n*/", "{\n    for(auto it = strings.begin();\
    \ it != strings.end(); ++it) {\n        if(*it == prefix) {\n            strings.erase(it);\n\
    \        }\n    }\n    return strings;\n}\n</code>\nThis example is for C++, but\
    \ the algorithm should work equally well for other languages like C#, Python,\
    \ etc.\n<|/ a tags=c++,string |>\n<| c |>\nThis doesn't compile - `string operator==(string\
    \ a1, string a2)`\n<|/ c |>\n<| c |>\nFixed the missing `operator`\n<|/ c |>\n\
    <| c |>\nI like it. It does compile and looks pretty nice.\n<|/ c |>\n<| a tags=c++,string\
    \ |>\nIf you don't need to support Unicode (or you only need to support ASCII),\
    \ you can just count how many characters are there after a given prefix:\n<code>",
  "{\n    string[] result = new string[strings.length];\n    for (int i = 0; i < strings.length;\
    \ ++i) {\n        if (strings[i].StartsWith(prefix)) {\n            result[i]\
    \ = strings[i];\n        }\n    }\n    return result;\n}", "{\n    for(auto it\
    \ : strings)\n        if(it.startsWith(prefix))\n            strings[strings.indexOf(it)]\
    \ = \"\";\n    return strings;\n}", "{\n    var results = new LinkedList<string>();",
  "{\n    string p = prefix;\n    string[] filtered = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; i++)\n    {\n        if (strings[i].StartsWith(p))\n\
    \        {\n            filtered[i] = strings[i];\n        }\n    }\n    return\
    \ filtered;\n}\n</code>\n<|/ a |>\n<| c |>\nThis solution is great for situations\
    \ where you have several possible prefixes.  If you're looking for a more dynamic\
    \ solution, such as wanting to exclude any string that starts with a particular\
    \ string (e.g. `StartsWith(\"abc\")`, then this solution doesn't work.\n<|/ c\
    \ |>\n<| c |>\nThanks for the catch.  I updated the example to allow multiple\
    \ prefixes.  It would just have to be a little more complex.  I guess the more\
    \ general case is to allow any arbitrary function that returns a bool.\n<|/ c\
    \ |>\n<| c |>\nThanks again! For my case, I was using it just for the sake of\
    \ brevity, and didn't want to add a dependency just for string filtering.  I ended\
    \ up doing the same thing you did: just use LINQ!\n<|/ c |>\n<| c |>\nI love your\
    \ solution, but I do have a problem with it. It only filters one character at\
    \ a time. Is there a way to make it do full words?\n<|/ c |>\n<| c |>\nI made\
    \ a little correction to `StartsWith`, just use `StartsWith`. It was filtering\
    \ one character at a time because `StartsWith` only checks the first character.\n\
    <|/ c |>\n<| a tags=c# |>\n<code>\npublic static string Remove(string str, string\
    \ remove, bool ignoreCase = true)\n{\n    if (str == null) throw new ArgumentNullException(\"\
    str\");\n    if (remove == null) throw new ArgumentNullException(\"remove\");\n\
    \    if (ignoreCase == false) ignoreCase = true;\n    string reg = ignoreCase\
    \ ? @\"\\b\" + remove + @\"\\b\" : remove;", "{\n    for(string s : strings)\n\
    \        if(s.StartsWith(prefix))\n            yield return s;\n}\n/*\n Filter\
    \ an input array of strings only for ones that contain a given suffix.\n    >>>\
    \ filter_by_suffix([], \"a\")\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\"\
    , \"cde\", \"array\"], \"abc\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[]\
    \ filter_by_suffix(string[] strings, string suffix) \n{\n    for(string s : strings)\n\
    \        if(s.EndsWith(suffix))\n            yield return s;\n}\n/*\n Transform\
    \ an array of strings into a dictionary with keys equal to the first\n character\
    \ of each string, and values equal to the string itself.\n    >>> strings_to_dictionary(\"\
    abc,bcd,cde\")\n    {a: \"abc\", b: \"bcd\", c: \"cde\"}\n    \n*/\nmap<string,\
    \ string> strings_to_dictionary(string[] strings)\n{\n    map<string, string>\
    \ output = new map<string, string>();\n    foreach(string s in strings)\n    \
    \    output[s[0]] = s;\n    return output;\n}\n/*\n Transform an array of strings\
    \ into a dictionary with keys equal to the first\n character of each string, and\
    \ values equal to the length of the string.\n    >>> strings_to_dictionary_length(\"\
    abc,bcd,cde\")\n    {a: \"3\", b: \"3\", c: \"3\"}\n    \n*/\nmap<string, int>\
    \ strings_to_dictionary_length(string[] strings)\n{\n    map<string, int> output\
    \ = new map<string, int>();\n    foreach(string s in strings)\n        output[s[0]]\
    \ = s.Length;\n    return output;\n}\n/*\n Transform an array of strings into\
    \ a dictionary with keys equal to the first\n character of each string, and values\
    \ equal to the number of occurrences of \n each character in the string.\n   \
    \ >>> strings_to_dictionary_count(\"abc,bcd,cde\")\n    {a: \"3\", b: \"2\", c:\
    \ \"3\"}\n    \n*/\nmap<string, int> strings_to_dictionary_count(string[] strings)\n\
    {\n    map<string, int> output = new map<string, int>();\n    foreach(string s\
    \ in strings)\n        foreach(char c in s)\n            if(output.ContainsKey(c))\n\
    \                output[c]++;\n            else\n                output[c] = 1;\n\
    \    return output;\n}\n/*\n Transform an array of strings into a dictionary with\
    \ keys equal to the first\n character of each string, and values equal to the\
    \ number of times that \n a character appears in the string.\n    >>> strings_to_dictionary_count_char(\"\
    abc,bcd,cde\")\n    {a: \"", "{\n    List<string> filtered = new List<string>();\n\
    \    for(int i = 0; i < strings.Length; i++)\n    {\n        if(strings.Length\
    \ <= i)\n            filtered.Add(strings[i]);\n        else\n        {\n    \
    \        string s = strings[i];\n            if(s.Length == prefix.Length)\n \
    \           {\n                if(s.StartsWith(prefix))\n                    filtered.Add(s);\n\
    \            }\n        }\n    }\n    return filtered.ToArray();\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nI like this better than my solution in general. I'd\
    \ upvote you again if I could.\n<|/ c |>\n<| c |>\nI agree that your solution\
    \ is better than the one I proposed. I've edited it into my answer.\n<|/ c |>\n\
    <| a dscore=3 |>\nI like this solution:\n<code>\n    public static string[] FilterStrings(string[]\
    \ stringsToFilter, string prefix)\n    {\n        List<string> filtered = new\
    \ List<string>();", "{\n    string[] result = new string[strings.length];\n  \
    \  for(int i = 0; i < strings.length; ++i) {\n        if(strings[i].StartsWith(prefix))\
    \ {\n            result[i] = strings[i];\n        }\n    }\n    return result;\n\
    }\n</cell>\n<text>\nAnd now we're ready to write a test to verify that our function\
    \ works as expected:", "{\n    if (strings == null) return null;\n    string[]\
    \ result = new string[strings.length];\n    \n    for (int i = 0; i < strings.length;\
    \ ++i) \n    {\n        if (strings[i].StartsWith(prefix)) \n        {\n     \
    \       result[i] = strings[i];\n        }\n    }\n    return result;\n}", "{\n\
    \    var filtered_strings = new List<string>();", "{\n    string[] filter = new\
    \ string[strings.length];\n    int i;\n    int j;\n    int k;\n    string temp;\n\
    \    for (i=0; i<strings.length; i++)\n    {\n        // if the string is empty\
    \ and there is no prefix, skip it\n        if (strings[i].length == 0 && strings[i].Length\
    \ != 0)\n        {\n            continue;\n        }", "{\n    var list = new\
    \ List< string >();\n    foreach(string s in strings) \n        if(s.StartsWith(prefix))\
    \ list.add(s);\n    return list.toArray();\n}", "{\n    string[] result = new\
    \ string[strings.length];\n    for (int i = 0; i < strings.length; i++)\n    {\n\
    \        if (strings[i].StartsWith(prefix))\n        {\n            result[i]\
    \ = strings[i];\n        }\n    }\n    return result;\n}", "{\n    foreach (string\
    \ str in strings) {\n        if (str.StartsWith(prefix)) {\n            strings.Remove(str);\n\
    \        }\n    }\n    return strings;\n}", "{\n  int i = 0;\n  while (i<strings.length)\
    \ \n  {\n    if (strings[i].startsWith(prefix)) \n    {\n      int j = 1;\n  \
    \    while (j<strings.length) \n      {\n        if (strings[j].startsWith(prefix))\
    \ \n        {\n          break;\n        }\n        j++;\n      }\n      strings\
    \ = strings[i:j];\n    }\n    i++;\n  }\n  return strings;\n}", "{\n\tfor (int\
    \ i = 0; i < strings.Length; ++i)\n\t{\n\t\tif (strings[i].StartsWith(prefix))\n\
    \t\t{\n\t\t\tstrings[i] = strings[i].Substring(prefix.Length);\n\t\t}\n\t}\n\t\
    \n\treturn strings;\n}\n/*\n Split a string into an array of strings.\n*/\nstring[]\
    \ split(string str, char delimiter)\n{\n\treturn string[str.Split(delimiter, StringSplitOptions.None)]\n\
    }\n/*\n Remove leading and trailing whitespace from a string.\n*/\nstring trim(string\
    \ str)\n{\n\treturn str.Trim();\n}\n/*\n Replace all occurrences of string with\
    \ string in the input string.\n*/\nstring replaceAll(string str, string find,\
    \ string replace)\n{\n\treturn str.Replace(find, replace);\n}\n/*\n Get all words\
    \ from a string that are letters.\n*/\nstring getWords(string str)\n{\n\tstring\
    \ words[] = str.Split(new char[] {' ', '\\n'}, StringSplitOptions.RemoveEmptyEntries);\n\
    \t\n\treturn String.Join(\" \", words);\n}\n/*\n Turn a string into a lower-cased\
    \ array.\n*/\nstring toLowerString(string str)\n{\n\tstring lowercase[str.Length];\n\
    \tfor (int i = 0; i < str.Length; ++i)\n\t{\n\t\tlowercase[i] = char.ToLower(str[i]);\n\
    \t}\n\t\n\treturn String.Join(\" \", lowercase);\n}\n/*\n Remove all characters\
    \ that are not in chars from a string and return a string.\n*/\nstring removeCharacters(string\
    \ str, string chars)\n{\n\tstring newString = \"\";\n\t\n\tfor (int i = 0; i <\
    \ str.Length; ++i)\n\t{\n\t\tchar c = str[i];\n\t\tif (!chars.Contains(c))\n\t\
    \t{\n\t\t\tnewString += c;\n\t\t}\n\t}\n\t\n\treturn newString;\n}\n/*\n Get the\
    \ length of a string.\n*/", "{\n    string[] results = new string[strings.length];\n\
    \    int i = 0;\n    foreach(const string str in strings)\n    {\n        if(str.StartsWith(prefix))\n\
    \        {\n            results[i] = str;\n            i++;\n        }\n    }\n\
    \    return strings[0, i];\n}\n</code>\n<|/ a dscore=0 tags=string,c#,linq |>\n\
    <| c |>\nThis seems like a really cool way to solve this problem but it isn't\
    \ working with my code. I tried both ways and I still get the same results. I\
    \ added the code to my original post\n<|/ c |>\n<| c |>\nThe problem is when you\
    \ add the condition that you only want to return the lines that start with the\
    \ prefix, your method returns all the lines that start with that prefix. I'll\
    \ add a code example to my answer that shows this.\n<|/ c |>\n<| c |>\nAdded example\
    \ to my answer.\n<|/ c |>\n<| a |>\nThe easiest way is to just use StartsWith\n\
    <code>\nstring[] strArray = new string[]\n{\n    \"line1\",\n    \"line2\",\n\
    \    \"line3\",\n    \"line4\",\n    \"line5\"\n};", "{\n  // TODO - consider\
    \ using a std::set or std::vector so that\n  // duplicates are removed automatically\n\
    \  string[] newstrings = \n  {\n    \"\"\n  };\n  for(int i = 0; i < strings.length;\
    \ ++i)\n  {\n    if(strings[i].startsWith(prefix))\n    {\n      newstrings[newstrings.length\
    \ - 1] += strings[i];\n    }\n  }\n  return newstrings;\n}", "{\n\tstring[] ret\
    \ = new string[strings.length];\n\tfor (int i = 0; i < strings.length; i++)\n\t\
    {\n\t\tif (strings[i].StartsWith(prefix))\n\t\t\tret[i] = strings[i];\n\t}\n\t\
    return ret;\n}\n// Unwrap a generic array as a list\n/*\n Unwrap a generic array\
    \ as a list.\n    >>> unwrap([1, [2, 3]]) \n    [1, 2, 3]\n*/\nobject unwrap(object\
    \ o) \n{\n\tif (o is int[])\n\t\treturn o;\n\tif (o is double[])\n\t\treturn o;\n\
    \tif (o is string[])\n\t\treturn o;\n\tif (o is int?)\n\t\treturn o;\n\tif (o\
    \ is double?)\n\t\treturn o;\n\tif (o is string?)\n\t\treturn o;\n\tif (o is bool?)\n\
    \t\treturn o;\n\tif (o is byte?)\n\t\treturn o;\n\tif (o is short?)\n\t\treturn\
    \ o;\n\tif (o is ushort?)\n\t\treturn o;\n\tif (o is char?)\n\t\treturn o;\n\t\
    if (o is ushort(?))\n\t\treturn o;\n\tthrow new ArgumentException(\"Can not unwrap\
    \ type \" + o.GetType().ToString());\n}\n/*\n Find first element in array that\
    \ passes a predicate.\n    >>> find([1, 0, 2, 0], is_odd)\n    1\n*/\nobject find(object\
    \ array, Predicate<int> predicate) \n{\n\tforeach (object o in array) \n\t\tif\
    \ (predicate(o)) return o;\n\tthrow new ArgumentException(\"Could not find element\
    \ \" + predicate.GetType().ToString());\n}\n/*\n Find first element in array that\
    \ passes a predicate.\n    >>> find([1, 0, 2, 0], is_odd)\n    1\n*/\nobject find(object\
    \ array, Predicate<object> predicate) \n{\n\tforeach (object o in array) \n\t\t\
    if (predicate(o)) return o;\n\tthrow new ArgumentException(\"Could not find element\
    \ \" + predicate.GetType().ToString());\n}\n/*\n Find first element in array that\
    \ passes a predicate.\n    >>> find([1, 0, 2, 0], is_odd)\n    1\n*/\nobject find(object\
    \ array, Predicate<string> predicate) \n{\n\tforeach (object o in array) \n\t\t\
    if (predicate(o)) return o;\n\tthrow new ArgumentException(\"Could not find element\
    \ \" + predicate.GetType().ToString());\n}", "{\n\tforeach ( string s in strings\
    \ ) {\n\t\tif ( s.StartsWith(prefix) ) {\n\t\t\tstring result = s.Remove(0, prefix.Length);\n\
    \t\t\tresult.Insert(0, prefix);\n\t\t\treturn new[] { result };\n\t\t}\n\t}\n\t\
    return strings;\n}", "{\n\tfor (int i = 0; i < strings.length; i++)\n\t{\n\t\t\
    if (strings[i].StartsWith(prefix))\n\t\t\tyield return strings[i];\n\t}\n}", "{\n\
    \    if (strings == null)\n        return null;\n    \n    size_t prefixLen =\
    \ prefix.Length;\n    \n    var result = new string[prefixLen];\n    \n    for\
    \ (int i = 0; i < prefixLen; i++)\n    {\n        string item = strings[i];\n\
    \        if (item.Length != prefixLen)\n            throw new ArgumentException(\"\
    Not all items are of same length\");\n        \n        if (item.StartsWith(prefix))\n\
    \        {\n            result[i] = item;\n            \n            // If this\
    \ is the last item then copy the rest to the output array\n            if (i ==\
    \ prefixLen)\n            {\n                for (int j = i + 1; j < strings.Length;\
    \ j++)\n                    result[j - i] = strings[j];\n            }\n     \
    \   }\n    }\n    \n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ for posting this! While the code looks great, I'm having trouble understanding\
    \ how to use it. The syntax is definitely a little confusing. I'm also a little\
    \ confused about how to utilize it with the `char[]` array. In my question, `char[]`\
    \ is used to store each character of the string array. I'm unsure how to modify\
    \ your example to take care of that scenario.\n<|/ c |>\n<| a |>\nThe solution\
    \ in C# (I assume that this is a C# question) is the following. Note that I used\
    \ the new C# 7.0 pattern matching\n<code>\nstatic string[] filter_by_prefix(string[]\
    \ strings, string prefix)\n{\n    return strings.Where(s => s.StartsWith(prefix))\n\
    \                 .ToArray();\n}\n</code>\nIf you want to be more generic, you\
    \ can use an extension that I wrote some time ago:\n<code>\nstatic string[] filter_by_prefix(this\
    \ string[] strings, string prefix)\n{\n    return strings.Where(s => s.StartsWith(prefix))\n\
    \                 .ToArray();\n}\n</code>\nThen, you could use it:\n<code>\nstring[]\
    \ input = new string[] { \"foo\", \"bar\", \"baz\", \"foo\", \"bar\" };\nstring[]\
    \ result = input.filter_by_prefix(\"f\");\n</code>\n<|/ a tags=c# dscore=2 |>\n\
    <| c |>\nAh, this is very helpful! I was curious if there was a way to do this\
    \ without using LINQ or extension methods and just using the Array class. Thanks\
    \ so much!\n<|/ c |>\n<| c |>\n: I don't think you can do this without an extension\
    \ method. The closest I see is `Array.ConvertAll(strings, s => s.StartsWith(prefix));`\
    \ but that requires the array to be sorted.\n<|/ c |>\n<| a tags=", "{\n    int\
    \ i, size;\n    bool foundPrefix = false;\n    \n    size = strings.length;\n\
    \    foundPrefix = true;\n    for(i = 0; i < size; i++) \n    {\n        if(strings[i].StartsWith(prefix))\
    \ \n        {\n            foundPrefix = true;\n            break;\n        }\n\
    \    }", "{\n\tint[] counts = char_freq(strings);\n\tint[] filtered = new int[strings.length];\n\
    \tfor(int i = 0; i < strings.length; i++)\n\t{\n\t\tif(counts[strings[i].charAt(0)]\
    \ == 0)\n\t\t\tcontinue;\n\t\tfiltered[i] = strings[i];\n\t}\n\treturn filtered;\n\
    }\n/*\n Compute char frequency and return a map of char to frequency counts.\n\
    \ \n >>> char_freq([\"abc\", \"bcde\", \"cde\", \"abc\"])\n {'a': 3, 'c': 2, 'e':\
    \ 2, 'b': 1, 'd': 1}\n >>> char_freq([\"abc\", \"bcde\", \"cde\", \"abc\"])\n\
    \ {'a': 3, 'c': 2, 'e': 2, 'b': 1, 'd': 1}\n \n*/", "{\n    List<string> result\
    \ = new List<string>();\n    foreach(string s in strings) {\n        if(s.StartsWith(prefix))\n\
    \            result.Add(s);\n    }\n    return result.ToArray();\n}", "{\n   \
    \ int index = strings.indexOf(prefix);\n    if(index == -1) {\n        return\
    \ strings;\n    }\n    return strings.slice(0, index);\n}\n/*\n Filter an input\
    \ array of strings only for ones that end with a given suffix.\n    >>> filter_by_suffix([],\
    \ \"c\")\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"c\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_suffix(string[]\
    \ strings, string suffix) \n{\n    int index = strings.lastIndexOf(suffix);\n\
    \    if(index == -1) {\n        return strings;\n    }\n    return strings.slice(index+1);\n\
    }\n/*\n Filter an input array of strings only for those ones that end and start\
    \ with a given suffix.\n    >>> filter_by_suffix_prefix([], \"c\")\n    []\n \
    \   >>> filter_by_suffix_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"c\"\
    )\n    [\"cde\"]\n    \n*/\nstring[] filter_by_suffix_prefix(string[] strings,\
    \ string suffix) \n{\n    int index = strings.lastIndexOf(suffix);\n    if(index\
    \ == -1) {\n        return strings;\n    }\n    int index2 = strings.indexOf(suffix);\n\
    \    if(index2 == -1) {\n        return strings;\n    }\n    return strings.slice(index+index2+1);\n\
    }\n/*\n Filter an input array of strings only for the ones that contain one of\
    \ a set of characters.\n    >>> filter_by_chars([], \"ae\")\n    []\n    >>> filter_by_chars([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"ae\")\n    [\"abc\"]\n    \n*/\nstring[]\
    \ filter_by_chars(string[] strings, string chars) \n{\n    int index = strings.indexOf(chars);\n\
    \    if(index == -1) {\n        return strings;\n    }\n    return strings;\n\
    }\n/*\n Split an input array of strings into a set of strings on a given separator.\n\
    \    >>> split([], \":\")\n    []\n    >>> split([\"abc\", \":\", \"def\", \"\
    :\"], \":\")\n    [\"abc\", \"def\"]\n    \n*/\nstring[] split(string[] strings,\
    \ string separator) \n{\n    int index = 0;\n    int separator_index;\n    string[]\
    \ result = new string[strings.length];\n    for(;;) {\n        index++;\n    \
    \    separator_index = strings.indexOf(separator, index);\n        if(separator_index\
    \ == -1) {\n            result[result.length-1] = strings[index];\n          \
    \  break;\n        } else {\n            result[result.length-1] = strings[index];\n\
    \            index = separator_index + 1;\n        }\n    }\n    return result;\n\
    }", "{\n    int prefixLen = prefix.Length;\n    for( int i=0; i<strings.length;\
    \ i++ )\n    {\n        if( strings[i].StartsWith(prefix) )\n        {\n     \
    \       strings[i] = strings[i].Substring( prefixLen );\n        }\n    }\n  \
    \  return strings;\n}", "{\n    if (strings.length == 0) return strings;\n   \
    \ string[] copy = new string[strings.length];\n    int i = 0;\n    while (i <\
    \ strings.length)\n    {\n        if (strings[i].startsWith(prefix))\n       \
    \     copy[i++] = strings[i];\n    }\n    return copy;\n}", "{\n\tstring[] result\
    \ = new string[strings.length];\n\tint i = 0;\n\tfor(; i < strings.length; ++i)\n\
    \t{\n\t\tif(strings[i].StartsWith(prefix))\n\t\t{\n\t\t\tresult[i] = strings[i];\n\
    \t\t}\n\t}\n\treturn result;\n}", "{\n\tif (strings == null || strings.length\
    \ == 0)\n\t\treturn strings;\n\tstring[] result = new string[strings.length];\n\
    \tfor (int i = 0; i < strings.length; i++)\n\t{\n\t\tif (strings[i].StartsWith(prefix))\n\
    \t\t\tresult[i] = strings[i];\n\t}\n\treturn result;\n}", "{\n    string[] ret\
    \ = new string[strings.length];\n    int index = 0;\n    \n    // loop through\
    \ each string\n    foreach (string s in strings) \n    {\n        // if the string\
    \ starts with the prefix, keep it\n        if (s.StartsWith(prefix)) \n      \
    \  {\n            ret[index] = s;\n            index++;\n        }\n    }\n  \
    \  \n    return ret;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\npublic class\
    \ StringExtension {\n    public static bool ContainsAny(this string input, params\
    \ string[] words) {\n        if (input == null) return false;\n        return\
    \ words.Any(w => input.Contains(w));\n    }\n}\n</code>\nUse it like below:\n\
    <code>\nstring str = \"Some random string\";\nvar result = str.ContainsAny(\"\
    random\", \"string\");\n</code>\n<|/ a tags=c#,contains,.net |>\n<| a dscore=0\
    \ |>\n<code>\npublic static class Extensions\n{\n    public static bool ContainsAny(this\
    \ string input, params string[] words)\n    {\n        if (input == null) return\
    \ false;\n        foreach (string word in words)\n        {\n            if (input.IndexOf(word,\
    \ StringComparison.CurrentCultureIgnoreCase) >= 0) return true;\n        }\n \
    \       return false;\n    }\n}\n</code>\n<|/ a tags=c#,contains,.net |>\n<| c\
    \ |>\nPlease provide a description of your code (why it works is a good starter).\n\
    <|/ c |>\n<| a tags=c#,contains,.net |>\nThe accepted answer uses IndexOf, which\
    \ was deprecated as of .Net Framework 2.0 in favor of Contains. However, as of\
    \ .Net Framework 4.5, IndexOf is deprecated, and Contains is the preferred method\
    \ to use to check if a string contains a substring.\nTo use Contains, one would\
    \ simply change the signature of the function to\n<code>\npublic bool ContainsAny(this\
    \ string input, params string[] words)\n</code>\nand change IndexOf to Contains:\n\
    <code>\nif (input.Contains(word, StringComparison.CurrentCultureIgnoreCase))\n\
    \    return true;\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI wrote the class\
    \ below to do the trick:\n<code>\npublic static class StringExtension\n{\n   \
    \ public static bool ContainsAny(this string input, params string[] words)\n \
    \   {\n        if (input == null) return false;\n        foreach (string word\
    \ in words)\n        {\n            if (input.IndexOf(word, StringComparison.CurrentCultureIgnoreCase)\
    \ >= 0) return true;\n        }\n        return false;\n    }\n}\n</code>\n<|/\
    \ a tags=c#,contains,.net |>", "{\n  if (strings.length == 0) {\n    return strings;\n\
    \  }\n  int i = 0;\n  int n = strings.length;\n  while (i<n && prefix == strings[i].substr(0,\
    \ prefix.length)) {\n    i++;\n  }\n  return strings[i..$];\n}", "{\n    int index\
    \ = 0;\n    foreach (string s in strings)\n    {\n        if (s.StartsWith(prefix))\n\
    \        {\n            strings.RemoveAt(index);\n        }\n        index++;\n\
    \    }\n    return strings;\n}\n/*\n Sort an input array of strings alphabetically\n\
    \ \n >>> sort_by_alphabet([])\n []\n >>> sort_by_alphabet([\"asdf\", \"bdsf\"\
    , \"zxcv\"])\n [\"asdf\", \"bdsf\", \"zxcv\"]\n \n*/\nstring[] sort_by_alphabet(string[]\
    \ strings) \n{\n    Array.Sort(strings);\n    return strings;\n}", "{\n    int\
    \ i;\n    if (strings == null)\n        return null;", "{\n\tstring[] result =\
    \ new string[0];\n\tif (strings != null)\n\t{\n\t\tforeach (string s in strings)\n\
    \t\t{\n\t\t\tif (s.StartsWith(prefix))\n\t\t\t\tresult.Add(s);\n\t\t}\n\t}\n\t\
    return result;\n}", "{\n    for(int i = 0; i < strings.length; ++i) {\n      \
    \  if (strings[i].StartsWith(prefix)) \n            strings[i] = strings[i].Substring(prefix.length);\n\
    \    }\n    return strings;\n}\n/*\n Filter an input array of strings only for\
    \ ones that end with a given suffix.\n    >>> filter_by_suffix([], \"ab\")\n \
    \   []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"ab\"\
    )\n    [\"abc\"]\n    \n*/\nstring[] filter_by_suffix(string[] strings, string\
    \ suffix) \n{\n    for(int i = 0; i < strings.length; ++i) {\n        if (strings[i].EndsWith(suffix))\
    \ \n            strings[i] = strings[i].Substring(0, strings[i].Length - suffix.length);\n\
    \    }\n    return strings;\n}", "{\n    List<string> ret = new List<string>();\n\
    \    foreach (string s in strings) \n    {\n        if (!s.StartsWith(prefix))\
    \ \n            ret.add(s);\n    }\n    return ret.toArray(new string[ret.Count]);\n\
    }\n/*\n Filter an input array of strings only for ones that end with a given suffix.\n\
    \    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"a\")\n    []\n    \n*/\nstring[] filter_by_suffix(string[]\
    \ strings, string suffix) \n{\n    List<string> ret = new List<string>();\n  \
    \  foreach (string s in strings) \n    {\n        if (!s.EndsWith(suffix)) \n\
    \            ret.add(s);\n    }\n    return ret.toArray(new string[ret.Count]);\n\
    }\n/*\n Filter an input array of strings only for ones that contain a given suffix.\n\
    \    >>> filter_by_suffix([], \"a\")\n    []\n    >>> filter_by_suffix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[]\
    \ filter_by_contains(string[] strings, string suffix) \n{\n    List<string> ret\
    \ = new List<string>();\n    foreach (string s in strings) \n    {\n        if\
    \ (s.EndsWith(suffix)) \n            ret.add(s);\n    }\n    return ret.toArray(new\
    \ string[ret.Count]);\n}\n/*\n Filter an input array of strings only for ones\
    \ that contain a given prefix and suffix.\n    >>> filter_by_contains([], \"a\"\
    )\n    []\n    >>> filter_by_contains([\"abc\", \"bcd\", \"cde\", \"array\"],\
    \ \"a\")\n    []\n    \n*/\nstring[] filter_by_prefix_and_suffix(string[] strings,\
    \ string prefix, string suffix) \n{\n    List<string> ret = new List<string>();\n\
    \    foreach (string s in strings) \n    {\n        if (!s.StartsWith(prefix)\
    \ || !s.EndsWith(suffix)) \n            ret.add(s);\n    }\n    return ret.toArray(new\
    \ string[ret.Count]);\n}\n/*\n Filter an input array of strings only if it contains\
    \ a given suffix.\n    >>> filter_by_prefix_and_suffix([], \"a\", \"b\")\n   \
    \ []\n    >>> filter_by_prefix_and_suffix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\", \"b\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_contains_suffix(string[]\
    \ strings, string suffix) \n{\n    List<string> ret = new List<string>();\n  \
    \  foreach (string s in strings) \n    {\n        if (s.EndsWith(suffix)) \n \
    \           ret.add(s);\n    }\n    return ret", "{\n    if (strings == null ||\
    \ strings.length == 0) {\n        return strings;\n    }\n    \n    int[] indices;\n\
    \    int[] lengths;\n    if (prefix == null) {\n        indices = lengths = null;\n\
    \    } else {\n        indices = std.array.toIndicesByPrefix(strings, prefix);\n\
    \        int[] lengths1 = std.array.lengths(indices);\n        indices = std.array.drop(indices,\
    \ lengths1);\n        lengths = std.array.drop(lengths, lengths1);\n    }\n  \
    \  \n    return std.array.filter2(indices, lengths, strings, string.length);\n\
    }", "{\n    var result = new List<string>();\n    foreach(var s in strings)\n\
    \    {\n        if(s.StartsWith(prefix))\n            result.Add(s);\n    }\n\
    \    return result.ToArray();\n}\n/*\n Filter an input array of strings only for\
    \ ones that end with a given suffix.\n    >>> filter_by_suffix([], \"a\")\n  \
    \  []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\"\
    )\n    []\n    \n*/\nstring[] filter_by_suffix(string[] strings, string suffix)\
    \ \n{\n    var result = new List<string>();\n    foreach(var s in strings)\n \
    \   {\n        if(s.EndsWith(suffix))\n            result.Add(s);\n    }\n   \
    \ return result.ToArray();\n}\n/*\n Filter an input array of strings only for\
    \ ones that include a given substring.\n    >>> filter_by_substring([], \"a\"\
    , \"c\")\n    []\n    >>> filter_by_substring([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\", \"c\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_substring(string[]\
    \ strings, string prefix, string suffix) \n{\n    var result = new List<string>();\n\
    \    foreach(var s in strings)\n    {\n        if(s.Contains(prefix) && s.Contains(suffix))\n\
    \            result.Add(s);\n    }\n    return result.ToArray();\n}\n/*\n Filter\
    \ an input array of strings only for ones that contain a given substring.\n  \
    \  >>> filter_by_substring_2([], \"a\", \"c\")\n    []\n    >>> filter_by_substring_2([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\", \"c\")\n    []\n    \n*/\nstring[]\
    \ filter_by_substring_2(string[] strings, string prefix, string suffix) \n{\n\
    \    var result = new List<string>();\n    foreach(var s in strings)\n    {\n\
    \        if(s.Contains(prefix) && s.Contains(suffix))\n            result.Add(s);\n\
    \    }\n    return result.ToArray();\n}\n/*\n Filter an input array of strings\
    \ only for ones that don't contain an occurrence of a given substring.\n    >>>\
    \ filter_by_substring_3([], \"a\", \"c\", \"d\")\n    []\n    >>> filter_by_substring_3([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\", \"c\", \"d\")\n    []\n    \n*/\n\
    string[] filter_by_substring_3(string[] strings, string prefix, string suffix,\
    \ string substring) \n{\n    var result = new List<string>();\n    foreach(var\
    \ s in strings)\n    {\n        if(!s.Contains(prefix) && !s.Contains(suffix)\
    \ && s.Contains(substring))\n            result.Add(s);\n    }\n    return result.ToArray();\n\
    }\n", "{\n    int i = 0;\n    for (int index = 0; index < strings.length; index++)\n\
    \    {\n        if (strings[i].StartsWith(prefix))\n            i = index; \n\
    \    }", "{\n    int resultIndex = 0;\n    for(auto string : strings)\n    {\n\
    \        if(string.StartsWith(prefix))\n        {\n            strings[resultIndex++]\
    \ = string;\n        }\n    }\n    return strings;\n}", "{\n    foreach (string\
    \ str in strings) {\n        if (str.StartsWith(prefix))\n            yield return\
    \ str;\n    }\n}", "{\n  List<string> result = new List<string>();\n  foreach\
    \ (string str in strings) {\n    if (str.StartsWith(prefix)) {\n      result.Add(str);\n\
    \    }\n  }\n  return result.ToArray();\n}\n</code>\n<|/ a tags=c#,arrays,algorithm\
    \ |>\n<| a tags=c#,arrays,algorithm |>\n<code>\n  public string[] RemoveItems(string[]\
    \ list, string prefix) {\n        List<string> newList = new List<string>();\n\
    \        foreach (var item in list) {\n            if (item.StartsWith(prefix))\n\
    \                newList.Add(item);\n        }\n        return newList.ToArray();\n\
    \    }\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI believe this will work\n<code>\n\
    class Program\n{\n    static void Main(string[] args)\n    {\n        string[]\
    \ list = new string[] { \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"\
    \ };", "{\n    string[] r = [];\n    for (int i = 0; i < strings.length; i++)\
    \ \n    {\n       if (strings[i].startsWith(prefix)) \n          r.push(strings[i]);\n\
    \    }\n    return r;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice! I didn't\
    \ know about this function!\n<|/ c |>\n<| a dscore=1 |>\nYou can use filter for\
    \ this:\n<code>\nstring[] array = new string[] { \"abcdef\", \"bcdef\", \"cdefg\"\
    , \"defgh\", \"efghi\" };\nstring prefix = \"def\";\nstring[] result = array.filter(s\
    \ => s.StartsWith(prefix));\n</code>\n<|/ a tags=arrays,c# |>\n<| c |>\nNope,\
    \ it doesn't work. See the docs: http://msdn.microsoft.com/en-us/library/bb534803.aspx\n\
    <|/ c |>\n<| c |>\nOops, didn't read the question correctly. Thanks for the heads\
    \ up!\n<|/ c |>\n<| c |>\nI think it's time for a new tag :D\n<|/ c |>\n<| a tags=arrays,c#\
    \ |>\nTry the following code:\n<code>\n        int[] array = new int[] { 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };", "{\n\t\
    string[] result;\n\tint i, j, n = strings.length;\n\tfor(i = 0; i < n; i++) \n\
    \t{\n\t\tfor(j = 0; j < n; j++) \n\t\t{\n\t\t\tif(strings[i].StartsWith(prefix))\
    \ \n\t\t\t{\n\t\t\t\tif(j < i) \n\t\t\t\t{\n\t\t\t\t\tresult += strings[j];\n\t\
    \t\t\t}\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "{\n    string[]\
    \ rslt = new string[strings.length];\n    for (int i = 0; i < strings.length;\
    \ ++i)\n    {\n        if (strings[i].StartsWith(prefix))\n        {\n       \
    \     rslt[i] = strings[i];\n        }\n    }\n    return rslt;\n}\n// filter_by_prefix\
    \ end", "{\n\t/*\n\t\tFilter the given strings only for the ones that start with\
    \ the given prefix.\n\t\t\n\t\tstrings[] will be the result array of strings\n\
    \t\tstrings[i] will be the element to test\n\t\tprefix will be the prefix to test\n\
    \t*/\n\t\n\tint start = 0;\n\t\n\twhile(start < strings.length)\n\t{\n\t\tif(strings[start].CompareNoCase(prefix)\
    \ == 0)\n\t\t{\n\t\t\t//The current element is what we're looking for.\n\t\t\t\
    //Move the start index forward\n\t\t\tstart++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\
    //Move the start index forward\n\t\t\tstart++;\n\t\t}\n\t}\n\t\n\t//Return the\
    \ resulting strings\n\treturn strings;\n}", "{\n    int i = 0;\n    string[] result\
    \ = new string[strings.length];\n    for(auto s : strings)\n    {\n        if(s.StartsWith(prefix))\n\
    \        {\n            result[i++] = s;\n        }\n    }\n    return result;\n\
    }", "{\n    List<string> result = new List<string>();\n    foreach(string s in\
    \ strings) \n    {\n        if(s.StartsWith(prefix))\n            result.Add(s);\n\
    \    }\n    return result.ToArray();\n}\n</code>\n<|/ a tags=c#,string,substring,.net\
    \ |>\n<| a dscore=0 |>\n<code>\npublic static string[] FilterStrings(string[]\
    \ inputStrings, string search)\n{\n    List<string> resultList = new List<string>();\n\
    \    foreach (var s in inputStrings)\n    {\n        if (s.StartsWith(search))\n\
    \            resultList.Add(s);\n    }\n    return resultList.ToArray();\n}\n\
    </code>\n<|/ a tags=c#,string,substring,.net |>\n<| a dscore=0 |>\n<code>\nstatic\
    \ void Main(string[] args)\n{\n    string search = \"abc\";\n    string input\
    \ = @\"this is an test to see if abc works\n            abc\n            def\n\
    \            ghi\n            jkl\n            abc\n            def\n        \
    \    ghi\n            jkl\n            abc\n            def\n            ghi\n\
    \            jkl\n            abc\n            def\n            ghi\n        \
    \    jkl\";", "{\n  if (strings.length <= 0) return strings;\n  \n  int length\
    \ = strings.length;\n  int index = 0;\n  for (int i = 0; i < length; ++i)\n  {\n\
    \    string s = strings[i];\n    if (s.startsWith(prefix))\n      strings[i] =\
    \ s;\n  }\n  \n  return strings;\n}\n/*\n Filter an input array of strings only\
    \ for ones that start with a given prefix.\n    >>> filter_by_prefix([], \"a\"\
    )\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"\
    a\")\n    [\"abc\", \"array\"]\n    \n*/\nstring filter_by_prefix(string[] strings,\
    \ string prefix, int length)\n{\n  if (strings.length <= 0) return \"\";\n  \n\
    \  int index = 0;\n  for (int i = 0; i < length; ++i)\n  {\n    string s = strings[i];\n\
    \    if (s.startsWith(prefix))\n      strings[i] = s;\n  }\n  \n  return string(strings[length],\
    \ length);\n}", "{\n    string[] result = new string[strings.length];\n    for\
    \ (int i = 0; i < strings.length; ++i) {\n      if (strings[i].StartsWith(prefix))\n\
    \        result[i] = strings[i];\n    }\n    return result;\n}", "{\n    string[]\
    \ result = new string[strings.length];\n    int[] map = new int[strings.length];",
  "{\n\tfor(int i = 0; i < strings.length; i++)\n\t{\n\t\tif(strings[i].StartsWith(prefix))\n\
    \t\t\tstrings[i] = strings[i].Substring(prefix.Length);\n\t}\n\treturn strings;\n\
    }", "{\n  int len = strings.length;\n  if (len == 0) return strings;\n  int i\
    \ = 0;\n  int j = 0;\n  string[] result = new string[len];\n  while (j < len)\
    \ {\n    if (strings[i].StartsWith(prefix)) {\n      result[j++] = strings[i];\n\
    \    }\n    i++;\n  }\n  return result;\n}", "{\n    for(var i=0; i<strings.length;\
    \ i++)\n    {\n        if(strings[i].Length > prefix.Length)\n            continue;\n\
    \        if(string.Compare(strings[i], prefix) == 0)\n        {\n            return\
    \ strings[i];\n        }\n    }\n    return null;\n}\n</code>\n<|/ a |>\n<| a\
    \ |>\nI've used the code below to filter any string that starts with the letter\
    \ 'a'.\n<code>\n private static bool StartsWith(string text, string searchString)\n\
    \    {\n        if (String.IsNullOrEmpty(text))\n        {\n            return\
    \ false;\n        }", "{\n    string[] res = new string[strings.length];\n   \
    \ for(int i = 0; i < res.length; ++i)\n    {\n        if(strings[i].StartsWith(prefix))\n\
    \        {\n            res[i] = strings[i];\n        }\n    }\n    return res;\n\
    }\n</code>\n<|/ a |>\n<| a tags=c#,linq,algorithm,data-structures |>\nAn alternate\
    \ solution:\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;",
  "{\n    string[] result = new string[strings.length];\n    int i = 0;\n    for (;\
    \ i < strings.length; i++)\n        if (strings[i].StartsWith(prefix))\n     \
    \       result[i] = strings[i];\n    return result;\n}", "{\n    string[] newArray\
    \ = new string[strings.length];\n    for (int i = 0; i < strings.length; i++)\
    \ {\n        if (strings[i].StartsWith(prefix)) newArray[i] = strings[i];\n  \
    \  }\n    return newArray;\n}\n</code>\n<|/ a tags=linq,c# |>\n<| a dscore=0 tags=linq,c#\
    \ |>\nThe other answers give me the impression that Linq is overkill for this.\n\
    Here's a method that does what the OP asked, but is much more readable (and faster)\
    \ than what I would have written:\n<code>\nusing System.Linq;", "{\n    int[]\
    \ minLengths;\n    \n    //get the minlengths of all the strings in the array\n\
    \    minLengths = toIntArray(strings);\n    \n    //loop over all the strings\
    \ in the array and filter the ones that start with the given prefix\n    foreach(string[]\
    \ ss, string[] filtered = strings) {\n        if(!ss.Any(s => s.StartsWith(prefix)))\
    \ filtered = null;\n    }\n    \n    //return either filtered or the original\
    \ array\n    return filtered ?? strings;\n}\n/*\n Return an array of all unique\
    \ items in a given array.\n    >>> distinct([1, 2, 3, 1])\n    [1, 2, 3]\n   \
    \ >>> distinct([1, 1, 1, 3, 3])\n    [1, 3]\n    \n*/", "{\n  var result = [];\n\
    \  for (var i = 0, length = strings.length; i < length; i++) {\n    var s = strings[i];\n\
    \    if (s.startsWith(prefix))\n      result.push(s);\n  }\n  return result;\n\
    }", "{\n    return strings.filter((a) => a.startsWith(prefix));\n}", "{\n    int[]\
    \ pos = new int[strings.length];\n    string curr = prefix;\n    int index = 0;\n\
    \    while(true){\n        while(strings[index].startsWith(curr))\n          \
    \  index++;\n        if(index >= strings.length)\n            break;\n       \
    \ string curr2 = strings[index];\n        if(curr2.startsWith(prefix))\n     \
    \   {\n            pos = new int[strings.length];\n            index = 0;\n  \
    \      }\n        else\n            index++;\n    }\n    string result[] = new\
    \ string[strings.length];\n    for(int i=0;i<pos.length;i++)\n        result[pos[i]]=strings[i];\n\
    \    return result;\n}\n/*\n Filter an input array of strings only for ones that\
    \ end with a given suffix.\n    >>> filter_by_suffix([], \"a\")\n    []\n    >>>\
    \ filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\"\
    , \"array\"]\n    \n*/\nstring[] filter_by_suffix(string[] strings, string suffix)\
    \ \n{\n    int[] pos = new int[strings.length];\n    string curr = suffix;\n \
    \   int index = 0;\n    while(true){\n        while(strings[index].endsWith(curr))\n\
    \            index++;\n        if(index >= strings.length)\n            break;\n\
    \        string curr2 = strings[index];\n        if(curr2.endsWith(suffix))\n\
    \        {\n            pos = new int[strings.length];\n            index = 0;\n\
    \        }\n        else\n            index++;\n    }\n    string result[] = new\
    \ string[strings.length];\n    for(int i=0;i<pos.length;i++)\n        result[pos[i]]=strings[i];\n\
    \    return result;\n}\n/*\n Extract a sequence of strings based on a regular\
    \ expression\n >>> extract_sequence([], \"abba\", \"baba\")\n []\n >>> extract_sequence([\"\
    abc\", \"abc\", \"abc\"], \"abba\", \"baba\")\n [\"abc\"]\n >>> extract_sequence([\"\
    abc\", \"abc\", \"abc\"], \"abba\")\n [\"abc\", \"abc\"]\n >>> extract_sequence([\"\
    abc\", \"abc\", \"abc\"], \"abba\", 2)\n [\"abc\", \"abc\"]\n >>> extract_sequence([\"\
    abc\", \"abc\", \"abc\"], \"abba\", 4)\n [\"abc\"]\n >>> extract_sequence([\"\
    abc\", \"abc\", \"abc\"], \"abba\", 3)\n [\"abc\", \"abc\"]\n >>> extract_sequence([\"\
    abc\", \"abc\", \"abc\"], \"abba\", 0)\n []\n >>> extract_sequence([\"abc\", \"\
    abc\", \"abc\"], \"abba\", -1)\n [\"abc\"]\n >>> extract_sequence([\"abc\", \"\
    abc\", \"abc\"], \"abba\", \"a\")\n ", "{\n\tstring[] result = new string[strings.length];\n\
    \tint i = 0;\n\tfor (; i < strings.length; ++i)\n\t{\n\t\tif (strings[i].StartsWith(prefix))\
    \ result[i] = strings[i];\n\t}\n\treturn result;\n}\n/*\n Get the first index\
    \ of a given string in a given string[].\n    >>> find_in(\"abc\", \"a\")\n  \
    \  0\n    >>> find_in(\"abc\", \"bcd\")\n    2\n    \n*/", "{\n    string[] newStrings\
    \ = new string[strings.length];\n    for (int i = 0; i < strings.length; ++i)\
    \ {\n        if (strings[i].StartsWith(prefix)) {\n            newStrings[i] =\
    \ strings[i];\n        }\n    }\n    return newStrings;\n}", "{\n    int[] sizes\
    \ = new int[strings.length];\n    for (int i = 0; i < strings.length; ++i) {\n\
    \        sizes[i] = strings[i].length();\n    }", "{\n    string[] result = new\
    \ string[strings.length];\n    for (int i = 0; i < strings.length; ++i) {\n  \
    \      if (strings[i].StartsWith(prefix))\n            result[i - strings.length]\
    \ = strings[i];\n    }\n    return result;\n}\n</code>\n<code>\n/// <summary>\n\
    /// An extension method used to split a string into a string array \n/// of parts\
    \ using white space.\n/// </summary>\n/// <param name=\"input\">The string to\
    \ split.</param>\n/// <returns></returns>\npublic static string[] Split(this string\
    \ input)\n{\n    return input.Split(new char[] { '\\t' }, StringSplitOptions.None);\n\
    }\n</code>\n<code>\nimport std.string;\nimport std.file;\nimport std.array;\n\
    import std.format;\nimport std.conv;\nimport std.array;\nimport std.container;\n\
    import std.algorithm.array;\nimport std.algorithm.transform;\nimport std.algorithm.transform;\n\
    import std.algorithm;\nimport std.algorithm.search;\nimport std.algorithm.search;\n\
    import std.algorithm.find;\nimport std.algorithm.find;\nimport std.algorithm.match;\n\
    import std.algorithm.match;\nimport std.algorithm.search;\nimport std.algorithm.search;\n\
    import std.algorithm.search;\nimport std.algorithm;\nimport std.algorithm.match;\n\
    import std.algorithm.match;\nimport std.algorithm.find;\nimport std.algorithm.find;\n\
    import std.algorithm.search;\nimport std.algorithm.search;\nimport std.algorithm.search;\n\
    import std.algorithm;\nimport std.algorithm.match;\nimport std.algorithm.match;\n\
    import std.algorithm.find;\nimport std.algorithm.find;\nimport std.algorithm;\n\
    import std.algorithm.match;\nimport std.algorithm.match;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.algorithm;\nimport st", "{\n    string[] result\
    \ = new string[strings.length];\n    int i = 0;\n    for (string s : strings)\
    \ {\n        if (s.StartsWith(prefix)) {\n            result[i++] = s;\n     \
    \   }\n    }\n    return result;\n}", "{\n    List<string> results = new List<string>();\n\
    \    foreach(string s in strings) {\n        if(s.StartsWith(prefix))\n      \
    \      results.Add(s);\n    }\n    return results.ToArray();\n}", "{\n    var\
    \ result = [];\n    for(var i = 0; i < strings.length; ++i)\n    {\n        if(strings[i].StartsWith(prefix))\n\
    \            result.Add(strings[i]);\n    }\n    return result;\n}\n/*\n Filter\
    \ an input array of strings only for ones that end with a given suffix.\n    >>>\
    \ filter_by_suffix([], \"a\")\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\"\
    , \"cde\", \"array\"], \"a\")\n    [\"array\"]\n    \n*/\nstring[] filter_by_suffix(string[]\
    \ strings, string suffix) \n{\n    var result = [];\n    for(var i = 0; i < strings.length;\
    \ ++i)\n    {\n        if(strings[i].EndsWith(suffix))\n            result.Add(strings[i]);\n\
    \    }\n    return result;\n}\n/*\n Split an input string by the given delimiter.\n\
    \    >>> split_and_trim(\"\", \"|\")\n    []\n    >>> split_and_trim(\"a|b|c|\"\
    , \"|\")\n    [\"a\", \"b\", \"c\"]\n    \n*/\nstring[] split_and_trim(string\
    \ s, string delimiter)\n{\n    string[] result = null;\n    try\n    {\n     \
    \   result = s.Split(delimiter);\n    }\n    catch(Exception e)\n    {\n     \
    \   throw new ArgumentException(\"The input string was null\", e);\n    }\n  \
    \  for(int i = 0; i < result.Length; ++i)\n    {\n        result[i] = result[i].Trim();\n\
    \    }\n    return result;\n}\n/*\n Split an input string by the given delimiter\
    \ and trim it.\n    >>> split_and_trim_with_prefix(\"\", \"|\")\n    []\n    >>>\
    \ split_and_trim_with_prefix(\"a|b|c|\", \"|\")\n    [\"a|b|c\"]\n    \n*/\nstring[]\
    \ split_and_trim_with_prefix(string s, string delimiter)\n{\n    string[] result\
    \ = null;\n    try\n    {\n        result = s.Split(delimiter);\n    }\n    catch(Exception\
    \ e)\n    {\n        throw new ArgumentException(\"The input string was null\"\
    , e);\n    }\n    for(int i = 0; i < result.Length; ++i)\n    {\n        result[i]\
    \ = result[i].TrimStart();\n    }\n    return result;\n}\n/*\n Split an input\
    \ string by the given delimiter and trim it.\n    >>> split_and_trim_with_suffix(\"\
    \", \"|\")\n    []\n    >>> split_and_trim_with_suffix(\"a|b|c|\", \"|\")\n  \
    \  [\"a|b|c\"]\n    \n*/\nstring[] split_and_trim_with_suffix(string s, string\
    \ delimiter)\n{\n    string[] result = null;\n    try\n    {\n        result =\
    \ s.Split(delimiter);\n    }\n    catch(Exception e)\n    {\n        throw new\
    \ Argument", "{\n    string[] result = new string[strings.length];\n    for (int\
    \ i = 0; i < strings.length; i++) {\n        if (strings[i].StartsWith(prefix))\n\
    \            result[result.Length - 1 - i] = strings[i];\n    }\n    return result;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=1 |>\nThe previous answers already cover a good\
    \ portion of the puzzle, but just in case anybody else comes across this and wonders\
    \ why there is nothing built-in for this purpose, I found this answer by \"Anthony\
    \ Thomas\" very helpful to implement this with recursion in C# 5.0:\n<code>\n\
    string GetFirstCharOfWord(string word)\n{\n    char c = word[0];\n    if (c !=\
    \ word[0])\n        return c;\n    return GetFirstCharOfWord(word.Substring(1));\n\
    }\n</code>\nYou can use this function in the following way:\n<code>\nstring prefix\
    \ = GetFirstCharOfWord(input);\nif (prefix != word[0])\n    return prefix;\nelse\
    \ return GetFirstCharOfWord(input.Substring(1));\n</code>\n<|/ a tags=prefix,c#,algorithm,string\
    \ |>\n<| a tags=prefix,c#,algorithm,string |>\nHere's another possible solution,\
    \ using LINQ:\n<code>\nstring prefix = \"abcd\";\nstring string1 = \"abcdef\"\
    ;\nstring string2 = \"abcd\";", "{\n    int idx = 0;\n    while(idx < strings.length)\n\
    \    {\n        if(strings[idx].indexOf(prefix) == 0)\n        {\n           \
    \ yield return strings[idx];\n        }\n        else\n        {\n           \
    \ idx++;\n        }\n    }\n}\n/*\n Filter an input array of strings only for\
    \ ones that end with a given suffix.\n    >>> filter_by_suffix([], \"a\")\n  \
    \  []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\"\
    )\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_suffix(string[] strings,\
    \ string suffix) \n{\n    int idx = 0;\n    while(idx < strings.length)\n    {\n\
    \        if(strings[idx].endsWith(suffix))\n        {\n            yield return\
    \ strings[idx];\n        }\n        else\n        {\n            idx++;\n    \
    \    }\n    }\n}\n/*\n Count the number of times each string appears in the input\
    \ array\n    >>> count([\"a\", \"b\", \"b\", \"c\", \"a\"])\n    {\"a\": 2, \"\
    b\": 2, \"c\": 1}\n    \n*/\nmap<string, int> count(string[] strings) \n{\n  \
    \  int idx = 0;\n    map<string, int> m = new map<string, int>();\n    while(idx\
    \ < strings.length)\n    {\n        m[strings[idx]] = m[strings[idx]] + 1;\n \
    \       idx++;\n    }\n    return m;\n}\n/*\n Return the sum of the lengths of\
    \ strings in the input array.\n    >>> sum_string_lens([])\n    0.0\n    >>> sum_string_lens([\"\
    abc\", \"bcd\", \"cde\"])\n    3.0\n    \n*/\ndouble sum_string_lens(string[]\
    \ strings)\n{\n    int idx = 0;\n    double sum = 0;\n    while(idx < strings.length)\n\
    \    {\n        sum += strings[idx].length();\n        idx++;\n    }\n    return\
    \ sum;\n}\n/*\n Return the sum of the lengths of words in the input array.  Words\
    \ are delimited by a space character.\n    >>> sum_string_lens([])\n    0.0\n\
    \    >>> sum_string_lens([\"abc bcd\", \"cde\"])\n    3.0\n    \n*/\ndouble sum_string_lens(string[]\
    \ strings)\n{\n    int idx = 0;\n    double sum = 0;\n    while(idx < strings.length)\n\
    \    {\n        sum += strings[idx].split(\" \").length;\n        idx++;\n   \
    \ }\n    return sum;\n}\n/*\n Return True if the given string contains a given\
    \ substring\n    >>> contains_substring(\"abc def\", \"abc\")\n    True\n    >>>\
    \ contains_substring(\"abc def\", \"def\")\n    False\n    \n*/", "{\n    string\
    \ pre = prefix + \".\";\n    string[] filtered = new string[strings.length];\n\
    \    for(int i = 0; i < strings.length; ++i)\n        if(strings[i].startsWith(pre))\n\
    \            filtered[i] = strings[i];\n    return filtered;\n}\n</code>\n<|/\
    \ a dscore=3 |>\n<| a tags=string,c#,algorithm,filter,string dscore=1 |>\nThis\
    \ is my solution :\n<code>\n    public static string RemoveLastPartOfString(string\
    \ strInput, string strToRemove)\n    {\n        if (strInput.Contains(strToRemove))\n\
    \        {\n            int indexOfStrToRemove = strInput.IndexOf(strToRemove);\n\
    \            strInput = strInput.Substring(0, indexOfStrToRemove);\n        }\n\
    \        return strInput;\n    }\n</code>\n<|/ a |>\n<| a dscore=1 tags=string,c#,algorithm,filter,string\
    \ |>\n<code>\nstring source = \"abc def ghi jkl\";", "{\n\treturn array.filter(strings,\
    \ function(string string){ return string.startsWith(prefix); });\n}\n/*\n Filter\
    \ an input array of strings only for ones that end with a given suffix.\n    >>>\
    \ filter_by_suffix([], \"a\")\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\"\
    , \"cde\", \"array\"], \"a\")\n    [\"abc\"]\n    \n*/\nstring[] filter_by_suffix(string[]\
    \ strings, string suffix) \n{\n\treturn array.filter(strings, function(string\
    \ string){ return string.endsWith(suffix); });\n}", "{\n\tstring[] result = new\
    \ string[strings.length];\n\tfor(int i=0; i<strings.length; ++i)\n\t{\n\t\tif\
    \ (strings[i].StartsWith(prefix))\n\t\t\tresult[i] = strings[i];\n\t}\n\treturn\
    \ result;\n}", "{\n    var filter = new string[strings.length];\n    for(int i\
    \ = 0; i < filter.length; i++) \n    {\n        if(strings[i].StartsWith(prefix))\
    \ filter[i] = strings[i];\n    }\n    return filter;\n}\n/*\n Filter an input\
    \ array of strings only for ones that end with a given suffix.\n    >>> filter_by_suffix([],\
    \ \"a\")\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\"]\n    \n*/\nstring[] filter_by_suffix(string[] strings,\
    \ string suffix) \n{\n    var filter = new string[strings.length];\n    for(int\
    \ i = 0; i < filter.length; i++) \n    {\n        if(strings[i].EndsWith(suffix))\
    \ filter[i] = strings[i];\n    }\n    return filter;\n}\n/*\n Filter an input\
    \ array of strings only for ones that have a given prefix or suffix.\n    >>>\
    \ filter_by_prefix_suffix([], \"a\", \"b\")\n    []\n    >>> filter_by_prefix_suffix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\", \"b\")\n    [\"abc\"]\n    \n*/\n\
    string[] filter_by_prefix_suffix(string[] strings, string prefix, string suffix)\
    \ \n{\n    var filter = new string[strings.length];\n    for(int i = 0; i < filter.length;\
    \ i++) \n    {\n        if(strings[i].StartsWith(prefix) && strings[i].EndsWith(suffix))\
    \ filter[i] = strings[i];\n    }\n    return filter;\n}\n/*\n Given an input array\
    \ of strings remove any element that has an excess length of that string.\n  \
    \  >>> remove_excess_len([\"a\"])\n    []\n    >>> remove_excess_len([\"a\",\"\
    a\",\"a\",\"a\",\"a\",\"a\"])\n    [\"a\"]\n    \n*/\nstring[] remove_excess_len(string[]\
    \ strings) \n{\n    var lens = new int[strings.length];\n    for(int i = 0; i\
    \ < lens.Length; i++) lens[i] = strings[i].Length;\n    lens = remove_excess_len(lens);\n\
    \    var filter = new string[strings.length];\n    for(int i = 0; i < filter.length;\
    \ i++) \n    {\n        if(lens[i] > 0) filter[i] = strings[i];\n    }\n    return\
    \ filter;\n}\n/*\n Given an array of ints return any that have the specified minimum.\n\
    \    >>> find_min([]) \n    0\n    >>> find_min([0]) \n    0\n    >>> find_min([1,2,3])\
    \ \n    1\n    >>> find_min([1,2,3]) \n    1\n    >>> find_min([4,5,5,5]) \n \
    \   4\n    \n*/", "{\n\tstring prefixed = prefix;\n\t\n\tfor(int i = 0, len =\
    \ strings.length; i < len; i++) {\n\t\tif(strings[i].StartsWith(prefixed)) {\n\
    \t\t\treturn strings[i];\n\t\t}\n\t}\n\treturn strings[0];\n}", "{\n    int n\
    \ = strings.length;\n    for(int i = 0; i < n; i++){\n        if (strings[i].StartsWith(prefix))\
    \ return strings[i];\n    }\n    return strings; \n}", "{\n    int len = strings.length;\n\
    \    string[] result = new string[len];\n    int i = 0;\n    foreach(var s in\
    \ strings) {\n        if (s.StartsWith(prefix))\n            result[i++] = s;\n\
    \    }\n    return result;\n}\n</code>\nYou can call it like this:\n<code>\n//\
    \ Example of usage\nstring[] strings = new string[] {\"aaa\", \"bbb\", \"ccc\"\
    , \"ddd\", \"eee\", \"fff\", \"ggg\", \"hhh\"};\nstring[] result = filter_by_prefix(strings,\
    \ \"ff\");\n// result: [\"ff\", \"fff\", \"ggg\", \"hhh\"]\n</code>\n<|/ a dscore=5\
    \ tags=c#,linq,list,arrays,string |>\n<| c |>\nI love the filter_by_prefix method!\n\
    <|/ c |>\n<| c |>\nAwesome! This was exactly what I was looking for.\n<|/ c |>\n\
    <| c |>\nHaving to call `ToList` every time you call `filter_by_prefix` seems\
    \ pretty expensive. Is there a way to avoid this?\n<|/ c |>\n<| c |>\nThis is\
    \ great, but I would suggest to call ToArray in the end, because you then have\
    \ an array and you can modify it without causing side effects (such as adding\
    \ items). Also, ToArray actually creates a copy of the array, so if you have a\
    \ large array, you will not create more than 2 copies.\n<|/ c |>\n<| c |>\nI added\
    \ `ToArray` at the end. It's more straightforward then.\n<|/ c |>\n<| a |>\nIn\
    \ C#, there are many LINQ extension methods that are very powerful, but can be\
    \ overused. So, I've created a library that has a lot of these extension methods\
    \ in it. It has a very small footprint and can be used in a production environment\
    \ with no issues. You can find it here: http://www.codeproject.com/Articles/10294/LINQ-Extension-Methods-Library\n\
    <|/ a tags=c#,linq,list,arrays,string dscore=4 |>\n<| c |>\nI love this library,\
    \ very small! Thanks for the link.\n<|/ c |>\n<| c |>\n- This library is awesome!\
    \  I always wonder why Microsoft didn't include LINQ support in the .NET Framework\
    \ itself, or why people would never use it.\n<|/ c |>\n<| c |>\nThe library has\
    \ become a part of the framework. http://msdn.microsoft.com/en-us/library/bb397941.aspx\n\
    <|/ c |>\n<| a dscore=3 |>\nThis is not a perfect answer to your question, but\
    \ it will hopefully give you the tools you need to solve ", "{\n  var result =\
    \ new string[strings.length];\n  int i = 0;\n  foreach ( string s in strings )\
    \ {\n    bool found = false;\n    for ( int j = 0; j<s.length(); j++ ) {\n   \
    \   if (s[j] == prefix[j]) {\n        found = true;\n        break;\n      }\n\
    \    }\n    if ( !found ) {\n      result[i++] = s;\n    }\n  }\n  return result;\n\
    }\n</code>\n<|/ a tags=c#,algorithm |>\n<| a dscore=0 |>\nThis is an old question\
    \ but I would like to share my answer, because I couldn't find anything that would\
    \ give me the expected result of the question.\nI needed something similar to\
    \ this:\n<code>\npublic class MyObject\n{\n    public int Key { get; set; }\n\
    \    public string Value { get; set; }\n}\n</code>\nAnd I had an array of MyObject\
    \ like this:\n<code>\nvar myArray = new List<MyObject>() {\n    new MyObject()\
    \ { Key = 1, Value = \"a\"},\n    new MyObject() { Key = 2, Value = \"b\"},\n\
    \    new MyObject() { Key = 3, Value = \"c\"},\n};\n</code>\nSo what I wanted\
    \ to do is to check if there were duplicate Keys inside myArray and if so, I would\
    \ want to merge the Value property into one string.\nI found something like this:\n\
    <code>\nList<MyObject> groups = myArray.GroupBy(x => x.Key)\n                \
    \             .Select(x => new MyObject\n                             {\n    \
    \                             Key = x.Key,\n                                 Value\
    \ = string.Join(\",\", x.Select(y => y.Value))\n                             }).ToList();\n\
    </code>\nAnd that is what I was looking for. Here I'm also getting back a list\
    \ of groups, but if I don't need it I can just use x.\nSo that would mean I could\
    \ do something like this:\n<code>\nvar myArray = new List<MyObject>() {\n    new\
    \ MyObject() { Key = 1, Value = \"a\"},\n    new MyObject() { Key = 2, Value =\
    \ \"b\"},\n    new MyObject() { Key = 3, Value = \"c\"},\n};", "{\n\tList<string>\
    \ result = new List<string>();\n\t\n\tforeach (string s in strings) {\n\t\tif\
    \ (s.StartsWith(prefix)) {\n\t\t\tresult.Add(s);\n\t\t}\n\t}\n\t\n\treturn result.ToArray();\n\
    }", "{\n    int length = strings.length;\n    \n    for (int i = 0; i < length;\
    \ i++) {\n        if (strings[i].StartsWith(prefix))\n            return strings[i];\n\
    \    }\n    \n    return null;\n}\n</code>\n<|/ a dscore=2 tags=c#,performance,algorithm,linq,.net\
    \ |>\n<| c |>\nYou don't need to do that. Just use `Any`\n<|/ c |>\n<| c |>\n\
    Thank you for your help! I'm testing this out now and will let you know if it\
    \ works.\n<|/ c |>\n<| c |>\nThe above is definitely the best solution. I'll test\
    \ this and mark this as answered if it works!\n<|/ c |>\n<| a dscore=1 |>\nThis\
    \ should work for you:\n<code>\nvar strs = new[] { \"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\" };\nvar filtered = strs.Where(x => x.StartsWith(\"a\")).ToArray();\n\
    </code>\n<|/ a tags=c#,performance,algorithm,linq,.net |>\n<| c |>\nThe OP is\
    \ looking for a function that does not return a new array.\n<|/ c |>\n<| a tags=c#,performance,algorithm,linq,.net\
    \ |>\nIf you're looking for a more efficient way, you could try the following;\n\
    <code>\nusing System.Linq;\nusing System.Collections.Generic;", "{\n    string[]\
    \ filtered = new string[strings.length];\n    int i = 0;\n    for(; i < strings.length;\
    \ i++)\n    {\n        if(strings[i].StartsWith(prefix))\n            filtered[i++]\
    \ = strings[i];\n    }\n    return filtered;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Nice, simple solution. Also, note that you can simplify your second `for` loop\
    \ to `for (int i = strings.length - 1; i >= 0; i--)`, or use `for (int i = 0;\
    \ i < strings.length; i++)`. `string` arrays index from 0 upwards, so `strings.length\
    \ - 1` evaluates to `strings.length` (which is out of bounds).\n<|/ c |>\n<| a\
    \ tags=c#,string,arrays |>\nYou can use Enumerable.Any extension method:\n<code>\n\
    string[] filtered = strings.Where(s => s.StartsWith(\"a\")).ToArray();\n</code>\n\
    Or use simple foreach loop:\n<code>\nstring[] filtered = new string[strings.length];\n\
    for(int i = 0; i < strings.length; i++)\n    if(strings[i].StartsWith(\"a\"))\n\
    \        filtered[i] = strings[i];\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ tags=c#,string,arrays |>\nYou can use Enumerable.Where:\n<code>\nstring[] filtered\
    \ = strings.Where(s => s.StartsWith(\"a\")).ToArray();\n</code>\n<|/ a |>\n<|\
    \ a tags=c#,string,arrays |>\nYou can use the method Array.Sort(string[] input,\
    \ int startIndex, bool descending)\nExample:\n<code>\nstring[] strings = new string[]\
    \ { \"a\", \"aa\", \"ab\", \"bb\", \"bbb\", \"ba\", \"bb\", \"bc\" };\nArray.Sort(strings,\
    \ 0, true);", "{\n    string[] newstrings = new string[strings.length];\n    int\
    \ i = 0;\n    foreach ( string s in strings ) {\n        if ( s.StartsWith(prefix)\
    \ ) {\n            newstrings[i++] = s;\n        }\n    }\n    return newstrings;\n\
    }", "{\n    foreach (string s in strings)\n    {\n        if (s.StartsWith(prefix))\n\
    \        {\n            yield return s;\n        }\n    }\n}", "{\n    foreach(i:\
    \ string; strings) {\n        if(strings[i].startsWith(prefix)) return strings[i];\n\
    \    }\n    return null;\n}", "{\n    string[] result = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; i++) {\n\tif (strings[i].StartsWith(prefix))\
    \ {\n\t    result[i] = strings[i];\n\t}\n    }\n    return result;\n}\n/*\n Filter\
    \ an input array of strings only for ones that end with a given suffix.\n    >>>\
    \ filter_by_suffix([], \"a\")\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\"\
    , \"cde\", \"array\"], \"a\")\n    [\"abc\"]\n    \n*/\nstring[] filter_by_suffix(string[]\
    \ strings, string suffix) \n{\n    string[] result = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; i++) {\n\tif (strings[i].EndsWith(suffix))\
    \ {\n\t    result[i] = strings[i];\n\t}\n    }\n    return result;\n}\n/*\n Filter\
    \ an input array of strings only for ones that contain a given substring.\n  \
    \  >>> filter_by_contains([], \"a\")\n    []\n    >>> filter_by_contains([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[]\
    \ filter_by_contains(string[] strings, string substring) \n{\n    string[] result\
    \ = new string[strings.length];\n    for (int i = 0; i < strings.length; i++)\
    \ {\n\tif (strings[i].Contains(substring)) {\n\t    result[i] = strings[i];\n\t\
    }\n    }\n    return result;\n}\n/*\n Filter an input array of strings only for\
    \ ones that have a specified suffix.\n    >>> filter_by_suffix([], \"a\")\n  \
    \  []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\"\
    )\n    [\"abc\"]\n    \n*/\nstring[] filter_by_suffix(string[] strings, string\
    \ suffix) \n{\n    string[] result = new string[strings.length];\n    for (int\
    \ i = 0; i < strings.length; i++) {\n\tif (strings[i].EndsWith(suffix)) {\n\t\
    \    result[i] = strings[i];\n\t}\n    }\n    return result;\n}\n/*\n Filter an\
    \ input array of strings only for ones that have a specified prefix.\n    >>>\
    \ filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\"\
    , \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_prefix(string[]\
    \ strings, string prefix) \n{\n    string[] result = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; i++) {\n\tif (strings[i].StartsWith(prefix))\
    \ {\n\t    result[i] = strings[i];\n\t}\n    }\n    return result;\n}\n/*\n Filter\
    \ an input array of strings only for the ones that don't have a specified suffix.\n\
    \    >>> filter_by_suffix([], \"a\")\n    []\n    >>> filter_by_suffix([\"abc\"\
    , \"bcd\", \"cde\", \"", "{\n    string[] filtered = new string[strings.length];\n\
    \    for (int i = 0; i < filtered.length; i++)\n    {\n        string s = strings[i];\n\
    \        if (s.StartsWith(prefix))\n            filtered[i] = s;\n    }\n    return\
    \ filtered;\n}\n/*\n Filter an input array of strings only for ones that start\
    \ with a given prefix.\n    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n\
    */\nstring filter_by_prefix(string strings, string prefix)\n{\n    string filtered\
    \ = \"\";\n    for (int i = 0; i < strings.length; i++)\n    {\n        string\
    \ s = strings[i];\n        if (s.StartsWith(prefix))\n            filtered = s;\n\
    \    }\n    return filtered;\n}\n/*\n Filter an input array of strings only for\
    \ ones that start with a given prefix.\n    >>> filter_by_prefix([], \"a\")\n\
    \    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\"\
    )\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_prefix(string[] strings,\
    \ string[] prefixes)\n{\n    string[] filtered = new string[strings.length];\n\
    \    for (int i = 0; i < filtered.length; i++)\n    {\n        string s = strings[i];\n\
    \        for (int j = 0; j < prefixes.length; j++)\n        {\n            if\
    \ (s.StartsWith(prefixes[j]))\n                filtered[i] = s;\n        }\n \
    \   }\n    return filtered;\n}\n/*\n Filter an input array of strings only for\
    \ ones that start with a given prefix.\n    >>> filter_by_prefix([], \"a\")\n\
    \    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\"\
    )\n    [\"abc\", \"array\"]\n    \n*/\nstring filter_by_prefix(string strings,\
    \ string[] prefixes)\n{\n    string filtered = \"\";\n    for (int i = 0; i <\
    \ strings.length; i++)\n    {\n        string s = strings[i];\n        for (int\
    \ j = 0; j < prefixes.length; j++)\n        {\n            if (s.StartsWith(prefixes[j]))\n\
    \                filtered = s;\n        }\n    }\n    return filtered;\n}\n/*\n\
    \ Filter an input array of strings only for ones that start with a given prefix.\n\
    \    >>> filter_by_prefix([], \"a\")\n    []\n    >>> filter_by_prefix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[]\
    \ filter_by_prefix(string[] strings, string[][] prefixes)\n{\n    string[] filtered\
    \ = new string[strings.length];\n    for (int i = 0; i < filtered.length; i++)\n\
    \    {\n        string s = strings[i];", "{\n    int i = _find(strings, prefix);\n\
    \    if (i < 0)\n        return strings;\n    string[] rval = new string[strings.length-1];\n\
    \    for(int i=0;i<strings.length-1;i++)\n    {\n        if(strings[i].StartsWith(prefix))\n\
    \        {\n            rval[i]=strings[i];\n        }\n    }\n    return rval;\n\
    }", "{\n    var results = new string[strings.length];\n    for (int i = 0; i <\
    \ strings.length; ++i)\n    {\n        if (strings[i].StartsWith(prefix))\n  \
    \          results[i] = strings[i];\n    }\n    return results;\n}", "{\n\tstring[]\
    \ out;\n\t\n\tfor(int i = 0; i < strings.length; ++i)\n\t{\n\t\tif (strings[i].StartsWith(prefix))\n\
    \t\t{\n\t\t\tout.Add(strings[i]);\n\t\t}\n\t}\n\treturn out;\n}\n/*\n Filter an\
    \ input array of strings only for those that end with a given suffix.\n    >>>\
    \ filter_by_suffix([], \"a\")\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\"\
    , \"cde\", \"array\"], \"a\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_suffix(string[]\
    \ strings, string suffix)\n{\n\tstring[] out;\n\t\n\tfor(int i = 0; i < strings.length;\
    \ ++i)\n\t{\n\t\tif (strings[i].EndsWith(suffix))\n\t\t{\n\t\t\tout.Add(strings[i]);\n\
    \t\t}\n\t}\n\treturn out;\n}\n/*\n Filter an input array of strings only for those\
    \ that contain the given prefix.\n    >>> filter_by_contains([], \"abc\")\n  \
    \  []\n    >>> filter_by_contains([\"abc\", \"bcd\", \"cde\", \"array\"], \"b\"\
    )\n    [\"bcd\", \"array\"]\n    \n*/\nstring[] filter_by_contains(string[] strings,\
    \ string prefix)\n{\n\tstring[] out;\n\t\n\tfor(int i = 0; i < strings.length;\
    \ ++i)\n\t{\n\t\tif (strings[i].Contains(prefix))\n\t\t{\n\t\t\tout.Add(strings[i]);\n\
    \t\t}\n\t}\n\treturn out;\n}\n/*\n Filter an input array of strings only for those\
    \ that contain the given suffix.\n    >>> filter_by_contains_suffix([], \"abc\"\
    )\n    []\n    >>> filter_by_contains_suffix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"c\")\n    [\"cde\", \"array\"]\n    \n*/\nstring[] filter_by_contains_suffix(string[]\
    \ strings, string suffix)\n{\n\tstring[] out;\n\t\n\tfor(int i = 0; i < strings.length;\
    \ ++i)\n\t{\n\t\tif (strings[i].Contains(suffix))\n\t\t{\n\t\t\tout.Add(strings[i]);\n\
    \t\t}\n\t}\n\treturn out;\n}\n/*\n Filter an input array of strings only for those\
    \ that contain the given prefix and suffix.\n    >>> filter_by_contains_contains_both([],\
    \ \"abc\")\n    []\n    >>> filter_by_contains_contains_both([\"abc\", \"bcd\"\
    , \"cde\", \"array\"], \"b\")\n    [\"bcd\", \"array\"]\n    \n*/\nstring[] filter_by_contains_contains_both(string[]\
    \ strings, string prefix, string suffix)\n{\n\tstring[] out;\n\t\n\tfor(int i\
    \ = 0; i < strings.length; ++i)\n\t{\n\t\tif (strings[i].Contains(prefix) && strings[i].Contains(suffix))\n\
    \t\t{\n\t\t\tout.Add(strings[i]);\n\t\t}\n\t}\n\treturn out;\n", "{\n    foreach(string[]\
    \ s in strings) {\n        if(s.StartsWith(prefix)) {\n            yield return\
    \ s;\n        }\n    }\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI think I found\
    \ the solution to your problem. Hope it helps!\n<code>\nimport std.stdio;\nimport\
    \ std.array;", "{\n\tstring[] result = new string[strings.length];\n\tfor (int\
    \ i = 0; i < strings.length; ++i)\n\t\tif (strings[i].StartsWith(prefix))\n\t\t\
    \tresult[i] = strings[i];\n\t\n\treturn result;\n}", "{\n    int pos = 0;\n  \
    \  foreach(string s in strings) {\n        if(s.StartsWith(prefix)) {\n      \
    \      yield return s;\n            pos += s.length;\n        }\n    }\n}", "{\n\
    \    foreach(string s in strings) {\n        if (s.StartsWith(prefix)) {\n   \
    \         strings[strings.indexOf(s)]=null;\n        }\n    }\n    return strings;\n\
    }", "{\n    string[] results = new string[strings.length];\n    for (int i = 0;\
    \ i < strings.length; ++i) {\n        if (strings[i].StartsWith(prefix))\n   \
    \         results[i] = strings[i];\n    }\n    return results;\n}", "{\n    for(string[]\
    \ s: strings) \n        if(s.StartsWith(prefix)) \n            \n            \
    \    return s;\n    return strings; \n}", "{\n    var found = false;\n    foreach(string[]\
    \ element in strings) {\n        if(element.startsWith(prefix)) {\n          \
    \  found = true;\n            yield return element;\n        }\n    }\n    if(!found)\
    \ throw new Exception(\"No prefix found for \"+prefix);\n}\n/*\n Filter an input\
    \ array of strings only for ones that end with a given suffix.\n    >>> filter_by_suffix([],\
    \ \"ed\")\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"ed\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_suffix(string[]\
    \ strings, string suffix) \n{\n    var found = false;\n    foreach(string[] element\
    \ in strings) {\n        if(element.endsWith(suffix)) {\n            found = true;\n\
    \            yield return element;\n        }\n    }\n    if(!found) throw new\
    \ Exception(\"No suffix found for \"+suffix);\n}\n/*\n Filter an input array of\
    \ strings for ones that contain a given substring.\n    >>> filter_by_contains([],\
    \ \"bc\")\n    []\n    >>> filter_by_contains([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"bc\")\n    [\"bcd\", \"array\"]\n    \n*/\nstring[] filter_by_contains(string[]\
    \ strings, string substring) \n{\n    var found = false;\n    foreach(string[]\
    \ element in strings) {\n        if(element.contains(substring)) {\n         \
    \   found = true;\n            yield return element;\n        }\n    }\n    if(!found)\
    \ throw new Exception(\"No substring found for \"+substring);\n}\n/*\n Filter\
    \ an input array of strings for ones that match a given pattern. \n All elements\
    \ of the array must match the pattern for it to match. \n    >>> filter_by_pattern([],\
    \ \"[0-9]\")\n    []\n    >>> filter_by_pattern([\"abc\", \"bcd\", \"cde\", \"\
    array\"], \"[0-9]\")\n    [\"abc\", \"array\"]\n    \n*/\nstring[] filter_by_pattern(string[]\
    \ strings, string pattern) \n{\n    var found = false;\n    foreach(string[] element\
    \ in strings) {\n        if(element.matches(\".*\"+pattern+\".*\")) {\n      \
    \      found = true;\n            yield return element;\n        }\n    }\n  \
    \  if(!found) throw new Exception(\"No pattern found for \"+pattern);\n}\n</code>\n\
    <|/ a dscore=4 tags=c#,string,linq,arrays |>\n<| c |>\nAren't there issues with\
    \ `yield` returning the elements as they were in the list? It would make more\
    \ sense to use `yield break` after the `yield` calls. And wouldn't it be better\
    \ to return the array with the elements removed instead of using `yield break`?\n\
    <|/ c |>\n<| ", "{\n    return strings.filter(s => s.startsWith(prefix));\n}\n\
    </code>\nIf you don't need it to be exactly the same but only that strings that\
    \ start with your prefix you might be able to use a regular expression.\n<|/ a\
    \ dscore=4 |>\n<| a tags=c#,string,split |>\n<code>\nvar result = string.Join(\"\
    ,\", input.Where(s => s.StartsWith(\"a\")).ToArray());\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nAgreed, however I think this might be a bit of a performance hit\
    \ (iterating twice over the collection).\n<|/ c |>\n<| c |>\n- It is not O(n)\
    \ though. It's O(1) in that it's iterating over the collection only once.\n<|/\
    \ c |>\n<| a |>\n<code>\nvar result = string.Join(\",\", input.Split(new char[]\
    \ {','}, StringSplitOptions.RemoveEmptyEntries)\n    .Where(s => s.StartsWith(\"\
    a\")).ToArray());\n</code>\n<|/ a dscore=3 tags=c#,string,split |>\n<| a |>\n\
    You could use LINQ and a regular expression:\n<code>\nvar result = string.Join(\"\
    ,\", Regex.Matches(input, @\"^a\").OfType<Match>().Select(m => m.Value));\n</code>\n\
    <|/ a dscore=3 tags=c#,string,split |>\n<| a dscore=3 tags=c#,string,split |>\n\
    You can split on ',' then filter the resulting array for ones that start with\
    \ 'a'\n<code>\nstring input = \"a,b,c,d,e,f,a\";", "{\n    for(int i = 0; i <\
    \ strings.length; i++)\n    {\n        if(strings[i].StartsWith(prefix))\n   \
    \     {\n            return new string[] { strings[i] };\n        }\n    }\n \
    \   return new string[0];\n}", "{\n\tint[] indices;\n\tfor (int i = 0; i < strings.length;\
    \ ++i)\n\t{\n\t\tif (strings[i].StartsWith(prefix))\n\t\t{\n\t\t\tindices = new\
    \ int[i];\n\t\t\tindices[i] = i;\n\t\t}\n\t\telse\n\t\t\tindices = null;\n\t}\n\
    \t\n\treturn filter_by_indices(strings, indices);\n}", "{\n    var re = new RegExp(\"\
    ^\" + prefix);\n    var r = new List<string>();\n    for (string s : strings)\
    \ {\n        if (re.test(s)) {\n            r.add(s);\n        }\n    }\n    return\
    \ r.ToArray();\n}", "{\n    string[] result = new string[strings.length];\n  \
    \  for(int i = 0; i<strings.length; i++){\n        if(strings[i].StartsWith(prefix)){\n\
    \            result[i] = strings[i];\n        }\n    }\n    return result;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\nYou can try to use LINQ and a lambda expression.\n\
    <code>\nvar results = new List<string>(); ", "{\n  var results = new List<string>();\n\
    \  \n  foreach (string s in strings)\n  {\n    if (s.StartsWith(prefix))\n   \
    \   results.Add(s);\n  }\n  \n  return results.ToArray();\n}\n/*\n Filter an input\
    \ array of strings only for ones that end with a given suffix.\n    >>> filter_by_prefix([],\
    \ \"a\")\n    []\n    >>> filter_by_prefix([\"ab\", \"abc\", \"array\"], \"a\"\
    )\n    [\"ab\", \"abc\"]\n    \n*/\nstring[] filter_by_prefix(string[] strings,\
    \ string suffix) \n{\n  var results = new List<string>();\n  \n  foreach (string\
    \ s in strings)\n  {\n    if (s.EndsWith(suffix))\n      results.Add(s);\n  }\n\
    \  \n  return results.ToArray();\n}\n/*\n Get the full name of a type\n    \n\
    \ >>> get_full_name(\"System.Collections.IEnumerable\")\n \"System.Collections.Generic.IEnumerable`1\"\
    \n \n >>> get_full_name(\"System.ValueTuple`2\")\n \"System.ValueTuple`2[[System.String,\
    \ System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.String,\
    \ mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\"\
    \n \n >>> get_full_name(\"System.ValueTuple`2[[System.String, System.Private.CoreLib,\
    \ Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.String,\
    \ mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\"\
    )\n \"System.ValueTuple`2[[System.String, System.Private.CoreLib, Version=4.0.0.0,\
    \ Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.String, mscorlib,\
    \ Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\"\n \n >>>\
    \ get_full_name(\"System.ValueTuple`2\")\n \"System.ValueTuple`2[[System.String,\
    \ System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.String,\
    \ mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\"\
    \n \n >>> get_full_name(\"System.ValueTuple`2[[System.", "{\n    foreach(i: string)\
    \ \n        if (i.StartsWith(prefix)) \n            strings = RemoveAt(strings,\
    \ i);\n    return strings;\n}\n/*\n Find the first index of a character in one\
    \ string in another.\n    >>> string1 = \"abcabc\"\n    >>> string2 = \"abc\"\n\
    \    >>> find(string1, string2, \"c\")\n    2\n    \n*/", "{\n    foreach(string[]\
    \ str, string[] arr) \n        if (str.Length > prefix.Length)\n            if\
    \ (str[0].StartsWith(prefix, true, true))\n                arr.Add(str[0]);\n\
    \    return arr;\n}\n</code>\n<|/ a tags=linq,.net,c# dscore=1 |>\n<| a dscore=1\
    \ |>\nOne liner for those who like to avoid foreach loops:\n<code>\nvar prefixes\
    \ = new List<string> { \"a\", \"ab\", \"abc\", \"abd\" };\nvar result = _source.Where(x\
    \ => prefixes.Select(y => y.Length).Min() <= x.StartsWith(y));\n</code>\n<|/ a\
    \ tags=linq,.net,c# |>\n<| c |>\nIf one uses this solution, then it's worth noting\
    \ that the `Min()` should be calculated *once* in advance of the query, rather\
    \ than on each iteration. Also note that this will return false positives, e.g.\
    \ `\"ab\"` will match `\"abc\"`.\n<|/ c |>\n<| c |>\n- yep, thanks for the note.\
    \ I'd just like to point out one more thing - it does work for all prefixes, not\
    \ just those with \"ab\".\n<|/ c |>\n<| c |>\nYes, but as I said in my answer,\
    \ it would be better to compute the minimum length before you start the query.\
    \ That would avoid any false positives.\n<|/ c |>\n<| c |>\n- ah yes, I see what\
    \ you mean. Thx!\n<|/ c |>\n<| a |>\nIn C# 7 you can do this with LINQ Select\
    \ method:\n<code>\nvar prefixes = new []{ \"a\", \"ab\", \"abc\", \"abd\" };\n\
    var result = _source.Where(x => prefixes.Select(y => y.Length).Min() <= x.StartsWith(y));\n\
    </code>\n<|/ a tags=linq,.net,c# dscore=1 |>\n<| a tags=linq,.net,c# |>\nHow about\
    \ this\n<code>\nprivate static bool CheckForPrefix(string prefix)\n{\n    foreach\
    \ (var s in new string[] { \"a\", \"ab\", \"abc\", \"abd\" })\n    {\n       \
    \ if (s.Length <= prefix.Length)\n        {\n            if (s.StartsWith(prefix))\n\
    \            {\n                return true;\n            }\n        }\n    }\n\
    \    return false;\n}", "{\n    string[] result = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; i++) \n    {\n        if (strings[i].StartsWith(prefix))\
    \ \n        {\n            result[i] = strings[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n Filter an input array of strings only for ones that end with\
    \ a given suffix.\n    >>> filter_by_suffix([], \"d\")\n    []\n    >>> filter_by_suffix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"d\")\n    [\"bcd\", \"array\"]\n    \n\
    */\nstring[] filter_by_suffix(string[] strings, string suffix) \n{\n    string[]\
    \ result = new string[strings.length];\n    for (int i = 0; i < strings.length;\
    \ i++) \n    {\n        if (strings[i].EndsWith(suffix)) \n        {\n       \
    \     result[i] = strings[i];\n        }\n    }\n    return result;\n}", "{\n\
    \  // First scan over the array and copy the elements that do not start with the\
    \ given prefix\n  var results = new string[strings.length];\n  var startsWithPrefix\
    \ = new int[strings.length];\n  var index = 0;\n  foreach (var s in strings) {\n\
    \    startsWithPrefix[index] = strings[index].StartsWith(prefix);\n    results[index]\
    \ = s;\n    index++;\n  }\n  // If any elements start with the given prefix, remove\
    \ them\n  var removed = 0;\n  foreach (var s in strings) {\n    if (startsWithPrefix[removed])\
    \ { removed++; continue; }\n    results[results.Length - removed] = s;\n  }\n\
    \  return results;\n}\n/*\n Filter an input array of strings only for ones that\
    \ end with a given suffix.\n    >>> filter_by_suffix([], \"e\")\n    []\n    >>>\
    \ filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"e\")\n    [\"abc\"\
    , \"array\"]\n    \n*/\nstring[] filter_by_suffix(string[] strings, string suffix)\
    \ \n{\n  // First scan over the array and copy the elements that do not end with\
    \ the given suffix\n  var results = new string[strings.length];\n  var endsWithSuffix\
    \ = new int[strings.length];\n  var index = 0;\n  foreach (var s in strings) {\n\
    \    endsWithSuffix[index] = strings[index].EndsWith(suffix);\n    results[index]\
    \ = s;\n    index++;\n  }\n  // If any elements end with the given suffix, remove\
    \ them\n  var removed = 0;\n  foreach (var s in strings) {\n    if (endsWithSuffix[removed])\
    \ { removed++; continue; }\n    results[results.Length - removed] = s;\n  }\n\
    \  return results;\n}\n/*\n Filter an input array of strings only for ones that\
    \ contain a given substring.\n    >>> filter_by_contains([], \"ab\")\n    []\n\
    \    >>> filter_by_contains([\"abc\", \"bcd\", \"cde\", \"array\"], \"ab\")\n\
    \    [\"abc\"]\n    \n*/\nstring[] filter_by_contains(string[] strings, string\
    \ substring) \n{\n  // First scan over the array and copy the elements that do\
    \ not contain a given substring\n  var results = new string[strings.length];\n\
    \  var contains = new int[strings.length];\n  var index = 0;\n  foreach (var s\
    \ in strings) {\n    contains[index] = strings[index].Contains(substring);\n \
    \   results[index] = s;\n    index++;\n  }\n  // If any elements contain the given\
    \ substring, remove them\n  var removed = 0;\n  foreach (var s in strings) {\n\
    \    if (contains[removed]) { removed++; continue; }\n    results[results.Length\
    \ - removed] = s;\n  }\n  return results;\n}\n/*\n Filter an ", "{\n  if (strings\
    \ == null || strings.length == 0) \n    return strings;", "{\n    var results\
    \ = new string[strings.length];\n    int i = 0;\n    for (; i < strings.length;\
    \ ++i)\n    {\n        if (strings[i].StartsWith(prefix))\n            results[i\
    \ - i] = strings[i];\n    }\n    return results;\n}", "{\n    var result = new\
    \ Array[int](strings.length);\n    for(int i = 0; i < strings.length; ++i) {\n\
    \        if (strings[i].StartsWith(prefix)) {\n            result[i] = strings[i];\n\
    \        }\n    }\n    return result;\n}\n/* \nFilter an input array of strings\
    \ to those that contain a given suffix.\n    >>> filter_by_suffix([], \"ab\")\n\
    \    []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"ab\"\
    )\n    [\"abc\"]\n*/\nstring[] filter_by_suffix(string[] strings, string suffix)\
    \ \n{\n    var result = new Array[int](strings.length);\n    for(int i = 0; i\
    \ < strings.length; ++i) {\n        if (strings[i].EndsWith(suffix)) {\n     \
    \       result[i] = strings[i];\n        }\n    }\n    return result;\n}\n/* \n\
    Filter an input array of strings to those that begin with a given prefix.\n  \
    \  >>> filter_by_prefix([], \"ab\")\n    []\n    >>> filter_by_prefix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"ab\")\n    [\"abc\", \"array\"]\n*/\nstring[]\
    \ filter_by_prefix(string[] strings, string prefix)\n{\n    var result = new Array[int](strings.length);\n\
    \    for(int i = 0; i < strings.length; ++i) {\n        if (strings[i].StartsWith(prefix))\
    \ {\n            result[i] = strings[i];\n        }\n    }\n    return result;\n\
    }\n/* \nFilter an input array of strings to those that end with a given suffix.\n\
    \    >>> filter_by_suffix([], \"ab\")\n    []\n    >>> filter_by_suffix([\"abc\"\
    , \"bcd\", \"cde\", \"array\"], \"ab\")\n    [\"abc\"]\n*/\nstring[] filter_by_suffix(string[]\
    \ strings, string suffix)\n{\n    var result = new Array[int](strings.length);\n\
    \    for(int i = 0; i < strings.length; ++i) {\n        if (strings[i].EndsWith(suffix))\
    \ {\n            result[i] = strings[i];\n        }\n    }\n    return result;\n\
    }\n/* \nGiven an input array of strings, this function will return a string that\
    \ contains the input \nstring repeated n times.\n    >>> repeat_string(\"abc\"\
    , 2)\n    \"abcabc\"\n    \n*/\nstring repeat_string(string s, int n) \n{\n  \
    \  var result = new String[int](s.length + n);\n    for(int i = 0; i < n; ++i)\
    \ {\n        result[i] = s;\n    }\n    for(int i = n; i < result.Length; ++i)\
    \ {\n        result[i] = s[n - 1];\n    }\n    return string.Join(\"\", result);\n\
    }\n/*\nGiven an input array of strings, this function will return a string that\
    \ contains the input \nstring repeated n times.\n    >>> repeat_string(\"ab\"\
    , 2)\n    \"abab\"\n    \n*/\nstring repeat_string(string s, int n) \n{", "{\n\
    \  std.foreach(strings, string=> { \n    if (string.startsWith(prefix)) { \n \
    \     yield string; \n    } \n  }); \n}", "{\n    foreach(i32 i,i32 len) strings[len..]\n\
    \        foreach (string string) {\n            string sub = string.slice(0, prefix);\n\
    \            if (string.startswith(sub))\n                strings[i] = string;\n\
    \        }\n    return strings;\n}", "{\n  \n  // Initialization:\n  var results\
    \ = new List<string>();\n  \n  // Filter the input strings one by one:\n  for(int\
    \ i = 0; i < strings.Length; ++i)\n  {\n    if(strings[i].StartsWith(prefix))\n\
    \      results.Add(strings[i]);\n  }\n  \n  // Return the results:\n  return results.ToArray();\n\
    }\n/*\n Filter an input array of strings only for ones that start with a given\
    \ prefix.\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"\
    a\")\n    [\"abc\", \"array\"]\n    \n*/\n</code>\n<|/ a dscore=1 |>\n<| a tags=arrays,c#,loops,.net,foreach\
    \ |>\nI wrote this extension method for arrays and lists that is similar to the\
    \ LINQ version of this:\n<code>\npublic static T[] Filter<T>(this T[] elements,\
    \ Predicate<T> predicate) \n{\n    var filteredElements = new List<T>();\n   \
    \ foreach (var element in elements)\n    {\n        if (predicate(element))\n\
    \        {\n            filteredElements.Add(element);\n        }\n    }\n   \
    \ return filteredElements.ToArray();\n}\n</code>\nYou can use it as follows:\n\
    <code>\nstring[] stringArray = ...\nList<string> stringList = ...\nvar filtered\
    \ = stringArray.Filter(s => s.StartsWith(\"a\"));\nvar filtered2 = stringList.Filter(s\
    \ => s.StartsWith(\"a\"));\n</code>\nThis works because IEnumerable<T> implements\
    \ IEnumerable and List<T> implements IList. Both of these classes have an Add\
    \ method that takes one parameter, which is what you would put in brackets. Because\
    \ this Add method also exists in both classes, calling Add on an array or list\
    \ will result in the array or list having the item added to it, as long as you\
    \ pass in the correct parameter.\nNote that this extension method does not require\
    \ the elements to be in an array, list, or other collection type. This extension\
    \ method also allows the element to be a nullable type. This is how I used it\
    \ for the following code:\n<code>\nstring[] stringArray = ...\nList<string> stringList\
    \ = ...\nvar filtered = stringArray.Filter(s => s != null);\nvar filtered2 = stringList.Filter(s\
    \ => s != null);\n</code>\nThis allows me to use this extension method on every\
    \ type of element that has a valid implementation of Add.\n<|/ a dscore=1 |>\n\
    <| a |>\nMy version uses Linq\n<code>\nstring[] stringArray = ...\nList<string>\
    \ stringList = ...\nList<string> filteredList = stringList.Where(s => s.StartsWith(\"\
    a\")).ToList();\n</code>\n<|/ a tags=arrays,c#,loop", "{\n    int[] lengths =\
    \ new int[strings.length];\n    for(int i = 0; i < strings.length; ++i)\n    \
    \    lengths[i] = strings[i].length();\n    \n    int[] starts = new int[lengths.length];\n\
    \    int index = 0;\n    for(int i = 0; i < lengths.length; ++i)\n        starts[i]\
    \ = index;\n        \n    int[] ends = new int[lengths.length];\n    starts[0]\
    \ = 0;\n    ends[lengths.length - 1] = lengths[lengths.length - 1];\n    \n  \
    \  int maxIndex = lengths.length - 1;\n    int maxValue = 0;\n    for(int i =\
    \ 0; i < lengths.length; ++i)\n    {\n        if(lengths[i] < prefix.length())\n\
    \            continue;\n        \n        int startIndex = starts[i];\n      \
    \  int endIndex = ends[i];\n        int length = endIndex - startIndex + 1;\n\
    \        \n        int prefixLength = prefix.length();\n        int minValue =\
    \ maxValue;\n        for(int j = startIndex; j < endIndex; ++j)\n        {\n \
    \           if(lengths[j] < prefixLength)\n                continue;\n       \
    \     \n            int value = lengths[j] - prefixLength;\n            if(minValue\
    \ > value)\n            {\n                minValue = value;\n               \
    \ maxIndex = j;\n            }\n        }\n        \n        string result = strings[maxIndex];\n\
    \        strings[maxIndex] = strings[startIndex];\n        strings[startIndex]\
    \ = result;\n        \n        maxValue = minValue;\n        starts[i] = maxIndex\
    \ + 1;\n        ends[i] = startIndex + 1;\n    }\n    \n    return strings;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis works well for the case in which the prefix\
    \ is at the beginning of the string. I would like to handle cases where this prefix\
    \ appears at any position in the string - would you be able to give me a pointer\
    \ on that?\n<|/ c |>\n<| c |>\nYou can see how this is done in the `filter_by_prefix`\
    \ function. The key is that we first calculate the lengths of each string and\
    \ then use the `starts` array to find the \"start\" of each string.\n<|/ c |>\n\
    <| c |>\nOk, thanks a lot for your help. That works well now!\n<|/ c |>\n<| c\
    \ |>\nHow do you get to `ends[i]` in `starts[ends[i]]` ?\n<|/ c |>\n<| c |>\n\
    I guess, I was too quick to comment. `ends` has the same length as `starts`.\n\
    <|/ c |>\n<| a |>\nAnother approach is to create a function that finds all substrings\
    \ of the desired prefix:\n<code>\nstring prefix = \"a\";\nvar input = \"abcab\"\
    ;\nvar result = input.Substring(0, input.IndexOf(input.Substring(prefix.Length))\
    \ +\n                             prefix.Length", "{\n    string[] result = new\
    \ string[strings.length];\n    for (int i = 0; i < strings.length; i++)\n    {\n\
    \        if (strings[i].StartsWith(prefix))\n        {\n            result[i]\
    \ = strings[i];\n        }\n    }\n    return result;\n}", "{\n    int[] prefix_length\
    \ = prefix.getLength();\n    int[] strings_length = strings.length - prefix_length\
    \ + 1;\n    int[] starts = new int[strings_length];\n    \n    int i;\n    for(i\
    \ = 0; i < starts.length; ++i)\n        starts[i] = prefix_length + strings[i].indexOf(prefix);\n\
    \    \n    int[] ends = new int[strings_length];\n    ends[ends.length - 1] =\
    \ strings[strings_length - 1].length();\n    \n    int j;\n    for(j = 0; j <\
    \ ends.length; ++j)\n        ends[j] = prefix_length + strings[j].indexOf(prefix,\
    \ ends[j] - prefix_length);\n    \n    int[] indices = new int[strings_length];\n\
    \    int[] prefix_lengths = new int[strings_length];\n    \n    for(i = 0; i <\
    \ strings_length; ++i)\n    {\n        int start = starts[i];\n        int end\
    \ = ends[i];\n        \n        indices[i] = i;\n        prefix_lengths[i] = end\
    \ - start;\n    }\n    \n    int[] ret = new int[indices.length];\n    int index\
    \ = 0;\n    for(i = 0; i < strings_length; ++i)\n    {\n        int start = starts[i];\n\
    \        int end = ends[i];\n        \n        int start = start;\n        int\
    \ end = end - prefix_lengths[i];\n        \n        while(start < end)\n     \
    \       ret[index++] = strings[indices[i]++];\n    }\n    \n    return ret;\n}",
  "{\n  string[] result = new string[strings.length];\n  int idx = 0;\n  for (int\
    \ i = 0; i < strings.length; ++i) {\n    if (strings[i].StartsWith(prefix)) \n\
    \      result[idx++] = strings[i];\n  }\n  return result;\n}", "{\n    // TODO:\
    \ Rewrite using for-loop and LINQ\n    for(int i = 0; i < strings.length; i++)\n\
    \    {\n        if(strings[i].StartsWith(prefix))\n        {\n            string\
    \ tempStr = strings[i];\n            strings[i] = \"\";\n            strings.RemoveAt(i);\n\
    \            strings.Insert(0, tempStr);\n        }\n    }\n    return strings;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis would have been my first suggestion;\
    \ however it's not `O(n)` but `O(n^2)`, which isn't really ideal either. I think\
    \ the solutions posted above are much better.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n\
    var a = new string[]\n{\n    \"hello\", \"hello\", \"world\", \"world\"\n};",
  "{\n    if(strings.length == 0 || strings[0] == null || prefix == null)\n      \
    \  return strings;\n    if(strings[0].StartsWith(prefix))\n        return strings;\n\
    \    for(int i = 0; i < strings.length; i++)\n    {\n        if(strings[i].StartsWith(prefix))\n\
    \            strings[i] = strings[i].Substring(prefix.Length);\n    }\n    return\
    \ strings;\n}", "{\n    int count = 0;\n    for (string s : strings) \n    {\n\
    \        if (s.StartsWith(prefix)) \n        {\n            count++;\n       \
    \ }\n    }\n    if (count == 0) \n    {\n        return strings;\n    }\n    int\
    \ size = strings.length;\n    string[] res = new string[size];\n    for (int i\
    \ = 0; i < size; i++) \n    {\n        if (strings[i].StartsWith(prefix)) \n \
    \       {\n            res[i] = strings[i];\n        }\n    }\n    return res;\n\
    }", "{\n    if (strings == null || strings.length == 0 || prefix == null || prefix.length\
    \ == 0) {\n        return strings;\n    }\n    \n    int prefixLen = prefix.length;\n\
    \    \n    int len = strings.length;\n    \n    if (len == 0 || prefixLen > strings[0].length)\n\
    \        return strings;\n    \n    // Copy all the strings whose first character\
    \ is not equal to the prefix.\n    List<string> newStrings = new List<string>(len);\n\
    \    for (int i = 0; i < len; i++) {\n        if (!strings[i].StartsWith(prefix))\n\
    \            newStrings.Add(strings[i]);\n    }\n    \n    return newStrings.ToArray();\n\
    }", "{\n    if (strings.isEmpty() || prefix == \"\") {\n        return strings;\n\
    \    }\n    \n    int i = 0;\n    \n    for (; strings[i] != null; ++i, strings[i]\
    \ = null);\n    \n    string prefix = prefix.toLowerCase();\n    \n    for (i\
    \ = 0; strings[i] != null; ++i) {\n        if (strings[i].startsWith(prefix))\
    \ {\n            strings[i] = strings[i].substring(prefix.length());\n       \
    \ }\n    }\n    \n    return strings;\n}", "{\n\tstring[] result = new string[0];\n\
    \tfor(int i = 0; i < strings.length; ++i)\n\t{\n\t\tif (strings[i].StartsWith(prefix))\n\
    \t\t{\n\t\t\tif (result.Length == 0)\n\t\t\t\tresult = new string[] {strings[i]};\n\
    \t\t\telse\n\t\t\t\tresult = new string[] {result[0], strings[i]};\n\t\t}\n\t\
    }\n\treturn result;\n}", "{\n    string[] result = new string[strings.length];\n\
    \    int i = 0;\n    foreach(string s in strings)\n    {\n        if(s.StartsWith(prefix))\n\
    \            result[i++] = s;\n    }\n    return result;\n}", "{\n    return strings.where(s\
    \ => s.startsWith(prefix));\n}", "{\n    int[] res = new int[strings.length];\n\
    \    for (int i = 0; i < strings.length; ++i)\n    {\n        if (strings[i].StartsWith(prefix))\n\
    \            res[i] = i;\n    }\n    return strings[res];\n}", "{\n\tif (strings.length\
    \ == 0)\n\t\treturn strings;\n\t\n\tif (strings[0].length < prefix.length)\n\t\
    \treturn strings;", "{\n    int i;\n    for(i = 0; i < strings.length; i++)\n\
    \    {\n        if (strings[i].StartsWith(prefix))\n        {\n            strings[i]\
    \ = strings[i].Remove(0, prefix.Length);\n            break;\n        }\n    }\n\
    \    return strings;\n}\n</code>\n<|/ a dscore=2 tags=.net,regex,c# |>\n<| a dscore=2\
    \ |>\nHere's a slightly different approach that avoids regular expressions.  It\
    \ splits the array into separate arrays for matching prefix and non-prefix elements.\
    \  It then loops through the prefix elements and replaces them with the non-prefix\
    \ versions.\n<code>\nusing System;\nusing System.Collections.Generic;", "{\n \
    \   string[] array = new string[strings.length];\n    int i = 0;\n    foreach\
    \ (string s in strings) {\n        if (s.StartsWith(prefix)) {\n            array[i++]\
    \ = s;\n        }\n    }\n    return array;\n}\n/*\n Filter an input array of\
    \ strings only for ones that end with a given suffix.\n    >>> filter_by_suffix([],\
    \ \"a\")\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"a\")\n    [\"abc\"]\n    \n*/\nstring[] filter_by_suffix(string[] strings,\
    \ string suffix) \n{\n    string[] array = new string[strings.length];\n    int\
    \ i = 0;\n    foreach (string s in strings) {\n        if (s.EndsWith(suffix))\
    \ {\n            array[i++] = s;\n        }\n    }\n    return array;\n}\n/*\n\
    \ Filter an input array of strings only for ones that start with a given prefix.\n\
    \    >>> filter_by_prefix_and_suffix([], \"a\", \"c\")\n    []\n    >>> filter_by_prefix_and_suffix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\", \"c\")\n    [\"abc\"]\n    \n*/\n\
    string[] filter_by_prefix_and_suffix(string[] strings, string prefix, string suffix)\
    \ \n{\n    string[] array = new string[strings.length];\n    int i = 0;\n    foreach\
    \ (string s in strings) {\n        if (s.StartsWith(prefix) && s.EndsWith(suffix))\
    \ {\n            array[i++] = s;\n        }\n    }\n    return array;\n}\n/*\n\
    \ Filter an input array of strings only for ones that end with a given suffix.\n\
    \    >>> filter_by_prefix_and_suffix([], \"a\", \"c\")\n    []\n    >>> filter_by_prefix_and_suffix([\"\
    abc\", \"bcd\", \"cde\", \"array\"], \"a\", \"c\")\n    [\"abc\"]\n    \n*/\n\
    string[] filter_by_prefix_and_suffix_string(string[] strings, string prefix, string\
    \ suffix) \n{\n    string[] array = new string[strings.length];\n    int i = 0;\n\
    \    foreach (string s in strings) {\n        if (s.StartsWith(prefix) && s.EndsWith(suffix))\
    \ {\n            array[i++] = s;\n        }\n    }\n    return array;\n}\n</code>\n\
    I hope it helps.\n<|/ a dscore=2 |>\n<| c |>\nThis is good, but I think it can\
    \ be optimized more by avoiding creating extra string arrays. For example, you\
    \ could just do the string concatenation in-place in the for loop. This also allows\
    \ you to get rid of the `int i` variable.\n<|/ c |>\n<| c |>\nI agree, this would\
    \ be better. I'll implement and modify my answer later today and I'll ", "{\n\
    \  return filter_by_prefix(strings, prefix, \"\");\n}", "{\n    var filtered =\
    \ new List<string>();\n    foreach(var s in strings) \n    {\n        if (s.StartsWith(prefix))\
    \ filtered.Add(s);\n    }\n    return filtered.ToArray();\n}", "{\n    var result\
    \ = new string[strings.length];\n    for (int i = 0; i < strings.length; i++)\
    \ {\n        if (strings[i].StartsWith(prefix)) {\n            result[i] = strings[i];\n\
    \        }\n    }\n    return result;\n}", "{\n    string[] result = new string[strings.length];\n\
    \    for(int i = 0; i < strings.length; ++i)\n    {\n        if(strings[i].StartsWith(prefix))\n\
    \            result[i] = strings[i];\n    }\n    return result;\n}\n/*\n Filter\
    \ an input array of strings only for ones that end with a given suffix.\n    >>>\
    \ filter_by_suffix([], \"a\")\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\"\
    , \"cde\", \"array\"], \"a\")\n    [\"abc\"]\n*/\nstring[] filter_by_suffix(string[]\
    \ strings, string suffix) \n{\n    string[] result = new string[strings.length];\n\
    \    for(int i = 0; i < strings.length; ++i)\n    {\n        if(strings[i].EndsWith(suffix))\n\
    \            result[i] = strings[i];\n    }\n    return result;\n}\n/*\n Filter\
    \ an input array of strings only for ones that contain a given substring\n   \
    \ (in any position).\n    >>> filter_by_substring([], \"abc\")\n    []\n    >>>\
    \ filter_by_substring([\"abc\", \"bcd\", \"cde\", \"array\"], \"abc\")\n    [\"\
    abc\"]\n    \n*/\nstring[] filter_by_substring(string[] strings, string substring)\
    \ \n{\n    string[] result = new string[strings.length];\n    for(int i = 0; i\
    \ < strings.length; ++i)\n    {\n        if(strings[i].Contains(substring))\n\
    \            result[i] = strings[i];\n    }\n    return result;\n}\n/*\n Given\
    \ a string, replace all characters that are not letters or digits \n    by '_'.\n\
    \    \n    >>> replace_non_letters_or_digits(\"abc 123\")\n    'abc_123'\n   \
    \ \n*/\nstring replace_non_letters_or_digits(string string)\n{\n    string result\
    \ = \"\";\n    for(int i = 0; i < string.Length(); ++i)\n    {\n        if(!Char.IsLetter(string[i])\
    \ && !Char.IsDigit(string[i]))\n        {\n            result += string[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n Given a string, replace all characters\
    \ that are not letters or digits,\n    but are not spaces, with a '-'.\n    \n\
    \    >>> replace_non_letters_or_digits(\"abc 123\")\n    'abc-123'\n    \n*/\n\
    string replace_non_letters_or_digits_with_hyphen(string string)\n{\n    string\
    \ result = \"\";\n    for(int i = 0; i < string.Length(); ++i)\n    {\n      \
    \  if(!Char.IsLetter(string[i]) && !Char.IsDigit(string[i]) && !Char.IsWhiteSpace(string[i]))\n\
    \        {\n            result += string[i];\n        }\n    }\n    return result;\n\
    }\n/*\n Given a string, remove all leading and trailing whitespace.\n    \n  \
    \  >>> ", "{\n    int[] count = new int[strings.length];\n    int pos = 0;\n \
    \   for(int i = 0; i < strings.length; i++)\n    {\n        if (strings[i].length\
    \ >= prefix.length && strings[i].substring(0, prefix.length).Equals(prefix))\n\
    \        {\n            count[i]++;\n        }\n    }\n    \n    string[] result\
    \ = new string[strings.length];\n    for (int i = 0; i < strings.length; i++)\n\
    \    {\n        if (count[i] > 0)\n        {\n            result[pos++] = strings[i];\n\
    \        }\n    }\n    \n    return result;\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ tags=c#,arrays,performance |>\nThis solution uses a Dictionary to keep track\
    \ of all unique prefixes and only processes strings starting with that prefix:\n\
    <code>\nstring[] prefixes = { \"a\", \"b\", \"c\" };\nstring[] strings = new string[]\
    \ { \"a\", \"a\", \"a\", \"b\", \"b\", \"c\", \"d\", \"c\", \"e\", \"f\", \"g\"\
    , \"h\" };", "{\n    int start = strings.indexOf(\"[\" + prefix + \"]\");\n  \
    \  while(start != -1) \n    {\n        strings[start] = strings[start].substring(prefix.length());\n\
    \        start = strings.indexOf(\"[\" + prefix + \"]\", start + 1);\n    }\n\
    \    return strings;\n}", "{\n\tint start = 0;\n\tfor (int i = 0; i < strings.length;\
    \ i++) \n\t{\n\t\tif (strings[i].length >= prefix.length && strings[i].substring(0,\
    \ prefix.length).equals(prefix)) \n\t\t{\n\t\t\tfor (int j = i; j < strings.length;\
    \ j++) \n\t\t\t{\n\t\t\t\tstrings[j] = strings[j].substring(prefix.length);\n\t\
    \t\t}\n\t\t\tstrings[strings.length-1] = \"\";\n\t\t\ti = strings.length-1;\n\t\
    \t}\n\t}\n\treturn strings;\n}\n//", "{\n    for(int i = 0; i < strings.length;\
    \ i++)\n    {\n        if(strings[i].startsWith(prefix))\n        {\n        \
    \    strings[i] = strings[i].substring(prefix.length());\n        }\n    }\n \
    \   return strings;\n}\n/*\n Filter an input array of strings only for ones that\
    \ end with a given suffix.\n    >>> filter_by_suffix([], \"a\")\n    []\n    >>>\
    \ filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\")\n    [\"abc\"\
    ]\n    \n*/\nstring[] filter_by_suffix(string[] strings, string suffix) \n{\n\
    \    for(int i = 0; i < strings.length; i++)\n    {\n        if(strings[i].endsWith(suffix))\n\
    \        {\n            strings[i] = strings[i].substring(0, strings[i].length()\
    \ - suffix.length());\n        }\n    }\n    return strings;\n}\n/*\n Filter an\
    \ input array of strings only for ones that both start and end with the given\
    \ prefix.\n    >>> filter_by_prefix_and_suffix([], \"a\", \"b\")\n    []\n   \
    \ >>> filter_by_prefix_and_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\"\
    , \"b\")\n    [\"abc\"]\n    \n*/\nstring[] filter_by_prefix_and_suffix(string[]\
    \ strings, string prefix, string suffix) \n{\n    for(int i = 0; i < strings.length;\
    \ i++)\n    {\n        if(strings[i].startsWith(prefix) && strings[i].endsWith(suffix))\n\
    \        {\n            strings[i] = strings[i].substring(prefix.length(), strings[i].length()\
    \ - suffix.length());\n        }\n    }\n    return strings;\n}\n/*\n Filter an\
    \ input array of strings only for ones that have the given prefix.\n    >>> filter_by_prefix([],\
    \ \"a\")\n    []\n    >>> filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"\
    ], \"ab\")\n    [\"abc\"]\n    \n*/\nstring[] filter_by_prefix(string[] strings,\
    \ string prefix)\n{\n    for(int i = 0; i < strings.length; i++)\n    {\n    \
    \    if(strings[i].startsWith(prefix))\n        {\n            strings[i] = strings[i].substring(prefix.length());\n\
    \        }\n    }\n    return strings;\n}\n/*\n Filter an input array of strings\
    \ only for ones that have the given suffix.\n    >>> filter_by_suffix([], \"a\"\
    )\n    []\n    >>> filter_by_suffix([\"abc\", \"bcd\", \"cde\", \"array\"], \"\
    a\")\n    [\"abc\"]\n    \n*/\nstring[] filter_by_suffix(string[] strings, string\
    \ suffix)\n{\n    for(int i = 0; i < strings.length; i++)\n    {\n        if(strings[i].endsWith(suffix))\n\
    \        {\n            strings[i] = strings[i].substring(0, strings[i].length()\
    \ - suffix.length());\n        }\n    }\n    return strings;\n}\n/*\n Filter an\
    \ input array of strings only for one", "{\n    var result = new string[strings.length];\n\
    \    var found = new bool[strings.length];\n    int prefixLength = prefix.Length;\n\
    \    int i;", "{\n  string[] result;\n  \n  for (int i=0; i<strings.length; i++)\
    \ {\n    if (strings[i].StartsWith(prefix)) {\n      result = new string[] { strings[i]\
    \ };\n      break;\n    }\n  }\n  \n  return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
