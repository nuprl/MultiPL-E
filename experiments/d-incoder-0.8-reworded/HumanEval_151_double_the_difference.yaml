name: HumanEval_151_double_the_difference
language: d
prompt: "import std.math;\n/*\n\n    Given an array of numbers, return the sum of\
  \ squares of the numbers\n    in the array that are odd. Ignore numbers that are\
  \ negative or not integers.\n    \n    >>> double_the_difference([1L, 3L, 2L, 0L])\n\
  \    10L\n    >>> double_the_difference([-1L, -2L, 0L])\n    0L\n    >>> double_the_difference([9L,\
  \ -2L])\n    81L\n    >>> double_the_difference([0L])\n    0L\n   \n    If the input\
  \ array is empty, return 0.\n    \n*/\nlong double_the_difference(float[] lst) \n"
tests: "unittest\n{\n    alias candidate = double_the_difference;\n\n    assert(candidate([])\
  \ == 0L);\n    assert(candidate([5.0, 4.0]) == 25L);\n    assert(candidate([0.1,\
  \ 0.2, 0.3]) == 0L);\n    assert(candidate([-10.0, -20.0, -30.0]) == 0L);\n    assert(candidate([-1.0,\
  \ -2.0, 8.0]) == 0L);\n    assert(candidate([0.2, 3.0, 5.0]) == 34L);\n    assert(candidate([-9.0,\
  \ -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0]) == 165L);\n}\nvoid main(){}"
completions: ["{\n    long sum = 0;\n    for (int i = 0; i < lst.Length; i++)\n  \
    \  {\n        long value = lst[i];\n        if (value >= 0)\n        {\n     \
    \       sum += value*value;\n        }\n        else\n        {\n            sum\
    \ += value;\n        }\n    }\n    return sum;\n}\n</code>\n<|/ a tags=c#,arrays\
    \ |>\n<| a |>\nI haven't tested this, but I think it should be fine.  I believe\
    \ it will work.  Just pass it an array with the numbers, and the length of the\
    \ array.  \n<code>\npublic static void main(String[] args) \n{", "{\n    int n\
    \ = (int)std.math.getLength(lst);\n    long sum = 0;\n    for (int i = 0; i<n;\
    \ ++i)\n        if (lst[i] % 2 == 1)\n            sum += lst[i];\n    return sum;\n\
    }\n'''", "{\n    long sum = 0;\n    for (float i : lst) \n        if (i % 2 ==\
    \ 1)\n            sum += i * i;\n    return sum;\n}\n</code>\n<|/ a tags=arrays,java\
    \ |>\n<| c |>\nThis is an amazing solution. I've never thought of it like this.\
    \ Thanks!\n<|/ c |>\n<| a tags=arrays,java dscore=1 |>\nThis solution works for\
    \ me in c#\n<code>\npublic static long SumOfSquareOfOdd(int[] inputArray)\n{\n\
    \    long sum = 0;\n    for (int i = 0; i < inputArray.Length; i++)\n    {\n \
    \       if (inputArray[i] % 2 == 1)\n            sum += inputArray[i] * inputArray[i];\n\
    \    }\n    return sum;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\npublic static\
    \ void main(String[] args) {\n    int arr[] = { 1, 2, 3, 4 };", "{\n    int sum\
    \ = 0;\n    for (int i=0; i<lst.length; i++) \n    {\n        if (lst[i] % 2 ==\
    \ 1)\n            sum += lst[i] * lst[i];\n    }\n    return sum;\n}\n\"\"\"",
  "{\n    long sum = 0;\n    for (int i = 0; i < lst.Length; i++)\n    {\n       \
    \ if (lst[i] % 2 == 1)\n        {\n            sum += lst[i];\n        }\n   \
    \ }\n    return sum;\n}", "{\n    long sum = 0;\n    for(int i=0; i<lst.length;\
    \ ++i)\n    {\n        if(lst[i] % 2 == 1)\n            sum += lst[i];\n    }\n\
    \    return sum;\n}\n/*", "{\n  if (lst == null || lst.Length == 0)\n    return\
    \ 0;\n    \n  long sum = 0;\n  \n  foreach (long item in lst)\n  {\n    if (item\
    \ % 2 == 1)\n      sum += item;\n  }\n  \n  return sum;\n}\n/*", "{\n  int i,\
    \ sum;\n  long result;", "{\n  int i;\n  long sum = 0;\n  if (lst.Length != 0)\n\
    \  {\n    for (i = 0; i < lst.Length; i++)\n    {\n      if (lst[i] % 2 == 1)\n\
    \      {\n        sum = sum + pow(lst[i], 2);\n      }\n    }\n  }\n  return sum;\n\
    }\n/*", "{\n    long ans = 0.0;\n    \n    foreach (float num in lst) {\n    \
    \    if (num > 0.0) ans += num * num;\n    }\n    return ans;\n}\n/*", "{\n\t\
    long result = 0;\n\tforeach(float x in lst)\n\t{\n\t\tif (fabs(x) > 1) continue;\n\
    \t\tif (x < 0) continue;\n\t\tif (fmod(x, 2) == 1) result += x;\n\t}\n\treturn\
    \ result;\n}", "{\n    long sum = 0;\n    \n    for (int i = 0; i < lst.Length;\
    \ ++i)\n    {\n        if (lst[i] > 0)\n        {\n            sum += Math.Pow((double)lst[i],\
    \ 2);\n        }\n    }\n    \n    return sum;\n}\n/*", "{\n    int i;\n    long\
    \ sum = 0;\n    for(i = 0; lst[i] > 0; i++){\n        if (lst[i] % 2 == 1)\n \
    \           sum += lst[i];\n    }\n    return sum;\n}", "{\n    long sum = 0;\n\
    \    int i;\n    for (i = 0; i < lst.length; ++i)\n    {\n        if (i % 2 ==\
    \ 1)\n            sum += lst[i];\n    }\n    return sum;\n}\n/*", "{\n    int\
    \ i, sum = 0;\n    for(i=0; i<lst.length; i++)\n    {\n        if(lst[i]%2 ==\
    \ 1)\n            sum += lst[i];\n    }\n    return sum;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=c#,arrays dscore=2 |>\nThis answer is based on a Java code snippet\
    \ posted on the following page:\nhttps://forum.codechef.com/threads/76705-How-do-you-sum-the-square-of-numbers-in-an-array\n\
    <code>\npublic static int sumOfSquare(int [] array){", "{\n  int i = 0;\n  int\
    \ j = 0;\n  long sum = 0;\n  while (i < lst.lenght) \n  {\n    j = 0;\n    while\
    \ (j <= i) { \n      if (lst[j] % 2 == 1)\n      {\n        sum += lst[j];\n \
    \     }\n      j++;\n    }\n    i++;\n  }\n  return sum;\n}\n</code>\n<|/ a dscore=0\
    \ tags=arrays,c++,vector |>\n<| c |>\nWhat happens if the array is empty?\n<|/\
    \ c |>\n<| c |>\nThe code checks if \"lst\" is empty before entering the loop.\
    \ If it is empty, the code returns the default value 0. I don't know if that is\
    \ what you want, but it seems logical to do that in my opinion.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nJust use std::accumulate with a lambda function:\n<code>\n#include\
    \ <vector>\n#include <numeric>", "{\n  int N = lst.length;\n  long sum = 0;",
  "{\n    if (lst.Length > 0)\n    {\n        long sum = 0;\n        foreach (float\
    \ i in lst)\n        {\n            if (i % 2 != 0)\n                sum += i;\n\
    \        }\n        return sum;\n    }\n    else\n        return 0;\n}\n</code>\n\
    <|/ a tags=c#,function,c++ |>\n<| c |>\nThis doesn't answer the question at all.\
    \ How does it answer the question asked in the title?\n<|/ c |>\n<| a tags=c#,function,c++\
    \ |>\n<code>\n static int Sum_Of_Odd_Numbers(int[] arr)\n        {\n         \
    \   if (arr.Length > 0)\n            {\n                int sum = 0;\n       \
    \         for (int i = 0; i != arr.Length; ++i)\n                {\n         \
    \           if (arr[i] % 2 != 0)\n                    {\n                    \
    \    sum += arr[i];\n                    }\n                }\n              \
    \  return sum;\n            }\n            else\n                return 0;\n \
    \       }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWhat about a non int array? What\
    \ happens then?\n<|/ c |>\n<| c |>\nYou might want to check the code first. Besides,\
    \ your answer is not exactly what the OP wanted.\n<|/ c |>\n<| c |>\ni think he\
    \ wants sum of odd numbers if any\n<|/ c |>\n<| a |>\n<code>", "{\n    long sum\
    \ = 0;\n    for (float v : lst) \n    {\n        if (v > 0 && v % 2 == 1)\n  \
    \          sum += v;\n    }\n    return sum;\n}\n</code>\n<|/ a tags=performance,arrays,c++,algorithm,sorting\
    \ dscore=1 |>\n<| a dscore=1 |>\nI think it's pretty easy to understand but hard\
    \ to implement\nThe algorithm is as follows:\n<code>\nInput: A[] = { 0, 1, 2,\
    \ 3, 4, 5 }\nOutput: sum = 0", "{\n    long sum = 0;\n    bool even = true;\n\
    \    \n    for (int i=0; i < lst.length; ++i)\n    {\n        if (even)\n    \
    \    {\n            if (lst[i] % 2 == 1)\n                sum += lst[i];\n   \
    \     }\n        else\n        {\n            if (lst[i] % 2 == 0)\n         \
    \       sum += lst[i];\n        }\n        even = !even;\n    }\n    return sum;\n\
    }\n</cell>\n<code language=julia-1.0>\nusing Plots\ngr()\n</cell>\n<code language=julia-1.0>\n\
    x = 1:1000\ny = double_the_difference(x)\n</cell>\n<code language=julia-1.0>\n\
    # Plot the result and compare with Python.\nplot(x, y)\n</cell>\n<text>\nExercise\
    \ 5.2", "{\n    long sum = 0;\n    foreach (long x in lst)\n    {\n        if\
    \ (x != 0.0F && x % 2 == 1) sum += x;\n    }\n    return sum;\n}", "{\n\tint i;\
    \ \n\tlong sum=0;", "{\n    long sum = 0;\n    for (float f : lst)\n        if\
    \ (f > 0)\n            sum += f * f;\n    return sum;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nWhat happens if `lst` contains negative numbers?\n<|/ c |>\n<| a tags=java\
    \ |>\nI think this is a very good task for stream API.\n<code>\n long result =\
    \ IntStream.of(floatArray).filter(x -> x > 0).sum();\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\nUsing streams:\n<code>\nArrays.stream(floatArray).filter(f\
    \ -> f > 0l).sum();\n</code>\n<|/ a tags=java |>\n<| a dscore=1 tags=java |>\n\
    Here's a solution that uses an IntStream and reduces:\n<code>\npublic class Test\
    \ {", "{\n\tlong sum = 0;\n\tfor (int i=0; i<lst.length; i++) \n\t{\n\t\tif (lst[i]\
    \ % 2 != 0) \n\t\t{\n\t\t\tsum += lst[i] * lst[i];\n\t\t}\n\t}\n\treturn sum;\n\
    }", "{\n    int i = 0;\n    long sum = 0;\n    for(i=0; i<lst.Length; i++)\n \
    \   {\n        if (lst[i] % 2 != 0)\n        {\n            sum += lst[i]*lst[i];\n\
    \        }\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    int i;\n  \
    \  float x;\n    \n    for (i=0; i<lst.length; i++) \n    {\n        x = lst[i];\n\
    \        if (x < 0) \n        {\n            sum -= x;\n            x += 1.0;\n\
    \        }\n        else \n        {\n            sum += x;\n        }\n    }\n\
    \    return sum;\n}\n/*", "{\n    long result = 0;\n    \n    for (float x : lst)\
    \ {\n        if (x != 0) {\n            result += ((long)(x * x));\n        }\n\
    \    }\n    \n    return result;\n}", "{\n    int i = 0;\n    long sum = 0;\n\
    \    while (i < lst.Length) {\n        if (lst[i] % 2 == 1) {\n            sum\
    \ += lst[i];\n        }\n        i++;\n    }\n    return sum;\n}\n</code>\n<|/\
    \ a dscore=0 tags=c#,arrays |>\n<| a dscore=0 |>\nAn alternative solution\n<code>\n\
    public static long SumOdds(int[] array)\n{\n    return array.Where(x => x % 2\
    \ != 0).Sum();\n}\n</code>\n<|/ a tags=c#,arrays |>\n<| a dscore=0 |>\nAnother\
    \ way to do it without any loop:\n<code>\npublic static long SumOdds(int[] array)\n\
    {\n    long sum = 0;\n    foreach (var num in array)\n    {\n        if (num %\
    \ 2 != 0)\n        {\n            sum += num;\n        }\n    }\n    return sum;\n\
    }\n</code>\n<|/ a tags=c#,arrays |>\n<| a tags=c#,arrays |>\nI like this one and\
    \ I wrote it based on my teachers' notes. I tested it with some input values,\
    \ including an empty array and negative numbers and it works perfectly. \n<code>\n\
    public class SumOfOdds\n{\n    public static void Main(string[] args)\n    {\n\
    \        int[] array = { 1, 3, 5, 7, 9, 11, 13, 17, 19 };", "{\n    long sum =\
    \ 0;\n    for (int i = 0; i < lst.len(); i++)\n        if (lst[i] != 0.0f)\n \
    \           sum += pow(lst[i], 2.0);\n    return sum;\n}", "{\n\tlong sum = 0;\n\
    \t\n\tfor(int i = 0; i < lst.length; i++)\n\t{\n\t\tif(lst[i] < 0)\n\t\t{\n\t\t\
    \treturn sum;\n\t\t}\n\t\t\n\t\tsum += lst[i];\n\t}\n\t\n\treturn sum;\n}", "{\n\
    \    int i, j, sum = 0;", "{\n    long sum = 0;\n    int n = lst.Length;\n   \
    \ int i;\n    for(i=0; i<n; ++i)\n        if(!(i%2))\n            sum += lst[i];\n\
    \    return sum;\n}\n/*", "{\n    long sum = 0;\n    long total = 0;\n    long\
    \ x = 0;\n    \n    for (int i = 0; i < lst.Length; i++)\n    {\n        x = lst[i];\n\
    \        if ((x % 2) == 1)\n        {\n            sum += x;\n        }\n    \
    \    else\n        {\n            total *= x;\n        }\n    }\n    \n    return\
    \ total;\n}\n/*", "{\n  long sum = 0;\n  int i = 0;\n  \n  while (i < lst.size())\
    \ {\n    if (!(lst[i] % 2L))\n      sum += lst[i];\n    ++i;\n  }\n  \n  return\
    \ sum;\n}\n/*****************************************************************************/\n\
    /*\n    Copyright (c) 2012, Nikolaus Efstrata\n    All rights reserved.", "{\n\
    \    long sum = 0;\n    int len = std.array.length(lst);\n    for (int i = 0;\
    \ i < len; ++i)\n    {\n        if (std.math.pow(long.parse(lst[i]), 2) != long.parse(lst[i]))\n\
    \        {\n            if (lst[i] == 0)\n            {\n                return\
    \ 0;\n            }\n            else\n            {\n                sum += long.parse(lst[i]);\n\
    \            }\n        }\n    }\n    return sum;\n}", "{\n    if (lst.length\
    \ == 0)\n    {\n        return 0;\n    }\n    \n    long sum = 0;\n    for (int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if (lst[i] % 2 == 1)\n        {\n\
    \            sum += lst[i];\n        }\n    }\n    return sum;\n}", "{\n    long\
    \ sum = 0;\n    foreach (float f in lst) \n    {\n        sum += std.math.pow(f\
    \ - floor(f), 2);\n    }\n    return sum;\n}", "{\n\tlong sum = 0L;\n\tfor (int\
    \ i = 0; i < lst.size(); ++i) {\n\t\tif (lst[i] % 2 == 1L) {\n\t\t\tsum += lst[i];\n\
    \t\t}\n\t}\n\treturn sum;\n}\n/*", "{\n\tint i;\n\tlong sum = 0;\n\tif (lst.Length\
    \ == 0)\n\t\treturn 0;\n\tfor (i = 0; i < lst.Length; i++)\n\t{\n\t\tdouble d\
    \ = lst[i];\n\t\tif (d % 2 == 1)\n\t\t\tsum += d * d;\n\t}\n\treturn sum;\n}",
  "{\n    long total=0;\n    foreach(float x,lst) {\n        if(!(x<0.0f)) total+=x*x;\n\
    \    }\n    return total;\n}", "{\n    long result = 0L;", "{\n    int idx = 0;\n\
    \    long sum = 0;\n    while (idx < lst.Length)\n    {\n        float num = lst[idx];\n\
    \        if (num > 0)\n        {\n            sum += num * num;\n            idx++;\n\
    \        }\n        else\n        {\n            // Skip negative numbers\n  \
    \          idx++;\n        }\n    }\n    return sum;\n}\n</code>\n<|/ a tags=c#\
    \ |>\n<| c |>\nThe idea is good, but there is a problem with the last case: double_the_difference([9L,\
    \ -2L]) gives 81 instead of 81.\n<|/ c |>\n<| a tags=c# |>\n<code>", "{\n    long\
    \ sum = 0;\n    for (int i = 0; i < lst.Length; ++i) \n    {\n        if (lst[i]\
    \ >= 0) \n        {\n            sum += lst[i] * lst[i];\n        }\n        else\
    \ \n        {\n            return 0;\n        }\n    }\n    return sum;\n}\n/*",
  "{\n    long result = 0;\n    for(int i = 0; i < lst.size(); i++)\n    {\n     \
    \   if(lst[i] < 0)\n        {\n            result -= lst[i];\n        }\n    \
    \    else\n        {\n            result += lst[i];\n        }\n    }\n    return\
    \ result;\n}", "{\n    long sum = 0;\n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        if (lst[i] % 2 == 1) // odd number\n        {\n            sum\
    \ += lst[i];\n        }\n    }\n    return sum;\n}", "{\n    long ret = 0L;\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] < 0L || lst[i]\
    \ % 2L != 0L)\n        {\n            ret += lst[i] * lst[i];\n        }\n   \
    \ }\n    return ret;\n}", "{\n    long sum = 0;\n    for (int i = 0; i < lst.Length;\
    \ i++)\n    {\n        if (lst[i] > 0) \n        {\n            sum += lst[i];\n\
    \        }\n    }\n    return sum;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhy\
    \ are you using recursion to solve this problem when you can use a loop?\n<|/\
    \ c |>\n<| c |>\nRecursion is the best way to solve this problem that I have come\
    \ across.\n<|/ c |>\n<| c |>\nI guess this is because my professor always states\
    \ that recursion is always the best way to solve a problem. Besides that, your\
    \ solution is correct and I am going to use it. Thank you\n<|/ c |>\n<| c |>\n\
    Recursion is *not* always the best way to solve a problem. It is *not* always\
    \ the best way to solve a problem with any kind of reasonable complexity or performance\
    \ requirement that you might have. In some cases, recursion has its own benefits\
    \ and is therefore a good solution.\n<|/ c |>\n<| c |>\nIf you're going to use\
    \ recursion to solve a problem, then you can also use loops to solve it. The benefit\
    \ that recursion has in solving problems is that you can do it more easily, which\
    \ can often lead to simpler programs. Loops often require more lines of code and\
    \ complexity. Recursion often requires an extra variable in order to track the\
    \ \"path\" back up the recursion. Some problems require loops, but many problems\
    \ require recursion.\n<|/ c |>\n<| a tags=c#,arrays |>\n<code>", "{\n    long\
    \ sum = 0;\n    for (int i=0; i < lst.size(); i++) {\n        if (is_odd(lst[i]))\
    \ {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}", "{\n \
    \   long sum = 0;\n    foreach (i, v) lst {\n        if (v%2 == 1) sum += v;\n\
    \    }\n    return sum;\n}\n</code>\n<|/ a |>\n<| c |>\nYou don't have to do any\
    \ looping, `sum` will work just fine\n<|/ c |>\n<| c |>\nAgreed, no looping or\
    \ anything else, just the native `Array` type.  I'll update my answer to include\
    \ a code sample.\n<|/ c |>\n<| a |>\nAn easy solution:\n<code>\n(myArray filter\
    \ odd) reduce(0, +);\n</code>\n<|/ a tags=sum,numbers,arrays dscore=3 |>\n<| a\
    \ dscore=3 |>\nA solution in Haskell using the same functions as you provided\
    \ in your question:\n<code>\nimport Data.Array", "{\n    long sum = 0;\n    int\
    \ i;\n    for (i = 0; i < lst.length; i++) \n    {\n        if (lst[i] % 2 ==\
    \ 1) \n        {\n            sum += lst[i];\n        }\n    }\n    return sum;\n\
    }", "{\n  int i = 0;\n  long sum = 0;\n  if ( !lst.length || lst.length == 0 )\
    \ {\n    return sum;\n  }\n  while (i < lst.length ) {\n    if (lst[i] % 2 ==\
    \ 1) {\n      sum += lst[i];\n    }\n    i += 1;\n  }\n  return sum;\n}", "{\n\
    \    long sum = 0;\n    int count = 0;\n    for(int i = 0; i < lst.size(); i++)\n\
    \    {\n        sum += lst[i] * lst[i];\n        if(lst[i] > 0 && lst[i] % 2 !=\
    \ 0)\n            count++;\n    }\n    if(count > 0)\n        return sum / count;\n\
    \    else\n        return 0;\n}\n</code>\n<|/ a tags=c++,arrays,c,function,algorithm\
    \ |>\n<| c |>\nThis fails to handle the empty array case.\n<|/ c |>\n<| c |>\n\
    I've fixed the problem\n<|/ c |>\n<| c |>\nI think you mean to return sum/count\
    \ instead of sum/lstsize\n<|/ c |>\n<| c |>\nI mean that if `count` is 0, then\
    \ `sum` will not be divided by `count` so the return value will be wrong.\n<|/\
    \ c |>\n<| c |>\nAh, yes, I see where you are going with that now. Thx\n<|/ c\
    \ |>\n<| a tags=c++,arrays,c,function,algorithm |>\nSince your language is C++,\
    \ why don't you use STL algorithm functions?\n<code>\nstd::vector<int> v = {1,2,3};",
  "{\n    long result = 0;\n    for(int i = 0; i < lst.length; ++i)\n    {\n     \
    \   if(!std.is_number(lst[i]))\n            throw new Exception(\"Invalid argument:\
    \ \" + lst[i]);\n        \n        if(!std.is_int(lst[i]) && !std.is_float(lst[i]))\n\
    \            throw new Exception(\"Invalid argument: \" + lst[i]);\n        \n\
    \        if(std.is_int(lst[i]) && std.is_odd(lst[i]))\n        {\n           \
    \ result += lst[i] * lst[i];\n        }\n    }\n    return result;\n}", "{\n\t\
    int i;\n\tlong sum = 0;", "{\n    int sum = 0;\n    for(int i = 0; i < lst.length;\
    \ i++) \n    {\n        if(lst[i] % 2 == 0) \n        {\n            sum += lst[i]*lst[i];\n\
    \        }\n    }\n    return sum;\n}\n/*", "{\n  long sum = 0;\n  \n  for (int\
    \ i=0; i<lst.size(); ++i) {\n    if (lst[i] >= 0)\n      sum += lst[i]*lst[i];\n\
    \  }\n  \n  return sum;\n}\n</code>\n<|/ a |>\n<| a tags=floating-point,c,floating-point\
    \ |>\nThe best solution I came up with is this:\n<code>", "{\n\tlong total = 0L;\n\
    \tif (lst != null) \n\t{\n\t\tforeach(double  d in lst) \n\t\t{\n\t\t\tif (isodd(d))\
    \ \n\t\t\t{\n\t\t\t\ttotal += d*d;\n\t\t\t}\n\t\t}\n\t}\n\treturn total;\n}",
  "{\n\tlong sum = 0;\n\tfor (int i = 0; i < lst.length; i++)\n\t{\n\t\tif (lst[i]%2\
    \ == 1)\n\t\t\tsum += lst[i];\n\t}\n\treturn sum;\n}", "{\n    long result = 0;\n\
    \    int i;\n    int length = lst.length;\n    for (i = 0; i < length; i++) {\n\
    \        if(lst[i] % 2 != 0)\n            result += lst[i];\n    }\n    return\
    \ result;\n}\n/*", "{\n\tif (lst.length==0)\n\t\treturn 0L;", "{\n    long result\
    \ = 0;\n    \n\tforeach(float f in lst)\n    {\n\tif(f>0)\n\t{\n\t    if(f % 2!=0)\n\
    \t    {\n\t\tresult += ((long)f)*((long)f);\n\t    }\n\t}\n    }\n    return std.math.pow(result,0.5);\n\
    }\nlong double_the_difference(long long int[] lst) \n{\n    long result = 0;\n\
    \    \n\tforeach(int i in lst)\n    {\n\tif(i>0)\n\t{\n\t    if(i%2 != 0)\n\t\
    \    {\n\t\tresult += ((long)i)*((long)i);\n\t    }\n\t}\n    }\n    return std.math.pow(result,0.5);\n\
    }\nlong double_the_difference(double [] lst) \n{\n    long result = 0;\n    \n\
    \tforeach(double d in lst)\n    {\n\tif(d>0)\n\t{\n\t    if(d % 2 != 0)\n\t  \
    \  {\n\t\tresult += (d*d);\n\t    }\n\t}\n    }\n    return std.math.pow(result,0.5);\n\
    }\nlong double_the_difference(int [] lst) \n{\n    long result = 0;\n    \n\t\
    foreach(int i in lst)\n    {\n\tif(i>0)\n\t{\n\t    if(i%2 != 0)\n\t    {\n\t\t\
    result += (i*i);\n\t    }\n\t}\n    }\n    return std.math.pow(result,0.5);\n}",
  "{\n  long sum = 0;\n  for (int i = 0; i < lst.size(); i++) \n  {\n    if (!(lst[i]\
    \ > 0)) \n    {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n}\n\
    </code>\n<|/ a tags=arrays,algorithm |>\n<| c |>\nIf `lst` is empty (as per OP)\
    \ then `sum` will remain zero.\n<|/ c |>\n<| c |>\nyep, this is because I didn't\
    \ test the case with empty array.\n<|/ c |>\n<| c |>\nIt doesn't even compile,\
    \ I got \"incompatible types: possible lossy conversion from double to long\"\n\
    <|/ c |>\n<| c |>\n, my mistake, fixed the code.\n<|/ c |>\n<| c |>\nThe code\
    \ I wrote does actually work, but it does it extremely slowly on a set of 100,000\
    \ elements. It's slow because of the `Math.pow` call. Simpler ways exist.\n<|/\
    \ c |>\n<| a |>\nThe algorithm is pretty simple, just start summing the odd numbers\
    \ and sum them only when they are bigger than 0 (i.e. the number is odd).\n<code>\n\
    public static void main(String[] args) {\n  List<Integer> list = new ArrayList<Integer>();\n\
    \  list.addAll(Arrays.asList(new Integer[]{1, 3, 5, 6, 7}));\n  list.addAll(Arrays.asList(new\
    \ Integer[]{-5, -2, 5, -4, -7, -6}));\n  System.out.println(sum_even_odd_numbers(list));\n\
    }", "{\n    long sum = 0;\n    foreach (x in lst)\n    {\n\tbool isOdd = (x %\
    \ 2L) != 0L;\n\tif (!isOdd)\n\t    continue;\n\tsum += x * x;\n    }\n    return\
    \ sum;\n}", "{\n    int sum = 0;\n    for(int i=0; i<lst.length; i++) \n    {\n\
    \        if(lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n\
    \    if(lst.length == 0) {\n        return 0;\n    }\n    return sum;\n}", "{\n\
    \    long result = 0;\n    for (int i = 0; i < lst.Length; ++i)\n    {\n     \
    \   if (lst[i] % 2 == 1) result += lst[i];\n    }\n    return result;\n}\n/*",
  "{\n    long result = 0.0;\n    for(int i=0;i<lst.length;i++)\n    {\n        if(lst[i]\
    \ > 0)\n        {\n            result += lst[i]*lst[i];\n        }\n    }\n  \
    \  return result;\n}\n/*", "{\n  int i, sum = 0;\n  \n  for (i = 0; i < lst.size;\
    \ i++) \n  {\n    if (lst[i] != 0.0) \n    {\n      if (lst[i] % 2 == 1) \n  \
    \    {\n        sum += lst[i];\n      }\n    }\n  }\n  return sum;\n}", "{\n \
    \   int sum = 0;\n    for(int i = 0; i< lst.Length; i++)\n    {\n        if(lst[i]%2\
    \ == 1)\n        {\n            sum += lst[i] * lst[i];\n        }\n    }\n  \
    \  return sum;\n}", "{\n    long sum = 0;\n    for (int i = 1; i < lst.length;\
    \ ++i)\n    {\n        if (lst[i] % 2 != 0)\n            sum += lst[i] * lst[i];\n\
    \    }\n    return sum;\n}", "{\n    int i;\n    long sum = 0;\n    \n    for\
    \ (i = 0; i < lst.length; i++) \n    {\n        if (lst[i] % 2 == 1) sum += (long)lst[i]\
    \ * lst[i];\n    }\n    \n    return sum;\n}\n/*", "{\n    int i;\n    long sum\
    \ = 0;\n    \n    for(i = 0; i < lst.length; ++i) \n        if(lst[i] < 0) \n\
    \            return 0;\n    \n    for(i = 0; i < lst.length; ++i) \n    {\n  \
    \      double val = lst[i];\n        if(val == 0) \n            return 0;\n  \
    \      sum += std.math.fabs(val);\n    }\n    return sum;\n}", "{\n\tint i;\n\t\
    long sum = 0;\n\tfor(i=0; i<lst.size(); ++i)\n\t{\n\t\tif(lst[i]<0) \n\t\t{\n\t\
    \t\t//System.out.println(\"Skipping negative number \" + lst[i]); \n\t\t}\n\t\t\
    else if(lst[i]%2 ==0) \n\t\t{\n\t\t\tsum += lst[i];\n\t\t}\n\t\telse \n\t\t{\n\
    \t\t\t//System.out.println(\"Skipping number \" + lst[i]); \n\t\t}\n\t}\n\treturn\
    \ sum;\n}", "{\n    int N=lst.length;\n    if (N==0)\n        return 0;\n    long\
    \ total = 0;\n    float sum = 0;\n    int i=0;\n    while (sum<0) {\n        sum+=lst[i];\n\
    \        i++;\n    }\n    while (i<N) {\n        sum+=lst[i];\n        i++;\n\
    \        if (sum<0) {\n            sum=0;\n        }\n    }\n    while (i<N) {\n\
    \        total+=lst[i]*lst[i];\n        i++;\n    }\n    return total;\n}\n</code>\n\
    <|/ a dscore=1 tags=performance,java,android,arrays |>\n<| c |>\nIt doesn't answer\
    \ the question\n<|/ c |>\n<| c |>\nI didn't say it did, only that it is an improvement\n\
    <|/ c |>\n<| c |>\nIf you have a different problem, please ask a new question,\
    \ don't edit an old question to change it.\n<|/ c |>\n<| c |>\nYou seem to have\
    \ no interest in answering his question or telling him where to find his source\
    \ code. Just posting a link with no explanation is not an answer. Please understand\
    \ that StackOverflow is meant to be for people who are having problems with an\
    \ issue and have no interest in solving the problem. It shouldn't be used as a\
    \ place where people go to their website and look at other peoples code.\n<|/\
    \ c |>\n<| c |>\n: I was just commenting on the fact that he accepted this answer\
    \ instead of yours, and the fact that this was the only answer that gave him any\
    \ actual improvement. Your answer was very helpful in making my code better, but\
    \ wasn't really an improvement - he couldn't have written the code any better\
    \ without knowing where to start. I think it's fine to accept an answer that doesn't\
    \ actually answer the question.\n<|/ c |>\n<| a dscore=0 tags=performance,java,android,arrays\
    \ |>\nThis should do it if you don't want to use any libraries:\n<code>", "{\n\
    \    long result = 0;\n    long temp = 0;\n    long i;\n    \n    for (i = 0;\
    \ i < lst.length; ++i) {\n        if (lst[i] < 0) {\n            result += (-lst[i]);\n\
    \        } else {\n            result += lst[i] * lst[i];\n        }\n    }\n\
    \    \n    return result;\n}", "{\n    long sum = 0L;\n    for (float v : lst)\
    \ \n    {\n        sum += std.math.pow(v,2);\n        if (sum > long.MaxValue)\
    \ \n        {\n            return 0L;\n        }\n    }\n    return sum;\n}",
  "{\n    int n = lst.Length;\n    long sum = 0;\n    int i;\n    \n    for (i = 0;\
    \ i < n; i++) {\n        if (!(lst[i] > 0 && lst[i] % 2 == 1)) { \n          \
    \  sum += lst[i]; \n        } \n    }\n    return sum;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThanks for your answer but I did this and it gave me the wrong\
    \ answer :( I'm doing this in C++ and I changed it to c++ but it still gave me\
    \ the wrong answer :(\n<|/ c |>\n<| c |>\nI just made a mistake in the code, and\
    \ I corrected it; it worked fine when I tested it on my machine.\n<|/ c |>\n<|\
    \ c |>\nSo I changed my code up above and I believe that it is right, but I still\
    \ gave me the wrong answer :(\n<|/ c |>\n<| c |>\nCan you please tell me if you\
    \ have Visual Studio 2012 or 2013 installed on your computer? My code above works\
    \ on both versions I mentioned.\n<|/ c |>\n<| c |>\nI have Visual Studio 2012\
    \ Professional but when I test it in visual studio 2013 the output is wrong. I\
    \ don't know why because my other code does work :( It just doesn't output the\
    \ correct answer. Does it have anything to do with my computer?\n<|/ c |>\n<|\
    \ a dscore=1 |>\nThe problem is with your logic : \n<code>\nfor (i = 1; i < n;\
    \ i++) {\n    if (lst[i] == lst[i - 1]) {\n        sum += lst[i];\n    } \n}\n\
    </code>\nIf i equals 0, this condition will be true because lst[0] is equal to\
    \ lst[0], then it won't execute the statement below because lst[0] is already\
    \ equal to lst[0]. \nYou can try something like this:\n<code>\nfor (i = 1; i <\
    \ n; i++) {\n    if (lst[i] == lst[i - 1]) {\n        sum += lst[i];\n    } \n\
    }\n</code>\n<|/ a tags=c++ |>\n<| c |>\nI did that but now I am getting a strange\
    \ number for my answer\n<|/ c |>\n<| c |>\nThis is what I got for the input you\
    \ gave me: 8\n7\n6\n5\n4\n3\n2\n1\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n<|/ c |>\n<|\
    \ c |>\nThis was the output for the input\n<|/ c |>\n<| c |>\nIt looks good to\
    \ me. What's your input?\n<|/ c |>\n", "{\n    long result = 0;\n    for (float\
    \ v : lst)\n    {\n        result += (long)std::pow((double)v, 2);\n    }\n  \
    \  return result;\n}\n</code>\n<|/ a |>\n<| c |>\nYour solution seems to have\
    \ three bugs \u2014 one of which is that `std::pow` is being passed two `double`\
    \ operands, while it should only be passed a `float` one; and two of which are\
    \ that you're multiplying by `v` before you cast it to a `long`; and one of which\
    \ is that you're casting `v` to a `double` before applying the `std::pow` function.\
    \  I fixed these three bugs for you, but please test and verify that your code\
    \ works.  Finally, you should have pointed out that the question explicitly stated\
    \ that \"ignore numbers that are negative or not integers\", rather than \"ignore\
    \ all negative numbers\".  If you do that, you should probably change your code\
    \ to handle that as well.\n<|/ c |>\n<| c |>\nYes thanks for spotting that. I\
    \ made some changes to the code and now it works.\n<|/ c |>\n<| c |>\n: I made\
    \ some code changes and tested the code above. Please let me know if it works.\n\
    <|/ c |>\n<| c |>\n: If you accept the fact that `pow()` is implemented in terms\
    \ of `pow()`, then you might as well just use `pow()`.  It's not like there's\
    \ a significant difference between using `pow()` with `double` and `pow()` with\
    \ `float`; it just makes it harder to write correct code.  You might as well just\
    \ use simple multiplication and division operations instead of going through `pow()`.\
    \  If you do that, you should probably change your code to handle that as well.\n\
    <|/ c |>\n<| c |>\n: I tested this and the code is working fine.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nYou can use the below method to calculate the sum of squares\
    \ of odd numbers in an array of numbers. \n<code>\nimport java.util.Arrays;",
  "{\n    long sum = 0;\n    for(int i=0; i< lst.length; i++)\n    {\n        if (lst[i]\
    \ > 0)\n        {\n            sum += (lst[i] ^ lst[i]);\n        }\n    }\n \
    \   \n    return sum;\n}", "{\n    if (lst.length == 0) {\n        return 0;\n\
    \    }", "{\n    long sum = 0;\n    for (int i=0; i<lst.Length; i++) \n    {\n\
    \        if (lst[i]<0L || lst[i]==0L) \n            { lst[i] = 0L; }\n       \
    \ else \n            { sum += lst[i]*lst[i]; }\n    }\n    return sum;\n}\n/*",
  "{\n  long sum = 0;\n  for(int i=0; i < lst.size(); i++) {\n    if(lst[i] >= 0)\
    \ {\n      sum += lst[i]*lst[i];\n    }\n  }\n  return sum;\n}", "{\n    int sum\
    \ = 0;\n    for (int i = 0; i < lst.size(); i++)\n    {\n        if (lst[i] >=\
    \ 0)\n        {\n            sum += (long double)lst[i] - (long double)lst[(i\
    \ + 1) % lst.size()];\n        }\n        else\n        {\n            sum +=\
    \ (long double)lst[i] + lst.size();\n        }\n    }\n    return sum;\n}\n</cell>\n\
    <cell>\n%timeit double_the_difference([1, 2, 3, 4])\n</cell>\n<cell>\n%timeit\
    \ double_the_difference([-1, -2, -3, -4, -5])\n</cell>\n<cell>\ndef odd(lst):\n\
    \    return sum(lst[1::2]) % 2 == 1\ndef double_the_difference(lst):\n    return\
    \ sum(lst[1::2]) + lst.size % 2 == 0\n</cell>\n<cell>\n%timeit odd([1, 2, 3, 4])\n\
    %timeit double_the_difference([1, 2, 3, 4])\n</cell>\n<cell>\n%timeit odd([-1,\
    \ -2, -3, -4, -5])\n%timeit double_the_difference([-1, -2, -3, -4, -5])\n</cell>\n\
    <cell>\n%timeit odd([1, 2, 3, 4, 5, 6, 7])\n%timeit double_the_difference([1,\
    \ 2, 3, 4, 5, 6, 7])\n</cell>\n<cell>\n%timeit odd([0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9])\n%timeit double_the_difference([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n</cell>\n\
    <cell>\n%timeit odd([0])\n%timeit double_the_difference([0])\n</cell>\n<text>\n\
    The sum function is much slower than the above approach. In the sum function,\
    \ you are iterating over all of the elements in the array and summing them up.\
    \ The above approach avoids iterating over all of the elements by using array\
    \ slicing.", "{\n    int len = std.length(lst);\n    long sum = 0;\n    int i\
    \ = 0;\n    \n    while (i < len) {\n        long elem = std.get_float(lst,i);\n\
    \        if (elem > 0.0) \n            sum += elem * elem;\n        i++;\n   \
    \ }\n    return sum;\n}\n/*", "{\n  long sum = 0;\n  foreach (float number in\
    \ lst) \n  {\n    if (std.math.isEven(number)) \n    {\n      sum += number;\n\
    \    }\n  }\n  return sum;\n}\n</code>\n<|/ a tags=d,arrays |>\n<| c |>\nI really\
    \ like your use of std.typecons, and how you're using std.functional to solve\
    \ this problem.\n<|/ c |>\n<| c |>\nI've just started learning D and I'm very\
    \ impressed with it, especially the new language features (and their relation\
    \ to Python)\n<|/ c |>\n<| a dscore=4 |>\nYou need std.algorithm.removeIf() instead\
    \ of std.algorithm. removeIf returns a bool telling if the function passed as\
    \ a parameter returns true for all the elements of the sequence.\n<code>\nimport\
    \ std.algorithm;", "{\n    long total = 0;\n    for (int i = 0; i < lst.length;\
    \ i++)\n        if (lst[i] < 0)\n            total += (long) 0L;\n        else\n\
    \            total += (long) std.math.pow((double) lst[i], 2);\n    return total;\n\
    }\n</code>\n<|/ a tags=c#,arrays,algorithm,mathematical-optimization dscore=0\
    \ |>\n<| c |>\nThis only gives you the odd numbers, not the sum of the odd numbers.\n\
    <|/ c |>\n<| c |>\nThe question says he wants the sum of the odd numbers, so that's\
    \ what I did.\n<|/ c |>\n<| c |>\nOh, ok. My apologies.\n<|/ c |>\n<| c |>\nYep,\
    \ it's like you said, sum of the odd numbers. But I think you wrote it in a different\
    \ way.\n<|/ c |>\n<| c |>\nThe question states \"sum of the odd numbers\" and\
    \ you answer \"sum of the numbers\".\n<|/ c |>\n<| a tags=c#,arrays,algorithm,mathematical-optimization\
    \ |>\nThe answer is pretty straightforward: just traverse the array twice, checking\
    \ for odd and even numbers, sum them up, multiply by the number of even numbers,\
    \ and add that to the sum of the odd numbers.\n<code>\nvar result = 0.0;\nvar\
    \ evenCount = 0;", "{\n  int n = lst.Length;\n  if (n < 0) return 0L;\n  long\
    \ sum = 0L;\n  long sumsq = 0L;\n  for(int i=0; i<n; ++i)\n  {\n    if (lst[i]\
    \ < 0) continue;\n    sum += lst[i] * lst[i];\n    sumsq += lst[i] * lst[i];\n\
    \  }\n  if (sumsq <= sum) sumsq = sum - sumsq;\n  return sumsq;\n}", "{\n  long\
    \ sum = 0;\n  int i = 0;\n  for(i; i < lst.size(); i++) \n  {\n    if(!is_odd(lst[i]))\
    \ \n    {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}", "{\n  int i, j,\
    \ sum = 0, count = 0;", "{\n    long sum = 0L;\n    int i = 0;\n    for(i = 0;\
    \ i < lst.length; ++i)\n    {\n        if(!(lst[i] > 0) && !(lst[i] < 0))\n  \
    \      {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n</code>\n\
    <|/ a |>\n<| c |>\n`sumOfOdd` looks very similar to `double_the_difference`.\n\
    <|/ c |>\n<| c |>\n`double_the_difference` has two loops. One loop to get the\
    \ sum of the odd numbers and another loop to get the number of odd numbers. `sumOfOdd`\
    \ is one loop to get the sum and another loop to get the count. Since the count\
    \ can be done without the sum loop, I just used the `double_the_difference` loop\
    \ to get the count and then added the sum.\n<|/ c |>\n<| c |>\n`sumOfOdd` also\
    \ has a `for` loop which adds each `lst[i]` to `sum` each time `!(i%2)` evaluates\
    \ to `true`.\n<|/ c |>\n<| c |>\nYes sorry, I was referring to `sumOfOdd` as `double_the_difference`.\
    \ I'll update my post to clarify\n<|/ c |>\n<| c |>\nThat makes sense. Thank you\
    \ for explaining that! I was trying to think of how to do it without that nested\
    \ loop in mind!\n<|/ c |>\n<| a tags=java,for-loop,loops,arrays |>\n<code>\nfor\
    \ (int i=0; i<array.length; i++){\n    if ( i%2 == 1){\n        sum+=array[i];\n\
    \    }\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYou need `array.length` instead\
    \ of `lst.length`.\n<|/ c |>\n<| c |>\n`lst` is also a variable name given to\
    \ another variable.\n<|/ c |>\n<| c |>\nAh sorry, I did misread it at first. :P\n\
    <|/ c |>\n<| c |>\nI fixed the variable names and added a sample output.\n<|/\
    \ c |>\n<| c |>\nI see you have changed your code now. Do you really think it\
    \ is better to compare with `lst`? My solution looks better, doesn't it? Do you\
    \ think mine is incorrect?\n<|/ c |>\n<| a dscore=1 |>\nI would suggest you start\
    \ by checking if the input contains more than 1 item, then iterate through and\
    \ add the odd values to your sum.\nSomething like: \n<code>\nimport java.util.Arrays;",
  "{\n    long sum=0;\n    for (float f:lst) \n    {\n        if(f>=0)\n        {\n\
    \            sum += f*f;\n        }\n        else\n        {\n            sum\
    \ +=abs(f);\n        }\n    }\n    return sum;\n}\n</code>\n<|/ a tags=c++,math\
    \ |>\n<| a |>\n<code>\n#include <stdio.h>\n#include <stdlib.h>", "{\n    if (lst.Length\
    \ < 1) return 0;\n    var sum = 0;\n    for (var i = 0; i < lst.Length; i++) {\n\
    \        if (lst[i] < 0 || lst[i] == float.NegativeInfinity)\n            continue;\n\
    \        sum += lst[i] * lst[i];\n    }\n    return sum;\n}\n</code>\n<|/ a tags=c#,arrays,c++,algorithm\
    \ dscore=0 |>\n<| c |>\nThe C# code you posted does not return the correct sum.\
    \ `double_the_difference([9L, -2L])` returns 103, not 81 (same as the C++ code\
    \ you posted). Also the C++ code has undefined behavior in cases where there are\
    \ no odd-length subarrays.\n<|/ c |>\n<| a |>\nHere is what I did for C#, not\
    \ sure if it is better than the other answers:\n<code>\nusing System;", "{\n \
    \   long result = 0;\n    for( int i=0; i<lst.length; i++ )\n    {\n        if\
    \ ( lst[i] != 0 )\n        {\n            result = result + ( lst[i] * lst[i]\
    \ );\n        }\n    }\n    return result;\n}\n/* \n    Given an array of numbers,\
    \ return the sum of squares of the numbers\n    in the array that are odd. Ignore\
    \ numbers that are negative or not integers.\n    \n    >>> double_the_difference([1L,\
    \ 3L, 2L, 0L])\n    10L\n    >>> double_the_difference([-1L, -2L, 0L])\n    0L\n\
    \    >>> double_the_difference([9L, -2L])\n    81L\n    >>> double_the_difference([0L])\n\
    \    0L\n   \n    If the input array is empty, return 0.\n    \n*/\nlong double_the_difference(double[]\
    \ lst) \n{\n    long result = 0;\n    for( int i=0; i<lst.length; i++ )\n    {\n\
    \        if ( lst[i] != 0 )\n        {\n            result = result + ( lst[i]\
    \ * lst[i] );\n        }\n    }\n    return result;\n}\n/*\n \n    Simple test\
    \ of correctness.\n    \n    >>> double_the_difference([1L, 2L, 3L, 4L, 0L])\n\
    \    25L\n    >>> double_the_difference([-1L, -2L, -3L, -4L, 0L])\n    0L\n  \
    \  \n*/\nlong double_the_difference(long[] lst) \n{\n    long result = 0;\n  \
    \  for( int i=0; i<lst.length; i++ )\n    {\n        if ( lst[i] != 0 )\n    \
    \    {\n            result = result + ( lst[i] * lst[i] );\n        }\n    }\n\
    \    return result;\n}\n/* \n    Simple test of correctness.\n    \n    >>> double_the_difference([1L,\
    \ 2L, 3L, 4L, 0L])\n    25L\n    >>> double_the_difference([-1L, -2L, -3L, -4L,\
    \ 0L])\n    0L\n    \n*/\nlong double_the_difference(int[] lst) \n{\n    long\
    \ result = 0;\n    for( int i=0; i<lst.length; i++ )\n    {\n        if ( lst[i]\
    \ != 0 )\n        {\n            result = result + ( lst[i] * lst[i] );\n    \
    \    }\n    }\n    return result;\n}", "{\n    int sum = 0;\n    int pos = 0;\n\
    \    \n    foreach(float x, lst)\n    {\n        if(!((x & 1ULL ) == 0ULL))\n\
    \        {\n            sum += powf(x - lst[pos], 2);\n        }\n        pos\
    \ += 1;\n    }\n    return sum;\n}", "{\n    int i = 0;\n    int j = 0;\n    int\
    \ sum = 0;\n    float temp;\n    float sum2 = 0;\n    \n    while (i < lst.length)\n\
    \    {\n        temp = lst[i];\n        while (j < (lst.length - 1))\n       \
    \ {\n            if (temp % 2 != 0)\n            {\n                sum2 = sum2\
    \ + temp;\n            }\n            else\n            {\n                sum2\
    \ = sum2 + temp - lst[j];\n            }\n            j++;\n        }\n      \
    \  sum = sum + sum2;\n        i = i + 1;\n        j = 0;\n    }\n    return sum;\n\
    }", "{\n    long sum = 0;\n    int i ;\n    \n    if (lst.length == 0) {\n   \
    \     return 0;\n    }\n    \n    for (i = 0; i < lst.length; ++i)\n    {\n  \
    \      if (lst[i] < 0)\n        {\n            return 0;\n        }\n        else\
    \ if (lst[i] % 2 == 1)\n        {\n            sum += lst[i] * lst[i];\n     \
    \   }\n    }\n    return sum;\n}", "{\n    long sum=0;\n    for (int i=0;i<lst.Length;i++)\n\
    \    {\n        if (lst[i] % 2 != 0)\n        {\n            sum += lst[i]*lst[i];\n\
    \        }\n    }\n    return sum;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nHi,\
    \ I have tested your code, but the result is incorrect. I used the test data,\
    \ but the result is still the same.\n<|/ c |>\n<| c |>\nI added the code for the\
    \ double_the_difference function I wrote, thank you for pointing out that I forgot\
    \ to put a return statement there.\n<|/ c |>\n<| c |>\nThe reason why this doesn't\
    \ work because your function is called \"double_the_difference\" whereas your\
    \ code is \"Double_the_difference\".\n<|/ c |>\n<| a tags=c#,arrays |>\nHere is\
    \ a different approach. It is not using loops which is nice for readability and\
    \ maintainability. It also avoids unnecessary casting by using the Linq extension\
    \ methods rather than loops.\n<code>\nvar result = lst.Where(l => l % 2 == 1).Sum();\n\
    </code>\nWhere lst is your array.\n<|/ a dscore=0 |>\n<| c |>\nHi, I have tested\
    \ the code, but the result is incorrect. I used the test data, but the result\
    \ is still the same.\n<|/ c |>\n<| a tags=c#,arrays dscore=0 |>\nYou can use LINQ\
    \ to simplify the solution to the problem:\n<code>\nusing System;\nusing System.Linq;\n\
    using System.Linq.Expressions;", "{\n    long sum = 0;\n    long index = 0;\n\
    \    long sum1 = lst[index];\n    \n    for(index = 1; index < lst.length; index++)\
    \ \n    {\n        if (lst[index] % 2 == 1)\n        {\n            sum += lst[index];\n\
    \        }\n    }\n    return sum * sum1;\n}", "{\n    long sum=0;\n    for (int\
    \ i=0; i<lst.length; ++i)\n    {\n        if (lst[i] < 0 || std.math.abs(lst[i])\
    \ == std.math.trunc(lst[i]) )\n        {\n            continue;\n        }\n \
    \       sum += (long)lst[i]*lst[i];\n    }\n    return sum;\n}", "{\n    int len\
    \ = lst.Length;\n    if(len == 0)\n        return 0;", "{\n    long sum = 0L;\n\
    \    \n    for (long i = 0; i < lst.Length; i++)\n    {\n        if (lst[i] >\
    \ 0 || lst[i] < -2)\n        {\n            continue;\n        }\n        sum\
    \ += Math.Abs(lst[i]);\n    }\n    \n    return sum;\n}\n/*", "{\n    long sum\
    \ = 0;\n    int count = 0;\n    foreach (var num in lst)\n    {\n        if (num\
    \ <= 0L || num % 2 == 1L)\n        {\n            sum += num;\n            count++;\n\
    \        }\n    }", "{\n  long sum = 0;\n  int idx = 0;", "{\n\tlong answer =\
    \ 0;\n\t\n\tif(lst.length == 0)\n\t{\n\t\treturn 0;\n\t}\n\t\n\tfloat sum = 0;\n\
    \t\n\tfor(int i = 0; i < lst.length; i++)\n\t{\n\t\tif(lst[i] < 0)\n\t\t{\n\t\t\
    \tcontinue;\n\t\t}\n\t\t\n\t\tsum += lst[i];\n\t}\n\t\n\tanswer += (long)Math.pow(sum,\
    \ 2);\n\t\n\treturn answer;\n}", "{\n    long sum = 0;\n    for(int i = 0; i <\
    \ lst.length; ++i)\n    {\n        if(lst[i] > 0)\n        {\n            sum\
    \ += lst[i]*lst[i];\n        }\n        else\n        {\n            if(lst[i]\
    \ < -1000000)\n            {\n                sum += lst[i];\n            }\n\
    \        }\n    }\n    return sum;\n}", "{\n    int i;\n    long sum = 0;\n  \
    \  for(i = 0; i < lst.size(); ++i)\n    {\n        if(lst[i] < 0)\n          \
    \  sum += lst[i] * lst[i];\n        else\n            sum += lst[i];\n    }\n\
    \    return sum;\n}", "{\n    long res = 0;\n    long temp = 0;\n    \n    foreach(i,\
    \ lst) \n    {\n        if(i&1)\n            temp = temp + i;\n        else\n\
    \            res = res + temp;\n    }\n    return res;\n}", "{\n\tlong sum = 0;\n\
    \t\n\tfor (int i = 0; i < lst.size(); i++) {\n\t\tif (lst[i] % 2 == 1) {\n\t\t\
    \tsum += lst[i];\n\t\t}\n\t}\n\treturn sum;\n}", "{\n    int i;\n    long sum\
    \ = 0;\n    \n    for (i=0; i<lst.length; i++) \n\t{\n\tif (!isinteger(lst[i]))\
    \ \n\t\t{\n            sum += lst[i] * lst[i];\n        }\n\telse\n\t\t{\n\t\t\
    sum += lst[i];\n        }\n\t}\n    return sum;\n}\n/*", "{\n    long sum = 0,\
    \ i;\n    \n    for (i = 0; i < lst.Length; ++i)\n    {\n        if (lst[i] >=\
    \ 0)\n            sum += lst[i]*lst[i];\n        else\n            sum += lst[i];\n\
    \    }\n    return sum;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nPlease don't\
    \ just post your code for others to understand. Explain what it does, and why,\
    \ rather than simply posting the code.\n<|/ c |>\n<| a tags=c# |>\nI'm sure there\
    \ is a more efficient way to do this, but the following code works for me.\n<code>\n\
    using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;",
  "{\n\tlong sum = 0;\n\tfor (int i = 0; i < lst.Length; i++) \n\t{\n\t\tif ((int)lst[i]\
    \ % 2 == 1)\n\t\t{\n\t\t\tsum += lst[i];\n\t\t}\n\t}\n\treturn sum;\n}\n/*", "{\n\
    \    long sum = 0;\n    for(uint i = 0; i < lst.size(); ++i)\n    {\n        if(lst[i]\
    \ % 2 != 0) \n            sum += pow(lst[i], 2);\n    }\n    return sum;\n}\n\
    /*", "{\n    long sum = 0;\n    long n = lst.size();\n    if (n > 0) {\n     \
    \   for (int i = 0; i < n; i++) {\n            long val = std.math.reciprocal(i);\n\
    \            if (lst[i] % 2 == 1) {\n                sum += (lst[i] - val) * (lst[i]\
    \ - val);\n            }\n        }\n    }\n    return sum;\n}", "{\n    long\
    \ sum = 0;\n    for (int i = 0; i < lst.Length; i++) \n    {\n        if (lst[i]\
    \ % 2 == 1)\n            sum += lst[i];\n    }\n    return sum;\n}", "{\n    long\
    \ sum = 0;\n    foreach (long x in lst) \n    {\n        if (x != 0L)\n      \
    \      sum += std.math.pow(x, 2);\n    }\n    return sum;\n}", "{\n  long sum\
    \ = 0;\n  int i;\n  \n  for (i = 0; i < lst.length; ++i)\n    if (lst[i] >= 0)\n\
    \      sum += lst[i] * lst[i];\n      \n  return sum;\n}\n'''\n        self.write_code('''\n\
    float double_the_difference(float[] lst) \n{\n  int i;\n  float sum = 0;\n  \n\
    \  for (i = 0; i < lst.length; ++i)\n    if (lst[i] >= 0)\n      sum += lst[i]\
    \ * lst[i];\n      \n  return sum;\n}\n''')", "{\n    int sum = 0;\n    int i;\n\
    \    float value;\n    \n    for(i = 0; i < lst.lenth; ++i)\n    {\n        value\
    \ = lst[i];\n        sum += value * (double)value;\n    }\n    return sum;\n}",
  "{\n    long ret = 0;\n    for(int i = 0; i < lst.size; ++i)\n    {\n        if\
    \ (lst[i] > 0)\n        {\n            ret += lst[i] * lst[i];\n        }\n  \
    \  }\n    return ret;\n}\n</code>\n<|/ a tags=c,arrays,sum,loops |>\n<| c |>\n\
    Hi Peter! Thank you for the help. I still get a seg fault when running this. It\
    \ appears that the for loop is not iterating correctly. I tried using a printf\
    \ statement in each loop to see if the loop was being ran correctly and I noticed\
    \ that after the first loop the array is never updated. I am not sure why. Thank\
    \ you!\n<|/ c |>\n<| c |>\nIt's been a while since I worked with C, but I don't\
    \ think you can declare variables outside of functions - try moving `float num`\
    \ inside the function.\n<|/ c |>\n<| c |>\nThank you for the advice. I moved the\
    \ declaration inside the function and it now compiles. However, when I run the\
    \ code it just stops after running the first loop. It doesn't give me any error\
    \ messages either. I am so lost now..\n<|/ c |>\n<| c |>\nI apologize for the\
    \ slow response! I was trying to figure out how to make my comments show up so\
    \ I could add more code. I think I accidentally deleted my comments.\n<|/ c |>\n\
    <| a |>\nThe below method will be the easiest to implement for you, but also the\
    \ most expensive one.\n<code>\nfloat sum(int n, float array[]) {\n    float sum\
    \ = 0;\n    for (int i = 0; i < n; i++)\n        sum += array[i];\n    return\
    \ sum;\n}\n</code>\nThis will add up all the numbers in the array and return the\
    \ value.\nIf you need more efficiency, you could create a method that is like\
    \ below:\n<code>\nfloat sum(int n, float array[]) {\n    float sum = 0;\n    for\
    \ (int i = 0; i < n; i++)\n        sum += array[i];\n    return sum;\n}\n</code>\n\
    And then you could write a method that takes in the array, and a range and finds\
    \ the sum of all the numbers in the range like so:\n<code>\nfloat sumRange(int\
    \ n, float array[], int start, int end) {\n    float sum = 0;\n    for (int i\
    \ = start; i < end; i++)\n        sum += array[i];\n    return sum;\n}\n</code>\n\
    With this method you just have to call sumRange with some array and start and\
    \ end values, and it gives you the sum of the numbers in that range.\n<|/ a tags=c,arrays,sum,loops\
    \ dscore=0 |>\n<| c |>\nThis is wrong. You cannot use the `+=` operator on floats.\n\
    <|/ c |>", "{\n    if (lst.length == 0)\n        return 0;\n    return std.math.reduce_max(\n\
    \        std.math.reduce_min(\n            std.math.pow(lst[0], 2.0L),\n     \
    \       lst[1],\n            lst[2]\n            ),\n        lst[3]\n        );\n\
    }\n/*\n    \n    Write a function that accepts a range of numbers and returns\
    \ their average.\n    \n    >>> average_of_range(2,5)\n    2.5\n    >>> average_of_range(1,2,3,4,5)\n\
    \    2.5\n    \n    \n    \n*/\nfloat average_of_range(float start_float, float\
    \ stop_float) \n{\n    return (start_float + stop_float) / 2.0f;\n}\n/*\n    \n\
    \    Write a function that accepts a range of numbers and returns their average.\n\
    \    \n    >>> average_of_range(2,5)\n    2.5\n    >>> average_of_range(1,2,3,4,5)\n\
    \    2.5\n    \n    \n    \n*/\ndouble average_of_range(double start_double, double\
    \ stop_double) \n{\n    return (start_double + stop_double) / 2.0;\n}\n/*", "{\n\
    \  int size = lst.Length;\n  long sum = 0;\n  int count = 0;\n  for(int i = 0;\
    \ i < size; i++) \n  { \n    if(lst[i] < 0 || lst[i] % 1 != 0) \n    {\n     \
    \ count += 1;\n    }\n    else\n    {\n      sum += lst[i] * lst[i];\n    }\n\
    \  }\n  if (count == 0) return 0;\n  return sum;\n}\n</code>\n<|/ a tags=c#,.net\
    \ |>\n<| c |>\nWhy should the OP \"try this\"? A ***good answer*** will always\
    \ have an explanation of what was done and why it was done in such a manner, not\
    \ only for the OP but for future visitors to SO.\n<|/ c |>\n<| a dscore=0 tags=c#,.net\
    \ |>\n<code>\n//The question asks you to count the number that are double of all\
    \ the integers\n//The answer is \"n\", where n is the number of integers that\
    \ are odd.", "{\n    int sum = 0;\n    for (int i=0; i<lst.length; i++)\n    {\n\
    \        if (lst[i]%2!=0) sum+=lst[i];\n    }\n    return sum;\n}\n</code>\nAnd\
    \ finally a version that doesn't use recursion. The algorithm is identical to\
    \ what you have done except for the stack frame. It is a bit easier to read:\n\
    <code>\nlong double_the_difference(float[] lst)\n{\n    if (lst==null || lst.length==0)\
    \ return 0;\n    float sum = 0;\n    for (int i=0; i<lst.length; i++)\n    {\n\
    \        if (lst[i]%2!=0) sum+=lst[i];\n    }\n    return sum;\n}\n</code>\nNote\
    \ that in C, unlike some other languages, array indices are zero-based, meaning\
    \ that lst[0] would be the first element of the array (which is what the first\
    \ two examples do). In C++, array indices are one-based, meaning that the first\
    \ element of the array would be accessed as lst[0].\n<|/ a dscore=1 |>\n<| a tags=algorithm,recursion,c++,c\
    \ |>\nHere's a Python solution that uses the fact that Python arrays are zero-based.\n\
    <code>\ndef double_the_difference( array ):\n    n = len( array )\n    if n ==\
    \ 0: return 0\n    diff = array[0]\n    for x in array[1:]:\n        diff += x\
    \ << 1\n    return diff\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,recursion,c++,c\
    \ |>\nHere is Python implementation - \n<code>\ndef double_the_difference(lst):\n\
    \  if len(lst) == 0 or len(lst) < 2:\n    return 0\n  x = lst[0]\n  for i in range(len(lst)\
    \ - 1):\n    x = x + lst[i+1]\n  return x\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    The question explicitly states that this is not an option. Python is an option,\
    \ however, not the answer.\n<|/ c |>\n<| a tags=algorithm,recursion,c++,c |>\n\
    C based implementation:\n<code>", "{\n    long sum = 0;\n    int i = 0, j = 0;\n\
    \    while (i<lst.Length && lst[i]!=0) \n    {\n        sum += lst[i++] * lst[i++];\
    \ \n        j++;\n    }\n    return sum;\n}\n</code>\n<|/ a tags=c#,arrays |>\n\
    <| c |>\nThanks alot, i think I understand the concept behind this, however I\
    \ cannot get it to work, it gives me an error in Visual Studio saying \"expected\
    \ a constant expression\"\n<|/ c |>\n<| c |>\nI cannot get it to compile, i think\
    \ it might be because I forgot to include the namespace std.math in the code?\n\
    <|/ c |>\n<| c |>\nThe std.math namespace is actually part of the standard library.\
    \ Just add `using std.math;` to the top of your file. I'll update my answer to\
    \ show this.\n<|/ c |>\n<| c |>\nJust for the record, the problem is not related\
    \ to the `std` namespace. C# doesn't have anonymous functions, it uses delegates\
    \ instead. `Func` is `Delegate`\n<|/ c |>\n<| c |>\nThanks for the explanation,\
    \ I'm still pretty new to C# so it didn't come to mind to use Func and delegates\n\
    <|/ c |>\n<| a |>\nI dont think you understand what a List is. A list is a collection\
    \ of objects, and each object has a unique index and a value.\n<|/ a tags=c#,arrays\
    \ dscore=0 |>\n<| c |>\nI do understand that, I was just explaining how I was\
    \ using it as an array. Thanks for the reply.\n<|/ c |>\n<| a tags=c#,arrays |>\n\
    It's called LINQ extension:\n<code>\nvar arr = new[] {1, 2, 3, 4, 5};\nvar res\
    \ = arr.Where((x, i) => i % 2 == 0).Sum();\n</code>\n<|/ a dscore=0 |>\n<| a tags=c#,arrays\
    \ |>\nI'm sorry guys, I have found the answer I needed and thanks for all the\
    \ answers I received, they were all correct, but I needed my array to be a double\
    \ or float array not an array with ints, I believe this is done because I wanted\
    \ the sum of all odd numbers so I could use it as a double. Thanks again.\n<|/\
    \ a dscore=0 |>\n<| c |>\nYes, it can use any type you want. The idea is that\
    \ you shouldn't worry about casting or loss of precision.\n<|/ c |>\n<| a dscore=0\
    \ |>\nThis is an example of a simple implementation ", "{\n  if (lst.Length ==\
    \ 0)\n    return 0;\n  long result = 0;\n  for (int i = 0; i < lst.Length; ++i)\n\
    \    if (lst[i] % 2 != 0)\n      result += (lst[i] - 1L) * (lst[i] - 1L);\n  return\
    \ result;\n}\n/*", "{\n    long sum = 0;\n    long n = lst.Length;\n    \n   \
    \ for (int i = 0; i < n; i++) \n    {\n        if (lst[i] >= 0.0f && lst[i] %\
    \ 1 == 0.0f) \n        {\n            sum += Math.Pow((double)lst[i], 2);\n  \
    \      }\n    }\n    return sum;\n}\n</code>\n<|/ a tags=c#,arrays |>\n<| a tags=c#,arrays\
    \ |>\nI think this is your solution \n<code>\n//Function to double the difference\
    \ of odd and even elements in the given array \nusing System;\nnamespace DoubleOddElements\n\
    {\n    class Program\n    {\n        static void Main(string[] args)\n       \
    \ {\n            int[] x = new int[] { 1, 3, 1, 2, 3, 4, 3, 2, 4 };\n        \
    \    Console.WriteLine(CalculateOddEvenSum(x));\n            Console.ReadLine();\n\
    \        }\n        public static long CalculateOddEvenSum(int[] array)\n    \
    \    {\n            long sum=0;\n            for(int i=0; i<array.Length; i++)\n\
    \            {\n                if(array[i]%2==0)\n                {\n       \
    \             sum+=array[i];\n                }\n                else\n      \
    \          {\n                    sum+=2*array[i];\n                }\n      \
    \      }\n            return sum;\n        }\n    }\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nJust for fun, here's a solution in LINQ using Where() and ToList():\n\
    <code>\npublic static double doubleOddsAndEvensSum(int[] array) {\n    return\
    \ array.Where(n => n % 2 == 0).ToList().Sum(n1 => n1 * n1);\n}\n</code>\n<|/ a\
    \ dscore=1 tags=c#,arrays |>\n<| c |>\n`double sum = Math.Pow(array.Where(n =>\
    \ n % 2 == 0).Sum(n => n * n), 0.5);` :)\n<|/ c |>\n<| a dscore=0 tags=c#,arrays\
    \ |>\nThis was the closest I came to it:\n<code>\nvar odd = new[] { 1, 3, 1, 2,\
    \ 3, 4, 3, 2, 4 };\nvar even = new[] { 0, 1, 5, 7, 3, 2, 4 };\nvar evenSquares\
    \ = odd.Concat(even)\n    .Where(o => o % 2 == 0)\n    .Sum(o => o * o);\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=c#,arrays |>\nHere is a simple solution:\n<code>\n\
    public static int doubleOddElements(int[] array)\n{\n    int sum = 0;", "{\n \
    \   int n = lst.Length;\n    long sum = 0;\n    \n    for (int i = 0; i < n; i++)\n\
    \    {\n        if (lst[i] > 0)\n        {\n            if (lst[i] % 2 == 1)\n\
    \            {\n                sum += lst[i] * lst[i];\n            }\n     \
    \   }\n    }\n    \n    return sum;\n}\n/*", "{\n  long sum = 0;\n  for(int i\
    \ = 0; i < lst.length; i++)\n  {\n    if(lst[i] % 2 != 0)\n    {\n      sum +=\
    \ pow(lst[i], 2);\n    }\n  }\n  return sum;\n}\n</code>\n<|/ a tags=java,arrays\
    \ |>\n<| c |>\nwhy not do `Math.pow(lst[i], 2);`?\n<|/ c |>\n<| c |>\nBecause\
    \ Math.pow() returns a double, and lst[i] has to be a float. So, it would be unnecessary\
    \ extra precision loss.\n<|/ c |>\n<| c |>\nSo why not just call `lst[i] >> 1`\
    \ to get an integer?\n<|/ c |>\n<| c |>\nBecause Math.pow() returns the type double,\
    \ which is more precise than a long. And, >> (shift right) shifts the binary representation\
    \ to the right by one bit, meaning it shifts all the 0s to 1s, and all the 1s\
    \ to 0s.\n<|/ c |>\n<| a dscore=0 tags=java,arrays |>\nThis might not be the most\
    \ efficient implementation, but it will work just fine for small arrays.\n<code>\n\
    public class DoubleTheDifference\n{\n    public static void main(String[] args)\n\
    \    {\n        int numbers[] = new int[]{1, 3, 2, 4};\n        System.out.println(findTheDouble(numbers));\n\
    \    }\n    public static long findTheDouble(int[] numbers)\n    {\n        int\
    \ i=0;\n        int total = 0;\n        long lastNumber = 0;\n        for(; i\
    \ < numbers.length; i++)\n        {\n            if((numbers[i] & 1) == 0)\n \
    \           {\n                total += numbers[i];\n            }\n         \
    \   else if(numbers[i] == 0)\n            {\n                lastNumber = total;\n\
    \                total = 0;\n            }\n            else if(numbers[i] ==\
    \ 1)\n            {\n                total -= lastNumber;\n                lastNumber\
    \ = 0;\n            }\n        }\n        return total;\n    }\n}\n</code>\n<|/\
    \ a |>\n<| a tags=java,arrays |>\nYou can use the following algorithm to find\
    \ the double the difference of two numbers, here is a pseudo code:\n<code>\ndouble\
    \ a[] = { 1 , 3, 2, 4 }", "{\n   long sum = 0;\n   int i = 0;", "{\n    long result\
    \ = 0;\n    int i = 0;\n    int length = lst.Length;\n    while (i < length)\n\
    \    {\n        if (lst[i] % 2 == 1)\n            result += (long)lst[i];\n  \
    \      i++;\n    }\n    return result;\n}\n// end Double the Difference function\n\
    // ------------------------------------\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    For some reason, it's returning 0 on all cases. The test code is: \n`float[] arr\
    \ = new float[] { 1L, 3L, 2L, 0L, -1L, -2L, 0L, 9L, -2L};\n        Console.WriteLine(double_the_difference(arr));`\n\
    <|/ c |>\n<| c |>\nI made some edits to the code, try it out again. It was returning\
    \ a 0 because you were checking the return value of the function call, you need\
    \ to check the return value from the function. I've also changed the function\
    \ so that it returns 0 if an empty array is passed.\n<|/ c |>\n<| c |>\nYeah,\
    \ I guess it did return 0 because you didn't pass an array in the test. I tested\
    \ this with a couple different sets of numbers, and it works great. Thanks for\
    \ the help!\n<|/ c |>\n<| a tags=c#,algorithm dscore=3 |>\nHere's a solution using\
    \ LINQ:\n<code>\nlong double_the_difference(float[] lst)\n{\n    return lst.Sum(x\
    \ => Math.Pow(x - lst[0], 2));\n}\n</code>\n<|/ a |>\n<| c |>\nAhh, didn't think\
    \ of Sum. That's probably the best solution for my specific situation. I was trying\
    \ to find a way to do it without a loop because of the sheer number of elements\
    \ to iterate through and I figured it would be less messy and easier to read.\
    \ Thanks for the help!\n<|/ c |>\n<| c |>\nYou're welcome. I agree with you that\
    \ the LINQ solution is probably the best for you, too. You should also look into\
    \ Jared's answer, too.\n<|/ c |>\n<| c |>\nThis isn't quite as efficient as using\
    \ Math.Pow because it uses pow multiple times for the same result. Also, since\
    \ you're using an anonymous function here, you're losing out on all those cool\
    \ things that are available with LINQ. Also, the lambda isn't necessary here,\
    \ you could just use `x => Math.Pow(x - lst[0], 2)` for the same effect.\n<|/\
    \ c |>\n<| c |>\n, you're right about the lambda being unnecessary, thanks for\
    \ pointing out. You're right about efficiency as well, thanks for pointing that\
    \ out. The anonymo", "{\n    long sum=0;\n    long i;\n    for(i=1; i<lst.length;\
    \ i++) \n    {\n        if(lst[i]%2!=0)\n            sum+=lst[i]*lst[i];\n   \
    \ }\n    return sum;\n}", "{\n\tint sum = 0;\n\tint i = 0;\n\t\n\twhile (i < lst.length)\n\
    \t{\n\t\tint val = lst[i];\n\t\tif (val >= 0)\n\t\t\tsum += val * val;\n\t\telse\n\
    \t\t\tsum += val;\n\t\ti++;\n\t}\n\treturn sum;\n}", "{\n    int i;\n    long\
    \ sum = 0;\n    \n    for (i=0; i<lst.length; i++){\n        if (lst[i] < 0L ||\
    \ lst[i] > 1L) \n            sum = 0; \n        else \n            sum += lst[i]*lst[i];\
    \ \n    }\n    \n    return sum;\n}", "{\n    long sum = 0;\n    for (int i =\
    \ 0; i < lst.Length; i++)\n    {\n        if (i % 2 == 1)\n        {\n       \
    \     sum += lst[i];\n        }\n    }\n    return sum;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nYou can do this with just one method call: \n<code>\npublic long\
    \ DoubleTheDifference(float[] lst)\n{\n    long sum = 0;\n    foreach (var i in\
    \ lst)\n        sum += i & 0x1L;\n    return sum;\n}\n</code>\nThis does just\
    \ one check and uses bit manipulation to find out the sum. \nNote: since you want\
    \ negative numbers to be ignored as well, this will have to do multiple checks.\
    \ \n<code>\npublic long DoubleTheDifference(float[] lst)\n{\n    long sum = 0;\n\
    \    foreach (var i in lst)\n        sum += i & 0x1L;\n    return sum;\n}", "{\n\
    \    long long ans = 0;\n    for (size_t i = 0; i < lst.size(); ++i)\n    {\n\
    \        if (lst[i] > 0) ans += lst[i]*lst[i];\n        if (lst[i] < 0) ans -=\
    \ lst[i]*lst[i];\n    }\n    return ans;\n}", "{\n   float sum = 0;\n   \n   if(lst.Length\
    \ == 0) return 0;\n   \n   for(int i = 0; i < lst.Length; i++) \n   {\n      if\
    \ (lst[i] % 2 != 0) \n         sum += lst[i];\n   }  \n   return sum * sum;\n}",
  "{\n\tint counter = 0;\n\tfloat avg = 0;\n\tfloat sum = 0;\n\tfor (int i=0;i<lst.lenght;i++)\n\
    \t{\n\t\tif (lst[i]%2 == 1)\n\t\t{\n\t\t\tcounter ++;\n\t\t\tavg = avg + lst[i];\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tsum = sum + lst[i];\n\t\t}\n\t}\n\tif (counter ==\
    \ 0)\n\t\treturn 0;\n\tavg = avg/counter;\n\treturn (sum - avg*avg);\n}\n/*",
  "{\n    long sum = 0;\n    for (int i = 0; i < lst.Length; i++)\n    {\n       \
    \ if (lst[i] % 2 == 1)\n        {\n            sum += lst[i];\n        }\n   \
    \ }\n    return sum;\n}", "{\n\tint i;\n\tlong sum;", "{\n  int n = (int)lst.Length;\n\
    \  long sum = 0;", "{\n    if (lst.Length == 0)\n        return 0;", "{\n  int\
    \ i = 0;\n  long sum = 0;\n  for(; i < lst.len; ++i)\n  {\n    if(!isinteger(lst[i]))\n\
    \    {\n      if(lst[i] < 0)\n      {\n        sum += lst[i] * lst[i];\n     \
    \ }\n      else\n      {\n        sum += lst[i];\n      }\n    }\n  }\n  return\
    \ sum;\n}", "{\n    long sum = 0;\n    int len = std.array.length(lst);\n    if\
    \ (len <= 0) {\n        return 0;\n    }\n    float x;\n    for(int i = 0; i <\
    \ len; ++i) {\n        x = lst[i];\n        if (x > 0) {\n            sum += x*x;\n\
    \        }\n        if (x < 0) {\n            sum += x*x*x;\n        }\n    }\n\
    \    return sum;\n}\n\"\"\")", "{\n\tint i, count = 0;\n\tdouble sum = 0.0;\n\t\
    for(i = 0; i < lst.Length; i++) {\n\t\tif(lst[i] % 2 != 0) count++;\n\t}\n\tfor(i\
    \ = 0; i < lst.Length; i++) {\n\t\tif(lst[i] % 2 != 0) sum += lst[i];\n\t}\n\t\
    \n\tlong ans = 0.0;\n\t\n\tfor(i = 0; i < lst.Length; i++) {\n\t\tif(lst[i] %\
    \ 2 != 0) ans += lst[i] * lst[i];\n\t}\n\t\n\treturn ans;\n}", "{\n    int i;\n\
    \    long result = 0;\n    for (i = 0; i < lst.Length; ++i)\n    {\n        if\
    \ (lst[i] < 0)\n        {\n            result += lst[i] * lst[i];\n        }\n\
    \        else\n        {\n            result += (long)lst[i];\n        }\n   \
    \ }\n    return result;\n}\n</code>\n<|/ a tags=c#,algorithm |>\n<| c |>\n+1 but\
    \ you should note that if all numbers are odd the result is always odd, so this\
    \ solution doesn't need any special checking. Only the first element is odd, all\
    \ the other numbers are even, and none of the numbers are negative.\n<|/ c |>\n\
    <| c |>\nYou're right, it didn't need to be special checking. I was just being\
    \ careful not to go out of bounds :)\n<|/ c |>\n<| a tags=c#,algorithm |>\nI believe\
    \ that the fastest solution would be something like:\n<code>\nprivate long DoubleTheDifference(IEnumerable<long>\
    \ numbers)\n{\n    long sum = 0;\n    foreach (long n in numbers)\n    {\n   \
    \     if (n % 2 == 1)\n        {\n            sum += n;\n        }\n    }\n  \
    \  return sum;\n}\n</code>\nBut of course it depends on the number of numbers.\
    \ If it's relatively small then the performance gain may not be noticeable.\n\
    <|/ a dscore=3 |>\n<| a dscore=2 tags=c#,algorithm |>\nI'm pretty sure that there\
    \ is a faster method using LINQ. I would try something like:\n<code>\nvar sum\
    \ = numbers.Sum(x => x % 2 == 1 ? x : 0);\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ work because 0 is still considered to be odd.\n<|/ c |>\n<| c |>\nYes, but you\
    \ know that since your array is only ever integers, that all numbers are even.\
    \ You need to check if x % 2 == 0 before you do your sum.\n<|/ c |>\n<| c |>\n\
    You don't have to do that if you know that all numbers are odd, which I'm sure\
    \ they are.\n<|/ c |>\n<| c |>\n`numbers.Sum(x => x % 2 == 1 ? 0 : x);`\n<|/ c\
    \ |>\n<| a tags=c#,algorithm |>\nI would use Linq:\n<code>\nvar numbers = new[]\
    \ { 0L, -1L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L };\nvar sum = numbers.Sum(n\
    \ => (int)Math.Pow(2, n));\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice! Just a\
    \ minor ", "{\n    int n = lst.GetLength(0);\n    long result = 0;\n    for (int\
    \ i = 0; i < n; i++) \n    {\n        if (lst[i] > 0) \n        {\n          \
    \  if (i % 2 == 0) \n            {\n                result += lst[i] * lst[i];\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    int i;\n   \
    \ long sum = 0;\n    if (lst.Length < 1)\n        return 0;\n    for (i = 0; i<lst.Length;\
    \ i++)\n        if (lst[i] % 2 != 0)\n            sum += lst[i];\n    return sum;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis answer might be useful to those who\
    \ were wondering why this was the best solution. It was designed to solve a slightly\
    \ different problem than the original poster.\n<|/ c |>\n<| a dscore=0 |>\nYou\
    \ can do this in one line:\n<code>", "{\n\tint N=lst.size;\n\tfloat sum;\n\tfloat\
    \ tmp;\n\t\n\tfor(int i=0; i<N; i++){\n\t\ttmp=lst[i];\n\t\tif(tmp>0){\n\t\t\t\
    if(tmp%2!=0){\n\t\t\t\tsum+=tmp*tmp;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(tmp%2==0){\n\
    \t\t\t\tsum+=tmp*tmp;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\n/*", "{\n    long\
    \ sum = 0;\n    for (float x : lst)\n    {\n        if(x>0) // if x is positive\n\
    \        {\n            if(x>1) //  if x is odd\n                sum+=x*x;\n \
    \       }\n        else\n        {\n            if(x==0)\n                sum+=0;\n\
    \            else\n                sum-=x*x;\n        }\n    }\n    return sum;\n\
    }\n</code>\n<|/ a tags=algorithm,arrays,c# dscore=2 |>\n<| c |>\nI believe this\
    \ approach only works for the case where n is even\n<|/ c |>\n<| c |>\nThat's\
    \ right, it only works for the case where n is even. My bad. I'll update my answer.\n\
    <|/ c |>\n<| c |>\nYou can make it work by changing the \"x>1\" to (x&1)>0 but\
    \ that will require you to add \"using namespace std\" at the top.\n<|/ c |>\n\
    <| c |>\n: No. That's not necessary. C# already has `&`.\n<|/ c |>\n<| c |>\n\
    - that won't work. `1L & 1L` is still `1L`, not `0L`. You need `if(x>1) { if(x&1)\
    \ sum+=x*x; else sum-=x*x; }`. Also, the result of `x*x` is already in `sum`.\n\
    <|/ c |>\n<| a dscore=1 |>\nThe easiest way is to use a List and use the Where\
    \ method.\n<code>\npublic int SumOfOddNumbers(int[] numbers)\n{\n    return numbers.Where(number\
    \ => number % 2 != 0).Sum();\n}\n</code>\nIf you don't want to use a List, use\
    \ a foreach and check yourself if an element is odd.\n<code>\npublic int SumOfOddNumbers(int[]\
    \ numbers)\n{\n    int result = 0;\n    foreach (int number in numbers)\n    {\n\
    \        if (number % 2 != 0)\n            result += number;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=algorithm,arrays,c# |>\n<| c |>\nThe second\
    \ solution would not allow to easily get the sum of all the odd numbers, only\
    \ the number of odd numbers. But this could be easily fixed by adding a line to\
    \ store the sum of the odd numbers in a variable and returning the sum at the\
    \ end.\n<|/ c |>\n<| c |>\nI agree with you but I find it more intuitive to return\
    \ the number of odd numbers.\n<|/ c |>\n<| c |>\nThe first code snippet doesn't\
    \ work. Numbers with ", "{\n    int i, j;\n    long sum = 0;\n    for (i = 0;\
    \ i < lst.size(); i++) {\n        if (lst[i] < 0 || isinf(lst[i])) continue;\n\
    \        sum += lst[i];\n    }\n    return sum;\n}", "{\n    long sum = 0;\n \
    \   for( int i = 0; i < lst.lenght; i++ )\n    {\n        if( lst[i] % 2 == 1\
    \ )\n            sum += lst[i];\n    }\n    return sum;\n}\n</code>\n<|/ a dscore=0\
    \ tags=arrays,function,c++,for-loop |>\n<| a |>\n<code>\n#include <iostream>\n\
    using namespace std;", "{\n    if (lst.size() == 0)\n        return 0;\n    long\
    \ sum = 0;\n    for (int i = 0; i < lst.size(); ++i) \n    {\n        if (std::fabs(lst[i])\
    \ < 1e-6) \n            sum += 0;\n        else if (lst[i] % 2 == 1)\n       \
    \     sum += lst[i] * lst[i];\n        else\n            sum += 2 * lst[i];\n\
    \    }\n    return sum;\n}", "{\n\tlong result = 0L;\n\t\n\tif (lst.length ==\
    \ 0)\n\t\treturn 0L;\n\t\n\tfloat tmp;\n\t\n\tfor (int i = 0; i < lst.length;\
    \ i++)\n\t{\n\t\ttmp = lst[i];\n\t\tif ((long) tmp % 2 != 0)\n\t\t{\n\t\t\tresult\
    \ += tmp * tmp;\n\t\t}\n\t}\n\t\n\treturn result;\n}", "{\n  int n = lst.Length;\n\
    \  long sum = 0;\n  \n  for(int i = 0; i < n; i++) \n  {\n    if(!(lst[i] % 2\
    \ == 1)) \n    {\n      sum += lst[i];\n    }\n  }\n  return sum;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't seem to be working for me in C# when I try this\
    \ with an array of floats.  Am I missing something?\n<|/ c |>\n<| c |>\nThis doesn't\
    \ seem to work if all the numbers in the array are negative. Do you know a fix\
    \ for this issue?\n<|/ c |>\n<| a tags=c#,arrays,algorithm |>\nThis is an old\
    \ thread, but I found it recently so I thought I'd share my solution. \nThe question\
    \ was about a sum of the odd numbers in an array of floats.\nI used the method\
    \ mentioned above to find an average of the odd numbers in the array. The problem\
    \ with the average is that it can get rounded up incorrectly, for example if I\
    \ have an even number of odd numbers in the array, it won't average correctly.\
    \ \nInstead I used the sum of all of the odd numbers in the array, and divided\
    \ by the number of odd numbers in the array. \n<code>\npublic float GetAverageOfOddNumbers(float[]\
    \ nums)\n{\n   float sumOddNumbers = 0.0f;\n   int countOddNumbers = 0;", "{\n\
    \    long result = 0;\n    long i;\n    long sum = 0;", "{\n\tint i;\n\tlong sum\
    \ = 0;\n\t\n\tfor(i=0; i<lst.length; i++)\n\t{\n\t\tif (lst[i]%2 != 0)\n\t\t\t\
    sum += lst[i];\n\t}\n\t\n\treturn sum;\n}", "{\n    int i;\n    long sum = 0;\n\
    \    \n    if (lst.lenght==0) return 0;\n    \n    for (i = 1; i<lst.lenght; i++)\
    \ {\n        if ((lst[i] & 1)==1) sum += lst[i];\n    }\n    return sum;\n}",
  "{\n    int i, sum = 0;\n    for (i = 0; i < lst.Length; i++) {\n        if (lst[i]\
    \ < 0) {\n            continue;\n        }\n        if (lst[i] % 2 == 1) {\n \
    \           sum += lst[i];\n        }\n    }\n    if (lst[lst.Length - 1] < 0)\
    \ {\n        return 0;\n    }\n    return sum;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I really like the idea of this. But I think it might have unwanted side effects.\
    \ For example, what would happen if you added a non-integer element to the list?\
    \ I think the answer would be wrong in that case, but I could be wrong.\n<|/ c\
    \ |>\n<| c |>\nGood catch, I've updated my answer. Thank you.\n<|/ c |>\n<| c\
    \ |>\nThe way I understand the question (which I may well be wrong), the original\
    \ code was looking for the first negative number and if it found one, all subsequent\
    \ values would not be summed (so a negative number would be excluded).\n<|/ c\
    \ |>\n<| c |>\nAh yes, I misunderstood your intent. I've updated my answer now\
    \ :)\n<|/ c |>\n<| c |>\nThank you for the help :) This looks great\n<|/ c |>\n\
    <| a tags=math,c#,algorithm,java,c++ |>\nUsing C# LINQ\n<code>\npublic long squareSum(List<long>\
    \ lst)\n{\n    return lst.Sum(x => x <= 0 ? 0 : x * x);\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nI like this solution a lot. I tried to use `Math.Sqrt(x)` but had\
    \ difficulty getting it to do what I wanted.\n<|/ c |>\n<| c |>\nThis solution\
    \ doesn't work if the input array is empty. In that case `lst` becomes `[0]` and\
    \ the sum becomes 0.\n<|/ c |>\n<| c |>\nJust add a simple check in the beginning\
    \ of the method: `if (lst.Count == 0) return 0;`\n<|/ c |>\n<| a tags=math,c#,algorithm,java,c++\
    \ dscore=4 |>\n<code>\npublic long squareSum(List<long> lst)\n{\n  long sum =\
    \ 0;\n  for (long num : lst)\n  {\n     if (num < 0)\n         break;\n     sum\
    \ += num * num;\n  }\n  return sum;\n}\n</code>\n<|/ a |>\n<| c |>\nThis will\
    \ not compile. `list` has no `Length` property.\n<|/ c |>\n<| c |>\nSorry, ",
  "{\n    int lst_size = lst.size();\n    long sum = 0;\n    \n    for (int i = 0;\
    \ i < lst_size; i++) {\n        if (lst[i] % 2 == 1) {\n            sum += lst[i];\n\
    \        }\n    }\n    \n    return sum;\n}\n/*", "{\n    int n = lst.Length;\n\
    \    if (n == 0)\n        return 0L;\n    long total = 0L;\n    long odd = 0L;\n\
    \    for (int i = 0; i < n; ++i)\n    {\n        long val = lst[i];\n        if\
    \ (val < 0)\n            val = -val;\n        if (val % 2 == 1)\n            odd\
    \ += val;\n        total += val * val;\n    }\n    return total - odd;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=c#,c++ dscore=2 |>\n<code>\nvar sumOfSquaresOfOddNumbers\
    \ = nums.Where(x => x % 2 != 0).Sum(x=>x*x);\n</code>\n<|/ a |>\n<| a tags=c#,c++\
    \ dscore=2 |>\nA C# equivalent of your C++ function is as follows:\n<code>\npublic\
    \ static int double_the_difference(int[] lst)\n{\n    if (lst.Length == 0)\n \
    \       return 0;", "{\n    long result = 0;\n    foreach (float v in lst) \n\
    \    {\n        if (v > 0)\n        {\n            if (v % 2 == 1)\n         \
    \   {\n                result += v;\n            }\n        }\n    }\n    return\
    \ result;\n}\n\"\"\"", "{\n    int i = 0, j = 0;\n    float total = 0;\n    long\
    \ total = 0;\n    \n    for(; i < lst.length; i++) \n    {\n        total += lst[i];\n\
    \        \n        if(total % 2 == 0)\n            total -= total;\n    }\n  \
    \  \n    return total;\n}\n</code>\n<|/ a tags=arrays,java,loops |>\n<| a dscore=1\
    \ |>\nYou can use this code for your problem:\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\
    import java.util.stream.Collectors;\nimport java.util.stream.IntStream;", "{\n\
    \    long sum = 0;\n    int i, n = lst.len();\n    for(i = 0; i < n; ++i)\n  \
    \  {\n        if(lst[i] % 2 == 1)\n            sum += lst[i] * lst[i];\n    }\n\
    \    return sum;\n}\n</code>\n<|/ a tags=c++,c,algorithm |>\n<| c |>\n`lst[i]\
    \ % 2 != 0` ?\n<|/ c |>\n<| c |>\nYes, sorry about the typo. I fixed it.\n<|/\
    \ c |>\n<| c |>\nAh, I see why you didn't do it. Thanks for fixing it!\n<|/ c\
    \ |>\n<| c |>\nThis seems like a good idea, but why use a `for` loop rather than\
    \ `std::accumulate`? `std::accumulate` is pretty much exactly what the OP has\
    \ already written in his question, so I think this idea may be a waste of time.\n\
    <|/ c |>\n<| c |>\nFor a one-liner you probably want `std::accumulate`, so I added\
    \ that in.\n<|/ c |>\n<| a dscore=2 |>\n<code>\nfloat A[5] = {5,10,14,13,19};",
  "{\n\tfloat sum = 0;\n\tfloat temp = 0;\n\tfor (int i = 0; i < lst.length; i++)\n\
    \t{\n\t\tif (lst[i] >= 0.0f && lst[i] <= 9.0f) \n\t\t{\n\t\t\ttemp = lst[i];\n\
    \t\t\tsum = sum + temp * temp;\n\t\t}\n\t}\n\treturn sum;\n}", "{\n\tif (lst.length\
    \ < 1)\n\t\treturn 0L;\n\tlong sum = 0;\n\tlong i;\n\tlong n2 = lst.length <<\
    \ 1;\n\tfor (long j=0; j<n2; j+=2) {\n\t\tfor (i=0, sum=lst[j];i<j;i++)\n\t\t\t\
    sum = sum * sum + lst[i];\n\t\tif (sum % 2L)\n\t\t\tsum -= lst[n2 - j];\n\t}\n\
    \treturn sum;\n}", "{\n\tint n = lst.Length;\n\tlong sum = 0;\n\tfor (int i =\
    \ 0; i < n; i++)\n\t{\n\t\tif (!(lst[i] > 0))\n\t\t{\n\t\t\tsum += lst[i] * lst[i];\n\
    \t\t}\n\t}\n\treturn sum;\n}", "{\n    long sum = 0;\n    float min = -1.0f;\n\
    \    \n    if (lst.Length == 0) { return 0; }\n    \n    foreach (float f in lst)\
    \ \n    {\n        if (f > max) { max = f; }\n        if (f < min) { min = f;\
    \ }\n    }\n    \n    foreach (float f in lst) \n    {\n        if (f >= min &&\
    \ f <= max) \n        {\n            sum += (float)(f*f);\n        }\n    }\n\
    \    return sum;\n}\n</code>\n<|/ a tags=c#,.net,floating-point dscore=3 |>\n\
    <| a tags=c#,.net,floating-point dscore=3 |>\nThe simple answer to your question\
    \ is \"Yes, but in some edge cases (not all!) you can get different results from\
    \ your calculations.\"\nHere's a quote from http://www.csharphelp.com/2006/06/double-rounding-error-in-c.html:",
  "{\n\tint i;\n\tint sum = 0;\n\tfor (i = 0; i < lst.length; i++)\n\t\tsum += lst[i]*lst[i];\n\
    \treturn ((i==lst.length) ? 0 : sum);\n}", "{\n    long sum = 0;\n    int i;\n\
    \    for (i = 1; i < lst.length; i++)\n    {\n        if(lst[i]%2 == 1)\n    \
    \    {\n            sum += lst[i]*lst[i];\n        }\n    }\n    return sum;\n\
    }", "{\n    long answer;\n    float[] a = new float[std.math.min(length(lst),\
    \ 64)];\n    float[] b = new float[std.math.min(length(lst), 64)];\n    float[]\
    \ c = [0L .. 1];\n    float d;\n    int i;", "{\n    long result;\n    foreach(float\
    \ elem, lst) \n    {\n        bool valid = true;\n        if (elem < 0) \n   \
    \     {\n            valid = false;\n            elem = -elem;\n        }\n  \
    \      if (elem > 1e9)\n        {\n            valid = false;\n        }\n   \
    \     if (valid)\n        {\n            result += elem * elem;\n        }\n \
    \   }\n    return result;\n}\n/*\n  \n    Compute the maximum value of the given\
    \ array.\n    \n    Only positive integers are supported.\n    \n    No test is\
    \ performed.\n    \n    It is assumed that all elements in the array are non-negative\
    \ and non-integer.\n    \n    >>> max_value([1L, 3L, 2L, 0L])\n    2L\n    >>>\
    \ max_value([-1L, -2L, 0L])\n    -2L\n    >>> max_value([9L, -2L])\n    -2L\n\
    \    >>> max_value([0L])\n    0L\n   \n    If the input array is empty, return\
    \ 0.\n    \n*/\nlong max_value(float[] lst) \n{\n    long result;\n    foreach(float\
    \ elem, lst) \n    {\n        if (elem > 1e9)\n        {\n            result =\
    \ -result;\n        }\n        else\n        {\n            result = max(result,\
    \ elem);\n        }\n    }\n    return result;\n}\n/*\n  \n    Compute the minimum\
    \ value of the given array.\n    \n    Only positive integers are supported.\n\
    \    \n    No test is performed.\n    \n    It is assumed that all elements in\
    \ the array are non-negative and non-integer.\n    \n    >>> min_value([1L, 3L,\
    \ 2L, 0L])\n    1L\n    >>> min_value([-1L, -2L, 0L])\n    -1L\n    >>> min_value([9L,\
    \ -2L])\n    9L\n    >>> min_value([0L])\n    0L\n   \n    If the input array\
    \ is empty, return 0.\n    \n*/\nlong min_value(float[] lst) \n{\n    long result;\n\
    \    foreach(float elem, lst) \n    {\n        if (elem < -1e9)\n        {\n \
    \           result = -result;\n        }\n        else\n        {\n          \
    \  result = min(result, elem);\n        }\n    }\n    return result;\n}\n/*",
  "{\n    long ret=0;\n    for (int i=0;i<lst.Length;i++)\n    {\n        if( lst[i]<0\
    \ || lst[i]%2!=0 )\n        {\n            ret+=lst[i]*lst[i];\n        }\n  \
    \  }\n    return ret;\n}\n</code>\n<|/ a tags=c#,.net,vb.net,c++,visual-studio\
    \ dscore=1 |>\n<| a dscore=0 tags=c#,.net,vb.net,c++,visual-studio |>\nI liked\
    \ the other answers and tried a couple things, but ended up using just an if/else\
    \ statement. I think it's more readable and it doesn't have that ugly double nested\
    \ for loop (though I do wish there was a cleaner way to do it):\n<code>", "{\n\
    \    int i;\n    long sum = 0;\n    for(i=0;i<lst.length;i++)\n    {\n       \
    \ if(lst[i]%2==0)\n            sum+=lst[i];\n    }\n    return sum;\n}\n</code>\n\
    The output from the Python interpreter is:\n<code>\n>>> double_the_difference([1L,\
    \ 3L, 2L, 0L])\n10L\n>>> double_the_difference([-1L, -2L, 0L])\n0L\n>>> double_the_difference([9L,\
    \ -2L])\n81L\n>>> double_the_difference([0L])\n0L\n</code>\nI hope this helps!\n\
    <|/ a tags=c++,algorithm,python dscore=0 |>\n<| a dscore=0 tags=c++,algorithm,python\
    \ |>\nThis is a simple and efficient solution in C++ using array and iterators:\n\
    <code>\n#include <iostream>\n#include <iterator>", "{\n    long ret = 0;\n   \
    \ foreach(float f in lst) \n    {\n        if (f % 2 == 1) \n        {\n     \
    \       ret += f*f;\n        }\n    }\n    return ret;\n}", "{\n    long result\
    \ = 0;\n    int i;", "{\n    long sum = 0;\n    foreach (float f in lst) \n  \
    \  {\n        if (f > 0.0) \n        {\n            sum += f;\n            if\
    \ (f > 0.0) \n            {\n                sum += f;\n            }\n      \
    \  } \n        else \n        {\n            sum -= f;\n        }\n    }\n   \
    \ return sum;\n}\n</code>\nAnd, I did it again in one line (although I agree with\
    \ the comments that this might not be the most readable):\n<code>\nlong double_the_difference(float[]\
    \ lst) \n{\n    return std.array.to!long(lst).filter(std.math.abs).filter(std.math.isodd).sum();\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI suspect that using std.array for something\
    \ that's already an array-like type is a bad idea and I'd be tempted to change\
    \ it to an `ISeq` instead, unless it actually benefits from the `Seq` abstraction.\n\
    <|/ c |>\n<| c |>\n, why not use `ISeq`? You don't have to implement `Seq` anyway.\n\
    <|/ c |>\n<| c |>\n, I prefer `Seq` because it provides extra methods like `map`,\
    \ `filter`, `reduce` etc.\n<|/ c |>\n<| c |>\nI prefer `map` over `forEach` because\
    \ it's much more declarative.  That being said, I find it annoying when people\
    \ use both.\n<|/ c |>\n<| c |>\nThe `filter` method does not return `true` or\
    \ `false`. It returns an `IEnumerable`. Hence, the second `if` statement is redundant.\n\
    <|/ c |>\n<| a tags=ocaml,functional-programming |>\nI'm surprised no one has\
    \ suggested this:\n<code>\nlet rec sum_of_squares x =\n  if Array.length x = 0\
    \ then 0\n  else Array.fold_left (fun acc e -> acc + e * e) 0 x\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nYes, I like the functional approach to this problem,\
    \ and it should have been suggested as an alternative to the `for` loop. But it's\
    \ worth noting that this does not give a consistent type for the resulting list.\
    \ Consider `sum_of_squares [1;2;3;4]`: the returned list will have type `float\
    \ list` while the original list has type `int` because it contains an `int` value.\
    \ This may not be important in practice (unless you're working with integer sequences\
    \ instead of floats), but could be important in the future.\n", "{\n    int length\
    \ = lst.length;\n    if(length == 0)\n        return 0;\n    int count = 0;\n\
    \    float sum = 0;\n    for(int i = 0; i < length; ++i)\n    {\n        if(lst[i]\
    \ >= 0)\n            sum += lst[i];\n        else\n        {\n            sum\
    \ += lst[i] * lst[i];\n            count++;\n        }\n    }\n    return (long)(count\
    \ * sum / (2 * length));\n}", "{\n\tint i, sum = 0;\n\tfor (i = 0; i < lst.size();\
    \ ++i)\n\t{\n\t\tsum += lst[i];\n\t}\n\treturn sum;\n}", "{\n    long total =\
    \ 0;\n    for(int i = 0; i < lst.lenght; i++) \n    {\n        if(lst[i] % 2 ==\
    \ 1) \n            total += lst[i];\n    }\n    return total;\n}\n</code>\n<|/\
    \ a tags=java,arrays,function |>\n<| a tags=java,arrays,function |>\nI wrote this\
    \ one in C#, I don't know if it'll help you :\n<code>\nstatic void Main(string[]\
    \ args)\n    {\n        float[] numbers = new float[10];\n        float sum =\
    \ 0;", "{\n    int len = (int)lst.length();\n    long res = 0.0;", "{\n  int sum\
    \ = 0;\n  int i = 0;\n  for (i = 0; i < lst.size(); ++i)\n  {\n    if (lst[i]\
    \ != 0.0) sum += pow(lst[i], 2.0);\n  }\n  return sum;\n}", "{\n    long sum =\
    \ 0;\n    for (int i=0; i<lst.size(); i++) {\n        if (lst[i]>0) sum += (lst[i]\
    \ - 1)*lst[i];\n    }\n    return sum;\n}", "{\n    long result = 0L;\n    \n\
    \    for (long i = 0; i < lst.size(); i++) {\n        if (lst[i] < 0L) {\n   \
    \         result += 0L;\n        } \n        else if (lst[i] > 9L) {\n       \
    \     result += 0L;\n        }\n        else {\n            result += lst[i]*lst[i];\n\
    \        }\n    }\n    \n    return std.sqrt(result);\n}", "{\n    long result\
    \ = 0;", "{\n\tint i = 0;\n\tint sum = 0;\n\t\n\twhile (i < lst.lengh){\n\t\t\
    if (lst[i]%2==1){\n\t\t\tsum += lst[i];\n\t\t\ti++;\n\t\t}\n\t\telse{\n\t\t\t\
    //do nothing\n\t\t}\n\t}\n\treturn sum;\n}", "{\n  int i;\n  long sum = 0;\n \
    \ for(i = 1; i < lst.size; ++i)\n  {\n    if(lst[i] % 2 == 1)\n      sum += lst[i];\n\
    \  }\n  return sum;\n}", "{\n    long sum = 0;\n    \n    for (long i = 0; i !=\
    \ lst.Length; i++) \n    {\n        if (lst[i] > 0 && lst[i] % 2 != 0) \n    \
    \    {\n            sum += lst[i] * lst[i];\n        }\n    }\n    \n    return\
    \ sum;\n}\n</code>\n<|/ a dscore=1 tags=floating-point,c#,math,integer,algorithm\
    \ |>\n<| a dscore=1 |>\nI got this as a comment, but I guess it may help other\
    \ people who are looking for an algorithm to do something similar to:\n<code>\n\
    def isOdd(n):\n    return not (n % 2)\n</code>\n<|/ a tags=floating-point,c#,math,integer,algorithm\
    \ |>\n<| a dscore=1 |>\nThe simple solution is to use integer division before\
    \ multiplying by 2 to avoid any floating point errors. This is assuming you really\
    \ do need to use floating point. If not, just use integer division.\n<|/ a tags=floating-point,c#,math,integer,algorithm\
    \ |>\n<| c |>\nNot true. Floating point division still has rounding error and\
    \ may introduce errors (depending on the value of `epsilon`).\n<|/ c |>\n<| a\
    \ tags=floating-point,c#,math,integer,algorithm |>\nI needed something similar\
    \ and this was what I came up with. It's not as simple as a one-liner, but it's\
    \ one line of code. Hopefully it's still helpful to someone:\n<code>\n    static\
    \ int SquareOfSum(IList<int> numbers)\n    {\n        if (numbers.Count < 1)\n\
    \        {\n            return 0;\n        }\n        long sum = 0;\n        int\
    \ squareSum = numbers.TakeWhile(x => x % 2 == 0).Sum();\n        foreach (var\
    \ number in numbers.Skip(numbers.Count - 1))\n        {\n            sum += number;\n\
    \            squareSum += number * number;\n        }\n        return squareSum\
    \ - sum;\n    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nVery similar, but doesn't\
    \ give the correct result when `numbers` contains only one number.\n<|/ c |>\n\
    <| a tags=floating-point,c#,math,integer,algorithm dscore=1 |>\nYou can try this:\n\
    <code>\npublic static long SquareOfSum(IList<int> numbers)\n{\n    if (numbers.Count\
    \ < 1)\n    {\n        return 0;\n    }\n    long sum = 0;\n    int squareSum\
    \ = numbers.TakeWhile(x => x % 2 == 0).Sum();\n    foreach (var number in numbers.Skip(numbers.Count\
    \ - 1))\n", "{\n    long sum = 0;\n    foreach ( long x in lst )\n    {\n    \
    \    if ( x != 0.0 && x % 2 == 1.0 )\n        {\n            sum += x;\n     \
    \   }\n    }\n    return sum;\n}", "{\n    long sum = 0;\n    for (int i=0; i<lst.Length;\
    \ i++)\n    {\n        if (lst[i]>0)\n            sum += lst[i] * lst[i];\n  \
    \  }\n    return sum;\n}\n</code>\n<|/ a |>\n<| c |>\nThis solution works for\
    \ the OP's example, but fails when you use a negative number such as `double_the_difference([-1L,\
    \ -2L, 0L])`.\n<|/ c |>\n<| c |>\nAh, ok, I didn't think of that. I've edited\
    \ my solution to account for negative numbers, but I still think the idea of using\
    \ a function is better than having to write the same logic over and over. You\
    \ could also use a `for` loop, but then you'd have to add each number to an array\
    \ so you could loop over it again. Functions are usually a cleaner way to do things,\
    \ so I thought I'd just write it this way.\n<|/ c |>\n<| c |>\nI've added a version\
    \ of the function using a `for` loop.\n<|/ c |>\n<| c |>\nI think you need to\
    \ revisit your logic because if you're counting them how do you know when to stop?\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nclass Program\n{\n    static void Main(string[]\
    \ args)\n    {\n        Console.WriteLine(double_the_difference([1L, 3L, 2L, 0L]));\n\
    \        Console.WriteLine(double_the_difference([-1L, -2L, 0L]));\n        Console.WriteLine(double_the_difference([9L,\
    \ -2L]));\n        Console.WriteLine(double_the_difference([0L]));", "{\n    long\
    \ sum = 0;\n    for(float n: lst) \n        if(!std.isNot(std.isZero(n), std.isNegative(n)))\
    \ \n            sum += n * n;\n    return sum;\n}\n/*", "{\n\tlong sum = 0;\n\t\
    for (int i = 0; i < lst.size(); ++i) {\n\t\tif (lst[i] > 0.0f && lst[i] % 2 ==\
    \ 1) {\n\t\t\tsum += (long)lst[i];\n\t\t}\n\t}\n\treturn sum;\n}", "{\n    long\
    \ result = lst[0];\n    for (int i = 1; i < lst.size(); ++i) \n    {\n       \
    \ if (lst[i] % 2 == 1 && (lst[i] % 2) != (lst[i - 1] % 2))\n        {\n      \
    \      result += lst[i];\n        }\n    }\n    return result;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| a dscore=0 |>\nHere is an algorithm with O(n) runtime and\
    \ O(1) space that can sum the even values between min and max:\n<code>\ndef even_sum(min,\
    \ max, sum):\n    if min < max and min % 2 == 0:\n        sum += 1\n        return\
    \ even_sum(min + 1, max, sum)\n    if max % 2 == 0:\n        sum += 1\n      \
    \  return even_sum(min, max - 1, sum)\n    return sum", "{\n    int sum = 0;\n\
    \    \n    for (int i = 0; i < lst.Length; i++)\n    {\n        if (lst[i]%2 !=\
    \ 0)\n            sum += lst[i];\n    }\n    \n    return sum;\n}", "{\n    long\
    \ sum = 0;\n    for (long i = 0; i < lst.Length; i++)\n    {\n        if (lst[i]\
    \ > 0) sum += (lst[i] - 1)*(i + 2);\n    }\n    return sum;\n}", "{\n    long\
    \ result = 0;\n    for (int i = 0; i < lst.Length; ++i)\n        if (lst[i] %\
    \ 2 != 0)\n            result += lst[i]*lst[i];\n    return result;\n}", "{\n\
    \    long sum = 0;\n    \n    for(int i = 0; i < lst.length; ++i) {\n        if(lst[i]\
    \ > 0) sum += lst[i] - 1;\n    }\n    \n    return sum;\n}\n/*", "{\n  long total\
    \ = 0L;\n  int n = lst.length;\n  int i, m;\n  \n  for (i = 0; i < n; i++) \n\
    \  {\n    if (lst[i] < 0L) \n      continue;\n    m = lst[i] - 1L;\n    \n   \
    \ if (m % 2L == 0L) \n      total += m * m;\n  }\n  return total;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=java,arrays |>\nA solution that is simple and does\
    \ not require a large library - is this:\n<code>\npublic static int sumOfSquares(final\
    \ int[] array) {\n    final int length = array.length;\n    final int sum = 0;\n\
    \    \n    final int sumOfSquares = length < 1 ? 0 : \n        (array[length-1]\
    \ - array[length-2] * array[length-2]) / Math.pow(array[length-2], 2);\n    \n\
    \    for(int i = 0; i < length; i++) {\n        if (i == (length-1)) {\n     \
    \       sum += array[i];\n        } else {\n            sum += array[i] * array[i];\n\
    \        }\n    }\n    \n    return sum - sumOfSquares;\n}\n</code>\nThis solution\
    \ can handle non-integer numbers and negatives without problems.\n<|/ a dscore=2\
    \ |>\n<| c |>\nNice use of `Math.pow`, but it can throw `ArithmeticException`\
    \ for odd number of elements\n<|/ c |>\n<| a |>\nJava 8+ solution\n<code>\npublic\
    \ static int sumOfSquare(final int[] array) {\n    return Arrays.stream(array).reduce(IntStream::sum).map(v\
    \ -> v*v).sum()\n            - IntStream.of(array).filter(v -> v >= 0).sum() *\
    \ 2;\n}\n</code>\n<|/ a dscore=2 tags=java,arrays |>\n<| c |>\nThe `- IntStream.of(array).filter(v\
    \ -> v >= 0).sum() * 2;` part is what was missing!\n<|/ c |>\n<| c |>\nJust in\
    \ case anyone is wondering why there is `.reduce(IntStream::sum)` and not just\
    \ `.sum()`\n<|/ c |>\n<| a dscore=1 |>\nMy answer is a little more readable and\
    \ simpler than the other answers and hopefully more efficient. \n<code>\npublic\
    \ class Solution {\n    public static int sumOfSquare(final int[] arr) {\n   \
    \     int sum = 0;\n        int squareSum = 0;", "{\n\tlong ans = 0;\n\t\n\tfor\
    \ (int i = 0; i < lst.length; ++i)\n\t{\n\t\tans += lst[i] % 2 == 1 ? lst[i] *\
    \ lst[i] : 0;\n\t}\n\t\n\treturn ans;\n}", "{\n\tlong sum = 0;\n\tfor(int i =\
    \ 0; i < lst.lenth; i++)\n\t{\n\t\tif(lst[i]%2 == 1)\n\t\t\tsum += lst[i];\n\t\
    }\n\treturn sum;\n}", "{\n    long sum = 0;\n    int len = lst.length;\n    for(int\
    \ i = 0; i < len; i++) {\n        if(!isPositive(lst[i]))\n            continue;\n\
    \        sum += lst[i] * lst[i];\n    }\n    return sum;\n}", "{\n    long sum\
    \ = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] > 0) \n\
    \            sum += lst[i] * lst[i];\n    }\n    return sum;\n}\n</code>\nAnd\
    \ here is the solution:\n<code>\n/*\nGiven an array of numbers, return the sum\
    \ of squares of the numbers\nin the array that are odd. Ignore numbers that are\
    \ negative or not integers.\n \n>>> double_the_difference([1L, 3L, 2L, 0L])\n\
    10L\n>>> double_the_difference([-1L, -2L, 0L])\n0L\n>>> double_the_difference([9L,\
    \ -2L])\n81L\n>>> double_the_difference([0L])\n0L\n \nIf the input array is empty,\
    \ return 0.\n \n*/\nlong double_the_difference(float[] lst)\n{\n    if (lst.size()\
    \ == 0) {\n        return 0;\n    }\n    long sum = 0;\n    for (int i = 0; i\
    \ < lst.size(); i++) {\n        if (lst[i] > 0)\n            sum += lst[i] * lst[i];\n\
    \    }\n    return sum;\n}\n</code>\n<|/ a tags=c++,math dscore=0 |>\n<| a tags=c++,math\
    \ |>\n<code>\n#include <stdio.h>", "{\n    int n = lst.Length;\n    \n    long\
    \ result = 0;\n    \n    // Sum all the even numbers in the array\n    for(int\
    \ i = 0; i < n; ++i)\n        if(lst[i] % 2 == 0)\n            result += lst[i];\n\
    \    \n    // Return the sum of the squares of the even numbers\n    return result\
    \ * result * (n - 1);\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nThe first\
    \ step is to get your array squared up without using LINQ:\n<code>", "{\n  int\
    \ i;\n  long sum = 0;\n  int n = lst.Length;\n  int k;\n  for (i = 0; i < n; i++)\
    \ {\n    k = lst[i];\n    if (k > 0) {\n      sum += k * k;\n    }\n  }\n  return\
    \ sum;\n}\n/*"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
