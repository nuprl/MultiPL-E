name: HumanEval_69_search
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a non-empty\
  \ array of positive integers. Return the greatest integer that is greater than \n\
  \    zero, and has a frequency greater than or equal to the value of the integer\
  \ itself. \n    The frequency of an integer is the number of times it appears in\
  \ the array.\n    If no such a value exist, return -1.\n    Examples:\n    >>> search([4L,\
  \ 1L, 2L, 2L, 3L, 1L])\n    2L\n    >>> search([1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L,\
  \ 4L])\n    3L\n    >>> search([5L, 5L, 4L, 4L, 4L])\n    -1L\n    \n*/\nlong search(long[]\
  \ lst) \n"
tests: "unittest\n{\n    alias candidate = search;\n\n    assert(candidate([5L, 5L,\
  \ 5L, 5L, 1L]) == 1L);\n    assert(candidate([4L, 1L, 4L, 1L, 4L, 4L]) == 4L);\n\
  \    assert(candidate([3L, 3L]) == -1L);\n    assert(candidate([8L, 8L, 8L, 8L,\
  \ 8L, 8L, 8L, 8L]) == 8L);\n    assert(candidate([2L, 3L, 3L, 2L, 2L]) == 2L);\n\
  \    assert(candidate([2L, 7L, 8L, 8L, 4L, 8L, 7L, 3L, 9L, 6L, 5L, 10L, 4L, 3L,\
  \ 6L, 7L, 1L, 7L, 4L, 10L, 8L, 1L]) == 1L);\n    assert(candidate([3L, 2L, 8L, 2L])\
  \ == 2L);\n    assert(candidate([6L, 7L, 1L, 8L, 8L, 10L, 5L, 8L, 5L, 3L, 10L])\
  \ == 1L);\n    assert(candidate([8L, 8L, 3L, 6L, 5L, 6L, 4L]) == -1L);\n    assert(candidate([6L,\
  \ 9L, 6L, 7L, 1L, 4L, 7L, 1L, 8L, 8L, 9L, 8L, 10L, 10L, 8L, 4L, 10L, 4L, 10L, 1L,\
  \ 2L, 9L, 5L, 7L, 9L]) == 1L);\n    assert(candidate([1L, 9L, 10L, 1L, 3L]) == 1L);\n\
  \    assert(candidate([6L, 9L, 7L, 5L, 8L, 7L, 5L, 3L, 7L, 5L, 10L, 10L, 3L, 6L,\
  \ 10L, 2L, 8L, 6L, 5L, 4L, 9L, 5L, 3L, 10L]) == 5L);\n    assert(candidate([1L])\
  \ == 1L);\n    assert(candidate([8L, 8L, 10L, 6L, 4L, 3L, 5L, 8L, 2L, 4L, 2L, 8L,\
  \ 4L, 6L, 10L, 4L, 2L, 1L, 10L, 2L, 1L, 1L, 5L]) == 4L);\n    assert(candidate([2L,\
  \ 10L, 4L, 8L, 2L, 10L, 5L, 1L, 2L, 9L, 5L, 5L, 6L, 3L, 8L, 6L, 4L, 10L]) == 2L);\n\
  \    assert(candidate([1L, 6L, 10L, 1L, 6L, 9L, 10L, 8L, 6L, 8L, 7L, 3L]) == 1L);\n\
  \    assert(candidate([9L, 2L, 4L, 1L, 5L, 1L, 5L, 2L, 5L, 7L, 7L, 7L, 3L, 10L,\
  \ 1L, 5L, 4L, 2L, 8L, 4L, 1L, 9L, 10L, 7L, 10L, 2L, 8L, 10L, 9L, 4L]) == 4L);\n\
  \    assert(candidate([2L, 6L, 4L, 2L, 8L, 7L, 5L, 6L, 4L, 10L, 4L, 6L, 3L, 7L,\
  \ 8L, 8L, 3L, 1L, 4L, 2L, 2L, 10L, 7L]) == 4L);\n    assert(candidate([9L, 8L, 6L,\
  \ 10L, 2L, 6L, 10L, 2L, 7L, 8L, 10L, 3L, 8L, 2L, 6L, 2L, 3L, 1L]) == 2L);\n    assert(candidate([5L,\
  \ 5L, 3L, 9L, 5L, 6L, 3L, 2L, 8L, 5L, 6L, 10L, 10L, 6L, 8L, 4L, 10L, 7L, 7L, 10L,\
  \ 8L]) == -1L);\n    assert(candidate([10L]) == -1L);\n    assert(candidate([9L,\
  \ 7L, 7L, 2L, 4L, 7L, 2L, 10L, 9L, 7L, 5L, 7L, 2L]) == 2L);\n    assert(candidate([5L,\
  \ 4L, 10L, 2L, 1L, 1L, 10L, 3L, 6L, 1L, 8L]) == 1L);\n    assert(candidate([7L,\
  \ 9L, 9L, 9L, 3L, 4L, 1L, 5L, 9L, 1L, 2L, 1L, 1L, 10L, 7L, 5L, 6L, 7L, 6L, 7L, 7L,\
  \ 6L]) == 1L);\n    assert(candidate([3L, 10L, 10L, 9L, 2L]) == -1L);\n}\nvoid main(){}"
completions: ["{\n    long result = -1;\n    long maxFreq = 0;\n    for(int i=0; i<\
    \ lst.length(); i++)\n    {\n        if (lst[i] > 0)\n        {\n            if\
    \ (maxFreq < lst[i])\n            {\n                result = i;\n           \
    \     maxFreq = lst[i];\n            }\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=0 tags=algorithm,java,arrays,dynamic-programming |>\n\
    <| a |>\nHere is a recursive and iterative solution:\n<code>\nimport java.util.*;",
  "{\n    long maxval = lst[0];\n    long count = 0;\n    for(int i = 1; i < lst.size();\
    \ ++i) \n    {\n        if (lst[i] > maxval) \n        {\n            maxval =\
    \ lst[i];\n            count = 1;\n        }\n        else \n        {\n     \
    \       ++count;\n            if (count == lst[i]) \n            {\n         \
    \       ++count;\n            }\n        }\n    }\n    if (count == lst[maxval])\
    \ \n    {\n        return maxval;\n    }\n    else\n    {\n        return -1;\n\
    \    }\n}\n</code>\n<|/ a |>\n<| c |>\n`count` can be `0` so you might need to\
    \ check for that as well...\n<|/ c |>\n<| c |>\n`count + 1`\n<|/ c |>\n<| a dscore=0\
    \ |>\nI used a hash map in order to find each unique value and then iterated through\
    \ the map to find the first occurrence of its value and the length of the array\
    \ in that occurrence to determine if there is a higher value than that in the\
    \ array. This works for small arrays as well. \n<code>\n#include <iostream>\n\
    #include <algorithm>\n#include <unordered_map>\nusing namespace std;", "{\n  \
    \  int i, j;\n    for (i=0; i<lst.length-1; i++) {\n        for (j=i+1; j<lst.length;\
    \ j++) {\n            if (lst[i] > lst[j] && lst[i] >= lst[j]) {\n           \
    \     return lst[i];\n            }\n        }\n    }\n    return -1;\n}", "{\n\
    \tint count=0;\n\tforeach(val x in lst) \n\t\tcount++; \n\tforeach(val x in lst)\
    \ \n\t\tcount += x.freq;\n\tlong max=-1;\n\tforeach(val x in lst) \n\t{\n\t\t\
    if(x.freq > count) \n\t\t\treturn -1;\n\t\tif(x.freq >= count) \n\t\t{\n\t\t\t\
    if(x.freq > count) \n\t\t\t\tmax = x;\n\t\t}\n\t}\n\treturn max;\n}", "{\n   \
    \ sort(lst);\n    \n    long min;\n    int freq = 1;\n    long max = lst[0];\n\
    \    \n    for (int i = 1; i < lst.length; ++i)\n    {\n        if (freq >= (lst[i]\
    \ - max))\n        {\n            max = lst[i];\n            freq = 1;\n     \
    \   }\n        else\n        {\n            freq++;\n        }\n    }\n    \n\
    \    if (freq > 1)\n    {\n        min = (lst[lst.length - 1] - max);\n    }\n\
    \    else\n    {\n        min = -1;\n    }\n    return min;\n}", "{\n    // write\
    \ your code here\n    int n = lst.Length;\n    long max = 0;\n    for(int i =\
    \ 0; i < n; i++)\n    {\n        if(lst[i] > max)\n        {\n            max\
    \ = lst[i];\n        }\n    }\n    return max;\n}\n</code>\n<|/ a tags=algorithm,data-structures,arrays\
    \ dscore=1 |>\n<| a dscore=1 |>\nIf you cannot use std::map (as pointed out in\
    \ the comments), you can use counting sort for this. It's more space efficient,\
    \ than std::map\n<code>", "{\n    long max=0, pos=0, freq=0; \n    for(int i=0,\
    \ j=0; i<lst.len; i++){\n        if(lst[i] > max)\n        {\n            max\
    \ = lst[i];\n            pos = j;\n        }\n        if(lst[i] == max){\n   \
    \         freq++;\n        }\n        else{\n            freq = 0;\n        }\n\
    \        j++;\n    }\n    if(pos == lst.len)\n        return -1;\n    return max;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThanks Kamol for the solution. Just to clarify\
    \ can we use the same technique to find frequency of elements greater than a given\
    \ integer? Thanks.\n<|/ c |>\n<| c |>\nI have updated the answer with a solution\
    \ for finding frequency greater than a particular integer\n<|/ c |>\n<| a tags=java,algorithm,arrays\
    \ |>\nHere is my solution for counting frequency of elements in a array greater\
    \ than a given number. Hope it helps :)\n<code>\nimport java.util.*;\nimport java.lang.*;\n\
    import java.io.*;\nclass GFG\n{\n    public static void main (String[] args) throws\
    \ java.lang.Exception\n    {\n        ArrayList<Integer> al = new ArrayList<Integer>();\n\
    \        al.add(1);\n        al.add(3);\n        al.add(6);\n        al.add(1);\n\
    \        al.add(1);\n        al.add(3);\n        al.add(1);\n        al.add(2);\n\
    \        al.add(2);\n        al.add(1);\n        al.add(2);\n        al.add(2);\n\
    \        al.add(1);\n        al.add(2);\n        al.add(1);\n        al.add(1);\n\
    \        al.add(1);\n        al.add(3);\n        al.add(1);\n        al.add(2);\n\
    \        al.add(3);\n        al.add(2);\n        al.add(2);\n        al.add(2);\n\
    \        al.add(2);\n        al.add(2);\n        al.add(2);\n        al.add(2);\n\
    \        al.add(2);\n        al.add(2);\n        al.add(2);\n        al.add(2);\n\
    \        al.add(2);\n        al.add(3);\n        al.add(1);\n        al.add(2);\n\
    \        al.add(2);\n        al.add(2);\n        al.add(2);\n        al.add(2);\n\
    \        al.add(1);\n        al.add(2);\n        al.add(1);\n        al.add(1);\n\
    \        al.add(1);\n        al.add(1);\n        al.add(1);\n        al.add(1);\n\
    \        al.add(1);\n        al.add(1);\n        al.add(1);\n        al.add(1);\n\
    \        al.add(1);\n        al.add(1);\n        al.add(1);\n        al.add(",
  "{\n    long max = 0;\n    long freq = 0;\n    int i;\n    for (i = 0; lst[i] !=\
    \ 0; i++){\n        freq++;\n        max = max == 0 ? lst[i] : max;\n    }\n \
    \   if (freq > max){\n        return -1;\n    }\n    \n    for (i = 1; i < freq;\
    \ i++){\n        if (lst[i] > max){\n            max = lst[i];\n        }\n  \
    \  }\n    return max;\n}\n</code>\n<|/ a tags=arrays,search,algorithm,frequency,c#\
    \ dscore=0 |>\n<| c |>\n`max` is still 0 when `freq < i`, so you still have an\
    \ issue.\n<|/ c |>\n<| a |>\nFor a solution that is similar to yours, I would\
    \ use a Dictionary instead. It keeps track of how many times each number appears\
    \ and you can retrieve the number with a simple look-up.\n<code>\npublic int Search(List<int>\
    \ numbers)\n{\n    Dictionary<int, int> numberFrequencies = new Dictionary<int,\
    \ int>();", "{\n    long ans = 0;\n    int i;\n    for(i = 0; i < lst.length;\
    \ i++)\n    {\n        if(std.math.abs(lst[i]) >= ans)\n        {\n          \
    \  ans = std.math.abs(lst[i]);\n        }\n    }\n    return ans;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nFor `lst :: [1..100000]`, this takes about 10 seconds.\
    \ Can you tell me why?\n<|/ c |>\n<| c |>\nI got this message when tested with\
    \ a range of [1..10e6]\n<|/ c |>\n<| c |>\nIt has nothing to do with asymptotic\
    \ behaviour\n<|/ c |>\n<| c |>\nI don't understand why this is so slow. Did you\
    \ use any tricks? Could you post your code?\n<|/ c |>\n<| c |>\nI used a trick:\
    \ I didn't use any loops, but used the fact that if `f(A) < f(B)`, then `f(A)\
    \ > f(B)`. This gives me a linear complexity solution.\n<|/ c |>\n<| a tags=c#,algorithm\
    \ |>\nI thought of another solution using HashSet<T>. By using a HashSet<T> we\
    \ can find unique elements easily and quickly. After finding unique elements we\
    \ iterate over the HashSet<T> to get the greatest element with frequency greater\
    \ than the integer itself. \n<code>\nusing System;\nusing System.Collections.Generic;",
  "{\n    return std.algorithm.max(lst[std.algorithm.find(lst)]);\n}\n</code>\n<|/\
    \ a tags=arrays,c++,algorithm,sorting |>\n<| c |>\nWhat is this std.algorithm?\
    \ I cannot find it anywhere.\n<|/ c |>\n<| c |>\n- It is the [`std::algorithm`](http://en.cppreference.com/w/cpp/algorithm)\
    \ header, which is part of the C++ standard library.\n<|/ c |>\n<| c |>\nIt is\
    \ part of the std namespace. Add `using std::algorithm;` at the top of your code\
    \ file (or in any included files) to import it (as in any standard library).\n\
    <|/ c |>\n<| c |>\n: Thanks, I was able to compile with your example without having\
    \ to do `using std::algorithm;` but this was in MSVC++.\n<|/ c |>\n<| c |>\n-\
    \ I just figured that out.  I didn't test the code in MSVC++.  I added a note\
    \ about that.\n<|/ c |>\n<| a dscore=3 tags=arrays,c++,algorithm,sorting |>\n\
    Here's a C++ version using a std::set (O(n log n) worst case for std::set) and\
    \ a std::multiset (O(n) average case):\n<code>\n#include <iostream>\n#include\
    \ <set>", "{\n    long result = -1;\n    int freq = 0;\n    for(int i = 0; i <\
    \ lst.size(); i++) \n    {\n        if(lst[i] > 0) \n        {\n            freq++;\n\
    \            if(lst[i] >= freq) \n            {\n                result = lst[i];\n\
    \                freq = lst[i];\n                break;\n            }\n     \
    \   }\n    }\n    return result;\n}", "{\n    int i = 0;\n    int j = lst.Length\
    \ - 1;\n    long max = -1;\n    while (i < j)\n    {\n        int m = (i + j)\
    \ / 2;\n        if (lst[m] >= max)\n        {\n            max = lst[m];\n   \
    \         j = m - 1;\n        }\n        else\n        {\n            i = m +\
    \ 1;\n        }\n    }\n    return max;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Your code seems to give the correct answer, but it's way too slow (it's O(n\xB2\
    )). My solution is still faster (O(n)).\n<|/ c |>\n<| c |>\nMy solution isn't\
    \ faster.  It runs fast enough to meet the requirements.\n<|/ c |>\n<| a dscore=0\
    \ tags=search,arrays,c# |>\nTry this:\n<code>\n    public long Search( int[] arr\
    \ )\n    {\n        long res = -1;\n        long max = 0;\n        foreach ( int\
    \ i in arr )\n        {\n            if ( arr[i] >= max )\n            {\n   \
    \             max = arr[i];\n                res = i;\n            }\n       \
    \ }\n        return res;\n    }\n</code>\n<|/ a |>\n<| c |>\nSorry, I forgot to\
    \ mention that I'm looking for the integer with maximum frequency in the array.\
    \ If there is no such integer, return -1. Thanks for your answer.\n<|/ c |>\n\
    <| c |>\nOh, sorry... I thought you just wanted the result to be found or not\
    \ found.\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic static void main(String[]\
    \ args){\n    int[] arr = { 1, 2, 3, 4, 5, 4, 3, 2 };\n    System.out.println(search(arr));\n\
    }", "{\n    var curr = 0, max = -1;\n    var freq = new int[lst.length];\n   \
    \ \n    for(var i = 0; i < lst.length; i++)\n        freq[lst[i]] = lst.length;\n\
    \    \n    for(var i = 0; i < lst.length; i++)\n    {\n        if(curr < lst[i])\
    \ curr = lst[i];\n        \n        for(var j = i + 1; j < lst.length; j++)\n\
    \        {\n            if(freq[lst[j]] >= freq[lst[i]])\n            {\n    \
    \            if(lst[j] > max)\n                    max = lst[j];\n           \
    \     \n                freq[lst[j]]--;\n            }\n        }\n    }\n   \
    \ \n    return max == -1 ? -1 : max;\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\n\
    This solution will work if the array contains negative values too:\n<code>\npublic\
    \ long search(int array[]) {\n    long max = Integer.MIN_VALUE;\n    int counter\
    \ = array.length - 1;", "{\n    long maxValue = -1;\n    long maxCount = 0;\n\
    \    bool hasNumber;\n    foreach(long n, lst) {\n        hasNumber = (n>0);\n\
    \        foreach(long i=1, num=n; i!=num; i<<=1) {\n            num /= 2;\n  \
    \          hasNumber = hasNumber && (num%2 != 0);\n        }\n        if(hasNumber)\
    \ {\n            if(n>maxValue) \n                maxValue = n;\n            int\
    \ count = 0;\n            foreach(long i=1, num=n; i!=num; i<<=1) {\n        \
    \        num /= 2;\n                count += i%2 ? 1 : 0;\n            }\n   \
    \         if(count > maxCount) maxCount = count;\n        }\n    }\n    return\
    \ maxValue;\n}\n</code>\n<|/ a |>\n<| a dscore=1 tags=algorithm |>\nThis solution\
    \ is O(log(N))\n<code>\npublic static int search(int[] arr) {\n        int result\
    \ = -1;\n        int maxCount = -1;\n        int mid = arr.length / 2;\n     \
    \   for (int i = 0; i < arr.length; i++) {\n            int count = 0;\n     \
    \       for (int j = 1; j <= Math.ceil(Math.log(arr[i])/Math.log(2)); j++) {\n\
    \                if (arr[i] % j == 0) {\n                    count += j;\n   \
    \             }\n            }\n            if (count > maxCount) {\n        \
    \        result = arr[i];\n                maxCount = count;\n            }\n\
    \        }\n        return result;\n    }\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ handle negative input. Besides, the question states that the array is positive.\n\
    <|/ c |>\n<| c |>\nYes it does handle negative input.\n<|/ c |>\n<| c |>\nThanks,\
    \ I updated the code to handle the negatives case.\n<|/ c |>\n<| a tags=algorithm\
    \ |>\nIt has been so long since I posted this answer but my solution also took\
    \ O(N) time. This was my first solution but it took O(N^2) time.\n<code>", "{\n\
    \    if (lst.Length == 0)\n        return -1;\n    int maxVal = lst[0];\n    for\
    \ (int i = 1; i < lst.Length; i++)\n    {\n        if (lst[i] > maxVal)\n    \
    \    {\n            maxVal = lst[i];\n        }\n    }\n    return maxVal;\n}\n\
    </code>\n<|/ a tags=search,arrays,c# |>\n<| c |>\nThis solution will not work\
    \ for negative numbers because of the `lst[i] > maxVal`. That statement evaluates\
    \ to true for negative numbers, so the code will return -1 for every value it\
    \ encounters.\n<|/ c |>\n<| c |>\nthanks for letting me know that it doesn't work\
    \ only for negative numbers. I'll update my solution soon.\n<|/ c |>\n<| c |>\n\
    What does `int[] search = { 1, 2 };` do? This code doesn't seem to compile.\n\
    <|/ c |>\n<| c |>\n`int[] search = { 1, 2 };` is creating an array called `search`\
    \ with two elements in it, `1` and `2`. `search[0]` is `1` and `search[1]` is\
    \ `2`.\n<|/ c |>\n<| a dscore=4 tags=search,arrays,c# |>\nThe fastest way I could\
    \ find (on .NET Core 3.1) is \n<code>\nArray.FindFirst(myArray, i => i > 0);\n\
    </code>\n<|/ a |>\n<| a |>\n<code>", "{\n    int j = 0;\n    for(long i: lst)\n\
    \    {\n        if(i>0&&i==lst[j])\n            j++;\n    }\n    if(j==0)\n  \
    \      return -1;\n    long max = 0, freq = 0;\n    int i = 0;\n    for(long x:\
    \ lst)\n    {\n        if(x>0)\n        {\n            if(x==lst[i])\n       \
    \     {\n                freq++;\n                max = Math.max(max,freq);\n\
    \            }\n            else\n            {\n                freq = 0;\n \
    \               max = Math.max(max,freq);\n            }\n        }\n        else\
    \ if(x==lst[i])\n        {\n            freq++;\n            max = Math.max(max,freq);\n\
    \        }\n        else\n        {\n            freq = 0;\n            max =\
    \ Math.max(max,freq);\n        }\n        i++;\n    }\n    return max;\n}", "{\n\
    \    long result = 0;\n    long count = 1;\n    for(long i = 0; i < lst.Length;\
    \ ++i)\n    {\n        if(lst[i] > result)\n        {\n            result = lst[i];\n\
    \            count = 1;\n        }\n        else if(lst[i] == result)\n      \
    \  {\n            ++count;\n        }\n    }\n    return result >= 0 ? result\
    \ : -1;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is O(n^2), not O(n), so\
    \ probably not what the OP wants.\n<|/ c |>\n<| a tags=c#,algorithm,arrays |>\n\
    <code>\nprivate static int Search(int value, int[] array)\n{\n    HashSet<int>\
    \ set = new HashSet<int>(array);\n    return set.Contains(value) ? value : -1;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nOh, sorry, I misread your question. I'll\
    \ leave this answer here in case someone finds it.\n<|/ c |>\n<| c |>\nWhat is\
    \ \"O(n)\"?\n<|/ c |>\n<| c |>\nMy mistake. O(n) means O(n/k), where k is the\
    \ number of values you have. So if you're doing this many times, you'd want to\
    \ sort and iterate through the array once before searching, so you can use the\
    \ built in sort algorithm.\n<|/ c |>\n<| c |>\nThe question is \"what is the optimal\
    \ complexity for this?\" It's not really a case of \"what is the fastest algorithm\
    \ for this\". It's a case of \"what is the best algorithm for this scenario\"\
    .\n<|/ c |>\n<| c |>\nYeah, I guess you're right. My mistake.\n<|/ c |>\n<| a\
    \ |>\nThis is an optimized version of Peter Pan's answer:\n<code>", "{\n    int\
    \ minVal = lst[0];\n    long maxVal = lst[0];\n    for(long i=1;i<lst.length;i++)\n\
    \    {\n        if(lst[i] == 0)\n        {\n            return -1;\n        }\n\
    \        if(lst[i] < minVal)\n        {\n            minVal = lst[i];\n      \
    \  }\n        if(lst[i] > maxVal)\n        {\n            maxVal = lst[i];\n \
    \       }\n    }\n    return maxVal;\n}", "{\n    long max = -1, pos = -1;\n \
    \   for(long i = 0; i< lst.size(); i++)\n    {\n        if(lst[i] > 0 && lst[i]==lst[pos])\n\
    \        {\n            max = lst[i];\n            pos = i;\n        }\n    }\n\
    \    return max >= 0 ? max : -1;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=dynamic-programming,algorithm,java\
    \ |>\nMy solution is as follows\n<code>\npublic static int search(int[] arr) {\n\
    \        int maxVal = arr[0];\n        int pos = 0;\n        int flag = 0;\n \
    \       int i = 0;\n        int j = 0;\n        while (pos < arr.length && i <\
    \ arr.length) {\n            if (arr[pos] == maxVal) {\n                flag =\
    \ 1;\n                break;\n            }\n            i++;\n            pos++;\n\
    \        }", "{\n    int low = 0, high = lst.length - 1;\n    long result = -1;\n\
    \    while(low <= high)\n    {\n        int mid = (low + high) / 2;\n        if(lst[mid]\
    \ > lst[mid+1]) \n            high = mid - 1;\n        else\n            low =\
    \ mid + 1;\n        if(result < 0 && lst[mid] < lst[mid-1]) \n            result\
    \ = mid;\n    }\n    return result;\n}", "{\n    int len = lst.Length;\n    if\
    \ (len < 1)\n        return -1;\n    int res = 0;\n    HashSet<long> hs = new\
    \ HashSet<long>();\n    int c = 0;\n    foreach(long l in lst) {\n        if (hs.Contains(l))\
    \ {\n            c++;\n        } else {\n            hs.Add(l);\n        }\n \
    \       res = l > res ? l : res;\n    }\n    if (c >= len)\n        return -1;\n\
    \    return res;\n}\n</code>\n<|/ a tags=search,linq,arrays,c# |>\n<| a dscore=0\
    \ |>\nThis would be the simplest answer and should be the accepted answer for\
    \ this question :\n<code>\nstatic long Search(int[] arr)\n{\n    return arr.Max(x\
    \ => arr.Count(y => y > x));\n}\n</code>\n<|/ a tags=search,linq,arrays,c# |>\n\
    <| a dscore=0 |>\nThis should work faster in case you have large arrays than using\
    \ .Count\n<code>\nstatic long Search(int[] array)\n{\n    var res = 0;\n    HashSet<long>\
    \ tempHash = new HashSet<long>();\n    foreach (var item in array)\n    {\n  \
    \      if (tempHash.Contains(item))\n        {\n            res += 1;\n      \
    \  }\n        tempHash.Add(item);\n    }\n    return res;\n}\n</code>\n<|/ a tags=search,linq,arrays,c#\
    \ |>\n<| c |>\nThis solution is O(n^2) in time.\n<|/ c |>\n<| a |>\nYou could\
    \ use LINQ for this by first grouping the values using GroupBy. Then count the\
    \ groups and find the max group (assuming all values have the same frequency).\
    \ The following code uses Enumerable.Range, Enumerable.Range, Enumerable.GroupBy,\
    \ Enumerable.Select and Enumerable.ToDictionary. Here it is:\n<code>\nvar frequencies\
    \ = array.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());\nvar result\
    \ = Enumerable.Range(0, array.Length)\n                        .Where(i => frequencies[array[i]]\
    \ != null\n                                        && (i == array.Length - 1 ||\
    \ frequencies[array[i + 1]] == frequencies[array[i]]))\n                     \
    \   .Max();\n</code>\n<|/ a tags=search,linq,arrays,c# dscore=0 |>\n<| a |>\n\
    <code>\nvar maxCount = array.Select((x, i) => new { Value = x, Index = i})\n \
    \                    .GroupBy(x => x.Value)\n                     .MaxBy(g =>\
    \ g.Count())\n                     .Select(g => g.Key);\n</code>\n<|/ a ", "{\n\
    \    long i, freq=0;\n    int j;\n    \n    // search the array from right to\
    \ left - we could search from left to right as well\n    \n    //get last element\
    \ and add frequency to it\n    \n    for(j=lst.size()-1; j>=0; j--) \n    {\n\
    \        \n        // get element by j and increment frequency\n        if(i==lst[j])\n\
    \        {\n            freq++;\n        }\n        else\n        {\n        \
    \    // if element found then compare frequency and if frequency is greater than\
    \ or equal to \n            // the element itself then break the loop\n      \
    \      if(freq >= lst[j])\n            {\n                break;\n           \
    \ }\n            else\n            {\n                freq = 0; // reset frequency\
    \ to zero\n                i = lst[j]; // set current element to element at position\
    \ of current frequency value \n            }\n        }\n    }\n    \n    // if\
    \ frequency was greater than 0 then return it\n    \n    return freq>0?freq:-1;\n\
    }", "{\n    if (lst.Length == 0)\n        return -1L;\n    var maxCount = lst[0];\n\
    \    var max = lst[0];\n    for (int i = 1; i < lst.Length; i++)\n    {\n    \
    \    if (lst[i] > max)\n        {\n            max = lst[i];\n            maxCount\
    \ = 1;\n        }\n        else if (lst[i] == max)\n        {\n            maxCount\
    \ += 1;\n        }\n    }\n    return max;\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nThe above solution also fails for arrays with two or more elements as\
    \ compared to the array size being greater than 2.\n<|/ c |>\n<| a |>\nI hope\
    \ this could help someone in the future. This is my solution to the question given\
    \ above.\n<code>\nvar array = [2, 3, 4, 4, 3, 2];", "{\n    long maxFreq = -1;\n\
    \    int len = lst.lenth;\n    for(int i = 0; i < len; i++){\n        if(lst[i]\
    \ > maxFreq){\n            maxFreq = lst[i];\n        }\n    }\n    if(maxFreq\
    \ == -1){\n        return -1;\n    }\n    int maxIdx = -1;\n    for(int i = 0;\
    \ i < len; i++){\n        if(lst[i] == maxFreq){\n            maxIdx = i;\n  \
    \      }\n    }\n    return maxIdx;\n}\n</code>\n<|/ a |>\n<| c |>\nthis solution\
    \ is not O(n), but O(n^2)\n<|/ c |>\n<| a dscore=2 tags=java,arrays,sorting,algorithm\
    \ |>\nThis is my O(n) solution, assuming that you always know the size of the\
    \ array. I assume that you have O(1) time to get the size of the array and that\
    \ it is sorted.\n<code>\npublic int search(int[] numbers) {\n    int size = numbers.length;\n\
    \    int[] temp = new int[size];\n    int first = 0;\n    int last = size - 1;\n\
    \    while (first < last) {\n        if (numbers[first] > numbers[last]) {\n \
    \           temp[first] = numbers[last];\n            last--;\n        } else\
    \ if (numbers[first] == numbers[last]) {\n            if (numbers[first] <= numbers[last])\
    \ {\n                last--;\n            }\n        } else {\n            first++;\n\
    \        }\n    }\n    return -1;\n}\n</code>\n<|/ a |>\n<| c |>\nWhy do you use\
    \ `temp[first]`? I thought that after the first loop it is the same as `numbers[first]`?\n\
    <|/ c |>\n<| c |>\n: You are right about `first++`, but since `temp` is sorted\
    \ you can also find the index of first equal element by `first` variable (that\
    \ is, the first equal element).\n<|/ c |>\n<| a tags=java,arrays,sorting,algorithm\
    \ |>\nI realize this question has been answered already, but I wanted to share\
    \ my implementation and compare it to other answers. This is in Java 8+.\n<code>\n\
    public static int search(int[] numbers) {\n    Arrays.sort(numbers);", "{\n  \
    \  long min = lst[0], max = 0;\n    int i = 0;\n    \n    for (i = 0; i < lst.length;\
    \ i++) {\n        if (lst[i] > max) {\n            max = lst[i];\n        }\n\
    \        if (lst[i] < min) {\n            min = lst[i];\n        }\n    }\n  \
    \  \n    if (min == 0) {\n        max = -1;\n    }\n    if (max == 0) {\n    \
    \    min = 1;\n    }\n    \n    long sum = 0;\n    \n    for (i = 0; i < lst.length;\
    \ i++) {\n        sum += lst[i];\n        if (sum == max) {\n            return\
    \ i;\n        }\n    }\n    return -1;\n}", "{\n    long i = 1;\n    long f =\
    \ lst[0];\n    while(i < lst.lenght)\n    {\n        if (f > lst[i])\n       \
    \ {\n            f = lst[i];\n        }\n        ++i;\n    }\n    return f;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>\nimport java.util.Scanner;\nclass\
    \ Main {\n  public static void main(String args[]) {\n    Scanner scanner = new\
    \ Scanner(System.in);\n    System.out.println(\"Enter the size of the array:\"\
    );\n    int size = scanner.nextInt();\n    long[] arr = new long[size];\n    System.out.println(\"\
    Enter the numbers:\");\n    for (int i = 0; i < arr.length; i++) {\n      arr[i]\
    \ = scanner.nextLong();\n    }\n    long max = 0;\n    for(int i = 0; i < arr.length;\
    \ i++) {\n      if(arr[i] > max)\n        max = arr[i];\n    }\n    System.out.println(\"\
    Maximum number is: \" + max);\n  }\n}\n</code>\n<|/ a tags=java,arrays,search\
    \ |>\n<| a |>\n<code>", "{\n    int sum = 0;\n    int max = 0;\n    int min =\
    \ lst.length;\n    for(int i : lst)\n    {\n        if( sum < i )\n        {\n\
    \            sum = i;\n            max = i;\n        }\n        else\n       \
    \ {\n            if( max < i )\n                max = i;\n        }\n    }\n \
    \   if( sum < min )\n        return -1L;\n    int n = lst.length;\n    int cnt\
    \ = 0;\n    for(int i : lst)\n    {\n        if( sum == i )\n            cnt++;\n\
    \    }\n    if( cnt >= n )\n        return -1L;\n    return max;\n}\n</code>\n\
    <|/ a tags=algorithm,arrays,java |>\n<| a dscore=0 |>\nYou can try this:\n<code>\n\
    public static int search(int[] arr){\n    int maxIndex = 0;\n    int maxValue\
    \ = 0;\n    for(int i = 1; i < arr.length; i++){\n        if(arr[i] > arr[0]){\n\
    \            int j = i;\n            while(arr[j] >= arr[0]){\n              \
    \  j--;\n            }\n            int count = j + 1;\n            while(arr[i]\
    \ >= arr[j] && count < arr.length){\n                count++;\n              \
    \  j++;\n            }\n            if(count > maxValue && maxValue == 0){\n \
    \               maxValue = count;\n                maxIndex = i;\n           \
    \ }\n        }\n    }\n    return maxIndex;\n}\n</code>\n<|/ a tags=algorithm,arrays,java\
    \ |>\n<| c |>\nThis is just wrong, because the code is assuming that arr is sorted\
    \ and all elements appear at least once. Also the while loops never terminate,\
    \ because the inner loop always decrements j by 1 until it reaches arr[0], which\
    \ then is never reached and the while loop terminates.\n<|/ c |>\n<| c |>\nThanks,\
    \ you are right. I edited the code.\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic\
    \ static void search(int[] arr){\n    Arrays.sort(arr);\n    int counter=1;\n\
    \    int count=0;\n    for(int i:arr){\n        count++;\n        if(count==i){\n\
    \            counter++;\n        }\n        if(counter>arr[0]){\n            counter=1;\n\
    \        }\n    }\n    System.out.println(\"Maximum value is:\"+arr[0]+\" and\
    \ its index is \"+counter);\n}\n</code>\n<|/ a tags=algorithm,arrays,java |>\n\
    <| a |>\n<code>\n// Complete the search function below.\npublic int search(int[]\
    \ arr) {\n    Arrays.sort(arr);\n    int max=0;\n    int maxIndex=0;\n    for\
    \ (int i = 0; i < arr.length; i++) {\n", "{\n    long max = -1;\n    for(int i\
    \ = 0; i< lst.length; i++)\n    {\n        if(lst[i] > max)\n        {\n     \
    \       max = lst[i];\n        }\n        if(lst[i] == max)\n        {\n     \
    \       return max;\n        }\n    }\n    return max;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nHi Abhishek Thanks for your comment. But I am getting this error\
    \ on compiling your code: error: cannot find symbol\n  if(lst[i] > max)\n  ^\n\
    \  symbol:   variable max\n  location: class Search\n<|/ c |>\n<| c |>\nI think\
    \ i fixed it. Check it\n<|/ c |>\n<| a dscore=1 tags=arrays,java,algorithm |>\n\
    The problem is that the variable max isn't declared in your method.\nTry replacing\
    \ this:\n<code>\nif(lst[i] > max)\n</code>\nwith this:\n<code>\nif(lst[i] > max)\n\
    {\n    max = lst[i];\n}\n</code>\n<|/ a |>\n<| a |>\nYour variable max is not\
    \ being declared. Try this:\n<code>\n  public long search(int[] lst) {\n    long\
    \ max = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n      if (lst[i]\
    \ > max) {\n        max = lst[i];\n      }\n    }\n    return max;\n  }\n</code>\n\
    <|/ a dscore=1 tags=arrays,java,algorithm |>\n<| c |>\nHi Joey, Thanks for your\
    \ comment. I am getting this error on compiling your code: error: cannot find\
    \ symbol\n      if (lst[i] > max) {\n      ^\n      symbol:   variable max\n \
    \     location: class Search\n<|/ c |>\n<| c |>\nAre you sure you have declared\
    \ max in your class as well?\n<|/ c |>\n<| a tags=arrays,java,algorithm |>\nThe\
    \ variable max doesn't exist in the scope of the method search. \n<code>\npublic\
    \ long search(int[] lst) {\n    long max = lst[0];\n    for (int i = 1; i < lst.length;\
    \ i++) {\n      if (lst[i] > max) {\n        max = lst[i];\n      }\n    }\n \
    \   return max;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nHi Ayush, Thanks for\
    \ your comment. I am getting this error on compiling your code: error: cannot\
    \ find symbol\n      if (lst[i] > max) {\n      ^\n      symbol:   variable max\n\
    \      location: class Search\n<|/ c |>\n<| a dscore=1 |>\n<code>\npublic class\
    \ Search {", "{\n    long max = -1;\n    long max = lst[0];\n    bool isExist\
    \ = false;", "{\n\tlong result = 0;\n\tfor (long i = 0; i < lst.Length; i++)\n\
    \t{\n\t\tif (lst[i] > result)\n\t\t{\n\t\t\tresult = lst[i];\n\t\t}\n\t\tif (lst[i]\
    \ == lst[lst[i]])\n\t\t{\n\t\t\tresult++;\n\t\t}\n\t}\n\treturn result;\n}\n</code>\n\
    <|/ a tags=c#,arrays,list |>\n<| c |>\nThat only works for an array of 1's and\
    \ 0's, what about an array of strings?\n<|/ c |>\n<| a tags=c#,arrays,list dscore=0\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Threading.Tasks;", "{\n    //write your code\
    \ here\n    long max = 0;\n    long freq = 0;\n    for(int i=0; i< lst.length;\
    \ i++){\n        if(lst[i] > 0 && lst[i] <= max){\n            max = lst[i];\n\
    \            freq = 1 + freq;\n        }\n    }\n    if(freq >= max)\n       \
    \ return -1;\n    return max;\n}\n</code>\n<|/ a |>\n<| c |>\nPlease explain your\
    \ code.\n<|/ c |>\n<| c |>\nI added comments to the code. Please check and give\
    \ me feedback\n<|/ c |>\n<| c |>\nIt's not optimal code but it's simple to understand\
    \ and understand the concept.\n<|/ c |>\n<| c |>\n`return max;` is missing in\
    \ your function definition. Also this algorithm fails for `search([-1L, -1L, -1L,\
    \ -1L])`\n<|/ c |>\n<| c |>\nYes, I did not consider that case. I think that was\
    \ the reason why you got -1. Sorry I did not see this case.\n<|/ c |>\n<| a |>\n\
    <code>\npublic class Solution {", "{\n\tlong maxValue = -1;\n\tlong maxCount =\
    \ 0;\n\tfor(long i = 0; i < lst.Length; i++) \n\t{\n\t\tlong count = Arrays.FindIndex(lst,i).Count;\n\
    \t\tif(count > maxCount) \n\t\t{\n\t\t\tmaxValue = lst[Arrays.FindIndex(lst,i).Index];\n\
    \t\t\tmaxCount = count;\n\t\t}\n\t}\n\t\n\treturn maxValue;\n}\n\t\n\t\n/*", "{\n\
    \    // Your code here\n    long maxIdx = -1, val = -1;\n    for(int i = 0; i\
    \ < lst.length; i++) \n    {\n        if(lst[i] > val) \n        {\n         \
    \   maxIdx = i;\n            val = lst[i];\n        }\n    }\n    return maxIdx;\n\
    }", "{\n    int i, max=0, freq=0;\n    for(i = 0; i< lst.Length; i++) \n    {\n\
    \        if (lst[i] > max) \n        {\n            max = lst[i];\n          \
    \  freq = 1;\n        }\n        else\n        {\n            freq += 1;\n   \
    \     }\n    }\n    \n    if (max > 0) \n    {\n        if (max > lst[freq]) \n\
    \        {\n            return -1L;\n        }\n        else\n        {\n    \
    \        return max;\n        }\n    }\n    return -1L;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nHi, your code is really great and simple to understand and implement.\
    \ I tried it on the online judge, the sample cases are passed with results. But\
    \ for other test cases, the code seems to be giving incorrect results.\n<|/ c\
    \ |>\n<| a dscore=2 |>\n<code>\npackage main", "{\n    int i = 0;\n    long max\
    \ = lst[0];\n    for(auto n: lst)\n    {\n        if(n > max)\n            max\
    \ = n;\n        if(n == max)\n        {\n            i++;\n        }\n    }\n\
    \    return i == 1 ? max : -1;\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=c++,algorithm\
    \ |>\nThis is my solution for this problem. Hope it help you.\n<code>\n#include\
    \ <bits/stdc++.h>", "{\n    for(int i=0;i<lst.Length;i++)\n        if(lst[i]>0)\
    \ \n        {\n            long cnt=1;\n            for(int j=i;j<lst.Length;j++)\n\
    \                if(lst[j]==lst[i])\n                    cnt++;\n            if(cnt>=lst[i])\
    \ \n                return lst[i];\n        }\n    return -1;\n}\n</code>\n<|/\
    \ a tags=c# |>\n<| c |>\nWhy are you doing `for (int i = 0; i < lst.Length; i++)`\
    \ and then `for (int j=i; j<lst.Length;j++)`?  Why not `for (int i = 0; i < lst.Length;\
    \ i++)` and `for (int j = 0; j < i; j++)`?\n<|/ c |>\n<| c |>\nTo make the code\
    \ easier to read, I prefer my for loops to start at the beginning of the array.\
    \ I think it's easier to see that the j loop isn't iterating over an i that's\
    \ already iterated over.\n<|/ c |>\n<| a |>\n<code>\npublic static int Search(List<long>\
    \ list, long searchKey)\n{\n    for (int i = 0; i < list.Count(); i++)\n    {\n\
    \        long count = 1;\n        for (int j = i; j < list.Count(); j++)\n   \
    \     {\n            if (list[j] == list[i])\n            {\n                count++;\n\
    \            }\n            if (count == searchKey)\n            {\n         \
    \       return i;\n            }\n        }\n    }\n    return -1;\n}\n</code>\n\
    <|/ a tags=c# dscore=1 |>\n<| a tags=c# |>\n<code>\npublic static long Search(long[]\
    \ arr, long searchKey)\n{\n    for (int i = 0; i < arr.Length; i++)\n    {\n \
    \       int count = 0;\n        for (int j = i; j < arr.Length; j++)\n       \
    \ {\n            if (arr[j] == arr[i])\n            {\n                count++;\n\
    \            }\n        }\n        if (count == searchKey)\n        {\n      \
    \      return i;\n        }\n    }\n    return -1;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=c# |>\n<code>\npublic static long Search(List<long> list, long\
    \ searchKey) {\n    if (list.Count > 0)\n        for (int i = 0; i < list.Count;\
    \ i++) {\n            long count = 1;\n            for (int j = i; j < list.Count;\
    \ j++)\n                if (list[j] == list[i]) {\n                    count++;\n\
    \                }\n            if (count == searchKey) {\n                return\
    \ i;\n            }\n        }\n    return -1;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=c# |>\n<code>\nusing System;\nusing System.Collections.Generic;", "{\n\
    \    long i, largest = -1;\n    long freq = 0;\n    \n    for(i = 0; i < lst.length;\
    \ i++)\n    {\n        freq++;\n        if(freq > lst[i])\n        {\n       \
    \     freq--;\n            largest = i;\n        }\n    }\n    return largest\
    \ != -1 ? largest : -1;\n}\n</code>\n<|/ a tags=arrays,algorithm,dynamic-programming,c++\
    \ dscore=2 |>\n<| c |>\nThis is a good solution but I think it should be noted\
    \ that the `freq` variable is unnecessarily redundant. Simply doing `if (freq\
    \ > lst[i])` will suffice, as long as the `freq` variable is initialized to zero.\
    \ `freq--` is only necessary if the value is greater than the value at the current\
    \ index, but at that point you're done.\n<|/ c |>\n<| c |>\nYou are right, it\
    \ is not necessary to use freq and then check if freq > lst[i] or freq < lst[i].\
    \ But I like the idea of using freq to count the frequency of lst[i].\n<|/ c |>\n\
    <| a dscore=0 |>\nHere is how you can solve this using a hashtable of size N.\
    \ Store the frequency of every number in that hashtable. Then, keep track of largest\
    \ number in the hashtable and keep track of index. Now for every new number you\
    \ are adding, simply update the hashtable and update the largestNumber. Now, for\
    \ every new number you can either check if the number has frequency of 1 or not\
    \ and if it has frequency of 1, compare it to the number stored at index, and\
    \ if they are equal - update the largestNumber accordingly. \nCode\n<code>\nvector<int>\
    \ nums;", "{\n    long res = -1;\n    foreach (long x in lst) \n    {\n      \
    \  res = Math.max(res, search(x));\n    }\n    return res;\n}", "{\n\t\n\tif(null\
    \ == lst) return -1;\n\tint max = -1;\n\tint maxcount = 0;\n\tfor (int i = 0;\
    \ i <lst.Length ; i++)\n\t{\n\t\tint c = lst[i];\n\t\tif(c>max) max = c;\n\t\t\
    int cnt = count(lst,c);\n\t\tif(cnt>maxcount) maxcount = cnt;\n\t}\n\t\n\treturn\
    \ max;\n}\n// end search", "{\n    long max_freq = -(1 << 31);\n    for(long freq\
    \ : lst) \n    {\n        freq >>= 1;\n        if(freq > max_freq) \n        {\n\
    \            max_freq = freq;\n        }\n    }", "{\n    long maxVal = 0;\n \
    \   long freq = 0;\n    for (int i = 0; i < lst.Length; i++) {\n        freq =\
    \ freq + lst[i];\n        if (freq > maxVal) maxVal = freq;\n    }\n    return\
    \ maxVal;\n}\n/*\n * Complete the searchBin function below.\n */", "{\n    return\
    \ search(lst, lst[0]);\n}\nlong search(long[] lst, long x)\n{\n    long pos =\
    \ 0;\n    bool found = false;\n    for (int i = 0; i < lst.Length; i++) {\n  \
    \      if ((lst[i] == x) && (!found)) {\n            found = true;\n         \
    \   pos = i;\n        }\n    }\n    if (found)\n        return pos;\n    else\n\
    \        return -1;\n}\n// C# does not allow using statements on top of the class\
    \ namespace\nusing System;", "{\n\tlong maxFrequency = -1;\n\tlong frequencyCounter\
    \ = 1;", "{\n    long maxval = 0, maxfreq = 0;\n    long val = 0;", "{\n    if\
    \ (lst.isEmpty()) {\n        return -1;\n    }\n    int res = -1;\n    int cnt\
    \ = 0;\n    for (int i = 0; i < lst.length(); i++) {\n        if (lst[i] > cnt)\
    \ {\n            res = lst[i];\n            cnt = lst[i];\n        }\n    }\n\
    \    return res;\n}\n</code>\n<|/ a |>\n<| c |>\nThis does not work. Try `search([0,\
    \ 10, 2, 9, 0, -1, 5])` which is supposed to return `9`. It returns `0` instead.\n\
    <|/ c |>\n<| c |>\nYes, but that's not what OP asked for ... `The frequency of\
    \ an integer is the number of times it appears in the array.`\n<|/ c |>\n<| c\
    \ |>\nThe asker asked to return -1 if there is no such integer in the array.\n\
    <|/ c |>\n<| c |>\nI agree with you but OP doesn't say that `-1` should be returned\
    \ in the case when no such value exists. `The frequency of an integer is the number\
    \ of times it appears in the array.`\n<|/ c |>\n<| a tags=arrays,java,algorithm\
    \ dscore=1 |>\nThis is not a perfect solution but it does what OP asked for. \n\
    <code>\npublic class SearchArray {\n    public static int search(int[] arr, int\
    \ val) {\n        int res = -1;", "{\n    long freq = -1, largest = 0;\n    for(long\
    \ x : lst) \n    {\n        freq++;\n        if(freq > x) \n        {\n      \
    \      freq = x;\n            largest = x;\n        }\n    }\n    return largest;\n\
    }\n</code>\n<|/ a tags=java,arrays dscore=0 |>\n<| c |>\n`return -1L` should be\
    \ `return -1`. Your code will never hit this line, which is more correct than\
    \ `return 0L`.\n<|/ c |>\n<| c |>\nThis is not working. Can you please take a\
    \ look: https://onlinegdb.com/Sk7Tzs9fG\n<|/ c |>\n<| c |>\n, did you check my\
    \ code? It should work for you now. I've tried it and it gives me the correct\
    \ output in all the examples.\n<|/ c |>\n<| c |>\nYes I checked your code. However\
    \ it doesn't work. I have posted a screenshot here with the output: https://ibb.co/5p5i9Wk\n\
    <|/ c |>\n<| c |>\n, did you try with the exact array that I have posted in my\
    \ answer? It gives me the correct output in my IDE.\n<|/ c |>\n<| a tags=java,arrays\
    \ |>\n<code>\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;",
  "{\n    if (lst.Length > 0) {\n        int firstElement = lst[0];\n        int index\
    \ = FindIndex(lst);\n        long value = lst[index];\n        int counter = 1;\n\
    \        if (index != -1 && value > 0) {\n            for (int i = index + 1;\
    \ i < lst.Length; i++) {\n                if (lst[i] == value) {\n           \
    \         counter++;\n                } else {\n                    if (counter\
    \ > value) {\n                        value = counter;\n                     \
    \   firstElement = i;\n                    }\n                    counter = 1;\n\
    \                }\n            }\n        }\n        if (index != -1 && value\
    \ == 0) {\n            value = counter;\n            firstElement = index;\n \
    \       }\n        return firstElement;\n    }\n    return -1;\n}", "{\n    int\
    \ left = 0;\n    int right = lst.size()-1;\n    long freq = 0;\n    long res =\
    \ -1;\n    while (left <= right) {\n        int mid = left + (right - left) /\
    \ 2;\n        long midValue = lst[mid];\n        long curValue = lst[mid];\n \
    \       freq += (curValue - midValue);\n        if (freq >= midValue) {\n    \
    \        left = mid+1;\n            freq -= midValue;\n        } else {\n    \
    \        right = mid-1;\n            freq -= midValue;\n        }\n        if\
    \ (freq == 0)\n            res = midValue;\n    }\n    return res;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nThe best solution I could find was to use\
    \ binary search to find the first number bigger than zero, which is guaranteed\
    \ to exist in the array. The binary search runs in O(log n). \n<code>\nfunction\
    \ search(values: number[], searchedNumber: number): number {\n  \n  let left =\
    \ 0;\n  let right = values.length - 1;\n  let mid = 0;\n  \n  while (left <= right)\
    \ {\n    mid = (left + right) / 2;\n    if (values[mid] > searchedNumber) {\n\
    \      right = mid - 1;\n    } else if (values[mid] < searchedNumber) {\n    \
    \  left = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n\
    }\n</code>\n<|/ a tags=arrays,algorithm,javascript |>\n<| a |>\nMy first thought\
    \ was to use Array.prototype.reduce() to find the index at which the searched\
    \ item would be inserted into its place, but reduce doesn't let you insert at\
    \ an index. Instead, you have to reduce the array to one item smaller. Thus, I'd\
    \ write my own reduce like so:\n<code>\nfunction reduce(arr, func, initial = undefined)\
    \ {\n    if (arr.length === 0) {\n        return initial;\n    }\n    const [head,\
    \ ...rest] = arr;\n    return head === undefined ? initial : func(head, reduce(rest,\
    \ func, initial));\n}\n</code>\nNotice that reduce isn't generic, this is just\
    \ to demonstrate how reduce works fundamentally. In practice, you would probably\
    \ be better off writing your own implementation of reduce for arrays.", "{\n \
    \   long cnt = 0;\n    long max = 0;\n    for(long i = 0; i < lst.Length; ++i)\n\
    \    {\n        if (lst[i] > 0)\n        {\n            cnt += 1;\n          \
    \  if (lst[i] > max)\n            {\n                max = lst[i];\n         \
    \   }\n        }\n    }\n    if (cnt == 0)\n    {\n        return -1;\n    }\n\
    \    return max;\n}\n</code>\n<|/ a tags=c#,arrays,algorithm,search,binary-search\
    \ |>\n<| a dscore=0 tags=c#,arrays,algorithm,search,binary-search |>\nHere is\
    \ my solution, tested in java. Hope this will help someone\n<code>\nstatic int\
    \ getMax(int[] arr) {\n    int size = arr.length;\n    if (size <= 0) {\n    \
    \    return -1;\n    }\n    int low = 0;\n    int high = size - 1;\n    int mid\
    \ = 0;\n    while (low <= high) {\n        mid = (low + high) / 2;\n        if\
    \ (arr[mid] > 0) {\n            high = mid - 1;\n        } else {\n          \
    \  low = mid + 1;\n        }\n    }\n    return arr[mid];\n}\n</code>\n<|/ a |>\n\
    <| a dscore=0 tags=c#,arrays,algorithm,search,binary-search |>\nHere is a simple\
    \ way in java using binary search with Arrays.binarySearch()\n<code>\npublic class\
    \ SearchElement {\n    public static void main(String[] args) {\n        int[]\
    \ arr = {4,1,5,7,0,9,4,0,5,8,9,5,3,9,5,7,4,9};\n        System.out.println(getMax(arr));\n\
    \    }\n    private static int getMax(int[] arr) {\n        int high = arr.length\
    \ - 1;\n        int low = 0;\n        int mid = 0;\n        while (low <= high)\
    \ {\n            mid = (low + high) / 2;\n            if (arr[mid] > 0)\n    \
    \            high = mid - 1;\n            else\n                low = mid + 1;\n\
    \        }\n        return Arrays.binarySearch(arr,arr[mid]);\n    }\n}\n</code>\n\
    <|/ a |>\n<| c |>\nOops, my bad, forgot to add Arrays.binarySearch() at the return\
    \ statement\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic int search(int[] arr,\
    \ int arrValue, int index){\n    int low = 0;\n    int high = arr.length - 1;\n\
    \    int mid = 0;\n    while(low <= high){\n        mid = (low+high)/2;\n    \
    \    if(arr[mid] == arrValue){\n            return mid;\n        }else if(arr[mid]\
    \ < arrValue){\n            low = mid + 1;\n        }else if(arr[mid] > arrValue){\n\
    \            high", "{\n    long freq = 1;\n    long maxVal = lst[0];\n    for\
    \ (int i = 1; i < lst.Length; i++)\n    {\n        if (freq + lst[i] > freq) \n\
    \        {\n            freq += lst[i];\n            maxVal = lst[i];\n      \
    \  }\n        else\n        {\n            if (lst[i] != lst[i - 1])\n       \
    \     {\n                freq += lst[i];\n                maxVal = lst[i];\n \
    \           }\n        }\n    }\n    if (freq > lst[lst.Length - 1])\n       \
    \ return -1;\n    return maxVal;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\nThis is a simple solution using Hash Tables.\n<code>", "{\n    long maxFrequency\
    \ = 0;\n    for(long i = 0; i < lst.Length; i++) {\n        if(lst[i] > maxFrequency)\
    \ \n        {\n            long curMaxFrequency = maxFrequency;\n            for(int\
    \ j = 0; j < i; j++) {\n                if(lst[j] == maxFrequency) {\n       \
    \             maxFrequency = lst[j];\n                }\n            }\n     \
    \       maxFrequency = curMaxFrequency;\n        }\n    }", "{\n    long result\
    \ = -1;\n    long max = lst[0];\n    int freq = lst.length;\n    for (int i =\
    \ 1; i < lst.length; i++) \n    {\n        if (lst[i] > max)\n        {\n    \
    \        max = lst[i];\n            freq = i;\n        }\n    }\n    if (freq\
    \ >= lst.length)\n        result = -1;\n    else\n        result = max;\n    return\
    \ result;\n}\n</code>\n<|/ a tags=java,sorting,arrays |>\n<| c |>\nThis doesn't\
    \ work if all integers are the same. You'd need to change the comparison to `frequency\
    \ >= lst.length`\n<|/ c |>\n<| c |>\nThe code is almost correct but `freq` should\
    \ be less than `lst.length` instead of greater than `lst.length`.\n<|/ c |>\n\
    <| a dscore=2 tags=java,sorting,arrays |>\nHere is a simple solution in Java:\n\
    <code>\npublic int search(long[] values) {\n    Arrays.sort(values);\n    return\
    \ IntStream.range(0, values.length)\n            .filter(i -> values[i] > 0l)\n\
    \            .findFirst()\n            .orElse(-1l);\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nthis one returns -1L for an empty array\n<|/ c |>\n<| c |>\nI believe\
    \ you can just replace `.filter(i -> values[i] > 0l)` with `.filter(i -> values[i]\
    \ > 0l && values[i] != 0l)` instead.\n<|/ c |>\n<| a dscore=1 |>\nHere's a method\
    \ using a LinkedHashMap, which preserves the order of insertion. With a slight\
    \ modification, it could be modified to return the frequency instead of the largest\
    \ integer:\n<code>\nprivate static LinkedHashMap<Long, Integer> search(int[] arr)\
    \ {\n  LinkedHashMap<Long, Integer> map = new LinkedHashMap<>();\n  for(int num\
    \ : arr) {\n    int frequency = map.get(num);\n    if (frequency == null) {\n\
    \      frequency = 1;\n      map.put(num, frequency);\n    } else {\n      frequency++;\n\
    \      map.put(num, frequency);\n    }\n  }\n  return map;\n}\n</code>\n<|/ a\
    \ tags=java,sorting,arrays |>\n<| c |>\nThis doesn't preserve the order of the\
    \ entries, though.\n<|/ c |>\n<| a tags=java,sorting,arrays dscore=0 |>\nThis\
    \ solution worked for me\n<code>\nimport java.util.Arrays;\nimport java.util.HashMap;\n\
    import java.util.Map;", "{\n    int low = 0;\n    int high = lst.lenth - 1;\n\
    \    while (low <= high)\n    {\n        int mid = low + high;\n        int midVal\
    \ = lst[mid];\n        int higherVal = midVal;\n        int higherValCount = 1;\n\
    \        while (higherVal > 0)\n        {\n            higherVal /= 10;\n    \
    \        higherValCount *= 10;\n        }\n        if (higherValCount >= midVal)\n\
    \        {\n            high = mid;\n        }\n        else\n        {\n    \
    \        low = mid + 1;\n        }\n    }\n    return (high < 0) ? -1 : lst[high];\n\
    }\n</code>\n<|/ a |>\n<| c |>\nWhile this code may answer the question, providing\
    \ additional context regarding why and/or how this code answers the question improves\
    \ its long-term value.\n<|/ c |>\n<| c |>\nThanks for sharing your answer! While\
    \ this code may answer the question, providing additional context regarding why\
    \ and/or how this code answers the question improves its long-term value.\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>\n//Program to find largest number that is greater\
    \ then 0 and is greater than the frequency of \n//the number", "{\n\tlong max\
    \ = 1;\n\tint i;", "{\n    long result = -1;\n    for(int i=0; i < lst.length;\
    \ i++){\n        int num = lst[i];\n        if(num>0 && num>result)\n        {\n\
    \            result = num;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=algorithm,java |>\n<| c |>\nI don't think you need to check all numbers,\
    \ just the first one.\n<|/ c |>\n<| a dscore=1 |>\nThis can easily be done in\
    \ O(log n) time using binary search and O(1) space:\n<code>\nstatic long search(long[]\
    \ arr) {\n    int lo = 0;\n    int hi = arr.length - 1;\n    while (lo <= hi)\
    \ {\n        int mid = (lo + hi) >>> 1;\n        int midVal = arr[mid];", "{\n\
    \    int i, j;\n    long freq = 0;\n    for (i = 0; i <  lst.size; i++) {\n  \
    \      for (j = i + 1; j <= lst.size; j++) {\n            if (lst[j] >= lst[i])\
    \ {\n                freq++;\n                if (freq > lst[i]) {\n         \
    \           return lst[i];\n                }\n            }\n        }\n    }\n\
    \    return -1;\n}", "{\n    long sum = 0;\n    int count = 0;\n    for (int i\
    \ = 0; i < lst.Length; i++)\n    {\n        sum += lst[i];\n        if (sum >=\
    \ 0)\n        {\n            count++;\n            sum = sum - lst[i];\n     \
    \   }\n        if (sum >= 0)\n        {\n            count++;\n            sum\
    \ = sum - lst[i];\n        }\n        if (sum >= 0)\n        {\n            count++;\n\
    \            sum = sum - lst[i];\n        }\n    }\n    if (count < 0)\n    {\n\
    \        return -1;\n    }\n    else\n    {\n        return sum / count;\n   \
    \ }\n}", "{\n    long max = lst[0];\n    long index = -1;\n    for(int i = 1;\
    \ i < lst.size(); i++)\n    {\n        if(lst[i] > max)\n        {\n         \
    \   max = lst[i];\n            index = i;\n        }\n    }\n    return index;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nYour code works for the test cases, but it fails\
    \ on more general case. See the example I added to my question.\n<|/ c |>\n<|\
    \ c |>\nI guess you misunderstood. Your code returns -1 for 5 as it is the biggest\
    \ number in the array and is also the biggest frequency and is not greater than\
    \ it. The correct return would be 3.\n<|/ c |>\n<| c |>\nI see, I see where I\
    \ went wrong, I have changed my solution to make it work. Thanks for the feedback\n\
    <|/ c |>\n<| c |>\nYes, it's working now. I did not try it with the test cases.\
    \ Thanks for the solution.\n<|/ c |>\n<| c |>\n, your algorithm is working on\
    \ the test cases, but not working for the general case. Please see my example\
    \ above. I appreciate your help.\n<|/ c |>\n<| a tags=arrays,algorithm |>\nA possible\
    \ solution would be to count how many times each value appears in the array and\
    \ then iterate over the sorted array to find the first element with value more\
    \ than 1.\n<|/ a dscore=0 |>\n<| c |>\nThe solution by is quite elegant and easy\
    \ to understand. Thanks anyway!\n<|/ c |>\n<| a tags=arrays,algorithm dscore=0\
    \ |>\n<code>\nfunction search2(arr) {\nvar sortedArr = arr.sort((a,b)=>a-b);\n\
    var result = []\nvar count = 1;\nfor(var i=0;i<sortedArr.length;i++) {\n    result.push(arr[i])\n\
    \    count++\n    if(arr[i]==sortedArr[i - 1]) {\n        count++\n    }\n}\n\
    return sortedArr[result.indexOf(count-1)+1]\n}\n</code>\n<|/ a |>\n<| a tags=arrays,algorithm\
    \ dscore=0 |>\nYou can use Map with array values as key and frequencies as value.\
    \ After sorting just iterate over map\n<code>\nvar arr = [\"4\", \"4\", \"4\"\
    , \"2\", \"2\", \"3\"]", "{\n    long max = Long.MinValue;\n    foreach(i, lst){\n\
    \        int freq = std.array.length(lst) - i; //array length\n        if (freq\
    \ >= i){\n            max = std.max(freq, max);\n        }\n    }\n    return\
    \ max;\n}\n</code>\n<|/ a tags=scala |>\n<| a dscore=0 |>\nTry the following :\n\
    <code>\nval input: List[Long] = List(4L, 1L, 2L, 2L, 3L, 1L)\nval result = input.foldLeft(List[Long]()){\n\
    \  case (acc, x) => x :: acc\n}.maxBy(identity)\n</code>\nresult will be 2L\n\
    <|/ a tags=scala |>\n<| a |>\nAnother option would be to just use a for comprehension:\n\
    <code>\nvar max = 1L\nfor (i <- input) if (max < i) max = i\n</code>\n<|/ a dscore=0\
    \ tags=scala |>\n<| c |>\nI like this but this code is buggy. It will always return\
    \ the last element. Instead I suggest `val max = 1L; for (i <- input) if (max\
    \ < i) max = i`\n<|/ c |>\n<| a dscore=0 |>\nYou can try this also, using foldLeft,\
    \ just to find which element appears maximum times:\n<code>\nval input: List[Long]\
    \ = List(4L, 1L, 2L, 2L, 3L, 1L)\nval maxOccurances = input.foldLeft(Map[Long,\
    \ Long]()){\n  case (acc, x) => {\n    val count = acc + (x -> (acc.getOrElse(x,\
    \ 0) + 1L))\n    count\n  }\n}", "{\n    if (lst.isEmpty())\n    {\n        return\
    \ -1;\n    }\n    int[] frequencies = new int[lst[0]];\n    for (int i = 1; i\
    \ < lst.Length; i++)\n    {\n        if (lst[i] == lst[0])\n        {\n      \
    \      frequencies[lst[i]]++;\n        }\n        else\n        {\n          \
    \  frequencies[lst[i]] = frequencies[lst[0]];\n        }\n    }\n    int maxValue\
    \ = 0;\n    foreach (var element in frequencies)\n    {\n        if (element >\
    \ maxValue)\n        {\n            maxValue = element;\n        }\n    }\n  \
    \  return maxValue > lst[0] ? maxValue : -1;\n}\n</code>\n<|/ a tags=arrays,.net,algorithm,c#\
    \ |>\n<| c |>\nYour code works with this input:", "{\n    if (lst.empty())\n \
    \       return -1;\n    long max = lst[0];\n    int freq = 0;\n    for (int i\
    \ = 1; i < lst.size(); i++)\n    {\n        if (lst[i] > max)\n        {\n   \
    \         max = lst[i];\n            freq = i;\n        }\n    }\n    if (max\
    \ > 0)\n        return max;\n    return -1;\n}\n</code>\n<|/ a |>\n<| c |>\nWhy\
    \ does it take more time to run? Was `std::max_element` designed for this?\n<|/\
    \ c |>\n<| c |>\n`std::max_element` is used to find the max element of an array.\
    \ `search` here is used to find the max element of a set of numbers. So `std::max_element`\
    \ is used to find the max element in an array of numbers. Since there are many\
    \ comparisons and lookups, `search` is more efficient than `std::max_element`.\
    \ The speed up is about `O(1)` in the best case.\n<|/ c |>\n<| c |>\nThe question\
    \ was about `std::max_element`, not `std::search`. The question clearly states\
    \ what `search` should return.\n<|/ c |>\n<| c |>\n, thanks for pointing this\
    \ out. My bad. Now it is correct.\n<|/ c |>\n<| c |>\nWon't this approach return\
    \ `0` if the array contains no elements?\n<|/ c |>\n<| a tags=c++,search,algorithm,arrays\
    \ |>\n<code>\n#include <iostream>\n#include <algorithm>\nusing namespace std;",
  "{\n    long res = -1L;\n    for (int i = 0; i < lst.length; ++i) {\n        if\
    \ (lst[i] > 0) {\n            for (long j = i + 1; j < lst.length; ++j) {\n  \
    \              if (lst[j] >= lst[i]) {\n                    ++res;\n         \
    \           break;\n                }\n            }\n        }\n    }\n    return\
    \ res;\n}\n</code>\n<|/ a dscore=1 tags=python-3.x,python |>\n<| c |>\nI am curious\
    \ to know why you think this answer would be better?\n<|/ c |>\n<| c |>\nIt's\
    \ better than mine in terms of space complexity and efficiency. It has a better\
    \ time complexity than mine since it does lesser iterations (but more space complexity).\
    \ But it's not better than yours in terms of time complexity and efficiency. Since\
    \ I'm also an avid python programmer I prefer my style and style is always better\
    \ than any other. I just wanted to share an alternative in python.\n<|/ c |>\n\
    <| c |>\n, that's not actually a fair comparison. yours is O(n) while mine is\
    \ O(n^2). Which one is better is a matter of judgement. I'm not a fan of big-O\
    \ complexity analysis since you cannot always trust that the algorithm is correct\
    \ or performs better for all inputs, but it's true that yours is better at time\
    \ complexity and space complexity than the other two. I'm just curious why you\
    \ think this particular solution is better than yours.\n<|/ c |>\n<| c |>\n, I\
    \ agree, and that's why I asked the OP why this answer is better than mine and\
    \ why he thought that the other two solutions are better. In fact, I already said\
    \ that in my answer but he didn't mentioned that and I wanted to explain that\
    \ to him.\n<|/ c |>\n<| c |>\n, sorry, I misread your comment before. You're right.\
    \ Yours is better than mine in terms of time complexity and efficiency. I also\
    \ edited my answer to show a slight change in time complexity. I also added a\
    \ small edit on space complexity, though I'm not sure if it's necessary. It's\
    \ more like a preference thing, I think :)\n<|/ c |>\n<| a |>\nHere's a solution\
    \ in Python that doesn't mutate the list in-place:\n<code>\ndef search(lst):\n\
    \    seen = set(lst)\n    for num in lst:\n        if num > 0:\n            for\
    \ prev in seen:\n                if num > prev:\n                    return num\n\
    \                seen.add(num)\n    return -1\n</code>\nAnd a version with O(1)\
    \ space complexity:\n", "{\n    int n = lst.Length;\n    long max = 0;\n    long\
    \ freq = 1;\n    for(int i = 0; i < n; ++i)\n    {\n        if(lst[i] == 0) continue;\n\
    \        freq = lst[i] > freq ? lst[i] : freq;\n        if(freq > max)\n     \
    \   {\n            max = freq;\n        }\n    }\n    return max < 0 ? -1 : max;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis answer is incorrect, since you are\
    \ only returning the `max` for the first occurrence. For example, `search([5,5,4,4,4])`\
    \ should return `4` since it's the first `4` which is greater in frequency than\
    \ the second `5`.\n<|/ c |>\n<| c |>\nyou are right i missed that case i will\
    \ edit the answer.\n<|/ c |>\n<| c |>\nI think you have a typo. The second `if(freq\
    \ > max)` should be `if(freq >= max)`. Otherwise you are only returning the `max`\
    \ for the first occurrence, not the greatest one.\n<|/ c |>\n<| c |>\nNo it won't,it\
    \ will return -1 because if there is no number that satisfies the condition it\
    \ will not enter the for loop.\n<|/ c |>\n<| a tags=algorithm,c# |>\n<code>",
  "{\n    long max = -1, min = 0;\n    for(int i : lst)\n    {\n        if(i > max)\n\
    \            max = i;\n        if(i <= min)\n            min = i;\n    }\n   \
    \ return (-1 == max ? -1 : max);\n}", "{\n    if(lst.lenth == 0)\n    {\n    \
    \    return -1L;\n    }", "{\n    int i = 0;\n    int j = 0;\n    long ans = -1;\n\
    \    int freq[lst.length];", "{\n\tint len = std.length(lst);\n\tint result =\
    \ -1;\n\tif (len <= 0) {\n\t\treturn result;\n\t}\n\tfor (int i = 0; i < len;\
    \ i++) {\n\t\tif (lst[i] >= 0) {\n\t\t\tlong freq = lst[i];\n\t\t\tlong maxFreq\
    \ = 0;\n\t\t\tint maxI = 0;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tlong\
    \ nextFreq = lst[j];\n\t\t\t\tif (nextFreq >= 0) {\n\t\t\t\t\tif (nextFreq <=\
    \ freq) {\n\t\t\t\t\t\tfreq = nextFreq;\n\t\t\t\t\t\tmaxFreq = freq;\n\t\t\t\t\
    \t\tmaxI = j;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmaxFreq = -1;\n\t\t\t\t\
    \tmaxI = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (maxFreq >= 0) {\n\t\t\t\tif (freq\
    \ >= maxFreq) {\n\t\t\t\t\tresult = lst[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\
    return result;\n}", "{\n    if (lst.length == 0) return -1;\n    var res = lst[0];\n\
    \    var freq = 0;\n    for (var i = 1; i < lst.length; i++)\n    {\n        if\
    \ (lst[i] > res && lst[i] <= lst[res + 1])\n            freq++;\n        else\n\
    \            freq--;\n        res = lst[freq < 0 ? lst.length - 1 : 0];\n    }\n\
    \    return res == -1 ? 0 : res;\n}\n</code>\n<|/ a tags=javascript,arrays,algorithm,time-complexity\
    \ dscore=0 |>\n<| a tags=javascript,arrays,algorithm,time-complexity dscore=0\
    \ |>\nIt took me a while to understand the \"find all duplicates in an array\"\
    \ question, so I'll try to explain my solution.\nThis solution uses the same concept\
    \ as others, however I find it easier to understand by implementing my own version\
    \ of the solution from the top answer here.\nThe basic idea is to iterate through\
    \ the array, incrementing a counter for each \"duplicate\" encountered during\
    \ iteration through the array.\nIf the counter reaches 0, the duplicate element\
    \ has been found and you can return it, else increment the counter and start again.\n\
    <code>\nfunction findDuplicate(arr) {\n    let counter = 0;\n    let duplicateFound\
    \ = false;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] ==\
    \ arr[i + 1]) {\n            counter++;\n            duplicateFound = true;\n\
    \        } else {\n            counter = 1;\n        }\n        if (counter ==\
    \ 0) {\n            return arr[i];\n        }\n    }\n    if (!duplicateFound)\
    \ {\n        return -1;\n    }\n}\n</code>\n<|/ a |>\n<| a tags=javascript,arrays,algorithm,time-complexity\
    \ |>\n<code>\nfunction findDuplicates(arr) {\n    let newArr = arr.filter((v,\
    \ i, a) => {\n        let found = false;\n        for (let ii = i; ii < a.length;\
    \ ii++) {\n            if (v == a[ii]) {\n                found = true;\n    \
    \            break;\n            }\n        }\n        return !found;\n    });\n\
    \    return newArr[0];\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease don't post\
    \ only code as an answer, but also provide an explanation of what your code does\
    \ and how it solves the problem of the question. Answers with an explanation are\
    \ usually of better quality, and are more likely to attract upvotes\n<|/ c |>\n\
    <| a tags=javascript,arrays,algorithm,time-complexity |>\n<code>\nlet input =\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 1, 2, 3, 4, 5];", "{\n    long val = lst[0];\n    long count\
    \ = 0;\n    for (long i : lst) {\n        if (i == val) {\n            count++;\n\
    \        }\n        if (count > val) {\n            val = count;\n        }\n\
    \    }\n    return val > 0 ? val : -1;\n}", "{\n    long max_val = 0;\n    long\
    \ freq = lst[0];\n    for (int i = 1; i < lst.Length; i++)\n    {\n        if\
    \ (lst[i] > freq)\n        {\n            max_val = lst[i];\n            freq\
    \ = lst[i];\n        }\n    }", "{\n    long ans = -1;\n    long min = lst[0];\n\
    \    for(int i = 1; i < lst.Length; i++) {\n        if(lst[i] >= min) break;\n\
    \        min = lst[i];\n    }\n    if(lst.Length > 0) {\n        int i = 0;\n\
    \        while(i < lst.Length && lst[i] <= min) {\n            i++;\n        }\n\
    \        ans = lst[i];\n    }\n    return ans;\n}", "{\n    long result = -1;\n\
    \    int i = 0;\n    for(i=0; i<lst.length; i++) \n    {\n        if(lst[i] >\
    \ 0)\n        {\n            long index = search(lst, i);\n            if(index\
    \ != -1)\n            {\n                if(index >= result) result = index;\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    if(lst.length\
    \ == 0)\n        return -1;", "{\n    return search(lst, -1, 0);\n}", "{\n   \
    \ long maxVal = lst[0], freq = 1;\n    for (int i = 1; i < lst.Length; i++)\n\
    \    {\n        if (lst[i] > 0)\n        {\n            freq++;\n            if\
    \ (freq > maxVal)\n            {\n                maxVal = freq;\n           \
    \ }\n        }\n        else\n        {\n            freq--;\n        }\n    }\n\
    \    return maxVal;\n}", "{\n    int maxIndex = 0, maxVal = 0;\n    for (int i\
    \ = 1; i < lst.size(); i++)\n    {\n        if (lst[i] >= lst[maxIndex])\n   \
    \     {\n            maxIndex = i;\n            maxVal = lst[i];\n        }\n\
    \    }\n    if (maxIndex == lst.size() - 1)\n        return -1;\n    else if (maxIndex\
    \ == 0)\n        return maxVal;\n    else\n        return search(lst, (maxIndex\
    \ - 1), maxVal);\n}", "{\n    long max = 0;\n    long freq = 0;\n    for(int i\
    \ = 0; i <lst.length; i++)\n    {\n        if(freq == 0) max = lst[i];\n     \
    \   freq = lst[i] + 1;\n    }\n    return max;\n}\n</code>\n<|/ a tags=c,algorithm,search,arrays\
    \ dscore=0 |>\n<| c |>\n`for(int i = 0; i <lst.length; i++)\n    {\n        if(freq\
    \ == 0) max = lst[i];\n        freq = lst[i] + 1;\n    }` this loop doesn't do\
    \ what OP expects\n<|/ c |>\n<| c |>\nOP is expecting `-1` as the answer.\n<|/\
    \ c |>\n<| c |>\n\"Return the greatest integer that is greater than zero\" - OP\
    \ says \"no such a value exist, return -1\"\n<|/ c |>\n<| c |>\nOops. I totally\
    \ missed that. I will delete my answer as soon as I come up with something better.\
    \ Thanks\n<|/ c |>\n<| c |>\nThank you so much! I am not looking for the most\
    \ efficient code, just an algorithm, and your solution was perfect!\n<|/ c |>\n\
    <| a |>\nA fast and straight forward approach for solving this would be to sort\
    \ the array of numbers and then use two pointers, one going forward and one going\
    \ backwards. Keep track of the current greatest number and the highest index at\
    \ which the number has been found. You then just have to compare the indices and\
    \ return the greater index number. This is how it would look like in C:\n<code>\n\
    #include <stdio.h>\n#include <stdlib.h>\n#include <string.h>", "{\n    if (lst.Length\
    \ <= 0)\n        return -1;\n    var dict = new SortedDictionary<long, int>(new\
    \ KeyValuePairComparer<long, int>((i, j) => { return i.Value < j.Value; }));\n\
    \    foreach (var x in lst)\n    {\n        if (!dict.ContainsKey(x))\n      \
    \      dict.Add(x, 0);\n        dict[x]++;\n    }\n    foreach (var v in dict)\n\
    \    {\n        if (v.Value >= v.Key.Value)\n            return v.Key;\n    }\n\
    \    return -1;\n}\n</code>\n<|/ a dscore=2 tags=algorithm,search |>\n<| c |>\n\
    Nice, but your solution only works in .NET 4. I'm looking for a solution in .NET\
    \ 3.5.\n<|/ c |>\n<| c |>\nYou can change lambda expression to delegate to work\
    \ with .NET 3.5.\n<|/ c |>\n<| c |>\n: Could you please post an answer?\n<|/ c\
    \ |>\n<| c |>\n: I added a LINQ-free .NET 3.5 solution. :-)\n<|/ c |>\n<| a dscore=1\
    \ |>\nThis is a little bit of an oddity, but a good exercise nonetheless.  Here's\
    \ a solution that (inspired by this question) uses a dictionary to look up all\
    \ the values once, and then a binary search to find the largest value.  \n<code>\n\
    private long BinarySearch(List<int> values)\n{\n    Dictionary<int, int> valueCounts\
    \ = new Dictionary<int, int>();\n    foreach (int value in values)\n    {\n  \
    \      if (!valueCounts.ContainsKey(value)) valueCounts[value] = 0;\n        valueCounts[value]++;\n\
    \    }\n    int max = -1;\n    int maxCount = 0;\n    int maxValue = 0;\n    int\
    \ minValue = Int32.MaxValue;\n    foreach (int value in values)\n    {\n     \
    \   if (valueCounts[value] > maxCount)\n        {\n            max = value;\n\
    \            maxCount = valueCounts[value];\n            maxValue = value;\n \
    \       }\n        if (valueCounts[value] < minValue)\n        {\n           \
    \ minValue = value;\n        }\n    }\n    return max != -1 ? max : minValue;\n\
    }\n</code>\nThe idea is to build a dictionary whose key is the current value,\
    \ and whose value is how many times that value appears in the list.  The dictionary\
    \ is initialized to contain one entry per unique value in the list.  Then, the\
    \ loop through the list sets the max to the first value with a count greater than\
    \ the current max count, and sets minValue to the smallest value that isn't larger\
    \ than the current max count.  This will give you a binary search for the largest\
    \ value.  Note that this is O(n) because we're iterating over the list only once.\n\
    <|/ a tags=algorithm,", "{\n    if (lst.Length == 0)\n        return -1;\n   \
    \ var max = lst[0];\n    foreach (var item in lst)\n    {\n        if (item >\
    \ max)\n            max = item;\n    }\n    return max;\n}\n</code>\n<|/ a |>\n\
    <| a tags=sorting,algorithm,c#,arrays,linq |>\nHere's my first attempt using LINQ\n\
    <code>", "{\n    long res = lst[0];\n    for(int i = 1; i < lst.length; i++)\n\
    \    {\n        if(i == lst.length)\n        {\n            return -1;\n     \
    \   }\n        if(std.math.abs(lst[i] - res) < res)\n        {\n            res\
    \ = lst[i];\n        }\n    }\n    return res;\n}", "{\n    long max_freq=0, freq=lst[0];\n\
    \    for(int i=1; i<lst.size(); i++)\n    {\n        freq = freq*lst[i];\n   \
    \     if(freq>=max_freq)\n        {\n            max_freq = freq;\n        }\n\
    \    }\n    if(max_freq==0)\n    {\n        return -1;\n    }\n    long ans =\
    \ -1;\n    for(int i=0; i<lst.size(); i++)\n    {\n        if(freq==lst[i])\n\
    \        {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\n</code>\n<|/ a |>\n<| c |>\nThis solution is amazing! Thanks for sharing.\
    \ I want to know why you used the constant \"0\" for \"max_freq\" variable?\n\
    <|/ c |>\n<| c |>\nBecause I used it initially and later changed it to something\
    \ more efficient by changing the variable name. It's a habit I learned after spending\
    \ days on my code before realizing that I had made the same mistake as in the\
    \ initial code.\n<|/ c |>\n<| c |>\nIt's a habit. In some languages it's required\
    \ to declare variables before using it. In Java that's not required. Python doesn't\
    \ require it. Hence the habit.\n<|/ c |>\n<| a dscore=2 tags=java,algorithm |>\n\
    This problem can be solved in O(n), using the following observation", "{\n   \
    \ long result = 0;\n    for (int i = 0; i < lst.Length; i++) {\n        if (lst[i]\
    \ > result) {\n            result = lst[i];\n        }\n        if (lst[i] ==\
    \ result) {\n            result += (lst[i] / lst[0]);\n        }\n    }\n    if\
    \ (result < 0) {\n        result = -1;\n    }\n    \n    return result;\n}\n</code>\n\
    <|/ a tags=python,algorithm |>\n<| a |>\nI guess it can be done in O(n), because\
    \ you need to count the frequency of each element in the given array, and since\
    \ you can't iterate through the array twice simultaneously, it can be done in\
    \ O(n). \n<code>\ndef findGreatestNumber(arr):\n    max = -1\n    frequency =\
    \ {}\n    for i in arr:\n        if i not in frequency:\n            frequency[i]\
    \ = 1\n        else:\n            frequency[i] += 1\n        if max < 0 and frequency[i]\
    \ > max:\n            max = i\n        elif frequency[i] > max:\n            max\
    \ = frequency[i]\n    return max\n</code>\n<|/ a tags=python,algorithm dscore=0\
    \ |>\n<| c |>\nBut this solution is actually O(n*n). Not O(n).\n<|/ c |>\n<| c\
    \ |>\n, OP asked for the O(n) solution. I mentioned that it's O(n*n). Thanks for\
    \ your comment though!\n<|/ c |>\n<| c |>\nOh, didn't see that part. Nevertheless,\
    \ this solution has quadratic complexity.\n<|/ c |>\n<| c |>\n, you're right,\
    \ thanks for pointing that out. I've updated the answer.\n<|/ c |>\n<| c |>\n\
    `max = -float('inf')` and `frequency = {}` would be better than `max = -1`.\n\
    <|/ c |>\n<| a dscore=0 |>\nA recursive solution can be something like this:\n\
    <code>\ndef search (arr):\n    if not arr:\n        return -1\n    if arr[0] >\
    \ arr[1]:\n        return arr[0]\n    else:\n        return max(search([arr[0]\
    \ - 1]) + 1, search([arr[1] - 1]) + 1) - arr[0] - 1\n</code>\n<|/ a tags=python,algorithm\
    \ |>\n<| c |>\nIt's O(n^2) because you call the same function twice.\n<|/ c |>\n\
    <| c |>\nThe recursion depth of the function itself is O(n) not O(n^2) because\
    \ of the two calls to the same function twice which would be considered as two\
    \ separate calls.\n<|/ c |>\n<| c |>\nThe recursion depth is actually O(n) but\
    \ that doesn't mean the whole algorithm is O(n) because ", "{\n    int idx = 1;\n\
    \    int freq = 1;\n    while(idx<lst.length){\n        if(lst[idx]==lst[idx-1])\
    \ freq++;\n        idx++;\n    }\n    long maxval = -1;\n    for(int i=0;i<lst.length;i++){\n\
    \        if(lst[i]>0 && lst[i]>freq && lst[i]!=maxval){\n            maxval =\
    \ lst[i];\n        }\n    }\n    return maxval;\n}\n</code>\n<|/ a |>\n<| a |>\n\
    I modified the solution provided by Michael Wong to fit into the template of a\
    \ C++ template. This solution utilizes STL for searching and sorting (std::set)\
    \ and STL for sorting (std::vector).\n<code>\n#include \"stdafx.h\"\n#include\
    \ <iostream>\n#include <set>\n#include <vector>\nusing namespace std;", "{\n \
    \   long result = 0;\n    int max = 0;\n    foreach (int i, lst)\n    {\n    \
    \    if (i > max)\n        {\n            if (result == 0 && max != 0)\n     \
    \       {\n                result += i - max;\n            }\n            max\
    \ = i;\n        }\n        else if (i == max)\n        {\n            result +=\
    \ i - max;\n        }\n    }\n    return result > 0 ? result : -1;\n}\n</code>\n\
    <|/ a tags=c# |>\n<| c |>\n`if (result == 0 && max != 0)` - `max` can be `-1`\n\
    <|/ c |>\n<| a |>\n<code>\nvar result = lst.Max(x => lst.Count(y => y >= x &&\
    \ y != x));\n</code>\n<|/ a tags=c# dscore=1 |>\n<| a tags=c# |>\n<code>", "{\n\
    \    long maxVal = lst[0];\n    long freq = lst[1];", "{\n    int res = -1;\n\
    \    foreach (long i : lst)\n    {\n        if (i > 0 && res > 0) \n        {\n\
    \            int c = i - 1;\n            if (res >= c)\n                return\
    \ res;\n        }\n        else\n            res = i;\n    }\n    return res;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,arrays |>\n<code>\npublic int Search(int[]\
    \ array)\n{\n    if (array == null || array.Length == 0)\n        return -1;\n\
    \    else\n    {\n        foreach (int i in array)\n            if (i > 0)\n \
    \               return i;\n    }\n    return -1;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding how and/or why it solves the problem would improve the answer's long-term\
    \ value.\n<|/ c |>\n<| c |>\nYeah, I should have explained that in more detail.\
    \ Just wanted to solve it for myself as I was having fun writing it. I thought\
    \ maybe it would be useful if anybody else came to my answer.\n<|/ c |>\n<| a\
    \ |>\n<code>", "{\n    long max = lst[0];\n    long index = -1;\n    for(int i=1;\
    \ i<lst.size(); i++)\n    {\n        if(max < lst[i])\n        {\n           \
    \ max = lst[i];\n            index = i;\n        }\n    }\n    return max;\n}",
  "{\n    int len = lst.Length;\n    for (int i = 0; i < len; i++)\n    {\n      \
    \  int freq = 0;\n        foreach (long j in lst)\n        {\n            if (j\
    \ == i) \n            {\n                freq++;\n            }\n        }\n \
    \       if (i > 0)\n        {\n            if (freq > lst[i - 1]) \n         \
    \   {\n                return -1;\n            }\n            else\n         \
    \   {\n                lst[i - 1] = freq;\n            }\n        }\n        else\n\
    \        {\n            if (freq > lst[i - 1]) \n            {\n             \
    \   return -1;\n            }\n            else\n            {\n             \
    \   lst[i - 1] = freq;\n            }\n        }\n    }\n    return lst[0];\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nThis is not a straight forward\
    \ question. \nYou are trying to find the first maximum value that can appear in\
    \ a given array (possibly in sorted array). \nThis is called binary search. \n\
    The algorithm goes as follows (I will not write it for you). ", "{\n    long high=0,\
    \ low=0;\n    long maxValue = lst[0];\n    long frequency = lst[0];\n    for (int\
    \ i=1; i<lst.size(); i++)\n    {\n        if (lst[i] > maxValue)\n        {\n\
    \            high=maxValue;\n            low=lst[i];\n            maxValue = lst[i];\n\
    \        }\n        else if (lst[i] == maxValue)\n        {\n            frequency++;\n\
    \        }\n        else\n        {\n            maxValue = lst[i];\n        \
    \    frequency = 1;\n        }\n    }\n    if (frequency <= lst[high])\n    {\n\
    \        return -1;\n    }\n    else\n    {\n        return low;\n    }\n}", "{\n\
    \tif (lst.length == 0)\n\t\treturn -1L;\n\tlong freq = 1L;\n\tfor (int i = 1;\
    \ i < lst.length; i++) \n\t\tif (lst[i] > lst[i - 1]) \n\t\t\tfreq++;\n\t\telse\n\
    \t\t\tbreak;\n\treturn freq;\n}\n/*", "{\n    long minval, maxval, freq, val,\
    \ i;\n    minval = lst[0];\n    maxval = lst[0];\n    freq = 0;\n    for(i = 0;\
    \ i < lst.size(); ++i)\n    {\n        if(lst[i] > maxval)\n        {\n      \
    \      maxval = lst[i];\n        }\n        if(lst[i] < minval)\n        {\n \
    \           minval = lst[i];\n        }\n        freq = freq + (lst[i] - minval);\n\
    \    }\n    if(freq >= maxval - minval)\n    {\n        return -1;\n    }\n  \
    \  return minval + freq;\n}\n</code>\n<|/ a tags=arrays,algorithm,c |>\n<| c |>\n\
    +1 for the solution, but I'm really trying to solve this problem without using\
    \ pointers and stuff\n<|/ c |>\n<| c |>\nYou said yourself in comments above that\
    \ you want to solve this problem without pointers and stuff.\n<|/ c |>\n<| c |>\n\
    If you don't like pointers and stuff then you're going to have to rewrite your\
    \ search algorithm from scratch -- no sane algorithm can do it without pointers\
    \ and stuff.\n<|/ c |>\n<| c |>\nYeah I know but I have to do it in an easier\
    \ way\n<|/ c |>\n<| c |>\nNo, your solution is correct. I'll post my code shortly.\n\
    <|/ c |>\n<| a dscore=0 |>\nI solved it myself thanks to all your answers. Here\
    \ is my code:\n<code>\n#include <stdio.h>\n#include <stdlib.h>", "{\n\tint l =\
    \ lst.length;\n\tlong retval = -1;\n\tfor (int i = 1; i < l; i++)\n\t{\n\t\tif\
    \ (lst[i] > lst[i - 1]) \n\t\t{\n\t\t\tif (retval <= 0) \n\t\t\t{\n\t\t\t\tretval\
    \ = lst[i];\n\t\t\t}\n\t\t\telse if (lst[i] != retval) \n\t\t\t{\n\t\t\t\tretval\
    \ = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn retval;\n}", "{\n    long max = 1;\n  \
    \  int i;\n    for (i = 0; i < (int)lst.Length; i++) {\n        if (lst[i] >=\
    \ 0) {\n            int fr = std.typecons.frequency(lst[i], lst);\n          \
    \  if (fr <= max) {\n                max = fr;\n            }\n        }\n   \
    \ }\n    return max;\n}\n</code>\n<|/ a tags=list,search,c#,arrays |>\n<| a tags=list,search,c#,arrays\
    \ |>\n<code>\nprivate static int Search(int SearchedValue, int[] Numbers)\n{\n\
    \    for (int i = 0; i < Numbers.Length; i++)\n    {\n        if (Numbers[i] >\
    \ SearchedValue)\n        {\n            return i;\n        }\n    }\n    return\
    \ -1;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe question was about finding\
    \ which one appeared in the array more than once.\n<|/ c |>\n<| c |>\nI thought\
    \ it was. Perhaps I misread it. Sorry for the misunderstanding.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nYou can try this:\n<code>\n        int[] arr = new int[] { 1,\
    \ 2, 3, 3, 2, 3 };\n        int number = 2; // Search for the number 2\n     \
    \   var count = arr.Where(n => n == number).ToList();\n        if(count.Count\
    \ > 0)\n        {\n            Console.WriteLine(count.Count);\n        }\n  \
    \      else\n        {\n            Console.WriteLine(\"Not found\");\n      \
    \  }\n</code>\nOutput:\n<code>\n4\n</code>\n<|/ a tags=list,search,c#,arrays |>\n\
    <| a tags=list,search,c#,arrays |>\nThis is a solution that counts the number\
    \ of instances of the element that appears more than once in the array. It returns\
    \ the index of the element (0 indexed) or -1 if the element does not appear in\
    \ the array:\n<code>", "{\n    long max = 0L;\n    long index = 0;\n    int sum\
    \ = 0;\n    for(int i = 0; i < lst.Length; i++)\n    {\n        sum += lst[i];\n\
    \        if(sum >= max)\n        {\n            max = sum;\n            index\
    \ = i;\n        }\n    }\n    if(max > 0)\n        return lst[index];\n    else\n\
    \        return -1L;\n}\n</code>\n<|/ a tags=search,algorithm dscore=1 |>\n<|\
    \ c |>\nI guess this works better than other answer, because it will find the\
    \ longest run of equal elements.\n<|/ c |>\n<| c |>\nYes, you are right, but I\
    \ don't see why it should be faster than the algorithm of Kael\n<|/ c |>\n<| a\
    \ dscore=0 tags=search,algorithm |>\n<code>\nimport java.util.Arrays;\nimport\
    \ java.util.Scanner;", "{\n\tfor(int i = 0; i< lst.length; i++) \n\t{\n\t\tint\
    \ sum = 0;\n\t\tfor(int j = 0;j < lst.length;j++) \n\t\t{\n\t\t\tif (lst[j] <=\
    \ lst[i]) \n\t\t\t{\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tif (sum >= lst[i]) \n\
    \t\t{\n\t\t\treturn lst[i];\n\t\t}\n\t}\n\treturn -1;\n}\n</code>\n<|/ a tags=algorithm,sorting\
    \ |>\n<| c |>\n`std.array` is `std` which is not necessary a good idea as it doesn't\
    \ have anything like `std` so I would remove it.\n<|/ c |>\n<| c |>\nI added an\
    \ alternative solution that does not use `std`\n<|/ c |>\n<| a |>\nThe problem\
    \ is that the input array must be sorted.\nHere is a simple algorithm to find\
    \ the greatest number that is greater than zero in a sorted array:\n<code>", "{\n\
    \    if(lst.size()==0)\n    {\n        return -1;\n    }\n    long res = lst[0];\n\
    \    for(int i=0;i<lst.size()-1;i++)\n    {\n        if(res>lst[i+1])\n      \
    \  {\n            res = lst[i+1];\n        }\n    }\n    return res;\n}\n</code>\n\
    <|/ a dscore=0 tags=java,algorithm |>\n<| c |>\nThis approach only works if all\
    \ elements of the input are positive. Which is not the case here, so this is not\
    \ an answer to the question.\n<|/ c |>\n<| c |>\nYes it works, just not for all\
    \ positive numbers. I guess I misread the question.\n<|/ c |>\n<| a tags=java,algorithm\
    \ dscore=0 |>\nThis should work, I made a slight change in what they asked.\n\
    <code>\npublic class Freq {", "{\n    if (lst.length == 0) \n        return -1;",
  "{\n    long sum = 0;\n    long maxVal = lst[0];\n    for (int i = 1; i < lst.size();\
    \ ++i)\n    {\n        if (lst[i] < maxVal)\n            sum += (maxVal == lst[i])\
    \ ? 1 : 0;\n        else\n        {\n            maxVal = lst[i];\n          \
    \  sum = 0;\n        }\n    }\n    if (sum >= lst.size())\n        return -1;\n\
    \    return maxVal;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYou should explain\
    \ why you think this works, it certainly doesn't.\n<|/ c |>\n<| c |>\n, what do\
    \ you mean explain it please?\n<|/ c |>\n<| c |>\nThe code might have some bugs,\
    \ since I wrote it here, but I believe it works.\n<|/ c |>\n<| c |>\n, I added\
    \ explanations, hope it helps.\n<|/ c |>\n<| c |>\nThanks Joachim. It looks like\
    \ your code works just fine.\n<|/ c |>\n<| a dscore=1 tags=arrays,c++,algorithm\
    \ |>\nOne method would be to use a hashtable. This would allow you to search quickly\
    \ by looking up the current number in O(1).\nThe algorithm would be:\n<code>\n\
    for each element e in array\n{\n    insert e into hash table H\n}\nfor each number\
    \ n from 1 to length of array\n{\n    find the largest number k such that H[k]\
    \ <= n and H[k] >=0\n    return -1 if there is no such k\n    decrement the value\
    \ of H[k]\n}\n</code>\nThis algorithm is O(1).\n<|/ a |>\n<| c |>\nThat doesn't\
    \ work. Assume you have this array: [1, 3, 2, 3, 1, 1, 2, 1]. The first pass through\
    \ the first loop will insert the integers 1 into H: {1: 1, 3: 1, 2: 2}. The second\
    \ pass will insert 2 into H: {1: 2, 3: 1, 2: 2}. Both 1 and 2 will be returned\
    \ in the second pass.\n<|/ c |>\n<| c |>\nAh yes that's true. The code I wrote\
    \ would just insert all the elements into hash table\n<|/ c |>\n<| a dscore=1\
    \ tags=arrays,c++,algorithm |>\nHere's my solution:\n<code>", "{\n    int n =\
    \ lst.length;\n    long max = 0;\n    \n    if(n < 1)\n        return -1;\n  \
    \  \n    for(int i = 0; i < n; i++)\n    {\n        if(max < lst[i])\n       \
    \ {\n            max = lst[i];\n        }\n    }\n    \n    return max;\n}\n</code>\n\
    <|/ a tags=c++,algorithm,arrays |>\n<| c |>\nThanks for the code! However it is\
    \ giving me this error after compilation: Undefined symbols for architecture x86_64:\n\
    \  \"_search\", referenced from:\n      _main in main.o\nld: symbol(s) not found\
    \ for architecture x86_64\nclang: error: linker command failed with exit code\
    \ 1 (use -v to see invocation)\n<|/ c |>\n<| c |>\nHave you declared the function\
    \ in the global scope? If so you need to add `static` to the declaration so it's\
    \ `static long search(long[] lst)`\n<|/ c |>\n<| c |>\nThank you so much! It works\
    \ :) You are the best!\n<|/ c |>\n<| a |>\n<code>\n#include <iostream>", "{\n\
    \    long max = -1, max = -1, i = -1, freq = 1, curr = lst[i], cnt = 0;\n    while\
    \ (curr != lst[i])\n    {\n        freq = ++cnt;\n        curr = lst[i];\n   \
    \ }\n    for (; i < lst.Length - 1; i++) \n    {\n        if (lst[i] < curr)\n\
    \            break;\n        curr++;\n        freq++;\n    }\n    if (freq >=\
    \ curr.Freq && max < 0)\n        max = curr.Num;\n    return max;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>\npublic static long search(int[] nums)\n{\n\
    \    int low = 0, high = nums.Length - 1;\n    long result = -1;", "{\n    //write\
    \ your code here\n    sort(lst);\n    int sum = 0;\n    int ans = -1;\n    int\
    \ i = 0;\n    int j = 0;\n    while(i < lst.lenght && j < lst.lenght)\n    {\n\
    \        \n        if (lst[i] > j)\n        {\n            sum = (lst[i] - j)\
    \ * (lst.lenght - j);\n            ans = max(ans, sum);\n            i++;\n  \
    \      }\n        if (j == lst.lenght - 1)\n        {\n            j = 0;\n  \
    \          sum = 0;\n        }\n        if (lst[j] >= sum)\n        {\n      \
    \      sum = (lst[j] - sum) * (lst.lenght - j + 1);\n            ans = max(ans,\
    \ sum);\n            j++;\n        }\n    }\n    return ans;\n}", "{\n    long\
    \ maxFreq = -1;\n    long maxVal = lst[0];\n    for (long i = 1; i < lst.length;\
    \ i++) \n    {\n        if (lst[i] > maxVal) \n        {\n            maxVal =\
    \ lst[i];\n            maxFreq = i;\n        }\n        else if (lst[i] == maxVal)\
    \ \n        {\n            maxFreq++;\n        }\n    }\n    return maxVal;\n\
    }\n</code>\n<|/ a tags=java,algorithm |>\n<| c |>\nthanks for the answer. But\
    \ I cannot understand your code. How are you checking for the occurrence of maxFreq\
    \ in array when we are only incrementing the maxVal ?\n<|/ c |>\n<| c |>\n- We\
    \ are comparing our maxVal to the current value in the array, if they are the\
    \ same then we increment the maxFreq. If they're not the same we update the maxVal.\n\
    <|/ c |>\n<| c |>\nI think you misunderstood what the question asks. I read it\
    \ as \"given a non-empty array of positive integers, find the greatest integer\
    \ that is greater than zero, and has a frequency greater than or equal to the\
    \ value of the integer itself. The frequency of an integer is the number of times\
    \ it appears in the array. If no such a value exist, return -1.\"\n<|/ c |>\n\
    <| c |>\n- Yeah, I misunderstood the question. Now I understand what they are\
    \ asking. Thanks.\n<|/ c |>\n<| a dscore=2 |>\n<code>\npublic static long search(long[]\
    \ lst) \n{\n    int maxFreq = -1;\n    int maxVal = lst[0];\n    for (int i =\
    \ 1; i < lst.length; i++) \n    {\n        if (lst[i] > maxVal) \n        {\n\
    \            maxVal = lst[i];\n            maxFreq = i;\n        }\n        else\
    \ if (lst[i] == maxVal) \n        {\n            maxFreq++;\n        }\n    }\n\
    \    return maxVal;\n}\n</code>\n<|/ a tags=java,algorithm |>\n<| c |>\nThe only\
    \ thing I didn't understand was that you are returning maxVal. What happens if\
    \ maxVal and lst[i] are not equal? Won't you be returning the first occurrence\
    \ of maxVal ?\n<|/ c |>\n<| c |>\n- Yes, you're right. maxVal is still the same\
    \ value as lst[0] when lst[0] wasn't the maxVal. I've updated the answer to be\
    \ clearer.\n<|/ c |>\n<| a tags=java,algorithm |>\nIn Python you could do this:\n\
    <code>\ndef search(lst):\n    maxFreq = -1\n    maxVal = lst[0]\n    for val in\
    \ lst:\n        if val == maxVal:\n            maxFreq += 1\n        else:", "{\n\
    \    long freq = lst[0];\n    int i = 0;", "{\n    int i = 0, j = 0;\n    long\
    \ res = -1;", "{\n    int index = findGreatestElement(lst);\n    long frequency;\n\
    \    if (index >= 0) {\n        frequency = std.length(lst) - index;\n    }\n\
    \    else {\n        frequency = -1;\n    }\n    return frequency;\n}", "{\n \
    \  long min = std.math.top.min(lst);\n   long max = std.math.top.max(lst);\n \
    \  long mid = (min + max) / 2;\n   long freq = lst[mid];\n   \n   if (freq ==\
    \ 0) return -1;\n   if (freq < 0) return search(freq < 0 ? lst[mid] : std.math.divrem(lst[mid],\
    \ -freq));\n   \n   long mindiff = std.math.sub(max, mid);\n   return search(std.math.divrem(std.math.sub(max,\
    \ mid), freq) < 0 ? lst[mid] : std.math.divrem(lst[mid], freq)) < mindiff ? \n\
    \              search(freq < 0 ? lst[mid] : std.math.divrem(lst[mid], -freq))\
    \ : \n              search(std.math.divrem(std.math.sub(max, mid), freq) < 0 ?\
    \ lst[mid] : std.math.divrem(lst[mid], freq));\n}", "{\n    int i, j;\n    int\
    \ max_i = -1, max_j = -1, max_freq = -1;\n    for (i = 0; i < lst.size(); i++)\n\
    \    {\n        if (max_freq == -1 || (lst.count(lst[i]) > max_freq && max_freq\
    \ == -1))\n        {\n            max_freq = lst.count(lst[i]);\n            max_i\
    \ = i;\n            max_j = lst.size() - 1;\n        }\n        else if (lst.count(lst[i])\
    \ > max_freq && max_freq != -1)\n        {\n            max_freq = lst.count(lst[i]);\n\
    \            max_i = i;\n            max_j--;\n        }\n    }\n    if (max_freq\
    \ != -1)\n        return lst[max_i];\n    return -1;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 tags=python,algorithm,c,java |>\nThis is my solution to find\
    \ all occurrences of a number in an array.\n<code>\n#include<stdio.h>\n#include<conio.h>\n\
    #include<stdlib.h>", "{\n    long res = 0;\n    long max = 0;\n    for(int i=0;\
    \ i<lst.length; i++)\n    {\n        if(lst[i] >= 0)\n        {\n            if((res\
    \ < lst[i]) || \n               ((res == lst[i]) && (lst[i] < max)))\n       \
    \     {\n                max = lst[i];\n                res = lst[i];\n      \
    \      }\n        }\n    }\n    return res;\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a tags=c++,algorithm,data-structures |>\nA simple approach would be to store\
    \ and maintain a binary search tree which keeps track of the largest values seen\
    \ so far. Then, when a new element is found, if the tree is empty, or the new\
    \ element is larger than the current largest, update the tree to keep track of\
    \ the new largest value.\nYou would simply traverse the tree to find the largest\
    \ value larger than zero.\nIf the tree is empty, simply return -1.\nIf the tree\
    \ is not empty but the new value is not larger than the current largest, simply\
    \ return -1.\nOtherwise, if the new value is larger than the current largest,\
    \ update the tree to keep track of the new largest value.\nIf the tree is empty,\
    \ then the new value is larger than the current largest, so simply update the\
    \ tree to keep track of the new largest value.\nOtherwise, if the new value is\
    \ smaller than the current largest, simply update the tree to keep track of the\
    \ new largest value.\nOtherwise, the new value is smaller than the current largest,\
    \ so simply update the tree to keep track of the new largest value.\n<|/ a dscore=1\
    \ |>\n<| a |>\n<code>\n#include<iostream>\n#include<cstdlib>", "{\n    Arrays.sort(lst);\n\
    \    long res = -1L;\n    for (int i=1; i<lst.length; ++i) {\n        if (lst[i-1]==lst[i])\
    \ {\n            if (lst[i-1]>res) res = lst[i-1];\n        } else {\n       \
    \     if (lst[i-1]<res) res = lst[i-1];\n        }\n    }\n    return res;\n}\n\
    </code>\n<|/ a |>\n<| a |>\nThis is a solution that works in O(n), but is way\
    \ less elegant than using an array.\n<code>\nlong search(long[] list) {\n    long\
    \ max = list[0], count = 0;\n    for(long i: list) {\n        if (i > max) {\n\
    \            max = i;\n            count = 1;\n        } else if (i > max * count)\
    \ {\n            max = i;\n            count = count + 1;\n        }\n    }\n\
    \    return max > 0 ? max : -1;\n}\n</code>\n<|/ a dscore=2 tags=algorithm,java,arrays,search\
    \ |>\n<| c |>\nThis solution is incorrect because it does not take into account\
    \ the frequency of an integer. For example, search([1,1,1,1,1]) should return\
    \ 1, but the answer given is 2.\n<|/ c |>\n<| a dscore=1 tags=algorithm,java,arrays,search\
    \ |>\nI believe that a hash map would be best for this, as it would not require\
    \ any sort or searching:\n<code>\npublic static long search(int[] array) {\n \
    \   int count = 0, max = -1;\n    for (long integer : array) {\n        count\
    \ += 1;\n        if (count > max) {\n            max = count;\n        }\n   \
    \ }", "{\n  int i = 0;\n  long maxVal = lst[0];\n  long curVal = maxVal;\n  long\
    \ maxFreq = maxVal;\n  long count = 1;\n  \n  // Find first occurrence of maxVal\n\
    \  while(!isincr(curVal, curVal, i, count)) \n  {\n    count++;\n    curVal =\
    \ maxVal;\n  }\n  \n  while(i < lst.size)\n  {\n    if(lst[i] > curVal)\n    {\n\
    \      // This value greater than curVal. Increment curVal.\n      curVal = lst[i];\n\
    \      // Increment count if curVal is greater than maxVal\n      if(curVal >\
    \ maxVal)\n      {\n        maxVal = curVal;\n        maxFreq = count;\n     \
    \ }\n      count = 1;\n    }\n    else // curVal is less than maxVal\n    {\n\
    \      count++;\n      curVal = maxVal;\n    }\n    i++;\n  }\n  \n  // Return\
    \ -1L if maxVal has no occurrence.\n  if(maxFreq == 1)\n    return -1L;\n  else\n\
    \    return maxVal;\n}", "{\n    long maxFrequency = 0; \n    int index = 0;\n\
    \    for(long i : lst){\n        //If i found first time\n        if(i > maxFrequency){\n\
    \            maxFrequency = i;\n            index = i;\n        }\n        if(index\
    \ != i){\n            //If index is different than current i\n            maxFrequency\
    \ = -1L;\n            index = 0;\n        }\n    }\n    return maxFrequency;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 tags=arrays,algorithm,java |>\nHere\
    \ is a Java 8 stream solution:\n<code>\npublic static int search(long[] nums)\
    \ {\n    return Arrays.stream(nums)\n            .max(Comparator.comparing(Long::intValue))\n\
    \            .filter(i -> i >= 0)\n            .orElse(-1);\n}\n</code>\n<|/ a\
    \ |>\n<| a tags=arrays,algorithm,java |>\nHere is what I've got so far. I think\
    \ it's simple, and it passes tests, but I'm not so sure about performance. I'm\
    \ asking if I'm missing something in the code.\n<code>\npublic static int search(long[]\
    \ nums) {\n    long[] freq = new long[nums.length];\n    int minFrequency = Integer.MAX_VALUE;\n\
    \    int index = 0;", "{\n    long maxVal = 0;\n    long maxCount = -1;\n    for(int\
    \ i = 0; i < lst.length; ++i) {\n        long count = count(lst, lst[i]);\n  \
    \      if(count > maxCount) {\n            maxVal = lst[i];\n            maxCount\
    \ = count;\n        }\n    }\n    return maxCount;\n}", "{\n    long max = -999999999999999999;\n\
    \    int i;\n    bool isOdd = true;\n    for (i = 0; i < lst.length; ++i)\n  \
    \  {\n        if (lst[i] == 0)\n            continue;\n        else if (lst[i]\
    \ == max)\n        {\n            return -1;\n        }\n        else if (lst[i]\
    \ > max)\n        {\n            max = lst[i];\n        }\n        else if (lst[i]\
    \ == max-1 && isOdd)\n        {\n            return max;\n        }\n        else\n\
    \        {\n            isOdd = false;\n        }\n    }\n    return max;\n}\n\
    </code>\n<|/ a tags=search,arrays,algorithm,java,time-complexity dscore=2 |>\n\
    <| a tags=search,arrays,algorithm,java,time-complexity dscore=1 |>\nThe solution\
    \ below is based on a HashMap (Hash Table data structure) with the value as the\
    \ frequency of the value in the array. The complexity is O(n) since it is using\
    \ a HashMap\n<code>\npublic class FindGreatestFrequencyElement {", "{\n    long[]\
    \ freq = Arrays.stream(lst)\n                      .collect(groupingBy(e -> e,\
    \ counting()));\n    return freq.entrySet().stream()\n                   .filter(e\
    \ -> e.getValue() > e.getKey())\n                   .map(Map.Entry::getValue)\n\
    \                   .filter(e -> e > 0)\n                   .map(e -> {\n    \
    \                   long freq = e.getKey();\n                       long pos =\
    \ e.getValue() - 1;\n                       return freq > pos ? freq : pos;\n\
    \                   })\n                   .findFirst()\n                   .orElse(-1);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is very similar to [the accepted answer](https://stackoverflow.com/a/53267029/1149773)\
    \ and I don't see any difference. Could you explain the purpose of `.map(e ->\
    \ e.getValue() - 1)`?\n<|/ c |>\n<| c |>\n, `e.getValue()-1` will remove the frequency\
    \ count, so it will return only the positive numbers from the `freq` array. If\
    \ we remove `-1`, then `search` will return the maximum frequency that is greater\
    \ than zero for each number.\n<|/ c |>\n<| a tags=collections,java-8,java,java-stream\
    \ |>\n<code>\npublic static int search(int[] arr) {\n    return IntStream.range(0,\
    \ arr.length)\n            .filter(i -> arr[i] > 0)\n            .filter(i ->\
    \ IntStream.range(0, arr.length)\n                    .filter(j -> j > i)\n  \
    \                  .filter(j -> arr[j] == arr[i])\n                    .count()\
    \ > i)\n            .findFirst()\n            .orElse(-1);\n}\n</code>\n<|/ a\
    \ dscore=3 |>\n<| c |>\nWhat is wrong with this solution? It doesn't use any additional\
    \ libraries except the standard libraries.\n<|/ c |>\n<| c |>\nIt has O(n2) complexity,\
    \ while it can be done in O(n) complexity by two nested loops.\n<|/ c |>\n<| c\
    \ |>\nI think you forgot your second `filter` call though.\n<|/ c |>\n<| c |>\n\
    I see. This solution has the complexity of O(n^2) which is not an improvement\
    \ over a simple loop. It seems this would be the best solution so far.\n<|/ c\
    \ |>\n<| c |>\nyes. It's a brute force approach, which is of course not going\
    \ to scale well for big data. I guess it's unfortunate that this has been accepted.\n\
    <|/ c |>\n<| a tags=collections,java-8,java,java", "{\n    long largest = lst[0];\n\
    \    for (long i = 1; i < lst.size(); i++) \n    {\n        if (lst[i] < largest\
    \ && lst.contains(lst[i])) \n        {\n            largest = lst[i];\n      \
    \  }\n    }\n    if (largest == 0) return -1;\n    if (lst.length > lst.contains(largest))\
    \ return -1;\n    return largest;\n}\n</code>\n<|/ a tags=optimization,performance,java,arrays\
    \ |>\n<| c |>\nFor `ArrayList` it seems to be slightly faster to use `Collections.max(...)`\n\
    <|/ c |>\n<| c |>\nThe question was asked in the context of Java, and your answer\
    \ is in C#. Also, the question was about how to improve performance and not about\
    \ what the correct solution is.\n<|/ c |>\n<| a tags=optimization,performance,java,arrays\
    \ |>\nHere is my solution in Java. Hope it helps you. The algorithm is very simple: ",
  "{\n    if (lst.Length == 0)\n        return -1;\n    if (lst[0] != 0)\n       \
    \ return lst[0];\n    long max = 1;\n    foreach (int i in lst)\n    {\n     \
    \   if (i > max)\n        {\n            max = i;\n            if (max == lst[lst.length\
    \ - 1])\n                return -1;\n        }\n    }\n    return max;\n}\n</code>\n\
    <|/ a tags=algorithm,c# |>\n<| a tags=algorithm,c# |>\n<code>\npublic class Program\n\
    {\n    public static void Main(string[] args)\n    {\n        int n = 4;\n   \
    \     int[] a = new int[n]; //Array with size n\n        a[0] = 1;\n        a[1]\
    \ = 2;\n        a[2] = 3;\n        a[3] = 4;\n        Console.WriteLine(\"Greatest\
    \ number which has frequency greater than or equal to that of the number in array:\
    \ \" + GetMax(a));\n        Console.ReadLine();\n    }", "{\n    int i, n = lst.lenth;\n\
    \    long res = -1;\n    long freq = -1;\n    for(i=0; i<n; i++) {\n        if(freq\
    \ < lst[i])\n            freq = lst[i];\n    }\n    if(freq > 0) {\n        long\
    \ low = -1;\n        long high = -1;\n        for(i=0; i<n; i++) {\n         \
    \   if(lst[i] > 0)\n                low = i;\n            if(lst[i] < 0)\n   \
    \             high = i;\n        }\n        if(low != -1 && high != -1) {\n  \
    \          int mid = (low + high) / 2;\n            long ans = search(lst.subarray(mid,n));\n\
    \            if((ans >= 0 && ans == freq) || (ans < 0 && ans == -freq))\n    \
    \            res = ans;\n        }\n    }\n    return res;\n}", "{\n    if( lst.length\
    \ < 2 )\n        return -1;\n    \n    int maxFreq = 0;\n    int maxNum = 0;\n\
    \    int count = 0;\n    for( int i = 0; i < lst.length; i++ )\n    {\n      \
    \  if( lst[i] == 0 )\n            count++;\n        \n        int freq = std.typecons.freq[lst[i]];\n\
    \        \n        if( count > maxNum || ( maxNum == 0 && count >= maxFreq ) )\n\
    \        {\n            maxNum = count;\n            maxFreq = freq;\n       \
    \ }\n        \n        if( lst[i] == 0 ) \n        {\n            count = -1;\n\
    \        }\n    }\n    return maxNum;\n}", "{\n    int[] arr;\n    int i, j, freq;\n\
    \    int max = Integer.MIN_VALUE;", "{\n    if (lst.Length == 0) return -1;\n\
    \    long max = 0;\n    long cur = 0;\n    foreach(long e in lst) \n    {\n  \
    \      cur++;\n        if (cur > max) \n        {\n            max = cur;\n  \
    \      }\n    }\n    if (cur > max) \n    {\n        max = cur;\n    }\n    return\
    \ max;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=c# dscore=0 |>\n<code>", "{\n\
    \    long maxVal = lst.last();\n    long maxFreq = 0;\n    foreach(long elm, lst)\n\
    \    {\n        if (elm > maxVal)\n        {\n            maxVal = elm;\n    \
    \    }\n        else if (elm == maxVal)\n        {\n            maxFreq++;\n \
    \       }\n    }\n    return maxVal > 0 ? maxVal : -1;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis is not correct. `search([4L, 1L, 2L, 2L, 3L, 1L])` returns 2L as\
    \ it is twice in the array.\n<|/ c |>\n<| a |>\nHere is another solution that\
    \ returns the first element greater than zero that has a frequency greater than\
    \ or equal to the value of the first element in the array\n<code>\npublic static\
    \ int search(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n      \
    \  int freq = Collections.frequency(arr, arr[i]);\n        if (freq >= arr[i])\
    \ {\n            return i;\n        }\n    }\n    return -1;\n}\n</code>\n<|/\
    \ a tags=sorting,arrays dscore=2 |>\n<| a tags=sorting,arrays |>\n<code>\npublic\
    \ int search(int[] arr) {\n   int max = 0;\n   for (int i = 1, max = arr[0]; i\
    \ < arr.length; i++){\n       if (max < arr[i])\n           max = arr[i];\n  \
    \     if (max >= arr[i])\n           return i;\n   }\n   return -1;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 tags=sorting,arrays |>\nThis code will give you\
    \ the index of element in the array if exists or -1 if doesn't exist\n<code>\n\
    public int search(int[] arr) {\n    int index = 0;\n    for (int i = 1; i < arr.length;\
    \ i++) {\n        if(arr[i] > arr[i-1]) {\n            index = i;\n        }\n\
    \    }\n    return index != -1 ? index : -1;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I think you meant `arr[i] > arr[i-1]`\n<|/ c |>\n<| c |>\nYes, you are right.\
    \ Thanks. I was just corrected it :)\n<|/ c |>\n<| a |>\n<code>\n//Java\nclass\
    \ Arrays\n{\n    public static int search(int[] arr) {\n        Arrays.sort(arr);\n\
    \        for (int i = arr.length - 1; i >= 0; i--) {\n            if (arr[i] >\
    \ arr[i + 1]) {\n                return arr[i];\n            }\n        }\n  \
    \      return -1;\n    }\n}", "{\n    long result = -1L;\n    for(long i = 1;\
    \ i < lst.Length; i++)\n    {\n        if(lst[i] + 1 >= lst[result])\n       \
    \ {\n            result = i;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 tags=search,c#,algorithm |>\n<| c |>\nYour code is O(n^2), but\
    \ you already know that it can not be done with O(n).\n<|/ c |>\n<| a |>\n<code>\n\
    // C# Program to find the largest palindrome in a given range", "{\n    long maxV\
    \ = lst[0];\n    long freq[lst.length];\n    for (int i = 0; i < lst.length; ++i)\
    \ freq[i] = 0L;\n    for (int i : lst) freq[i - 1] += i;\n    long ans = -1L;\n\
    \    for (int i = 1; i < freq.length; ++i) \n        if (freq[i] >= freq[ans]\
    \ || freq[i] == 0L) ans = i;\n    return ans;\n}\n</code>\n<|/ a tags=arrays,algorithm,sorting\
    \ |>\n<| c |>\nThank you very much for the response. My question was more towards\
    \ how you would go about solving this problem as I am not too good at coding and\
    \ was having a hard time understanding it.\n<|/ c |>\n<| c |>\nHi again, I'm sorry\
    \ to bother you again. I ran the code and it seems okay at first glance, but when\
    \ I run it with larger arrays it doesn't return anything. I am guessing this is\
    \ because I made an issue with my array? Any suggestions? Thanks again for the\
    \ help and quick response.\n<|/ c |>\n<| c |>\nHow big is the array you give it?\
    \ For your test case, the code runs instantly. Can you give an example of a larger\
    \ array that doesn't work?\n<|/ c |>\n<| c |>\n[1L, 2L, 3L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L, 1L, 1L, ", "{\n    int  max;\n    int  freq;\n    long val;", "{\n    long\
    \ max = 0; // the value of max and count are both 0.\n    long count = 0; // the\
    \ number of times the max number occurs\n    foreach (long i in lst) \n    {\n\
    \        if (i >= 0) // don't need to do anything for negative numbers\n     \
    \   {\n            if (max < 0) // no count is needed\n            {\n       \
    \         max = i; \n                count = 1; \n            }\n            else\n\
    \            {\n                if (i > max) // a new max is found\n         \
    \       {\n                    max = i;\n                    count = 1;\n    \
    \            }\n                else // a repeated max is found\n            \
    \    {\n                    count++; \n                }\n            }\n    \
    \    }\n        else\n        {\n            return -1;\n        }\n    }\n  \
    \  return max;\n}\n</code>\n<|/ a tags=search,arrays,c# dscore=0 |>\n<| a |>\n\
    <code>\n    public long Search(int[] input)\n    {\n        var result = new Dictionary<long,\
    \ int>();\n        var max = -1;\n        foreach (var number in input)\n    \
    \    {\n            if (result.ContainsKey(number))\n            {\n         \
    \       result[number]++;\n                if (result[number] > max)\n       \
    \         {\n                    max = result[number];\n                }\n  \
    \          }\n            else\n            {\n                result.Add(number,\
    \ 1);\n                if (result[1] > max)\n                {\n             \
    \       max = result[1];\n                }\n            }\n        }\n      \
    \  return max < 0 ? -1 : max;\n    }\n</code>\n<|/ a tags=search,arrays,c# dscore=0\
    \ |>\n<| a |>\n<code>\nvar result = _myArray\n  .GroupBy(x => x)\n  .ToLookup(x\
    \ => x.Key, x => x.Count())\n  .OrderByDescending(x => x.Value).FirstOrDefault()\n\
    \  .Key;\n</code>\n<|/ a dscore=0 tags=search,arrays,c# |>\n<| a |>\n<code>",
  "{\n    long max = 0; \n    long frequency = 0;\n    \n    for (int i=0; i<lst.length;\
    \ i++) \n    {\n        if (lst[i] > max) \n        {\n            max = lst[i];\n\
    \            frequency = 1;\n        }\n        else if (lst[i] == max) \n   \
    \     {\n            frequency += 1;\n        }\n        else\n        {\n   \
    \         frequency = -1;\n            break;\n        }\n    }\n    return frequency;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\npublic static int search(int[]\
    \ arr, int val) \n{\n    int maxIndex = 0;\n    int currentIndex = 0;\n    int\
    \ maxVal = Integer.MIN_VALUE;\n    for(int i = 1; i < arr.length; i++)\n    {\n\
    \        if(arr[i] == val)\n        {\n            if(val > maxVal)\n        \
    \    {\n                maxVal = val;\n                maxIndex = i;\n       \
    \     }\n        }\n        else\n        {\n            if(arr[i] > maxVal)\n\
    \            {\n                maxVal = arr[i];\n                maxIndex = i;\n\
    \            }\n        }\n    }\n    return maxIndex;\n}\n</code>\n<|/ a tags=arrays,algorithm,java\
    \ |>\n<| a dscore=0 |>\nHere is my solution:\n<code>\npublic class MyClass\n{\n\
    \    public static void main(String[] args)\n    {\n        int[] numbers = {1,\
    \ 2, 3, 4, 5};\n        int maxValue = search(numbers, 4);\n        if(maxValue\
    \ > 0)\n            System.out.println(\"The max number is \" + maxValue);\n \
    \       else\n            System.out.println(\"There is no such number\");\n \
    \   }", "{\n    if(lst.Length <= 1) return -1L;\n    long max = 0;\n    foreach(long\
    \ i in lst)\n    {\n        if(i ==  max) return i;\n        max = max(max, i);\n\
    \    }\n    return max;\n}\n</code>\n<|/ a tags=c# |>\n<| a dscore=2 |>\nThe simple\
    \ solution is:\n<code>\n public static int Search(List<int> list)\n {\n      \
    \  int max = 0;\n        foreach (int i in list)\n        {\n            if (i\
    \ == max)\n            {\n                return i;\n            }\n         \
    \   max = Math.Max(max, i);\n        }\n        return -1;\n    }\n</code>\n<|/\
    \ a tags=c# |>\n<| a tags=c# |>\nYou don't need any extra libraries.\n<code>\n\
    public int Search(int[] arr) {\n    int max = 0;\n    for(int i = 0; i < arr.Length;\
    \ i++) {\n        max = Math.Max(max, arr[i]);\n    }\n    return max;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nWhat if there are 2 or more integers with the same\
    \ max value?\n<|/ c |>\n<| a dscore=1 |>\n<code>", "{\n    long maxVal = -1;\n\
    \    long maxCount = 0;\n    int i, count = 0, val;\n    foreach (i, val) in lst\
    \ \n    {\n        if (val > 0)\n        {\n            count += val;\n      \
    \      if (count > maxCount)\n            {\n                maxCount = count;\n\
    \                maxVal = i;\n            }\n        }\n    }\n    return maxVal;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for me. Searching for [1L, 1L,\
    \ 1L, 2L, 2L] with your function produces -1 where it should be 2, which according\
    \ to your example is correct. The solution given by jlewis works for me though.\n\
    <|/ c |>\n<| c |>\nI believe that the solution that I posted also works. What\
    \ are you testing it with?\n<|/ c |>\n<| c |>\nI was testing it with the array\
    \ [1L, 1L, 1L, 2L, 2L] which should return 2 which it's not.\n<|/ c |>\n<| a |>\n\
    This algorithm searches an array and returns the index of the first element with\
    \ frequency greater than or equal to the element.\n<code>\npublic static int search(int[]\
    \ arr, int elm) {\n    int i, count = 0;\n    int max = -1;\n    for (i = 0; i\
    \ < arr.length; i++) {\n        if (arr[i] >= elm) {\n            count++;\n \
    \           if (count > max) {\n                max = count;\n               \
    \ max = i;\n            }\n        }\n    }\n    return max;\n}\n</code>\n<|/\
    \ a tags=c#,arrays dscore=0 |>\n<| a dscore=0 |>\n<code>", "{\n    /*\n      \
    \  Your code here\n    */\n    for(int i = 0; i< lst.Length; i++)\n    {\n   \
    \     for(int j=0; j < lst.Length; j++)\n        {\n            if(lst[i] + lst[j]\
    \ == 0)\n            {\n                return -1;\n            }\n        }\n\
    \    }\n    \n    return lst[0];\n}\n</code>\n<|/ a |>\n<| c |>\nWhy don't you\
    \ use ArrayList instead of an array? That will make the code a lot more simple.\
    \ Also you can optimize your search code a bit by doing it only once outside the\
    \ for loops.\n<|/ c |>\n<| c |>\nBecause the OP specifically said that the size\
    \ of an array is unknown.\n<|/ c |>\n<| c |>\nIf you use ArrayLists then you do\
    \ not need any loops at all. And the size of a list does not affect its performance.\n\
    <|/ c |>\n<| c |>\n: I agree that the size of the list should not affect its performance.\
    \ But the OP said that the size was unknown, which means he would have to dynamically\
    \ allocate it, which would be a lot of extra code. The point is that we should\
    \ not waste our time trying to optimize something that does not matter, instead\
    \ we should optimize what does matter.\n<|/ c |>\n<| c |>\nI think this can be\
    \ done even faster without recursion.\n<|/ c |>\n<| a tags=performance,algorithm,java,arrays\
    \ |>\n<code>\nimport java.util.Arrays;", "{\n    if (lst.length == 0)\n      \
    \  return -1;\n    long min = lst[0], max = 0;\n    for (int i = 1; i < lst.length;\
    \ i++)\n    {\n        long c = lst[i];\n        if (c == min)\n            max\
    \ = c;\n        else if (c < min)\n            min = c;\n        else if (c >\
    \ max)\n            max = c;\n    }\n    if (max == lst[0])\n        return min;\n\
    \    return -1;\n}\n</code>\n<|/ a dscore=3 tags=search,algorithm,arrays |>\n\
    <| a |>\n<code>\n#include <iostream>\nusing namespace std;", "{\n    for(int i\
    \ = 0; i< lst.Length; i++)\n    {\n        if (lst[i] > 0)\n        {\n      \
    \      int count = 0;\n            foreach (int item in lst)\n            {\n\
    \                if (item == lst[i])\n                {\n                    count\
    \ += 1;\n                }\n            }\n            if (count >= lst[i])\n\
    \            {\n                return lst[i];\n            }\n        }\n   \
    \ }\n    return -1L;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI have solved this\
    \ using Linq and lambda expressions. Please find the code below. It will give\
    \ the desired output. \n<code>\npublic class SearchForGreatestIntegerWithFrequency\n\
    {\n    public void SearchForGreatestIntegerWithFrequency(int[] arr)\n    {\n \
    \       int[] tempList = new int[arr.Length];", "{\n    long i, freq;", "{\n \
    \   long max = 0, cnt = 0;\n    for(int i : lst)\n    {\n        if(i>0 && i==lst[i])\
    \ cnt++;\n        else if(cnt==0)\n        {\n            max = i;\n         \
    \   cnt = 1;\n        }\n        else if(cnt==1)\n        {\n            if(max<i)\
    \ max = i;\n            else cnt = 1;\n        }\n        else if(cnt>=2) cnt++;\n\
    \    }\n    return max==0? -1: max;\n}\n</code>\n<|/ a tags=arrays,sorting,algorithm,java\
    \ dscore=1 |>\n<| c |>\nHi Hayes, thank you very much for that comment. I am still\
    \ learning and was wondering if there is any way to optimize this algorithm. Also\
    \ thanks for not downvoting. I apologize for my English.\n<|/ c |>\n<| a tags=arrays,sorting,algorithm,java\
    \ |>\nThis is my solution to the problem:\n<code>\npublic class Greatest {\n \
    \   public static int search(int[] arr) {\n        Arrays.sort(arr);\n       \
    \ int max = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if\
    \ (arr[i] >= max) {\n                max = arr[i];\n            }\n        }\n\
    \        int count = 0;\n        for (int i = 0; i < arr.length; i++) {\n    \
    \        if (arr[i] == max) {\n                count++;\n            }\n     \
    \   }\n        if (count == arr.length) return -1;\n        return max;\n    }\n\
    \    public static void main(String[] args) {\n        int[] arr = {4, 1, 2, 4,\
    \ 3, 1, 2};\n        System.out.println(search(arr));\n    }\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=arrays,sorting,algorithm,java dscore=0 |>\n<code>\n\
    import java.util.*;\nimport java.lang.*;\nimport java.io.*;", "{\n    long maxI\
    \ = std.arrayMin(lst);\n    long maxF = std.arrayMax(lst);\n    long result =\
    \ -1;", "{\n    std.collections.ArrayList <int> arr = new std.collections.ArrayList\
    \ <int> ();\n    foreach(long el, lst)\n        arr.Add(el);\n    long result\
    \ = -1;\n    int max = arr.Max();\n    int cur = max;\n    int cnt = 0;\n    int\
    \ i = 0;\n    while (i < arr.Count) {\n        if (arr.Get(i) == max) {\n    \
    \        cnt += arr.Get(i);\n            i++;\n        } else if (arr.Get(i) >\
    \ max) {\n            break;\n        } else if (arr.Get(i) == max) {\n      \
    \      cnt += arr.Get(i);\n        } else {\n            while (arr.Get(i) > 0)\
    \ {\n                cur--;\n                if (arr.Get(i) == cur) \n       \
    \             cnt++;\n            }\n            if (cnt > result) \n        \
    \        result = max;\n        }\n    }\n    return result;\n}\n</code>\n<|/\
    \ a dscore=1 tags=c# |>\n<| a dscore=1 |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;", "{\n    int lo = 0;\n    int hi = lst.length - 1;", "{\n\
    \    long max = lst[0];\n    int i = 0;\n    while(i<lst.length && max < lst[i])\n\
    \    {\n        max = lst[i];\n        i++;\n    }\n    if(i == lst.length)\n\
    \        return -1L;\n    long cnt = 0;\n    while(max < lst[i])\n    {\n    \
    \    max = lst[i];\n        cnt++;\n        i++;\n    }\n    return cnt;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=0 tags=c |>\nHere's my solution, which\
    \ is a bit more generic:\n<code>", "{\n    \n    int low = 0;\n    int high =\
    \ lst.length - 1;\n    int mid = 0;\n    long maxVal = lst[0];\n    int count\
    \ = 0;\n    \n    while (low <= high) {\n        mid = (low + high) / 2;\n   \
    \     \n        if (lst[mid] >= maxVal) {\n            count = count + 1;\n  \
    \          maxVal = lst[mid];\n        } else {\n            if (lst[mid] == maxVal)\
    \ {\n                count = count + 1;\n            }\n            high = mid\
    \ - 1;\n        }\n        if (mid == 0) {\n            break;\n        }\n  \
    \      if (lst[mid] <= maxVal) {\n            low = mid + 1;\n        }\n    }\n\
    \    \n    if (count > lst[high]) {\n        return -1;\n    } else {\n      \
    \  return maxVal;\n    }\n}\n/*", "{\n    // Write your code here.\n    long max=\
    \ -1, min= 0, freq=0;\n    for(long i:lst)\n    {\n       if(freq==0)\n      \
    \ {\n           max=i;\n           min=i;\n           freq++;\n       }\n    \
    \   if(i>max)\n       {\n           max=i;\n           min=i;\n       }\n    \
    \   if(i<min)\n       {\n           min=i;\n       }\n    }\n    if(max<=0)\n\
    \    {\n        return -1;\n    }\n    else\n    {\n        return max;\n    }\n\
    }", "{\n    int min = findMin(lst);\n    if (min == -1)\n        return -1;\n\
    \    return lst[min];\n}", "{\n    if (lst.length < 1)\n        return -1L;\n\
    \    long freq = 1;\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length;\
    \ i++) \n    {\n        if (lst[i] > max)\n            max = lst[i];\n       \
    \ else if (lst[i] == max)\n            freq++;\n    }\n    \n    return max ==\
    \ lst[0] ? -1 : max;\n}\n</code>\n<|/ a tags=java,search,arrays |>\n<| a tags=java,search,arrays\
    \ |>\n<code>\npublic int search(final int[] a) {\n    int max = 0;\n    int freq\
    \ = 0;\n    for (int i = 0; i < a.length; i++) {\n        if (max == a[i]) freq++;\n\
    \        else {\n            if (freq > max) {\n                max = freq;\n\
    \                freq = 0;\n            }\n        }\n    }\n    if (max >= a.length)\
    \ return -1;\n    return max;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=java,search,arrays\
    \ |>\nI think this code is a simple and very good solution:\n<code>\npublic int\
    \ search(final int[] arr) {", "{\n    long highestFrequency = -1, targetFrequency\
    \ = 0;\n    for(int i = 0; i < lst.Length; i++) {\n        if(lst[i] > 0) {\n\
    \            targetFrequency = lst[i];\n            if(highestFrequency < targetFrequency)\
    \ {\n                highestFrequency = targetFrequency;\n            }\n    \
    \    } else {\n            return -1;\n        }\n    }\n    return highestFrequency;\n\
    }\n/*", "{\n    long freq = -1;\n    int idx = -1;\n    for (int i = 0; i < lst.Length;\
    \ i++) \n    {\n        int val = lst[i];\n        if (val > freq)\n        {\n\
    \            freq = val;\n            idx = i;\n        }\n    }\n    return idx\
    \ >= 0 ? lst[idx] : -1;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nTry this simple\
    \ one-liner!\n<code>\npublic static int search(int[] array, int searchValue) {\n\
    \    return Array.FindIndex(array, x => x > searchValue) ? x : -1;\n}\n</code>\n\
    <|/ a tags=c#,arrays,integer dscore=0 |>\n<| c |>\nThat won't work because the\
    \ array is not sorted.\n<|/ c |>\n<| a tags=c#,arrays,integer dscore=0 |>\nThe\
    \ solution using LINQ:\n<code>\nvar result = array.OrderByDescending(x => x).Take(1).DefaultIfEmpty(-1).FirstOrDefault();\n\
    </code>\n<|/ a |>\n<| c |>\nThat won't work because the array is not sorted.\n\
    <|/ c |>\n<| c |>\nThis won't work if the original array contains negative values.\n\
    <|/ c |>\n<| c |>\nIf original array contains negative values then use OrderByDescending(x=>x).Take(1).DefaultIfEmpty(-1).FirstOrDefault();\n\
    <|/ c |>\n<| a |>\n<code>", "{\n    // write your code in C# 6.0 with .NET 4.5\
    \ (Mono)\n    return long.MaxValue;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\npublic class Frequency\n{\n    public static void Main(string[]\
    \ args)\n    {\n        int[] myNumbers = new int[] { 1, 1, 1, 2, 3, 4, 4, 4,\
    \ 4, 4, 5, 6, 7, 8, 8, 9, 10, 11, 12, 12, 12, 13, 14, 14, 14, 14, 14, 15, 16,\
    \ 17, 18 };\n        Console.WriteLine(\"Your number is: \" + SearchForMax(myNumbers,\
    \ 0));\n        Console.ReadKey();\n    }", "{\n    long result = -1L;\n    int\
    \ low = 0;\n    int high = lst.size - 1;\n    int freq = 0;\n    while(low <=\
    \ high)\n    {\n        int mid = low + high >> 1;\n        freq = std.array.frequency(lst,lst[mid]);\n\
    \        if(freq >= mid)\n        {\n            low = mid+1;\n        }\n   \
    \     else\n        {\n            high = mid - 1;\n        }\n    }\n    if(freq\
    \ > 0)\n        result = lst[low];\n    return result;\n}", "{\n    int i, count,\
    \ num = 0;", "{\n    int pos = 0, freq = 1;\n    for (int i : lst) {\n       \
    \ if (freq >= i) {\n            pos = i + 1;\n            freq--;\n        } else\
    \ {\n            freq++;\n        }\n    }\n    return pos == lst.length ? -1\
    \ : pos;\n}\n</code>\n<|/ a tags=java,algorithm,arrays,c++ dscore=2 |>\n<| a dscore=1\
    \ |>\nThis is not so difficult with linear time complexity.\nThe algorithm is:\n\
    <code>\nFor all input integers:\n  Sort them in descending order.\n  For every\
    \ i such that i < n:\n    Sort array from 0 to i (use Insertion sort).\n    Check\
    \ if first element of array is greater than 0.\n    If it is then return that\
    \ element as answer.\n</code>\nFor example for input [1, 2, 1, 4, 2]\n<code>\n\
    1-2-3-4\n ^\n i\n</code>\nSo we will have first element greater than 0 and the\
    \ array is sorted in descending order. Now the question is what is the next i\
    \ such that i < n and array[0] <= i or i < n-1.\nThe first element greater or\
    \ equal to i can have two possibilities, one the element that is greater than\
    \ i and the other is equal to i-1. So we will have to check for both of these\
    \ possibilities.\nFor the first element greater than i we will have to sort from\
    \ 0 to i (use Insertion sort).\n<code>\n1-2-3-4\n     ^\n     i\n</code>\nFor\
    \ the first element equal to i we will have to sort from 0 to n-1.\n<code>\n1-2-3-4\n\
    \     ^\n     i\n</code>\nThe complexity is O(n * log n)\n<|/ a tags=java,algorithm,arrays,c++\
    \ |>\n<| c |>\nCan you please explain it with an example?\n<|/ c |>\n<| c |>\n\
    The question is tagged `c++` so why are you suggesting `std::sort` ?\n<|/ c |>\n\
    <| c |>\n`std::sort` is C++ only.\n<|/ c |>\n<| c |>\n`std::sort` uses `qsort`\
    \ for std containers and `std::reverse` for `std::vector`.\n<|/ c |>\n<| a dscore=0\
    \ tags=java,algorithm,arrays,c++ |>\n<code>\nimport java.util.*;\npublic class\
    \ Test{\n    public static void main(String args[]){\n        int[] a = {4, 5,\
    \ 6, 1, 2, 2, 3, 4};\n        System.out.println(Arrays.toString(findNum(a)));\n\
    \    }\n    public static int[] findNum(int[] a){\n        int maxNum = ", "{\n\
    \tlong maxVal=0;\n\tlong minVal=lst[0]; \n\tint count=0;\n\tfor(int i=1; i<lst.len;\
    \ i++) \n\t{\n\t\tif(lst[i]>=minVal)\n\t\t{\n\t\t\tcount++;\n\t\t\tmaxVal=maxVal*(count-1)+lst[i];\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tcount++;\n\t\t\tminVal=lst[i];\n\t\t}\n\t}\n\tif(count>lst.len)\
    \ \n\t{\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\treturn maxVal;\n\t}\n}", "{\n \
    \   // write your code in C# 6.0 with .NET 4.5 (Mono)\n    long result = -1;\n\
    \    long maxValue = long.MaxValue;", "{\n    long max_element = 0;\n    long\
    \ max_freq = 0;\n    for(long i = 0; i < lst.length; i++)\n    {\n        long\
    \ freq = lst[i];\n        if(freq >= max_freq) continue;\n        if(freq > max_freq)\
    \ \n        {\n            max_element = i;\n            max_freq = freq;\n  \
    \      }\n    }\n    if(max_freq > lst[max_element])\n        return -1;\n   \
    \ return max_element;\n}", "{\n    int count = 0;\n    for(int i = 0; i < lst.Length;\
    \ i++)\n    {\n        if(lst[i] > 0)\n        {\n            count++;\n     \
    \       if(lst[i] == lst[count])\n                count++;\n        }\n    }\n\
    \    if(count > 0)\n        return lst[count - 1];\n    return -1;\n}\n</code>\n\
    <|/ a dscore=0 tags=arrays,c#,search,algorithm |>\n<| c |>\nWhile this code may\
    \ answer the question, providing additional context regarding why and/or how this\
    \ code answers the question improves its long-term value.\n<|/ c |>\n<| a tags=arrays,c#,search,algorithm\
    \ dscore=0 |>\n<code>\npublic class Solution {\n    public int Search(string input,\
    \ int[] inputArray) {\n        var search = new List<int>();\n        int cnt\
    \ = 0;\n        foreach (var item in inputArray.OrderByDescending(x=>x)) {\n \
    \           if (search.Count > 0 && (search.Last() == item)) {\n             \
    \   cnt = search.Last();\n                search.RemoveAt(search.Count - 1);\n\
    \            }\n            if (cnt > 0) {\n                cnt++;\n         \
    \       if (item > 0 && item <= cnt)\n                    return item;\n     \
    \       }\n            search.Add(item);\n        }\n        return -1;\n    }\n\
    }\n</code>\n<|/ a |>\n<| a |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;", "{\n    long maxval = lst[0];\n    long\
    \ cnt = 0;\n    for( int i = 1; i < lst.Length; i++ ) {\n        long val = lst[i];\n\
    \        long newcnt = cnt + 1;\n        long newval = val + val;\n        if(\
    \ newcnt > maxval || newval > maxval ) {\n            maxval = newval;\n     \
    \       cnt = newcnt;\n        }\n    }\n    if( cnt > maxval )\n        return\
    \ -1L;\n    return maxval;\n}\n</code>\n<|/ a tags=algorithm,arrays,c# dscore=0\
    \ |>\n<| c |>\nThanks for this. However, how would you go about making it case\
    \ insensitive? I have been trying to figure it out but I haven't been able to\
    \ come up with a solution yet.\n<|/ c |>\n<| c |>\n: Just add a case insensitive\
    \ string comparison: `if( (newcnt == maxval || newval == maxval) && newval.Equals(maxval,\
    \ StringComparison.CurrentCultureIgnoreCase) ) return -1L;` If you need further\
    \ explanation, please ask a new question and explain the problem in more detail.\n\
    <|/ c |>\n<| a tags=algorithm,arrays,c# dscore=0 |>\n<code>\n    public class\
    \ Program\n    {\n        public static void Main(string[] args)\n        {\n\
    \            Console.WriteLine(search([1, 2, 3, 2, 3]));\n            Console.WriteLine(search([3,\
    \ 2, 1, 2, 3]));\n            Console.WriteLine(search([1, 2, 3, 4, 5]))\n   \
    \     }\n        public static long search(int[] arr)\n        {\n           \
    \ long max = 0;\n            long min = 0;\n            foreach(int item in arr)\n\
    \            {\n                if (arr[item] < min)\n                    min\
    \ = arr[item];\n                if (arr[item] > max)\n                    max\
    \ = arr[item];\n            }\n            if (max >= min)\n            {\n  \
    \              return -1;\n            }\n            int index = -1;\n      \
    \      for (int i = 1; i < arr.Length; i++)\n            {\n                if\
    \ (arr[index] < arr[i])\n                    index = i;\n            }\n     \
    \       if (index > 0)\n            {\n                long left = max - arr[index\
    \ - 1];\n                long right = arr[index] - max;\n                if (right\
    \ >= left || left == 0 && arr.Length < 3)\n                    return -1;\n  \
    \              else\n                    return arr[arr.Length - index - 1];\n\
    \            }\n            return -1;\n        }\n    }\n</code>\n<|/ a |>\n\
    <| a tags=algorithm,arrays,c# |>\n<code>\npublic static long search(int[] arr)\n\
    {\n    long max = 0;\n    long min = 0;\n    long count = 1;\n    for (int i =\
    \ 1; i < arr.Length; i++)\n    {\n        if (arr[i] > max)\n        {\n", "{\n\
    \    int max = 1;\n    long freq = 0;\n    for (int i = 0; i <lst.Length; i++)\n\
    \    {\n        freq = lst[i]; \n        max = Math.Max(max, freq);\n    }", "{\n\
    \    long low = 0, high = lst.length-1;\n    while(low < high)\n    {\n      \
    \  int mid = (low+high)/2;\n        if(lst[mid] > 0)\n            high = mid-1;\n\
    \        else if(lst[mid] < 0)\n            low = mid+1;\n        else\n     \
    \   {\n            return mid;\n        }\n    }\n    return -1;\n}\n</code>\n\
    <|/ a tags=c,arrays,binary-search,binary-search-tree,search |>\n<| c |>\nPlease\
    \ explain what this code does.\n<|/ c |>\n<| c |>\nThis does not answer the question.\
    \ It just uses a different approach. Besides, it would be better if you could\
    \ explain how the original code works.\n<|/ c |>\n<| c |>\nThe code is simple\
    \ and understandable. Its performance is not that good. I tried some code and\
    \ it doesn't give the right answer but works perfectly fine.\n<|/ c |>\n<| c |>\n\
    I agree, this approach is good but not for the problem.\n<|/ c |>\n<| c |>\nThe\
    \ code fails on `search([4, 2, 1, 2])`. The result is supposed to be `3` but the\
    \ result is `4`.\n<|/ c |>\n<| a tags=c,arrays,binary-search,binary-search-tree,search\
    \ |>\n<code>\n#include <iostream>\nusing namespace std;", "{\n    int[] dp = new\
    \ int[std.array.max(lst) + 1];\n    for(int i : lst)\n        dp[i] += 1;", "{\n\
    \    long maxval = -1;\n    long freq = -1;\n    long max = -1;\n    \n    for(int\
    \ i = 0; i < lst.length; i++) \n    {\n        if(lst[i] > 0)\n        {\n   \
    \         freq = freq + 1;\n            if(max < freq)\n            {\n      \
    \          maxval = lst[i];\n                max = freq;\n            }\n    \
    \    }\n    }\n    return maxval;\n}", "{\n    long freq[] = new long[std.length(lst)];\n\
    \    int i, max_val, idx = 0, min_val = std.min_index(lst);\n    bool exists =\
    \ false;\n    long max_val = lst[0];\n    for(i = 0; i < std.length(lst); ++i)\n\
    \    {\n        freq[idx++] = lst[i];\n        if(lst[i] > max_val)\n        {\n\
    \            max_val = lst[i];\n            max_idx = idx-1;\n        }\n    \
    \    if(lst[i] == min_val)\n            exists = true;\n    }\n    if(!exists)\
    \ return -1;\n    for(i = 0; i < max_idx; ++i)\n    {\n        if(freq[i] >= freq[max_idx])\n\
    \        {\n            if(freq[i] > freq[max_idx])\n            {\n         \
    \       max_val = max_idx;\n                max_idx = i;\n            }\n    \
    \    }\n    }\n    return max_val;\n}\n\"\"\")\n</cell>\n<cell>\n# Check your\
    \ solution manually\nsearch([2, 1, 2, 3, 1]) == 3\n</cell>\n<text>\nBinary Search\n\
    The search algorithm you just implemented is a binary search. This algorithm has\
    \ O(log n) average complexity, and O(log n) worst-case complexity in the worst\
    \ cases (where we can't determine that the element doesn't exist in the list).",
  "{\n    bool hasValue = false;\n    long max = 0;\n    int freq = 0;\n    \n   \
    \ int size = lst.size();\n    int i;\n    \n    for(i = 0; i < size; ++i) \n \
    \   {\n        if(lst[i] > 0 && lst[i] <= max)\n        {\n            hasValue\
    \ = true;\n            max = lst[i];\n            freq = i + 1;\n        }\n \
    \   }\n    \n    if(!hasValue)\n        return -1;\n    else\n    {\n        if(freq\
    \ == max)\n            return lst[freq];\n        else\n            return -1;\n\
    \    }\n}", "{\n\tlong max;\n\t\n\tif (lst == null || lst.length < 0) \n\t\treturn\
    \ -1;\n\tmax = lst[0];\n\t\n\tfor (int i = 1; i < lst.length; i++) \n\t{\n\t\t\
    if (lst[i] > max) \n\t\t{\n\t\t\tmax = lst[i];\n\t\t}\n\t}\n\treturn max;\n}",
  "{\n    int maxIndex = 0;\n    int maxValue = lst[0];\n    for(int i=1; i<lst.length;\
    \ i++){\n        if(lst[i] > maxValue){\n            maxValue = lst[i];\n    \
    \        maxIndex = i;\n        }\n    }\n    return maxIndex;\n}\n</code>\n<|/\
    \ a tags=arrays,c,search,algorithm |>\n<| c |>\nWhile this code may solve the\
    \ question, [including an explanation](//meta.stackexchange.com/q/114762) of how\
    \ and why this solves the problem would really help to improve the quality of\
    \ your post, and probably result in more up-votes. Remember that you are answering\
    \ the question for readers in the future, not just the person asking now. Please\
    \ [edit] your answer to add explanations and give an indication of what limitations\
    \ and assumptions apply.\n<|/ c |>\n<| c |>\nThe code has two problems: 1) it\
    \ will return wrong result if all elements are equal. It will return the index\
    \ of the first element that is greater that maxValue. 2) the complexity is O(N),\
    \ even if we could find out how many times each value is repeated.\n<|/ c |>\n\
    <| c |>\nYes, you are absolutely right. I updated my answer to fix those 2 problems.\n\
    <|/ c |>\n<| a dscore=3 tags=arrays,c,search,algorithm |>\n<code>", "{\n    int\
    \ i, max_frequency, freq;\n    freq = 0;\n    max_frequency = 0;\n    for (i =\
    \ 0; i < lst.Length; i++) {\n        freq = GetFreq(lst[i]);\n        if (freq\
    \ >= max_frequency) {\n            max_frequency = freq;\n        }\n    }\n \
    \   return -1L;\n}", "{\n    if( lst.isEmpty() ) return -1;\n    long max = lst.peek();\
    \ \n    long max2 = lst.peek(); \n    for(long i = 0; i < lst.length; ++i ) {\n\
    \        long num = lst[i];\n        if( num == max ) {\n            if( num >\
    \ max2 ) return num;\n            max2 = max;\n            max = num;\n      \
    \  }\n        else if( num > max ) {\n            max2 = max;\n            max\
    \ = num;\n        }\n    }\n    return max2;\n}\n</code>\n<|/ a dscore=0 tags=c++,arrays,algorithm,sorting\
    \ |>\n<| a dscore=0 tags=c++,arrays,algorithm,sorting |>\nI have solved it in\
    \ O(n) time complexity using Dynamic Programming \n<code>\n #include <bits/stdc++.h>",
  "{\n    long m = Long.MAX_VALUE;\n    long maxFreq = -1;\n    for(int i=0; i<lst.size();\
    \ i++){\n        long curr = lst[i];\n        long currFreq = map(curr, 1, lst,\
    \ 0);\n        if(currFreq > m)\n            m = currFreq;\n        if(currFreq\
    \ >= maxFreq){\n            maxFreq = currFreq;\n        }\n    }\n    return\
    \ maxFreq;\n}", "{\n\tint m = lst.Length;\n\tint n = lst.Length;\n\tfor (int i\
    \ = 0; i < m; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\tif (lst[j]\
    \ >= lst[i]) return lst[i];\n\t\t}\n\t}\n\treturn -1;\n}\n</code>\n<|/ a tags=java,arrays,algorithm\
    \ dscore=0 |>\n<| a tags=java,arrays,algorithm |>\nThe first solution is a O(n)\
    \ solution, whereas the second solution is O(n*log(n)). \n<code>\nlong search(int[]\
    \ arr) {\n    int pos = 0;\n    for (int i = 0; i < arr.length; i++) {\n     \
    \   int num = arr[i];\n        for (int j = pos; j < arr.length; j++) {\n    \
    \        int x = arr[j];\n            if (x == num) {\n                pos = j;\n\
    \                break;\n            }\n        }\n    }\n    return pos;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nHere is simple java 8 solution\n\
    <code>\nstatic long search(int[] arr) {\n    int firstEle = Collections.frequency(arr,\
    \ arr[0]);\n    return IntStream.range(0, arr.length)\n            .filter(i ->\
    \ arr[i] == firstEle)\n            .max(Comparator.comparingInt(a -> arr[i]))\n\
    \            .orElse(-1);\n}\n</code>\n<|/ a tags=java,arrays,algorithm |>\n<|\
    \ a |>\nIn one line:\n<code>\nimport java.util.Arrays;", "{\n    long best= lst[0];\n\
    \    int min= 0, max= 0, cnt=0;\n    for (int i = 1; i < lst.length; i++)\n  \
    \  {\n        if (lst[i] == best)\n        {\n            cnt ++;\n        }\n\
    \        else if (lst[i] > best)\n        {\n            best = lst[i];\n    \
    \        min = i;\n        }\n        else if (lst[i] < best)\n        {\n   \
    \         max = i;\n        }\n    }\n    return cnt >= min ? best: -1;\n}", "{\n\
    \    if (lst.empty())\n        return -1;\n    long maxValue = 0;\n    long maxFreq\
    \ = 0;\n    long curValue = lst[0];\n    long curFreq = 0;\n    foreach(long ele,\
    \ lst)\n    {\n        curFreq++;\n        if (curFreq > maxFreq)\n        {\n\
    \            if (curFreq > maxFreq)\n            {\n                maxFreq =\
    \ curFreq;\n                maxValue = curValue;\n            }\n        }\n \
    \       curValue = ele;\n    }\n    return maxValue;\n}", "{\n    long freq, i,\
    \ max = -1;\n    freq = -1;\n    for (i = 0; i < lst.length; i++) {\n        /*if\
    \ (lst[i] > 0) {\n            freq++;\n        }*/\n        if (lst[i] > freq)\
    \ {\n            max = lst[i];\n            freq = lst[i];\n        }\n    }\n\
    \    return max;\n}\n</code>\n<|/ a dscore=0 tags=c# |>\n<| c |>\nI don't think\
    \ that this algorithm can work correctly. Please try it on your example array.\
    \ I get `-2L` which is not what OP expects.\n<|/ c |>\n<| c |>\n`-2L` means that\
    \ there are no frequencies above `-2`. Your code assumes that `-1` appears at\
    \ least once. That is not correct. Your code just assumes that there is at least\
    \ one `0`.\n<|/ c |>\n<| c |>\nI fixed the issue, thank you for the heads up.\n\
    <|/ c |>\n<| c |>\nThis is wrong. It assumes that there are at least one `0`.\
    \ It does not check that the frequency of the array is greater than or equal to\
    \ the frequency of `0`. Try `search([4L, 1L, 2L, 2L, 3L, 1L]);`. Your code returns\
    \ `3L` which is wrong.\n<|/ c |>\n<| c |>\nThank you for the heads up! I fixed\
    \ my answer, this was my first answer on SO.\n<|/ c |>\n<| a dscore=0 |>\nOk here\
    \ is my solution, I think it is pretty straightforward. I am not sure how it will\
    \ perform on large arrays and I still have some questions.\n<code>\nprivate static\
    \ int search(int[] arr)\n{\n    int maxVal = -1;\n    int maxCount = 0;", "{\n\
    \    if(lst.size() == 0) return -1L;\n    \n    int high = lst.size() - 1;\n \
    \   int freq = 0;\n    int index = 0;", "{\n    long ans = 0;\n    int i = 0,\
    \ j = 0, k;\n    for(int k = 0; k < lst.length; k++){\n        while(j<lst.length\
    \ && lst[j] == lst[i]){\n            ans = lst[i];\n            j = j + 1;\n \
    \           i = i + 1;\n        }\n        j = k + 1;\n        i = k + 1;\n  \
    \  }\n    return ans;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe complexity\
    \ is `O(n*n)` since `j` is set back to 0 in every loop. Also, `i` and `k` should\
    \ be set back to 0 at the start of the function anyway. So, `O(n^2)` overall.\
    \ Also, the `while` loop can always be rewritten as an `if` statement, and the\
    \ code should be better than this.\n<|/ c |>\n<| c |>\nThe complexity is O(n^2)\
    \ because of the nested while loops. Also, i and k should be set to 0 at the start\
    \ of each function, otherwise if there are several runs of the function, the value\
    \ of k is incorrect and will be incremented several times. Finally, the while\
    \ loop can be rewritten as an if statement as you say.\n<|/ c |>\n<| a dscore=0\
    \ tags=search,algorithm,java |>\n<code>\n// Java program\n// Finding most frequent\
    \ integer in a given array\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;",
  "{\n    long x = 0;\n    long maxFreq = 0;\n    int maxCount = -1;", "{\n    if(lst.length\
    \ == 0)\n        return -1;\n    \n    long greatest = lst[0];\n    int counter\
    \ = 1;\n    \n    for(int i = 1; i < lst.length; i++)\n    {\n        if(lst[i]\
    \ > greatest)\n        {\n            counter = 1;\n            greatest = lst[i];\n\
    \        }\n        else if(lst[i] == greatest)\n        {\n            counter++;\n\
    \        }\n    }\n    \n    if(counter == 1)\n        return greatest;\n    \n\
    \    return -1;\n}", "{\n    long max= std.math.max(lst);\n    long freq= 0;\n\
    \    foreach(long x, lst) \n    {\n        if(x==max)\n        {\n           \
    \ freq++;\n        }\n    }\n    return std.math.max(freq,-1);\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nthis solution does not account for zero occurrences of any number.\n\
    <|/ c |>\n<| c |>\nthe original question doesn't say anything about zero occurrences.\
    \ If you don't care about that then you could use `return lst.reduce((prev, curr)\
    \ => max(freq, curr) > prev ? max(freq, curr) : prev);`\n<|/ c |>\n<| c |>\nthat\
    \ would not work if `lst = [1, 2]`\n<|/ c |>\n<| c |>\n, thanks for pointing out.\
    \ I missed that. Let me fix it.\n<|/ c |>\n<| c |>\nYour answer does work. I would\
    \ edit it to replace \"max\" with \"Math.max\", but the edit is too small for\
    \ a comment.\n<|/ c |>\n<| a |>\nThis also works, although it looks more confusing.\
    \ \n<code>\nlong search(int[] lst) {\n    int max = 0;\n    int freq = 0;\n  \
    \  for (int i = 0; i < lst.length; i++) {\n        if(lst[i] == max) {\n     \
    \       freq++;\n        }\n    }\n    return freq == 0 ? -1 : max;\n}\n</code>\n\
    <|/ a tags=java dscore=2 |>\n<| c |>\nYou might want to rethink what you are returning:\
    \ if `lst` is `[3, 2, 2, 2, 2, 2, 3]` then your code will return `2`, but OP's\
    \ code will return `-1`. Also this does not work for `lst = [4, 2, 2, 2, 3]`,\
    \ which would return `2` for `[3, 2, 2, 2, 2, 2, 3]`\n<|/ c |>\n<| a dscore=2\
    \ |>\nThe most concise answer I can find is this:\n<code>\npublic static int search(final\
    \ int[] lst) {\n    return lst.reduce(Math.max(lst[0]), (a, b) -> Math.max(Math.max(a,\
    \ b), lst[1]));\n}\n</code>\n<|/ a tags=java |>\n<| c |>\nI used Math.max(a, b),\
    \ because if a is greater than b, then b is the one that should be returned for\
    \ a. The one returned by Math.max(lst[1], lst[0]) would be the one that should\
    \ be returned for max(a, b).\n<|/ c |>\n<| c |>\nI guess I don't understand why\
    \ `Math.max(Math.max(a,b), lst[1])` should only be evaluated once and why `Math.max(a,b)`\
    \ is evaluated twice.\n", "{\n    int i,j;\n    long min=0,temp;\n    for(i=0;i<lst.size();i++){\n\
    \        min=lst[i];\n        for(j=i+1;j<lst.size();j++){\n            if(lst[j]<min){\n\
    \                min=lst[j];\n            }\n        }\n        if(min!=lst[i]){\n\
    \            temp=min;\n            min=lst[i];\n            lst[i]=temp;\n  \
    \      }\n    }\n    return lst[lst.size()-1];\n}", "{\n    if(lst.Length > 0)\n\
    \    {\n        long[] num = new long[lst.Length];\n        for(int i = 0; i <=\
    \ lst.Length; i++)\n        {\n            if(num[lst.Length - 1 - i] == lst[i])\n\
    \            {\n                num[lst.Length - 1 - i] = -1;\n              \
    \  return lst.Length - 1 - i;\n            }\n        }\n        return -1;\n\
    \    }\n    return -1;\n}\n</code>\n<|/ a |>\n<| c |>\nThis solution doesn't satisfy\
    \ the requirement that the array be sorted. Also it requires creation of temporary\
    \ arrays so it's slower than the other solutions.\n<|/ c |>\n<| a |>\nYou could\
    \ use a hash set. This would be more efficient than a linear search as you are\
    \ only looking for the first occurrence of a number in the array:\n<code>\nHashSet<int>\
    \ nums = new HashSet<int>();", "{\n    // write your code in Java here.\n    std.array.sort(lst);\n\
    \    long maxIndex = 0;\n    for(int i = lst.length - 1; i >= 0; i--)\n    {\n\
    \        if(lst[i] == lst[maxIndex] && maxIndex != 0)\n        {\n           \
    \ maxIndex--;\n        }\n        else if(lst[i] != lst[maxIndex] && maxIndex\
    \ != 0)\n        {\n            maxIndex++;\n        }\n        else if(lst[i]\
    \ == lst[maxIndex] && maxIndex == 0)\n        {\n            return lst[i];\n\
    \        }\n        else if(lst[i] != lst[maxIndex] && maxIndex == 0)\n      \
    \  {\n            maxIndex--;\n        }\n    }\n    return -1;\n}\n</code>\n\
    <|/ a tags=java,arrays,algorithm dscore=1 |>\n<| c |>\nThis is incorrect because\
    \ you didn't consider that `search([4L, 1L, 2L, 2L, 3L, 1L])` returns `2L` instead\
    \ of `3L`.\n<|/ c |>\n<| c |>\nThe question clearly states return -1 if no such\
    \ value exists\n<|/ c |>\n<| a |>\nThis is a recursive solution and will return\
    \ the maximum number in the array.\nThe complexity will be O(n).\n<code>\nimport\
    \ java.util.*;", "{\n    long greatest = 0;\n    long freq = 0;\n    for (long\
    \ i : lst) {\n        freq += i;\n        if (freq > greatest) {\n           \
    \ greatest = freq;\n        }\n    }\n    if (greatest == 0) {\n        return\
    \ -1;\n    }\n    return greatest;\n}\n</code>\n<|/ a tags=java,performance,time-complexity,algorithm\
    \ dscore=2 |>\n<| a dscore=1 tags=java,performance,time-complexity,algorithm |>\n\
    As already suggested in other answer, I suggest this simple approach: Use a Map\
    \ to store frequencies of each element. \nThen iterate over all elements and choose\
    \ the element which has the highest frequency.\nThe running time would be O(n).\n\
    <|/ a |>\n<| a dscore=0 tags=java,performance,time-complexity,algorithm |>\nO(n)\
    \ approach: \n<code>\npublic class FindGreatestFrequency{\n    static int maxFrequency\
    \ = 0;\n    public static void main(String args[]){\n        int[] arr = new int[]\
    \ {4L, 1L, 2L, 2L, 3L, 1L};\n        findGreatestFrequency(arr);\n    }", "{\n\
    \tint pos = 0;\n\tlong min = lst[0];\n\tlong max = lst[0];\n\tfor(int i = 1; i\
    \ < lst.Length; i++)\n\t{\n\t\tif(lst[i] < min)\n\t\t\tmin = lst[i];\n\t\telse\
    \ if(lst[i] > max)\n\t\t\tmax = lst[i];\n\t}\n\twhile(pos < lst.Length && lst[pos]\
    \ == max)\n\t{\n\t\tpos++;\n\t}\n\tif(pos == lst.Length)\n\t\treturn -1;\n\tlong\
    \ mid = lst[pos];\n\twhile(pos < lst.Length && lst[pos] < mid)\n\t{\n\t\tpos++;\n\
    \t}\n\twhile(pos < lst.Length && lst[pos] > mid)\n\t{\n\t\tpos++;\n\t}\n\twhile(pos\
    \ > 0)\n\t{\n\t\tlst[--pos] = lst[pos];\n\t}\n\tlst[pos] = max;\n\treturn min;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 tags=c#,algorithm |>\nA solution\
    \ I came up with that should be O(N) where N is the length of the list:\n<code>\n\
    static long search(long[] lst)\n{\n    if (lst.Length == 0)\n        return -1;",
  "{\n    int n=lst.Length;\n    if (n==0) \n        return -1L;\n    Dictionary<long,\
    \ int> dic = new Dictionary<long, int>();\n    for(int i=0;i<n;i++) \n    {\n\
    \        int counter = dic[lst[i]];\n        dic[lst[i]] = ++counter;\n      \
    \  if (counter > lst.Length) \n            return -1L;\n    }\n    long max=0L;\n\
    \    int j=0;\n    foreach (long k,dic.Keys)\n    {\n        if (k<max) continue;\n\
    \        j++;\n        if (j>n) break;\n        if (dic[k]==lst.Length) \n   \
    \     {\n            max = k;\n            break;\n        }\n    }\n    return\
    \ max;\n}\n</code>\n<|/ a tags=algorithm,c#,performance,c |>\n<| c |>\nI think\
    \ this is wrong, at least for duplicates. Try `search([1L, 2L, 2L, 3L, 3L, 3L,\
    \ 4L, 4L, 4L])`.\n<|/ c |>\n<| c |>\n: You're right. I edited my answer and removed\
    \ the duplicate checking.\n<|/ c |>\n<| a tags=algorithm,c#,performance,c |>\n\
    Here is my C# solution:\n<code>\nstatic long search(long[] arr)\n{\n    if (arr.Length\
    \ == 0)\n        return -1L;", "{\n\tlong x = 0;\n\tlong max = 0;\n\tfor(long\
    \ i = 0; i < lst.lenght; i++) \n\t{\n\t\tif(lst[i] > x)\n\t\t{\n\t\t\tx = lst[i];\n\
    \t\t\tmax++;\n\t\t}\n\t\telse if(lst[i] == x)\n\t\t\tmax++;\n\t}\n\tif(max > 0)\
    \ \n\t\treturn x;\n\treturn -1;\n}", "{\n    long biggest = 0;\n    long cnt =\
    \ 0;\n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) cnt++;\n\
    \        if (lst[i] > biggest) {\n            biggest = lst[i];\n        }\n \
    \   }\n    if (cnt > lst.length) return -1L;\n    return biggest;\n}\n</code>\n\
    <|/ a tags=arrays,algorithm |>\n<| c |>\nThis is what I was looking for, thank\
    \ you :)\n<|/ c |>\n<| c |>\nThanks a lot for the solution but can you please\
    \ explain why it works? It would be really helpful to understand and improve my\
    \ coding skills.\n<|/ c |>\n<| a |>\n<code>", "{\n    long maxVal, maxCount;\n\
    \    int index;\n    \n    foreach(index, lst) \n    {\n        maxCount = 1;\n\
    \        maxVal = index;\n        foreach(index ++, lst) \n        {\n       \
    \     if(index != lst)\n            {\n                if(index % index == 0)\n\
    \                {\n                    ++maxCount;\n                    if(maxCount\
    \ > maxVal)\n                    {\n                        maxCount = 1;\n  \
    \                      maxVal = index;\n                    }\n              \
    \  }\n                else\n                {\n                    if(maxCount\
    \ >= maxVal)\n                    {\n                        break;\n        \
    \            }\n                    else\n                    {\n            \
    \            maxCount = 1;\n                        maxVal = index;\n        \
    \            }\n                }\n            }\n        }\n        if(maxCount\
    \ >= maxVal)\n            break;\n    }\n    return -1;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nWell done for solving the first part of my problem. However, the\
    \ second part of this problem is still not resolved. I've edited my post and added\
    \ some more information on the second part of the problem.\n<|/ c |>\n<| a |>\n\
    Here's an approach that doesn't use hashing.\nThis approach uses the fact that\
    \ the integers you're looking for are multiples of the divisors of the given integers.\n\
    We can get the divisors of a number by multiplying it by itself (until it gets\
    \ zero), and subtracting the divisor from the result. Then we add the divisor\
    \ itself to the result, and so on.\nWe then sort the divisors, and get the first\
    \ one whose multiples match our given integers (if any).\nThe time complexity\
    \ of this approach is O(n log n).\n<code>\nimport java.util.*;", "{\n  long max\
    \ = -1;\n  int iMax = 0;\n  foreach (long x in lst)\n  {\n    if (x>0) {\n   \
    \   max = (max > x) ? max : x;\n      if (max > iMax)\n        iMax = max;\n \
    \   }\n  }\n  return iMax;\n}\n</code>\n<|/ a tags=arrays,search,algorithm |>\n\
    <| c |>\nCould you elaborate on the solution?\n<|/ c |>\n<| c |>\nThanks. I guess\
    \ the trick is the use of a HashMap to count the frequency of integers and return\
    \ -1 if not found in a list.\n<|/ c |>\n<| c |>\nNice, I was just thinking about\
    \ doing that :)\n<|/ c |>\n<| c |>\nI made it into Java - https://gist.github.com/josephcardenas/89b2e9be4ab0d39e6b3ee6ddfa430e16\n\
    <|/ c |>\n<| c |>\nAs a side note, this is a greedy algorithm, i.e. if you have\
    \ multiple occurrences of the same max number, you might get the wrong answer.\n\
    <|/ c |>\n<| a dscore=4 |>\nMy java implementation of Binary Indexed Tree in JavaScript:\n\
    <code>\n/**\n * Binary indexed tree\n * \n * {Array}\n *\n */\nfunction bst (x)\
    \ {\n    return {\n        value: x[0],\n        left: bst(x[1]),\n        right:\
    \ bst(x[2])\n    }\n}", "{\n    var ans: long = 0;\n    var freq: Array<_> = new\
    \ Array<_>(lst.Length);\n    var x: long = 0;\n    foreach (var v in lst) \n \
    \       freq[v]++;\n    foreach (var v in freq) \n        if (freq[v] > ans) {\n\
    \            ans = v;\n        }\n    return ans;\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis is great, but doesn't seem to work on negative numbers. The input would\
    \ be `[-1L, -1L, -1L, -1L, 2L, 2L, 2L, 2L, 3L, 3L, 3L, 3L, 3L]` and it should\
    \ return `3L`, but it gives me `-1L`\n<|/ c |>\n<| c |>\nGood catch.  I edited\
    \ the solution so it now works for negative numbers.\n<|/ c |>\n<| c |>\nI'm also\
    \ looking at another solution.  I'll post it when I get a chance.\n<|/ c |>\n\
    <| c |>\nNice one, it's much more efficient than the one I was thinking of. I\
    \ don't think my solution scales well though, since it will need to loop through\
    \ the entire array every time, whereas I believe it's possible to do it in linear\
    \ time\n<|/ c |>\n<| a tags=arrays,c#,sorting,algorithm,search |>\nI think a better\
    \ way would be:\n<code>\npublic long SearchArray(long[] array, long searchValue)\n\
    {\n    var searchedItem = array.Select((x, i) => new { x, i }).Where(x => x.x\
    \ == searchValue).FirstOrDefault();\n    if (searchedItem != null)\n    {\n  \
    \      var freq = array.Where((x, i) => searchedItem.i == i).Count();\n      \
    \  if (searchedItem.i != searchValue && freq >= searchedItem.x)\n        {\n \
    \           return searchedItem.i;\n        }\n    }\n    return -1;\n}\n</code>\n\
    And then call it by:\n<code>\nSearchArray(array, searchValue);\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nYou might want to explain the `Select` part a bit. Why\
    \ do you need a pair at all? What does `FirstOrDefault` do?\n<|/ c |>\n<| c |>\n\
    I added an explanation, I hope it's clear now.\n<|/ c |>\n<| c |>\nWhat about\
    \ negative numbers? `-1`?\n<|/ c |>\n<| c |>\nYes but that should be fixed by\
    \ comparing `i` with length of the array.\n<|/ c |>\n<| c |>\nI meant negative ",
  "{\n    long result = -1;\n    for(int i=0;i<lst.Length;++i) \n    {\n        if(result\
    \ < 0) return result;\n        result += (lst[i]-1);\n    }\n    return result;\n\
    }", "{\n    int size = lst.size();\n    int result = (int)lst[0];\n    int count\
    \ = 1, value = result;\n    for(int i=1; i<size; i++){\n        if(lst[i] > value){\n\
    \            count = 1;\n            value = lst[i];\n        }else if(lst[i]\
    \ == value){\n            count += 1;\n        }else if(lst[i] > value){\n   \
    \         count = -1;\n            break;\n        }\n    }\n    return count\
    \ >= 0 ? result : -1;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThat code is a\
    \ bit confusing. Why are you incrementing `count` twice per loop iteration? `count`\
    \ will just get incremented to `2` after you found the element and will never\
    \ be incremented again.\n<|/ c |>\n<| c |>\nI think there is another problem:\
    \ the last `if` statement in your `search` method is only looking for the last\
    \ entry in the array, not the first.\n<|/ c |>\n<| c |>\nYeah, I was just looking\
    \ at it again and noticed that too.  I just updated it with an else block to fix\
    \ that.\n<|/ c |>\n<| a dscore=1 tags=c++ |>\nHere's an example of how you can\
    \ do this with a std::map<long, int>\n<code>\n#include <iostream>\n#include <map>\n\
    using namespace std;", "{\n    int lo = 0;\n    int hi = std.array.length(lst)-1;\n\
    \    \n    while(lo <= hi)\n    {\n        int mid = (lo+hi)/2;\n        int val\
    \ = std.math.max(std.array.lookup(lst,mid),0);\n        if(std.array.lookup(lst,mid)\
    \ == val)\n        {\n            hi = mid-1;\n        }\n        else if(val\
    \ > std.array.lookup(lst,mid))\n        {\n            hi = mid-1;\n        }\n\
    \        else\n        {\n            lo = mid+1;\n        }\n    }\n    return\
    \ lo;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=search,arrays,algorithm,big-o,sorting\
    \ |>\n<code>\nfunction searchSort(a,x)\n{\nvar aLength = a.length;\nvar temp =\
    \ 0;", "{\n    //write your code here\n    \n    long sum = 0;\n    for(int i\
    \ = 0; i < lst.length; i++)\n    {\n        if(lst[i] > 0)\n            sum +=\
    \ lst[i];\n    }\n    \n    long max = 0, freq = 0;\n    for(int i = 0; i < lst.length;\
    \ i++)\n    {\n        if(lst[i] == sum)\n        {\n            freq++;\n   \
    \         if(lst[i] > max)\n                max = lst[i];\n        }\n    }\n\
    \    if(max > 0 && freq >= max)\n        return -1;\n    return max;\n}\n</code>\n\
    <|/ a tags=algorithm,java |>\n<| a dscore=0 tags=algorithm,java |>\nI know this\
    \ is a late answer but I just want to share my solution as I think it can help\
    \ others too!\n<code>\n// Complete the search function below.\nstatic long search(int[]\
    \ nums, int K) {\n    long numsMin = nums[0];\n    int numsMinIndex = -1;\n  \
    \  int numsMax = nums[0];\n    int numsMaxIndex = -1;\n    \n    // Loop through\
    \ each number in the array\n    for (int num : nums) {\n        // If the current\
    \ number is the max of all the numbers in the array\n        if (num > numsMax)\
    \ {\n            // Set the max to the current number\n            numsMax = num;\n\
    \            // Set the index to the first index of the current max\n        \
    \    numsMaxIndex = numsMinIndex;\n        }\n        // If the current number\
    \ is the min of all the numbers in the array\n        else if (num < numsMin)\
    \ {\n            // Set the min to the current number\n            numsMin = num;\n\
    \            // Set the index to the first index of the current min\n        \
    \    numsMinIndex = numsMinIndex;\n        }\n        // If the current number\
    \ is equal to the max of all the numbers in the array\n        else if (num ==\
    \ numsMax) {\n            // If the current number is the max of the current min\
    \ and max of the array\n            if (num > nums[numsMinIndex] && nums[numsMaxIndex]\
    \ == num) {\n                // Increment the frequency count by 1\n         \
    \       numsMinIndex++;\n                numsMaxIndex++;\n                // If\
    \ there are more max numbers in the array than the current max\n             \
    \   if (numsMinIndex == numsMaxIndex) {\n                    // Set the index\
    \ to the current min index\n                    numsMinIndex = numsMaxIndex;\n\
    \                }\n            }\n            // If there are more min numbers\
    \ in the array than the current min\n            else if (numsMinIndex == numsMaxIndex)\
    \ {\n                // Set the index to the current max index\n             \
    \   numsMaxIndex = numsMaxIndex;\n            }\n        }\n    }\n    // If the\
    \ current max is greater than K\n    if (numsMax - numsMin > K) {\n        //\
    \ Return -1", "{\n   long res = -1;\n   foreach(i, lst)\n      if (i > res) res\
    \ = i;", "{\n    var max_val: long = 0;\n    var count: long = 0;\n    for (i\
    \ <- 0 until lst.length) \n    {\n        count = 1;\n        max_val = lst[i];\n\
    \        while (lst[i] > max_val) \n        {\n            lst[i] -= 1L;\n   \
    \         count += 1;\n        }\n        if (count >= lst[i])\n        {\n  \
    \          return max_val;\n        }\n    }\n    return -1L;\n}\n</code>\nThe\
    \ code above is O(n) time and O(n) space.\n<|/ a tags=performance,big-o,time-complexity,algorithm\
    \ dscore=3 |>\n<| c |>\nThis is great. I'm new to big-O notation and this is so\
    \ helpful. Thank you!\n<|/ c |>\n<| c |>\nIt's important to note that the above\
    \ code has a bug.  It returns -1 if the array is empty, even if the frequency\
    \ of the given value is greater than 0.\n<|/ c |>\n<| c |>\nYou're right, I missed\
    \ that part, but fixed it now.\n<|/ c |>\n<| a |>\nThe first and most straight-forward\
    \ way is to iterate through the array:\n<code>\n1. Count the frequencies of all\
    \ numbers in the array\n2. Sort them by frequency, ascending\n3. Go from left\
    \ to right and stop whenever you hit a number that's frequency is equal to or\
    \ greater than your input\n</code>\nThis doesn't require much extra space and\
    \ can be done in O(n) time complexity and O(n) space complexity.\nHere's a Python\
    \ implementation (using collections):\n<code>\ndef search(nums):\n    counts =\
    \ collections.Counter(nums)\n    counts.most_common()\n    counts.sort()\n   \
    \ for i in range(0, nums[-1]):\n        if counts[nums[i]] >= i:\n           \
    \ return nums[i]\n</code>\n<|/ a tags=performance,big-o,time-complexity,algorithm\
    \ dscore=3 |>\n<| c |>\nAwesome! I like that solution. Thanks!\n<|/ c |>\n<| a\
    \ |>\nIn case you can not use extra space, you have to use auxiliary array - array\
    \ of pairs, where first element is number of repetitions and second is number\
    \ that have that amount of repetitions. Then you need to iterate through this\
    \ array and search for the pair where the first element is greater than given\
    \ value. Then you need to iterate through this array to find out which number\
    \ has that amount of repetitions. And so on...\n<|/ a dscore=2 tags=performance,big-o,time-complexity,algorithm\
    \ |>\n<| c |>\n+1 for the right approach. But in such cases, you might consider\
    \ using extra space too, even though it does not contribute much ", "{\n    int\
    \ maxfreq = 0;\n    long maxval = Long.MIN_VALUE;\n    int i = 0;\n    for (i\
    \ = 0; i < lst.size(); i++) {\n        if (lst[i] > maxval) {\n            maxval\
    \ = lst[i];\n            maxfreq = i;\n        }\n    }\n    if (maxfreq == lst.size())\
    \ {\n        return -1L;\n    }\n    return maxval;\n}", "{\n    long retVal =\
    \ -1;\n    HashSet<long> hs = new HashSet<long>();\n    foreach(long l in lst)\n\
    \    {\n        if(hs.contains(l))\n        {\n            hs.remove(l);\n   \
    \     }\n        else\n        {\n            hs.add(l);\n        }\n    }\n \
    \   if(hs.isEmpty())\n    {\n        retVal = 0;\n    }\n    else\n    {\n   \
    \     retVal = *hs.begin();\n    }\n    return retVal;\n}\n</code>\n<|/ a tags=c++,algorithm\
    \ |>\n<| c |>\nHashSet has a very high collision rate. You would need a very large\
    \ hash-table, which will cause you memory overflows.\n<|/ c |>\n<| a dscore=0\
    \ |>\nI guess you could just use a hash table. \n<code>", "{\n  long max_freq\
    \ = 1;\n  int idx = 0;\n  for (idx = 0; idx < lst.Length && max_freq > 0; idx++)\n\
    \    if (lst[idx] > 0)\n      max_freq++;", "{\n    long max = 0;\n    foreach\
    \ (int x in lst) \n    {\n        long y = x + 1;\n        if (std.array.contains(lst,\
    \ y)) \n        {\n            long z = x - 1;\n            if (std.array.contains(lst,\
    \ z)) \n            {\n                max = std.math.max(max, x + 1 + z);\n \
    \           }\n            else \n            {\n                max = std.math.max(max,\
    \ x + 1);\n            }\n        }\n        else \n        {\n            max\
    \ = std.math.max(max, x);\n        }\n    }\n    return max;\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a |>\nThe fastest I can think of is probably to have a hashset\
    \ with the first n elements, and if there is a collision with an element of the\
    \ array, then add it to the hashset, and update the hashset with the remaining\
    \ elements. Then, if you find an element of the array that is not in the hashset,\
    \ then you know that there is no such number. So the complexity is O(n) where\
    \ n is the length of the array.\n<code>", "{\n    long greatest = 0;\n    \n \
    \   for (long i = 0; i < lst.length; i++) \n        if (greatest < lst[i] && lst[i]\
    \ >= lst[greatest]) \n            greatest = lst[i];\n    \n    return greatest;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis code works, but it isn't efficient\
    \ since it needs to iterate the entire list even after finding the first element\
    \ that is greater than zero.\n<|/ c |>\n<| a |>\nHere's my attempt, I hope it\
    \ helps!\n<code>\npublic int search(int[] nums) {\n    int maxCount = 0;\n   \
    \ int maxNum = 0;\n    int minCount = 0;\n    int minNum = 0;\n    int maxDifference\
    \ = 0;\n    for(int num: nums) {\n        int counter = 1;\n        for(int i\
    \ = num - 1; i >= 0; i--) {\n            if(i == num) break;\n            int\
    \ diff = i - num;\n            if(diff > maxDifference) maxDifference = diff;\n\
    \            counter++;\n        }\n        if(counter > maxCount) {\n       \
    \     maxCount = counter;\n            maxNum = num;\n        }\n        for(int\
    \ i = num + 1; i < nums.length; i++) {\n            if(i == num) break;\n    \
    \        int diff = i - num;\n            if(diff > maxDifference) maxDifference\
    \ = diff;\n            counter++;\n        }\n        if(counter > minCount) {\n\
    \            minCount = counter;\n            minNum = num;\n        }\n    }\n\
    \    return maxCount == minCount ? minNum : -1;\n}\n</code>\n<|/ a tags=c,c++\
    \ dscore=0 |>\n<| a |>\nHere's a Python solution with an O(n) time complexity,\
    \ using only lists rather than arrays.\n<code>\ndef search(lst):\n    # find the\
    \ smallest number larger than 0 \n    # that occurs at least once in the input\
    \ list\n    smallestIndex = -1\n    smallestVal = -1\n    for index, num in enumerate(lst):\n\
    \        if num > 0:\n            if num == smallestVal:\n                # this\
    \ number already occurs, update minIndex and minVal\n                smallestIndex\
    \ = index\n                smallestVal = num\n            elif num < smallestVal:\n\
    \                # this number occurs after the first time we encountered \n \
    \               # it but before we encountered the previous smallestVal\n    \
    \            smallestIndex = index\n                smallestVal = num", "{\n \
    \   if (lst.Length == 0)\n        return -1;\n    var max = std.collections.max(lst);\n\
    \    var index = std.collections.indexOf(lst,max);\n    if (index != -1) \n  \
    \      return max;\n    if (lst[index] == 0)\n        return -1;\n    \n    for\
    \ (var i = index; i < lst.Length; i++)\n    {\n        if (lst[i] > 0)\n     \
    \   {\n            max = std.collections.max(lst);\n            var index = std.collections.indexOf(lst,max);\n\
    \            if (index != -1) \n                return max;\n            if (lst[index]\
    \ == 0)\n                return -1;\n        }\n    }\n    return -1;\n}\n</code>\n\
    <|/ a tags=c#,arrays,algorithm |>\n<| c |>\nPlease add some explanation to your\
    \ answer\n<|/ c |>\n<| a dscore=0 tags=c#,arrays,algorithm |>\nYou might want\
    \ to look at Array.BinarySearch() Method (T[], T) ", "{\n    long biggest = lst[0];\n\
    \    int index = -1;\n    for(int i=1; i<lst.length; i++)\n    {\n        if(lst[i]\
    \ > biggest)\n            biggest = lst[i];\n        else\n        {\n       \
    \     index = i;\n            break;\n        }\n    }\n    return index == -1\
    \ ? -1 : lst[index];\n}\n</code>\n<|/ a tags=c++,algorithm,arrays |>\n<| c |>\n\
    This fails if you pass in [1L, 2L, 2L, 3L, 3L, 3L, 4L, 4L, 4L] as the array (for\
    \ me, at least).\n<|/ c |>\n<| c |>\nNotice that it is returning 2 for the example\
    \ I provided. Is that intended?\n<|/ c |>\n<| c |>\nI actually had to go back\
    \ and look this over.  I think the problem is the order of the for loop.  It should\
    \ start at 1 instead of 0.  I'll correct it.\n<|/ c |>\n<| c |>\nThe algorithm\
    \ can be simplified even more, just set `biggest` to `lst[0]` and only iterate\
    \ `i` up to `lst.length - 1` -- that is, `for (int i=1; i<lst.length; ++i) { ...\
    \ }`\n<|/ c |>\n<| c |>\nYeah, the first code I posted would always return 2.\
    \  I changed it to be more general.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "{\n\
    \tif (lst.empty()) return -1;\n\tlong x = 0;\n\tfor (long i : lst) \n\t{\n\t\t\
    if (i >= x) x = i;\n\t}\n\treturn x;\n}", "{\n    \n    long res = -1;\n    \n\
    \    for(int i=0; i<lst.length; i++)\n    {\n        int c = std.collection.Compare.get(lst[i]);\n\
    \        if(c==0) res = lst[i];\n        if(c>0) c--;\n        if(c==0) break;\n\
    \    }\n    return res;\n}", "{\n    if(lst.length==0) return -1;\n    long max=0;\n\
    \    for(long i=0;i<lst.length;i++)\n    {\n        if(lst[i]>max)\n        {\n\
    \            max=lst[i];\n        }\n    }\n    return max;\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>", "{\n    std.sort(lst);\n    for (int\
    \ i = 0; i < lst.size(); ++i) \n    {\n        if (lst[i] > 0) \n        {\n \
    \           long count = std.count[lst[i]];\n            if (count > 0)\n    \
    \        {\n                return lst[i];\n            }\n        }\n    }\n\
    \    return -1;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
