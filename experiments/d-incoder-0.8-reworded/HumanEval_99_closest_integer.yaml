name: HumanEval_99_closest_integer
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that\
  \ takes a value (string) representing a number\n    and returns the closest integer\
  \ to it. If the number is equidistant\n    from two integers, round it away from\
  \ zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"\
  15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given\
  \ number is equidistant\n    from two integers, the one you should return is the\
  \ one that is the\n    farthest from zero. For example closest_integer(\"14.5\"\
  ) should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n\
  */\nlong closest_integer(string value) \n"
tests: "unittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"\
  10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"\
  -15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"\
  0\") == 0L);\n}\nvoid main(){}"
completions: ["{\n    long integer;\n    string numstring = str(value);\n    string\
    \ num1 = numstring.substr(0, numstring.find(\".\"));\n    string num2 = numstring.substr(numstring.find(\"\
    .\") + 1);\n    long num1val = std.string.toLong(num1);\n    long num2val = std.string.toLong(num2);\n\
    \    double num1double = float(num1val);\n    double num2double = float(num2val);\n\
    \    long num1int = int(num1double);\n    long num2int = int(num2double);", "{\n\
    \    auto num = std.parseLong(value);\n    long closest = 0;\n    long distance\
    \ = abs(num - closest);", "{\n    long result = 0;\n    long difference = long.MaxValue;\n\
    \    long first = 0;\n    long second = long.MaxValue;\n    bool isNegative =\
    \ false;\n    string stringValue;\n    string temp;\n    long tempResult;", "{\n\
    \tlong  value;\n\tbool isNegative = false;\n\tint sign;", "{\n    long result;\n\
    \    // find the closest integer\n    long min = FLT_MIN;\n    long max = 0;\n\
    \    foreach (char c in value.toLocal8Bit()) {\n        long num = c == '.' ?\
    \ 0 : c - '0';\n        if (num < min) min = num;\n        if (num > max) max\
    \ = num;\n    }\n    result = min;\n    // round the number up if equidistant\n\
    \    result += (max - min) / 2;\n    if (result == 0) {\n        return min;\n\
    \    } else {\n        return result;\n    }\n}", "{\n    long result;\n    //\
    \ Convert string value to long value.\n    result = std.strtoul(value.c_str(),\
    \ 0, 10);\n    // If result is equal to zero, return zero.\n    if (result ==\
    \ 0)\n        return 0;", "{\n    int closest;\n    long closestVal;\n    double\
    \ diff;\n    double diffAbs;\n    long tempVal;\n    \n    if(!value.empty() &&\
    \ !value[value.size()-1] == 'L')\n    {\n        value = value + 'L';\n    }\n\
    \    \n    tempVal = std.atoi(value);\n    diff = value - tempVal;\n    diffAbs\
    \ = std::abs(diff);\n    \n    if(diffAbs < 1.0e-9)\n    {\n        closestVal\
    \ = tempVal;\n    }\n    else\n    {\n        if(diffAbs > std::numeric_limits<double>::max())\n\
    \        {\n            closest = numeric_limits<long>::max();\n        }\n  \
    \      else\n        {\n            closest = std.round(tempVal);\n        }\n\
    \    }\n    \n    return std.typecons.cast(closest);\n}", "{\n    long result;\n\
    \    char comma = value.find_first_of(\",.-\");\n    if(comma == string::npos)\
    \ {\n        comma = value.length();\n    }\n    \n    stringstream ss(value);\n\
    \    \n    string first_number;\n    while(ss >> first_number) {\n    \n     \
    \   long num = std.atoi(first_number.c_str());\n    \n        if(num == 0 || num\
    \ == 1) {\n            if(num > result) {\n                result = num;\n   \
    \         }\n            continue;\n        }\n    \n        long difference =\
    \ abs(num - result);\n        if(difference <= 10) {\n            if(difference\
    \ < difference) {\n                difference = difference;\n            }\n \
    \           result = num;\n        }\n    }\n    \n    if(result < 0 && value.length()\
    \ > 1) {\n        --result;\n    }\n    \n    return result + comma;\n}", "{\n\
    \    long lower = __long0(std.string.toLong(value));\n    long higher = __long0(std.string.toLong(value\
    \ + \"L\"));\n    \n    if(std.long.isDouble(lower) && std.long.isDouble(higher))\n\
    \    {\n        // If we are dealing with a double, let's find the nearest\n \
    \       // integer.\n        double num = __double0(lower);\n        double num2\
    \ = __double0(higher);\n        \n        if(num == num2) \n        {\n      \
    \      // If the two numbers are the same, then we can't decide\n            //\
    \ which one is closer to zero, so\n            return __long0(lower);\n      \
    \  }\n        \n        int num3 = __int(num2);\n        int num4 = __int(num);\n\
    \        \n        if(num3 > num4) \n        {\n            // If the second number\
    \ is bigger, use that one.\n            return __long0(lower);\n        }\n  \
    \      else if(num3 < num4)\n        {\n            // If the second number is\
    \ smaller, use that one.\n            return __long0(higher);\n        }\n   \
    \     \n        // The two numbers are equidistant\n        int d = __double0(num)\
    \ - __double0(num2);\n        return __long0(std.math.round(d * 0.5));\n    }\n\
    \    \n    if(std.string.startsWith(lower, \"-\"))\n    {\n        lower = std.string.toLong(lower\
    \ + \"L\");\n        \n        if(std.string.startsWith(higher, \"-\"))\n    \
    \    {\n            higher = std.string.toLong(higher + \"L\");\n            \n\
    \            if(std.long.isDouble(lower) && std.long.isDouble(higher))\n     \
    \       {\n                // If we are dealing with a double, let's find the\
    \ nearest\n                // integer.\n                double num = __double0(lower);\n\
    \                double num2 = __double0(higher);\n                \n        \
    \        if(num == num2) \n                {\n                    // If the two\
    \ numbers are the same, then we can't decide\n                    // which one\
    \ is closer to zero, so\n                    return __long0(lower);\n        \
    \        }\n                \n                int num3 = __int(num2);\n      \
    \          int num4 = __int(num);\n                \n                if(num3 >\
    \ num4) \n                {\n                    // If the second number is bigger,\
    \ use that one.\n                    return __long0(lower);\n                }\n\
    \                else if(num3 < num4)\n                {\n                   \
    \ // If the second number is smaller, use that one.\n                    return\
    \ __long0(higher);\n                }\n                \n                // The\
    \ two numbers are equ", "{\n    if (value.empty())\n    {\n        throw new invalid_argument(\"\
    Empty string cannot be an argument.\");\n    }\n    long a = 0, b = 0, c = 0,\
    \ d = 0;\n    long delta;\n    long int_value, float_value, integer_value;", "{\n\
    \    /*\n    \n    Declare variables at the top of a function where possible.\
    \ \n    \n    \n    */\n    long intValue;\n    double intValue;\n    long closest;\n\
    \    \n    intValue = std.string(value).toInt();\n    closest = (intValue==0)?\
    \ intValue: intValue - 1;\n    \n    /*\n    \n    Declare variables and function\
    \ prototypes at the top of functions. \n    \n    \n    */\n    double closestNum;\n\
    \    double newNum;\n    double oldNum;\n    \n    closestNum = (closest);\n \
    \   newNum = closestNum + .00001;\n    oldNum = closestNum;\n    \n    if (closest\
    \ < intValue) {\n        closestNum = newNum;\n    }\n    \n    while (closest\
    \ < intValue && closestNum != 0) {\n        oldNum = closestNum;\n        closestNum\
    \ = newNum;\n        newNum = oldNum + .00001;\n    }\n    \n    if (closest ==\
    \ intValue) {\n        closestNum = newNum;\n    }\n    \n    return std.long(closestNum);\n\
    }\n/*", "{\n    long int intvalue = 0;\n    if (stringtolong(value) != -1)\n \
    \   {\n        intvalue = stringtolong(value);\n    }\n    return round(value);\n\
    }\nlong stringtolong(string value)\n{\n    long int intvalue = 0;\n    char buf[512];\n\
    \    string strbuf;\n    if (value.find_first_of(\"0123456789\") != string::npos)\n\
    \    {\n        strbuf = value.substr(0, value.find_first_of(\"0123456789\"));\n\
    \    }\n    else\n    {\n        strbuf = value;\n    }\n    char *end = strbuf.c_str();\n\
    \    char *ptr;\n    while (true)\n    {\n        ptr = strtok(buf, \" \");\n\
    \        if (!ptr)\n            break;\n        intvalue *= 10;\n        intvalue\
    \ += stringtolong(ptr);\n    }\n    return intvalue;\n}\nstring round(string value)\n\
    {\n    long int intvalue = 0;\n    if (stringtolong(value) != -1)\n    {\n   \
    \     intvalue = stringtolong(value);\n    }\n    int intsign = 1, intpow = 0;\n\
    \    if (value.find_first_of(\"-\") != string::npos)\n    {\n        intsign =\
    \ -1;\n        value.erase(value.find_first_of(\"-\"));\n    }\n    if (value.find_first_of(\"\
    0\") != string::npos)\n    {\n        intpow = value.find_first_of(\"0\");\n \
    \   }\n    else\n    {\n        intpow = value.size();\n    }\n    double doublevalue\
    \ = std.strtod(value.c_str(), 0);\n    long int roundto;\n    if (intpow > 0)\n\
    \    {\n        roundto = std.floor(doublevalue / std.pow(10.0, intpow));\n  \
    \  }\n    else if (intpow < 0)\n    {\n        roundto = std.ceil(doublevalue\
    \ / std.pow(10.0, intpow));\n    }\n    else\n    {\n        roundto = std.round(doublevalue);\n\
    \    }\n    double remaining = doublevalue - std.pow(10.0, intpow) * roundto;\n\
    \    long int newintvalue = intvalue + intsign * roundto;\n    if (intvalue ==\
    \ newintvalue)\n    {\n        return value;\n    }\n    if (intvalue == 0)\n\
    \    {\n        return \"0\";\n    }\n    if (intvalue == std.abs(intvalue))\n\
    \    {\n        if (intpow < 0)\n        {\n            return std.abs(newintvalue)\
    \ + \"0\";\n        }\n        else\n        {\n            return \"0\" + std.abs(newintvalue);\n\
    \        }\n    }\n    return std.to_string(newintvalue) + std.to_string(intsign\
    \ * roundto);\n}\n</code>", "{\n    long result;\n    string digits = value.substr(0,\
    \ value.find_first_of(\"0123456789\"));\n    long max = (long)std::stol(digits);\n\
    \    long min = (long)std::stol(digits.substr(0, value.find_first_of(\"0123456789\"\
    )));\n    long difference = max - min;\n    if (difference == 0)\n    {\n    \
    \    result = min;\n    }\n    else\n    {\n        if (difference < 0)\n    \
    \    {\n            result = min - difference + 1;\n        }\n        else\n\
    \        {\n            result = min + difference;\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nThe previous answers seem to\
    \ use too much recursion.  Here's a version that does not use recursion:\n<code>\n\
    function closestInteger( number )\n{\n  var digits = number.split(\"\");\n  var\
    \ largest = digits.pop();\n  var smallest = largest;\n  for(var i = 0; i < digits.length;\
    \ i++)\n  {\n    var digit = digits[i];\n    largest = digit;\n    var current\
    \ = Number(digit);\n    if(current > smallest)\n      smallest = current;\n  }\n\
    \  return largest+smallest;\n}\n</code>\n<|/ a tags=numbers,c++,number-formatting\
    \ |>\n<| a tags=numbers,c++,number-formatting |>\nMy solution:\n<code>\n#include\
    \ <stdio.h>", "{\n    long intValue = std.string(value).asLong();\n    long prevValue\
    \ = intValue;\n    int intValueDiff = 0;\n    \n    for (long i=intValue;; i=prevValue)\
    \ {\n        long nextValue = (i+1)/2;\n        if (nextValue == i) {\n      \
    \      return i;\n        }\n        else {\n            prevValue = i;\n    \
    \        intValueDiff = i - nextValue;\n            if (intValueDiff < intValueDiff*0.1)\
    \ {\n                return nextValue;\n            }\n        }\n    }\n}", "{\n\
    \    long intValue = std.parseNum(value);\n    long intDifference = abs(intValue\
    \ - intValue);", "{\n    // Your code here\n    long int n = std.parseLong(value);\n\
    \    \n    long int min = 10000000000L;\n    long int max = -10000000000L;\n \
    \   \n    for(long int i=0; i<n; i++)\n    {\n        if(i<min)\n            min\
    \ = i;\n        if(i>max)\n            max = i;\n    }\n    \n    if(n-max<min)\n\
    \        max += 1;\n    \n    return max;\n}", "{\n    long num;\n    double x=0.0,\
    \ y=0.0, z;", "{\n    long value;\n    if (value.empty())\n    {\n        throw\
    \ new invalid_argument(\"Invalid number\");\n    }\n    int pos = value.find_first_of(',');\n\
    \    if (pos < 0)\n    {\n        throw new invalid_argument(\"Invalid number\"\
    );\n    }\n    string svalue = value.substr(0, pos);\n    long res = std.parseLong(svalue);\n\
    \    if (res > LONG_MAX)\n    {\n        res = LONG_MAX;\n    }\n    else if (res\
    \ < -LONG_MAX)\n    {\n        res = -LONG_MAX;\n    }\n    else\n    {\n    \
    \    long diff = value - std.stringify(res);\n        if (diff > LONG_MAX)\n \
    \       {\n            res = -res;\n        }\n        else if (diff < -LONG_MAX)\n\
    \        {\n            res = res;\n        }\n    }\n    return res;\n}", "{\n\
    \    int digits[2];\n    long int closest_digit, closest_digit1, closest_digit2;",
  "{\n    long result;\n    long max_diff = numeric_limits<double>::infinity();",
  "{\n\tlong num;\n\tdouble diff;\n\t\n\tnum = std.string(value);\n\t\n\tdiff = std.math.getDistance(val,\
    \ num);\n\t\n\tif(diff > 0) \n\t{\n\t\tif(num < 0) \n\t\t{\n\t\t\treturn num +\
    \ std.math.getDistance(-val, num);\n\t\t}\n\t\t\n\t\treturn num - std.math.getDistance(val,\
    \ num);\n\t}\n\t\n\tif(diff < 0) \n\t{\n\t\tif(num > 0) \n\t\t{\n\t\t\treturn\
    \ num + std.math.getDistance(-val, num);\n\t\t}\n\t\t\n\t\treturn num - std.math.getDistance(val,\
    \ num);\n\t}\n\t\n\treturn num;\n}", "{\n\tlong x;\n\tint diff;", "{\n    long\
    \ intvalue = std.atoi(value);\n    int diff = intvalue - intvalue % 10;\n    if\
    \ (diff < 0) {\n        diff += 10;\n    }\n    return diff < intvalue ? intvalue\
    \ + 10 : intvalue;\n}\n/*", "{\n    long closest_int = long.MinValue;\n    long\
    \ min_dist = 0;\n    for(auto d : intervals(value))\n    {\n        if(d < -10)\n\
    \            d = -10;\n        if(d > 10)\n            d = 10;\n        long distance\
    \ = abs(value - d);\n        if(distance < min_dist)\n        {\n            min_dist\
    \ = distance;\n            closest_int = d;\n        }\n    }\n    return closest_int;\n\
    }\n</code>\nThis returns -1 when the value passed doesn't contain a number in\
    \ the specified intervals (0-9) because this function will always return -1 when\
    \ there are no possible return values (since there is no possible return value\
    \ that is equidistant from all the possible return values).\n<|/ a tags=c++,algorithm,math\
    \ dscore=3 |>\n<| a dscore=3 |>\nHere is an algorithm to find the closest to zero\
    \ number\n<code>\n//Finding closest to zero", "{\n  // find the difference between\
    \ value and 0 from left of value\n  int diff;\n  if (value[0] == '-') {\n    diff\
    \ = -(std.strtolong(value.substr(1)) - std.strtolong(value.substr(0, 1)));\n \
    \ } else {\n    diff = std.strtolong(value) - std.strtolong(value);\n  }", "{\n\
    \    long result = 0;\n    long first = 0;\n    long last = 0;\n    long total\
    \ = 0;\n    long diff;", "{\n    long n = std.parseInt(\"0\"+value);\n    long\
    \ nearest = n;\n    \n    int count = 0;\n    \n    while (true) {\n        nearest\
    \ /= 10;\n        count++;\n        if (nearest == 0) break;\n    }\n    \n  \
    \  return nearest.__shl__(count).__mul__(10);\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\nHere is an implementation that uses string parsing to convert\
    \ the input to a number and then checks if the input number is an integer. I use\
    \ an iterative approach to keep track of the number of iterations until we hit\
    \ the desired precision.\n<code>", "{\n    // Initialize our return value\n  \
    \  long ans = value.length() - 1;", "{\n    long intValue = 0;\n    long intValue2\
    \ = intValue;\n    long intValue3 = intValue2;\n    int digitCount = value.size();\n\
    \    int power = 0;\n    \n    int currentPower = 0;\n    long closest = 0;\n\
    \    \n    for (int i = 0; i < digitCount; i++)\n    {\n        char character\
    \ = value[i];\n        bool isDigit = (character >= '0' && character <= '9');\n\
    \        bool isClosest = true;\n        \n        if (isDigit)\n        {\n \
    \           char otherCharacter = value[digitCount - i - 1];\n            bool\
    \ otherIsDigit = (otherCharacter >= '0' && otherCharacter <= '9');\n         \
    \   \n            /*\n                if (character == '.' || otherCharacter ==\
    \ '.') {\n                    isClosest = false;\n                }\n        \
    \        else {\n                    isClosest = true;\n                }\n  \
    \          */\n            \n            int charValue = (int)character;\n   \
    \         int otherCharValue = (int)otherCharacter;\n            \n          \
    \  isClosest = charValue == otherCharValue;\n        }\n        \n        if (isClosest\
    \ == true)\n        {\n            if (closest < intValue2)\n            {\n \
    \               closest = (intValue2 + 1);\n            }\n            else\n\
    \            {\n                closest = (intValue2 - 1);\n            }\n  \
    \      }\n        \n        if (closest == intValue)\n        {\n            intValue\
    \ = (intValue + 1);\n        }\n        else if (closest == intValue2)\n     \
    \   {\n            intValue = (intValue - 1);\n        }\n        else\n     \
    \   {\n            intValue = (intValue * 10);\n        }\n        \n        intValue\
    \ = intValue / 10;\n        \n        power += 1;\n        \n        if (power\
    \ == 3)\n        {\n            power = 0;\n            \n            if (intValue3\
    \ > intValue2)\n            {\n                intValue2 = intValue3;\n      \
    \      }\n            else\n            {\n                intValue2 = intValue3;\n\
    \            }\n        }\n    }\n    \n    return closest;\n}\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a tags=c++,algorithm,integer dscore=1 |>\nIt depends on the\
    \ expected range. E.g. for small numbers there will be a decent chance that the\
    \ difference is even but the bigger the number, the bigger your chance for even\
    \ numbers. So you could say: For any given number it has a probability of at least\
    \ 0.1/10^42 that your integer will be within one tenth of that number, but in\
    \ most cases it will be within 2 tenths. Then you just loop over all possible\
    \ powers of 10 until you find a number that would make it the closest number",
  "{\n\tif (value.is_empty())\n\t\treturn 0L;\n\tlong l = std.strtol(value, null,\
    \ 10);\n\tif (std.typecons.is_int(l))\n\t\treturn l;\n\t\n\tlong max = (long)(std.math.pow(10.0,\
    \ std.math.log10(abs(l))));\n\tlong closest = (long) std.math.pow(10.0, std.math.log10(abs(value)));\
    \ \n\tif (abs(value - closest) < abs(value - max))\n\t\treturn max;\n\telse\n\t\
    \treturn closest;\n}", "{\n    long a = toLong(value), b = a+1;\n    long c =\
    \ toLong(value), d = c+1;", "{\n    // TODO: implement this!\n    \n    return\
    \ 0;\n}", "{\n\tlong result;\n\tif (value.empty()) return 0L;\n\tif (std.int.is_integer(value))\
    \ \n\t{\n\t\tresult = std.int.parse(value);\n\t} \n\telse \n\t{\n\t\tresult =\
    \ std.double.parse(value);\n\t}\n\tresult = std.math.max(result, 0L);\n\tstd.debug.assert(result\
    \ != 0);\n\treturn result;\n}\n/*", "{\n    auto sd = value.find_last_of('.');\n\
    \    auto ec = value.find_last_of('e');", "{\n    long n = 0;\n    string decimals\
    \ = value.split(\".\")[1];\n    char decimal = decimals[0];\n    long firstLong\
    \ = 0;\n    \n    for(int i=0;i<decimals.length;i++) {\n        char c = decimals[i];\n\
    \        if(!isdigit(c)) {\n            n = n * 10 + firstLong;\n            return\
    \ n;\n        }\n        firstLong = firstLong * 10 + c - '0';\n    }\n    \n\
    \    n = n * 10 + firstLong;\n    return n;\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a dscore=2 |>\nPython version:\n<code>\ndef closest_int(s):\n    if '.' in s:\
    \ # if we have an extra dot on the string, remove it\n        s = s.rstrip('.')\n\
    \    else: \n        # if we don't have the dot, just remove all digits \n   \
    \     s = ''.join(x for x in s if not x.isdigit())\n    i = int(s)\n    return\
    \ 0 if not i else i\n</code>\n<|/ a tags=algorithm,performance,python |>\n<| a\
    \ dscore=1 tags=algorithm,performance,python |>\nThis works in CPython 3.6+ and\
    \ in 2.7:\n<code>\ndef closest_int(s):\n    import math\n    return math.ceil(int(s))\
    \ if '.' in s else int(s)\n</code>\n<|/ a |>\n<| c |>\nThis does not work in Python\
    \ 3, where `math.ceil` is actually `math.ceiling`.\n<|/ c |>\n<| a |>\nThis is\
    \ my solution.\n<code>\ndef closest_int(num):\n    import math\n    if '.' in\
    \ num:\n        return math.ceil(int(num))\n    else:\n        return int(num)\n\
    </code>\n<|/ a tags=algorithm,performance,python dscore=1 |>\n<| a |>\nThis worked\
    \ for me in Python 3.7:\n<code>\ndef closest_integer(s):\n  i = int(s.split(\"\
    .\")[0])\n  return int(math.ceil(i))\n</code>\n<|/ a tags=algorithm,performance,python\
    \ dscore=1 |>\n<| a |>\nI've tried this in Python 3.7.4 and it works fine.\n<code>\n\
    def closest_integer(s):\n    if \".\" in s:\n        num = float(s.split(\".\"\
    )[0])\n        return int(math.ceil(num))\n    else:\n        return int(s)\n\
    </code>\n<|/ a tags=algorithm,performance,python dscore=1 |>\n<| a dscore=1 |>\n\
    Python 3.8 solution\n<code>\nfrom math import ceil", "{\n    long intValue = 0;\n\
    \    long closestVal = int.MaxValue;\n    if (value.Contains(\".\")) {\n     \
    \   string[] numbers = value.Split('.');\n        intValue = Convert.ToInt64(numbers[0]);\n\
    \        closestVal = int.MaxValue;\n        for (Int32 i = 0; i < numbers.Length;\
    \ i++) {\n            Int64 tempVal = Convert.ToInt64(numbers[i]);\n         \
    \   if (tempVal == intValue) {\n                closestVal = tempVal;\n      \
    \          break;\n            }\n        }\n    }\n    else {\n        intValue\
    \ = Convert.ToInt64(value);\n    }\n    if (intValue == closestVal) {\n      \
    \  closestVal = int.MaxValue;\n    }\n    return closestVal;\n}\n</code>\n<|/\
    \ a tags=c# dscore=1 |>\n<| a tags=c# |>\nIf your numbers are in double format,\
    \ you can simply use Convert.ToInt32()\n<code>\ndouble yourDouble = ...", "{\n\
    \    long lvalue;\n    lvalue = std.parse(value);\n    if (lvalue == 0)\n    {\n\
    \        lvalue = std.parse(value);\n        if (lvalue == 0)\n        {\n   \
    \         lvalue = std.parse(value);\n        }\n    }\n    return lvalue;\n}\n\
    /*", "{\n    int firstInt = to!int(value);\n    int secondInt = to!int(value);",
  "{\n    long iValue = std.parseLong(value);\n    int iSign = std.parseInt(\"sign(iValue)\"\
    );\n    int iMin = std.parseInt(\"min(iValue)\");\n    int iMax = std.parseInt(\"\
    max(iValue)\");\n    iSign *= (iMax - iMin);\n    iValue *= iSign;\n    if (iValue\
    \ < iMin) \n    {\n        iValue = iMin;\n        iSign = -1;\n    }\n    else\
    \ if (iValue > iMax) \n    {\n        iValue = iMax;\n        iSign = 1;\n   \
    \ }\n    return std.parseLong(iValue.toString()) * iSign;\n}\n// End of function\
    \ closest_integer", "{\n    /*\n        Note: This solution was taken from http://stackoverflow.com/questions/504103/how-do-i-determine-if-a-number-is-a-whole-number-in-python\n\
    \    */\n    char numbers[]= value.c_str();\n    int length = sizeof(numbers)/sizeof(char);\n\
    \    long largest = -10000000000000000000L;\n    long least = 10000000000000000000L;\n\
    \    for(int i = 0; i < length; i++) \n    {\n        long temp = (long) atof(numbers\
    \ + i);\n        if (temp > largest) {\n            largest = temp;\n        }\n\
    \        if (temp < least) {\n            least = temp;\n        }\n    }\n  \
    \  long diff = largest - least;\n    if (diff >= 1) {\n        diff = diff * -1;\n\
    \    }\n    return least + diff;\n}", "{\n    auto val = getLong(value);", "{\n\
    \tlong result;", "{\n\tlong lower = std.strtoul(value.c_str(), 0, 10);\n\tlong\
    \ upper = std.strtoul(value.c_str(), 0, 10);\n\tlong diff = std.fabs(upper - lower);\n\
    \treturn std.clamp(lower + diff/2, upper, 0L);\n}\n/*\n*/\nlong closest_integer(string\
    \ value, string radices) \n{\n\tstring tmp = value;\n\tstring radix = radices;\n\
    \tvector<char> radics = std.strsplit(radix, \"l\");\n\tstring digits = std.strsplit(tmp,\
    \ \".\");\n\tstring ints = digits[0];\n\tvector<long> ints = std.strsplit(ints,\
    \ \"l\");\n\tstring ints_str = digits[0];\n\tvector<long> radic_str = std.strsplit(radics[0],\
    \ \"l\");\n\t\n\tfor(vector<long>::size_type i = 0, size = ints.size(); i < size;\
    \ ++i)\n\t\tints[i] = std.strtoul(ints_str.c_str(), 0, 10);\n\tfor(vector<long>::size_type\
    \ i = 0, size = radics.size(); i < size; ++i)\n\t\tradics[i] = std.strtoul(radic_str[i].c_str(),\
    \ 0, 10);\n\t\n\tlong lower = std.fmin(ints[0], radics[0]);\n\tlong upper = std.fmax(ints[0],\
    \ radics[0]);\n\tlong diff = std.fabs(upper - lower);\n\t\n\tfor(vector<long>::size_type\
    \ i = 0, size = ints.size(); i < size; ++i)\n\t{\n\t\tif(i == 0)\n\t\t\tupper\
    \ = ints[i];\n\t\telse\n\t\t\tupper = std.clamp(ints[i] + diff/2, upper, 0L);\n\
    \t}\n\tfor(vector<long>::size_type i = 0, size = radics.size(); i < size; ++i)\n\
    \t{\n\t\tif(i == 0)\n\t\t\tlower = radics[i];\n\t\telse\n\t\t\tlower = std.clamp(radics[i]\
    \ - diff/2, lower, 0L);\n\t}\n\t\n\treturn lower;\n}", "{\n    return std.math.toInt(value);\n\
    }", "{\n    long result;\n    int digit;\n    int i;", "{\n    auto [minValue,\
    \ maxValue] = std.int.reduce((long long int) std.toLong(value), std.toLong(0));",
  "{\n    long result = 0;", "{\n\tlong num = 0;\n\tif (value.size() != 1) throw new\
    \ InvalidArgumentException(\"Invalid input\");\n\tchar c = value[0];\n\tif (c\
    \ == '-') c = value.substr(1);\n\ttry {\n\t\tnum = (long) std.parseNum(value);\n\
    \t} catch (Exception ex) {\n\t\tthrow new InvalidArgumentException(\"Invalid input\"\
    );\n\t}\n\ttry {\n\t\tdouble d = (double) num;\n\t\tif (std.isNumber(d))\n\t\t\
    \treturn (int) d;\n\t\telse if (std.isString(d))\n\t\t\treturn (int) std.parseNum(std.toLong(d),\
    \ 10);\n\t\tthrow new Exception();\n\t} catch (Exception ex) {\n\t\tthrow new\
    \ InvalidArgumentException(\"Invalid input\");\n\t}\n}", "{\n    if(isdigit(value))\n\
    \    {\n        return (long) value;\n    }\n    \n    long num;\n    if(value\
    \ == \"0\")\n    {\n        return 0;\n    }\n    \n    string value_copy = value;\
    \ // Make a copy of the value\n    for(char c : value_copy)\n    {\n        if(!isdigit(c))\n\
    \        {\n            value_copy = value.substr(0,value.size()-1); // Cut the\
    \ trailing digit\n            break;\n        }\n    }\n    \n    int i = 0;\n\
    \    for(char c : value_copy)\n    {\n        if(!isdigit(c))\n        {\n   \
    \         value_copy = value.substr(0,value.size()-1); // Cut the trailing digit\n\
    \            break;\n        }\n    }\n    \n    if(isdigit(value_copy))\n   \
    \ {\n        num = (long) value;\n    }\n    \n    return num;\n}", "{\n\tlong\
    \ temp;\n\tif (value.length() <= 2)\n\t\treturn 0;", "{\n    long value;\n   \
    \ if (value.empty())\n        throw \"Empty string\";\n    if (value[0] == '+')\n\
    \        value = value.replace(\"+\", \"\");\n    else if (value[0] == '-')\n\
    \        value = value.replace(\"-\", \"\");\n    else\n        value = value.replace(\"\
    .\", \"\");\n    \n    long left = 0;\n    long right = 0;\n    int diff = 0;\n\
    \    bool isNegative = false;\n    if (value[0] == '-')\n        isNegative =\
    \ true;\n    else\n        value = value.replace(\".\", \"\");", "{\n    auto\
    \ lvalue = std.parse(value);\n    if (lvalue.is_empty())\n        throw runtime_error(\"\
    The value you passed was empty.\");\n    if (lvalue.type != std.typecons.integer)\n\
    \        throw runtime_error(\"The value you passed was not an integer.\");\n\
    \    if (lvalue.value.is_negative())\n        throw runtime_error(\"The value\
    \ you passed was negative.\");\n    \n    auto result = lvalue.value;\n    while\
    \ (result > std.math.sqrt(lvalue.value))\n        --result;\n    return result;\n\
    }", "{\n    long lval = std.parseLong(value);\n    if(lval == 0)\n        lval\
    \ = std.parseLong(value.substr(0,1)); // first char is '-'\n    if(lval == 0)\n\
    \        lval = 1; // force long int", "{\n    long l1 = std.atoi(value);\n  \
    \  long l2 = std.atoi(value);\n    long d = abs(l1-l2);\n    \n    if(d == 0)\
    \ {\n        if(l1 > l2) return l1;\n        else if(l1 < l2) return l2;\n   \
    \     else return l1;\n    }\n    \n    // Otherwise, return whichever is closest\
    \ to zero\n    if(d >= 2) return l1;\n    else return l2;\n}", "{\n    long closest_int\
    \ = (long)ceil(value);\n    long closest_diff = 0;\n    long current_diff;\n \
    \   \n    for(int i = 0; i < value.size(); ++i)\n    {\n        current_diff =\
    \ value[i] - '0';\n        if(current_diff < closest_diff)\n        {\n      \
    \      closest_diff = current_diff;\n            closest_int = i;\n        }\n\
    \    }\n    return closest_int;\n}", "{\n\tlong result;", "{\n    long result;\n\
    \    \n    // The \"sign\" variable will be 1 or -1 depending on whether the value\
    \ \n    // is a positive number or not.\n    long sign;\n    bool is_negative\
    \ = false;\n    if (value.compare(0, value.length(), 0, value, value.length(),\
    \ 0) == 0)\n    {\n        result = std.parseLong(value.substring(0,value.length()-1));\n\
    \    }\n    else\n    {\n        result = std.parseLong(value);\n        is_negative\
    \ = value < 0;\n    }", "{\n\tassert(isdigit(value[0]));\n\tlong result = stringToLong(value);",
  "{\n    long ret = 0;", "{\n    long num;\n    double temp;\n    char sep;", "{\n\
    \    long val = 0;\n    long min = 0;\n    long max = INT_MAX;\n    bool isInt\
    \ = std.isIntegral(value); // Will be true if 'value' is a number that can be\
    \ converted to an integer.\n    if (isInt) {\n        val = std.toLong(value);\n\
    \    } else {\n        val = std.strtoul(value, null, 10);\n    }\n    val = std.toLong(value);\n\
    \    if (val < 0) {\n        val = 0 - val;\n    }", "{\n    long closest;\n \
    \   long closestInteger;\n    int divisor = cast(ulong, value);", "{\n    long\
    \ result = 0;\n    long smallest = 0;\n    long largest = INT_MAX;\n    \n   \
    \ auto testString = [&](string str) -> bool\n    {\n        auto testNum = [&](string\
    \ num, long expected, string actual) -> bool\n        {\n            bool result\
    \ = std.conv.parse<long long>(num) == expected;\n            assert(result ==\
    \ actual);\n            return result;\n        };\n        \n        return testNum(value,\
    \ result, actual);\n    };\n    \n    if(testString(value, smallest, \"-inf\"\
    ))\n    {\n        largest = -1;\n    }\n    else if(testString(value, largest,\
    \ \"inf\"))\n    {\n        smallest = -1;\n    }\n    else\n    {\n        auto\
    \ test = [&](string str, long expected, string actual) -> bool\n        {\n  \
    \          auto parseResult = std.conv.parse<long long>(str);\n            bool\
    \ result = parseResult == expected;\n            assert(result == actual);\n \
    \           return result;\n        };\n        \n        auto testResult = [&](string\
    \ num, long expected)\n        {\n            if(test(num, expected, num))\n \
    \           {\n                return true;\n            }\n            return\
    \ false;\n        };\n        \n        auto tests = [&](string num) -> bool\n\
    \        {\n            return testResult(num, expected);\n        };\n      \
    \  \n        for(long num = smallest; num < largest; num++)\n        {\n     \
    \       if(tests(num))\n            {\n                largest = num;\n      \
    \      }\n        }\n        for(long num = -1 * smallest; num >= largest; num--)\n\
    \        {\n            if(tests(num))\n            {\n                smallest\
    \ = num;\n            }\n        }\n    }\n    \n    result = smallest < 0 ? smallest\
    \ : largest + 1;\n    \n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\n`long\
    \ roundTo(string input)` should be `long long` since the input is a string not\
    \ a float\n<|/ c |>\n<| a tags=c++,algorithm |>\n<code>", "{\n    int a = to_integer(value);\n\
    \    int b = to_integer(value);", "{\n    int closest;\n    long a = std.atoi(value);\n\
    \    long b = std.atoi(value);\n    if (a == b)\n    {\n        closest = std.round(a);\n\
    \    }\n    else\n    {\n        closest = std.round(a);\n        while (closest\
    \ == b)\n        {\n            closest = std.round(a);\n            std.fmod(b,\
    \ 10, &b);\n        }\n    }\n    return std.atoi(value);\n}", "{\n    auto s\
    \ = std.parsec();", "{\n\t\n    long n = 0;\n    \n    if(value.contains(\".\"\
    )) {\n        n = std.parseLong(value);\n    } else {\n        n = std.parseInt(value);\n\
    \    }\n    \n    if(n==0) return 0L;\n    \n    long diff = ((n - std.parseInt(\"\
    1\")));\n    \n    if(diff>0) {\n        return std.parseInt(\"1\");\n    } else\
    \ {\n        return std.parseInt(\"-1\");\n    }\n    \n}\n/*", "{\n    long val\
    \ = 0;\n    long diff = std.math.abs(std.typecons.toLong(value) - std.typecons.toLong(val));\n\
    \    if (diff <= 0) {\n        val = std.typecons.toLong(value);\n    }\n    else\
    \ { \n        val = std.math.ceil(val);\n    }\n    return val;\n}", "{\n    long\
    \ long valueAsLong = std.strtoll(value, nullptr, 10);\n    if(valueAsLong == 0)\n\
    \    {\n        return valueAsLong;\n    }", "{\n    long n = std.parseLong(value);\n\
    \    long closest_integer;\n    double diff = std.parseDouble(value) - n;\n  \
    \  double abs_diff = abs(diff);\n    long divisor = 1;\n    long quotient;\n \
    \   bool is_even;\n    bool is_odd;\n    while (abs_diff > std.parseDouble(\"\
    1.0E-6\")) {\n        divisor = divisor * 10;\n        abs_diff = std.parseDouble(value)\
    \ - n / divisor;\n    }\n    is_even = true;\n    is_odd = true;\n    while (divisor\
    \ > 1) {\n        if (diff > std.parseDouble(\"1.0E-6\")) {\n            is_odd\
    \ = false;\n        }\n        if (diff < std.parseDouble(\"1.0E-6\")) {\n   \
    \         is_even = false;\n        }\n        if (is_even ^ is_odd) {\n     \
    \       quotient = n / divisor;\n            abs_diff = abs(quotient - n);\n \
    \           break;\n        }\n        divisor = divisor / 10;\n    }\n    closest_integer\
    \ = (long)(quotient + .5);\n    return closest_integer;\n}", "{\n    long num\
    \ = 0;\n    long difference = abs(strtoul(value.c_str(), NULL, 10) - num);\n \
    \   long max;\n    long min;\n    max = num + difference;\n    min = num - difference;",
  "{\n\tlong closest = (long) value;\n\tlong a = value - closest;\n\tlong b = value\
    \ - ((long) (value) + closest);\n\tlong c = value - ((long) (value) - closest);",
  "{\n    long result = to_integer(value);\n    long difference = abs(result - value);\n\
    \    if (result == 0) \n    {\n        if (difference < long_threshold) \n   \
    \     {\n            return 0;\n        }\n        else\n        {\n         \
    \   return result;\n        }\n    }\n    bool is_close = false;\n    int closest\
    \ = numeric_limits<int>::min();\n    double closeness_square = numeric_limits<double>::min();\n\
    \    double delta = (numeric_limits<double>::max()\n        - numeric_limits<double>::min())/10;\n\
    \    for (long i = 0; i <= numeric_limits<long>::max(); i++)\n    {\n        long\
    \ test = (long)i;\n        long square = square(i*i);\n        if (test == 0)\n\
    \        {\n            continue;\n        }\n        bool is_equal = abs(test*test\
    \ - result) < closeness_square;\n        bool is_better = abs(test - result) <\
    \ delta;\n        bool is_less_close = test < result && abs(test - result) < closeness_square;\n\
    \        if (is_equal && !is_better && !is_less_close)\n        {\n          \
    \  difference = square;\n            result = test;\n            is_close = true;\n\
    \            break;\n        }\n        if (is_better)\n        {\n          \
    \  closeness_square = square;\n        }\n    }\n    if (!is_close)\n    {\n \
    \       return numeric_limits<long>::min();\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=c++,integer,floating-point,ceil,ceiling |>\n<| c |>\nYou can't compare\
    \ two floating point numbers for equality. For that you need some sort of tolerance\
    \ (which is more or less what I had in mind).\n<|/ c |>\n<| c |>\n: What are you\
    \ talking about? `float a = 1.0f == 1.0f` gives me `1`, which I believe is correct.\
    \ I also used it in a similar function, and it worked fine.\n<|/ c |>\n<| c |>\n\
    Yes, the floating point representation for 1.0f is 1.0000000000000002f, but it's\
    \ still not the same.\n<|/ c |>\n<| c |>\nOh, I see. You're right. I had misunderstood\
    \ what you said. You're right. I'll fix my answer.\n<|/ c |>\n<| c |>\n: How does\
    \ that make \"1\" or \"1.0\" the best choice?\n<|/ c |>\n<| a tags=c++,integer,floating-point,ceil,ceiling\
    \ |>\n<code>\nfloat floor(float n)\n{\n   return floor(n - floor(double(n)));\n\
    }\n</code>\n<|/ a dscore=", "{\n\tlong x = 0;\n\tlong y = 0;\n\tlong difference\
    \ = 0;\n\tint n = value.size();", "{\n    auto one = 1;\n    auto zero = 0;\n\
    \    auto diff = std.math.remainder(value, one);\n    if(diff == zero)\n    {\n\
    \        // Number is equidistant from two integers, round it away from zero.\n\
    \        return std.typecons.max((double)(value - one), ((double)(value - zero)));\n\
    \    }\n    return diff;\n}", "{\n    long int_value = 0;\n    long int_difference\
    \ = 0;\n    bool has_digit = false;\n    size_t size = value.size();\n    for\
    \ (size_t i = 0; i < size; i++) {\n        bool digit = std.isdigit(value[i]);\n\
    \        int_value += (digit ? std.tointeger(value[i]) : 0);\n        has_digit\
    \ = has_digit || digit;\n        int_difference = abs(int_value - int_difference);\n\
    \        int_value = int_value + ((has_digit && int_difference > 0) ? 1 : 0);\n\
    \        int_difference = int_difference + ((has_digit && int_difference > 0)\
    \ ? 1 : 0);\n    }\n    return int_value;\n}", "{\n    long lower = std.strtolong(value);\n\
    \    long upper = std.strtolong(value);\n    int dist = int(std.sqrt(pow(upper-lower,2)));\n\
    \    long diff = Math.abs(lower-upper);\n    if(diff < dist*1.05)\n        return\
    \ lower;\n    else if(diff > dist*1.05)\n        return upper;\n    else\n   \
    \     return lower-dist;\n}", "{\n    int diff, diff2;\n    long min = -1000000;\n\
    \    long max = 1000000;\n    long closest;", "{\n  int i, i1, i2, i3, c = 0;\n\
    \  long num;\n  if (value.length() == 1)\n    return tolong(value);\n  for (i\
    \ = 1, i1 = toint(value[0]); i < value.length(); i++) {\n    i2 = toint(value[i]);\n\
    \    i3 = toint(value[i - 1]);\n    if ((i3 - i2) < c)\n      num = i1;\n    c\
    \ = i3 - i2;\n    i1 = i2;\n  }\n  return num;\n}\n/*", "{\n\tassert(typeid(value)\
    \ == typeid(string));\n\t\n    long value2 = strtod(value.c_str(), nullptr);\n\
    \    if (value2 < 0 && value2 > -MAX)\n    {\n        value2 += MAX;\n    }\n\
    \    \n    return value2;\n}", "{\n    auto f = [value](long x) -> long {\n  \
    \      double x = std.stod(value);\n        return std.isinf(x) ? x : std::round(x+1);\n\
    \    };", "{\n    long n = 0;\n    \n    for (int i = 0; i < value.size(); i++)\
    \ {\n        n = std.string.format(value).parseLong(i);\n        if (std.math.isClose(n,\
    \ std.math.toInt64(n))) {\n            return n;\n        }\n    }\n    return\
    \ n;\n}", "{\n    int x = std.string.toLong(value);\n    int delta = (abs(x -\
    \ std.math.toInt(x)) <= 2) ? 1 : 0;", "{\n    long long closest;\n    bool isInt\
    \ = std.typecons.is_integer(std.str.trim(value));\n    \n    if (isInt) {\n  \
    \      long long num = std.math.tolonglong(std.str.trim(value));\n        \n \
    \       if (num >= 0) {\n            closest = num;\n        } else {\n      \
    \      closest = -num - 1;\n        }\n    } else {\n        closest = std.math.tolonglong(std.str.trim(value));\n\
    \    }\n    \n    if (closest != std.math.tolonglong(std.str.trim(value))) {\n\
    \        \n        // Round away from zero if the given value is equidistant from\n\
    \        // two integers.\n        if (closest == 0) {\n            closest =\
    \ 1;\n        }\n    }\n    \n    return std.typecons.tointeger(closest);\n}",
  "{\n    long low = Long.parseLong(value);\n    long high = Long.parseLong(value);",
  "{\n    long retval;\n    double x = std.parseNum(value);\n    double closest_x\
    \ = std.fabs(x);", "{\n    return std.math::closestInt(std.string(value));\n}",
  "{\n    long lower = 0, upper = 0;", "{\n\tif (value.length() == 0)\n\t\treturn\
    \ 0;", "{\n    auto f = [=](long x) -> long {\n        return x == x ? x : x ==\
    \ x - 1 ? x : (long)((x - 1)/(x+1));\n    };\n    long low = std::stoll(value),\
    \ high = std::stold(value);\n    auto x = std::distance(std::begin(std.algorithms),\
    \ std::find(std::begin(std.algorithms), std::end(std.algorithms), std::bind(f,\
    \ low)));\n    long result = std::distance(std::begin(std.typecons), std::find(std::begin(std.typecons),\
    \ std::end(std.typecons), x));\n    if (low == high) return low;\n    if (low\
    \ + 1 == high) return std::max(low, (long)(x - 1)) + 1;\n    if (low == high -\
    \ 1) return std::max(low, (long)(x - 1)) + 1;\n    return low + (long)(std::ceil(std::abs(high\
    \ - low)/(x-result)));\n}\n/*", "{\n    int x = 0;\n    int y = 0;\n    int xmin\
    \ = x;\n    int xmax = x;\n    long minval = x;\n    long maxval = x;\n    double\
    \ valueDouble;", "{\n    auto [sign, magnitude] = parse(value);\n    long result;",
  "{\n    long value;\n    double v;\n    double r;\n    long r;\n    long i;", "{\n\
    \    auto firstChar = value[0];\n    long number = 0;\n    long nextNumber = 1;",
  "{\n    long num = std.string(value).parseLong();\n    string s = std.string(value).chars().map(string).map(std.int).collect(Collectors.joining());\n\
    \    long max = std.string(value).parseLong(s.substring(s.length() - 1));\n  \
    \  long min = std.string(value).parseLong(s.substring(0, s.length() - 1));\n \
    \   long diff = (num - min) + (max - num);\n    return std.math.max(min, std.math.max(num,\
    \ diff));\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nAnother solution in Java 8\
    \ is \n<code>", "{\n\tlong ld = std.parseLong(value);\n\tif (ld == 0) {\n\t\t\
    throw new System.Exception(\"Unable to parse '\" + value + \"'\");\n\t}\n\t\n\t\
    bool sign = ld < 0;\n\t\n\tstring base = getBase(value);\n\t\n\tstring digits\
    \ = string.Join(\"\", base.TakeWhile(x => x >= '0').Select(x => (char)(x - '0')));\n\
    \tstring remainder;\n\t\n\tif (base.Last() == '.') {\n\t\tstring decimal = base.Skip(base.Length\
    \ - 1).TakeWhile(x => x >= '0').Select(x => (char)(x - '0')).First();\n\t\tremainder\
    \ = string.Join(\"\", base.Skip(base.Length - 1).TakeWhile(x => x <= '0'));\n\t\
    }\n\telse {\n\t\tremainder = base;\n\t}\n\t\n\tlong dm = std.parseLong(digits);\n\
    \tlong res = dm + sign.Value;\n\t\n\tif (remainder.Length > 0 && std.stringCompare(remainder,\
    \ \".\") == 0) {\n\t\tres = res - 1;\n\t\t\n\t\tif (res < 0) {\n\t\t\tres = 0;\n\
    \t\t}\n\t}\n\t\n\treturn res;\n}", "{\n    long result;\n    long diff;\n    long\
    \ round;\n    string temp;", "{\n    long n = std.atoi(value);\n    if (n >= 0)\n\
    \        return n;", "{\n    long result = 0;\n    long val = 0;\n    string unit\
    \ = \"\";\n    char c;\n    bool first = true;\n    bool check = false;\n    \n\
    \    for (int i = 0; i < (int) value.size(); i++)\n    {\n        c = value[i];\n\
    \        switch(c)\n        {\n            case '-':\n            case '+':\n\
    \            case '.':\n            case '0':\n            case ',':\n       \
    \     case '-':\n            case '+':\n            case '.':\n            case\
    \ '0':\n            case '#':\n            case '%':\n            case '^':\n\
    \            case '&':\n            case '|':\n            case '(':\n       \
    \     case ')':\n            case '[':\n            case ']':\n            case\
    \ '{':\n            case '}':\n            case '?':\n            case '%':\n\
    \            case '~':\n            case '*':\n            case '+':\n       \
    \     case '-':\n            case '/':\n            case ':':\n            case\
    \ '<':\n            case '>':\n            case '=':\n            case '%':\n\
    \            case '&':\n            case '|':\n            case '(':\n       \
    \     case ')':\n            case '[':\n            case ']':\n            case\
    \ '{':\n            case '}':\n            case '?':\n            case '%':\n\
    \            case '~':\n            case '*':\n            case '+':\n       \
    \     case '-':\n            case '/':\n            case ':':\n            case\
    \ '<':\n            case '>':\n            case '=':\n            case '%':\n\
    \            case '&':\n            case '|':\n            case '(':\n       \
    \     case ')':\n            case '[':\n            case ']':\n            case\
    \ '{':\n            case '}':\n            case '?':\n            case '%':\n\
    \            case '~':\n            case '*':\n            case '+':\n       \
    \     case '-':\n            case '/':\n            case ':':\n            case\
    \ '<':\n            case '>':\n            case '=':\n            case '%':\n\
    \            case '&':\n            case '|':\n            case '(':\n       \
    \     case ')':\n            case '[':\n            case ']':\n            case\
    \ '{':\n            case '}':\n            case '?':\n            case '%':\n\
    \            case '~':\n            case '*':\n            case '+':\n       \
    \     case '-':\n            case '/':\n            case ':':\n            case\
    \ '<':\n            case '>':\n            case '=':\n            case '%':\n\
    \            case '&':\n            case '|':\n            case '(':\n       \
    \     case ')':\n            case '[':\n            case ']':\n            case\
    \ '{':\n            case '}':\n            case '?':\n            case '%':\n\
    \            case '~':\n            case '*':\n            case '+':\n       \
    \     case '-':\n            case '/':\n            case ':':\n            case\
    \ '<':\n            case '>':\n            case '=':\n            case '%':\n\
    \            case '&':\n            case '|':\n            case '(':\n       \
    \     case ')':\n", "{\n    long closest;\n    int first;\n    int second;\n \
    \   bool isNegative;\n    int diff;\n    long firstDiff;\n    long secondDiff;\n\
    \    long temp;\n    \n    isNegative = (value[0]=='-');\n    if(isNegative)\n\
    \    {\n        value = value.substr(1);\n    }\n    first = std.string.toLong(value);\n\
    \    second = first;\n    isNegative = (value[0]=='-');\n    if(isNegative)\n\
    \    {\n        first = -first;\n        second = -second;\n    }\n    diff =\
    \ abs(first - second);\n    temp = first;\n    firstDiff = diff;\n    secondDiff\
    \ = diff;\n    while(true)\n    {\n        if(first == second)\n            break;\n\
    \        if(abs(first) < abs(second))\n        {\n            temp = first;\n\
    \            first += 1;\n            firstDiff += 1;\n        }\n        else\n\
    \        {\n            temp = second;\n            second += 1;\n           \
    \ secondDiff += 1;\n        }\n        if(firstDiff < secondDiff)\n          \
    \  first = temp;\n        else\n            second = temp;\n        diff = abs(first\
    \ - second);\n    }\n    if(first == second)\n        return abs(first);\n   \
    \ if(diff < abs(first - second))\n        return first;\n    return second;\n\
    }\n</code>\n<|/ a tags=integer,c++,string |>\n<| c |>\nThis is awesome, I was\
    \ going to post my own solution to this but I like it better.\n<|/ c |>\n<| c\
    \ |>\nIt's not *that* bad. Some people would use recursion for this.\n<|/ c |>\n\
    <| c |>\nIt should be pointed out that this isn't an ideal solution, just an attempt\
    \ to make the code work.\n<|/ c |>\n<| c |>\nThis code doesn't work for the case\
    \ where there is only one integer. You'd return 0, but that's the closest integer.\n\
    <|/ c |>\n<| c |>\nThis solution does not work if the input is \"-10.5\".\n<|/\
    \ c |>\n<| a tags=integer,c++,string |>\nHere's a recursive version:\n<code>\n\
    long closest(int first, int second)\n{\n  if (first > second)\n  {\n    long diff\
    \ = abs(first - second);\n    if (diff > abs(first + 1))\n      return first +\
    \ 1;\n    else if (diff < abs(first - 1))\n      return first - 1;\n    else\n\
    \      return first;\n  }\n  else\n  {\n    long diff = abs(second - first);\n\
    \    if (diff > abs(", "{\n    long retval = valueToLong(value);\n    long closestVal\
    \ = long.min;\n    long closestDiff = long.max;\n    long diff = closestDiff;",
  "{\n    long int_value = std.parseLong(value);\n    \n    long closest = (long)\
    \ int_value;\n    if (int_value >= 0) return closest;\n    else \n    {\n    \
    \    long diff = closest - int_value;\n        if (diff < 0) diff = -diff;\n \
    \       return int_value + diff;\n    }\n}", "{\n    long valueToInt = std.string(value).as_long();",
  "{\n    long result;\n    \n    // Find the difference\n    long diff = parseInt64(value)\
    \ - parseInt64(value);\n    \n    // Check for equidistant values\n    if(diff%2==0)\n\
    \    {\n        // If equidistant round away\n        result = parseInt64(value)\
    \ - (diff/2);\n    }\n    else\n    {\n        result = parseInt64(value) + (diff/2);\n\
    \    }\n    \n    return result;\n}", "{\n\t\n\tif(value.contains(\".\"))\n\t\
    {\n\t\tstring[] strings = value.split(\".\");\n\t\tfloat f = std.float(strings[0]);\n\
    \t\tfloat f2 = std.float(strings[1]);\n\t\tint i1 = std.int(f);\n\t\tint i2 =\
    \ std.int(f2);\n\t\treturn std.int(f) + std.int(f2) - i1 + i2;\n\t}\n\treturn\
    \ std.int(std.float(value));\n}\n/*", "{\n    long result = value;\n    if (result==0)\
    \ return 0;\n    if (value < 0)\n        result = -result;\n    std.typecons.SortBy<long>((int\
    \ x, int y) -> {\n        double d = value - x;\n        if (d<0) return -1;\n\
    \        if (d==0) return 0;\n        return 1;\n    }).forEach(result);\n   \
    \ return result;\n}", "{\n\tlong closest = std.math.remainder(value, 1);\n\tlong\
    \ diff = (value - closest) + 1;\n\tif (diff > 0)\n\t\tdiff = -1;\n\treturn std.math.remainder(value\
    \ + diff, 1);\n}", "{\n\tlong x = std.parseNum(value);", "{\n    long result;\n\
    \    // Convert string to int\n    int val = int(value);\n    // Get difference\
    \ from zero\n    long diff = (val == 0) ? 0 : val - int(val);\n    // Get differences\
    \ between two ints\n    long diff2 = val - val;\n    // Check if difference is\
    \ equidistant from both int values\n    if( diff == diff2 )\n    {\n        result\
    \ = val - int(val);\n    }\n    else\n    {\n        // Round it away from zero\n\
    \        if( diff < 0 )\n        {\n            result = (int)( val - diff2 );\n\
    \        }\n        else\n        {\n            result = (int)( val + diff2 );\n\
    \        }\n    }\n    \n    // Check for edge case\n    if( result < 0 )\n  \
    \  {\n        result = result + val + 1;\n    }\n    else if( result > val )\n\
    \    {\n        result = result - val - 1;\n    }\n    \n    return result;\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| a dscore=3 |>\nThe accepted answer was a good\
    \ one, but I took it a step further and decided that I wasn't happy with having\
    \ to convert back and forth between strings and ints and longs all the time. I\
    \ had already written a to_int() function, so I just added an overload to to_long(),\
    \ and that worked:\n<code>\nstring to_string(int value)\n{\n    return to_string(static_cast<long>(value));\n\
    }", "{\n    long value;\n    long distance;\n    string a = (long) std.string.length(value)\
    \ / std.string.length(\"0\");\n    long a2 = (long) std.string.length(a) / 2;\n\
    \    \n    if((int)std.string.length(value) % 2 == 0)\n    {\n        value =\
    \ (long)std.string.sub(value, 0, a2);\n        distance = std.typecons.abs((long)(value\
    \ - std.string.length(value)) / std.string.length(\"0\"));\n    }\n    else\n\
    \    {\n        value = (long)std.string.sub(value, a2);\n        distance = std.typecons.abs((long)(value\
    \ - std.string.length(value)) / std.string.length(\"0\"));\n    }\n    \n    std.string.repeat(\"\
    0\", (int)distance).write(value, 0, (int)(std.string.length(value) - (int)distance));\n\
    \    \n    return value;\n}\n</code>\n<|/ a tags=string,c++ |>\n<| c |>\nThis\
    \ isn't correct. Try `closest_integer(\"1245\")` for example.\n<|/ c |>\n<| c\
    \ |>\n.: Oh, I see. So it isn't an ideal function, but rather a first pass at\
    \ a solution. The closest integer function is actually quite interesting, I didn't\
    \ know you could cast a string to a long. Thanks.\n<|/ c |>\n<| c |>\nThe first\
    \ version of this answer was incorrect. I've updated my answer to fix it, but\
    \ I haven't tested the function.\n<|/ c |>\n<| a tags=string,c++ |>\nSince this\
    \ is C++, I would personally use stoi for the conversion, then use floor to get\
    \ the floor, convert it to a string, and then return the string.\n<code>\n#include\
    \ <cmath>\n#include <string>\n#include <iostream>", "{\n    // write your code\
    \ in C# here\n    return null;\n}\n</code>\n<|/ q |>\n<| a dscore=1 |>\nSo basically\
    \ you want to find the closest integer from a string?  In .NET you can easily\
    \ use a function like Int32.TryParse.  \n<code>\nlong closestInt = -1;\nif (Int32.TryParse(myString,\
    \ out int intResult))\n{\n    closestInt = intResult;\n}\n</code>\n<|/ a tags=c#,math\
    \ |>\n<| c |>\nThis won't work.  It would return false for strings like \"123ABC\"\
    \ which obviously is not an integer\n<|/ c |>\n<| a tags=c#,math |>\nI thought\
    \ about doing it with modulo, but that would be too hard to do if I had a large\
    \ amount of numbers.\nAnyway, I found a way to do it with modulus\n<code>\nstring\
    \ myString = \"10\";\nlong closestInt = -1;\n//Convert myString to a long\nlong\
    \ myLong = Convert.ToInt64(myString);\n//Get a random number", "{\n    long intValue\
    \ = 0L;\n    long int2Value = 0L;\n    long difference = abs(std.math.abs(value\
    \ - intValue));", "{\n\t// TODO: implement me!\n\tlong closest;\n\tif(value.length()\
    \ == 1)\n\t{\n\t\t// Nothing to do\n\t}\n\telse if(value.length() == 2)\n\t{\n\
    \t\t// Both numbers are equal\n\t\tif(value == value.substr(1))\n\t\t{\n\t\t\t\
    // Round away from zero\n\t\t\tclosest = std.math.round(value.substr(0, 1) - \"\
    0\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tclosest = std.math.round(value.substr(0,\
    \ 1));\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Too many digits, no such integer\n\t\t\
    closest = 0;\n\t}\n\treturn closest;\n}\n/*", "{\n    auto intValue = std.parseNum(value);\n\
    \    if (intValue.value == 0) \n        intValue.value = 1;\n    if (intValue.value\
    \ == 1)\n        intValue.value = 2;\n    if (intValue.value == 2)\n        intValue.value\
    \ = 3;\n    if (intValue.value == 3)\n        intValue.value = 4;\n    if (intValue.value\
    \ == 4)\n        intValue.value = 5;\n    if (intValue.value == 5)\n        intValue.value\
    \ = 6;\n    if (intValue.value == 6)\n        intValue.value = 7;\n    if (intValue.value\
    \ == 7)\n        intValue.value = 8;\n    if (intValue.value == 8)\n        intValue.value\
    \ = 9;\n    if (intValue.value == 9)\n        intValue.value = 10;\n    if (intValue.value\
    \ == 10)\n        intValue.value = 11;\n    if (intValue.value == 11)\n      \
    \  intValue.value = 12;\n    if (intValue.value == 12)\n        intValue.value\
    \ = 13;\n    if (intValue.value == 13)\n        intValue.value = 14;\n    if (intValue.value\
    \ == 14)\n        intValue.value = 15;\n    if (intValue.value == 15)\n      \
    \  intValue.value = 16;\n    if (intValue.value == 16)\n        intValue.value\
    \ = 17;\n    if (intValue.value == 17)\n        intValue.value = \"NaN\";\n  \
    \  if (intValue.value == 18)\n        intValue.value = \"Infinity\";\n    if (intValue.value\
    \ == 19)\n        intValue.value = \"-Infinity\";\n    return intValue.value;\n\
    }", "{\n    return std.math.round(std.typecons.float(value));\n}", "{\n    long\
    \ val;\n    if (value.empty())\n    {\n        throw runtime_error(\"value cannot\
    \ be empty\");\n    }\n    if (value.size()==1)\n    {\n        val = std.atoi(value.c_str());\n\
    \    }\n    else\n    {\n        val = std.atoi(value.c_str())-1;\n    }\n   \
    \ long closest=numeric_limits<long>::min();\n    long farthest=numeric_limits<long>::max();\n\
    \    if (val<closest)\n        closest=val;\n    if (val>farthest)\n        farthest=val;\n\
    \    return (closest+farthest)/2;\n}", "{\n    long low, high, mid;\n    bool\
    \ even;\n    double float_value, value_as_double;", "{\n    long i;", "{\n   \
    \ long low = std.strtolong(value);\n    long high = std.strtolong(value);\n  \
    \  \n    if (low > high)\n    {\n        return std.strtolong(value) + 1;\n  \
    \  }\n    \n    std.assert(low != 0);\n    std.assert(high != 0);\n    \n    long\
    \ mid = std.strtolong(value);\n    \n    if (mid == 0)\n    {\n        return\
    \ mid;\n    }\n    \n    long midDiff = high - mid;\n    \n    std.assert(midDiff\
    \ > 0);\n    \n    std.assert(mid != 0);\n    \n    long midDiffSqrt = std.sqrt(midDiff);\n\
    \    \n    long midDiffFloor = std.floor(midDiffSqrt);\n    \n    long midDiffCeil\
    \ = std.ceil(midDiffSqrt);\n    \n    std.assert(midDiffFloor < midDiffCeil);\n\
    \    \n    if (midDiffCeil == midDiffFloor)\n    {\n        return mid;\n    }\n\
    \    \n    long midCeil = std.strtolong(value);\n    \n    if (midCeil == 0)\n\
    \    {\n        return mid;\n    }\n    \n    long midCeilDiff = high - midCeil;\n\
    \    \n    std.assert(midCeilDiff > 0);\n    \n    if (midCeilDiff == midDiffFloor)\n\
    \    {\n        return midCeil;\n    }\n    \n    long midFloor = std.strtolong(value);\n\
    \    \n    if (midFloor == 0)\n    {\n        return mid;\n    }\n    \n    long\
    \ midFloorDiff = high - midFloor;\n    \n    std.assert(midFloorDiff > 0);\n \
    \   \n    if (midFloorDiff == midDiffFloor)\n    {\n        return midFloor;\n\
    \    }\n    \n    long diff;\n    \n    if (midDiffFloor < midDiffCeil)\n    {\n\
    \        diff = midDiffFloor;\n    }\n    else\n    {\n        diff = midDiffCeil;\n\
    \    }\n    \n    if (midCeilDiff < midDiffFloor)\n    {\n        diff += midCeilDiff;\n\
    \    }\n    else\n    {\n        diff += midDiffFloor;\n    }\n    \n    std.assert(diff\
    \ > 0);\n    \n    return low + diff;\n}", "{\n  int ind = find_nearest_index(value.c_str(),\
    \ numbers);\n  long n = numbers[ind];\n  long nextn = numbers[ind+1];\n  if (nextn\
    \ != 0L && abs(value - n) < abs(value - nextn)) {\n    return nextn;\n  }\n  return\
    \ n;\n}\n/*\n    Create a function that takes a value (string) representing a\
    \ number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.", "{\n\tlong val = 0;\n\tbool\
    \ isNegative = false;\n\tlong closest = 0;\n\tif (isNegative = value.startswith(\"\
    -\"))\n\t{\n\t\tval = std.parseLong(value.substring(1).replace(\"-\",\"\"));\n\
    \t}\n\telse\n\t{\n\t\tval = std.parseLong(value);\n\t}", "{\n    long closest;\n\
    \    if (value.find('.') == -1)\n        throw new IllegalArgumentException(\"\
    Invalid integer format\");\n    string val1 = value.substring(0, value.find('.'));\n\
    \    string val2 = value.substring(value.find('.') + 1);\n    double d1 = std.stod(val1);\n\
    \    double d2 = std.stod(val2);\n    double d = d1 - d2;\n    if (d == 0)\n \
    \   {\n        closest = (long)std.sqrt(d1 * d1 + d2 * d2);\n    }\n    else\n\
    \    {\n        closest = std.round(d * 1000) / 1000;\n    }\n    if (closest\
    \ < 0)\n        closest = 0;\n    return closest;\n}\n/*", "{\n\tlong intValue\
    \ = 0;\n\ttry {\n\t\tintValue = (long) std.atoi(value);\n\t}\n\tcatch (invalid_argument\
    \ e) {\n\t\tcout << \"Invalid argument passed\\n\";\n\t\treturn 0L;\n\t}\n\tif\
    \ (intValue == 0) return 0L;\n\tstd.sort([value](long x, long y){return abs(x\
    \ - y) < 10;});\n\treturn intValue - (intValue % 10L);\n}\n/*", "{\n\tif (value.length()\
    \ != 1ul)\n\t{\n\t\tthrow new ArgumentOutOfRangeException(\"value\");\n\t}", "{\n\
    \    return std.math.round(std.math.abs(std.math.toLong(value)));\n}", "{\n  \
    \  long num;\n    if (value.empty())\n        throw new Exception(\"Closest integer\
    \ needs a non-empty value\");\n    long numVal = std.string.toLong(value);\n \
    \   if (numVal < 0)\n        numVal = -numVal;\n    double d = abs(numVal);\n\
    \    double smallest;\n    double largest;\n    if (d > 0.1) {\n        smallest\
    \ = numVal / 2;\n        largest = (numVal * 2) - smallest;\n    } else {\n  \
    \      smallest = numVal;\n        largest = numVal * 2;\n    }\n    long ans\
    \ = smallest;\n    while (largest-smallest > 0.1) {\n        double d = (largest\
    \ - smallest) / 2.0;\n        if (d < 0.0) break;\n        long tmp = (long)smallest+d;\n\
    \        if (std.math.abs(tmp - numVal) < 0.1) {\n            ans = tmp;\n   \
    \         break;\n        }\n        ans = tmp;\n        smallest = tmp;\n   \
    \     largest = (tmp * 2) - smallest;\n    }\n    return ans;\n}", "{\n    return\
    \ long.parse(value); \n}", "{\n\tlong lnum;\n\tlong ldiff;\n\tint ival;", "{\n\
    \tlong i;\n\tlong minI;\n\tdouble dvalue;\n\t\n\t//split string by '.'\n\tvector<string>\
    \ numbers = split(value, \".\");\n\t\n\t//check for single or no digits\n\tif\
    \ (numbers.size() < 2)\n\t\treturn 0L;", "{\n    long x;\n    long y;", "{\n \
    \   long x;\n    if ( value.empty() )\n        throw new runtime_error(\"Empty\
    \ string!\");\n    x = std.string.toLong(value);\n    if ( x == std.long.MIN_VALUE\
    \ )\n        throw new runtime_error(\"Number is too small to fit in a long!\"\
    );\n    while ( x > std.long.MAX_VALUE )\n    {\n        x -= std.long.MAX_VALUE;\n\
    \        x += std.long.MAX_VALUE;\n    }\n    x -= std.long.MIN_VALUE;\n    return\
    \ x;\n}\n/*", "{\n    long number;\n    double doubleNumber;\n    \n    number\
    \ = strtol(value.c_str(), nullptr, 10);\n    doubleNumber = std.typecons.toDouble(number);\n\
    \    \n    if (doubleNumber == 0) {\n        return 0;\n    } else {\n       \
    \ long closest = (long) std.math.trunc(doubleNumber);\n        return closest;\n\
    \    }\n}\n*/\n</code>\nThis code uses the following library:\n<code>\n#include\
    \ <cstdlib>\n#include <cstdint>\n#include <cmath>\n#include <string>\n#include\
    \ <typecons>\n#include <math.h>\n</code>\n<|/ a tags=c,integer,floating-point,string\
    \ dscore=1 |>\n<| c |>\nThe example in your code outputs 15 when the input is\
    \ 15.5. Not sure if that's what you wanted.\n<|/ c |>\n<| c |>\nI have tested\
    \ it and it outputs 15. That's why I said I didn't know if the rounding was wanted.\n\
    <|/ c |>\n<| c |>\nThank you for the update. I think that will work well enough.\
    \ I don't know what will happen when floating point numbers are very close to\
    \ integers. I'm going to try a few test cases and see if I come up with some edge\
    \ cases.\n<|/ c |>\n<| c |>\nJust realized that your example does not work for\
    \ this problem: closest_integer(\"15.5\") returns 15. closest_integer(\"15.3\"\
    ) returns 15. closest_integer(\"15\") returns 15. closest_integer(\"14.75\") returns\
    \ 15. closest_integer(\"14.75.1\") returns 15. closest_integer(\"14.75.01\") returns\
    \ 15.\n<|/ c |>\n<| c |>\nYeah, it returns 15 for the first two examples. It only\
    \ works on numbers that are equidistant from two integers. But you are right,\
    \ it doesn't work for \"14.75.01\" because it is equidistant from both \"14\"\
    \ and \"15\".\n<|/ c |>\n<| a tags=c,integer,floating-point,string |>\n<code>\n\
    #include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>",
  "{\n    long result;\n    \n    /*\n    Convert string value to a number\n    */\n\
    \    double num = std.toNumber(value);\n    /*\n    Check whether the given number\
    \ is equidistant from two integers\n    */\n    if (std.typecons.isPowerOfTwo(std.math.abs(num)))\n\
    \    {\n        /*\n        If the number is equidistant from two integers, round\
    \ it away from zero.\n        */\n        result = std.math.roundTowardZero(num);\n\
    \    }\n    else\n    {\n        /*\n        If the number is equidistant from\
    \ two integers, round it towards zero.\n        */\n        result = std.math.roundTowardZero(num);\n\
    \    }\n    \n    /*\n    Convert back to string\n    */\n    return std.string.ofValue(result,\
    \ std.string.chars);\n}\n/*\nEnd closest_integer", "{\n    int factor;\n    string\
    \ stringValue;\n    double doubleValue;\n    long newValue;\n    bool isNegative;\n\
    \    \n    isNegative = (value.StartsWith(\"-\"));\n    \n    if (value.EndsWith(\"\
    .0\"))\n    {\n        stringValue = value.Substring(value.Length - 1);\n    \
    \    stringValue = stringValue.Substring(0, stringValue.IndexOf(\".\"));\n   \
    \     doubleValue = std.strtod(stringValue.c_str(), nullptr);\n    }\n    else\n\
    \    {\n        stringValue = value;\n        doubleValue = std.strtod(stringValue.c_str(),\
    \ nullptr);\n    }\n    \n    if (doubleValue >= 1.0)\n    {\n        newValue\
    \ = (long)(doubleValue + 0.5);\n    }\n    else\n    {\n        factor = (int)(doubleValue\
    \ * 100.0);\n        while (factor > 100)\n        {\n            factor /= 10;\n\
    \        }\n        factor -= 1;\n        newValue = (long)(factor + 0.5);\n \
    \   }\n    \n    if (isNegative)\n    {\n        newValue = -newValue;\n    }\n\
    \    \n    return newValue;\n}", "{\n    long number;\n    long diff;\n    long\
    \ diff2;\n    string numberAsString = value.toLongString();\n    number = std.strtoul(numberAsString.c_str(),0,10);\n\
    \    diff = abs(number);\n    diff2 = abs(number-1);\n    if(diff == diff2) {\n\
    \        return number;\n    } else {\n        string roundTo;\n        if (diff\
    \ > diff2) {\n            roundTo = \"L\";\n        } else {\n            roundTo\
    \ = \"LL\";\n        }\n        return std.strtoul(numberAsString.c_str(),0,10)+\
    \ roundTo;\n    }\n}\n*/\nlong closest_integer(string value) \n{\n    long number;\n\
    \    long diff;\n    long diff2;\n    string numberAsString = value.toLongString();\n\
    \    number = std.strtoul(numberAsString.c_str(),0,10);\n    diff = abs(number);\n\
    \    diff2 = abs(number-1);\n    if(diff == diff2) {\n        return number;\n\
    \    } else {\n        string roundTo;\n        if (diff > diff2) {\n        \
    \    roundTo = \"L\";\n        } else {\n            roundTo = \"LL\";\n     \
    \   }\n        return roundTo;\n    }\n}", "{\n    long l= std.typecons.toLong(value);\n\
    \    long a= std.math.min(l,1);\n    long b= std.math.max(l,1);\n    a= std.math.mod(a,b);\n\
    \    return a;\n}", "{\n\tlong i, mid;\n\t\n\tlong closest = 0;\n\tlong a = atol(value);\n\
    \tlong b = atoi(value.substr(1));\n\t\n\tif (a == b) \n\t\treturn a;\n\t\n\tmid\
    \ = a + (b-a)/2;\n\tif (a >= 0 && a < mid) \n\t\tclosest = mid;\n\tif (b >= 0\
    \ && b < mid) \n\t\tclosest = mid;\n\t\n\tif (closest == a) \n\t\tclosest = atol(value.substr(2));\n\
    \tif (closest == b) \n\t\tclosest = atol(value.substr(2));\n\t\n\treturn closest;\n\
    }", "{\n    long number = std.strtoll(value, &endptr);\n    if( endptr != value.end()\
    \ )\n        throw \"Error\";\n    if( number < 0 )\n    {\n        if( number\
    \ == -number )\n            return -number;\n        else\n            throw \"\
    Error\";\n    }", "{\n    long diff;", "{\n  long i;\n  long min = std::numeric_limits<long>::max();\n\
    \  long max = std::numeric_limits<long>::min();\n  \n  istringstream iss(value);\n\
    \  \n  while(!iss.eof()) {\n    iss >> i;\n    if(i == 0) break;\n    \n    if(i\
    \ == max) {\n      max = i;\n    }\n    \n    if(i == min) {\n      min = i;\n\
    \    }\n  }\n  \n  if(max == min) {\n    long rounded = min + 1;\n    \n    if(std::numeric_limits<long>::max()\
    \ == rounded) {\n      return min;\n    }\n    \n    return rounded;\n  }\n  \n\
    \  return max;\n}", "{\n    string first;\n    string second;\n    long diff;\n\
    \    long closest = 0;\n    string number;", "{\n    long long result = 0;\n \
    \   stringstream ss(value);\n    \n    while(!ss.eof())\n    {\n        ss >>\
    \ result;\n        \n        if(result == value)\n            break;\n    }\n\
    \    \n    if(result == value)\n    {\n        result -= 1;\n    }\n    \n   \
    \ return result;\n}", "{\n    if (value.length() >= 2) {\n        long min = Long.MAX_VALUE;\n\
    \        long max = Long.MIN_VALUE;\n        string numbers[] = value.split(\"\
    \\\\.\");\n        string first = numbers[0];\n        long firstValue = std.parseLong(first);\n\
    \        long secondValue = std.parseLong(numbers[1]);\n        long difference\
    \ = secondValue - firstValue;\n        long closestValue = firstValue;\n     \
    \   if (difference < 0) {\n            difference = -difference;\n           \
    \ closestValue = -firstValue;\n        }\n        \n        for (int i = 1; i\
    \ < numbers.length; ++i) {\n            string next = numbers[i];\n          \
    \  long nextValue = std.parseLong(next);\n            long difference = nextValue\
    \ - closestValue;\n            if (difference > 0 && difference < min) {\n   \
    \             min = difference;\n                closestValue = nextValue;\n \
    \           }\n            if (difference < 0 && difference > max) {\n       \
    \         max = difference;\n                closestValue = nextValue;\n     \
    \       }\n        }\n        long result = closestValue + min;\n        if (std.abs(result)\
    \ < Long.MIN_VALUE) result = -result;\n        return result;\n    }\n    return\
    \ 0;\n}\n</code>\n<|/ a tags=string,integer,python-3.x,python,parsing |>\n<| a\
    \ |>\nThis answer is more of a comment than an answer but I do not have enough\
    \ reputation to add a comment.\n<code>\nimport re\ndef closestToNumber(numStr,numList):\n\
    \    match = re.search('(\\d+\\.\\d+)|(\\-?\\d+\\.?\\d+)\\.?$',numStr)\n    if\
    \ match:\n        a,b = map(lambda x: re.sub('(\\-?\\d+\\.?\\d+)\\.?$','',x),match.groups())\n\
    \        a,b = float(a),float(b)\n        lst = sorted(numList,key=lambda x:abs(x-a))\n\
    \        return lst[abs(numList.index(lst[len(lst)-1])+b)/a]\n    return 0\n</code>\n\
    <|/ a tags=string,integer,python-3.x,python,parsing dscore=1 |>\n<| a dscore=1\
    \ tags=string,integer,python-3.x,python,parsing |>\nI really like this solution:\n\
    <code>\nimport re\ndef closestToNumber(numStr, numList):\n    match = re.search('(\\\
    d+\\.\\d+)|(\\-?\\d+\\.?\\d+)\\.?$', numStr)\n    if match:\n        a, b = map(lambda\
    \ x: re.sub('(\\-?\\d+\\.?\\d+)\\.?$', '', x), match.groups())\n        a, b =\
    \ float(a), float(b)\n        return min(numList, key=lambda x: (abs(x - a), abs(x\
    \ - b)))\n    return 0\n</code>\nIt also works if you have a ", "{\n    long n\
    \ = std.atoi(value);\n    // if number is equidistant from two integers, round\
    \ it away from zero\n    if (n < 0)\n        return -n;\n    // if number is within\
    \ 1 or 2 of integer zero, return it\n    if ((n / abs(n)) <= 2)\n        return\
    \ n;\n    // if number is within 3 or 4 of the integer, round it away from zero\n\
    \    if (n < 3)\n        return std.ctoi(-n);\n    // otherwise, return an integer\
    \ that is equidistant from two integers\n    long roundValue = std.ctoi(-n) +\
    \ 1;\n    return std.ctoi(-roundValue) + 1;\n}\n/*", "{\n    return std.math.round(std.math.toDouble(value));\n\
    }", "{\n    long intvalue = tointeger(value);\n    \n    // If it is equidistant\
    \ from two integers, round it away from zero\n    if (intvalue == tointeger(floor(value)))\
    \ \n    {\n        float f = tofloat(value);\n        long value = floor_float(tointeger(floor(f)));\n\
    \        if (value == tointeger(floor(f))) \n        {\n            return tointeger(f);\n\
    \        }\n    }\n    \n    return intvalue;\n}", "{\n\tlong diff = 0;\n\tlong\
    \ a = toLong(value.c_str());\n\tif (a >= 0)\n\t{\n\t\tlong b = a + 1;\n\t\twhile\
    \ (b <= a)\n\t\t{\n\t\t\tdiff += toLong((string(\"000\") + toString(b)).c_str());\n\
    \t\t\tb++;\n\t\t}\n\t}\n\telse\n\t{\n\t\tlong b = 0;\n\t\twhile (a >= b)\n\t\t\
    {\n\t\t\tdiff += toLong((string(\"000\") + toString(a)).c_str());\n\t\t\tb++;\n\
    \t\t}\n\t}\n\tlong diff2 = diff - 1;\n\treturn (toLong((string(\"000\") + toString(diff2)).c_str()));\n\
    }", "{\n    int intValue = 0;\n    long doubleValue = 0;\n    float floatValue\
    \ = 0;\n    double doubleValue = 0;\n    bool isNegative = false;\n    bool isPositive\
    \ = false;\n    bool isInteger = false;\n    bool isDouble = false;", "{\n  //\
    \ TODO: Implement function\n  long result = 0;\n  string num = value;\n  long\
    \ max_int = numeric_limits<long>::max();\n  long min_int = numeric_limits<long>::min();\n\
    \  double max = (double) max_int;\n  double min = (double) min_int;\n  bool flag\
    \ = false;\n  double valueDouble = 0;\n  double numDouble = 0;\n  if(num.find(\"\
    .\") != -1)\n  {\n    numDouble = std.strtod((num.c_str()), &valueDouble);\n \
    \ }\n  else\n  {\n    numDouble = std.atoi(num.c_str());\n  }\n  int len = numDouble.str().length();\n\
    \  if(len == 2)\n  {\n    if(numDouble-(int)numDouble == 0)\n    {\n      result\
    \ = (long)numDouble;\n    }\n    else\n    {\n      double num2 = numDouble;\n\
    \      numDouble = num - numDouble;\n      valueDouble = std.strtod(num.c_str(),\
    \ &valueDouble);\n      if(numDouble == num2)\n      {\n        result = valueDouble\
    \ - numDouble;\n      }\n      else\n      {\n        while(numDouble-(int)numDouble\
    \ == 0)\n        {\n          numDouble -= 1;\n          valueDouble = std.strtod(num.c_str(),\
    \ &valueDouble);\n          if(numDouble == num2)\n          {\n            result\
    \ = valueDouble - numDouble;\n            break;\n          }\n        }\n   \
    \   }\n    }\n  }\n  else if(len == 3)\n  {\n    if(numDouble-(int)numDouble ==\
    \ 0)\n    {\n      result = (long)numDouble;\n    }\n    else\n    {\n      if(numDouble-(int)numDouble\
    \ == 1)\n      {\n        numDouble -= 1;\n      }\n      valueDouble = std.strtod(num.c_str(),\
    \ &valueDouble);\n      if(numDouble == num2)\n      {\n        result = valueDouble\
    \ - numDouble;\n      }\n      else\n      {\n        while(numDouble-(int)numDouble\
    \ == 1)\n        {\n          numDouble -= 1;\n          valueDouble = std.strtod(num.c_str(),\
    \ &valueDouble);\n          if(numDouble == num2)\n          {\n            result\
    \ = valueDouble - numDouble;\n            break;\n          }\n        }\n   \
    \   }\n    }\n  }\n  else if(len == 4)\n  {\n    if(numDouble-(int)numDouble ==\
    \ 0)\n    {\n      result = (long)numDouble;\n    }\n    else\n    {\n      if(num",
  "{\n\tlong lower = std.math._min_long(std.math._max_long(std.convert.from_string_long(value,\
    \ \"d\"), 0), 0);\n\tlong upper = std.math._min_long(std.math._max_long(std.convert.from_string_long(value,\
    \ \"d\"), 0), 0);\n\t\n\t// If any of our numbers is equidistant, we're done\n\
    \tif (lower == upper)\n\t\treturn lower;\n\t\n\tlong maxDist = std.math._max_long(std.math._abs(lower\
    \ - upper), 0);\n\t\n\t// If the difference between our numbers is smaller than\
    \ the max distance,\n\t// we're done\n\tif (maxDist < std.math._abs(lower - upper))\n\
    \t\treturn lower;\n\t\n\t// Otherwise we recur to find the closest number\n\t\
    return closest_integer(value);\n}", "{\n    int result;", "{\n\tlong result =\
    \ long.MAX_VALUE;", "{\n    long lower = long.parse(value);\n    long higher =\
    \ lower;\n    while (!std.typecons.is_int(higher)) {\n        lower = higher;\n\
    \        higher = long.parse(value.substring(0,value.lastIndexOf(\".\")));\n \
    \   }\n    long diff = abs(lower - higher);\n    long mid = (lower + higher)/2;\n\
    \    while (diff > std.math.abs(mid-lower)) {\n        lower = mid;\n        mid\
    \ = (lower + higher)/2;\n        diff = abs(lower - higher);\n    }\n    while\
    \ (diff > std.math.abs(mid-higher)) {\n        higher = mid;\n        mid = (lower\
    \ + higher)/2;\n        diff = abs(lower - higher);\n    }\n    return mid;\n\
    }\n/*", "{\n    long a = 0;\n    long b = 1;\n    long diff;\n    long closest;\n\
    \    \n    long temp;\n    int sign = +1;\n    \n    bool isNegative = false;\n\
    \    bool isNegativeAsString = false;\n    \n    bool isPositive = false;\n  \
    \  bool isPositiveAsString = false;\n    \n    bool isEven = false;\n    \n  \
    \  bool isOdd = false;\n    \n    bool isDivisibleByTen = false;\n    \n    bool\
    \ isDivisibleByFive = false;\n    \n    bool isDivisibleByThree = false;\n   \
    \ \n    bool isDivisibleByTwo = false;\n    \n    \n    char firstChar = ' ';\n\
    \    char secondChar = ' ';\n    char thirdChar = ' ';\n    char fourthChar =\
    \ ' ';\n    char fifthChar = ' ';\n    \n    long remainder;\n    \n    \n   \
    \ \n    \n    while(true)\n    {\n        \n        if(value == \"\")\n      \
    \  {\n            throw(std::runtime_error(\"Value cannot be null\"));\n     \
    \       \n        }\n        if(value.length() <= 0)\n        {\n            throw(std::runtime_error(\"\
    Value cannot be blank\"));\n            \n        }\n        \n        \n    \
    \    if(isDivisibleByTwo == false)\n        {\n            if(isDivisibleByThree\
    \ == false)\n            {\n                if(isDivisibleByFive == false)\n \
    \               {\n                    if(isDivisibleByTen == false)\n       \
    \             {\n                        if(isDivisibleByFive == false)\n    \
    \                    {\n                            if(isDivisibleByThree == false)\n\
    \                            {\n                                if(isDivisibleByTwo\
    \ == false)\n                                {\n                             \
    \       if(isDivisibleByTen == false)\n                                    {\n\
    \                                        if(isDivisibleByFive == false)\n    \
    \                                    {\n                                     \
    \       if(isDivisibleByThree == false)\n                                    \
    \        {\n                                                if(isDivisibleByTwo\
    \ == false)\n                                                {\n             \
    \                                       if(isDivisibleByTen == false)\n      \
    \                                              {\n                           \
    \                             if(isDivisibleByFive == false)\n               \
    \                                         {\n                                \
    \                            if(isDivisibleByThree == false)\n               \
    \                                             {\n                            \
    \                                    if(isDivisibleByTwo == false)\n         \
    \                                                       {\n                  \
    \                                                  if(isDivisibleByTen == false)\n\
    \                                                                    {\n     \
    \                                                                   if(isDivisibleByFive\
    \ == false)\n                                                                \
    \        {\n                                                                 \
    \           if(isDivisibleByThree == false)\n                                \
    \                                            {\n                             \
    \                                                   if(isDivisible", "{\n    auto\
    \ [d, e, f] = parse!( value );\n    if ( d == e || d == f )\n        return d;\n\
    \    auto const d = d - e;\n    if ( d > 0 )\n        return f + d;\n    return\
    \ e + d;\n}\n/*", "{\n    long num;\n    long diff = abs( toLong(value) );\n \
    \   if (diff == 0)\n        return toLong(value);\n    float fnum = (float)toLong(value);\n\
    \    long floorNum = fnum/((float)num+1);\n    return floorNum*(num+1);\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| a dscore=3 |>\nHere is my solution using std::next, std::nextl\
    \ and std::prev for c++11:\n<code>\nlong closestNum(long x) {\n    long long lower\
    \ = std::nextl(x);\n    long long upper = std::prev(x);", "{\n    auto [lower,\
    \ upper] = parse_integer_range(value);\n    \n    if(upper - lower == 1)\n   \
    \ {\n        return lower;\n    }\n    \n    auto [min, max] = parse_integer_range(std::to_string(lower).substr(1)\
    \ + \n                                          \"L\" + std::to_string(upper).substr(1));",
  "{\n    auto svalue = to_long(value);", "{\n    long num;\n    long factor;\n  \
    \  long min;\n    long max;\n    bool negative;", "{\n    long result;\n    double\
    \ numberToDouble = std.string(value).asDouble();\n    if (numberToDouble == numberToDouble)\
    \ {\n        result = numberToDouble;\n    } else {\n        result = std.intmax(numberToDouble);\n\
    \    }\n    return result;\n}", "{\n\tint closest_int = 0;\n\tint closest_diff\
    \ = 0;\n\tlong closest_number = long(0);\n\tlong last_int = long(0);\n\tlong last_diff\
    \ = long(0);\n\tdouble doubleValue = 0;\n\t\n\tif (isNumeric(value)) {\n\t\tdoubleValue\
    \ = std.math.parseDouble(value);\n\t} else {\n\t\tdoubleValue = 0;\n\t}\n\t\n\t\
    foreach(char c in value) {\n\t\tint intValue = char2int(c);\n\t\tint diff = doubleValue\
    \ - intValue;\n\t\tint lastdiff = diff - last_diff;\n\t\tint lastintValue = intValue\
    \ - last_int;\n\t\t\n\t\tif (diff > 0) {\n\t\t\tclosest_int = intValue;\n\t\t\t\
    closest_diff = diff;\n\t\t\tlast_int = intValue;\n\t\t\tlast_diff = diff;\n\t\t\
    } else if (diff < 0 && lastintValue == 0) {\n\t\t\tclosest_int = -intValue;\n\t\
    \t\tclosest_diff = diff;\n\t\t\tlast_int = -intValue;\n\t\t\tlast_diff = diff;\n\
    \t\t} else if (diff == 0) {\n\t\t\tif (lastdiff == 0) {\n\t\t\t\tclosest_int =\
    \ intValue;\n\t\t\t\tclosest_diff = diff;\n\t\t\t\tlast_int = intValue;\n\t\t\t\
    \tlast_diff = diff;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (closest_int == 0) {\n\t\t\
    return closest_number;\n\t} else {\n\t\treturn closest_int + closest_diff;\n\t\
    }\n}", "{\n    long v1 = std.parseLong(value);\n    long v2 = std.parseLong(getAttr(value,\
    \ \"closest\"));\n    long diff = v1-v2;\n    if (diff < -std.INT32MAX) return\
    \ v1;\n    if (diff > std.INT32MAX) return v2;\n    if (diff == 0)\n    {\n  \
    \      long temp=v1+std.parseLong(getAttr(value, \"step\"));\n        if (temp\
    \ > v2) return temp;\n        else\n        {\n            if (v1 < 0) return\
    \ v2;\n            else return v1;\n        }\n    }\n    else\n    {\n      \
    \  if (diff < 0) return v2;\n        else\n        {\n            if (v1 < 0)\
    \ return v1;\n            else return v2;\n        }\n    }\n    \n}\n/*", "{\n\
    \    long low = 0;\n    long high = (long)(std.math.remainder(std.math.toInt(value),\
    \ std.math.abs(value)));\n    string lowString = to_string(low);\n    string highString\
    \ = to_string(high);\n    \n    if (lowString == \"0\" & highString == \"0\")\
    \ return low;\n    if (lowString == \"0\" & highString != \"0\") return high;\n\
    \    if (lowString != \"0\" & highString == \"0\") return low;\n    if (lowString\
    \ != \"0\" & highString != \"0\") return high;\n    \n    int comparison = compare(value,\
    \ to_string(low));\n    if (comparison != 0) return low;\n    \n    comparison\
    \ = compare(value, to_string(high));\n    if (comparison != 0) return high;\n\
    \    \n    return low;\n}", "{\n    long result;\n    double d = std.parsedouble(value);\n\
    \    if (std.isIntegral(d)) \n    {\n        // We're close to two integers\n\
    \        long min = -std.typecons.maxint64 - std.typecons.minint64;\n        long\
    \ max = std.typecons.maxint64 - std.typecons.minint64;\n        if (std.typecons.greaterthan(d,\
    \ min)) \n        {\n            result = min;\n        } \n        else if (std.typecons.lessthan(d,\
    \ max)) \n        {\n            result = max;\n        } \n        else \n  \
    \      {\n            result = std.typecons.roundtowardzero(d);\n        }\n \
    \   } \n    else \n    {\n        // We're close to one integer\n        long\
    \ min = -std.typecons.maxint64 - std.typecons.minint64;\n        long max = std.typecons.maxint64\
    \ - std.typecons.minint64;\n        if (std.typecons.greaterthan(d, std.typecons.trunc(min)))\
    \ \n        {\n            result = min;\n        } \n        else if (std.typecons.lessthan(d,\
    \ std.typecons.trunc(max))) \n        {\n            result = max;\n        }\
    \ \n        else \n        {\n            result = std.typecons.roundtowardzero(d);\n\
    \        }\n    }\n    return result;\n}", "{\n    // Your code here!\n    long\
    \ result;\n    char firstValue = '0';\n    char secondValue = '0';\n    long firstValueResult\
    \ = 0;\n    long secondValueResult = 0;\n    float valueAsFloat = std.typecons.float(value);\n\
    \    std.math.clamp(valueAsFloat, 0, 1);\n    std.math.floor_divide(valueAsFloat,\
    \ 1);\n    long resultAsLong = std.math.round(valueAsFloat);\n    if (std.math.abs(resultAsLong\
    \ - 1) < std.math.abs(resultAsLong + 1))\n    {\n        firstValue = value[0];\n\
    \        secondValue = value[1];\n        firstValueResult = std.math.abs(firstValueResult\
    \ + 1);\n        secondValueResult = std.math.abs(secondValueResult + 1);\n  \
    \  }\n    else\n    {\n        firstValue = value[1];\n        secondValue = value[0];\n\
    \        firstValueResult = std.math.abs(firstValueResult + 1);\n        secondValueResult\
    \ = std.math.abs(secondValueResult + 1);\n    }\n    if (resultAsLong > firstValueResult)\n\
    \    {\n        result = firstValue;\n    }\n    else if (resultAsLong < secondValueResult)\n\
    \    {\n        result = secondValue;\n    }\n    else\n    {\n        result\
    \ = resultAsLong;\n    }\n    return result;\n}\n</code>\n<|/ a tags=string,c++,arrays\
    \ |>\n<| a tags=string,c++,arrays dscore=0 |>\nI wrote a solution for my homework.\
    \ Since you asked, here is my solution :\n<code>\n#include <iostream>\n#include\
    \ <string>\n#include <cstring>", "{\n    long lValue = (long)std.parse(value);\n\
    \    if (lValue == 0)\n        lValue = (long)std.parse(\"-\" + value);\n    long\
    \ lClosest = lValue;\n    if (lValue - lClosest >= lValue + lClosest)\n      \
    \  lClosest += 1;\n    return lClosest;\n}", "{\n\tlong result;\n\tlong[] values\
    \ = {1L};\n\t\n\tforeach(long x in values)\n\t{\n\t\tif(value == x)\n\t\t\treturn\
    \ x;\n\t\t\n\t\tif(math.abs(value - x) < math.abs(value - x) / 2)\n\t\t{\n\t\t\
    \tresult = x;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn result;\n}", "{\n\tlong\
    \ number = 0;\n\tlong maxDistance = distance(number);\n\tbool isNegative = value.startsWith(\"\
    -\");\n\tstring numberAsString = toLong(value);\n\tlong firstNumber = toLong(numberAsString.substr(1,1));\n\
    \tlong secondNumber = toLong(numberAsString.substr(0,1));", "{\n    long low =\
    \ 0;\n    long high = numeric_limits<long>::max();", "{\n    auto result = to_long(value);\n\
    \    auto min = (result == 0 ? 0 : result + 1);\n    auto max = (result == (long)INT_MAX\
    \ / 2) ? (long)INT_MAX : result;\n    return round_away_from_zero(min, max);\n\
    }", "{\n    long closest;\n    long min = ~0L;\n    long max = ~0L;", "{\n\tstring\
    \ strValue = value;\n\tlong val = 0;\n\tint pos;\n\tchar firstChar, secondChar;\n\
    \tbool neg = false;\n\t\n\t// Check if string is a valid number.\n\tif (!string_to_long(strValue,\
    \ &val)) {\n\t\treturn 0L;\n\t}", "{\n    if(value.length() < 2) return 0;\n \
    \   int first;\n    long second = strtoll(value.c_str(), &first);\n    if(second\
    \ == 0) return first;\n    \n    long difference = second - first;\n    long rounding;\n\
    \    if(abs(difference) <= LONG_MAX / 2) return first;\n    if(abs(difference)\
    \ > LONG_MAX / 2) difference = difference * (LONG_MAX / abs(difference));\n  \
    \  rounding = difference - floorl(difference);\n    \n    if(rounding < -LONG_MAX\
    \ / 2) return first;\n    if(rounding > LONG_MAX / 2) rounding = rounding * (-LONG_MAX\
    \ / abs(rounding));\n    \n    long result = (first+rounding);\n    long remainder\
    \ = result % first;\n    \n    if(remainder == 0) return result;\n    else if(remainder\
    \ > 0) return first+(remainder+1);\n    else return first+(remainder-1);\n}\n\
    /*", "{\n    long l = 0;\n    long x = std.string.toLong(value);\n    \n    if\
    \ (x == 0) \n    {\n        throw new Exception(\"The string given is not numeric\"\
    );\n    }\n    \n    if (x < 0) \n    {\n        throw new Exception(\"The string\
    \ given is negative number\");\n    }\n    \n    long y = (long) ((x - 1) * ((long)(x)));\n\
    \    \n    if (y > l) \n    {\n        l = y;\n    }\n    \n    return l;\n}\n\
    </code>\n<|/ a dscore=0 tags=c#,vb.net |>\n<| a |>\nI got one more solution in\
    \ C# using extension method. \n<code>\npublic static class StringExtensions\n\
    {\n    public static long ParseToLong(this string str, long defaultValue = 0,\
    \ bool isNegative = false)\n    {\n        if (!int.TryParse(str, out var intValue))\n\
    \        {\n            return defaultValue;\n        }", "{\n  long l = 0;\n\
    \  int index = 0;\n  int n = value.size();\n  for(int i=0; i<n; i++)\n  {\n  \
    \  if(value[i] == '.') \n    {\n      if(index != n-1)\n      {\n        if(value[index]\
    \ == value[i]) \n        {\n          l++;\n        } \n      }\n      else\n\
    \      {\n        l++;\n      }\n      index = i+1;\n    }\n  }\n  return l;\n\
    }\n</code>\n<|/ a tags=c++ |>\n<| a |>\nAnother way of doing it without using\
    \ a function?\n<code>\n#include <iostream>\nusing namespace std;", "{\n    //\
    \ your code here\n    \n    if ( value == \"\") return 0L;\n    long result;\n\
    \    \n    if (value[0] == '-') // handle negative numbers\n    {\n        char[]\
    \ negativeArray = value.toCharArray();\n        negativeArray[1] = negativeArray[1]\
    \ == '-' ? '0' : '1';\n        char[] newArray = new char[negativeArray.length];\n\
    \        for (int i = 0; i < negativeArray.length; i++)\n            newArray[i]\
    \ = negativeArray[i];\n        value = newArray.toString();\n    }\n    \n   \
    \ int start = 0;\n    int end = 0;\n    int length = value.length();\n    long\
    \ lastDigit;\n    double lastDigitized = value.substring(end,end+1);\n    double\
    \ currentDigitized = value.substring(start,end+1);\n    \n    while (start <=\
    \ length-1)\n    {\n        int digit = value.substring(start,start+1);\n    \
    \    int currentDigit = currentDigitized;\n        double nextDigit;\n       \
    \ double currentDigitized = value.substring(start,start+1);\n        double currentDivisedWithPrevious\
    \ = currentDigitized/lastDigitized;\n        \n        if (digit == '.' || digit\
    \ == '-' || digit == '+')\n        {\n            \n            if (currentDigitized\
    \ > currentDivisedWithPrevious)\n            {\n                \n           \
    \     double difference = currentDigitized - currentDivisedWithPrevious;\n   \
    \             double modulus = Math.pow(10,digit);\n                long roundDifference\
    \ = Math.round(difference/modulus)*modulus;\n                long roundValue =\
    \ roundDifference + lastDigit;\n                \n                long roundedValue\
    \ = (long) roundValue;\n                \n                if (roundedValue > result\
    \ )\n                {\n                    result = roundedValue;\n         \
    \       }\n            }\n            else\n            {\n                long\
    \ roundDifference = Math.round(currentDivisedWithPrevious/10)*10;\n          \
    \      long roundValue = roundDifference + lastDigit;\n                long roundedValue\
    \ = (long) roundValue;\n                \n                if (roundedValue > result\
    \ )\n                {\n                    result = roundedValue;\n         \
    \       }\n            }\n            \n            currentDigitized = value.substring(start,start+1);\n\
    \            lastDigit = currentDigitized;\n            lastDigitized = currentDivisedWithPrevious;\n\
    \            start++;\n        }\n        else\n        {\n            if (digit\
    \ == '0' )\n            {\n                long roundValue = lastDigit + 1;\n\
    \                long roundedValue = (long) roundValue;\n                \n  \
    \              if (roundedValue > result )\n                {\n              \
    \      result = roundedValue;\n                }\n                ", "{\n    long\
    \ x;\n    double y; \n    bool isNegative = false;\n    if(value.StartsWith(\"\
    -\"))\n    {\n        isNegative = true;\n        value = value.Substring(1);\n\
    \    }\n    x = std.to!long(value);\n    y = floor(x);\n    if(isNegative) y =\
    \ -y;\n    return y;\n}", "{\n    auto digits = std.string(value).chars();", "{\n\
    \tint diff = 0;\n\tint cur = std.int.rep(0);\n\tint last = std.int.rep(0);\n\t\
    \n\tforeach(char c, value) \n\t{\n\t\tchar curChar = std.toupper(c);\n\t\t\n\t\
    \tif(curChar == '.' || curChar == '-') continue;\n\t\t\n\t\tif(!std.is.digit(c))\
    \ continue;\n\t\t\n\t\tdiff = std.string.length(value, cur) - std.string.length(value,\
    \ last);\n\t\t\n\t\tif(diff > 0) curChar = curChar - '0';\n\t\tif(diff < 0) curChar\
    \ = curChar + '0';\n\t\t\n\t\tcur = std.parseInt(\"0\" + curChar, 10);\n\t\tlast\
    \ = cur;\n\t}\n\t\n\treturn cur;\n}", "{\n    auto f = std.function0<long()>([value]\
    \ () {\n        long val = 0;\n        auto i = std.parse_integer(value);\n  \
    \      if (i > 0)\n            val = i;\n        else if (i < 0)\n           \
    \ val = (-i);\n        return val;\n    });\n    return std.integral_min(std.integral_min(value,\
    \ f));\n}", "{\n    long lower = std.string.toLong(value);\n    long upper = lower;\n\
    \    while (lower % 2 == 0) \n    {\n        lower /= 2;\n        upper /= 2;\n\
    \    }\n    bool is_even = lower % 2 == 0;\n    bool is_odd = !is_even;\n    string\
    \ to_return = to_string(lower, is_even, to_string(upper, is_odd, to_string(0,\
    \ false, \"\")));\n    to_return = to_return.substr(0, to_return.length() - 1);\n\
    \    return std.string.toLong(to_return);\n}\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ tags=math,algorithm,c# |>\nFor a more complete example of the answer from Lars\
    \ Palsson\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Threading.Tasks;", "{\n    long number;\n   \
    \ string digits = value[value.size()-1];", "{\n    string value = value;", "{\n\
    \    long value = tolong(value);\n    \n    // If two numbers equidistant, return\
    \ the one farthest from zero.\n    long diff1 = value - floor(value);\n    long\
    \ diff2 = value - ceil(value);", "{\n    return std.math.ceilToLong(std.convert.toLong(value));\n\
    }", "{\n    long result;\n    long diff;\n    \n    try\n    {\n        result\
    \ = parse(value);\n    }\n    catch(exception)\n    {\n        throw new exception(\"\
    Invalid number string passed to closest_integer. Invalid format: \" + value);\n\
    \    }", "{\n\t// TODO: implement!\n\treturn 0;\n}", "{\n  long result=0;\n  long\
    \ lower = std.toLong(trim(left(value)));\n  long upper = std.toLong(trim(right(value)));",
  "{\n    return to_integer(value)==value?value:to_integer(to_integer(value)+0.5);\n\
    }", "{\n\tif (value.empty()) \n\t{\n\t\tthrow runtime_error(\"Empty string passed\
    \ to closest_integer()\");\n\t}\n\t\n\tstring number = value.to_string();\n\t\n\
    \tsize_t start = 0;\n\tsize_t end = 1;\n\tsize_t mid = 0;\n\t\n\tdouble maxDiff;\n\
    \tdouble diff;\n\t\n\tlong result;\n\t\n\twhile (start <= end)\n\t{\n\t\tmid =\
    \ (start + end) / 2;\n\t\t\n\t\tdouble x = std.parsedouble(number.substr(start,\
    \ end - start));\n\t\tdouble y = std.parsedouble(number.substr(mid, end - mid));\n\
    \t\t\n\t\tmaxDiff = diff = 0;\n\t\t\n\t\tfor (int i = 0; i < end; i++)\n\t\t{\n\
    \t\t\tif (i == start) continue;\n\t\t\t\n\t\t\tdouble yDiff = std.parsedouble(number.substr(i,\
    \ end - i));\n\t\t\t\n\t\t\tif (yDiff > 0)\n\t\t\t{\n\t\t\t\tdiff = yDiff - y;\n\
    \t\t\t\tif (diff > maxDiff) maxDiff = diff;\n\t\t\t}\n\t\t\telse if (yDiff < 0)\n\
    \t\t\t{\n\t\t\t\tdiff = y - yDiff;\n\t\t\t\tif (diff > maxDiff) maxDiff = diff;\n\
    \t\t\t}\n\t\t}\n\t\t\n\t\tif (maxDiff < 0)\n\t\t{\n\t\t\tend = mid + 1;\n\t\t\
    }\n\t\telse if (maxDiff > 0)\n\t\t{\n\t\t\tstart = mid + 1;\n\t\t}\n\t\telse\n\
    \t\t{\n\t\t\tresult = std.parselong(number.substr(start, end - start));\n\t\t\t\
    break;\n\t\t}\n\t}\n\t\n\treturn result;\n}", "{\n    long low = 0;\n    long\
    \ high = pow(10,10);\n    long closest_index = -1;\n    long closest;\n    \n\
    \    if(value == \".\")\n    {\n        return 0;\n    }\n    \n    for(long i\
    \ = 0; i < value.length(); i++)\n    {\n        long digit = std.atoi(value.substr(i,\
    \ 1).c_str());\n        \n        if(digit < low)\n        {\n            low\
    \ = digit;\n        }\n        else if(digit > high)\n        {\n            high\
    \ = digit;\n        }\n        else\n        {\n            closest_index = i;\n\
    \            \n            if(digit == 0 || value == 0)\n            {\n     \
    \           closest = 0;\n            }\n            else if(digit > 0)\n    \
    \        {\n                closest = (long) pow(10, value.length()-1);\n    \
    \        }\n            else\n            {\n                closest = (long)\
    \ pow(10, value.length()+1);\n            }\n        }\n    }\n    \n    if(closest_index\
    \ == -1)\n    {\n        low = std.atoi(value.c_str());\n        \n        if(low\
    \ > 0 && low < high)\n        {\n            closest = low;\n        }\n     \
    \   else\n        {\n            high = std.atoi(value.c_str());\n           \
    \ \n            if(low > 0)\n            {\n                closest = (long) pow(10,\
    \ value.length()-1);\n            }\n            else\n            {\n       \
    \         closest = (long) pow(10, value.length()+1);\n            }\n       \
    \ }\n    }\n    \n    if(closest == 0)\n    {\n        return 0;\n    }\n    \n\
    \    double dLow = double(low);\n    double dHigh = double(high);\n    double\
    \ dClosest = double(closest);\n    \n    double dAbs = dClose - dLow;\n    double\
    \ dNext = dHigh - dClose;\n    \n    if(dAbs < dNext)\n    {\n        closest\
    \ = dHigh;\n    }\n    else\n    {\n        closest = dLow;\n    }\n    \n   \
    \ return std.int64(closest);\n}", "{\n    long n = std.parseLong(value);\n   \
    \ long min = 0;\n    long max = Integer.MAX_VALUE;\n    if (n >= 0) {\n      \
    \  min = max - n;\n    } else {\n        max = min + n;\n    }", "{\n    auto\
    \ d = std.parseNumber(value);\n    if (d < 0)\n        throw runtime_error(\"\
    invalid value\");\n    if (d % 2 == 0)\n        d -= 1;\n    long low = 0;\n \
    \   long high = std::numeric_limits<long>::max();\n    while (true) {\n      \
    \  low = (low + high) / 2;\n        long mid = low + std.divRound(std.floor /\
    \ 2);\n        string midstr = to_string(mid);\n        if (midstr == value) \n\
    \            return mid;\n        if (midstr < value) \n            low = mid\
    \ + 1;\n        else \n            high = mid - 1;\n    }\n}", "{\n    long n1\
    \ = std.parseLong(value);\n    long n2 = n1;\n    while (n1 == n2)\n        n2\
    \ = std.nextLong();\n    return n1;\n}\n</code>\n<|/ a |>\n<| a tags=math,c#,rounding\
    \ |>\n<code>\npublic static int Closest(int? value)\n{\n    int closest;\n   \
    \ int zero = int.MinValue;\n    if (!value.HasValue)\n    {\n        closest =\
    \ 0;\n    }\n    else if (value.Value < zero)\n    {\n        closest = int.MaxValue;\n\
    \    }\n    else\n    {\n        closest = value.Value + 1;\n    }\n    return\
    \ closest;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYour code doesn't work for\
    \ negative numbers. Negative numbers just become positive numbers with some offset\
    \ (negative = positive + 1).\n<|/ c |>\n<| a dscore=1 |>\nHere's an extension\
    \ method that you can call from LINQ:\n<code>\n/// <summary>\n/// Return closest\
    \ value to passed value that isn't greater than passed value\n/// </summary>\n\
    /// <param name=\"value\">Value to check</param>\n/// <returns>Closest value not\
    \ greater than passed value</returns>\npublic static long ClosestNotGreaterThan(this\
    \ long value)\n{\n    return value.ClosestGreaterThan(value.Value);\n}", "{\n\t\
    long num;\n\tint index;\n\tchar strNum[128];\n\tstring strValue;", "{\n    //\
    \ TODO: implement me\n    long result = 0L;\n    //return result;\n    return\
    \ result;\n}", "{\n    long result;\n    double d = std.parsedouble(value);\n\
    \    result = std.parselong(value); // convert from string to long\n    result\
    \ = std.trunc(result); // round result to nearest whole number\n    d = std.abs(d);\n\
    \    result = std.round(d);\n    // result should be the same as the original\
    \ string\n    // but with extra characters at the end\n    // so strip off any\
    \ trailing characters\n    if(std.endsWith(value, result))\n        result = result.substring(0,\
    \ result.length() - std.length(result));\n    return std.tostring(result);\n}",
  "{\n  long intValue = std.stringtolong(value);\n  long diff = (intValue - intValue%10);\n\
    \  if(diff == 0) \n    return intValue%10;\n  return intValue%10 + diff;\n}",
  "{\n    long intVal;\n    long intVal2;\n    intVal = std.parseLong(value);", "{\n\
    \    auto int_value = parse(value);\n    auto int_min = std.pow(2, std.log2(int_value));\n\
    \    auto int_max = std.pow(2, std.log2(int_min) + 1);\n    long diff1 = std.fabs(int_value\
    \ - int_min);\n    long diff2 = std.fabs(int_value - int_max);\n    long diff\
    \ = (diff1 < diff2) ? diff1 : diff2;\n    if (diff == 0) {\n        return int_min;\n\
    \    } else if (diff > 0) {\n        return int_min;\n    } else {\n        return\
    \ int_max;\n    }\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe function does not\
    \ compile for me.\n<|/ c |>\n<| c |>\nIt did compile for me with c++17 enabled.\
    \ Perhaps you need to add `using std::sqrt;` to your header file.\n<|/ c |>\n\
    <| c |>\nThe function didn't work properly. `closest_integer(\"1.10\")` returns\
    \ 1, but `closest_integer(\"1.11\")` returns 1.\n<|/ c |>\n<| c |>\nYes, I had\
    \ assumed you wanted the nearest integer, not nearest float.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\n#include <iostream>\n#include <cmath>\nusing namespace std;"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
