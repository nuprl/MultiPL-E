name: HumanEval_20_find_closest_elements
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n From a supplied array of numbers\
  \ (of length at least two) select and return two that are the closest to each\n\
  \    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float)\
  \ find_closest_elements(float[] numbers) \n"
tests: "unittest\n{\n    alias candidate = find_closest_elements;\n\n    assert(candidate([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]) == tuple(3.9, 4.0));\n    assert(candidate([1.0, 2.0,\
  \ 5.9, 4.0, 5.0]) == tuple(5.0, 5.9));\n    assert(candidate([1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2]) == tuple(2.0, 2.2));\n    assert(candidate([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0]) == tuple(2.0, 2.0));\n    assert(candidate([1.1, 2.2, 3.1, 4.1, 5.1]) ==\
  \ tuple(2.2, 3.1));\n}\nvoid main(){}"
completions: ["    where {\n    var min = VectorOf!(float, numbers.length);\n    var\
    \ max = VectorOf!(float, numbers.length);\n    var min_d = VectorOf!(float, numbers.length);\n\
    \    var max_d = VectorOf!(float, numbers.length);\n    for (i from 0 .. numbers.length-1)\
    \ {\n        min[i] = numbers[i];\n        max_d[i] = max[i] - min[i];\n    }\n\
    \    for (i from 1 .. numbers.length-1) {\n        var dist = distance(numbers[0],\
    \ numbers[i]);\n        var current_min = VectorOf!(float, numbers.length);\n\
    \        current_min[0] = numbers[0];\n        var current_max = VectorOf!(float,\
    \ numbers.length);\n        var current_min_d = VectorOf!(float, numbers.length);\n\
    \        var current_max_d = VectorOf!(float, numbers.length);\n        for (i\
    \ from 0 .. numbers.length-1) {\n            var next_dist = distance(numbers[i],\
    \ numbers[i+1]);\n            var next_min_dist = distance(numbers[i], min[i]);\n\
    \            var next_max_dist = distance(numbers[i], max[i]);\n            if\
    \ ((dist < next_dist) || \n                (dist == next_dist &&\n           \
    \         (next_dist < min_d[i] || min_d[i] == next_min_dist || min_d[i] == next_min_dist\
    \ && next_dist < current_min_d[i]))) {\n                min_d[i] = next_min_dist;\n\
    \                min_d[i+1] = next_min_dist;\n                max[i] = next_max_dist;\n\
    \                max[i+1] = next_max_dist;\n                current_min[i] = numbers[i];\n\
    \                current_max[i] = numbers[i];\n                current_min_d[i]\
    \ = next_min_dist;\n                current_max_d[i] = next_max_dist;\n      \
    \          dist = next_dist;\n            }\n            else {\n            \
    \    current_min[i+1] = numbers[i+1];\n                current_max[i+1] = numbers[i+1];\n\
    \                current_min_d[i+1] = next_min_dist;\n                current_max_d[i+1]\
    \ = next_max_dist;\n            }\n        }\n        if (current_min[0] == numbers[0])\
    \ {\n            min[0] = current_min[1];\n            max[0] = current_max[1];\n\
    \            min_d[0] = current_min_d[1];\n            max_d[0] = current_max_d[1];\n\
    \        }\n        else {\n            min[0] = current_min[0];\n           \
    \ max[0] = current_max[0];\n            min_d[0] = current_min_d[0];\n       \
    \     max_d[0] = current_max_d[0];\n        }\n    }\n    return Tuple!(float,\
    \ float) tuple(min.sum(), max.sum());\n}\n*/", "{\n    // Sort the array\n   \
    \ sort(numbers, numbers, (a, b) =>\n    {\n        return std.nearbyint(a) - std.nearbyint(b);\n\
    \    });\n    // Return the two closest elements\n    return numbers[numbers.length\
    \ - 1] < numbers[0] ? numbers[numbers.length - 1] : numbers[0];\n}\n</code>\n\
    <|/ a |>\n<| a |>\nHere's a solution using std.algorithm.sort and std.algorithm.tuple.\n\
    <code>\nimport std.algorithm : sort;\nimport std.algorithm : tuple;", "{\n   \
    \ float min = numbers[0];\n    float max = numbers[0];", "{\n\tvar closest_value\
    \ = numbers[0];\n\tvar closest_value = numbers[0];\n\tfor(var i = 1; i < numbers.length;\
    \ i++)\n\t{\n\t\tif(numbers[i] < closest_value)\n\t\t{\n\t\t\tclosest_value =\
    \ numbers[i];\n\t\t}\n\t}\n\treturn Tuple!(closest_value, closest_value);\n}",
  "{\n    assert(numbers.length > 0);", "{\n    var min_dist = Float.MaxValue;\n \
    \   var best_element = float.min;\n    var best_index = -1;\n    var current_index\
    \ = -1;\n    \n    for (index in 0 .. numbers.length-1)\n    {\n        current_index\
    \ = index;\n        var current_dist = numbers[current_index];\n        var next\
    \ = numbers[index+1];\n        \n        // Check if this is the first element\
    \ in the list\n        if(current_index == 0)\n        {\n            min_dist\
    \ = current_dist;\n            best_element = current_dist;\n            best_index\
    \ = index;\n            \n        }\n        \n        // Check if the current\
    \ element is the best so far\n        else\n        {\n            var previous_element\
    \ = numbers[current_index-1];\n            \n            // Check if the current\
    \ element is closer to any previous elements\n            if(current_dist < min_dist)\
    \ \n            {\n                min_dist = current_dist;\n                best_element\
    \ = current_dist;\n                best_index = index;\n            }\n      \
    \      // Check if the current element is the closest to any following elements\n\
    \            else if(current_dist < previous_element) \n            {\n      \
    \          min_dist = current_dist;\n                best_element = current_dist;\n\
    \                best_index = index;\n            }\n        }\n    }\n    \n\
    \    return Tuple!(best_element, best_index);\n}", "{\n\tvar min = numbers[0];\n\
    \tvar max = numbers[0];\n\tfor (var i=1; i<numbers.length; i++)\n\t{\n\t\tvar\
    \ val = numbers[i];\n\t\tif (val < min)\n\t\t{\n\t\t\tmin = val;\n\t\t}\n\t\t\
    if (val > max)\n\t\t{\n\t\t\tmax = val;\n\t\t}\n\t}\n\treturn Tuple!(min, max);\n\
    }\n\"\"\")\n\t# END FORM DECLARATION\n\t\n\t# BEGIN FORM IMPLEMENTATION\n\t\n\t\
    # NOTE: This form of implementation is based on Knuth's \"The Art of Computer\
    \ Programming\".\n\t# It is based on the following pseudo-code:\n\t\n\t# \tmin\
    \ = array[0];\n\t# \tmin = array[1];\n\t# \tfor i in 2 to array.length:\n\t# \t\
    \tval = array[i]\n\t# \t\tmin = min(min, val)\n\t# \t\tmax = max(max, val)\n\t\
    # \treturn (min,max)\n\t\n\t\n\t# Iterate through each element in the input array\n\
    \tmin_value = array[0]\n\tmax_value = array[0]\n\tfor n in xrange(1,len(array)):\n\
    \t\tval = array[n]\n\t\t\n\t\t# Find smallest and largest values\n\t\tif val <\
    \ min_value:\n\t\t\tmin_value = val\n\t\tif val > max_value:\n\t\t\tmax_value\
    \ = val\n\t\n\t# Return the tuple that gives the smallest and largest values\n\
    \treturn (min_value, max_value)\n\t\n\t\n\t# END FORM IMPLEMENTATION\n\t\n# END\
    \ FUNCTION\n\t", "{\n\tfloat min1 = numbers[0], min2 = numbers[0], mid, tmp;\n\
    \tfor (int i = 1; i < numbers.length; ++i)\n\t{\n\t\ttmp = numbers[i];\n\t\tif\
    \ (tmp < min1)\n\t\t{\n\t\t\tmin2 = min1;\n\t\t\tmin1 = tmp;\n\t\t}\n\t\telse\
    \ if (tmp < min2)\n\t\t{\n\t\t\tmin2 = tmp;\n\t\t}\n\t\telse if (tmp > min2)\n\
    \t\t{\n\t\t\tmin2 = tmp;\n\t\t\tmid = (min1 + min2) / 2;\n\t\t\tbreak;\n\t\t}\n\
    \t}\n\treturn Tuple!(mid, min2);\n}\n'''\n</cell>\n<cell>\n!./build.py -c -a -s\
    \ -k generate_tests\n</cell>\n<cell>\n!cd /content/tf-distances && /content/tf-distances/tensorflow/lite/toco\
    \ > tflite.log &\n</cell>\n<cell>\n!grep -A 3 'Opcodes' tflite.log\n</cell>\n\
    <cell>\n!./generate_tests.py generate_tests.toco\n</cell>\n<cell>\n!./generate_tests.py\
    \ generate_tests.toco generate_tests.toco\n</cell>\n<cell>\n!cd /content/tf-distances\
    \ && /content/tf-distances/tensorflow/lite/toco > tflite.log &\n</cell>\n<cell>\n\
    !./generate_tests.py generate_tests.toco generate_tests.toco generate_tests.toco\n\
    </cell>\n<cell>\n!cd /content/tf-distances && /content/tf-distances/tensorflow/lite/toco\
    \ > tflite.log &\n</cell>\n<cell>\n!./generate_tests.py generate_tests.toco generate_tests.toco\
    \ generate_tests.toco\n</cell>\n<cell>\n!cd /content/tf-distances && /content/tf-distances/tensorflow/lite/toco\
    \ > tflite.log &\n</cell>\n<cell>\n!./generate_tests.py generate_tests.toco generate_tests.toco\
    \ generate_tests.toco\n</cell>\n<cell>\n!cd /content/tf-distances && /content/tf-distances/tensorflow/lite/toco\
    \ > tflite.log &\n</cell>\n<cell>\n!./generate_tests.py generate_tests.toco generate_tests.toco\
    \ generate_tests.toco\n</cell>\n<cell>\n!cd /content/tf-distances && /content/tf-distances/tensorflow/lite/toco\
    \ > tflite.log &\n</cell>\n", "    where numbers: Vector!(float); \n{\n    var\
    \ minVal = numbers[0];\n    var maxVal = numbers[0];\n    for (float v : numbers)\
    \ {\n        if (minVal > v) {\n            minVal = v;\n        }\n        if\
    \ (maxVal < v) {\n            maxVal = v;\n        }\n    }\n    return Tuple!(float,\
    \ float) (minVal, maxVal);\n}", "{\n    assert(numbers.length >= 2);\n    \n \
    \   float minimum = numbers[0];\n    float maximum = numbers[0];\n    \n    for(float\
    \ number : numbers) {\n        if(minimum > number) {\n            minimum = number;\n\
    \        }\n        if(maximum < number) {\n            maximum = number;\n  \
    \      }\n    }\n    \n    return Tuple!(minimum, maximum);\n}", "{\n    \n  \
    \  int smallest = find_index(numbers, 0.0, numbers[0]);\n    int largest = find_index(numbers,\
    \ 0.0, numbers[0]);", "{\n\tif(null numbers)\n\t\tthrow new Exception(\"Null input.\"\
    );", "{\n\tvar sortedNumbers = sort_numbers(numbers);\n\t\n\tvar minX = sortedNumbers[0];\n\
    \tvar maxX = sortedNumbers[0];\n\t\n\tfor (int i = 0; i < sortedNumbers.length;\
    \ i++)\n\t{\n\t\tif (maxX < sortedNumbers[i])\n\t\t\tmaxX = sortedNumbers[i];\n\
    \t\t\n\t\tif (minX > sortedNumbers[i])\n\t\t\tminX = sortedNumbers[i];\n\t}\n\t\
    \n\treturn Tuple!(minX, maxX);\n}", "{\n    Tuple!(float, float) result;\n   \
    \ float min = numbers[0];\n    float max = numbers[0];", "{\n\tfloat[] distances\
    \ = distances(numbers);\n\tint minDistIndex = distances.indexOf(minValue(distances));\n\
    \tint maxDistIndex = distances.indexOf(maxValue(distances));\n\t\n\treturn Tuple!(numbers[minDistIndex],\
    \ numbers[maxDistIndex]);\n}", "{\n    int i = 0;\n    int j = numbers.length\
    \ - 1;\n    float mindiff = MAX_FLOAT;\n    while(i != j) \n    {\n        int\
    \ mid = (i+j)/2;\n        float diff = fabs(numbers[mid] - numbers[i]);\n    \
    \    if(diff < mindiff)\n        {\n            mindiff = diff;\n            i\
    \ = mid;\n        }\n        else \n        {\n            j = mid;\n        }\n\
    \    }\n    return Tuple!(numbers[i], numbers[j]);\n}", "{\n    auto n = numbers.length\
    \ >> 1;\n    float closest1, closest2;\n    \n    if (numbers.length < 2)\n  \
    \  {\n        return Tuple!(0.f, 0.f);\n    }\n    \n    for (float i = 0.f; i\
    \ < n; i++)\n    {\n        auto min = std.min(numbers, numbers + n);\n      \
    \  auto max = std.max(numbers, numbers + n);\n        auto diff = max - min;\n\
    \        \n        if (diff == 0.f)\n        {\n            continue;\n      \
    \  }\n        \n        if (diff > 0.f)\n        {\n            closest2 = max;\n\
    \            closest1 = min;\n        }\n        else\n        {\n           \
    \ closest1 = max;\n            closest2 = min;\n        }\n        \n        return\
    \ Tuple!(closest1, closest2);\n    }\n    \n    return Tuple!(0.f, 0.f);\n}",
  "{\n    let len = numbers.Length;\n    let closest_a = 0.0;\n    let closest_b =\
    \ 0.0;\n    for (i in 0..len-1) {\n        let a = numbers[i];\n        let b\
    \ = numbers[i+1];\n        let diff = std.math.sqrt_float(a) - std.math.sqrt_float(b);\n\
    \        if (diff < 0.0) {\n            closest_a = a;\n            closest_b\
    \ = b;\n        } else if (diff == 0.0) {\n            if ((a < closest_a) ||\
    \ (a > closest_b)) {\n                closest_a = a;\n            } else if ((b\
    \ < closest_a) || (b > closest_b)) {\n                closest_b = b;\n       \
    \     }\n        }\n    }\n    return Tuple!(closest_a, closest_b);\n}", "{\n\
    \    float smallest = numbers[0], largest = numbers[0];\n    for (int i = 1; i\
    \ < numbers.length; ++i) {\n        if (numbers[i] < smallest && numbers[i] >\
    \ largest) {\n            largest = smallest = numbers[i];\n        } else if\
    \ (numbers[i] > largest) {\n            largest = numbers[i];\n        } else\
    \ if (numbers[i] < smallest) {\n            smallest = numbers[i];\n        }\n\
    \    }\n    return Tuple!(largest, smallest);\n}", "{\n\tif((numbers.length <\
    \ 2)) return (numbers[0], numbers[0]);\n\t\n\tfloat max = numbers[0];\n\tfloat\
    \ min = numbers[0];\n\t\n\tfor(int i = 0; i < numbers.length; i++)\n\t{\n\t\t\
    if(numbers[i] > max) max = numbers[i];\n\t\tif(numbers[i] < min) min = numbers[i];\n\
    \t}\n\t\n\treturn (max, min);\n}\n/*\n Given a two elements (from find_closest_elements)\
    \ return a float which is the distance between the two\n \n >>> find_closest_distance(2.0,\
    \ 2.2)\n 0.0\n >>> find_closest_distance(2.0, 2.0)\n 0.0\n >>> find_closest_distance(3.0,\
    \ 4.0)\n 0.5\n >>> find_closest_distance(3.0, 3.0)\n 0.0\n >>> find_closest_distance(5.0,\
    \ 5.0)\n 1.0\n >>> find_closest_distance(5.0, 2.2)\n 0.0\n \n*/\nfloat find_closest_distance(float[]\
    \ element1, float[] element2)\n{\n\treturn (float)(find_closest_elements(element2)\
    \ - find_closest_elements(element1));\n}\n/*\n Given a number and a number array\
    \ (of length at least two), return a tuple of the two numbers which are closest\n\
    \ to each other (smaller, larger) and in the order closest to larger.\n \n >>>\
    \ closest_element(1.0, [1.0, 2.0])\n (1.0, 2.0)\n >>> closest_element(2.0, [1.0,\
    \ 2.0])\n (1.0, 2.0)\n >>> closest_element(2.0, [1.0, 2.1])\n (1.0, 2.1)\n >>>\
    \ closest_element(5.0, [1.0, 2.0])\n (1.0, 2.0)\n >>> closest_element(5.0, [1.0,\
    \ 2.1])\n (1.0, 2.1)\n >>> closest_element(5.0, [1.0, 1.0])\n (1.0, 1.0)\n >>>\
    \ closest_element(5.0, [2.0, 2.1])\n (2.0, 2.1)\n >>> closest_element(5.0, [1.0,\
    \ 1.0])\n (1.0, 1.0)\n >>> closest_element(5.0, [1.0, 1.1])\n (1.0, 1.0)\n >>>\
    \ closest_element(5.0, [1.0, 2.0])\n (1.0, 2.0)\n >>> closest_element(2.0, [1.0,\
    \ 2.0])\n (1.0, 2.0)\n >>> closest_element(2.0, [1.0, 2.1])\n (1.0, 2.1)\n >>>\
    \ closest_element(2.0, [1.0, 1.0])\n (1.0, 1.0)\n >>> closest_element(2.0, [1.0,\
    \ 1.1])\n (1.0, 1.0)\n >>> closest_element(2.0, [1.0, 2.0])\n (1.0, 2.0)\n >>>\
    \ closest_element(2.0, [1.0, 2.1])\n (1.0, 2.1)\n >>> closest_element(1.0, [2.0,\
    \ 2.1])\n (2.0, 2.1)\n >>> closest_element(1.0, [1.0, 1.0])\n (1.0, 1.0)\n >>>\
    \ closest_element(1.0, [1.0, 1.1])", "{\n    if (numbers.Length < 2)\n       \
    \ return Tuple!( numbers[0], numbers[0]);\n    \n    float closest_value = numbers[0];\n\
    \    float closest_value_2 = numbers[0];\n    float closest_difference = numbers[0]\
    \ * (float)(numbers[0]);\n    float closest_squared_difference = numbers[0] *\
    \ (float)(numbers[0]);\n    \n    for (int i = 1; i < numbers.Length; i++) {\n\
    \        float current_value = numbers[i];\n        float current_squared_difference\
    \ = numbers[i] * (float)(numbers[i]);\n        float current_difference = current_squared_difference\
    \ - closest_squared_difference;\n        closest_value = current_value;\n    \
    \    closest_value_2 = closest_value;\n        closest_difference = current_difference;\n\
    \        closest_squared_difference = current_squared_difference;\n        \n\
    \        if (current_squared_difference < closest_squared_difference) {\n    \
    \        closest_value = current_value;\n            closest_value_2 = closest_value;\n\
    \            closest_difference = current_difference;\n            closest_squared_difference\
    \ = current_squared_difference;\n        }\n    }\n    \n    return Tuple!(closest_value,\
    \ closest_value_2);\n}", "{\n\tfloat smallest;\n\tfloat largest;\n\t\n\tfloat\
    \ min1 = numbers[0];\n\tfloat max1 = numbers[0];\n\t\n\tfloat min2 = numbers[0];\n\
    \tfloat max2 = numbers[0];\n\t\n\tfor(int i=1; i < numbers.length; i++)\n\t{\n\
    \t\tif(numbers[i] < min1)\n\t\t\tmin1 = numbers[i];\n\t\tif(numbers[i] > max1)\n\
    \t\t\tmax1 = numbers[i];\n\t\t\n\t\tif(numbers[i] < min2)\n\t\t\tmin2 = numbers[i];\n\
    \t\tif(numbers[i] > max2)\n\t\t\tmax2 = numbers[i];\n\t}\n\t\n\tsmallest = min1;\n\
    \tlargest = max1;\n\t\n\tif(min2 < min1)\n\t{\n\t\tsmallest = min2;\n\t\tlargest\
    \ = max2;\n\t}\n\t\n\tif(smallest == largest)\n\t{\n\t\tif(smallest == 0)\n\t\t\
    {\n\t\t\tsmallest = 1.0;\n\t\t\tlargest = 2.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\
    if(largest == 0)\n\t\t\t\tlargest = 0.0;\n\t\t\treturn Tuple!(smallest, largest);\n\
    \t\t}\n\t}\n\telse\n\t{\n\t\tif(smallest == max2)\n\t\t\treturn Tuple!(smallest,\
    \ largest);\n\t\telse\n\t\t\treturn Tuple!(smallest, largest);\n\t}\n}", "{\n\
    \    float[] closest = {float.MaxValue, float.MaxValue};\n    \n    for(int i\
    \ = 0; i < numbers.Length; i++)\n    {\n        float distance = abs(numbers[i]\
    \ - closest[1]);\n        \n        if(distance < closest[0])\n        {\n   \
    \         closest[0] = distance;\n            closest[1] = numbers[i];\n     \
    \   }\n    }\n    \n    return Tuple!(closest[1], closest[0]);\n}", "{\n    let\
    \ a = numbers[0];\n    let b = numbers[1];", "{\n\tif (numbers.length < 2)\n\t\
    \treturn Tuple!(float,float)!(0,0);\n\t\n\tfloat[] mins = {numbers[0],numbers[0]};\n\
    \tfloat[] maxs = {numbers[0]};\n\tfor(int i=1; i< numbers.length; i++)\n\t{\n\t\
    \tif (numbers[i]<mins[0])\n\t\t{\n\t\t\tmins[0]=numbers[i];\n\t\t}\n\t\tif (numbers[i]>maxs[0])\n\
    \t\t{\n\t\t\tmaxs[0]=numbers[i];\n\t\t}\n\t\tif (numbers[i]<mins[1])\n\t\t{\n\t\
    \t\tmins[1]=numbers[i];\n\t\t}\n\t\tif (numbers[i]>maxs[1])\n\t\t{\n\t\t\tmaxs[1]=numbers[i];\n\
    \t\t}\n\t}\n\treturn Tuple!(float,float)!(mins[0],maxs[0]);\n}", "{\n    var biggest\
    \ = numbers[0];\n    var smallest = numbers[0];\n    foreach (x in numbers) {\n\
    \        if (x.f > biggest.f) {\n            biggest.f = x.f;\n        }\n   \
    \     if (x.f < smallest.f) {\n            smallest.f = x.f;\n        }\n    }\n\
    \    return (smallest.f, biggest.f);\n}", "{\n    Vec2<float> vector = Vec2<float>[\n\
    \        numbers[0],\n        numbers[1],\n    ];\n    Vec2<float> vector2 = Vec2<float>[\n\
    \        numbers[2],\n        numbers[3],\n    ];\n    float minimum = float.max;\n\
    \    float minimum2 = float.max;\n    for(size_t i = 0; i < 2; i++) {\n      \
    \  if (vector[i] > vector2[i]) {\n            minimum2 = minimum;\n          \
    \  minimum = vector[i];\n        } else {\n            minimum = minimum2;\n \
    \           minimum2 = vector2[i];\n        }\n    }\n    for(size_t i = 0; i\
    \ < 2; i++) {\n        if (minimum == float.max)\n            return Tuple!(float.max,\
    \ float.max);\n        if (vector[i] < minimum) {\n            return Tuple!(vector[i],\
    \ minimum);\n        }\n        if (minimum2 == float.max)\n            return\
    \ Tuple!(float.max, float.max);\n        if (vector2[i] < minimum2) {\n      \
    \      return Tuple!(minimum, minimum2);\n        }\n    }\n    return Tuple!(minimum,\
    \ minimum2);\n}", "    ensure(is_sorted(numbers), message=\"numbers must be sorted\"\
    );\n    \n// From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n    other and return them in order\
    \ (smaller number, larger number).\n    Tuple!(float, float) find_closest_elements(float\
    \ numbers[]) \n{\n    int low = 0, high = length(numbers)-1;\n    while (low <=\
    \ high) {\n        int index = (low+high)/2;\n        float middle = numbers[index];\n\
    \        if (numbers[index] > numbers[high]) \n            high = index-1;\n \
    \       else \n            low = index+1;\n    }\n    return Tuple!(numbers[low],\
    \ numbers[high]);\n}\n    \n/*\n From a supplied array of numbers (of length at\
    \ least two) select and return two that are the closest to each\n    other and\
    \ return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float)\
    \ find_closest_elements(float numbers[]) \n    Tuple!(float, float) find_closest_elements(float[]\
    \ numbers) \n{\n    return find_closest_elements(Vec(numbers));\n}", "{\n\tif\
    \ (numbers.length < 2)\n\t\treturn Tuple!(float, float);\n\t\n\tfloat[] min_diff\
    \ = {FLT_MAX, FLT_MAX};\n\tfloat min_val = numbers[0];\n\tfloat max_val = numbers[0];\n\
    \tfloat min_diff_index = -1;\n\tfor (int i = 1; i < numbers.length; ++i)\n\t{\n\
    \t\tfloat diff = numbers[i] - min_val;\n\t\tif (diff < min_diff[0])\n\t\t{\n\t\
    \t\tmin_diff[0] = diff;\n\t\t\tmin_diff_index = i;\n\t\t}\n\t\telse if (diff <\
    \ min_diff[1])\n\t\t{\n\t\t\tmin_diff[1] = diff;\n\t\t}\n\t\telse if (diff ==\
    \ 0)\n\t\t{\n\t\t\tmin_val = numbers[i];\n\t\t\tmin_diff_index = i;\n\t\t}\n\t\
    }\n\t\n\treturn Tuple!(min_val, numbers[min_diff_index]);\n}", "{\n    int[] closest_numbers\
    \ = new int[numbers.length];\n    int closest_to_next_number = 0;\n    for(int\
    \ i = 0; i < closest_numbers.length; i++) {\n        float number1 = numbers[i];\n\
    \        float number2 = numbers[(i + 1) % numbers.length];\n        float dist\
    \ = abs(number1 - number2);\n        if(!isIn(closest_numbers, i) && isIn(closest_numbers,\
    \ (i + 1) % numbers.length) && dist < closest_to_next_number) {\n            closest_numbers[i]\
    \ = closest_to_next_number;\n            closest_to_next_number = dist;\n    \
    \    }\n    }\n    return Tuple!(float(closest_numbers[0]), float(closest_numbers[numbers.length\
    \ - 1]));\n}\n</code>\n<|/ a tags=dart,loops,list,algorithm,flutter |>\n<| a tags=dart,loops,list,algorithm,flutter\
    \ dscore=0 |>\nIf you want a generic solution you should first think about how\
    \ you would do it in Java. \nFor a list where you just want to iterate through\
    \ it once and return the two closest values then you would write something like\
    \ this:\n<code>\n    double firstClosest = Double.MAX_VALUE;\n    double secondClosest\
    \ = Double.MAX_VALUE;\n    double currentClosest = Double.MAX_VALUE;", "{\n  \
    \  float a = 0;\n    float b = numbers[0];\n    float c = numbers[0];\n    float\
    \ d = numbers[0];\n    float e = numbers[0];\n    float f = numbers[0];\n    float\
    \ g = numbers[0];\n    float h = numbers[0];\n    float i = numbers[0];\n    float\
    \ j = numbers[0];\n    float k = numbers[0];\n    float l = numbers[0];\n    float\
    \ m = numbers[0];\n    float n = numbers[0];\n    float o = numbers[0];\n    float\
    \ p = numbers[0];\n    float q = numbers[0];\n    float r = numbers[0];\n    float\
    \ s = numbers[0];\n    float t = numbers[0];\n    float u = numbers[0];\n    float\
    \ v = numbers[0];\n    float w = numbers[0];\n    float x = numbers[0];\n    float\
    \ y = numbers[0];\n    float z = numbers[0];", "{\n\t\n\tif (numbers.Length <\
    \ 2)\n\t{\n\t\treturn Tuple!(float, float)(numbers[0], numbers[0]);\n\t}\n\t\n\
    \tfloat[] sorted_numbers = sort!(numbers);\n\tfloat closest_distance = sorted_numbers[0]\
    \ - sorted_numbers[1];\n\tfloat closest_index = 1;\n\t\n\tfloat index = 0;\n\t\
    float prev_distance = closest_distance;\n\tfloat prev_distance = closest_distance;\n\
    \twhile (index < sorted_numbers.Length)\n\t{\n\t\tfloat distance = sorted_numbers[index]\
    \ - closest_distance;\n\t\t\n\t\tif (prev_distance < distance)\n\t\t{\n\t\t\t\
    closest_index = index;\n\t\t\tclosest_distance = distance;\n\t\t}\n\t\t\n\t\t\
    prev_distance = distance;\n\t\t\n\t\tindex++;\n\t}\n\t\n\treturn Tuple!(float,\
    \ float)(closest_distance, closest_index);\n}\n/*\n This function finds the element\
    \ (from a sorted array or tuple) that is closest to a supplied value.\n If supplied\
    \ value is more than the difference between any two elements in the array/tuple\
    \ then None is \n returned.\n \n >>> find_closest_element([2.0, 1.0, 3.0, 4.0,\
    \ 5.0])\n 2.0\n >>> find_closest_element([])\n None\n \n */\nTuple!(float, float)\
    \ find_closest_element(float number) \n{\n\treturn find_closest_elements(VecToTuple(VecToVec(number)));\n\
    }", "{\n    \n    if (numbers.length < 2) {\n        return Tuple!(float, float)\
    \ tuple();\n    }\n    \n    float min = numbers[0];\n    float max = numbers[0];\n\
    \    \n    for (float element : numbers) {\n        if (element < min) {\n   \
    \         min = element;\n        }\n        if (element > max) {\n          \
    \  max = element;\n        }\n    }\n    \n    return Tuple!(float, float) tuple(min/2,\
    \ max/2);\n}\n// To test your function, run the code in the main body of this\
    \ module:\n/*", "{\n\tif(numbers.length < 2)\n\t{\n\t\tthrow new Exception(\"\
    find_closest_elements called with less than 2 numbers to find distances between\"\
    );\n\t}\n\telse\n\t{\n\t\tfloat smallestDiff = numbers[0].abs();\n\t\tfloat largestDiff\
    \ = numbers[0].abs();\n\t\t\n\t\tfor(int i = 1; i < numbers.length; ++i)\n\t\t\
    {\n\t\t\tfloat diff = numbers[i].abs() - numbers[i - 1].abs();\n\t\t\tif(diff\
    \ < smallestDiff)\n\t\t\t{\n\t\t\t\tsmallestDiff = diff;\n\t\t\t}\n\t\t\tif(diff\
    \ > largestDiff)\n\t\t\t{\n\t\t\t\tlargestDiff = diff;\n\t\t\t}\n\t\t}\n\t\treturn\
    \ Tuple!(numbers[smallestDiff], numbers[largestDiff]);\n\t}\n}", "{\n    \n  \
    \  float minValue = numbers[0]; \n    float maxValue = numbers[0];\n    \n   \
    \ for(float number : numbers) {\n        if(number < minValue) minValue = number;\n\
    \        if(number > maxValue) maxValue = number;\n    }\n    \n    return Tuple!(float,float)((minValue,maxValue));\n\
    }", "{\n\tsize_t smallerSize = min(numbers.length, 2);\n\tsize_t largerSize =\
    \ max(numbers.length, 2);\n\tfor (size_t i = 0; i < smallerSize; ++i) {\n\t\t\
    float smaller = numbers[i];\n\t\tfor (size_t j = 0; j < largerSize; ++j) {\n\t\
    \t\tfloat larger = numbers[j];\n\t\t\tif (fabs(smaller - larger) < 0.000001) {\n\
    \t\t\t\treturn Tuple!(smaller, larger);\n\t\t\t}\n\t\t}\n\t}\n\treturn Tuple!(-1.f,\
    \ -1.f);\n}", "{\n  float smallest;\n  float largest;\n  float difference;\n \
    \ int index;", "{\n\tfloat smallest = float.infinity();\n\tfloat largest = -float.infinity();\n\
    \tfor(int i = 0; i < numbers.Length; i++)\n\t{\n\t\tif(numbers[i] < smallest)\n\
    \t\t{\n\t\t\tsmallest = numbers[i];\n\t\t}\n\t\tif(numbers[i] > largest)\n\t\t\
    {\n\t\t\tlargest = numbers[i];\n\t\t}\n\t}\n\treturn Tuple!(float,float)!{smallest,\
    \ largest};\n}", "    where {\n    // TODO: replace with stdlib minmax\n    int\
    \ smallest=numbers[0].abs();\n    int largest=numbers[0].abs();\n    for (int\
    \ i=1; i < numbers.length; ++i) {\n        int n = numbers[i].abs();\n       \
    \ if (n < smallest) {\n            smallest = n;\n        } else if (n > largest)\
    \ {\n            largest = n;\n        }\n    }\n    return Tuple!(smallest,largest);\n\
    }", "{\n\tArray!(float) a = numbers;\n\t\n\tint smallest = std.minIndex(a);\n\t\
    int largest = std.maxIndex(a);\n\t\n\tif (smallest < largest)\n\t{\n\t\treturn\
    \ Tuple!(float, float)(a.array[smallest], a.array[largest]);\n\t}\n\telse\n\t\
    {\n\t\treturn Tuple!(float, float)(a.array[largest], a.array[smallest]);\n\t}\n\
    }", "{\n    int[] counts = std.foldl(\n        0, \n        numbers, \n      \
    \  (a, b) => a + b, \n        0\n    );\n    for(int i = 0; i < numbers.Length;\
    \ i++)\n    {\n        int cur_count = counts[i];\n        if(cur_count != 0)\n\
    \        {\n            float cur = numbers[i];\n            float min = numbers[i];\n\
    \            for(int j = 0; j < numbers.Length; j++)\n            {\n        \
    \        float diff = numbers[j] - cur;\n                if(diff*diff < min*min)\n\
    \                {\n                    min = numbers[j];\n                  \
    \  int j = i;\n                }\n            }\n            Tuple!(float, float)\
    \ ret;\n            ret.first  = min;\n            ret.second = cur;\n       \
    \     return ret;\n        }\n    }\n    \n    throw Exception(\"No two elements\
    \ match. Found none.\");\n}\n/*\n    From two vectors, return a tuple with the\
    \ closest values.\n    \n    Example:\n    >>> v1 = (1.0, 2.0)\n    >>> v2 = (3.0,\
    \ 4.0)\n    >>> find_closest_elements(v1, v2)\n    (1.0, 3.0)\n    \n*/\nTuple!(float,\
    \ float) find_closest_elements(float2 v1, float2 v2) \n{\n    return find_closest_elements(new[]\
    \ { v1.x, v2.x }, new[] { v1.y, v2.y });\n}\n/*\n    From a 2D vector, return\
    \ a tuple with the closest values.\n    \n    Example:\n    >>> v1 = (1.0, 2.0)\n\
    \    >>> v2 = (1.1, 2.1)\n    >>> find_closest_elements(v1, v2)\n    (1.0, 1.1)\n\
    \    \n*/\nTuple!(float, float) find_closest_elements(float2 v) \n{\n    return\
    \ find_closest_elements(new[] { v.x, v.y });\n}\n/*\n    From a 3D vector, return\
    \ a tuple with the closest values.\n    \n    Example:\n    >>> v1 = (1.0, 2.0,\
    \ 3.0)\n    >>> v2 = (1.1, 2.1, 3.1)\n    >>> find_closest_elements(v1, v2)\n\
    \    (1.0, 1.1)\n    \n*/\nTuple!(float, float) find_closest_elements(float3 v)\
    \ \n{\n    return find_closest_elements(new[] { v.x, v.y, v.z });\n}\n/*\n   \
    \ From a 4D vector, return a tuple with the closest values.\n    \n    Example:\n\
    \    >>> v1 = (1.0, 2.0, 3.0, 4.0)\n    >>> v2 = (1.1, 2.1, 3.1, 4.1)\n    >>>\
    \ find_closest_elements(v1, v2)\n    (1.0, 1.1)\n    \n*/\nTuple!(float, float)\
    \ find_closest_elements(float4 v) \n{\n    return find_closest_elements(new[]\
    \ { v.x, v.y, ", "{\n\tassert(length(numbers) > 1);\n\tfloat min_val = numbers[0];\n\
    \tfloat max_val = numbers[0];\n\tforeach(number in numbers) {\n\t\tif(number <\
    \ min_val) {\n\t\t\tmin_val = number;\n\t\t}\n\t\tif(number > max_val) {\n\t\t\
    \tmax_val = number;\n\t\t}\n\t}\n\tif(max_val - min_val < 1e-4) return Tuple!(0,0);\n\
    \tfloat delta = max_val - min_val;\n\tif(delta < 1e-4) return Tuple!(0,0);\n\t\
    float mid_val = min_val + delta/2;\n\tforeach(number in numbers) {\n\t\tif(number\
    \ == mid_val) return Tuple!(min_val, mid_val);\n\t}\n\treturn Tuple!(0,0);\n}\n\
    /*\n From a supplied array of numbers (of length at least two) select and return\
    \ two that are the closest to each\n    other and return them in order (smaller\
    \ number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[]\
    \ numbers, bool ascending) \n{\n\tassert(length(numbers) > 1);\n\tfloat min_val\
    \ = numbers[0];\n\tfloat max_val = numbers[0];\n\tforeach(number in numbers) {\n\
    \t\tif(number < min_val) {\n\t\t\tmin_val = number;\n\t\t}\n\t\tif(number > max_val)\
    \ {\n\t\t\tmax_val = number;\n\t\t}\n\t}\n\tif(max_val - min_val < 1e-4) return\
    \ Tuple!(0,0);\n\tfloat delta = max_val - min_val;\n\tif(delta < 1e-4) return\
    \ Tuple!(0,0);\n\tfloat mid_val = min_val + delta/2;\n\tforeach(number in numbers)\
    \ {\n\t\tif(number == mid_val) return Tuple!(min_val, mid_val);\n\t}\n\tif(!ascending)\
    \ foreach(number in numbers) {\n\t\tif(number < mid_val) {\n\t\t\treturn Tuple!(min_val,\
    \ mid_val);\n\t\t}\n\t}\n\treturn Tuple!(0,0);\n}", "{\n  if(numbers.length <\
    \ 2) return 0;\n  int smallest = 0, largest = numbers.length - 1;\n  while(smallest\
    \ != largest && smallest != -1) \n  {\n    float curr = numbers[smallest];\n \
    \   float next = numbers[(smallest + 1) % numbers.length];\n    float diff = (curr\
    \ - next);\n    if(diff < 0)\n      largest = smallest - 1;\n    else\n      smallest\
    \ = smallest + 1;\n  }\n  return Tuple(numbers[smallest], numbers[largest]);\n\
    }", "{\n    \n\tauto minV = numbers[0];\n\tauto maxV = numbers[0];", "{\n    float[]\
    \ array = [numbers[0], numbers[1], numbers[numbers.length-2]];\n    Tuple!(float,\
    \ float) tuple = find_closest_element(array);\n    return tuple;\n}", "{\n\tVec2[]\
    \ nearest_elements = new Vec2[numbers.length];\n\tint i, j, closest;\n\tfloat\
    \ diff1, diff2;\n\tfor (i=0; i<numbers.length; i++)\n\t{\n\t\tdiff1 = numbers[i]\
    \ - numbers[closest];\n\t\tdiff2 = numbers[i] - numbers[closest-1];\n\t\tif (diff1\
    \ < diff2)\n\t\t{\n\t\t\tnearest_elements[i] = numbers[i];\n\t\t\tclosest = i;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tnearest_elements[i] = numbers[closest-1];\n\t\t\
    }\n\t}\n\treturn Tuple!(nearest_elements[0], nearest_elements[numbers.length-1]);\n\
    }", "{\n    Tuple!(float, float)? closest;\n    auto iter = numbers[0];\n    auto\
    \ min = (*iter).abs() + (numbers[1] * std::numeric_limits<float>::epsilon());\n\
    \    auto max = (*iter).abs();\n    for(size_t i = 2; i < numbers.size(); i++)\
    \ {\n        if(numbers[i].abs() > max) {\n            max = numbers[i].abs();\n\
    \        }\n        if((numbers[i].abs() - min).abs() < min) {\n            min\
    \ = (numbers[i].abs() - min).abs();\n            iter = numbers[i];\n        }\n\
    \    }\n    closest = Tuple!(float, float)((*iter).abs(), (numbers[iter].abs()));\n\
    \    return closest;\n}\n#endif", "{\n\tlet mut smallest = FLT_MAX;\n\tlet mut\
    \ largest = -FLT_MAX;\n\tfor (index, value) in numbers.iter().enumerate() {\n\t\
    \tif smallest < value {\n\t\t\tsmallest = value;\n\t\t}\n\t\tif largest > value\
    \ {\n\t\t\tlargest = value;\n\t\t}\n\t}\n\t\n\tlet mut result = Vec::new();\n\t\
    let mut min_pos = Vec::new();\n\tresult.push(smallest);\n\tmin_pos.push(0);\n\t\
    \n\tlet mut max_pos = Vec::new();\n\tresult.push(largest);\n\tmax_pos.push(0);\n\
    \t\n\tfor i in 0..numbers.len() - 1 {\n\t\tif numbers[i] < smallest {\n\t\t\t\
    smallest = numbers[i];\n\t\t\tresult.push(smallest);\n\t\t\tmin_pos.push(0);\n\
    \t\t}\n\t\telse if numbers[i] > largest {\n\t\t\tlargest = numbers[i];\n\t\t\t\
    result.push(largest);\n\t\t\tmax_pos.push(0);\n\t\t}\n\t\telse if numbers[i] ==\
    \ smallest {\n\t\t\tif min_pos[0] == 0 {\n\t\t\t\tresult.push(smallest);\n\t\t\
    \t\tmin_pos.push(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.push(smallest);\n\t\
    \t\t\tmin_pos.push(min_pos[0]);\n\t\t\t}\n\t\t\t\n\t\t\tif max_pos[0] == numbers.len()\
    \ - 1 {\n\t\t\t\tresult.push(largest);\n\t\t\t\tmax_pos.push(0);\n\t\t\t}\n\t\t\
    \telse {\n\t\t\t\tresult.push(largest);\n\t\t\t\tmax_pos.push(max_pos[0]);\n\t\
    \t\t}\n\t\t}\n\t}\n\t\n\tlet result = Tuple!(float, float) (result[0], result[1]);\n\
    \tmin_pos = Vec::new();\n\tresult.min_pos = min_pos;\n\t\n\tlet result = Tuple!(float,\
    \ float) (result[0], result[1]);\n\tmax_pos = Vec::new();\n\tresult.max_pos =\
    \ max_pos;\n\t\n\treturn result;\n}", "{\n\tfloat minimum = numbers[0];\n\tfloat\
    \ maximum = numbers[0];\n\t\n\tif (numbers.length > 1)\n\t{\n\t\tfloat mid = numbers[1];\n\
    \t\t\n\t\tif (numbers.length >2)\n\t\t{\n\t\t\tmaximum = numbers[2];\n\t\t}\n\t\
    \t\n\t\tfor (float number : numbers)\n\t\t{\n\t\t\tif (number < mid)\n\t\t\t{\n\
    \t\t\t\tif (number > minimum)\n\t\t\t\t{\n\t\t\t\t\tminimum = number;\n\t\t\t\t\
    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (number > maximum)\n\t\t\t\t{\n\t\t\
    \t\t\tmaximum = number;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn make_tuple(minimum,\
    \ maximum);\n}", "{\n\tfloat[] a = sort(numbers);\n\tfloat max_val = a[0];\n\t\
    float min_val = a[0];", "{\n\tlet min = numbers[0];\n\tlet max = numbers[0];\n\
    \tfor (i <- 1 .. numbers.len) \n\t{\n\t\tlet v = numbers[i];\n\t\tif (v < min)\
    \ min = v;\n\t\tif (v > max) max = v;\n\t}\n\treturn Tuple(min, max);\n}\n/*\n\
    \ Return an array of numbers (of length at least two) ordered from largest to\
    \ smallest.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n \
    \   [2.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n    \n*/\nArray!(float, float) find_closest_elements(float[]\
    \ numbers)\n{\n\tlet max = numbers[0];\n\tlet min = numbers[0];\n\tfor (i <- 1\
    \ .. numbers.len) \n\t{\n\t\tlet v = numbers[i];\n\t\tif (v < min) min = v;\n\t\
    \tif (v > max) max = v;\n\t}\n\treturn Array{Float64}(max + 1, min - 1);\n}\n\
    /*\n Return an array of numbers (of length at least two) ordered from smallest\
    \ to largest.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
    \    [2.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n    \n*/\nArray!(float, float) find_closest_elements(Float64[]\
    \ numbers)\n{\n\tlet min = numbers[0];\n\tlet max = numbers[0];\n\tfor (i <- 1\
    \ .. numbers.len) \n\t{\n\t\tlet v = numbers[i];\n\t\tif (v < min) min = v;\n\t\
    \tif (v > max) max = v;\n\t}\n\treturn Array{Float64}(min-1, max+1);\n}\n/*\n\
    \ Return an array of numbers (of length at least two) ordered from smallest to\
    \ largest.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  \
    \  [2.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n    \n*/\nArray!(float, float) find_closest_elements(int[]\
    \ numbers)\n{\n\tlet min = numbers[0];\n\tlet max = numbers[0];\n\tfor (i <- 1\
    \ .. numbers.len) \n\t{\n\t\tlet v = numbers[i];\n\t\tif (v < min) min = v;\n\t\
    \tif (v > max) max = v;\n\t}\n\treturn Array{Float64}(min-1, max+1);\n}\n/*\n\
    \ Return an array of numbers (of length at least two) ordered from smallest to\
    \ largest.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  \
    \  [2.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n    \n*/\nArray!(float, float) find_closest_elements(bool[]\
    \ numbers)\n{\n\tlet min = numbers[0];\n\tlet max = number", "{\n    float xmin\
    \ = numbers[0];\n    float xmax = numbers[0];\n    float ymin = numbers[0];\n\
    \    float ymax = numbers[0];\n    float dist = std.math.hypot(xmax - xmin, ymax\
    \ - ymin);\n    for (int i = 1; i < numbers.length; i++) {\n        float x =\
    \ numbers[i];\n        float y = numbers[i - 1];\n        float dx = x - xmin;\n\
    \        float dy = y - ymin;\n        float distance = std.math.hypot(dx, dy);\n\
    \        if (distance < dist) {\n            dist = distance;\n            xmin\
    \ = x;\n            ymin = y;\n        }\n    }\n    Tuple!(xmin, ymin);\n}\n\
    /*\n Return whether an arbitrary point lies within a circle of radius r. \n*/",
  "{\n    if (numbers.length < 2) \n        throw new Exception(\"\");\n    \n   \
    \ var lower = numbers[0];\n    var upper = numbers[0];\n    \n    for (i in 1..numbers.length-1)\n\
    \    {\n        var delta = numbers[i] - lower;\n        if (delta > upper)\n\
    \            upper = delta;\n        \n        delta = numbers[i] - upper;\n \
    \       if (delta < lower)\n            lower = delta;\n    }\n    \n    return\
    \ Tuple!(lower, upper);\n}\n/*\n From a supplied array of numbers (of length at\
    \ least two) select and return two that are the closest to each\n    other and\
    \ return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(double, double)\
    \ find_closest_elements(double[] numbers) \n{\n    if (numbers.length < 2) \n\
    \        throw new Exception(\"\");\n    \n    var lower = numbers[0];\n    var\
    \ upper = numbers[0];\n    \n    for (i in 1..numbers.length-1)\n    {\n     \
    \   var delta = numbers[i] - lower;\n        if (delta > upper)\n            upper\
    \ = delta;\n        \n        delta = numbers[i] - upper;\n        if (delta <\
    \ lower)\n            lower = delta;\n    }\n    \n    return Tuple!(lower, upper);\n\
    }", "{\n\tfloat min1, min2;\n\tfor (int i = 0; i < numbers.length; i++)\n\t{\n\
    \t\tmin1 = float.min;\n\t\tmin2 = float.max;\n\t\tif (numbers[i] < min1)\n\t\t\
    \tmin1 = numbers[i];\n\t\tif (numbers[i] > min2)\n\t\t\tmin2 = numbers[i];\n\t\
    }\n\treturn Tuple!(min1, min2);\n}", "{\n\t\n\tTuple!(float, float) result;\n\t\
    \n\tfloat maxDistance = float.max(numbers[numbers.length - 1] - numbers[0], numbers[0]\
    \ - numbers[numbers.length - 1]);\n\tfor (int i = 1; i < numbers.length; ++i)\
    \ {\n\t\tfloat distance = float.max(numbers[i] - numbers[i - 1], numbers[i - 1]\
    \ - numbers[i]);\n\t\tif (distance < maxDistance) {\n\t\t\tmaxDistance = distance;\n\
    \t\t\tresult = Tuple!(numbers[i], numbers[i - 1]);\n\t\t}\n\t}\n\treturn result;\n\
    }", "{\n  int minIndex = 0;\n  int maxIndex = 0;\n  for (int i = 0; i < numbers.length;\
    \ ++i) {\n    int diff = numbers[i] - numbers[maxIndex];\n    if (diff < 0.0)\
    \ {\n      maxIndex = i;\n    } else {\n      minIndex = i;\n    }\n  }\n  return\
    \ (numbers[minIndex], numbers[maxIndex]);\n}", "{\n  if(numbers.length < 2) return\
    \ Tuple!(float, float);", "{\n\tfloat smallest, smallest_index;\n\tfloat largest,\
    \ largest_index;\n\tfloat temp;\n\tint k;\n\tbool found_smallest = false, found_largest\
    \ = false;\n\t\n\tsmallest = numbers[0];\n\tlargest = numbers[0];\n\tsmallest_index\
    \ = -1;\n\tlargest_index = -1;", "{\n  int i, j;\n  float smallest, largest;\n\
    \  int n2 = numbers.length, num = 0;\n  float temp;\n  \n  smallest = numbers[0];\n\
    \  largest = numbers[0];\n  \n  for(i=1; i<n2; ++i)\n  {\n    if(numbers[i] <\
    \ smallest )\n    {\n      smallest = numbers[i];\n    }\n    \n    if(numbers[i]\
    \ > largest )\n    {\n      largest = numbers[i];\n    }\n  }\n  \n  for(i=0;\
    \ i<n2; ++i)\n  {\n    for(j=0; j<n2; ++j)\n    {\n      if(i != j)\n      {\n\
    \        temp = numbers[i];\n        numbers[i] = numbers[j];\n        numbers[j]\
    \ = temp;\n      }\n    }\n  }\n  \n  if(smallest == largest)\n  {\n    return\
    \ Tuple!(float)(smallest, largest);\n  }\n  \n  smallest = abs(smallest);\n  largest\
    \ = abs(largest);\n  \n  for(i=0; i<n2; ++i)\n  {\n    if(numbers[i] == largest)\n\
    \    {\n      return Tuple!(float)(largest, smallest);\n    }\n    \n    if(numbers[i]\
    \ == smallest)\n    {\n      return Tuple!(float)(smallest, largest);\n    }\n\
    \  }\n  \n  return Tuple!(float)(smallest, largest);\n}", "{\n    var n = numbers.length\
    \ - 1;\n    if(n < 2)\n        return (numbers[0], numbers[0]);\n    var midpoint\
    \ = std.math.max(numbers);\n    var left = mid - (mid / n);\n    var right = mid;\n\
    \    while(left > 0.01) {\n        midpoint -= 0.01;\n        mid = (left + right)\
    \ / 2;\n        left = mid - (mid / n);\n        right = mid;\n    }\n    var\
    \ closestPoint = midpoint;\n    var closestNumber = numbers[midpoint];\n    while(left\
    \ > 0.01) {\n        midpoint -= 0.01;\n        closestNumber = numbers[midpoint];\n\
    \        if(closestNumber > closestPoint) {\n            closestPoint = closestNumber;\n\
    \        }\n        left = mid - (mid / n);\n        right = mid;\n    }\n   \
    \ return (closestPoint, closestNumber);\n}", "{\n    \n    // get min and max\
    \ from array\n    float min = numbers[0];\n    float max = numbers[0];\n    \n\
    \    // get the min and max values\n    foreach(x <- numbers) {\n        if(x\
    \ < min)\n            min = x;\n        if(x > max)\n            max = x;\n  \
    \  }\n    \n    // set closest element to min and max\n    float closestToMin\
    \ = min;\n    float closestToMax = max;\n    \n    // loop through remaining numbers\
    \ and set closest\n    foreach(x <- numbers) {\n        // if x is closer then\
    \ update closestToMin and closestToMax\n        float closest = closestToMin;\n\
    \        if(x < closest) {\n            closest = x;\n        }\n        // if\
    \ x is closer then update closestToMin and closestToMax\n        if(x > closest)\
    \ {\n            closest = x;\n        }\n        \n        // if x is closer\
    \ then update closestToMin and closestToMax\n        if(x < closestToMax) {\n\
    \            closestToMax = x;\n        }\n        if(x > closestToMax) {\n  \
    \          closestToMax = x;\n        }\n    }\n    \n    // return the new tuple\n\
    \    return Tuple(closestToMin, closestToMax);\n}\n\"\"\")\n    \n# -----------------------------\n\
    # Test Code to run from command line\n# -----------------------------\nif __name__\
    \ == \"__main__\":\n    import doctest\n    doctest.testmod()", "{\n    int n\
    \ = numbers.length;\n    if(n <= 0) return Tuple!(float,float)();\n    \n    float\
    \ smallest = (float)numbers[0];\n    float largest = (float)numbers[0];\n    \n\
    \    for(int i=1; i < n; i++)\n    {\n        float temp = (float)numbers[i];\n\
    \        if(temp < smallest)\n            smallest = temp;\n        else if(temp\
    \ > largest)\n            largest = temp;\n    }\n    \n    return Tuple!(float,float)((float)\
    \ smallest, (float) largest);\n}\n\"\"\"", "{\n    Tuple!(float, float) minmax;\n\
    \    \n    int i = 0;\n    float closestDistance = math::abs(numbers[0]);\n  \
    \  minmax = (numbers[0], numbers[0]);\n    \n    while (i < numbers.length - 1)\
    \ {\n        float distanceToNext = math::abs(numbers[i + 1] - numbers[i]);\n\
    \        if (distanceToNext < closestDistance) {\n            minmax = (numbers[i],\
    \ numbers[i + 1]);\n            closestDistance = distanceToNext;\n        }\n\
    \        i++;\n    }\n    \n    return minmax;\n}\n/*\n Calculate the average\
    \ of two supplied numbers.\n*/\nfloat2 average(float2 a, float2 b)\n{\n    return\
    \ a + b;\n}\n/*\n Calculate the average of a set of numbers, optionally passing\
    \ in the number of elements of the set\n so that the function will return the\
    \ averages instead of only the averages.\n*/\nfloat2[] average(float2[] numbers,\
    \ int numValues) \n{\n    int i;\n    float sum = 0;\n    float2[] result = new\
    \ float2[numValues];\n    \n    for (i = 0; i < numValues; i++) \n    {\n    \
    \    sum += numbers[i];\n    }\n    \n    for (i = 0; i < numValues; i++) \n \
    \   {\n        result[i] = (numbers[i] / sum);\n    }\n    \n    return result;\n\
    }\n/*\n Find the squared distance between two points.\n*/\nfloat squared_distance(float\
    \ x, float y)\n{\n    return math::pow(x, 2) + math::pow(y, 2);\n}\n/*\n Find\
    \ the squared distance between two points (the points must be of the same dimensions).\n\
    */\nfloat2 squared_distance(float2 a, float2 b)\n{\n    return math::pow(a.x -\
    \ b.x, 2) + math::pow(a.y - b.y, 2);\n}\n/*\n Find the squared distance between\
    \ two vectors.\n*/\nfloat squared_distance(float2 a, float2 b)\n{\n    return\
    \ math::pow(a.x - b.x, 2) + math::pow(a.y - b.y, 2);\n}\n/*\n Find the squared\
    \ distance between two vectors (the points must be of the same dimensions).\n\
    */\nfloat2 squared_distance(float2 a, float2 b)\n{\n    return math::pow(a.x -\
    \ b.x, 2) + math::pow(a.y - b.y, 2);\n}\n/*\n Find the squared distance between\
    \ two vectors.\n*/\nfloat squared_distance(float2 a, float2 b)\n{\n    return\
    \ math::pow(a.x - b.x, 2) + math::pow(a.y - b.y, 2);\n}\n/*\n Find a dot product\
    \ of two floats.\n*/\nfloat dot(float2 a, float2 b)\n{\n    return a.x * ", "{\n\
    \    assert(numbers.length >= 2);\n    assert(numbers[0] < numbers[1]);\n    \n\
    \    float diff = numbers[0] - numbers[1];\n    float closest[2];\n    closest[0]\
    \ = numbers[1];\n    closest[1] = numbers[0];\n    \n    for (int i = 1; i < numbers.length\
    \ - 1; i++)\n    {\n        float current[2] = {numbers[i], numbers[i + 1]};\n\
    \        float distance = (diff);\n        float smallest = (diff);\n        \n\
    \        for (int j = 0; j < 2; j++)\n        {\n            float currentDifference\
    \ = distance(current[j]);\n            if (currentDifference < smallest)\n   \
    \         {\n                smallest = currentDifference;\n                closest[j]\
    \ = current[j];\n            }\n        }\n        diff = smallest;\n    }\n \
    \   return Tuple!(closest[0], closest[1]);\n}", "{\n    Vector{Tuple{float, float}}\
    \ = numbers;\n    \n    float min_number = numbers[0];\n    float max_number =\
    \ numbers[0];\n    \n    Vector{float} = numbers;\n    \n    for i = 1; i < numbers.len();\
    \ ++i\n    {\n        if(numbers[i] > max_number)\n        {\n            max_number\
    \ = numbers[i];\n        }\n        \n        if(numbers[i] < min_number)\n  \
    \      {\n            min_number = numbers[i];\n        }\n    }\n    \n    Vector{Tuple{float,\
    \ float}} = numbers;\n    \n    float new_max_number = max_number;\n    float\
    \ new_min_number = min_number;\n    \n    for i = 1; i < numbers.len(); ++i\n\
    \    {\n        if(numbers[i] > new_max_number)\n        {\n            new_max_number\
    \ = numbers[i];\n        }\n        \n        if(numbers[i] < new_min_number)\n\
    \        {\n            new_min_number = numbers[i];\n        }\n    }\n    \n\
    \    return Tuple!(new_max_number, new_min_number);\n}", "{\n\t\n\tfor (int i\
    \ = 0; i < numbers.length; ++i)\n\t{\n\t\tdouble currentDifference = numbers[i]\
    \ - numbers[0];\n\t\tdouble bestDifference = numbers[0];\n\t\tdouble bestIndex\
    \ = i;\n\t\t\n\t\tfor (int j = 1; j < numbers.length; ++j)\n\t\t{\n\t\t\tif (j\
    \ != i)\n\t\t\t{\n\t\t\t\tdouble difference = numbers[j] - numbers[i];\n\t\t\t\
    \tif (difference < bestDifference)\n\t\t\t\t{\n\t\t\t\t\tbestDifference = difference;\n\
    \t\t\t\t\tbestIndex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tnumbers[bestIndex]\
    \ = numbers[i];\n\t}\n\t\n\tTuple!(float, float)!\n}", "{\n  int i = (int)floor(length(numbers)/2);\n\
    \  if (i > length(numbers))\n    i = length(numbers);\n  float a = numbers[i];\n\
    \  float b = numbers[i - 1];\n  return Tuple!(a, b);\n}", "{\n    \n    if(numbers.length\
    \ < 2)\n        throw new Exception(\"find_closest_elements(): array is empty.\"\
    );\n    \n    float min = numbers[0];\n    float max = numbers[0];\n    \n   \
    \ int i;\n    \n    for(i=1; i<numbers.length; ++i)\n    {\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n        if(numbers[i]\
    \ > max)\n        {\n            max = numbers[i];\n        }\n    }\n    \n \
    \   return Tuple!float(min, max);\n}\n\"\"\"\n)", "{\n\tint[] indices = binary_search_first(numbers);\n\
    \tif(indices.isEmpty)\n\t{\n\t\treturn Tuple!(float,float)();\n\t}\n\treturn Tuple!(numbers[indices[0]],\
    \ numbers[indices[1]]);\n}", "{\n\tvar closest: f32 = numbers[0]; // This is the\
    \ \"current\" number\n\tvar closest_old: f32 = numbers[0]; // This is the \"previous\"\
    \ number\n\tvar closest_diff: f32 = 0.0; // This is the \"difference\" between\
    \ the two \"current\" numbers\n\tvar closest_next: f32 = numbers[0]; // This is\
    \ the \"next\" number to check\n\t\n\tfor (var i = 1; i < numbers.len; i++ ) {\n\
    \t\t\n\t\tfloat diff = abs(numbers[i] - closest);\n\t\t\n\t\t// The \"previous\"\
    \ number is either the \"current\" number if the\n\t\t// \"current\" number is\
    \ the smallest number in the array.\n\t\tclosest_old = closest;\n\t\tclosest =\
    \ numbers[i];\n\t\t\n\t\tclosest_diff = diff;\n\t\tclosest_next = numbers[i];\n\
    \t\t\n\t\t// If the difference between the current and previous number is less\
    \ than the minimum distance between the\n\t\t// two numbers then use the new \"\
    current\" number.\n\t\tif (diff < closest_diff) {\n\t\t\tclosest_diff = diff;\n\
    \t\t\tclosest_next = closest;\n\t\t}\n\t}\n\treturn Tuple!(closest_next, closest_old);\n\
    }", "{\n    int[] mins = {INT_MIN, INT_MAX};\n    int[] maxs = {INT_MAX, INT_MIN};\n\
    \    foreach(float number in numbers) {\n        mins = min(mins, min(abs(number),\
    \ abs(maxs[0])));\n        maxs = max(maxs, max(abs(number), abs(mins[0])));\n\
    \    }\n    return Tuple!(float, float)(mins[0], maxs[0]);\n}", "{\n    if(numbers.length\
    \ < 2)\n    {\n        return (numbers[0], numbers[0]);\n    }\n    int maxIdx\
    \ = numbers.length - 1;\n    float min = numbers[0], max = numbers[0];\n    for(int\
    \ i = 0; i < maxIdx; ++i)\n    {\n        if(numbers[i] > max)\n        {\n  \
    \          max = numbers[i];\n            maxIdx = i;\n        }\n        if(numbers[i]\
    \ < min)\n        {\n            min = numbers[i];\n        }\n    }\n    return\
    \ (min, max);\n}\n</code>\n<|/ a |>\n<| a tags=functional-programming,c++ |>\n\
    Here is how to do this without recursion and without the STL altogether:\n<code>\n\
    vector<int> v{1,2,3,4,5};\nvector<int> v(v.begin(),v.begin()+3);\n</code>\nThe\
    \ vector v is {1,2,3,4}\nThe vector v(v.begin(),v.begin()+3) is {1,2,3}\n<|/ a\
    \ dscore=1 |>\n<| a dscore=0 |>\nI came up with this solution. It's a little bit\
    \ like Howard's solution, but the recursive function ends up being simpler:\n\
    <code>\ntemplate<class T> auto min(T&& a, T&& b)\n{\n    return a < b ? a : b;\n\
    }", "{\n\tArrayView!(float, numbers) numbers;\n\tArrayView!(float, numbers) mins;\n\
    \tArrayView!(float, numbers) maxs;\n\tmaxs[0] = maxs[1] = numbers[0];\n\tmins[0]\
    \ = mins[1] = numbers[0];\n\tfor(int i = 1; i < numbers.len; i++)\n\t{\n\t\tif(numbers[i]\
    \ > maxs[i])\n\t\t\tmaxs[i] = numbers[i];\n\t\telse if(numbers[i] < mins[i])\n\
    \t\t\tmins[i] = numbers[i];\n\t}\n\tif(mins[1] == maxs[1])\n\t\treturn (mins[0],\
    \ mins[1]);\n\telse\n\t{\n\t\tfloat delta = maxs[1]-mins[1];\n\t\tfloat temp;\n\
    \t\tif(delta < 0.0)\n\t\t\ttemp = (maxs[1]+mins[1])/2.0;\n\t\telse\n\t\t\ttemp\
    \ = (mins[1]+maxs[1])/2.0;\n\t\treturn (temp, temp);\n\t}\n}\n/*\n From a supplied\
    \ array of numbers (of length at least two) select and return two that are the\
    \ closest to each\n    other and return them in order (smaller number, larger\
    \ number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  \
    \  tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\
    \    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[]\
    \ numbers, float delta) \n{\n\tArrayView!(float, numbers) numbers;\n\tArrayView!(float,\
    \ numbers) mins;\n\tArrayView!(float, numbers) maxs;\n\tmaxs[0] = maxs[1] = numbers[0];\n\
    \tmins[0] = mins[1] = numbers[0];\n\tfor(int i = 1; i < numbers.len; i++)\n\t\
    {\n\t\tif(numbers[i] > maxs[i])\n\t\t\tmaxs[i] = numbers[i];\n\t\telse if(numbers[i]\
    \ < mins[i])\n\t\t\tmins[i] = numbers[i];\n\t}\n\tif(mins[1] == maxs[1])\n\t\t\
    return (mins[0], mins[1]);\n\telse\n\t{\n\t\tfloat temp = maxs[1]-mins[1];\n\t\
    \tif(delta < 0.0)\n\t\t\ttemp = (maxs[1]+mins[1])/2.0;\n\t\telse\n\t\t\ttemp =\
    \ (mins[1]+maxs[1])/2.0;\n\t\treturn (temp, temp);\n\t}\n}\n/*\n Given an array\
    \ of numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_element", "{\n    float minValue\
    \ = numbers[0];\n    float maxValue = numbers[0];\n    for(float  i : numbers)\n\
    \    {\n        if (maxValue < i)\n        {\n            maxValue = i;\n    \
    \    }\n        else if (minValue > i)\n        {\n            minValue = i;\n\
    \        }\n    }\n    return Tuple!(minValue, maxValue);\n}", "{\n    require(length(numbers)\
    \ >= 2, \"Array lengths must be > 2\");\n    \n    Tuple!(float, float) min_max;\n\
    \    \n    float minimum = numbers[0];\n    float maximum = numbers[0];\n    \n\
    \    float min_diff = math.inf;\n    float max_diff = -math.inf;\n    \n    float\
    \ current_minimum = minimum;\n    float current_maximum = minimum;\n    \n   \
    \ float current_diff = 0;\n    \n    for(int i = 0; i < length(numbers) - 1; i++)\
    \ {\n        current_minimum = min(current_minimum, numbers[i]);\n        current_maximum\
    \ = max(current_maximum, numbers[i]);\n        current_diff = math::fabs(numbers[i]\
    \ - current_minimum);\n        \n        if(current_diff < min_diff) {\n     \
    \       minimum = current_minimum;\n            \n            min_diff = current_diff;\n\
    \        }\n        \n        if(current_diff > max_diff) {\n            maximum\
    \ = current_maximum;\n            \n            max_diff = current_diff;\n   \
    \     }\n    }\n    \n    min_max = Tuple!(minimum, maximum);\n    \n    return\
    \ min_max;\n}\n'''\n</cell>\n<cell>\n%%writefile functions/math_math_util.ipynb_checkpoint\n\
    import math\ndef ceilDiv(num: int, div: int) -> int:\n    \"\"\"\n    Calculate\
    \ the ceil of a division operation.\n    \"\"\"\n    return num // div\n</cell>\n\
    <cell>\n# hide\n# skip\n# hide\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n\
    # skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n\
    # skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n\
    # skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n\
    # skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n\
    # skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n\
    # skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n\
    # skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n# skip\n\
    # skip\n# skip\n# skip\n", "{\n    float low = numbers[0];\n    float high = numbers[0];",
  "{\n  float x = numbers[0];\n  float y = numbers[0];\n  for(unsigned i = 0; i <\
    \ numbers.length; ++i)\n  {\n    if (numbers[i] < x)\n      x = numbers[i];\n\
    \    if (numbers[i] > y)\n      y = numbers[i];\n  }\n  return Tuple!(y, x);\n\
    }", "{\n    var smaller = float.max(numbers[0]);\n    var larger = float.min(numbers[0]);\n\
    \    for (int i = 0; i < numbers.Length; i++) {\n        if (numbers[i] < smaller)\
    \ {\n            smaller = numbers[i];\n        }\n        if (numbers[i] > larger)\
    \ {\n            larger = numbers[i];\n        }\n    }\n    return Tuple!(smaller,\
    \ larger);\n}", "{\n\tint minIndex;\n\tint minValue;\n\tint minIndex2;\n\tfloat\
    \ minValue2;\n\tfloat minValue;\n\tfor (int i = 0; i < numbers.length/2; i++)\
    \ \n\t{\n\t\tminIndex = i;\n\t\tminValue = numbers[i];\n\t\tfor (int j = i; j\
    \ < numbers.length/2; j++) \n\t\t{\n\t\t\tif (numbers[j] < minValue) \n\t\t\t\
    {\n\t\t\t\tminIndex = j;\n\t\t\t\tminValue = numbers[j];\n\t\t\t}\n\t\t}\n\t\t\
    minIndex2 = i;\n\t\tminValue2 = numbers[i];\n\t\tfor (int j = i; j < numbers.length/2;\
    \ j++) \n\t\t{\n\t\t\tif (numbers[j] > minValue) \n\t\t\t{\n\t\t\t\tminIndex2\
    \ = j;\n\t\t\t\tminValue2 = numbers[j];\n\t\t\t}\n\t\t}\n\t\tif ((minIndex !=\
    \ minIndex2) && ((minValue - minValue2) != ((numbers[minIndex] - numbers[minIndex2])*(numbers[minIndex]\
    \ - numbers[minIndex2])) / ((numbers[minIndex] - numbers[minIndex2])+1e-10)))\n\
    \t\t{\n\t\t\treturn tuple2(minValue2, minValue2);\n\t\t}\n\t}\n\treturn tuple2(numbers[0],\
    \ numbers[numbers.length/2]);\n}", "{\n  int n = numbers.length - 1;\n  \n  int\
    \ minIndex = 0;\n  float minDistance = (float)numbers[0];\n  int minDifference\
    \ = INT_MAX;\n  float minDifferenceDifference = (float)0;\n  \n  int maxIndex\
    \ = 0;\n  float maxDistance = (float)numbers[0];\n  int maxDifference = INT_MAX;\n\
    \  float maxDifferenceDifference = (float)0;\n  \n  for (int i = 0; i < n; i++)\
    \ \n  {\n    int thisDistance = (int)numbers[i+1] - numbers[i];\n    float thisDifference\
    \ = thisDistance - minDistance;\n    float thisDifferenceDifference = thisDifference\
    \ - minDifference;\n    if (thisDifferenceDifference < minDifferenceDifference)\
    \ \n    {\n      minIndex = i + 1;\n      minDistance = thisDistance;\n      minDifference\
    \ = thisDifference;\n      minDifferenceDifference = thisDifferenceDifference;\n\
    \    }\n    \n    if (thisDifferenceDifference > maxDifferenceDifference) \n \
    \   {\n      maxIndex = i;\n      maxDistance = thisDistance;\n      maxDifference\
    \ = thisDifference;\n      maxDifferenceDifference = thisDifferenceDifference;\n\
    \    }\n  }\n  \n  return Tuple!(float, float)(minDistance, maxDistance);\n}",
  "{\n  int mid = 0;\n  float biggest = numbers[0];\n  float smallest = numbers[0];\n\
    \  float result = numbers[0];\n  for (int i=1; i<numbers.length; ++i)\n  {\n \
    \   float curr = numbers[i];\n    if (curr > biggest)\n    {\n      biggest =\
    \ curr;\n      mid = i;\n    }\n    else if (curr < smallest)\n    {\n      smallest\
    \ = curr;\n      mid = i;\n    }\n  }\n  return Tuple!(mid, biggest);\n}", "{\n\
    \    // TODO: Check for duplicate numbers\n    if (numbers.length <= 2) {\n  \
    \      return numbers;\n    }", "{\n\tfloat min1 = numbers[0];\n\tfloat min2 =\
    \ numbers[0];\n\tfor(float number : numbers){\n\t\tfloat dif = abs(number - min1);\n\
    \t\tif(dif < min2){\n\t\t\tmin2 = min1;\n\t\t\tmin2 = number;\n\t\t}else{\n\t\t\
    \tmin2 = number;\n\t\t}\n\t\tmin1 = number;\n\t}\n\treturn Tuple!(min2, min2);\n\
    }\n*/", "{\n    int[] minValues = new int[2*(numbers.length - 1) +\n        (numbers.length\
    \ - 1) + 1];", "{\n    int closest_index = 0;\n    float smallest_distance = FLT_MAX;",
  "{\n    auto smaller = numbers[0];\n    auto larger = numbers[0];\n    for(int i=1;\
    \ i<numbers.length; ++i) {\n        if(numbers[i] < smaller) {\n            smaller\
    \ = numbers[i];\n        } else if(numbers[i] > larger) {\n            larger\
    \ = numbers[i];\n        }\n    }\n    return Tuple!(smaller, larger);\n}", "{\n\
    \tvar min_index = uint(0);\n\tvar min_value = numbers[uint(0)];\n\tfor (uint i\
    \ = 0; i < uint(len(numbers)); i++) {\n\t\tvar current_value = numbers[i];\n\t\
    \tif (current_value < min_value) {\n\t\t\tmin_index = i;\n\t\t\tmin_value = current_value;\n\
    \t\t}\n\t}\n\tTuple!(\"numbers[$min_index]\", \"numbers[uint(min_index)]\");\n\
    }", "{\n\tauto min = numbers[0];\n\tauto max = numbers[0];\n\tauto mid = 0.0;\n\
    \t\n\tfor (int i = 1; i < numbers.length; ++i) {\n\t\tif (numbers[i] < min) {\n\
    \t\t\tmin = numbers[i];\n\t\t}\n\t\telse if (numbers[i] > max) {\n\t\t\tmax =\
    \ numbers[i];\n\t\t}\n\t\telse {\n\t\t\tmid = numbers[i];\n\t\t\tbreak;\n\t\t\
    }\n\t}\n\t\n\treturn Tuple!(float,float) Tuple(min, mid, max);\n}", "{\n    Tuple!(float,\
    \ float) ret;\n    ret[0] = distance(float::to_float(numbers[0]), float::to_float(numbers[1]));\n\
    \    ret[1] = distance(float::to_float(numbers[0]), float::to_float(numbers[2]));",
  "{\n    Tuple!(float, float) result = Tuple!(float, float);\n    \n    for (float\
    \ num : numbers)\n    {\n        float smallest = numbers[0];\n        float largest\
    \ = numbers[0];\n        \n        for (float num : numbers)\n        {\n    \
    \        if (num > largest && num < smallest)\n            {\n               \
    \ largest = num;\n            }\n            else if (num < smallest && num >\
    \ largest)\n            {\n                smallest = num;\n            }\n  \
    \      }\n        \n        result.0 = smallest;\n        result.1 = largest;\n\
    \    }\n    \n    return result;\n}", "{\n    float smallest = numbers[0];\n \
    \   float largest = numbers[0];\n    for (float num : numbers) {\n        if (num\
    \ < smallest ){\n            smallest = num;\n        }\n        if (num > largest\
    \ ){\n            largest = num;\n        }\n    }\n    return Tuple!(smallest,\
    \ largest);\n}\n/*\n This function takes a string and returns the number of times\
    \ the string occurs in it.\n    \n*/", "{\n\tTuple!(float, float) tuple;\n\tfloat[]\
    \ arr;\n\t\n\tarr = copy(numbers);\n\t\n\tarr.sort!( [](a,b) -> fabs(a-b));\n\t\
    \n\ttuple = Tuple!(arr[1], arr[arr.length-1])\n\t\n\treturn tuple;\n}", "{\n \
    \   int min = 0;\n    int max = numbers.length - 1;\n    float bestMatch = numbers[0];\n\
    \    while (min <= max) {\n        float mid = min + (max - min) / 2;\n      \
    \  float diff = numbers[mid] - bestMatch;\n        if (diff < 0.0) {\n       \
    \     min = mid + 1;\n        } else {\n            max = mid - 1;\n        }\n\
    \    }\n    return Tuple!(bestMatch, numbers[max]);\n}", "{\n\tconst length =\
    \ length(numbers);\n\tconst int half = length / 2;\n\tconst float zero = numbers[half];\n\
    \tfloat min1 = zero;\n\tfloat min2 = zero;\n\tfloat index1 = 0;\n\tfloat index2\
    \ = half;", "{\n  float smallest = numbers[0];\n  float largest = numbers[0];\n\
    \  for (int i = 1; i < numbers.Length; i++)\n  {\n    float cur = numbers[i];\n\
    \    if (cur < smallest)\n    {\n      smallest = cur;\n    }\n    else if (cur\
    \ > largest)\n    {\n      largest = cur;\n    }\n  }\n  return Tuple!(f32(),\
    \ f32())(smallest, largest);\n}", "{\n    int[] index = {0,0};\n    float smallest\
    \ = Float::nan;\n    float largest = Float::nan;\n    for (auto n : numbers)\n\
    \    {\n        if (smallest > n)\n        {\n            smallest = n;\n    \
    \        index[0] = 0;\n        }\n        else if (largest < n)\n        {\n\
    \            largest = n;\n            index[1] = 1;\n        }\n    }\n    return\
    \ Tuple!(smallest,largest);\n}", "{\n    var min: float = numbers[0];\n    var\
    \ max: float = numbers[0];\n    var current: float = numbers[0];", "{\n\tfor(let\
    \ i = 0; i < numbers.length - 1; ++i)\n\t{\n\t\tfor(let j = i + 1; j < numbers.length;\
    \ ++j)\n\t\t{\n\t\t\tlet d = fabs(numbers[i]-numbers[j]);\n\t\t\tif(d < numbers[i].mag\
    \ + numbers[j].mag)\n\t\t\t\treturn Tuple!(float,float)(numbers[i], numbers[j]);\n\
    \t\t}\n\t}\n\treturn Tuple!(float,float)(numbers[numbers.length-1], numbers[0]);\n\
    }", "{\n\tint left = 0;\n\tint right = numbers.length - 1;\n\tfloat closest =\
    \ 0;\n\tfloat closest2 = 0;\n\tfloat smaller = 0;\n\tfloat smaller2 = 0;\n\t\n\
    \twhile (left < right) {\n\t\tfloat mid = (left + right) / 2;\n\t\tfloat currentClosest\
    \ = Math.abs(numbers[mid]);\n\t\tif (currentClosest < closest) {\n\t\t\tsmaller\
    \ = numbers[mid];\n\t\t\tsmaller2 = mid;\n\t\t\tclosest = currentClosest;\n\t\t\
    }\n\t\tif (currentClosest < closest2) {\n\t\t\tclosest2 = currentClosest;\n\t\t\
    }\n\t\tif (numbers[mid] > numbers[right]) {\n\t\t\tright = mid - 1;\n\t\t} else\
    \ if (numbers[mid] < numbers[left]) {\n\t\t\tleft = mid + 1;\n\t\t} else {\n\t\
    \t\tright = mid - 1;\n\t\t\tleft = mid + 1;\n\t\t}\n\t}\n\treturn Tuple!(smaller,\
    \ closest2);\n}", "{\n    int len = 1;\n    if (numbers.length < 2)\n    {\n \
    \       throw runtime_error(\"find_closest_elements requires at least two numbers\
    \ to work with\");\n    }", "{\n    if(numbers.length == 0) \n        return (0.0,\
    \ 0.0);\n    \n    double min_dist_sqr_1 = numbers[0];\n    double max_dist_sqr_1\
    \ = numbers[0];\n    \n    double min_dist_sqr_2 = numbers[0];\n    double max_dist_sqr_2\
    \ = numbers[0];\n    \n    for(unsigned i = 0; i < numbers.length; i++ ) \n  \
    \  {\n        double dist_sqr_1 = numbers[i] * numbers[i];\n        double dist_sqr_2\
    \ = numbers[(i + 1) % numbers.length] * numbers[i];\n        \n        if(dist_sqr_1\
    \ < min_dist_sqr_1)\n        {\n            min_dist_sqr_1 = dist_sqr_1;\n   \
    \         \n            if(dist_sqr_2 < min_dist_sqr_2)\n                min_dist_sqr_2\
    \ = dist_sqr_2;\n        }\n        else\n        {\n            if(dist_sqr_2\
    \ < min_dist_sqr_2)\n                min_dist_sqr_2 = dist_sqr_2;\n        }\n\
    \    }\n    \n    Tuple!(float, float) ret;\n    ret.first_elem = numbers[min_dist_sqr_2];\n\
    \    ret.second_elem = numbers[min_dist_sqr_1];\n    return ret;\n}", "{\n   \
    \ var best = f32::NAN;\n    var closest = f32::NAN;\n    var bestIndex = 0;\n\
    \    var closestIndex = -1;\n    var i = 1;\n    \n    while (i < numbers.len)\
    \ {\n        if (numbers.len() < 2) {\n            return error(\"Invalid input,\
    \ must at least have two numbers to compare\");\n        }\n        \n       \
    \ if (numbers[i-1] < best) {\n            best = numbers[i-1];\n            bestIndex\
    \ = i;\n        }\n        \n        if (numbers[i] > best) {\n            best\
    \ = numbers[i];\n            bestIndex = i;\n        }\n        \n        i +=\
    \ 1\n    }\n    \n    while (i < numbers.len) {\n        if (numbers[i-1] < closest)\
    \ {\n            closest = numbers[i-1];\n            closestIndex = i;\n    \
    \    }\n        \n        if (numbers[i] > closest) {\n            closest = numbers[i];\n\
    \            closestIndex = i;\n        }\n        \n        i += 1\n    }\n \
    \   \n    return Tuple!(numbers[bestIndex], numbers[closestIndex]);\n}\n'''",
  "{\n\tfloat max = numbers[0];\n\tfloat min = numbers[0];\n\tfor(float number : numbers)\
    \ {\n\t\tif(number > max) max = number;\n\t\tif(number < min) min = number;\n\t\
    }\n\tif(max == min) return Tuple!(0.0,0.0);\n\treturn Tuple!(min,max);\n}", "{\n\
    \    int4 min1 = 0, min2 = 0, min3 = 0;\n    float min4 = 0.0f, min5 = 0.0f, min6\
    \ = 0.0f;\n    foreachi(numbers,[min1, min2, min3, min4, min5, min6], i = i)\n\
    \    {\n        if(min3 < min1)\n        {\n            min3 = min1;\n       \
    \ }\n        if(min4 < min2)\n        {\n            min4 = min2;\n        }\n\
    \        if(min5 < min3)\n        {\n            min5 = min3;\n        }\n   \
    \     if(min6 < min4)\n        {\n            min6 = min4;\n        }\n    }\n\
    \    return Tuple!(float,float)!(min3, min4);\n}", "{\n    if (numbers.length\
    \ < 2) {\n        // No point doing this if there are only 2 numbers.\n      \
    \  throw new Exception(\"find_closest_elements(): No point doing this with only\
    \ 2 elements.\");\n    }", "{\n    return find_closest_elements(numbers, length(numbers),\
    \ 0);\n}", "    where {\n    int min1, min2, max1, max2;\n    float mindiff =\
    \ -1;\n    foreach(i : numbers) {\n        if (i == min1 || i == max1) {\n   \
    \         continue;\n        }\n        if (i == min2) {\n            max2 = min2;\n\
    \        }\n        else {\n            if (i < min2) {\n                max2\
    \ = min2;\n            }\n            else {\n                max2 = i;\n    \
    \        }\n        }\n        if (max1 - min1 <= 0) {\n            min1 = max1;\n\
    \            min2 = max2;\n            mindiff = float.abs(max1 - min1);\n   \
    \     }\n        else if (mindiff > float.abs(max1 - min1)) {\n            mindiff\
    \ = float.abs(max1 - min1);\n            min1 = max1;\n            min2 = max2;\n\
    \        }\n        else {\n            min2 = max2;\n        }\n    }\n    return\
    \ (min1, min2);\n}\n'''", "{\n\t\n\t//check validity of input\n\tfor(uint i =\
    \ 0; i < numbers.length; i++ ) {\n\t\tif(!numbers[i] >= 0) {\n\t\t\treturn null;\n\
    \t\t}\n\t}", "{\n    if(numbers.length < 2)\n    {\n        throw \"Not enough\
    \ numbers\";\n    }\n    var smallest = numbers[0];\n    var largest = numbers[0];\n\
    \    for(var i = 1;i < numbers.length;i++)\n    {\n        if(numbers[i] < smallest)\n\
    \        {\n            smallest = numbers[i];\n        }\n        if(numbers[i]\
    \ > largest)\n        {\n            largest = numbers[i];\n        }\n    }\n\
    \    return (smallest, largest);\n}", "{\n\tvar i, j, current, previous;\n\tvar\
    \ closest;\n\tvar largest = numbers[0];\n\tvar smallest = numbers[0];\n\tvar closest_elements\
    \ = Tuple!(float, float);", "{\n    // TODO: Sort array in reverse order", "{\n\
    \  if(numbers.length < 2) return Tuple!(float,float)(0.0,0.0);\n  \n  var min_d\
    \ = Vector2!float2(Number.MIN_VALUE, Number.MIN_VALUE);\n  var max_d = Vector2!float2(Number.MAX_VALUE,\
    \ Number.MAX_VALUE);\n  \n  foreach(number, num in numbers)\n  {\n    var d =\
    \ num - numbers[0];\n    if(d.x < min_d.x) min_d.x = d.x;\n    if(d.y < min_d.y)\
    \ min_d.y = d.y;\n    \n    if(d.x > max_d.x) max_d.x = d.x;\n    if(d.y > max_d.y)\
    \ max_d.y = d.y;\n  }\n  \n  return Tuple!(float,float)(\n      min((max_d.x -\
    \ min_d.x) / 2.0, (max_d.y - min_d.y) / 2.0),\n      max((max_d.x - min_d.x) /\
    \ 2.0, (max_d.y - min_d.y) / 2.0)\n  );\n}\n/*\n From a supplied array of numbers\
    \ (of length at least two) select and return two that are the closest to each\n\
    \    other and return them in order (smaller number, larger number).\n    >>>\
    \ find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0, 2.2)\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float2 numbers) \n\
    {\n  return find_closest_elements(Vector2[] numbers);\n}\n/*\n From a supplied\
    \ array of numbers (of length at least two) select and return two that are the\
    \ closest to each\n    other and return them in order (smaller number, larger\
    \ number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  \
    \  tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\
    \    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float3\
    \ numbers) \n{\n  return find_closest_elements(Vector3[] numbers);\n}\n/*\n From\
    \ a supplied array of numbers (of length at least two) select and return two that\
    \ are the closest to each\n    other and return them in order (smaller number,\
    \ larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
    \    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float4\
    \ numbers) \n{\n  return find_closest_elements(Vector4[] numbers);\n}\n/*\n From ",
  "{\n\tfloat closest_dist = math.abs(numbers[0] - numbers[1]);\n\tfloat closest_element\
    \ = numbers[0];\n\tfloat other_number = numbers[1];\n\tfor(int i = 1; i < numbers.length;\
    \ ++i)\n\t{\n\t\tfloat cur_dist = math.abs(numbers[i] - other_number);\n\t\tif(cur_dist\
    \ < closest_dist)\n\t\t{\n\t\t\tclosest_dist = cur_dist;\n\t\t\tclosest_element\
    \ = numbers[i];\n\t\t}\n\t}\n\treturn Tuple!(closest_element, closest_element);\n\
    }", "{\n    int[] idx;\n    float minDist = FLT_MAX;\n    float minVal;\n    float\
    \ minIdx = 0;\n    float maxVal;\n    float maxIdx;\n    for (int i = 0; i < numbers.length;\
    \ ++i)\n    {\n        idx = std.int([numbers[i] - minVal, numbers[i] - maxVal]);\n\
    \        if (minDist > idx[1])\n        {\n            minDist = idx[1];\n   \
    \         minVal = numbers[i];\n            minIdx = idx[0];\n        }\n    \
    \    if (maxDist < idx[1])\n        {\n            maxDist = idx[1];\n       \
    \     maxVal = numbers[i];\n            maxIdx = idx[0];\n        }\n    }\n \
    \   return Tuple!(float,float)!(minVal, maxVal);\n}", "{\n\tfor(const &x: numbers)\n\
    \t{\n\t\tconst float currentDist = abs(x - numbers[0]);\n\t\tconst float min =\
    \ numbers[0];\n\t\tfor(const &y: numbers)\n\t\t{\n\t\t\tconst float currentDist2\
    \ = abs(y - x);\n\t\t\tif(currentDist2 >= currentDist)\n\t\t\t{\n\t\t\t\tmin =\
    \ y;\n\t\t\t\tcurrentDist = currentDist2;\n\t\t\t}\n\t\t}\n\t\tif(currentDist\
    \ > 0)\n\t\t{\n\t\t\treturn Tuple!(min, x);\n\t\t}\n\t}\n\tassert(false);\n}",
  "{\n    // TODO: Improvement\n    \n    // TODO: Test this\n    float sum = 0;\n\
    \    for (int i = 0; i < numbers.Length; ++i)\n    {\n        sum += numbers[i];\n\
    \    }\n    \n    float average = sum / numbers.Length;\n    float smaller = numbers[0];\n\
    \    float larger = numbers[0];\n    \n    for (int i = 0; i < numbers.Length;\
    \ ++i)\n    {\n        if (numbers[i] > larger)\n        {\n            larger\
    \ = numbers[i];\n        }\n        if (numbers[i] < smaller)\n        {\n   \
    \         smaller = numbers[i];\n        }\n    }\n    \n    return Tuple(smaller,\
    \ larger);\n}", "{\n    int i, smallest_index, largest_index;\n    float smallest_value,\
    \ largest_value;", "{\n    var min: float = numbers[0];\n    var max: float =\
    \ numbers[0];\n    for (var i = 1; i < numbers.length; ++i) {\n        if (numbers[i]\
    \ < min) {\n            min = numbers[i];\n        } else if (numbers[i] > max)\
    \ {\n            max = numbers[i];\n        }\n    }\n    return Tuple!(min, max);\n\
    }", "{\n\tif (numbers.length <= 2)\n\t\treturn numbers;\n\tvar smallest_difference\
    \ = numbers[0];\n\tvar biggest_difference = numbers[0];\n\tvar smallest_difference_index\
    \ = -1;\n\tvar biggest_difference_index = -1;\n\tfor (var i = 1; i < numbers.length;\
    \ i++)\n\t{\n\t\tvar difference = numbers[i] - numbers[i - 1];\n\t\tif (difference\
    \ < smallest_difference)\n\t\t{\n\t\t\tsmallest_difference = difference;\n\t\t\
    \tsmallest_difference_index = i - 1;\n\t\t}\n\t\tif (difference > biggest_difference)\n\
    \t\t{\n\t\t\tbiggest_difference = difference;\n\t\t\tbiggest_difference_index\
    \ = i;\n\t\t}\n\t}\n\treturn Tuple!(numbers[smallest_difference_index], numbers[biggest_difference_index]);\n\
    }\n/*\n From a supplied array of numbers (of length at least two) select and return\
    \ two that are the closest to each\n    other and return them in order (smaller\
    \ number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements_2d(float[]\
    \ numbers) \n{\n\tif (numbers.length <= 2)\n\t\treturn numbers;\n\tvar smallest_difference\
    \ = numbers[0];\n\tvar biggest_difference = numbers[0];\n\tvar smallest_difference_index\
    \ = -1;\n\tvar biggest_difference_index = -1;\n\tfor (var i = 1; i < numbers.length;\
    \ i++)\n\t{\n\t\tvar difference = numbers[i] - numbers[i - 1];\n\t\tif (difference\
    \ < smallest_difference)\n\t\t{\n\t\t\tsmallest_difference = difference;\n\t\t\
    \tsmallest_difference_index = i - 1;\n\t\t}\n\t\tif (difference > biggest_difference)\n\
    \t\t{\n\t\t\tbiggest_difference = difference;\n\t\t\tbiggest_difference_index\
    \ = i;\n\t\t}\n\t}\n\treturn Tuple!(numbers[smallest_difference_index], numbers[biggest_difference_index]);\n\
    }\n/*\n From a supplied array of numbers (of length at least two) select and return\
    \ two that are the closest to each\n    other and return them in order (smaller\
    \ number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements_3d(float[]\
    \ numbers) \n{\n\tif (numbers.length <= 2)\n\t\treturn numbers;\n\tvar smallest_difference\
    \ = numbers[0];\n\tvar biggest_difference = numbers[0];\n\tvar smallest_difference_index\
    \ = -1;\n\tvar biggest_difference_index = -1;\n\tfor (var i", "{\n\t\n\t/*\n\t\
    \tFor each value in numbers, find the distance between it and every other value\
    \ in numbers\n\t\tthe distance is then stored as an element in the tuple\n\t\t\
    \n\t*/\n\t\n\tvar max_dist:float = numbers[0]; //Initialise the largest distance\
    \ value to this number\n\tvar min_dist:float = numbers[0];\n\tfor(var i:int =\
    \ 0; i < numbers.length; i++) \n\t{\n\t\tvar dist:float = abs(numbers[i] - numbers[i\
    \ - 1]);\n\t\tif(dist > max_dist)\n\t\t{\n\t\t\tmax_dist = dist;\n\t\t}\n\t\t\
    if(dist < min_dist)\n\t\t{\n\t\t\tmin_dist = dist;\n\t\t}\n\t}\n\t\n\t//Return\
    \ the smallest distance pair\n\treturn (min_dist, max_dist);\n}", "{\n    \n \
    \   // Write your code here\n    \n    \n    return Tuple!(float, float)(numbers[0],\
    \ numbers[1]);\n    \n}", "{\n    if (numbers.length < 2) {\n        throw \"\
    array must be of length at least 2\";\n    }\n    var min = numbers[0];\n    var\
    \ max = numbers[0];\n    var min_i = 1;\n    var max_i = 1;\n    foreach (var\
    \ n in numbers) {\n        if (n < min)\n        {\n            min = n;\n   \
    \         min_i = 1;\n        } else if (n > max)\n        {\n            max\
    \ = n;\n            max_i = 1;\n        }\n    }\n    var d = max - min;\n   \
    \ var new_min = min + (d * ((max_i - min_i) / 2));\n    var new_max = max - (d\
    \ * ((max_i - min_i) / 2));\n    var tuple = Tuple!<float>(new_min, new_max);\n\
    \    return tuple;\n}", "{\n  if(numbers.length == 0)\n    error(\"Invalid list\
    \ of numbers: %s\", numbers);\n  if(numbers.length < 2)\n    error(\"List of numbers\
    \ must be of length at least two: %s\", numbers);\n  var largest = numbers[0];\n\
    \  var smallest = numbers[0];\n  for(int i = 1; i < numbers.length; i++)\n  {\n\
    \    if(numbers[i] < smallest)\n      smallest = numbers[i];\n    if(numbers[i]\
    \ > largest)\n      largest = numbers[i];\n  }\n  return Tuple!(smallest, largest);\n\
    }\n/*\n Convert a string representation of a float or integer into a number.\n\
    \ \n Example:\n  >>> convert_string_to_float(\"0.12\")\n  0.12\n  >>> convert_string_to_float(\"\
    100\")\n  100.0\n  >>> convert_string_to_float(\"100.0\")\n  100.0\n  >>> convert_string_to_float(\"\
    0.12E12\")\n  0.12E12\n*/\nfloat! (float) convert_string_to_float(string number)\n\
    {\n  if(number.indexOf(\".\") != -1)\n    return std.math.tofloat(number);\n \
    \ else\n    return std.strtod!(number, \"\");\n}\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n  if(numbers.length == 0)\n    error(\"Invalid list of numbers: %s\", numbers);\n\
    \  if(numbers.length < 2)\n    error(\"List of numbers must be of length at least\
    \ two: %s\", numbers);\n  var largest = numbers[0];\n  var smallest = numbers[0];\n\
    \  for(int i = 1; i < numbers.length; i++)\n  {\n    if(numbers[i] < smallest)\n\
    \      smallest = numbers[i];\n    if(numbers[i] > largest)\n      largest = numbers[i];\n\
    \  }\n  return Tuple!(smallest, largest);\n}\n/*\n Convert a string representation\
    \ of a float or integer into a number.\n \n Example:\n  >>> convert_string_to_float(\"\
    0.12\")\n  0.12\n  >>> convert_string_to_float(\"100\")\n  100.0\n  >>> convert_string_to_float(\"\
    100.0\")\n  100.0\n  >>> convert_string_to_float(\"0.12E12\")\n  0.12E12\n*/\n\
    float! (float) convert_string_to_float(string number)\n{", "{\n    float[int]\
    \ indexedNumbers;\n    int n = 0;\n    for(int i : numbers)\n    {\n        indexedNumbers[n]\
    \ = i;\n        n++;\n    }", "{\n    float smallest = numbers[0];\n    float\
    \ largest = numbers[0];", "    where T: std.IEquatable<T> \n{\n    // Convert\
    \ each number to its \"distance\" from the first element \n    float smallest\
    \ = numbers[0];\n    float largest = numbers[0];\n    for (float number : numbers)\
    \ {\n        float distanceToTheFirst = distance(number, smallest);\n        smallest\
    \ = min(number, smallest);\n        largest = max(number, largest);\n    }", "{\n\
    \   var l: float =numbers[0];\n   var r: float =numbers[1];\n   \n   for (var\
    \ i = 2; i < numbers.len(); i++) \n   {\n      var m: float=numbers[i];\n    \
    \  var c: float =l+r;\n      var d: float=l-r;\n      \n      if (d < Math.abs(m-l)\
    \ || d < Math.abs(r-m)  ) {\n          l = m; \n      }\n      else {\n      \
    \    r = m; \n      }\n   }\n   return Tuple!( l, r );\n}\n/**\n * Return two\
    \ numbers from the given array (numbers) that are closest to each\n * other and\
    \ return them in order (smaller number, larger number). The first one is\n * included\
    \ and the second one is excluded.\n */\nTuple!(float, float) find_closest_elements_excluding_first_one(float\
    \ [] numbers) \n{\n    return find_closest_elements(numbers).v;\n}", "{\n\tfloat\
    \ temp1 = numbers[1];\n\tfloat temp2 = numbers[0];\n\tfloat diff1 = abs(temp1\
    \ - temp2);\n\tint idx = 1;\n\tfor(int i = 2; i < numbers.length; i++) \n\t{\n\
    \t\tfloat temp = numbers[i];\n\t\tfloat diff2 = abs(temp - temp1);\n\t\tif(diff2\
    \ < diff1)\n\t\t{\n\t\t\tdiff1 = diff2;\n\t\t\tidx = i;\n\t\t}\n\t}\n\treturn\
    \ Tuple!(temp1, temp2);\n}", "{\n    int minIndex = FindMin(numbers, numbers.length);\n\
    \    return Tuple(numbers[minIndex], numbers[FindMax(numbers, numbers.length)\
    \ - minIndex]);\n}", "{\n    \n    Vector[int, int] v;\n    Vector[float, float]\
    \ w;\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        v.push_back(i);\n\
    \        w.push_back(numbers[i]);\n    }\n    \n    while(true)\n    {\n     \
    \   int min = v[0];\n        int max = v[1];\n        float minw = w[0], maxw\
    \ = w[1];\n        for(int i = 2; i < v.size(); ++i)\n        {\n            if(v[i]\
    \ < max)\n            {\n                max = v[i];\n                maxw = w[i];\n\
    \            }\n            if(v[i] > min)\n            {\n                min\
    \ = v[i];\n                minw = w[i];\n            }\n        }\n        if(max\
    \ > min) return Tuple!(float,float)(fmax(minw, maxw), fmin(minw, maxw));\n   \
    \     v.push_back(min);\n        w.push_back(minw);\n        v.push_back(max);\n\
    \        w.push_back(maxw);\n    }\n}\n</cell>\n<cell>\n%python\nfrom libc.stdlib\
    \ cimport malloc, free\nfrom ctypes import Structure, c_float, sizeof\nfrom typing\
    \ import List\nfrom math import fmax, fmin", "{\n    var min = math.min(numbers);\n\
    \    var max = math.max(numbers);\n    var mid = (min + max) / 2;\n    if (numbers.length\
    \ <= 2)\n        return (mid, mid);\n    else\n        return (find_closest_elements(numbers.slice(1))\
    \ + min);\n}", "{\n    int min = 0;\n    int max = numbers.length - 1;\n    float\
    \ result = Float.NaN;\n    \n    while (min <= max) \n    {\n        float mid\
    \ = min + (max - min) / 2;\n        \n        if (numbers[mid] == numbers[min])\n\
    \        {\n            result = numbers[min];\n            min = mid + 1;\n \
    \       }\n        else if (numbers[mid] < numbers[min])\n        {\n        \
    \    min = mid + 1;\n        }\n        else\n        {\n            result =\
    \ numbers[max];\n            max = mid - 1;\n        }\n    }\n    return Tuple!(result,\
    \ result);\n}", "{\n    if (numbers.Length < 2) \n        error(\"find_closest_elements\
    \ expects at least two numbers.\"); \n    var smaller = math.min(numbers[0], numbers[1]);\n\
    \    var larger = math.max(numbers[0], numbers[1]);\n    if (larger - smaller\
    \ <= 0.0000001) {\n        return Tuple!(smaller, larger);\n    }", "{\n    Tuple!(float,\
    \ float)\n    float smallest = math.min(numbers);\n    float largest = math.max(numbers);\n\
    \    float difference = largest - smallest;\n    float sum = 0;\n    for (float\
    \ number in numbers)\n    {\n        sum += number;\n        if (sum < smallest)\n\
    \        {\n            smallest = sum;\n        }\n        if (sum > largest)\n\
    \        {\n            largest = sum;\n        }\n    }\n    return (smallest,\
    \ largest);\n}", "    where numbers.length >= 2 {\n    let mutable mindist = float.max;\n\
    \    let mutable minelement: float = numbers.[0];\n    let mutable maxelement:\
    \ float = numbers.[0];\n    let mutable maxdistance: float = numbers.[0];\n  \
    \  for i in numbers[1..] {\n        let mutable distance = abs(minelement - i).abs();\n\
    \        if (mindistance < distance) {\n            mindistance = distance;\n\
    \            minelement = i;\n        }\n        else { \n            distance\
    \ = abs(maxelement - i).abs();\n            if (maxdistance < distance) {\n  \
    \              maxdistance = distance;\n                maxelement = i;\n    \
    \        }\n        }\n    }\n    let x = minelement;\n    let y = maxelement;\n\
    \    let distance = abs(x - y);\n    Tuple!(x, y, distance);\n}\n</code>\n<|/\
    \ a tags=f#,algorithm,performance |>\n<| a dscore=1 tags=f#,algorithm,performance\
    \ |>\nA simple way to solve this problem (using LINQ):\n<code>\nopen System.Collections.Generic\n\
    open System.Linq\nopen System.Collections\nopen System.Linq.Expressions", "{\n\
    \    Array!(float) numberArray = numbers;\n    Array!(float) closestArray = arrayOf;\n\
    \    \n    double minDistance = double(distance(numbers[0], numbers[1]));\n  \
    \  \n    foreach(number in numberArray) {\n        double currentDistance = distance(number,\
    \ numbers[1]);\n        if(currentDistance < minDistance) {\n            minDistance\
    \ = currentDistance;\n            closestArray[0] = number;\n        }\n     \
    \   else if(currentDistance == minDistance) {\n            closestArray[1] = number;\n\
    \        }\n    }\n    return Tuple!(closestArray[0], closestArray[1]);\n}", "{\n\
    \    float minValue = numbers[0];\n    float maxValue = numbers[0];\n    for(float\
    \ number : numbers) {\n        if(number > maxValue) {\n            maxValue =\
    \ number;\n        }\n        if(number < minValue) {\n            minValue =\
    \ number;\n        }\n    }", "{\n  assert(numbers.length >= 2);\n  float max1\
    \ = numbers[0];\n  float min1 = numbers[0];\n  for(int i = 0; i < numbers.length;\
    \ ++i)\n  {\n    float num1 = numbers[i];\n    if(num1 < min1)\n    {\n      min1\
    \ = num1;\n    }\n    if(num1 > max1)\n    {\n      max1 = num1;\n    }\n  }\n\
    \  float max2 = numbers[0];\n  float min2 = numbers[0];\n  for(int i = 1; i <\
    \ numbers.length; ++i)\n  {\n    float num2 = numbers[i];\n    if(num2 < min2)\n\
    \    {\n      min2 = num2;\n    }\n    if(num2 > max2)\n    {\n      max2 = num2;\n\
    \    }\n  }\n  float max3 = numbers[0];\n  float min3 = numbers[0];\n  for(int\
    \ i = 2; i < numbers.length; ++i)\n  {\n    float num3 = numbers[i];\n    if(num3\
    \ < min3)\n    {\n      min3 = num3;\n    }\n    if(num3 > max3)\n    {\n    \
    \  max3 = num3;\n    }\n  }\n  if(max1 < min2 || min2 < max3 || max1 < min3)\n\
    \  {\n    throw Exception(\"find_closest_elements failed, no combination of numbers\
    \ is closer to each other than other combinations of numbers.\");\n  }\n  return\
    \ Tuple!(float,float) (min1, max1);\n}", "{\n\tvar small = numbers[0];\n\tvar\
    \ largest = numbers[0];", "{\n\tfor(float num : numbers)\n\t{\n\t\tif(abs(num\
    \ - numbers[0]) < abs(num - numbers[1]))\n\t\t{\n\t\t\treturn Tuple!(float,float)!(numbers[0],\
    \ numbers[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn Tuple!(float,float)!(numbers[1],\
    \ numbers[0]);\n\t\t}\n\t}\n\treturn Tuple!(float,float)!(numbers[1], numbers[0]);\n\
    }", "{\n    if (numbers.length < 2) \n        return make_tuple(numbers[0], numbers[0]);\n\
    \        \n    float closest = numbers[0];\n    int closestIndex = 0;\n    for\
    \ (int i = 1; i < numbers.length; i++) {\n        if (numbers[i] < closest) {\n\
    \            closest = numbers[i];\n            closestIndex = i;\n        }\n\
    \    }\n    \n    return make_tuple(closest, numbers[closestIndex]);\n}\n'''",
  "{\n    if (numbers.length < 2)\n        return Tuple!(0, 0);\n    var min = numbers[0];\n\
    \    var max = numbers[0];\n    for (var i = 1; i < numbers.length; i++) {\n \
    \       var d = numbers[i] - min;\n        if (d < min) {\n            min = d;\n\
    \            min = i;\n        } else if (d > max) {\n            max = d;\n \
    \           max = i;\n        }\n    }\n    return Tuple!(min, max);\n}\n*/",
  "    where {\n    size_t count = 0;\n    for (float f : numbers) {\n        if (count\
    \ < 2) {\n            count++;\n            return Tuple!(f, f);\n        }\n\
    \        else {\n            float f_old = f;\n            float f = f + 0.5;\n\
    \            float g = f + 0.5;\n            if ((f < f_old)) {\n            \
    \    count++;\n                return Tuple!(f, f);\n            }\n         \
    \   else if ((g < f_old)) {\n                count++;\n                return\
    \ Tuple!(f, g);\n            }\n        }\n    }\n    return Tuple!(numbers[0],\
    \ numbers[0]);\n}\n#endif\n\"\"\"", "{\n\tvar max_dist = math.abs(numbers[0] -\
    \ numbers[1]);\n\tvar min_dist = math.abs(numbers[0] - numbers[1]);\n\tvar closest\
    \ = numbers[0];\n\tfor (var i = 1; i < numbers.length; ++i) {\n\t\tvar distance\
    \ = math.abs(numbers[i] - closest);\n\t\tif (distance < min_dist) {\n\t\t\tmin_dist\
    \ = distance;\n\t\t\tclosest = numbers[i];\n\t\t}\n\t\tif (distance > max_dist)\
    \ {\n\t\t\tmax_dist = distance;\n\t\t\tclosest = numbers[i];\n\t\t}\n\t}\n\treturn\
    \ Tuple(closest, closest);\n}", "{\n    var min1: float;\n    var min2: float;\n\
    \    \n    var min1_index: uint;\n    var min2_index: uint;\n    \n    var min1_dist:\
    \ float64;\n    var min2_dist: float64;\n    \n    var min_distance: float64;\n\
    \    \n    var current_index: uint = 0;\n    \n    var numbers_length = numbers.length;\n\
    \    \n    var current_number: float = numbers[current_index];\n    \n    while(current_index\
    \ < numbers_length)\n    {\n        var next_number = numbers[current_index +\
    \ 1];\n        \n        if(min1 == null)\n        {\n            min1 = current_number;\n\
    \            min1_index = current_index;\n            min1_dist = abs(next_number\
    \ - min1);\n        }\n        else if(next_number < min1)\n        {\n      \
    \      min2 = current_number;\n            min2_index = current_index;\n     \
    \       min2_dist = abs(next_number - min2);\n        }\n        else if(next_number\
    \ > min1)\n        {\n            if(min1_dist > min2_dist)\n            {\n \
    \               min2 = current_number;\n                min2_index = current_index;\n\
    \                min2_dist = abs(next_number - min2);\n            }\n       \
    \     else\n            {\n                min1 = current_number;\n          \
    \      min1_index = current_index;\n                min1_dist = abs(next_number\
    \ - min1);\n            }\n        }\n        \n        current_index += 1;\n\
    \        current_number = next_number;\n    }\n    \n    min_distance = (min1_dist\
    \ + min2_dist);\n    \n    return Tuple!(min1, min2);\n}", "{\n  assert(numbers.length\
    \ >= 2, \"find_closest_elements called with an empty array.\");\n  \n  return\
    \ Tuple!(number, number) [ \n    numbers[0], numbers[1] ];\n}", "{\n\tfloat minNum\
    \ = numbers[0];\n\tfloat maxNum = numbers[0];\n\tforeach(float num, numbers) {\n\
    \t\tif(num < minNum) minNum = num;\n\t\tif(num > maxNum) maxNum = num;\n\t}\n\t\
    return Tuple!(minNum, maxNum);\n}", "{\n    var min1d: float = numbers[0];\n \
    \   var min2d: Tuple!(float, float) = (0, 0);\n    var min3d: Tuple!(float, float,\
    \ float) = Tuple!(0, 0);", "{\n  FloatingPointComparisons!(numbers); //make sure\
    \ we're comparing floating point numbers and not a whole number\n  Tuple!(float,float)\
    \ smallest, largest;\n  smallest.first = (-FloatingPointComparisons!(_) -> FloatingPointComparisons!(_)\
    \ < FloatingPointComparisons!(_), 0.f);\n  largest.first = (FloatingPointComparisons!(_)\
    \ -> FloatingPointComparisons!(_) > FloatingPointComparisons!(_), 0.f);\n  smallest.second\
    \ = FloatingPointComparisons!(_);\n  largest.second = FloatingPointComparisons!(_);\n\
    \  \n  for (int i = numbers.Length - 1; i >= 0; i--) \n  {\n    \n    if (FloatingPointComparisons!(_)\
    \ < FloatingPointComparisons!(_)) \n    {\n      smallest.first = (FloatingPointComparisons!(_),\
    \ numbers[i]);\n      smallest.second = numbers[i];\n    } \n    else \n    {\n\
    \      smallest.second = FloatingPointComparisons!(_);\n      largest.first =\
    \ FloatingPointComparisons!(_);\n      largest.second = numbers[i];\n    }\n \
    \ }\n  return smallest;\n}\n/*\n From a supplied array of numbers (of length at\
    \ least two) select and return two that are the closest to each\n    other and\
    \ return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float,float)\
    \ find_closest_elements(float[][] numbers) \n{\n  FloatingPointComparisons!(numbers);\n\
    \  Tuple!(float,float) smallest, largest;\n  smallest.first = (-FloatingPointComparisons!(_)\
    \ -> FloatingPointComparisons!(_) < FloatingPointComparisons!(_), 0.f);\n  largest.first\
    \ = (FloatingPointComparisons!(_) -> FloatingPointComparisons!(_) > FloatingPointComparisons!(_),\
    \ 0.f);\n  smallest.second = FloatingPointComparisons!(_);\n  largest.second =\
    \ FloatingPointComparisons!(_);\n  \n  for (int i = 0; i < numbers.Length; i++)\
    \ \n  {\n    \n    for (int j = numbers.Length - 1; j >= 0; j--) \n    {\n   \
    \   \n      if (FloatingPointComparisons!(_) < FloatingPointComparisons!(numbers[i][j",
  "{\n    float smallest = numbers[0];\n    float largest = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; ++i){\n        smallest = std::min(smallest, numbers[i]);\n\
    \        largest = std::max(largest, numbers[i]);\n    }\n    return Tuple!(smallest,\
    \ largest);\n}", "{\n\tfloat min = numbers[0], max = numbers[0];\n\t\n\tfor int\
    \ i = 0; i < numbers.length; ++i {\n\t\tif (numbers[i] < min) {\n\t\t\tmin = numbers[i];\n\
    \t\t} else if (numbers[i] > max) {\n\t\t\tmax = numbers[i];\n\t\t}\n\t}\n\treturn\
    \ Tuple!(float, float)(min, max);\n}", "{\n    if (numbers.length < 2) \n    \
    \    return Tuple!(0.f, 0.f);\n    int low = 0;\n    int high = numbers.length\
    \ - 1;\n    while (low <= high) \n    {\n        int mid = low + ((high - low)\
    \ >> 1);\n        float left_number = numbers[mid];\n        float right_number\
    \ = numbers[mid + 1];\n        if (left_number < right_number) \n            low\
    \ = mid + 1;\n        else\n            high = mid - 1;\n    }\n    return Tuple!(numbers[low],\
    \ numbers[high]);\n}", "{\n\tfor (float number : numbers) {\n\t\tfor (float x\
    \ : numbers) {\n\t\t\tif (x == number) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfloat\
    \ delta = x - number;\n\t\t\tif (delta <= 0.0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\
    \t\t\tif (delta == math.abs(delta)) {\n\t\t\t\treturn (x, number);\n\t\t\t}\n\t\
    \t\tif (delta > math.abs(delta)) {\n\t\t\t\tfloat tmp = number;\n\t\t\t\tnumber\
    \ = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t}\n\t}\n\tassert(false);\n\treturn (numbers[0],\
    \ numbers[0]);\n}", "    where {\n        if (numbers.length <= 1) return numbers;\n\
    \        float[] distances = new float[numbers.length];\n        float smallestDistance\
    \ = float.infinity;\n        for (int i = 0; i < numbers.length; i++) {\n    \
    \        distances[i] = abs(numbers[i] - numbers[i - 1]);\n            if (distances[i]\
    \ < smallestDistance) {\n                smallestDistance = distances[i];\n  \
    \          }\n        }\n        float closestNumber = numbers[0];\n        float\
    \ closestDistance = float.infinity;\n        for (int i = 1; i < numbers.length;\
    \ i++) {\n            if (abs(numbers[i] - closestNumber) < closestDistance) {\n\
    \                closestDistance = abs(numbers[i] - closestNumber);\n        \
    \        closestNumber = numbers[i];\n            }\n        }\n        return\
    \ Tuple!(closestNumber, closestDistance);\n    }\n/*\n From a supplied array of\
    \ numbers (of length at least two) select and return two that are the closest\
    \ to each\n    other and return them in order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    Tuple(2.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    Tuple(2.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float2 numbers) \n\
    \    where {\n        if (numbers.length <= 1) return numbers;\n        float[]\
    \ distances = new float[numbers.length];\n        float smallestDistance = float.infinity;\n\
    \        for (int i = 0; i < numbers.length; i++) {\n            distances[i]\
    \ = abs(numbers[i] - numbers[i - 1]);\n            if (distances[i] < smallestDistance)\
    \ {\n                smallestDistance = distances[i];\n            }\n       \
    \ }\n        float closestNumber = numbers[0];\n        float closestDistance\
    \ = float.infinity;\n        for (int i = 1; i < numbers.length; i++) {\n    \
    \        if (abs(numbers[i] - closestNumber) < closestDistance) {\n          \
    \      closestDistance = abs(numbers[i] - closestNumber);\n                closestNumber\
    \ = numbers[i];\n            }\n        }\n        return Tuple!(closestNumber,\
    \ closestDistance);\n    }\n/*\n From a supplied array of numbers (of length at\
    \ least two) select and return two that are the closest to each\n    other and\
    \ return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    Tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    Tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float)\
    \ find_closest_elements(float3 numbers) \n    where {\n        if (numbers.length\
    \ <= 1) return numbers;\n        float[] distances = new float[numbers.length];\n\
    \        float smallestDistance = float.in", "{\n    int j = 0;\n    int k = 1;\n\
    \    int i = 1;\n    while (i <= numbers.length - 1) {\n        while (j < i)\
    \ {\n            if (numbers[j] < numbers[k])\n                swap(&numbers[j],\
    \ &numbers[k]);\n            k += 1;\n        }\n        j += 1;\n        k +=\
    \ 1;\n        i += 1;\n    }\n    return (numbers[0], numbers[k - 1]);\n}\n/*\n\
    \ From a supplied array of numbers (of length at least two) select and return\
    \ two that are the closest to each\n    other and return them in reverse order\
    \ (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n    tuple(5.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0])\n    tuple(5.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements_reversed(float[]\
    \ numbers) \n{\n    int j = 0;\n    int k = 1;\n    int i = 1;\n    while (i <=\
    \ numbers.length - 1) {\n        while (j < i) {\n            if (numbers[k] <\
    \ numbers[j])\n                swap(&numbers[k], &numbers[j]);\n            j\
    \ += 1;\n        }\n        k -= 1;\n        j += 1;\n        i += 1;\n    }\n\
    \    return (numbers[k], numbers[0]);\n}\n/*\n From a supplied array of numbers\
    \ (of length at least two) select and return two that are the closest to each\n\
    \    other and return them in order (smaller number, larger number).\n    >>>\
    \ find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2, 8.0])\n    tuple(5.0, 2.2)\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2, 1.0])\n    tuple(5.0,\
    \ 2.2)\n    \n*/\nTuple!(float, float) find_closest_elements_reversed_order(float[]\
    \ numbers) \n{\n    int j = 0;\n    int k = 1;\n    int i = 1;\n    while (i <=\
    \ numbers.length - 1) {\n        while (j < i) {\n            if (numbers[k] <\
    \ numbers[j])\n                swap(&numbers[k], &numbers[j]);\n            j\
    \ += 1;\n        }\n        k -= 1;\n        j += 1;\n        i += 1;\n    }\n\
    \    return (numbers[k], numbers[0]);\n}\n/*\n From a supplied array of numbers\
    \ (of length at least two) select and return two that are the closest to each\n\
    \    other and return them in reverse order (smaller number, larger number).\n\
    \    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2, 8.0])\n    tuple(5.0,\
    \ 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2, 1.0])\n \
    \   tuple(5.0, 2.2)\n    \n*/\nTuple!(float, float) find_closest_", "{\n\tif (numbers.length\
    \ < 2) {\n\t\treturn make_tuple(-1, -1);\n\t}\n\tfloat x1 = numbers[0];\n\tfloat\
    \ x2 = numbers[1];\n\tfloat y1;\n\tfloat y2;\n\tfloat y3;\n\tfloat y4;\n\tfloat\
    \ t;\n\tif (x1 == x2) {\n\t\ty1 = y2 = y3 = y4 = x1;\n\t} else if (y1 > x2) {\n\
    \t\ty1 = y2;\n\t\ty2 = y1;\n\t\ty4 = y3;\n\t\ty3 = y4;\n\t} else {\n\t\ty1 = x2;\n\
    \t\ty2 = x1;\n\t\ty3 = y4;\n\t\ty4 = y3;\n\t}", "{\n\tTuple!(float, float) ret;\n\
    \tfloat min = numbers[0];\n\tfloat max = numbers[0];\n\t\n\tfor (float n: numbers)\n\
    \t{\n\t\tif (n < min)\n\t\t{\n\t\t\tmin = n;\n\t\t}\n\t\t\n\t\tif (n > max)\n\t\
    \t{\n\t\t\tmax = n;\n\t\t}\n\t}\n\t\n\tret.Item1 = min;\n\tret.Item2 = max;\n\t\
    return ret;\n}", "{\n    var minval: float = numbers[0];\n    var maxval: float\
    \ = numbers[0];\n    \n    var currentmin: float;\n    var currentmax: float;\n\
    \    var smallest: float;\n    var largest: float;\n    \n    var num: uint =\
    \ numbers.length;\n    \n    for (uint i = 0; i < num; i++) {\n        if (numbers[i]\
    \ < minval) {\n            minval = numbers[i];\n        }\n        \n       \
    \ if (numbers[i] > maxval) {\n            maxval = numbers[i];\n        }\n  \
    \  }\n    \n    smallest = minval;\n    largest = maxval;\n    \n    for (uint\
    \ i = 0; i < num; i++) {\n        if (numbers[i] < smallest) {\n            smallest\
    \ = numbers[i];\n        }\n        \n        if (numbers[i] > largest) {\n  \
    \          largest = numbers[i];\n        }\n    }\n    \n    return Tuple!(smallest,\
    \ largest);\n}", "{\n    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    \n    for each (float number in numbers) {\n        if (number > largest)\
    \ largest = number;\n        if (number < smallest) smallest = number;\n    }\n\
    \    \n    return Tuple!(smallest, largest);\n}", "{\n    \n    int firstIndex\
    \ = std::distance(numbers.begin(), std::min_element(numbers.begin(), numbers.end()));\n\
    \    int secondIndex = std::distance(numbers.begin(), std::max_element(numbers.begin(),\
    \ numbers.end()));\n    return Tuple!(numbers[firstIndex], numbers[secondIndex]);\n\
    }", "{\n    var min1 = float.max(numbers[0], numbers[1]);\n    var min2 = float.max(numbers[0],\
    \ numbers[1]);\n    for(var i = 2; i < numbers.length; i++) {\n        var m =\
    \ float.max(numbers[i], numbers[i-1]);\n        min1 = float.min(min1, m);\n \
    \       min2 = float.min(min2, m);\n    }\n    return Tuple!(min1, min2);\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThe code works as expected! Thank you very much! I\
    \ am very new to swift so this is very helpful.\n<|/ c |>\n<| c |>\nI guess it\
    \ should be `var min1 = float.min(numbers[0], numbers[1]);` `var min2 = float.min(numbers[0],\
    \ numbers[1]);` and also `var min1 = float.min(min1, m);` and `var min2 = float.min(min2,\
    \ m);`\n<|/ c |>\n<| c |>\n`var min1 = min2;` seems useless here.\n<|/ c |>\n\
    <| c |>\n: Yes, thanks for noticing. I just copied the code from the OP. Now corrected.\n\
    <|/ c |>\n<| c |>\nThe original code doesn't seem to handle negative numbers correctly.\
    \ Instead of `min(min1, min2)`, it returns `min1` twice (which is clearly wrong\
    \ since `min(min2, min1)` gives the correct answer). This answer seems to work\
    \ better: https://stackoverflow.com/a/46291479/9178704\n<|/ c |>\n<| a dscore=3\
    \ |>\nThis should work perfectly:\n<code>\nfunc getClosestElement(fromArray array:\
    \ [Double]) -> Double {\n    var minElement = Double.max\n    for element in array\
    \ {\n        if element < minElement {\n            minElement = element\n   \
    \     }\n    }\n    return minElement\n}\n</code>\n<|/ a tags=swift |>\n<| a |>\n\
    Here is another solution without sorting. Just iterate and check if current element\
    \ is less than previous.\n<code>\nvar minValue: Double?\nfor value in array\n\
    {\n    if let newMinValue = minValue\n    {\n        if value < newMinValue\n\
    \        {\n            break\n        }\n    }\n    minValue = value\n}\n</code>\n\
    <|/ a tags=swift dscore=2 |>\n<| c |>\nThis will only work if all values are positive.\
    \ Better to just sort.\n<|/ c |>\n<| c |>\n, yes, sorry for that.\n<|/ c |>\n\
    <| a dscore=2 |>\n", "{\n\tfloat smallest1 = numbers[0];\n\tfloat smallest2 =\
    \ numbers[0];\n\tfloat difference1 = numbers[0] - numbers[1];\n\tfloat difference2\
    \ = numbers[1] - numbers[2];\n\tfloat difference3 = numbers[2] - numbers[3];\n\
    \tfloat difference4 = numbers[3] - numbers[4];\n\tfloat difference5 = numbers[4]\
    \ - numbers[5];", "{\n\tauto closest_two = numbers.iter()\n\t\t.zip(numbers.iter().skip(1))\n\
    \t\t.min_by([](Tuple!(float, float) a, Tuple!(float, float) b) {\n\t\t\treturn\
    \ a.0 < (b.0 ? a.1 - b.1 : b.0 - a.1);\n\t\t});", "{\n    Tuple!(float, float)\
    \ ret;\n    float min = numbers[0];\n    float max = numbers[0];\n    \n    foreach(i\
    \ : numbers){\n        float curr = (float) i;\n        if (curr < min){\n   \
    \         min = curr;\n        }\n        else if (curr > max){\n            max\
    \ = curr;\n        }\n    }\n    Tuple!(float, float) ret2 = Tuple!(float, float)(min,\
    \ max);\n    return ret2;\n}", "{\n\tint min = (int) numbers[0];\n\tint max =\
    \ (int) numbers[0];\n\t\n\tfor (int i = 0; i < numbers.Length; i++)\n\t{\n\t\t\
    if (numbers[i] > max)\n\t\t{\n\t\t\tmax = numbers[i];\n\t\t}\n\t\tif (numbers[i]\
    \ < min)\n\t\t{\n\t\t\tmin = numbers[i];\n\t\t}\n\t}", "{\n\tint N = numbers.length;\n\
    \tif (N < 2) return Tuple!(float, float) _;\n\tfloat min = numbers[0];\n\tfloat\
    \ max = numbers[0];\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tif (numbers[i] <\
    \ min)\n\t\t{\n\t\t\tmin = numbers[i];\n\t\t}\n\t\telse if (numbers[i] > max)\n\
    \t\t{\n\t\t\tmax = numbers[i];\n\t\t}\n\t}\n\treturn Tuple!(float, float) min/max;\n\
    }\n/*\n Return a float array containing all elements in a dictionary ordered by\
    \ the value\n    \n    From a dictionary return the elements in a sorted array\
    \ ordered by the value\n*/\nfloat[] get_sorted_array(Dictionary<string, float>\
    \ dictionary) \n{\n\tfloat[] result = new float[dictionary.count];\n\tfor (KeyValuePair<string,\
    \ float> kvp in dictionary)\n\t{\n\t\tresult[dictionary.indexOf(kvp)] = kvp.value;\n\
    \t}\n\tArrays.sort(result);\n\treturn result;\n}", "{\n    assert(numbers.length\
    \ >= 2);\n    float smallest_diff=numbers[0];\n    float largest_diff=numbers[1];\n\
    \    for (int i=1; i<numbers.length; i+=2){\n        float diff=numbers[i]-numbers[i-1];\n\
    \        if (diff<smallest_diff){\n            smallest_diff=diff;\n        }\n\
    \        if (diff>largest_diff){\n            largest_diff=diff;\n        }\n\
    \    }\n    return tuple(smallest_diff,largest_diff);\n}\n\"\"\"", "{\n   for\
    \ (i : 0 to numbers.length - 1)\n   {\n      if(numbers[i] < numbers[i+1])\n \
    \     {\n         return Tuple!(numbers[i], numbers[i+1]);\n      }\n   }\n  \
    \ return Tuple!(numbers[0], numbers[0]);\n}", "{\n    // Create an array of floats\n\
    \    var floatArray = new Float32Array(numbers);\n    // Create a min and max\
    \ vars\n    var min = floatArray[0];\n    var max = floatArray[0];\n    var minIndex\
    \ = 0;\n    var maxIndex = 0;\n    // Loop through all the numbers until we find\
    \ a min\n    for (var i = 0; i < floatArray.length; ++i) {\n        if (floatArray[i]\
    \ < min) {\n            min = floatArray[i];\n            minIndex = i;\n    \
    \    }\n    }\n    // Loop through all the numbers until we find a max\n    for\
    \ (var i = 0; i < floatArray.length; ++i) {\n        if (floatArray[i] > max)\
    \ {\n            max = floatArray[i];\n            maxIndex = i;\n        }\n\
    \    }\n    // Return the min and max\n    return Tuple!(floatArray[minIndex],\
    \ floatArray[maxIndex]);\n}\n/*\n Return an array of numbers from [start, stop)\
    \ (both inclusive) in random order\n    \n From http://stackoverflow.com/a/627438/328857\n\
    \ http://stackoverflow.com/a/1660405/328857\n*/\nFloat32Array! random_inside_range(float\
    \ start, float stop)\n{\n    var arr = new Float32Array(2);\n    arr[0] = start;\n\
    \    arr[1] = stop;\n    var random = Random.new(arr.length);\n    arr.forEach((i)\
    \ => {arr[i] = random.nextFloat()});\n    return arr;\n}\n/*\n Select a random\
    \ float within the range [start, stop) and return it as two floats\n \n From http://stackoverflow.com/a/627438/328857\n\
    \ http://stackoverflow.com/a/1660405/328857\n*/\nTuple!(float,float) random_float_range_within_range(float\
    \ start, float stop)\n{\n    var arr = random_inside_range(start, stop);\n   \
    \ return Tuple!((arr[0]),(arr[1]));\n}\n/*\n Return a random float between a min\
    \ and max inclusive\n    \n From http://stackoverflow.com/a/627438/328857\n http://stackoverflow.com/a/1660405/328857\n\
    */\nfloat! random_float_within_range(float min, float max)\n{\n    return Random.newFloat(min,\
    \ max);\n}\n/*\n Select a random int within the range [start, stop) and return\
    \ it as two ints\n \n From http://stackoverflow.com/a/627438/328857\n http://stackoverflow.com/a/1660405/328857\n\
    */\nTuple!(int,int) random_int_range_within_range(int start, int stop)\n{\n  \
    \  var arr = random_inside_range(start, stop);\n    return Tuple!((arr[0]),(arr[1]));\n\
    }\n/*\n", "{\n    if (numbers.Length < 2)\n        throw new ArgumentException(\"\
    List must have at least two elements\");\n    \n    var minValue = numbers[0];\n\
    \    var maxValue = numbers[0];\n    for (var i = 1; i < numbers.Length; ++i)\n\
    \    {\n        var currentValue = numbers[i];\n        var currentDiff = math.abs(currentValue\
    \ - minValue);\n        if (currentDiff < maxValue)\n        {\n            maxValue\
    \ = currentValue;\n            maxDiff = currentDiff;\n        }\n        else\n\
    \        {\n            minValue = currentValue;\n            minDiff = currentDiff;\n\
    \        }\n    }\n    \n    var tuple = (minValue, maxValue);\n    return tuple;\n\
    }\n/*\n From a supplied array of numbers (of length at least two) select and return\
    \ two that are the closest to each\n    other and return them in order (smaller\
    \ number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[]\
    \ numbers, float tolerance) \n{\n    if (numbers.Length < 2)\n        throw new\
    \ ArgumentException(\"List must have at least two elements\");\n    \n    var\
    \ minValue = numbers[0];\n    var maxValue = numbers[0];\n    for (var i = 1;\
    \ i < numbers.Length; ++i)\n    {\n        var currentValue = numbers[i];\n  \
    \      var currentDiff = math.abs(currentValue - minValue);\n        if (currentDiff\
    \ < maxValue)\n        {\n            maxValue = currentValue;\n            maxDiff\
    \ = currentDiff;\n        }\n        else\n        {\n            minValue = currentValue;\n\
    \            minDiff = currentDiff;\n        }\n    }\n    \n    var tuple = (minValue,\
    \ maxValue);\n    return tuple;\n}\n/*\n From a supplied array of numbers (of\
    \ length at least two) select and return two that are the closest to each\n  \
    \  other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float)\
    \ find_closest_elements(float[] numbers, float tolerance, float direction) \n\
    {\n    if (numbers.Length < 2)\n        throw new ArgumentException(\"List must\
    \ have at least two elements\");\n    \n    var minValue = numbers[0];\n    var\
    \ maxValue = numbers[0];\n    var minDiff = math.abs(minValue);\n    var maxDiff\
    \ = math.abs(maxValue);\n    for (var i = 1; i < numbers.Length; ++i)\n    {\n\
    \        var currentValue = numbers[i];\n        var ", "{\n\tassert(numbers.length\
    \ > 2);\n\t\n\tfloat minValue = numbers[0];\n\tfloat maxValue = numbers[0];\n\t\
    \n\t// Find the minimum and maximum\n\tfor (float n : float)numbers[] {\n\t\t\
    if (n < minValue)\n\t\t\tminValue = n;\n\t\telse if (n > maxValue)\n\t\t\tmaxValue\
    \ = n;\n\t}\n\t\n\tfloat middle = num.floor_divide(numbers.lenght, 2);\n\t\n\t\
    return Tuple(maxValue, middle);\n}", "{\n    let l = numbers.length - 1;\n   \
    \ let result = vec![numbers[0]; l];\n    let max_val = numbers[0] as f64;\n  \
    \  let min_val = numbers[0] as f64;\n    for i in 0..l {\n        let val = numbers[i];\n\
    \        if val < min_val {\n            min_val = val;\n        } else if (val\
    \ > max_val) {\n            max_val = val;\n        }\n        result[i] = max_val;\n\
    \    }\n    result[l] = min_val;\n    return result;\n}\n/*\n Given a number of\
    \ things, return a list of tuples (of size 2) of the two things that is closest\
    \ to each\n    other and in order (smaller, larger).\n    >>> find_closest_elements([(1.0,\
    \ 2.0), (2.0, 1.0), (4.0, 5.0)])\n    tuple(4.0, 4.0)\n    >>> find_closest_elements([(1.0,\
    \ 2.0), (2.0, 1.0), (3.0, 4.0)])\n    tuple(1.0, 2.0)\n    \n*/\nTuple!(float,\
    \ float) find_closest_elements(Tuple!(float, float) numbers) \n{\n    let l =\
    \ numbers.length - 1;\n    let result = vec![numbers[0]; l];\n    let max_val\
    \ = numbers[0] as f64;\n    let min_val = numbers[0] as f64;\n    for i in 0..l\
    \ {\n        let val = numbers[i];\n        if val < min_val {\n            min_val\
    \ = val;\n        } else if (val > max_val) {\n            max_val = val;\n  \
    \      }\n        result[i] = max_val;\n    }\n    result[l] = min_val;\n    return\
    \ result;\n}\n/*\n Given a number of things, return a list of tuples (of size\
    \ 2) of the two things that is closest to each\n    other and in order (smaller,\
    \ larger).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0])\n    tuple(1.0,\
    \ 2.0)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0])\n    tuple(1.0,\
    \ 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] numbers)\
    \ \n{\n    let l = numbers.length - 1;\n    let result = vec![numbers[0]; l];\n\
    \    let max_val = numbers[0] as f64;\n    let min_val = numbers[0] as f64;\n\
    \    for i in 0..l {\n        let val = numbers[i];\n        if val < min_val\
    \ {\n            min_val = val;\n        } else if (val > max_val) {\n       \
    \     max_val = val;\n        }\n        result[i] = max_val;\n    }\n    result[l]\
    \ = min_val;\n    return result;\n}\n/*\n Given a number of things, return a list\
    \ of tuples (of size 2) of the two things that is closest to each\n    other and\
    \ in order (smaller, larger).\n    >>> find_closest_elements(Tuple(1.0, 2.0))\n\
    \    ", "{\n\tif(numbers.length < 2) \n\t{\n\t\tthrow new Exception(getpid(),\
    \ \"find_closest_elements called with less than two numbers\");\n\t}\n\t\n\tfloat\
    \ smallest = numbers[0];\n\tfloat largest = numbers[0];\n\tfor(int i = 1; i <\
    \ numbers.length; i++) \n\t{\n\t\tif(numbers[i] < smallest) \n\t\t{\n\t\t\tsmallest\
    \ = numbers[i];\n\t\t}\n\t\telse if(numbers[i] > largest)\n\t\t{\n\t\t\tlargest\
    \ = numbers[i];\n\t\t}\n\t}\n\treturn Tuple!(smallest, largest);\n}", "{\n\t//\
    \ TODO: Optimize for speed\n\tvar minIndex = 0;\n\tvar minValue = numbers[0];\n\
    \tfor (int i = 1; i < numbers.Length; i++) {\n\t\tvar value = numbers[i];\n\t\t\
    if (value < minValue) {\n\t\t\tminValue = value;\n\t\t\tminIndex = i;\n\t\t}\n\
    \t}\n\treturn Tuple!(numbers[minIndex], numbers[minIndex + 1]);\n}", "{\n\tfor\
    \ (float number in numbers)\n\t{\n\t\tfloat closest = number;\n\t\tfloat minDist\
    \ = number;\n\t\tfloat maxDist = number;\n\t\tfloat bestDifference = number;\n\
    \t\t\n\t\tfor (float othernumber in numbers)\n\t\t{\n\t\t\tfloat distance = std.distance(number,\
    \ othernumber);\n\t\t\tif (distance > maxDist)\n\t\t\t{\n\t\t\t\tmaxDist = distance;\n\
    \t\t\t\tbestDifference = maxDist - distance;\n\t\t\t\tbest = othernumber;\n\t\t\
    \t}\n\t\t\tif (distance < minDist)\n\t\t\t{\n\t\t\t\tminDist = distance;\n\t\t\
    \t\tbestDifference = minDist - distance;\n\t\t\t\tbest = number;\n\t\t\t}\n\t\t\
    }\n\t\t\n\t\tif (bestDifference < 0)\n\t\t{\n\t\t\tbest = closest;\n\t\t}\n\t\t\
    else\n\t\t{\n\t\t\tbest = best;\n\t\t}\n\t\t\n\t\tTuple!(float, float)!(best,best);\n\
    \t}\n}", "{\n    forall((i,j),i,j in numbers) \n    {\n        if ( abs(numbers[i]\
    \ - numbers[j]) <  eps )\n        {\n            return Tuple!(numbers[i], numbers[j]);\n\
    \        }\n    }\n    \n    return Tuple!( numbers[0], numbers[1]);\n}", "{\n\
    \    Tuple result = Tuple::new(numbers[0], numbers[0]);\n    foreach (float n\
    \ in numbers) {\n        Tuple near_result = Tuple::new(result._0, n);\n     \
    \   foreach (float m in numbers) {\n            if (abs(m - n) < abs(near_result._0\
    \ - n)) {\n                near_result = Tuple::new(result._0, n);\n         \
    \   }\n        }\n        result = near_result;\n    }\n    return result;\n}",
  "{\n    var max_index : usize = 0;\n    var min_index : usize = 0;\n    \n    for\
    \ (uint i = 0; i < numbers.lenght; i++)\n    {\n        if (numbers[i] > numbers[max_index])\n\
    \        {\n            max_index = i;\n        }\n        else if (numbers[i]\
    \ > numbers[min_index])\n        {\n            min_index = i;\n        }\n  \
    \  }\n    return Tuple!(numbers[min_index], numbers[max_index]);\n}", "{\n\tfloat2\
    \ min;\n\tfloat2 max;\n\tfloat2 min = numbers[0];\n\tfloat2 max = numbers[0];\n\
    \tfor (float2 number : numbers) {\n\t\tif (number < min) {\n\t\t\tmin = number;\n\
    \t\t} else if (number > max) {\n\t\t\tmax = number;\n\t\t}\n\t}\n\treturn Tuple!(min.x,\
    \ max.x);\n}", "{\n    float min;\n    float minIndex;\n    float max;\n    float\
    \ maxIndex;\n    min = numbers[0];\n    min = numbers[0];\n    minIndex = 0;\n\
    \    maxIndex = -1;\n    for(int i = 1; i < numbers.length; ++i)\n    {\n    \
    \    if(numbers[i] < min)\n        {\n            min = numbers[i];\n        \
    \    minIndex = i;\n        }\n        if(numbers[i] > max)\n        {\n     \
    \       max = numbers[i];\n            maxIndex = i;\n        }\n    }\n    return\
    \ (numbers[minIndex], numbers[maxIndex]);\n}", "{\n    int midpoint = numbers.length\
    \ / 2;\n    float smallestAbs = numbers[0];\n    float largestAbs = numbers[0];\n\
    \    float smallestIndex = -1;\n    float largestIndex = -1;\n    for (int i =\
    \ 1; i < numbers.length; i++)\n    {\n        float currentAbs = numbers[i];\n\
    \        if (currentAbs < smallestAbs)\n        {\n            smallestAbs = currentAbs;\n\
    \            smallestIndex = i;\n        }\n        else if (currentAbs > largestAbs)\n\
    \        {\n            largestAbs = currentAbs;\n            largestIndex = i;\n\
    \        }\n    }\n    \n    return Tuple!(smallestAbs, largestAbs);\n}\n'''",
  "{\n\tfloat result = Float.nan;\n\tfloat smaller = Float.nan;\n\tfloat greater =\
    \ Float.nan;\n\tfor (float number in numbers) {\n\t\tif (number < smaller) {\n\
    \t\t\tsmaller = number;\n\t\t} else if (number > greater) {\n\t\t\tgreater = number;\n\
    \t\t} else {\n\t\t\tresult = number;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn Tuple!(smaller,\
    \ greater, result);\n}", "{\n    var smallest, largest;\n    smallest = numbers[0];\n\
    \    largest = numbers[0];\n    for(float num : numbers) {\n        if(num < smallest\
    \ ) {\n            smallest = num;\n        }\n        if(num > largest ) {\n\
    \            largest = num;\n        }\n    }\n    return Tuple!(smallest, largest);\n\
    }\n/*\n From a supplied array of numbers (of length at least two) select and return\
    \ two that are the closest to each\n    other and return them in order (smaller\
    \ number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float2[]\
    \ numbers) \n{\n    var smallest, largest;\n    smallest = numbers[0];\n    largest\
    \ = numbers[0];\n    for(float num : numbers) {\n        if(num < smallest ) {\n\
    \            smallest = num;\n        }\n        if(num > largest ) {\n      \
    \      largest = num;\n        }\n    }\n    return Tuple!(smallest, largest);\n\
    }\n/*\n From a supplied array of numbers (of length at least two) select and return\
    \ two that are the closest to each\n    other and return them in order (smaller\
    \ number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float3[]\
    \ numbers) \n{\n    var smallest, largest;\n    smallest = numbers[0];\n    largest\
    \ = numbers[0];\n    for(float num : numbers) {\n        if(num < smallest ) {\n\
    \            smallest = num;\n        }\n        if(num > largest ) {\n      \
    \      largest = num;\n        }\n    }\n    return Tuple!(smallest, largest);\n\
    }\n/*\n From a supplied array of numbers (of length at least two) select and return\
    \ two that are the closest to each\n    other and return them in order (smaller\
    \ number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float4[]\
    \ numbers) \n{\n    var smallest, largest;\n    smallest = numbers[0];", "{\n\
    \    var minV = numbers[0];\n    var maxV = numbers[0];\n    var minI = -1;\n\
    \    var maxI = -1;\n    var i = 0;\n    foreach(number in numbers)\n    {\n \
    \       if(number < minV) minV = number;\n        if(number > maxV) maxV = number;\n\
    \        if(minI < 0 || number < minV) minI = i;\n        if(maxI < 0 || number\
    \ > maxV) maxI = i;\n        i += 1;\n    }\n    var t = minV;\n    var t2 = minV;\n\
    \    foreach(number in numbers)\n    {\n        if(number != t)\n        {\n \
    \           t2 = t;\n            t = number;\n        }\n        if(number !=\
    \ t2)\n        {\n            return Tuple!(float,t2);\n        }\n    }\n   \
    \ return Tuple!(float,t);\n}\n/*\n From a supplied array (of length at least two)\
    \ select and return two that are the closest to each\n    other and return them\
    \ in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float)\
    \ find_closest_elements(float[] numbers) \n{\n    var minV = numbers[0];\n   \
    \ var maxV = numbers[0];\n    var minI = -1;\n    var maxI = -1;\n    var i =\
    \ 0;\n    foreach(number in numbers)\n    {\n        if(number < minV) minV =\
    \ number;\n        if(number > maxV) maxV = number;\n        if(minI < 0 || number\
    \ < minV) minI = i;\n        if(maxI < 0 || number > maxV) maxI = i;\n       \
    \ i += 1;\n    }\n    var t = minV;\n    var t2 = minV;\n    foreach(number in\
    \ numbers)\n    {\n        if(number != t)\n        {\n            t2 = t;\n \
    \           t = number;\n        }\n        if(number != t2)\n        {\n    \
    \        return Tuple!(float,t2);\n        }\n    }\n    return Tuple!(float,t);\n\
    }\n/*\n From a supplied array of numbers (of length at least two) select and return\
    \ two that are the closest to each\n    other and return them in order (smaller\
    \ number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[] ",
  "{\n\tlet mindist = math::min(numbers);\n\tlet minindex = math::min(numbers, |number|\
    \ number - mindist);\n\treturn Tuple!(mindist, minindex);\n}\n/* Return the next\
    \ item in the given sequence that satisfies a predicate */\nTuple!(bool, float)\
    \ next_in_sequence(List!(Element) -> bool, elements: List!(Element) ) \n{\n\t\
    let next = List::new(elements);\n\tfor element in next {\n\t\tif (next(element))\
    \ {\n\t\t\treturn Tuple!(false, element);\n\t\t}\n\t}\n\treturn Tuple!(false,\
    \ next[0]);\n}\n/* Given an item and a sequence select the next item in the sequence\
    \ that satisfies a predicate\n   and return the index of that element in the sequence.\n\
    \   >>> select_next_in_sequence(2.0, [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n   2\n \
    \  >>> select_next_in_sequence(2.0, [1.0, 2.0, 3.0, 4.0, 5.0, 2.1])\n   0\n*/",
  "{\n    float[] a = sort(numbers);\n    int lower = a[0];\n    int higher = a[1];\n\
    \    while(higher - lower > 1)\n    {\n        int mid = lower + (higher - lower)\
    \ / 2;\n        if(abs(numbers[mid]) < abs(numbers[lower]))\n        {\n     \
    \       lower = mid;\n        }\n        else\n        {\n            higher =\
    \ mid;\n        }\n    }\n    return (lower, numbers[lower]);\n}", "{\n\tfloat\
    \ min1 = -100000, min2 = 100000;\n\tfloat max1 = 100000, max2 = -100000; ", "{\n\
    \    var m = numbers.length;\n    var closest = numbers[0];\n    var least = numbers[0];\n\
    \    var second_closest = numbers[0];\n    var second_least = numbers[0];\n  \
    \  \n    for (var i = 1; i < m; i++)\n    {\n        var a = numbers[i];\n   \
    \     var b = numbers[(i + 1) % m];\n        var distance = std.math.abs(a - b);\n\
    \        if (distance < least)\n        {\n            second_closest = closest;\n\
    \            second_least = least;\n            least = distance;\n          \
    \  closest = b;\n        }\n        else if (distance < closest)\n        {\n\
    \            second_closest = closest;\n            second_least = least;\n  \
    \          least = distance;\n            closest = a;\n        }\n        else\n\
    \        {\n            if (a < second_least)\n            {\n               \
    \ second_closest = closest;\n                second_least = a;\n             \
    \   least = distance;\n                closest = b;\n            }\n         \
    \   else\n            {\n                second_closest = least;\n           \
    \     second_least = b;\n                least = distance;\n                closest\
    \ = a;\n            }\n        }\n    }\n    \n    return Tuple!(closest, second_closest);\n\
    }\n/*\n From a supplied array of numbers (of length at least two) select and return\
    \ two that are the closest to each\n    other and return them in order (smaller\
    \ number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[]\
    \ numbers, int) \n{\n    var m = numbers.length;\n    var closest = numbers[0];\n\
    \    var least = numbers[0];\n    var second_closest = numbers[0];\n    var second_least\
    \ = numbers[0];\n    \n    for (var i = 1; i < m; i++)\n    {\n        var a =\
    \ numbers[i];\n        var b = numbers[(i + 1) % m];\n        var distance = std.math.abs(a\
    \ - b);\n        if (distance < least)\n        {\n            second_closest\
    \ = closest;\n            second_least = least;\n            least = distance;\n\
    \            closest = std.math.min(a, b);\n        }\n        else if (distance\
    \ < closest)\n        {\n            second_closest = closest;\n            second_least\
    \ = least;\n            least = distance;\n            closest = std.math.max(a,\
    \ b);\n        }\n        else\n        {\n            if (a < second_least)\n\
    \            {\n                second_closest = closest;\n                second_least\
    \ = a;\n                least = distance;\n                closest = std.math.min(a,\
    \ b);\n            }\n", "{\n    size_t len = numbers.length;\n    if(len < 2)\n\
    \        return (Tuple!(float, float)!(0, 0));\n    float smallest = Math.min(numbers[0],\
    \ numbers[1]);\n    float largest = Math.max(numbers[0], numbers[1]);\n    for(size_t\
    \ i = 2; i + 1 < len; ++i)\n    {\n        float midpoint = (numbers[i] + numbers[i+1])/2;\n\
    \        if(midpoint < smallest || midpoint > largest)\n            smallest =\
    \ midpoint;\n        else\n            largest = midpoint;\n    }\n    return\
    \ Tuple!(smallest, largest);\n}\n/*\n From a supplied array of numbers (of length\
    \ at least two) select and return two that are the closest to each\n    other\
    \ and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(int, int) find_closest_elements(int[]\
    \ numbers) \n{\n    size_t len = numbers.length;\n    if(len < 2)\n        return\
    \ (Tuple!(int, int)!(0, 0));\n    int smallest = Math.min(numbers[0], numbers[1]);\n\
    \    int largest = Math.max(numbers[0], numbers[1]);\n    for(size_t i = 2; i\
    \ + 1 < len; ++i)\n    {\n        int midpoint = (numbers[i] + numbers[i+1])/2;\n\
    \        if(midpoint < smallest || midpoint > largest)\n            smallest =\
    \ midpoint;\n        else\n            largest = midpoint;\n    }\n    return\
    \ Tuple!(smallest, largest);\n}", "{\n   let mut lowest_number = numbers[0];\n\
    \   let mut highest_number = numbers[0];\n   for number in numbers {\n      if\
    \ number < lowest_number {\n         lowest_number = number;\n      } else if\
    \ number > highest_number {\n         highest_number = number;\n      }\n   }\n\
    \   return Tuple(lowest_number, highest_number);\n}", "    => (float[2], float[2])\
    \ \n{\n    var min1 = 0.0f in; var min2 = 0.0f in; var max1 = numbers[1] in; var\
    \ max2 = numbers[0] in;\n    foreach(x from 0 .. numbers.length-1)\n    {\n  \
    \      if(numbers[x] < min1)\n        {\n            min1 = numbers[x];\n    \
    \    }\n        if(numbers[x] > max1)\n        {\n            max1 = numbers[x];\n\
    \        }\n        if(numbers[x] < min2)\n        {\n            min2 = numbers[x];\n\
    \        }\n        if(numbers[x] > max2)\n        {\n            max2 = numbers[x];\n\
    \        }\n    }\n    return Tuple!(float,float)(min1, min2), Tuple!(float,float)(max1,\
    \ max2);\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you for your answer, I\
    \ modified the question to make it clearer. Your answer does not work for this\
    \ case.\n<|/ c |>\n<| c |>\nI updated my answer with a new function. It should\
    \ now handle your new requirements.\n<|/ c |>\n<| a tags=c#,algorithm,c++ |>\n\
    I wrote the function using C++ and it works.\n<code>\nfloat FindClosestElement(vector<float>\
    \ numbers)\n{\n    float min1 = numbers[0];\n    float min2 = numbers[0];\n  \
    \  for (int i = 0; i < numbers.size() - 1; ++i)\n    {\n        if (numbers[i]\
    \ < min1)\n        {\n            min2 = min1;\n            min1 = numbers[i];\n\
    \        }\n        else if (numbers[i] > min2)\n        {\n            min2 =\
    \ numbers[i];\n        }\n        else\n            break;\n    }\n    float max1\
    \ = numbers[numbers.size() - 1];\n    float max2 = numbers[numbers.size() - 1];\n\
    \    for (int i = 0; i < numbers.size() - 1; ++i)\n    {\n        if (numbers[i]\
    \ > max2)\n        {\n            max2 = numbers[i];\n            max1 = numbers[numbers.size()\
    \ - 1 - i];\n        }\n        else if (numbers[i] < max1)\n        {\n     \
    \       max2 = numbers[i];\n            max1 = numbers[numbers.size() - 1 - i];\n\
    \        }\n        else\n            break;\n    }\n    float ans = min1;\n \
    \   for (int i = 0; i < numbers.size() - 1; ++i)\n    {\n        if (numbers[i]\
    \ > max2 && numbers[i] < ans)\n        {\n            ans = numbers[i];\n    \
    \    }\n        else if (numbers[i] < max1 && numbers[i] > ans)\n        {\n \
    \           ans = numbers[i];\n        }\n    }\n    return ans;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work if you have two numbers that are\
    \ equal ", "{\n  var lower = float.min(numbers);\n  var upper = float.max(numbers);\n\
    \  var closest_tuple = Tuple!(float, float);", "{\n\tlet length = numbers.length;\n\
    \tif (length < 2)\n\t\treturn Tuple!(float, float)((numbers[0], numbers[0]));\n\
    \tlet index = get_index(numbers);\n\tlet maxdiff = float.infinity();\n\tlet mindiff\
    \ = float.infinity();\n\tlet closest;\n\tlet closestindex;\n\tif (index > 0) {\n\
    \t\tlet diff = abs(numbers[index] - numbers[index - 1]);\n\t\tif (diff > maxdiff)\
    \ {\n\t\t\tmaxdiff = diff;\n\t\t\tclosest = numbers[index];\n\t\t\tclosestindex\
    \ = index - 1;\n\t\t}\n\t}\n\tif (index < length - 1) {\n\t\tlet diff = abs(numbers[index]\
    \ - numbers[index + 1]);\n\t\tif (diff < mindiff) {\n\t\t\tmindiff = diff;\n\t\
    \t\tclosest = numbers[index];\n\t\t\tclosestindex = index + 1;\n\t\t}\n\t}\n\t\
    return Tuple!(float, float)((closest, closestindex));\n}\n/*\n From a supplied\
    \ array of numbers (of length at least two) select and return two that are the\
    \ closest to each\n    other and return them in order (smaller number, larger\
    \ number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  \
    \  tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\
    \    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[size]\
    \ numbers) \n{\n\tlet length = numbers.length;\n\tif (length < 2)\n\t\treturn\
    \ Tuple!(float, float)((numbers[0], numbers[0]));\n\tlet index = get_index(numbers);\n\
    \tlet maxdiff = float.infinity();\n\tlet mindiff = float.infinity();\n\tlet closest;\n\
    \tlet closestindex;\n\tif (index > 0) {\n\t\tlet diff = abs(numbers[index] - numbers[index\
    \ - 1]);\n\t\tif (diff > maxdiff) {\n\t\t\tmaxdiff = diff;\n\t\t\tclosest = numbers[index];\n\
    \t\t\tclosestindex = index - 1;\n\t\t}\n\t}\n\tif (index < length - 1) {\n\t\t\
    let diff = abs(numbers[index] - numbers[index + 1]);\n\t\tif (diff < mindiff)\
    \ {\n\t\t\tmindiff = diff;\n\t\t\tclosest = numbers[index];\n\t\t\tclosestindex\
    \ = index + 1;\n\t\t}\n\t}\n\treturn Tuple!(float, float)((closest, closestindex));\n\
    }\n/*\n From a supplied array of numbers (of length at least two) select and return\
    \ two that are the closest to each\n    other and return them in order (smaller\
    \ number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    tuple(2.0, ", "{\n\tlet min: Float = numbers[0];\n\tlet\
    \ max: Float = numbers[0];\n\tfor n in numbers do\n\t{\n\t\tmin = math::min(min,\
    \ n);\n\t\tmax = math::max(max, n);\n\t}\n\t\n\treturn Tuple!(float, float) (min,max);\n\
    }\n\t\n\t\n// To test our functions:", "{\n\tif(numbers.length < 2)\n\t{\n\t\t\
    return Tuple!(float, float)((numbers[0], numbers[0]));\n\t}", "{\n    \n    let\
    \ mut min_diff = float::MAX;\n    let mut min_diff = float::MAX;\n    let mut\
    \ min_diff2 = float::MAX;\n    let mut min_diff2 = float::MAX;\n    \n    for\
    \ i in 0..numbers.len()-1 {\n        let current_diff = numbers[i] - numbers[i+1];\n\
    \        if current_diff < min_diff {\n            min_diff = current_diff;\n\
    \            min_diff2 = numbers[i];\n        }\n        if current_diff < min_diff2\
    \ {\n            min_diff2 = current_diff;\n        }\n    }\n    \n    if min_diff\
    \ == float::MAX {\n        return Tuple!(min_diff2, min_diff2);\n    } else {\n\
    \        return Tuple!(min_diff2, min_diff);\n    }\n}", "{\n\tif (numbers.length\
    \ < 2)\n\t{\n\t\tthrow new ArgumentError(\"Not enough numbers in input\");\n\t\
    }\n\tfloat smallest = numbers[0];\n\tfloat largest = numbers[0];\n\tfloat midpoint;\n\
    \tfor(int i = 1; i < numbers.length; i++)\n\t{\n\t\tfloat temp = largest;\n\t\t\
    largest = smallest;\n\t\tsmallest = temp;\n\t\tmidpoint = smallest + (largest\
    \ - smallest) / 2.0;\n\t\tif (numbers[i] < midpoint)\n\t\t{\n\t\t\tsmallest =\
    \ midpoint;\n\t\t}\n\t\telse if (numbers[i] > midpoint)\n\t\t{\n\t\t\tlargest\
    \ = midpoint;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn Tuple!(smallest,\
    \ largest);\n}", "{\n    if (numbers.len == 0)\n    {\n        return Tuple!(float,\
    \ float)(std::numeric_limits<float>::min(), std::numeric_limits<float>::max());\n\
    \    }\n    \n    float maxValue = 0;\n    float minValue = numbers[0];\n    \n\
    \    for(float num : numbers)\n    {\n        if (num > maxValue)\n        {\n\
    \            maxValue = num;\n        }\n        \n        if (num < minValue)\n\
    \        {\n            minValue = num;\n        }\n    }\n    \n    return Tuple!(float,\
    \ float)(minValue, maxValue);\n}", "{\n    var t0 = numbers[0];\n    var t1 =\
    \ numbers[1];\n    \n    var d = t0 - t1;\n    var s = t0 + t1;\n    \n    var\
    \ min = d*d;\n    var max = s*s;\n    \n    for(var i = 2; i < numbers.length;\
    \ i += 2)\n    {\n        var n1 = numbers[i];\n        var n2 = numbers[i + 1];\n\
    \        var d = n1 - n2;\n        var s = n1 + n2;\n        \n        if( d <\
    \ min )\n        {\n            min = d;\n        }\n        if( s > max )\n \
    \       {\n            max = s;\n        }\n    }\n    \n    for(var i = numbers.length\
    \ - 1; i > 0; i -= 2)\n    {\n        var n1 = numbers[i];\n        var n2 = numbers[i\
    \ - 1];\n        var d = n1 - n2;\n        var s = n1 + n2;\n        \n      \
    \  if( d < min )\n        {\n            min = d;\n        }\n        if( s >\
    \ max )\n        {\n            max = s;\n        }\n    }\n    \n    var result\
    \ = Tuple(min, max);\n    \n    return result;\n}", "{\n    var a = numbers[0];\n\
    \    var b = numbers[1];\n    var i;\n    for(i = 0; i <= numbers.length -1; i++)\n\
    \    {\n        if(((Math.abs(numbers[i]) - a) < 0.0f) && (Math.abs(numbers[i])\
    \ - b < 0.0f))\n        {\n            a = numbers[i];\n        }\n        else\
    \ if((Math.abs(numbers[i] - a) < 0.0f) && (Math.abs(numbers[i] - b) < 0.0f))\n\
    \        {\n            b = numbers[i];\n        }\n    }\n    return Tuple!(a,\
    \ b);\n}\n/*\n From a supplied array of numbers (of length at least two) select\
    \ and return two that are the closest to each\n    other and return them in order\
    \ (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[]\
    \ numbers, float tolerance) \n{\n    var a = numbers[0];\n    var b = numbers[1];\n\
    \    var i;\n    for(i = 0; i <= numbers.length -1; i++)\n    {\n        if(((Math.abs(numbers[i])\
    \ - a) < tolerance) && (Math.abs(numbers[i]) - b < tolerance))\n        {\n  \
    \          a = numbers[i];\n        }\n        else if((Math.abs(numbers[i] -\
    \ a) < tolerance) && (Math.abs(numbers[i] - b) < tolerance))\n        {\n    \
    \        b = numbers[i];\n        }\n    }\n    return Tuple!(a, b);\n}\n/*\n\
    \ From a supplied array of numbers (of length at least two) select and return\
    \ two that are the closest to each\n    other and return them in order (smaller\
    \ number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.2])\n    tuple(2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n    tuple(2.0, 2.0)\n    \n*/\nTuple!(float, float) find_closest_elements(float[]\
    \ numbers, float tolerance, float max_difference) \n{\n    var a = numbers[0];\n\
    \    var b = numbers[1];\n    var i;\n    for(i = 0; i <= numbers.length -1; i++)\n\
    \    {\n        if(((Math.abs(numbers[i]) - a) < tolerance) && (Math.abs(numbers[i])\
    \ - b < tolerance))\n        {\n            a = numbers[i];\n        }\n     \
    \   else if((Math.abs(numbers[i] - a) < tolerance) && (Math.abs(numbers[i] - b)\
    \ < tolerance))\n        {\n            b = numbers[i];\n        }\n    }\n  \
    \  return Tuple!(a, b);\n}\n/*\n From a supplied array of numbers (of length at\
    \ least two) select and return two that are the closest to each\n    other and\
    \ return them in order ("]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
