name: HumanEval_97_multiply
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nComplete the function that takes\
  \ two integers and returns \n    the product of their unit digits.\n    Assume the\
  \ input is always valid.\n    Examples:\n    >>> multiply(148L, 412L)\n    16L\n\
  \    >>> multiply(19L, 28L)\n    72L\n    >>> multiply(2020L, 1851L)\n    0L\n \
  \   >>> multiply(14L, -15L)\n    20L\n    \n*/\nlong multiply(long a, long b) \n"
tests: "unittest\n{\n    alias candidate = multiply;\n\n    assert(candidate(148L,\
  \ 412L) == 16L);\n    assert(candidate(19L, 28L) == 72L);\n    assert(candidate(2020L,\
  \ 1851L) == 0L);\n    assert(candidate(14L, -15L) == 20L);\n    assert(candidate(76L,\
  \ 67L) == 42L);\n    assert(candidate(17L, 27L) == 49L);\n    assert(candidate(0L,\
  \ 1L) == 0L);\n    assert(candidate(0L, 0L) == 0L);\n}\nvoid main(){}"
completions: ["{\n  if (b == 0) \n    return 0;\n  \n  long long n = std.math.remainder(a,\
    \ b);\n  long long p = (long long)std.math.remainder(a, b);\n  long long q = ((long\
    \ long)std.math.remainder(n, b)) * 10;\n  long long r = (long long)std.math.remainder(q,\
    \ 10);\n  long long s = std.math.remainder(q, 10);", "{\n    long product = 0,\
    \ digit;\n    while (b != 0) {\n        digit = a % 10;\n        a = a / 10;\n\
    \        product = product * 10 + digit;\n        b = b / 10;\n    }\n    return\
    \ product;\n}", "{\n    int x = a;\n    int y = b;\n    int z = 0;\n    while\
    \ (x>0){\n        z = x%10;\n        y = y*10 + z;\n        x = x/10;\n    }\n\
    \    x = b;\n    y = a;\n    while (y>0){\n        z = y%10;\n        x = x*10\
    \ + z;\n        y = y/10;\n    }\n    return x;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThank you for your answer! But it didn't work on python 2.7.6 because\
    \ of the \"l\" at the end. I am working on Windows 10, so I guess my problem is\
    \ with my computer. I will try it in Linux.\n<|/ c |>\n<| a |>\nYou can use the\
    \ following code to get your result without multiplication:\n<code>\ndef multiply(a,\
    \ b):\n    while a:\n        b, a = divmod(a, 10)\n    while b:\n        a, b\
    \ = divmod(b, 10)\n    return a\n</code>\n<|/ a dscore=1 tags=math,python,python-2.7\
    \ |>\n<| a tags=math,python,python-2.7 dscore=1 |>\nI came up with another approach\
    \ for this question,\n<code>\nfrom math import floor", "{\n    long carry = 0,\
    \ sum = 0;\n    \n    while (a != 0 && b != 0)\n    {\n        long digitA = (a%10);\n\
    \        long digitB = (b%10);\n        \n        carry = digitA * digitB + carry;\n\
    \        sum = digitA + digitB + sum;\n        \n        a/=10;\n        b/=10;\n\
    \    }\n    \n    return carry + sum;\n}", "{\n    long prod;\n    prod = a;\n\
    \    while (b > 0)\n    {\n        prod = prod * 10 + (b%10);\n        b /= 10;\n\
    \    }\n    return prod;\n}", "{\n    long product = 0;\n    int digit1, digit2;\n\
    \    \n    if (a < 10) {\n        if (b < 10) {\n            product = std.math.rem(a,\
    \ b);\n        } else {\n            digit1 = a % 10;\n            digit2 = (b\
    \ - (std.math.rem(10, a) * digit1)) / 10;\n            product = std.math.rem(digit1,\
    \ digit2) * 10 + digit2;\n        }\n    } else {\n        if (b < 10) {\n   \
    \         digit1 = (a / 10) % 10;\n            digit2 = (b - (std.math.rem(10,\
    \ a / 10) * digit1)) / 10;\n            product = digit1 * 10 + digit2;\n    \
    \    } else {\n            digit1 = (a / 10) % 10;\n            digit2 = (b -\
    \ (std.math.rem(10, a / 10) * digit1)) / 10;\n            product = digit1 * 10\
    \ + digit2;\n        }\n    }\n    \n    return product;\n}\n</code>\nThe only\
    \ issue with this is that if the input is invalid, it'll return a negative number.\n\
    <|/ a |>\n<| c |>\nVery nice, thank you! Any thoughts on how to do it without\
    \ using strings?\n<|/ c |>\n<| c |>\nYou could also use `std::to_string`, but\
    \ that uses strings. You could use [`std::istringstream`](http://en.cppreference.com/w/cpp/io/basic_istringstream)\
    \ instead.\n<|/ c |>\n<| c |>\n, `std::to_string` would indeed be better since\
    \ it doesn't require strings anymore.\n<|/ c |>\n<| a dscore=1 |>\nI have modified\
    \ the code by Robert Kamel. Works fine\n<code>\n#include <iostream>\n#include\
    \ <math.h>\n#include <string.h>", "{\n\tint unit;\n\tlong sum, carry=0;\n\tfor(unit=0;\
    \ unit<=9; unit++)\n\t{\n\t\tsum=((long) (a%(unit*10)*10+b%unit*10))+carry;\n\t\
    \tcarry=(sum>9);\n\t\ta=(unit*10+sum-carry)/10;\n\t\tb=(unit+sum-carry)%10;\n\t\
    }\n\treturn a+(long)(b*10+carry);\n}", "{\n    long unit = (a / 10) % 10;\n  \
    \  long rest = a%10;\n    return (a*b) / unit + (a*b%unit)*unit;\n}", "{\n\tlong\
    \ mul = std.math.mul(a, b);\n\treturn mul%10L;\n}", "{\n    if (a == 0 || b ==\
    \ 0)\n        return 0;\n    long res = 0;\n    long product = a*b;\n    while\
    \ (product > 0)\n    {\n        res += (product%10);\n        product /= 10;\n\
    \    }\n    return res;\n}", "{\n\tlong prod = 0;\n\tfor (long i=a;i>0;i--) {\n\
    \t\tprod *= 10;\n\t\tprod += i % 10;\n\t}\n\tfor (long i=b;i>0;i--) {\n\t\tprod\
    \ *= 10;\n\t\tprod += i % 10;\n\t}\n\treturn prod;\n}\n/*\nComplete the function\
    \ that takes a string containing two \n    integers and returns the sum of the\
    \ product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n\
    \    >>> add(\"148\", \"412\")\n    16L\n    >>> add(\"19\", \"28\")\n    72L\n\
    \    >>> add(\"2020\", \"1851\")\n    0L\n    >>> add(\"14\", \"-15\")\n    20L\n\
    \    \n*/\nlong add(string a, string b) \n{\n\tstring sum = \"0\";\n\tlong sum1\
    \ = 0;\n\tfor (long i=a.length();i>0;i--) {\n\t\tsum1 += multiply(a.charAt(i)\
    \ - '0', b.charAt(i) - '0');\n\t}\n\tfor (long i=b.length();i>0;i--) {\n\t\tsum\
    \ += b.charAt(i) - '0';\n\t}\n\treturn sum1 * sum;\n}", "{\n\t// TODO: Your code\
    \ here\n\tlong result = 0;\n\twhile (b != 0) {\n\t\tresult = result + (b % 10);\n\
    \t\tb = b >> 5;\n\t}\n\treturn result;\n}", "{\n\tlong product = 1L;\n\tfor(int\
    \ i = 0; i < DIGITS - 1; i++)\n\t{\n\t\tproduct = multiply(product, std.math.remainder(a,\
    \ b));\n\t\ta = std.math.remainder(a, b);\n\t}\n\treturn product;\n}\n/*\nComplete\
    \ the function that takes two integers and returns \n    the product of their\
    \ unit digits, modulo the product of their \n    unit digits.\n    Assume the\
    \ input is always valid.\n    Examples:\n    >>> multiply(148L, 412L)\n    16L\n\
    \    >>> multiply(19L, 28L)\n    72L\n    >>> multiply(2020L, 1851L)\n    15L\n\
    \    >>> multiply(14L, -15L)\n    20L\n    \n*/\nlong multiply(long a, long b)\
    \ \n{\n\tlong product = 1L;\n\tfor(int i = 0; i < DIGITS - 1; i++)\n\t{\n\t\t\
    product = multiply(product, std.math.remainder(a, b));\n\t\ta = std.math.remainder(a,\
    \ b);\n\t}\n\treturn product;\n}\n/*\nComplete the function that takes two integers\
    \ and returns \n    the product of their unit digits, modulo the product of their\
    \ \n    unit digits.\n    Assume the input is always valid.\n    Examples:\n \
    \   >>> multiply(148L, 412L)\n    16L\n    >>> multiply(19L, 28L)\n    72L\n \
    \   >>> multiply(2020L, 1851L)\n    15L\n    >>> multiply(14L, -15L)\n    20L\n\
    \    \n*/\nlong multiply(long a, long b) \n{\n\tlong product = 1L;\n\tfor(int\
    \ i = 0; i < DIGITS - 1; i++)\n\t{\n\t\tproduct = multiply(product, std.math.remainder(a,\
    \ b));\n\t\ta = std.math.remainder(a, b);\n\t}\n\treturn product;\n}\n/*\nComplete\
    \ the function that takes two integers and returns \n    the product of their\
    \ unit digits, modulo the product of their \n    unit digits.\n    Assume the\
    \ input is always valid.\n    Examples:\n    >>> multiply(148L, 412L)\n    16L\n\
    \    >>> multiply(19L, 28L)\n    72L\n    >>> multiply(2020L, 1851L)\n    15L\n\
    \    >>> multiply(14L, -15L)\n    20L\n    \n*/\nlong multiply(long a, long b)\
    \ \n{\n\tlong product = 1L;\n\tfor(int i = 0; i < DIGITS - 1; i++)\n\t{\n\t\t\
    product = multiply(product, std.math.remainder(a, b));\n\t\ta = std.math.remainder(a,\
    \ b);\n\t}\n\treturn product;\n}\n/*\nComplete the function that takes two integer",
  "{\n    long unitDigits = a % 10;\n    long product = a / 10;\n    \n    product\
    \ *= b;\n    product %= 10;\n    \n    product += unitDigits;\n    product %=\
    \ 10;\n    \n    return product;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nTo find\
    \ prime factors of a number N you can use following method:\n<code>\nimport java.io.*;\n\
    class Prime{\npublic static void main(String[] args) throws IOException{\n   \
    \ int n=12;\n    int i=0;\n    System.out.println(n);\n    if(n==2){\n       \
    \ i=1;\n    }\n    else if(n<2){\n        i=0;\n    }\n    else{\n        do{\n\
    \            i=0;\n            while(n%2==0){\n            System.out.print(\"\
    2\");\n            n=n/2;\n            i++;\n            }\n            System.out.println(i);\n\
    \            i=0;\n            while(n%4==0){\n            System.out.print(\"\
    4\");\n            n=n/4;\n            i++;\n            }\n            System.out.println(i);\n\
    \            i=0;\n            while(n%8==0){\n            System.out.print(\"\
    8\");\n            n=n/8;\n            i++;\n            }\n            System.out.println(i);\n\
    \            i=0;\n            while(n%16==0){\n            System.out.print(\"\
    16\");\n            n=n/16;\n            i++;\n            }\n            System.out.println(i);\n\
    \            i=0;\n            while(n%32==0){\n            System.out.print(\"\
    32\");\n            n=n/32;\n            i++;\n            }\n            System.out.println(i);\n\
    \            i=0;\n            while(n%64==0){\n            System.out.print(\"\
    64\");\n            n=n/64;\n            i++;\n            }\n            System.out.println(i);\n\
    \        }while(i<=12);\n    }\n}\n}\n</code>\n<|/ a tags=algorithm,java dscore=2\
    \ |>\n<| a tags=algorithm,java |>\nYou could use the Sieve of Eratosthenes algorithm.\
    \ It is not difficult to implement, but it is rather inefficient in practice.\n\
    <|/ a dscore=2 |>\n<| a |>\nA faster way of doing it is by using Bitwise XOR.\n\
    For example, if you have number 7\n<code>\n0 110 111\n</code>\nAnd if you XOR\
    \ it with a number with only 1 bit in it\n<code>\n001 100\n</code>\nThe result\
    \ will be \n<code>\n111 111\n</code>\nSo if you XOR it with every number with\
    \ only 1 bit in it, you will get the prime factors of ", "{\n\tlong mul = 0, i;\n\
    \t\n\tfor (i = 1; i <= abs(b); ++i)\n\t{\n\t\tif (b >= 0)\n\t\t{\n\t\t\tmul =\
    \ mul * 10 + (a % 10);\n\t\t\ta = a / 10;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmul =\
    \ mul * 10 + (a % 10) * -1;\n\t\t\ta = a / 10;\n\t\t}\n\t}\n\t\n\treturn mul;\n\
    }", "{\n\tlong c = 0;\n\t\n\tif (a > 0 && a%10 == 0) {\n\t\tc = c + a%10;\n\t\t\
    a = a%10;\n\t}\n\t\n\tif (b > 0 && b%10 == 0) {\n\t\tc = c + b%10;\n\t\tb = b%10;\n\
    \t}\n\t\n\tlong temp = a*b;\n\t\n\tif (temp%10 == 0) {\n\t\tc = c + temp%10;\n\
    \t\ttemp = (temp%10)*10 + temp/10;\n\t}\n\t\n\treturn c;\n}", "{\n    long c =\
    \ 1;\n    long digit1;\n    long digit2;\n    \n    while (a != 0) {\n       \
    \ digit1 = a%10;\n        digit2 = b/10;\n        c += digit2*digit1;\n      \
    \  b = b/10;\n        a = a/10;\n    }\n    \n    return c;\n}\n</code>\n<|/ a\
    \ |>\n<| a |>\nOne way to solve this problem is to first convert both numbers\
    \ to strings, then convert the resulting strings to lists of digits. Then you\
    \ can simply concatenate those lists and convert the result back to an integer.\
    \ Here is an implementation:\n<code>\nimport java.util.List;\nimport java.util.Arrays;\n\
    import java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;",
  "{\n    long result = 1;\n    long temp = 1;\n    \n    for (int i = 0; i < 32;\
    \ i++) {\n        if ((a & (1 << i)) != 0) {\n            result *= temp;\n  \
    \      }\n        if ((b & (1 << i)) != 0) {\n            result *= temp;\n  \
    \      }\n        temp *= 10;\n    }\n    return result;\n}", "{\n    long c =\
    \ 0;\n    if (a < 0 || b < 0) {\n        throw new IllegalArgumentException();\n\
    \    }\n    while (a > 0 || b > 0) {\n        long a = a % 10;\n        long b\
    \ = b % 10;\n        c = c + std.math.pow(b, a);\n        a = a / 10;\n      \
    \  b = b / 10;\n    }\n    return c;\n}", "{\n\tlong unitDigits[] = new long[20];\n\
    \tunitDigits[0] = a % 10;\n\ta /= 10;\n\tunitDigits[1] = a % 10;\n\ta /= 10;\n\
    \tunitDigits[2] = a % 10;\n\ta /= 10;\n\tunitDigits[3] = a % 10;\n\ta /= 10;\n\
    \tunitDigits[4] = a % 10;\n\ta /= 10;\n\tunitDigits[5] = a % 10;\n\ta /= 10;\n\
    \tunitDigits[6] = a % 10;\n\ta /= 10;\n\tunitDigits[7] = a % 10;\n\ta /= 10;\n\
    \tunitDigits[8] = a % 10;\n\ta /= 10;\n\tunitDigits[9] = a % 10;\n\ta /= 10;\n\
    \tunitDigits[10] = a % 10;\n\ta /= 10;\n\tunitDigits[11] = a % 10;\n\ta /= 10;\n\
    \tunitDigits[12] = a % 10;\n\ta /= 10;\n\tunitDigits[13] = a % 10;\n\ta /= 10;\n\
    \tunitDigits[14] = a % 10;\n\ta /= 10;\n\tunitDigits[15] = a % 10;\n\ta /= 10;\n\
    \tunitDigits[16] = a % 10;\n\ta /= 10;\n\tunitDigits[17] = a % 10;\n\ta /= 10;\n\
    \tunitDigits[18] = a % 10;\n\ta /= 10;\n\tunitDigits[19] = a % 10;\n\ta /= 10;\n\
    \tunitDigits[20] = a % 10;\n\tunitDigits[21] = b / 10;\n\tb %= 10;\n\tunitDigits[22]\
    \ = b / 10;\n\tb %= 10;\n\tunitDigits[23] = b / 10;\n\tb %= 10;\n\tunitDigits[24]\
    \ = b / 10;\n\tb %= 10;\n\tunitDigits[25] = b / 10;\n\tb %= 10;\n\tunitDigits[26]\
    \ = b / 10;\n\tb %= 10;\n\tunitDigits[27] = b / 10;\n\tb %= 10;\n\tunitDigits[28]\
    \ = b / 10;\n\tb %= 10;\n\tunitDigits[29] = b / 10;\n\tb %= 10;\n\tunitDigits[30]\
    \ = b / 10;\n\tb %= 10;\n\tunitDigits[31] = b / 10;\n\tb %= 10;\n\tunitDigits[32]\
    \ = b / 10;\n\tb %= 10;\n\tunitDigits[33] = b / 10;\n\tb %= 10;", "{\n    int\
    \ n = 1;\n    while (b != 0)\n    {\n        if (b & 1)\n        {\n         \
    \   n = n * a;\n        }\n        a = a * 10;\n        b = b >> 1;\n    }\n \
    \   return n;\n}", "{\n    long mulResult = 0;\n    long firstDigit = a%10;\n\
    \    long secondDigit = b%10;\n    long thirdDigit = a/10;\n    long fourthDigit\
    \ = b/10;\n    long fifthDigit = fourthDigit;\n    long sixthDigit = (firstDigit\
    \ * fourthDigit)%10;\n    long seventhDigit = (secondDigit * fourthDigit)%10;\n\
    \    long eightDigit = (thirdDigit * fourthDigit)%10;\n    long ninethDigit =\
    \ (fourthDigit * fourthDigit)%10;\n    if (firstDigit == 0) firstDigit = 1;\n\
    \    if (secondDigit == 0) secondDigit = 1;\n    if (thirdDigit == 0) thirdDigit\
    \ = 1;\n    if (fourthDigit == 0) fourthDigit = 1;\n    if (fifthDigit == 0) fifthDigit\
    \ = 1;\n    if (sixthDigit == 0) sixthDigit = 1;\n    if (seventhDigit == 0) seventhDigit\
    \ = 1;\n    if (eightDigit == 0) eightDigit = 1;\n    if (ninethDigit == 0) ninethDigit\
    \ = 1;\n    //System.out.println(firstDigit + \" \" + secondDigit + \" \" + thirdDigit\
    \ + \" \" + fourthDigit + \" \" + fifthDigit + \" \" + sixthDigit + \" \" + seventhDigit\
    \ + \" \" + eightDigit + \" \" + ninethDigit);\n    \n    mulResult = mulResult\
    \ + firstDigit*eightDigit;\n    mulResult = mulResult + secondDigit*eightDigit;\n\
    \    mulResult = mulResult + thirdDigit*eightDigit;\n    mulResult = mulResult\
    \ + fourthDigit*eightDigit;\n    mulResult = mulResult + fifthDigit*eightDigit;\n\
    \    mulResult = mulResult + sixthDigit*eightDigit;\n    mulResult = mulResult\
    \ + seventhDigit*eightDigit;\n    mulResult = mulResult + ninethDigit*eightDigit;\n\
    \    mulResult = mulResult + firstDigit*seventhDigit;\n    mulResult = mulResult\
    \ + secondDigit*seventhDigit;\n    mulResult = mulResult + thirdDigit*seventhDigit;\n\
    \    mulResult = mulResult + fourthDigit*seventhDigit;\n    mulResult = mulResult\
    \ + fifthDigit*seventhDigit;\n    mulResult = mulResult + sixthDigit*", "{\n \
    \   if (a == 0) {\n        return 0;\n    }\n    if (b == 0){\n        return\
    \ a;\n    }\n    long product = a / b;\n    int remainder = a % b;\n    return\
    \ remainder == 0 ? product : product * multiply(remainder, b);\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nHi thanks for your answer. Unfortunately i can't use\
    \ recursion and my professor wants us to implement the algorithm with the loops.\n\
    <|/ c |>\n<| c |>\nOh I see. I posted another version that uses loops though.\
    \ Honestly, I'm a bit surprised that recursion isn't allowed.\n<|/ c |>\n<| c\
    \ |>\nI think recursion is allowed in my professor, it's just not what he wants\
    \ us to do.\n<|/ c |>\n<| c |>\nOh I see. Well, if your professor doesn't like\
    \ recursive functions, you might have to go with a loop version of it. But remember,\
    \ it might not be as efficient as your professor's recursive solution.\n<|/ c\
    \ |>\n<| c |>\nYeah, I agree, thats why I didn't post it as an answer, just commented\
    \ on his question and asked him to clarify whether he wants loops or recursion.\n\
    <|/ c |>\n<| a |>\nIf you can use recursion:\n<code>\nlong multiply(long a, long\
    \ b){\n    if(a < 10){\n        return a;\n    }\n    return multiply(a/10, b)\
    \ + 10*(a%b);\n}\n</code>\n<|/ a dscore=0 tags=recursion,java |>\n<| c |>\nI thought\
    \ about a recursive solution, but i cant use recursion. I'm sorry if I didn't\
    \ make that clear on my  question\n<|/ c |>\n<| c |>\nIf you can't use recursion,\
    \ please specify what language you are using. I am guessing C, but please specify\
    \ this in your question.\n<|/ c |>\n<| c |>\nI'm using Java, but I think it's\
    \ irrelevant, because it's a basic question about recursion\n<|/ c |>\n<| c |>\n\
    I see, well, in that case please specify in your question because we can't answer\
    \ it without knowing the language.\n<|/ c |>\n<| c |>\nI've added the tag\n<|/\
    \ c |>\n<| a tags=recursion,java dscore=0 |>\n<code>\n/**\n * multiply two number\
    \ \n * \n * a the first number\n * b the second number\n * \n", "{\n    if (b==0)\n\
    \        return 0;\n    int c = digits(b);\n    long product = 0;\n    for (int\
    \ i = 0; i <= c; i++)\n    {\n        product += a % 10 * (b / pow(10, i) % 10);\n\
    \        a /= 10;\n    }\n    return product;\n}", "{\n    // TODO: implement\
    \ me\n}\n</cell>\n<cell>\n//export", "{\n\tlong aunit = a%10;\n\tlong bunit =\
    \ b%10;\n\tlong sum = aunit * 10 + bunit;\n\treturn sum;\n}", "{\n\tlong unitDigits\
    \ = a % 10;\n\ta = a / 10;\n\tlong unitDigits2 = b % 10;\n\tb = b / 10;\n\tlong\
    \ result = unitDigits * unitDigits;\n\tif (result != 0) \n\t{\n\t\tresult *= unitDigits2\
    \ * unitDigits;\n\t\tif (result != 0) \n\t\t\tresult *= unitDigits2 * unitDigits;\n\
    \t\tif (result != 0) \n\t\t\tresult *= unitDigits2 * unitDigits;\n\t\tif (result\
    \ != 0) \n\t\t\tresult *= unitDigits2 * unitDigits;\n\t}\n\telse\n\t{\n\t\tresult\
    \ = unitDigits * unitDigits2 * unitDigits2 * unitDigits;\n\t}\n\treturn result;\n\
    }\n/*\nComplete the function that takes two strings containing \n    the numbers\
    \ and returns the sum of the squares of their digits.\n    If the strings aren't\
    \ valid, the function should return 0L\n    Examples:\n    >>> sumOfDigits(\"\
    1412\", \"412\")\n    26L\n    >>> sumOfDigits(\"1928\", \"1851\")\n    12L\n\
    \    >>> sumOfDigits(\"2020\", \"1851\")\n    0L\n    >>> sumOfDigits(\"12\",\
    \ \"-1\")\n    0L\n*/\nlong sumOfDigits(string a, string b) \n{\n\tlong unitDigits1,\
    \ unitDigits2 = 0;\n\tif (a.length() > 0 && b.length() > 0)\n\t{\n\t\tunitDigits1\
    \ = std.atoi(a);\n\t\tunitDigits2 = std.atoi(b);\n\t}\n\telse\n\t{\n\t\tunitDigits1\
    \ = 0;\n\t\tunitDigits2 = 0;\n\t}\n\tlong result = unitDigits1 + unitDigits2;\n\
    \tresult *= unitDigits1 * unitDigits1;\n\tresult *= unitDigits2 * unitDigits2;\n\
    \treturn result;\n}\n/*\nComplete the function that takes two strings containing\
    \ \n    the numbers and returns the sum of the squares of their digits \n    when\
    \ the numbers are in the range [1, 999999]. The function should \n    return the\
    \ sum of the squares of their digits when the numbers are \n    in the range [1,\
    \ 999999]. If the strings aren't valid, the function should \n    return 0L\n\
    \    Examples:\n    >>> sumOfDigitsInRange(\"1412\", \"412\")\n    26L\n    >>>\
    \ sumOfDigitsInRange(\"1928\", \"1851\")\n    12L\n    >>> sumOfDigitsInRange(\"\
    2020\", \"1851\")\n    0L\n    >>> sumOfDigitsInRange(\"12\", \"-1\")\n    0L\n\
    */\nlong sumOfDigitsInRange(string a, string b) \n{\n\tint unitDigits1, unitDigits2,\
    \ unitDig", "{\n    /* code goes here */\n    long d = a%10;\n    long c = b%10;\n\
    \    long x = a*b%10;\n    long d = (d*2)%10;\n    long c = c*2%10;\n    long\
    \ x = (x*3)%10;\n    return x*(d*3%10);\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,java\
    \ |>\n<code>\npublic static void main(String[] args) {\n        int x=7292;\n\
    \        int y=9144;\n        int m=0;\n        int n=0;\n        while(x>0)\n\
    \        {\n            m=(m*10)+(x%10);\n            x=x/10;\n        }\n   \
    \     while(y>0)\n        {\n            n=(n*10)+(y/10);\n            y=y/10;\n\
    \        }\n        System.out.println(\"Multiply Result \"+(m*n));\n    }\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nCode only answers are discouraged. Please add some\
    \ explanation as to how your code solves the problem, or how this solves the problem.\n\
    <|/ c |>\n<| c |>\nIt's a mathematical question, it doesn't matter how you calculate\
    \ it, as long as you find the same number\n<|/ c |>\n<| c |>\nThis doesn't do\
    \ what the OP is asking for. It is a multiplication algorithm.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nAs you said that the input will always be valid, this is an easy\
    \ approach to solve this problem. The solution is as follows", "{\n    long sum\
    \ = 0;\n    long carry = 0, t;\n    for (int i = 0; i < 2; ++i) {\n        int\
    \ digit = (int) (a % 10);\n        a = a / 10;\n        if (a < 0) a += 10;\n\
    \        if (b > 0) {\n            t = (int) (b % 10);\n            b = b / 10;\n\
    \            if (b < 0) b += 10;\n        }\n        else {\n            t = 10\
    \ + b;\n            b = 0;\n        }\n        if (carry > 0) {\n            sum\
    \ += digit;\n            carry += (digit * t) + carry;\n        }\n        else\
    \ {\n            sum += digit;\n            carry = t;\n        }\n    }\n   \
    \ if (b > 0) {\n        sum += (int) (b % 10);\n    }\n    return sum + carry;\n\
    }", "{\n    return (int) pow((double) a, (double) b);\n}\n</code>\n<|/ a |>\n\
    <| c |>\nI understand that, but my question is how does that solve the problem\
    \ with negative numbers?\n<|/ c |>\n<| c |>\nIt will work as long as `a` and `b`\
    \ are positive numbers. You can add this line `a = a < 0? -a : a;` before the\
    \ first `return` line, but I would not recommend this kind of solution.\n<|/ c\
    \ |>\n<| a dscore=3 |>\nThe problem is with your int type. From the spec:", "{\n\
    \tlong c = 0;\n\t\n\twhile (b != 0) \n\t{\n\t\tc = a%10;\n\t\ta = c/10;\n\t\t\n\
    \t\tif (a == 1) \n\t\t{\n\t\t\tc = a * b;\n\t\t}\n\t\t\n\t\tb = b / 10;\n\t}\n\
    \t\n\treturn c;\n}", "{\n  int max = (int)Math.ceil(Math.log10(a));\n  int min\
    \ = (int)Math.ceil(Math.log10(b));", "{\n\tint i = (int)a;\n\tint j = (int)b;\n\
    \tlong c = 1L;\n\twhile(i >= 0){\n\t\tint k = (int)(a % 10);\n\t\tc += std.pow(10,\
    \ k)*std.pow(10, j);\n\t\ta = a/10;\n\t\tj = j/10;\n\t}\n\treturn c;\n}", "{\n\
    \tint carry = 0;\n\tlong product = 0;\n\tfor(int i = 0; i < digits; i++)\n\t{\n\
    \t\tif(b > 9)\n\t\t{\n\t\t\tproduct = product + b - 10;\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t\tproduct = product + b;\n\t\t}\n\t\tb = b % 10;\n\t\tcarry = product *\
    \ 10 + carry;\n\t\tproduct = product % 10;\n\t}\n\t\n\treturn carry + product;\n\
    }", "{\n  long sum = 0;\n  long carry = 1;\n  long temp;\n  \n  while(b != 0)\n\
    \  {\n    temp = b % 10;\n    sum = sum + (temp * a * carry + temp);\n    carry\
    \ = carry * 10;\n    b = b / 10;\n  }\n  \n  return sum + carry;\n}", "{\n   \
    \ \n    if (a == 0)\n        return 0;\n    \n    if (b == 0)\n        return\
    \ a;\n    \n    long x = pow10(floor(log10(b)), 0);\n    long y = pow10(floor(log10(a)),\
    \ x);\n    long r = y;\n    \n    while (x != 0) {\n        long m = floor(x/y);\n\
    \        y = y;\n        r = r * 10 + m;\n        x = x - m * y;\n    }\n    return\
    \ r;\n}\n</cell>\n<cell>\ndef multiply(a, b):\n    \"\"\"\n    Multiply two integers\
    \ and return the product of their unit digits.", "{\n    // write your code in\
    \ Java here\n    return a;\n}", "{\n    long result = 0;\n    while (b != 0)\n\
    \    {\n        if ((b & 1) == 1) \n            result += a;\n        a = a *\
    \ 10;\n        b = b >> 1;\n    }\n    return result;\n}", "{\n    int i = 0,\
    \ j = 0;\n    long result = 1;\n    while(a != 0)\n    {\n        i++;\n     \
    \   result *= a % 10;\n        a /= 10;\n    }\n    while(j != 0)\n    {\n   \
    \     j--;\n        result *= b % 10;\n        b /= 10;\n    }\n    return result;\n\
    }\n/*\nComplete the function that returns true if the \n    numbers are in the\
    \ valid range, and false otherwise.\n    Examples:\n    >>> validRange(148L, 412L)\n\
    \    True\n    >>> validRange(19L, 28L)\n    False\n    >>> validRange(2020L,\
    \ 1851L)\n    False\n    \n*/", "{\n    if( b < 0 ) return 0L;\n    if( a < 0\
    \ || b < 0 ) return 0L;\n    if( a < b ) return 0L;\n    int ret = 0;\n    for(int\
    \ i = intDigits(a) - 1; i>=0; i--){\n        if( a % 10L != b % 10L ){\n     \
    \       return 0L;\n        }\n        ret += intDigit(a/10L)*intDigit(b/10L);\n\
    \        a/=10L;\n        b/=10L;\n    }\n    return ret;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=algorithm |>\nAs others have said, you cannot do this by brute\
    \ force for numbers as small as 14. You cannot do that by comparing the digits\
    \ of 14 as your number is only 19 digits long. That is what your recursive implementation\
    \ will do to 14. \nThat is why you need a solution that involves dividing by 10\
    \ 10 times. So you basically are dividing by 10 10 times. And if you don't want\
    \ your solution using division then you can do the same thing with multiplication.\
    \ That is what your recursive implementation will do to 14. \nIt is also worth\
    \ noting that if the input is a multiple of 10, then you just need to return the\
    \ number itself. So a solution that does not use division will always work. Just\
    \ divide the number by 10 10 times and return the quotient and the remainder.\
    \ \nThe idea here is that you can do multiplication by raising your number to\
    \ the power of 10. You only need to do division by 10 10 times if you are going\
    \ to do multiplication.\n<|/ a dscore=2 |>\n<| a tags=algorithm |>\nYou could\
    \ use the following algorithm:\n<code>", "{\n    if(a<0) return multiply(-a, b);\n\
    \    if(b<0) return multiply(a, -b);\n    if(a==0 && b==0) return 0;\n    if(a==0)\
    \ return 0;\n    if(b==0) return 0;\n    if(a>9) return multiply(a/10, b%10);\n\
    \    if(b>9) return multiply(a%10, b/10);\n    return a * b % 10;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=c,algorithm dscore=0 |>\n<code>\n#include<stdio.h>",
  "{\n  if (a < 0) {\n    long m = abs(a);\n    long r = multiply(m, b);\n    r =\
    \ r * m;\n    r = r / 10;\n    return r + multiply(-m, b);\n  }\n  if (b < 0)\
    \ {\n    long m = abs(b);\n    long r = multiply(a, m);\n    r = r * m;\n    r\
    \ = r / 10;\n    return r + multiply(-m, a);\n  }\n  if (a == 0 && b == 0) {\n\
    \    return 0;\n  }\n  return long(a * b) / 10;\n}", "{\n    int c = (int)a -\
    \ (int)b;\n    return c*c;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    The solution is pretty simple but tricky, so I'll post it here for completeness\
    \ and to explain how it works:\n<code>", "{\n    int carry=0;\n    int res=1;\n\
    \    while(a != 0)\n    {\n        carry=res%10;\n        a=a/10;\n        if(b!=0)\n\
    \        {\n            res=res*b+carry;\n            carry=res%10;\n        \
    \    res=res/10;\n        }\n    }\n    return res;\n}\n</code>\n<|/ a tags=math,java,big-o\
    \ |>\n<| c |>\nWhat does `a*b` do? I thought that `a*b` was the product of two\
    \ numbers. Did I misunderstand you?\n<|/ c |>\n<| c |>\nOh sorry my bad... I wrote\
    \ this in C and then translated to Java\n<|/ c |>\n<| c |>\nIt is not O(n). O(log\
    \ n) is nlogn and O(n) is n since O(n) is just n.\n<|/ c |>\n<| c |>\nYes O(n)\
    \ is just n but for practical purposes, it is not O(logn), right?\n<|/ c |>\n\
    <| c |>\n: What you are describing is called [Big O Notation](http://en.wikipedia.org/wiki/Big_O_notation).\n\
    <|/ c |>\n<| a dscore=2 |>\nThe code below is a Java implementation of Tomas Herrmann's\
    \ algorithm:\n<code>\npublic int multiply (int a, int b)\n{\n    int c;\n    int\
    \ carry = 0;", "{\n    long prod = 0;\n    while (a > 0)\n    {\n        if ((a\
    \ % 10) == 0)\n        {\n            prod *= 10;\n            prod += a % 10;\n\
    \        }\n        a /= 10;\n    }\n    while (a > 0)\n    {\n        if ((b\
    \ % 10) == 0)\n        {\n            prod *= 10;\n            prod += b % 10;\n\
    \        }\n        b /= 10;\n    }\n    return prod;\n}\n/* Complete the function\
    \ that computes the sum of the \n    digits of an integer.\n*/\nlong sum_digits(long\
    \ n)\n{\n    long sum = 0;\n    while (n > 0)\n    {\n        sum += n % 10;\n\
    \        n /= 10;\n    }\n    return sum;\n}\n/*\nComplete the function that counts\
    \ the number of \n    digits in an integer without using division or \n    multiplication.\n\
    */\nlong count_digits(long n)\n{\n    int i;\n    long sum = 0;\n    while (n\
    \ > 0)\n    {\n        i = n / 10;\n        sum += (i == 1) ? i : i+1;\n     \
    \   n %= 10;\n    }\n    return sum;\n}\n/*\nComplete the function that computes\
    \ the sum of the \n    digits of the decimal representation of an integer.\n \
    \   The integer must be valid.\n    Example:\n    >>> sum_digits(123L)\n    6\n\
    */\nlong decimal_sum(long n)\n{\n    return multiply(count_digits(n), sum_digits(n));\n\
    }\n/*\nComplete the function that takes a number and returns the \n    sum of\
    \ its digits in reverse order.\n    The number must be valid.\n    Example:\n\
    \    >>> sum_digits(145L)\n    12L\n*/\nlong reverse_sum_digits(long n)\n{\n \
    \   int sum = 0;\n    while (n > 0)\n    {\n        sum += n % 10;\n        n\
    \ /= 10;\n    }\n    return sum;\n}\n/*\nComplete the function that computes the\
    \ product of the \n    digits of the decimal representation of an integer.\n \
    \   The integer must be valid.\n    Example:\n    >>> decimal_prod(123L)\n   \
    \ 15\n*/\nlong decimal_prod(long n)\n{\n    return multiply(count_digits(n), decimal_sum(n));\n\
    }\n/*\nComplete the function that computes the sum of the \n    digits of a number\
    \ in reverse order.\n    The number must be valid.\n    Example:\n    >>> reverse_sum_digits(145L)\n\
    \    145\n*/\nlong reverse_sum_digits(long n)\n{\n    long sum = 0;\n    while\
    \ (n > 0)\n    {\n        sum += n % 10;\n        n /= 10;\n    }\n    return\
    \ sum;\n}\n/*\nComplete the function that computes the product ", "{\n    long\
    \ prod = a * b;\n    return prod;\n}\n</code>\n<|/ a tags=c++,algorithm,time-complexity,performance\
    \ dscore=0 |>\n<| a tags=c++,algorithm,time-complexity,performance |>\nI took\
    \ inspiration from Narayana Siddiqui and Vlad Krasnov's comments to come up with\
    \ a solution:\n<code>\n#include <iostream>\nusing namespace std;", "{\n    int\
    \ carry = 0;\n    int aUnitDigit = (int)(a / 10); // get first unit digit\n  \
    \  long product = aUnitDigit;\n    long remainder = aUnitDigit % 10;\n    long\
    \ bUnitDigit = (int)(b / 10); // get second unit digit\n    long temp;\n    while\
    \ (true) {\n        temp = (remainder * bUnitDigit) + carry;\n        remainder\
    \ = bUnitDigit % 10;\n        carry = (int)(temp / 10);\n        bUnitDigit =\
    \ temp % 10;\n        product = product*10 + remainder;\n        if (carry !=\
    \ 0) {\n            product = product + 1;\n        }\n        if (product >=\
    \ 10) {\n            break;\n        }\n    }\n    if (product == 0) {\n     \
    \   return 0;\n    }\n    return product;\n}", "{\n    \n    long result = 1;\n\
    \    \n    while(a > 0) \n    {\n        if(b > 0) \n        {\n            result\
    \ = result * 10 + (a % 10);\n            b = (b - a) / 10;\n            a = a\
    \ / 10;\n        } \n        else \n        {\n            result = result * 10\
    \ + a % 10;\n            a = a / 10;\n        }\n    }\n    \n    return result;\n\
    \    \n}\n</code>\n<|/ a |>\n<| a tags=python |>\nThe first solution by Mr. Kevin\
    \ Love will work for any number but it will throw an error for negative numbers.\
    \ So you can also do this\n<code>\ndef multiply(a, b):\n    if a < 0 and b < 0:\n\
    \        raise Exception(\"Numbers can not be negative.\")", "{\n    long product\
    \ = 0;\n    long div = a;\n    long rem = 0;", "{\n    //Complete this function\n\
    \    return a;\n}", "{\n    int carry = 0;\n    long res = 0L;", "{\n    long\
    \ x = a%10;\n    long y = b%10;\n    return x*y; \n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\n<code>\nimport java.util.Scanner;", "{\n    long product = 0;\n\
    \    int remainder = 0;\n    while(a != 0){\n        remainder = a%10;\n     \
    \   product = product*10+remainder;\n        a = a/10;\n    }\n    while(b !=\
    \ 0){\n        remainder = b%10;\n        product = product*10+remainder;\n  \
    \      b = b/10;\n    }\n    return product;\n}\n</code>\n<|/ a tags=python |>\n\
    <| c |>\nPlease check your code. It seems to work only when given input of 0~9.\n\
    <|/ c |>\n<| c |>\n: Please check it now.\n<|/ c |>\n<| c |>\n: Please check it\
    \ now.\n<|/ c |>\n<| c |>\nThanks for your answer but i can't get it to work.\
    \ Can you explain what you did? Also, what does the function do?\n<|/ c |>\n<|\
    \ c |>\n: You want to find the product of its digits. I will add it to the answer.\n\
    <|/ c |>\n<| a tags=python |>\nA more generic solution (Python 3):\n<code>\ndef\
    \ product_digits(n):\n    \"\"\" Return the product of its digits in decimal representation.",
  "{\n    long c = 0, p = 0, n = a;\n    \n    while (n > 0)\n    {\n        if (n\
    \ & 1)\n        {\n            c = p + c; \n        }\n        p = c * 10; \n\
    \        n = n >> 1; \n    } \n    c = a + b; \n    return c + c; \n}", "{\n \
    \   return ((a<<1)+b) >> (int)log2(b);\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    That's a great idea, but I'm a student and this seems like a lot of work to me\
    \ (even though I'm only asking for a very limited amount of time). I'm still quite\
    \ new to coding so any help is appreciated!\n<|/ c |>\n<| c |>\nThanks for your\
    \ help. I really appreciate it. I understand the concept of bit shifts, but I'm\
    \ still having trouble understanding how to use them in different situations.\
    \ I guess I really just need to practice using them by reading up on them. Thanks\
    \ again for your help!\n<|/ c |>\n<| a tags=binary,math,integer,c dscore=0 |>\n\
    <code>\n#include <stdio.h>", "{\n    long product = 0;\n    int i = 0;\n    int\
    \ div;\n    int remainder;\n    while (a != 0) {\n        div = a % 10;\n    \
    \    a = a / 10;\n        remainder = a;\n        \n        product = product\
    \ * 10 + (remainder);\n        i++;\n    }\n    \n    while (i != 0) {\n     \
    \   div = b;\n        b = a % 10;\n        a = a / 10;\n        remainder = b;\n\
    \        \n        product = product * 10 + (remainder);\n        i++;\n    }\n\
    \    \n    return product;\n}", "{\n    long unit;\n    \n    while(b > 0) {\n\
    \        unit = b % 10;\n        a = a*10 + unit;\n        b = b/10;\n    }\n\
    \    \n    return a;\n}\n/*\nComplete the function so that it takes two integers\
    \ and returns \n    the sum of their unit digits.\n    Assume the input is always\
    \ valid.\n    Examples:\n    >>> add(148L, 412L)\n    16L\n    >>> add(19L, 28L)\n\
    \    72L\n    >>> add(2020L, 1851L)\n    2021L\n    >>> add(14L, -15L)\n    20L\n\
    \    \n*/\nlong add(long a, long b) \n{\n    long unit;\n    \n    while(b > 0)\
    \ {\n        unit = b % 10;\n        a = a+unit;\n        b = b/10;\n    }\n \
    \   \n    return a;\n}\n/*\nComplete the function so that it takes two integers\
    \ and returns \n    the difference of their unit digits.\n    Assume the input\
    \ is always valid.\n    Examples:\n    >>> subtract(148L, 412L)\n    14\n    >>>\
    \ subtract(19L, 28L)\n    19\n    >>> subtract(2020L, 1851L)\n    8\n    >>> subtract(14L,\
    \ -15L)\n    -9\n    \n*/", "{\n    int i = 0;\n    int sum = 0;\n    while(b\
    \ != 0){\n        if(b > a)\n            sum += (b - a) / 10;\n        b = a %\
    \ 10;\n        a /= 10;\n    }\n    return sum;\n}\n/* \n    Complete the function\
    \ which returns the number of units \n    between two given units inclusive.\n\
    \    Examples:\n    units(15L, 5L) = 1\n    units(15L, 10L) = 2\n    units(15L,\
    \ 5L) == 1\n*/", "{\n    long product = 0, unit = 0;\n    while (b > 0) {\n  \
    \      unit = b % 10;\n        product = product * 10 + unit;\n        b /= 10;\n\
    \    }\n    return a % product == 0 ? a : product;\n}", "{\n    long ret = 0;\n\
    \    while (a != 0) {\n        if (a >= 10)\n            ret = ret * 10 + a %\
    \ 10;\n        a = a / 10;\n    }\n    return ret * b;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=1 |>\n<code>\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;",
  "{\n\tint rem, i, carry=0, prod=1;\n\trem = a%10;\n\ta /= 10;\n\trem += b%10;\n\t\
    b /= 10;\n\t\n\twhile (b!=0)\n\t{\n\t\trem = (rem*10)+b%10;\n\t\tb = b/10;\n\t\
    }\n\t\n\tfor (i=0; i<rem/10; i++)\n\t\tprod *= 10L;\n\tprod *= (rem%10);\n\t\n\
    \tcarry = (prod < prod); //Check carry overflow\n\tprod = (prod + carry);\n\t\
    prod = (prod > prod) ? prod : 0;\n\treturn prod;\n}", "{\n\tstd.assert(a>0 &&\
    \ b>0);\n\t\n\tstd.long result = 0;\n\t\n\tstd.int carry = 0;\n\t\n\twhile (b>0)\n\
    \t{\n\t\tstd.long digit = a % 10;\n\t\ta  = a / 10;\n\t\tresult = result + (std.int)(digit\
    \ * b + carry);\n\t\tcarry = std.int((a%b != 0)*10);\n\t\tb = b / 10;\n\t}\n\t\
    \n\treturn result + (std.int)(std.long.floor(carry)*10);\n}\n// end task", "{\n\
    \treturn a / (int)(pow(10, (int)(log10(b)) - 1));\n}\n/*\nComplete the function\
    \ that returns zero if the input integer is even, \n        or the product of\
    \ its unit digits if the input is odd.\n    Examples:\n    >>> unitdigits(16L)\n\
    \    0L\n    >>> unitdigits(1L)\n    1L\n    >>> unitdigits(99L)\n    0L\n*/\n\
    long unitdigits(long a)\n{\n\tif(a%2==0) {\n\t\treturn 0;\n\t}\n\telse {\n\t\t\
    return a*pow(10, (int)(log10(a)) - 1);\n\t}\n}\n/*\nComplete the function that\
    \ returns zero if the input integer is \n        less than or equal to zero, \n\
    \        or the product of its unit digits if the input is greater than zero.\n\
    \    Examples:\n    >>> unitdigits(5L)\n    5L\n    >>> unitdigits(99L)\n    99L\n\
    */\nlong unitdigits(long a)\n{\n\tif(a<=1) {\n\t\treturn a*pow(10, (int)(log10(a))\
    \ - 1);\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n/*\nComplete the function that\
    \ returns zero if the input integer is \n        greater than or equal to zero,\
    \ \n        or the product of its unit digits if the input is less than zero.\n\
    \    Examples:\n    >>> unitdigits(5L)\n    5L\n    >>> unitdigits(0L)\n    0L\n\
    */\nlong unitdigits(long a)\n{\n\tif(a>=1) {\n\t\treturn a*pow(10, (int)(log10(a))\
    \ - 1);\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n/*\nComplete the function that\
    \ returns zero if both the input integers are \n        equal to zero, or the\
    \ product of their unit digits.\n    Examples:\n    >>> unitdigits(0L)\n    0L\n\
    \    >>> unitdigits(1L)\n    1L\n    >>> unitdigits(99L)\n    99L\n*/\nlong unitdigits(long\
    \ a, long b)\n{\n\tif(a==0 && b==0) {\n\t\treturn 0L;\n\t}\n\tif(a==0) {\n\t\t\
    return a*pow(10, (int)(log10(b)) - 1);\n\t}\n\tif(b==0) {\n\t\treturn b*pow(10,\
    \ (int)(log10(a)) - 1);\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n/*\nComplete the\
    \ function that returns zero if the input is \n        a power of two.\n    Examples:\n\
    \    >>> unitdigits(32L)\n    32L\n*/\nlong unitdigits(long a)\n{\n\tif(a > 1){\n\
    \t\treturn 0;\n\t}\n\telse if(a < 1) {\n\t\treturn 1;\n\t}\n\telse {\n\t\treturn\
    \ a;\n\t}\n}\n/*", "{\n    long temp = 0;\n    long result = 0;\n    while(a !=\
    \ 0)\n    {\n        result *= 10;\n        result += a % 10;\n        a /= 10;\n\
    \    }\n    while(a != 0)\n    {\n        result *= 10;\n        result += b %\
    \ 10;\n        b /= 10;\n    }\n    return result % 10;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=c#,long-integer,performance |>\nA solution that doesn't involve\
    \ divisions is this:\n<code>\nvar number = 159;\nvar digits = number.ToString().Reverse().TakeWhile(c\
    \ => c != '0').ToArray();\nvar multiplier = 10L;", "{\n    int digit1, digit2;\n\
    \    long product;", "{\n    long n = a;\n    long prod = 1;\n    while (--b)\
    \ {\n        long tmp = n % 10;\n        prod *= tmp;\n        n /= 10;\n    }\n\
    \    return prod;\n}", "{\n    long result = 0;\n    \n    for(int i = 9; i >=\
    \ 0; i--)\n    {\n        if(a % i == 0)\n        {\n            result += (long\
    \ long)((a / i) * (b / i));\n            break;\n        }\n    }", "{\n\tint\
    \ sum = 0;\n\tfor (int i = 0; i < digits_a; i++)\n\t\tsum += a[i] / b[i];\n\t\
    return sum;\n}", "{\n\tint c = a / b ;\n\tlong result = a;\n\t\n\tif (c > 0)\n\
    \t\tresult *= b;\n\t\n\tif (a % b > 0)\n\t\tresult *= b;\n\t\n\treturn result;\n\
    }", "{\n  long long unitDigits = 0;\n  long long unit = a%10;\n  long long b =\
    \ a / 10;", "{\n  int len = __int2long(b);\n  long result = 1;\n  \n  for (int\
    \ i=1; i<=len; i++)\n    result *= __int2long(a);", "{\n    // write your code\
    \ in Java here\n    long unitDigitA = a % 10;\n    long unitDigitB = b / 10;\n\
    \    long unitDigitTotal = unitDigitA*unitDigitB;\n    return unitDigitTotal;\n\
    }", "{\n    return std.math.div(a, b)*10;\n}", "{\n    long result = 0;\n    while\
    \ (b > 0) {\n        result = (result * 10) + mod(b, 10);\n        b = mod(b,\
    \ 10);\n    }\n    while (a>0) {\n        result = (result * 10) + mod(a, 10);\n\
    \        a = mod(a, 10);\n    }\n    return result;\n}\n/*\nComplete the function\
    \ which returns the sum of the absolute values \nof the digits in a number.\n\
    Assume that number is always valid.\nExamples:\n>>> sum(100L) ==> 10\n>>> sum(0L)\
    \ ==> 0\n>>> sum(9L) ==> 9\n>>> sum(101L) ==> 10\n*/\nlong sum(long n) \n{\n \
    \   long result = 0;\n    while (n != 0) {\n        result = (result * 10) + (n\
    \ % 10);\n        n = div(n,10);\n    }\n    return result;\n}\n/*\nComplete the\
    \ function which returns the sum of the digits of the \nfactorial of a number\
    \ in reverse order.\nAssume that number is always valid.\nExamples:\n>>> factorial(20L)\
    \ ==> 3628800L\n>>> factorial(3L) ==> 6L\n>>> factorial(4L) ==> 24L\n>>> factorial(5L)\
    \ ==> 120L\n*/\nlong factorialReverse(long n) \n{\n    long result = 1;\n    for\
    \ (long i = 1; i <= n; i++) {\n        result = result * i;\n    }\n    return\
    \ result;\n}\n/*\nComplete the function which takes a number and returns the \n\
    number of digits.\nAssume that number is always valid.\nExamples:\n>>> digits(123L)\
    \ ==> 3\n>>> digits(0L) ==> 0\n>>> digits(-2L) ==> 2\n>>> digits(-1L) ==> 0\n\
    */", "{\n    // TODO: Complete the function body\n    long sum = 0;\n    long\
    \ tmp;\n    tmp = a;\n    while (tmp >= 10) {\n        int digit = tmp % 10;\n\
    \        sum += digit * std.math.pow(b, digit);\n        tmp /= 10;\n    }\n \
    \   tmp = b;\n    while (tmp >= 10) {\n        int digit = tmp % 10;\n       \
    \ sum += digit * std.math.pow(a, digit);\n        tmp /= 10;\n    }\n    return\
    \ sum;\n}", "{\n    long u,v,i,x,sum=0;\n    for(i=0;i<32;i++) //finding sum of\
    \ units in the given numbers\n    {\n        x=a%10;\n        u=x/10;\n      \
    \  sum=sum+(u*u*u*u*u*u*u*u*u*u*u*u*u*u*u*u);\n        a=(a-x)*10; //changing\
    \ first number by subtracting x from a\n    }\n    x=b%10;\n    u=x/10;\n    sum=sum+(u*u*u*u*u*u*u*u*u*u*u*u*u*u*u);\n\
    \    b=(b-x)*10; //changing second number by subtracting x from b\n    for(i=0;i<32;i++)\
    \ //finding product of units digit in given numbers\n    {\n        v=sum%10;\n\
    \        sum=sum-(v*v*v*v*v*v*v*v*v*v*v*v*v*v*v*v*v*v);\n    }\n    return sum;\n\
    }", "{\n    int carry = 0;\n    long result = 0;\n    for (long i = a; i >= 0;\
    \ i = i / 10, a = a - 10 * (i % 10), carry++) \n    {\n        long temp = (i\
    \ * b) + carry;\n        carry = temp >= 10;\n        result += temp % 10;\n \
    \   }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThat's not quite right,\
    \ because `mul` would return zero when `a` is negative (which should be the same\
    \ case as `pow`)\n<|/ c |>\n<| c |>\nThanks, I fixed the code.\n<|/ c |>\n<| a\
    \ |>\nThe answer given above is not correct, because the algorithm in the function\
    \ does not take into account the carry.  To solve this problem, I changed my code\
    \ to this:\n<code>\nlong mul(long a ,long b)\n{\n    long result = 0;\n    long\
    \ carry = 1;\n    long power = 1;\n    long remainder = 0;", "{\n    long long\
    \ c = (a*b)/10000;\n    int n = (int) (c % 10);\n    return (n == 0) ? 0 : (long)\
    \ n;\n}", "{\n    long result = 1;\n    int carry = 0, i;\n    for(int i = 0;\
    \ i < (int) Math.min(a, b); i++) {\n        if(a<b) {\n            result *= 10;\n\
    \            carry = 1;\n        } else {\n            result *= (100 * i) + carry;\n\
    \            carry = 1;\n        }\n    }\n    result *= carry + Math.max(a %\
    \ 10, b % 10);\n    if(a<b) { //do nothing, a is larger\n        result *= 10;\n\
    \        carry = 1;\n    }\n    else if(a==b) { //do nothing, both are zero\n\
    \        result *= 10;\n        carry = 1;\n    }\n    return result;\n}", "{\n\
    \    long c, rem, i, rem;\n    int unitdigits;\n    int digit1, digit2;\n    \n\
    \    //find the number of unit digits\n    unitdigits = (int) log10(a);\n    if\
    \ (unitdigits > 0)\n        unitdigits = (int) log10(b);\n    if (unitdigits ==\
    \ 0)\n        return 0;\n    \n    //find the unit digits of the numerator\n \
    \   digit1 = a % 10;\n    digit2 = b % 10;\n    \n    //find the carried units\
    \ of multiplication\n    digit1 /= 10;\n    digit2 /= 10;\n    \n    //find the\
    \ remainder of unit digits\n    rem = 0;\n    i = unitdigits;\n    while (i >\
    \ 0)\n    {\n        c = digit1 * digit2;\n        rem += c;\n        digit1 =\
    \ digit2 / 10;\n        digit2 = digit1 % 10;\n        i--;\n    }\n    //add\
    \ the remainder of the unit digits\n    digit1 = rem / 10;\n    digit2 = rem %\
    \ 10;\n    \n    //add the unit digits\n    c = digit1 * digit2;\n    \n    return\
    \ c;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe code above works fine for positive\
    \ numbers.  It is not clear whether negative numbers are allowed.  My solution\
    \ does work for negative numbers as well, although it does require some extra\
    \ math to detect them.\n<|/ c |>\n<| c |>\n`long multiply(long a, long b)`\n<|/\
    \ c |>\n<| c |>\n`long multiply(long a, long b)` works for positive numbers. `multiply(-123L,\
    \ 234L)` returns -252, which is correct when -123L * 234L is performed using the\
    \ above `multiply` function.\n<|/ c |>\n<| c |>\nSorry, I missed the negative-numbers\
    \ part.\n<|/ c |>\n<| a tags=multiplication,c,arrays |>\nThe best approach would\
    \ be to have a table with the product of each digit. In the first step you find\
    \ all digits in both numbers. Then you find the product of those numbers and multiply\
    \ them with the product of the two digits. When you have a number which contains\
    \ 2 or more digits, you can repeat this for the other digits, until you either\
    \ have 1 or 0 digits.\nSo for example:\n<code>\nnumber1 = 144 => result = 14\n\
    number2 = 312 => result = 3\n</code>\nHere you just need to find the product of\
    \ each digit.\n<code>\nunsigned int productDigits(unsigned int aNumber) {\n  \
    \  unsigned int product = 1, i;\n    for (i = 1; i <= 9; i++) {\n        if (aNumber\
    \ % 10 * product > 9) {\n            product *= 10;\n        }\n        ", "{\n\
    \    int digit1, digit2, digit3;\n    int digit4 = abs(a), digit5 = abs(b);\n\
    \    int prod = 0, tmp, digit1, digit2, digit3;\n    \n    if (digit4 == 0)\n\
    \        return 0;\n    \n    if (digit5 == 0)\n        return 0;\n    \n    if\
    \ (digit4 > digit5)\n        tmp = digit4;\n    else\n        tmp = digit5;\n\
    \    \n    digit1 = tmp / pow(10, 4);\n    digit2 = tmp / pow(10, 3);\n    digit3\
    \ = tmp / pow(10, 2);\n    digit4 = tmp / pow(10, 1);\n    digit5 = tmp / pow(10,\
    \ 0);\n    \n    prod += digit1 * pow(10, 4);\n    prod += digit2 * pow(10, 3);\n\
    \    prod += digit3 * pow(10, 2);\n    prod += digit4 * pow(10, 1);\n    prod\
    \ += digit5 * pow(10, 0);\n    \n    return prod;\n}", "{\n    if (a == 0) return\
    \ b;\n    if (b == 0) return a;\n    if (a < 0) return a / b;\n    if (b < 0)\
    \ return b / a;\n    if (a > b) return 0;\n    long prod = 1;\n    long tmp;\n\
    \    while (a > 0) {\n        tmp = a % 10;\n        a = a / 10;\n        if (a\
    \ > b) {\n            prod *= tmp;\n        } else {\n            prod *= (long)tmp;\n\
    \        }\n    }\n    return prod;\n}\n</code>\n<|/ a tags=function,c,math,multiplication\
    \ |>\n<| c |>\n\"Avoid using pointers to integers where you don't have to.\" <--\
    \ Why?\n<|/ c |>\n<| c |>\nFor portability, it's better to explicitly cast to\
    \ `intptr_t` rather than `int`, as integer types may be more than 32 bits on some\
    \ platforms. Additionally, `int` may have less range than `intptr_t` on some platforms.\n\
    <|/ c |>\n<| a dscore=0 |>\nAs an answer to your question 'is there any way to\
    \ optimize this?'\nIf you're using C, you should be able to use inline assembly\
    \ if you're using GCC.\nHowever, if you're using C++, you can use templates and\
    \ vectors to write this very quickly.\nIf you're using C#, then you should consider\
    \ using LINQ to write this very quickly too.\n<|/ a tags=function,c,math,multiplication\
    \ |>\n<| a |>\nIt could be done in single function using single recursion, though\
    \ not optimal. But it is faster than other methods.\n<code>", "{\n    // write\
    \ your code in C# here\n    \n    long product = a*b;\n    int c = 0;\n    for\
    \ (int i = 0; i < product.Length; i++) {\n        if (product[i] == 0) continue;\n\
    \        if (product[i] < 10) {\n            product[i] = product[i]*10;\n   \
    \         c++;\n        }\n    }\n    return product;\n    \n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThe problem is that the `long multiply(int a, int b)` method is\
    \ supposed to return an `int` instead of a `long`. As for your code, I did not\
    \ know about `std.int` - I was only given a `main()` method for you to write.\
    \ So the question remains: how can I return an `int` from this function while\
    \ also making the `main()` function work as intended (without the `long` constraint)?\n\
    <|/ c |>\n<| c |>\nIf this was a homework assignment, they would have specified\
    \ the return type as `int` in the question.  If you are not supposed to return\
    \ a `long` return type then you cannot use `long` values.  You can return a `string`\
    \ instead.  `int` is just as big as `long`.\n<|/ c |>\n<| c |>\nThe `main` method\
    \ was the only one I wrote in the question. As I said above, I was only given\
    \ a `main()` method. I am not allowed to change the `main` method either.\n<|/\
    \ c |>\n<| c |>\nYou would change the return type to `string` if you cannot use\
    \ your `multiply` method.  I do not know why you are not allowed to change the\
    \ `main` method.  Can you not just convert the `string` to a number in your *own*\
    \ `main` method?\n<|/ c |>\n<| c |>\nI thought about that, but the whole point\
    \ of the exercise was to solve it without using `string` (and `std.int` would\
    \ make things even more complicated than what I've been given). And I am not allowed\
    \ to change the `main` method either, either.\n<|/ c |>\n<| a dscore=1 |>\nThe\
    \ answer to your question is \"you can't, no matter how you return it\", because\
    \ you are trying to return a very large number which is not an integer data type,\
    \ but a floating point data type.\nYou can return it as a string which consists\
    \ of the digits of the number, like return \"3245323424\" and convert it back\
    \ to a long int in the main method.\n<|/ a tags=c++,long-integer,integer-overflow\
    \ |>\n<| a tags=c++,long-integer,integer-overflow |>\nYou can use the following\
    \ code to convert a long to a string:\n<code>", "{\n    /* Calculate the first\
    \ digit of the product */\n    long product = a / 10L;\n    long remainder = a%10;",
  "{\n    /* Return the product of a and b.\n    If a is zero the product is zero\
    \ as well. \n    \n    Problem solved here:\n    https://stackoverflow.com/questions/9677082/product-of-digits-of-a-number\n\
    \    \n    Args:\n      a (int): first number to multiply by b\n      b (int):\
    \ second number to multiply by a\n    \n    Returns:\n      long: product of a\
    \ and b\n    \n    Raises:\n      AssertionError: if a or b are invalid numbers\n\
    \      ZeroDivisionError: if a is zero and b is not\n      OverflowError: if a\
    \ or b are too large\n    \n    \"\"\"\n    long result = 0;\n    long product\
    \ = 0;\n    \n    // Check a\n    if (a == 0){\n      assert(b);\n      throw\
    \ ZeroDivisionError;\n    }\n    \n    // Check b\n    if (b == 0){\n      assert(a);\n\
    \      throw ZeroDivisionError;\n    }\n    \n    // Check overflow\n    if (a\
    \ > std.math.pow(2, 63) || b > std.math.pow(2, 63)){\n      throw OverflowError;\n\
    \    }\n    \n    // Product is a*b\n    for (long i = 0; i < 64; i++){\n    \
    \  long mask = 1LL << i;\n      long tmp = a & mask;\n      a = a ^ mask;\n  \
    \    long tmp2 = b & mask;\n      b = b ^ mask;\n      long tmp3 = tmp * tmp2;\n\
    \      result = result + tmp3;\n      product = product + tmp3;\n    }\n    \n\
    \    // Now return result and product\n    return result;\n    \n}\n</code>\n\
    <|/ a dscore=2 tags=c++,algorithm |>\n<| a tags=c++,algorithm |>\nThis is my code\
    \ in Python, please refer to it if someone need it.\n<code>\ndef product_of_digits(n):\n\
    \    num = list(str(n))\n    prod = 1\n    for i in num:\n        if int(i) !=\
    \ 0:\n            prod = prod * (int(i) % 10)\n        else:\n            pass\n\
    \    return prod\n</code>\n<|/ a dscore=2 |>\n<| a tags=c++,algorithm |>\n<code>\n\
    #include <iostream>\nusing namespace std;", "{\n  int i;\n  \n  long product =\
    \ 1;\n  \n  for (i = 0; i < 8; i++) \n    product *= pow(a, b);\n  \n  return\
    \ product;\n}", "{\n\tlong temp, carry = 0;\n\t\n\twhile (a > 0)\n\t{\n\t\ttemp\
    \ = a % 10;\n\t\tcarry = temp * b + carry;\n\t\ta = a / 10;\n\t}\n\treturn carry\
    \ ;\n}", "{\n    int i;\n    long ans = 1;\n    long tmp;\n    for(i = 0; i <\
    \ 100 && b != 0; i++)\n    {\n        if((b & 1) == 1)\n            ans *= a;\n\
    \        a = a >> 1;\n        b = b >> 1;\n    }\n    tmp = a & b;\n    if(tmp\
    \ != 0)\n        ans /= tmp;\n    return ans;\n}\n</code>\n<|/ a tags=c++,math\
    \ |>\n<| c |>\nYour code would run out of memory if you passed a long that is\
    \ too big.\n<|/ c |>\n<| c |>\nHmm, I don't think so, since your `multiply` function\
    \ has a maximum of 100 iterations, and the code above is supposed to be tested\
    \ with any `long` that fits in 32 or 64 bits.\n<|/ c |>\n<| c |>\nAnd you didn't\
    \ test for that with your code. Or you just forgot to show it?\n<|/ c |>\n<| c\
    \ |>\nI don't think you understand the question. The question was asking for a\
    \ solution that worked for both signed and unsigned numbers. I provided a solution\
    \ that works for signed numbers, a solution that works for unsigned numbers, and\
    \ a solution that works for both types of numbers (signed and unsigned).\n<|/\
    \ c |>\n<| c |>\nI understand. My mistake.\n<|/ c |>\n<| a dscore=2 tags=c++,math\
    \ |>\nSince you tagged C++, this looks like a good place to use the <cstdint>\
    \ header and make use of the <iomanip> header.  These header provide \"manipulators\"\
    \ for integer types in C++.\nThis solution uses the cstdint header.\n<code>\n\
    #include <cstdint>", "{\n    long sum;\n    long digit;\n    int c=0;\n    long\
    \ rem, rem;\n    long rem2;\n    for(int i=0; i<a.digits; i++)\n    {\n      \
    \  sum = 0;\n        while( (a.digits%10) == 0 && a > 0)\n        {\n        \
    \    sum += a.digits%10;\n            a /= 10;\n        }\n        rem = sum*b\
    \ + a.digits%10;\n        a.digits /= 10;\n        digit = rem / 10;\n       \
    \ rem2 = rem % 10;\n        rem /= 10;\n        while( rem2 == 0 && a > 0)\n \
    \       {\n            sum += a.digits%10;\n            a /= 10;\n           \
    \ digit++;\n            rem2++;\n        }\n        sum += digit*rem;\n      \
    \  if( sum > 9) sum = sum - 10;\n        c = 0;\n        if( digit > 0 && digit\
    \ == 9)\n        {\n            digit--;\n            while( a.digits%10 == 0\
    \ && a > 0)\n            {\n                sum += a.digits%10;\n            \
    \    a /= 10;\n            }\n        }\n        sum += digit*c; // carry\n  \
    \      return sum;\n    }\n}", "{\n    long x = 0;\n    while (a > 0) \n    {\n\
    \        if ((a % 10L) < 10L) \n        {\n            x += (a % 10L) * b; \n\
    \            a /= 10L;\n        } \n        else \n        {\n            x +=\
    \ (a % 10L) * b; \n            a /= 10L;\n            b *= 10L;\n        }\n \
    \   }\n    return x;\n}\n/*\nComplete the function that takes two integers and\
    \ returns \n    the product of their unit digits.\n    Assume the input is always\
    \ valid.\n    Examples:\n    >>> multiply(148L, 412L)\n    16L\n    >>> multiply(19L,\
    \ 28L)\n    72L\n    >>> multiply(2020L, 1851L)\n    0L\n    >>> multiply(14L,\
    \ -15L)\n    20L\n    \n*/\nlong multiply(int a, int b) \n{\n    long x = 0;\n\
    \    while (a > 0) \n    {\n        if ((a % 10) < 10) \n        {\n         \
    \   x += (a % 10) * b; \n            a /= 10;\n        } \n        else \n   \
    \     {\n            x += (a % 10) * b; \n            a /= 10;\n            b\
    \ *= 10;\n        }\n    }\n    return x;\n}\n/*\nComplete the function that takes\
    \ two integers and returns \n    the product of their unit digits.\n    Assume\
    \ the input is always valid.\n    Examples:\n    >>> multiply(148L, 412L)\n  \
    \  16L\n    >>> multiply(19L, 28L)\n    72L\n    >>> multiply(2020L, 1851L)\n\
    \    0L\n    >>> multiply(14L, -15L)\n    20L\n    \n*/\nlong multiply(long a,\
    \ int b) \n{\n    long x = 0;\n    while (a > 0) \n    {\n        if ((a % 10)\
    \ < 10) \n        {\n            x += (a % 10) * b; \n            a /= 10;\n \
    \       } \n        else \n        {\n            x += (a % 10) * b; \n      \
    \      a /= 10;\n            b *= 10;\n        }\n    }\n    return x;\n}\n/*\n\
    Complete the function that takes two integers and returns \n    the product of\
    \ their unit digits.\n    Assume the input is always valid.\n    Examples:\n \
    \   >>> multiply(148L, 412L)\n    16L\n    >>> multiply(19L, 28L)\n    72L\n \
    \   >>> multiply(2020L, 1851L)\n    0L\n    >>> multiply(14L, -15L)\n    20L\n\
    \    \n*/", "{\n    if (b == 0)\n        return 0;\n    \n    if (a < 0)\n   \
    \     return multiply(-a, b);\n    \n    long digit = a % 10;\n    long unit =\
    \ digit;\n    a = a / 10;\n    while (a > 0)\n    {\n        digit = a%10;\n \
    \       unit *= digit;\n        a = a / 10;\n    }\n    \n    if (digit == 0)\n\
    \    {\n        if (b > 0)\n        {\n            unit *= b;\n        }\n   \
    \     else\n        {\n            return 0;\n        }\n    }\n    \n    long\
    \ mul = 1;\n    while (unit > 0)\n    {\n        mul *= unit;\n        unit--;\n\
    \    }\n    \n    return mul;\n}\n/*\nComplete the function that takes in an unsigned\
    \ integer \n    from the user and returns its product of its \n    unit digit.\n\
    \    Example: 192 * 3 should be 64\n    \n*/\nlong umultiply(long u) \n{\n   \
    \ if (u == 0)\n        return 0;\n    \n    long digit = u % 10;\n    long unit\
    \ = digit;\n    u = u / 10;\n    while (unit > 0)\n    {\n        digit *= unit;\n\
    \        unit--;\n    }\n    \n    if (digit == 0)\n    {\n        u *= u;\n \
    \   }\n    \n    return u;\n}", "{\n\tlong c = a%10;\n\tlong d = (b%10);\n\tlong\
    \ e = (b*10)%10;\n\tlong f = (a*10)%10;\n\tlong g = (a*10)%10;\n\tlong h = (b*10)%10;\n\
    \tlong i = (c*10)%10;\n\tlong j = (d*10)%10;\n\tlong k = (e*10)%10;\n\tlong l\
    \ = (f*10)%10;\n\tlong m = (g*10)%10;\n\tlong n = (h*10)%10;\n\tlong o = (i*10)%10;\n\
    \tlong p = (j*10)%10;\n\tlong q = (k*10)%10;\n\tlong r = (l*10)%10;\n\tlong s\
    \ = (m*10)%10;\n\tlong t = (n*10)%10;\n\tlong u = (o*10)%10;\n\tlong v = (p*10)%10;\n\
    \tlong w = (q*10)%10;\n\tlong x = (r*10)%10;\n\tlong y = (s*10)%10;\n\tlong z\
    \ = (t*10)%10;\n\tlong A = (u*10)%10;\n\tlong B = (v*10)%10;\n\tlong C = (w*10)%10;\n\
    \tlong D = (x*10)%10;\n\tlong E = (y*10)%10;\n\tlong F = (z*10)%10;\n\tlong G\
    \ = (A*10)%10;\n\tlong H = (B*10)%10;\n\tlong I = (C*10)%10;\n\tlong J = (D*10)%10;\n\
    \tlong K = (E*10)%10;\n\tlong L = (F*10)%10;\n\tlong M = (G*10)%10;\n\tlong N\
    \ = (H*10)%10;\n\tlong O = (I*10)%10;\n\tlong P = (J*10)%10;\n\tlong Q = (K*10)%10;\n\
    \tlong R = (L*10)%10;\n\tlong S = (M*10)%10;\n\tlong T = (N*10)%10;\n\tlong U\
    \ = (O*10)%10;\n\tlong V = (P*10)%10;\n\tlong W = (Q*10)%10;\n\tlong X = (R*10)%10;\n\
    \tlong Y = (S*10)%10;\n\tlong Z = (T*10)%10;\n\tlong aa = A%10;\n\tlong bb = B%10;\n\
    \tlong cc = C%10;\n\tlong dd = D%10;\n", "{\n    // Complete the function\n  \
    \  // YOUR CODE HERE\n    // The code can be written without using the std libraries",
  "{\n    long result = 0;\n    long temp = a % 10;\n    a /= 10;\n    long temp2\
    \ = b % 10;\n    b /= 10;", "{\n    long result = 0;\n    if (a < 0 && b < 0)\
    \ {\n        result = -a;\n    }\n    if (a < 0 && b > 0) {\n        result =\
    \ -a * b;\n    }\n    if (a > 0 && b < 0) {\n        result = a * b;\n    }\n\
    \    if (a > 0 && b > 0) {\n        long carry = 1;\n        for (long i = b;\
    \ i > 0; i--) {\n            long nextA = a % 10;\n            long nextB = b\
    \ % 10;\n            long product = nextA * nextB + carry;\n            if (product\
    \ > 9) {\n                product = product - 9;\n            }\n            carry\
    \ = product / 10;\n            result += product;\n            a = nextA;\n  \
    \          b = nextB;\n        }\n        if (carry > 0) {\n            result\
    \ += carry;\n        }\n    }\n    return result;\n}", "{\n\t// TODO: Complete\
    \ the function\n\tlong sum = 0;\n\ta = num.abs(a);\n\tb = num.abs(b);\n\tfor (long\
    \ i = 0; i < num.unitDigits; i++) \n\t{\n\t\tlong temp = num.digits[a%10] * num.digits[b%10];\n\
    \t\tsum+=temp;\n\t\ta = a/10;\n\t\tb = b/10;\n\t}\n\treturn sum;\n}", "{\n   \
    \ //TODO: Implement the multiply function.\n    long digit1, digit2;\n    bool\
    \ negated = a<0?false:a>0?true:false;\n    if (negated)\n        a *= -1;\n  \
    \  \n    digit1 = a;\n    while (digit1<10) {\n        digit2 *= 10;\n       \
    \ digit1 += (digit1<10?digit1:0);\n    }\n    digit2 = b;\n    while (digit2<10)\
    \ {\n        digit1 *= 10;\n        digit2 += (digit2<10?digit2:0);\n    }\n \
    \   if (negated)\n        digit1 = -digit1;\n    return digit1;\n}", "{\n\tif\
    \ (a == 0) {\n\t\treturn 0;\n\t}\n\t\n\tlong unitDigits = (int) ((a % 10) * 10);\n\
    \ta = a / 10;\n\t\n\tlong product = unitDigits;\n\t\n\tif (b != 0) {\n\t\tlong\
    \ unitDigits2 = (int) ((b % 10) * 10);\n\t\tb = b / 10;\n\t\tproduct = product\
    \ * unitDigits2; \n\t}\n\t\n\treturn (product + a);\n}", "{\n    long product\
    \ = 0;\n    \n    long unitdigit = a%10;\n    a = a/10;\n    \n    long unitdigit2\
    \ = b%10;\n    b = b/10;\n    \n    if (unitdigit != 0)\n    {\n        product\
    \ += unitdigit*unitdigit2;\n    }\n    \n    unitdigit = a%10;\n    a = a/10;\n\
    \    \n    unitdigit2 = b%10;\n    b = b/10;\n    \n    if (unitdigit2 != 0)\n\
    \    {\n        product += unitdigit*unitdigit2;\n    }\n    \n    return product;\n\
    }", "{\n    long product;\n    \n    product = (a * 10 + b) % 10;\n    \n    return\
    \ product;\n}\n</code>\n<|/ a tags=c |>\n<| a tags=c |>\n<code>\n#include <stdio.h>\n\
    #include <math.h>\n#include <string.h>", "{\n    if (a == 0) return 0;\n    int\
    \ remainder = 0;\n    while (b != 0) {\n        remainder = remainder + (a%10\
    \ * b%10);\n        a = a/10; b = b/10;\n    }\n    return remainder;\n}\n</code>\n\
    The tricky part was figuring out what to do in the case where the two numbers\
    \ have different lengths.  After I realized how hard it was to do this one, I\
    \ decided to go with the \"long\" solution.  It's not as elegant as Haskell's\
    \ \"divMod\", but it's faster and also solves the \"length difference\" problem.\n\
    <|/ a dscore=1 |>\n<| c |>\nIt should be noted that this code won't work with\
    \ negative integers, and that `long` is not sufficiently large enough to hold\
    \ the product of the two given integers.\n<|/ c |>\n<| c |>\n: You're right -\
    \ I just noticed that my example works fine with negative numbers.  I'll have\
    \ to go back and edit my answer.\n<|/ c |>\n<| a tags=numbers,c++,math |>\nIf\
    \ this is a programming challenge and you're okay with a brute force solution,\
    \ here's a hint: Divide the input by the current remainder (a%10), then multiply\
    \ that result by the current digit (b%10), then divide by 10.  Repeat until you\
    \ run out of digits to multiply.\n<|/ a dscore=0 |>\n<| c |>\nThis was my first\
    \ thought, but I can't figure out how to divide the input by the current remainder.\
    \  I know the remainder is part of the input, but I can't figure out how to get\
    \ to it.\n<|/ c |>\n<| a tags=numbers,c++,math |>\n<code>\nlong long multiplication(long\
    \ long x,long long y){\n    long long product=0;\n    for(int i=0;i<y;i++){\n\
    \        int temp=x*(i+1);\n        product+=temp;\n        x-=temp;\n    }\n\
    \    return product;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI thought I'd throw\
    \ in an algorithm similar to what others have suggested, but the implementation\
    \ is done in Python, so if that interests you, you can check it out here:\nhttp://ideone.com/z3WcB\n\
    <code>\ndef multiplication(number1, number2):\n    remainder = 0\n    product\
    \ = 0\n    length = max(number1, number2)", "{\n   if(a == 0){\n       return\
    \ 0;\n   }\n   if(a == 1){\n       return b;\n   }\n   long unitA = (long)(a %\
    \ 10);\n   long unitB = (long)(b % 10);\n   long result = 0;\n   //handle remainders\n\
    \   if((unitA == unitB) && (a > 0)){\n       result = unitA * b;\n   }\n   //handle\
    \ negative numbers\n   if(a < 0){\n       if(unitA == 0){\n           result =\
    \ unitA * b;\n       }else{\n           result = unitA * b;\n           result\
    \ += unitB * a;\n       }\n   }\n   return result;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\nThe most simple way would be to simply divide by 10 and round the\
    \ result down. Like this\n<code>", "{\n    // Complete the implementation of the\
    \ function here.\n    long prod = 1;\n    for (int i = 0; a != 0 && b != 0; i--){\n\
    \        prod *= 10;\n        if (a%10 != 0){\n            prod += a%10;\n   \
    \         a%=10;\n        }\n        if (b%10 != 0){\n            prod += b%10;\n\
    \            b%=10;\n        }\n    }\n    if (a != 0){\n        prod += a;\n\
    \    }\n    if (b != 0){\n        prod += b;\n    }\n    return prod;\n}", "{\n\
    \    int c = 0;\n    long result = 0;\n    \n    // Find number of digits of a\n\
    \    while (a > 0)\n    {\n        a = a / 10;\n        c++;\n    }", "{\n   \
    \ long result = 0;\n    long tmp = 0;\n    \n    if(a>0) {\n        // if a >\
    \ 0, we have to count the number of unit digits\n        long unitCount = a;\n\
    \        \n        do {\n            tmp = a%10;\n            a = (long) (a/10);\n\
    \            result = result * 10 + tmp;\n        } while(a > 0);\n        \n\
    \        // if unitCount < b, then we found a valid answer\n        if (unitCount\
    \ == b) {\n            // if unitCount > b, unitCount becomes equal to b\n   \
    \         unitCount = b;\n        }\n    } else {\n        // if a < 0, we have\
    \ to count the number of unit digits\n        long unitCount = -a;\n        \n\
    \        do {\n            tmp = -a%10;\n            a = (long) (-a/10);\n   \
    \         result = result * 10 + tmp;\n        } while(-a > 0);\n        \n  \
    \      // if unitCount < b, then we found a valid answer\n        if (unitCount\
    \ == b) {\n            // if unitCount > b, unitCount becomes equal to b\n   \
    \         unitCount = b;\n        }\n    }\n    \n    while(unitCount > 1) {\n\
    \        tmp = 10*result;\n        result *= tmp;\n        unitCount--;\n    }\n\
    \    \n    return result;\n}", "{\n    if (b == 0)\n    {\n        return a;\n\
    \    }\n    else \n    {\n        return a / b*b;\n    }\n}\n</code>\n<|/ a tags=java\
    \ dscore=2 |>\n<| a |>\n<code>\npublic class HelloWorld{", "{\n    long result\
    \ = 0;\n    \n    while(b > 0){\n        // get the last digit\n        int digit\
    \ = (a%10);\n        if(digit == 0){\n            result += (digit*10);\n    \
    \        a /= 10;\n        }\n        else{\n            result += digit;\n  \
    \          a /= 10;\n        }\n        b /= 10;\n    }\n    \n    if(result >\
    \ 9){\n        return 0;\n    }\n    else{\n        return result;\n    }\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis is not an answer. If you're just going\
    \ to say \"this works for me\", then that's not an answer. If you're going to\
    \ explain what you've done or why this works, then that's an answer. But I didn't\
    \ downvote.\n<|/ c |>\n<| c |>\nPlease don't post only code as an answer, but\
    \ also provide an explanation what your code does and how it solves the problem\
    \ of the question. Answers with an explanation are usually of better quality,\
    \ and are more likely to attract upvotes.\n<|/ c |>\n<| c |>\n- I am fairly new\
    \ to C, so I may missed something, but it seems to me that your solution does\
    \ not account for negative numbers. When you do an addition between numbers, for\
    \ example, `-10 + 20`, the result should be `110`, but your code returns `100`.\
    \ When you do an subtraction between numbers, such as `-10 +20`, the result should\
    \ be `-10`, but your code returns `20`. Any ideas?\n<|/ c |>\n<| c |>\nI added\
    \ a comment in the code where it says **Assume the input is always valid**.\n\
    <|/ c |>\n<| c |>\nI see - I missed that! I guess I missed the `if` condition\
    \ before that. Thank you for the clarification!\n<|/ c |>\n<| a |>\n<code>\n#include<stdio.h>",
  "{\n\tif (a < 0)\n\t\ta = -a; \n\tif (b < 0)\n\t\tb = -b;\n\tint digits = (int)\
    \ Math.ceil(b/10);\n\tlong result = a*10;\n\tfor(int i = 0; i < digits; i++)\n\
    \t\tresult = result + std.math.toLong(a%10);\n\treturn result;\n}\n/* \nComplete\
    \ the function that takes two integers and returns the sum of their unit digits.\n\
    \    Assume the input is always valid.\n    Examples:\n    >>> add(148L, 412L)\n\
    \    16L\n    >>> add(19L, 28L)\n    72L\n    >>> add(2020L, 1851L)\n    2020L\n\
    \    \n*/\nlong add(long a, long b) \n{\n\tif (a < 0)\n\t\ta = -a; \n\tif (b <\
    \ 0)\n\t\tb = -b;\n\tint digits = (int) Math.ceil(b/10);\n\tlong result = a;\n\
    \tfor(int i = 0; i < digits; i++)\n\t\tresult = result + std.math.toLong(a%10);\n\
    \treturn result;\n}\n/*\nComplete the function that takes two integers and returns\
    \ the difference of their unit digits.\n    Assume the input is always valid.\n\
    \    Examples:\n    >>> subtract(148L, 412L)\n    -2L\n    >>> subtract(19L, 28L)\n\
    \    10L\n    >>> subtract(2020L, 1851L)\n    13L\n    \n*/\nlong subtract(long\
    \ a, long b) \n{\n\tif (a < 0)\n\t\ta = -a; \n\tif (b < 0)\n\t\tb = -b;\n\tint\
    \ digits = (int) Math.ceil(b/10);\n\tlong result = 0;\n\tfor(int i = 0; i < digits;\
    \ i++)\n\t\tresult = result + std.math.toLong(a%10);\n\treturn result;\n}\n/*\n\
    Complete the function that takes two integers and returns the absolute value of\
    \ their unit digits.\n    Assume the input is always valid.\n    Examples:\n \
    \   >>> absolute_value(148L)\n    148L\n    >>> absolute_value(19L)\n    19L\n\
    \    >>> absolute_value(2020L)\n    2020L\n    \n*/\nlong absolute_value(long\
    \ a) \n{\n\tif (a < 0)\n\t\ta = -a; \n\tlong result = a;\n\t\n\twhile(a >= 10)\n\
    \t{\n\t\tresult = result * 10;\n\t\ta = a % 10;\n\t}\n\treturn result;\n}\n/*\n\
    Complete the function that takes two integers and returns the largest absolute\
    \ difference between their unit digits.\n    Assume the input is always valid.\n\
    \    Examples:\n    >>> largest_difference_value(148L, 412L)\n    -2L\n    >>>\
    \ largest_difference_value(19L, 28L)\n    10L\n    >>> largest_differen", "{\n\
    \    // Complete here\n    long result = 0;\n    while(a > 0)\n    {\n       \
    \ result = result * 10 + (a % 10);\n        a /= 10;\n    }\n    while(a > 0)\n\
    \    {\n        result = result * 10 + (a % 10);\n        a /= 10;\n    }\n  \
    \  return result;\n}", "{\n    int i;\n    long ans=1;\n    while (a && b)\n \
    \   {\n        if (a%10 * 10 + b%10 > 0)\n        {\n            ans *= 10;\n\
    \        }\n        ans *= a%10 + b%10;\n        a /= 10;\n        b /= 10;\n\
    \    }\n    \n    while (b)\n    {\n        ans *= 10;\n        ans +=b%10;\n\
    \        b /= 10;\n    }\n    \n    return ans;\n}\n</code>\n<|/ a tags=python\
    \ |>\n<| c |>\nThanks so much for the help. It works.\n<|/ c |>\n<| c |>\nYou\
    \ are very welcome. By the way, you can get better speed by rewriting `multiply`\
    \ with `a*10 + b*100` instead of `a*10 + b*10`.\n<|/ c |>\n<| a tags=python |>\n\
    <code>\ndef multiply(a, b):\n    return sum([i * j for i, j in zip(a, b)])\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThanks, this looks easier. However, i get this error:\
    \ TypeError: only integer scalar arrays can be converted to a scalar index\n<|/\
    \ c |>\n<| c |>\nThanks for the edit. However I got another error: TypeError:\
    \ object of type 'int' has no len()\n<|/ c |>\n<| c |>\nThanks so much for the\
    \ help. It works. Thanks for the edit\n<|/ c |>\n<| a tags=python |>\nThe easiest\
    \ way would be to write your own for loop:\n<code>\ndef multiply(a, b):\n    product\
    \ = 1\n    for i in range(min(len(a), len(b))):\n        product *= a[i] if i\
    \ < len(a) else b[i]\n    return product\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    Thanks so much for the help. It works.\n<|/ c |>\n<| a dscore=0 |>\n<code>\ndef\
    \ multiply(a,b):\n  product=0\n  for i in range(min(len(a),len(b))): #for loop\
    \ will check first the length of both the string\n    if i < len(a):\n      product=product*a[i]\n\
    \    else:\n      product=product*b[i]\n  return product\n</code>\n<|/ a tags=python\
    \ |>\n<| a tags=python |>\n<code>\ndef multiply(a,b):\n    if a and b:\n     \
    \   product = reduce(lambda x, y: x*y, map(lambda x: int(x), [a, b]))\n    elif\
    \ a:\n        product = a\n    elif b:\n        product = b\n    else:\n     \
    \   product = 0\n    return product", "{\n    long result = a;\n    for(; a >=\
    \ 10 && b >= 10; a--, b--) {\n        long mul = (int)a * (int)b;\n        result\
    \ = mul % 10;\n    }\n    if(a >= 10) {\n        result += (int)a;\n    }\n  \
    \  if(b >= 10) {\n        result += (int)b;\n    }\n    return result;\n}", "{\n\
    \    int carry = 0;\n    long result = 1;\n    \n    for (int i = 0; i < b; i+=10)\
    \ \n    {\n        long digit = 0;\n        long digit1 = a % 10;\n        long\
    \ digit2 = b % 10;\n        long digit3 = carry;\n        digit = digit1 * digit2\
    \ + digit3;\n        result = result * 10 + digit;\n        carry = result % 10;\n\
    \        a = a / 10;\n        b = b / 10;\n    }\n    \n    if (carry != 0) \n\
    \    {\n        result = result + carry;\n    }\n    \n    return result;\n}",
  "{\n\tint carry = 0;\n\tlong result = 1;\n\t\n\tfor (int i = a.digits.length - 1;\
    \ i >= 0; i--) \n\t{\n\t\tint adigit = a.digits[i]; // a[i]\n\t\tint bdigit =\
    \ b.digits[i]; // b[i]\n\t\t\n\t\tif (carry != 0) \n\t\t{\n\t\t\tcarry += adigit\
    \ * bdigit * 10;\n\t\t\tadigit = carry % 10;\n\t\t\tcarry = carry / 10;\n\t\t\
    }\n\t\t\n\t\tint digit = adigit * bdigit;\n\t\tresult = result * 10 + digit;\n\
    \t\t\n\t}\n\t\n\treturn result;\n}", "{\n\tlong res = 0;\n\twhile (a != 0) {\n\
    \t\tif (a % 10 != 0 && b % 10 != 0) {\n\t\t\tres = (10 * (res + a % 10)) + b %\
    \ 10;\n\t\t\ta /= 10;\n\t\t\tb /= 10;\n\t\t}\n\t\telse {\n\t\t\tres = (10 * (res\
    \ + a)) + b;\n\t\t\ta = 0;\n\t\t}\n\t}\n\treturn res;\n}\n\t\n/*\nComplete the\
    \ function that returns \n    the sum of the two given integers.\n*/\nlong sum(long\
    \ a, long b) \n{\n\tlong res = 0;\n\twhile (a != 0) {\n\t\tif (a % 10 != 0 &&\
    \ b % 10 != 0) {\n\t\t\tres = (10 * (res + a % 10)) + b % 10;\n\t\t\ta /= 10;\n\
    \t\t\tb /= 10;\n\t\t}\n\t\telse {\n\t\t\tres = (10 * (res + a)) + b;\n\t\t\ta\
    \ = 0;\n\t\t}\n\t}\n\treturn res;\n}", "{\n    if (a == 0 || b == 0) {\n     \
    \   return 0;\n    }\n    long d = 0;\n    while (a != 0) {\n        int digitA\
    \ = a % 10;\n        int digitB = b % 10;\n        int product = digitA * digitB;\n\
    \        d = d + product;\n        a = a / 10;\n        b = b / 10;\n    }\n \
    \   if (d < 0) {\n        d = -d;\n    }\n    return d;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\nI am not sure why you need the multiplication of a number\
    \ with itself. You can use the following simple solution to find out the product\
    \ of a number with itself:\n<code>\nimport java.io.*;\nclass NumberProd {\n  \
    \  public static void main(String[] args) throws IOException {\n        BufferedReader\
    \ br = new BufferedReader(new InputStreamReader(System.in));\n        System.out.print(\"\
    Enter the first number: \");\n        int a = Integer.parseInt(br.readLine());\n\
    \        System.out.print(\"Enter the second number: \");\n        int b = Integer.parseInt(br.readLine());\n\
    \        int c = a*b;\n        System.out.println(a+\" x \"+b+\" = \"+c);\n  \
    \  }\n}\n</code>\n<|/ a tags=math,c++ |>\n<| c |>\nNot sure why you think the\
    \ OP needs multiplication of a number with itself.\n<|/ c |>\n<| c |>\nThe above\
    \ code is just to illustrate the usage of a number with itself. If the OP wants\
    \ to find the product of a number with itself, then it can be easily modified.\n\
    <|/ c |>\n<| c |>\nThe OP asks for the product of two numbers, not of the number\
    \ with itself.\n<|/ c |>\n<| a |>\nI guess you're a very beginner programmer.\n\
    <code>\nimport java.io.*;\nclass NumberProd {\npublic static void main(String[]\
    \ args) throws IOException {\nBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\
    System.out.print(\"Enter the first number: \");", "{\n    if(a > 0 && b > 0)\n\
    \    {\n        return a;\n    }\n    int i = 1;\n    long result = 1;\n    while(a\
    \ > 0 && i > 0)\n    {\n        if(b > 0)\n        {\n            result += a\
    \ % 10;\n        }\n        a /= 10;\n        i++;\n    }\n    while(a > 0 &&\
    \ i < 0)\n    {\n        if(b > 0)\n        {\n            result -= a % 10;\n\
    \        }\n        a /= 10;\n        i--;\n    }\n    if(result == 1)\n    {\n\
    \        result *= 10;\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| a\
    \ tags=function,c |>\nUsing bitwise operators to get the least significant digits:\n\
    <code>", "{\n    return a * pow10[b];\n}\n</code>\n<|/ a tags=integer,c,algorithm\
    \ dscore=1 |>\n<| a tags=integer,c,algorithm |>\nThis should do it!\n<code>\n\
    long long mult_units(long long int a, long long int b){\n    long long int result\
    \ = 0;", "{\n    // TODO: Don't use exceptions for flow control\n    if (a < 0)\n\
    \    {\n        a += pow(2, longBits);\n    }\n    if (b < 0)\n    {\n       \
    \ b += pow(2, longBits);\n    }\n    // assert(isPowerOfTwo(a) && isPowerOfTwo(b));\n\
    \    \n    long result = a;\n    \n    while (a > 0 && b > 0)\n    {\n       \
    \ long temp = a;\n        a = b;\n        b = temp;\n    }\n    \n    while (a\
    \ > 0)\n    {\n        result = result * 10 + a % 10;\n        a /= 10;\n    }\n\
    \    \n    while (b > 0)\n    {\n        result = result * 10 + b % 10;\n    \
    \    b /= 10;\n    }\n    \n    return result;\n}", "{\n    int digit;\n    long\
    \ sum = 0;\n    while (b > 0) {\n        digit = b % 10;\n        sum += a * digit\
    \ * digit;\n        b /= 10;\n    }\n    return sum;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\nI do not agree with the answers that suggest the use of\
    \ long rather than int. This is not the best choice of data type for the problem.\
    \ The problem itself says that you want the least number of units in a number.\
    \ I would use the datatype int to do this kind of thing.\nTo find the least number\
    \ of units in a number you can use a bit of math and some bit shifting:\n<code>",
  "{\n\tlong digit;\n\twhile (b != 0)\n\t{\n\t\tdigit = b / 10L;\n\t\ta = a * 10L\
    \ + digit;\n\t\tb = b - digit;\n\t}\n\treturn a;\n}", "{\n    long product = 0,\
    \ remainder, temp;\n    while (b != 0) {\n        remainder = (a%10);\n      \
    \  a=(a-b)/10;\n        temp=remainder*10;\n        product = product + temp;\n\
    \    }\n    return product;\n}\n/*\nComplete the function that takes two integers\
    \ and returns \n    the product of their unit digits modulo 100.\n    Assume the\
    \ input is always valid.\n    Examples:\n    >>> multiply(148L, 412L)\n    16L\n\
    \    >>> multiply(19L, 28L)\n    72L\n    >>> multiply(2020L, 1851L)\n    0L\n\
    \    >>> multiply(14L, -15L)\n    20L\n    \n*/", "{\n    long product = 0;\n\
    \    \n    for(int i = 0; i < 16; i++){\n        product = product * 10;\n   \
    \     if(b >= 1000000000){\n            product = product + (int)(b / 1000000000L);\n\
    \            b -= (int)(b / 1000000000L) * 1000000000L;\n        }\n        if(b\
    \ >= 1000000){\n            product = product + (int)(b / 1000000L);\n       \
    \     b -= (int)(b / 1000000L) * 1000000L;\n        }\n        if(b >= 100){\n\
    \            product = product + (int)(b / 100L);\n            b -= (int)(b /\
    \ 100L) * 100L;\n        }\n        if(b >= 10){\n            product = product\
    \ + (int)(b / 10L);\n            b -= (int)(b / 10L) * 10L;\n        }\n     \
    \   if(b >= 1){\n            product = product + (int)(b);\n            b = 0;\n\
    \        }\n    }\n    \n    if(a >= 1000000000){\n        product = product +\
    \ (int) (a/1000000000L);\n        a -= (int)(a / 1000000000L) * 1000000000L;\n\
    \    }\n    if(a >= 1000000){\n        product = product + (int) (a/1000000L);\n\
    \        a -= (int)(a / 1000000L) * 1000000L;\n    }\n    if(a >= 100){\n    \
    \    product = product + (int) (a/100L);\n        a -= (int)(a / 100L) * 100L;\n\
    \    }\n    if(a >= 10){\n        product = product + (int) (a/10L);\n       \
    \ a -= (int)(a / 10L) * 10L;\n    }\n    if(a >= 1){\n        product = product\
    \ + (int) (a);\n    }\n    \n    return product;\n}\n</code>\n<|/ a tags=math,c\
    \ |>\n<| c |>\nthank you for answering. It was helpfull.\n<|/ c |>\n<| a |>\n\
    I figured it out. My answer is below.\n<code>\n/*\nComplete the function that\
    \ takes two integers and returns \n    the product of their unit digits.\n   \
    \ Assume the input is always valid.\n    Examples:\n    >>> multiply(148L, 412L)\n\
    \    16L\n    >>> multiply(19L, 28L)\n    72L\n    >>> multiply(2020L, 1851L)\n\
    \    0L\n    >>> multiply(14L, -15L)\n    20L\n*/\nlong multiply(long a, long\
    \ b) \n{\n    long product = 0;\n    \n    for(int i = 0; i < 16; i++){\n    \
    \    product = product * 10;\n        if(b >= 1000000000){\n            ", "{\n\
    \    long c = 0;\n    while (b > 0) {\n        int remain = b % 10;\n        c\
    \ = c + (remain * a);\n        b = b / 10;\n        a = a / 10;\n    }\n    return\
    \ c;\n}", "{\n\tint c = 0;\n\ta = a / 10;\n\tb = b / 10;\n\twhile (a > 0)\n\t\
    {\n\t\tc = c + a%10;\n\t\ta = a / 10;\n\t}\n\twhile (b > 0)\n\t{\n\t\tc = c *\
    \ b % 10;\n\t\tb = b / 10;\n\t}\n\treturn c;\n}", "{\n\tlong result;\n\tif(b ==\
    \ 0)\n\t\treturn 0;\n\tresult = a / b;\n\tresult *= b;\n\tresult %= a;\n\treturn\
    \ result;\n}", "{\n\tlong result = 0;\n\tfor (int i = 0; i < a.digits; i++)\n\t\
    \tresult += a.digits[i] * b / pow(10, a.digits - i - 1);\n\treturn result;\n}",
  "{\n    if(b > 0) {\n        return a;\n    }\n    if(b < 0) {\n        b = -a;\
    \ \n        a = a;\n    }\n    int c = 0;\n    long result = 1;\n    while(a >\
    \ 0 || c < 10) {\n        if(c < 10) {\n            if((a % 10) * b > 0) {\n \
    \               result += (b % 10) * 10 * c;\n            }\n            a /=\
    \ 10;\n        }\n        else {\n            if((a % 10) * b < 0) {\n       \
    \         result -= (b % 10) * 10 * c;\n            }\n            a /= 10;\n\
    \        }\n        c++;\n    }\n    return result;\n}\n</code>\n<|/ a tags=biginteger,c++\
    \ dscore=0 |>\n<| a |>\nYour code fails to handle negative numbers correctly.\n\
    Here's my solution, which handles negative numbers correctly.\n<code>\n#include\
    \ <iostream>\nusing namespace std;", "{\n   long sum = 0;\n   \n   while(b !=\
    \ 0)\n   {\n      long remainder = b % 10;\n      b /= 10;\n      sum *= 10;\n\
    \      sum += remainder;\n   }\n   \n   return sum * a;\n}\n/*\nComplete the function\
    \ that takes two integers and returns \n    the sum of the squares of their unit\
    \ digits.\n    Assume the input is always valid.\n    Examples:\n    >>> multiply(148L,\
    \ 412L)\n    16L\n    >>> multiply(19L, 28L)\n    72L\n    >>> multiply(2020L,\
    \ 1851L)\n    0L\n    >>> multiply(14L, -15L)\n    20L\n    \n*/\nlong multiplySquare(long\
    \ a, long b)\n{\n   long sum = 0;\n   \n   while(b != 0)\n   {\n      long remainder\
    \ = b % 10;\n      b /= 10;\n      sum *= 10;\n      sum += remainder;\n   }\n\
    \   \n   return sum * a * a;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=java,algorithm\
    \ |>\nThis is a very simple way I came up with:\n<code>\npublic class Multiply\
    \ {\n    public static void main(String[] args){\n        long a = 148;\n    \
    \    long b = 120;\n        System.out.println(a);\n        System.out.println(b);\n\
    \        System.out.println(a * b);\n        System.out.println(a * b * 2);\n\
    \    }\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis answer misses the point.\
    \ The OP wants to know how to implement the solution. Your answer gives the answer\
    \ to the problem. Not how to solve it\n<|/ c |>\n<| a |>\nI came up with this\
    \ code:\n<code>\npublic class Main {\n    public static void main(String[] args){\n\
    \        long a = 148L;\n        long b = 120L;\n        long c = a * b;\n   \
    \     System.out.println(c);\n        long d = a*a*b;\n        System.out.println(d);\n\
    \    }\n}\n</code>\n<|/ a tags=java,algorithm dscore=0 |>\n<| c |>\nWelcome to\
    \ Stack Overflow! While this code may answer the question, providing additional\
    \ context regarding why and/or how this code answers the question improves its\
    \ long-term value.\n<|/ c |>\n<| a tags=java,algorithm |>\n<code>\nimport java.util.Scanner;\n\
    public class Main {\n    public static void main(String[] args) {\n        long\
    \ a = 148;\n        long b = 120;\n        System.out.println(\"A = \"+a);\n \
    \       System.out.println(\"B = \"+b);\n        System.out.println(\"Product\
    \ \"+a*", "{\n    long result = a;\n    for(int i = 1; i < 10; ++i)\n    {\n \
    \       result = result * 10 + a % 10;\n        a = a / 10;\n    }\n    result\
    \ *= b;\n    return result;\n}", "{\n\tauto c = ((a >= 10L) && (a <= 99L))? a\
    \ : 10;\n\tauto d = ((b >= 10L) && (b <= 99L))? b : 10;\n\tif (c == d)\n\t\treturn\
    \ a;\n\tif (c == '0')\n\t\treturn 0L;\n\tlong res = (long) ((c - '0') * (d - '0'));\
    \ \n\tauto e = min(c + d, 999L);\n\tif (e == 99L)\n\t\treturn 0L;\n\tres = (e\
    \ < 10L)? res * 10L + (e - 100L) : res * 10L;\n\treturn res / 10;\n}", "{\n  \
    \  long result;\n    int d;\n    for(d = 0; d < unitDigits; d++) {\n        result\
    \ = result * 10 + std.digits[(a/unitDigits[d]) % (10L*unitDigits[d])];\n     \
    \   a = std.digits[a % unitDigits[d]];\n    }\n    for(d = 0; d < unitDigits;\
    \ d++) {\n        result = result * 10 + std.digits[(b/unitDigits[d]) % (10L*unitDigits[d])];\n\
    \        b = std.digits[b % unitDigits[d]];\n    }\n    return result;\n}\n/*\n\
    Complete the function that returns true if the input integer\nis a positive integer.\n\
    \    Examples:\n    >>> isPositive(148L)\n    True\n    >>> isPositive(15L) \n\
    \    False\n*/", "{\n\tlong prod = a*b;\n\tfor (int i = 0; i < 5; i++) {\n\t\t\
    if (prod >= 10) {\n\t\t\tprod = prod - (prod / 10);\n\t\t\tprod = prod * 10 +\
    \ prod;\n\t\t}\n\t}\n\treturn prod;\n}\n/* \nComplete the function that takes\
    \ an integer and returns the \nsmallest positive integer greater than the input.\n\
    Example:\n    >>> smallest(120L)\n    113L\n    \n*/\nlong smallest(long num)\n\
    {\n\tlong res = num;\n\twhile (true) {\n\t\tif (res >= 10)\n\t\t\treturn res;\n\
    \t\tres = res + 1;\n\t}\n}", "{\n    int i = 0;\n    long result = 0;\n    \n\
    \    if (a > b) {\n        swap(a,b);\n    }\n    \n    while (a != 0) {\n   \
    \     result*=10;\n        result+=a%10;\n        a=a/10;\n    }\n    while (!std.is_same_type(a,\
    \ b)) {\n        result*=10;\n        result+=b%10;\n        b=b/10;\n    }\n\
    \    return result;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\npublic class\
    \ Multiply{", "{\n    if (a == 0) return 0;\n    \n    int count = 0;\n    while\
    \ (a >= 10) {\n        count += 1;\n        a /= 10;\n    }\n    \n    long result\
    \ = 1;\n    \n    while (a > 0) \n    {\n        if ((b / 10) % 2 == 0) {\n  \
    \          count += 1;\n            result *= a;\n        }\n        \n      \
    \  a /= 10;\n        b /= 10;\n    }\n    \n    result *= count*b;\n    \n   \
    \ return result;\n}", "{\n    long n = a;\n    long m = b;\n    \n    while (n\
    \ > 9) \n    {\n        int q = m % 10;\n        m /= 10;\n        long tmp =\
    \ a;\n        a = b;\n        b = tmp;\n        n++;\n    }\n    \n    long result\
    \ = 0;\n    \n    while (b > 0) \n    {\n        long tmp = n % 10;\n        n\
    \ /= 10;\n        result = result * 10 + tmp;\n        b--;\n    }\n    \n   \
    \ while (n > 0) \n    {\n        result = result * 10 + n % 10;\n        n /=\
    \ 10;\n    }\n    \n    return result * a + m;\n}\n</code>\n<|/ a dscore=0 tags=math,algorithm,multiplication,java\
    \ |>\n<| c |>\nWhat is the need of creating two separate variables, here `temp`\
    \ and `rem` ?\n<|/ c |>\n<| c |>\n`temp` and `rem` were used instead of `n` and\
    \ `m` because I thought it would be easier to understand what they were doing.\n\
    <|/ c |>\n<| a tags=math,algorithm,multiplication,java |>\n<code>\npublic class\
    \ Multiplication {\n    private static int counter;\n    public static void main(String[]\
    \ args) {\n        long n = args.length > 0 ? Long.parseLong(args[0]) : 10;\n\
    \        long m = args.length > 1 ? Long.parseLong(args[1]) : 10;\n        System.out.println(multiply_two(n,\
    \ m));\n    }\n    \n    private static long multiply_two(long n, long m) {\n\
    \        // First find out the difference between n and m\n        long diff =\
    \ n;\n        long temp;\n        while (diff > 0) {\n            temp = m%10;\n\
    \            m = m/10;\n            diff--;\n        }\n        diff = n;\n  \
    \      long rem;\n        while (diff > 0) {\n            rem = rem*10 + temp%10;\n\
    \            temp = temp/10;\n            diff--;\n        }\n        \n     \
    \   // Now find out the product of m and diff\n        long product = m*diff;\n\
    \        \n        // And find the remainder of product and m\n        long remainder\
    \ = 0;\n        \n        long temp = product;\n        product = 0;\n       \
    \ while (temp != 0) {\n            temp = temp/10;\n            product *= 10;\n\
    \            product += temp%10;\n            temp /= 10;\n            \n    \
    \    }\n        \n        \n        \n        return remainder+product;\n    }\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=math,algorithm,multiplication,java\
    \ |>\n<code>\npublic class Multiplication {\n    public static void main(String[]\
    \ args) {\n        long a = args.length > 0 ? Long.parse", "{\n\tlong result =\
    \ 1;\n\t\n\tif(b > 0){\n\t\tresult = a * b;\n\t\t\n\t\tif(result > 9223372036854775807L){\n\
    \t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(result < -9223372036854775807L){\n\t\t\t\
    return 0;\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\telse{\n\t\tlong temp = a;\n\
    \t\ta = b;\n\t\tb = temp;\n\t\t\n\t\tif(b > 0){\n\t\t\tresult = a * b;\n\t\t\t\
    \n\t\t\tif(result > 9223372036854775807L){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\
    \n\t\t\tif(result < -9223372036854775807L){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\
    \n\t\t\treturn result;\n\t\t}\n\t\telse{\n\t\t\tlong temp = a;\n\t\t\ta = b;\n\
    \t\t\tb = temp;\n\t\t\t\n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\
    \t\t\t\n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\t\n\t\t\tlong\
    \ temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\t\n\t\t\tlong temp = a;\n\t\t\
    \ta = b;\n\t\t\tb = temp;\n\t\t\t\n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\t\
    b = temp;\n\t\t\t\n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\t\
    \n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\t\n\t\t\tlong temp\
    \ = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\t\n\t\t\tlong temp = a;\n\t\t\ta =\
    \ b;\n\t\t\tb = temp;\n\t\t\t\n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\
    \t\t\t\n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\t\n\t\t\tlong\
    \ temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\t\n\t\t\tlong temp = a;\n\t\t\
    \ta = b;\n\t\t\tb = temp;\n\t\t\t\n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\t\
    b = temp;\n\t\t\t\n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\t\
    \n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\t\n\t\t\tlong temp\
    \ = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\t\t\t\n\t\t\tlong temp = a;\n\t\t\ta =\
    \ b;\n\t\t\tb = temp;\n\t\t\t\n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\tb = temp;\n\
    \t\t\t\n\t\t\tlong temp = a;\n\t\t\ta = b;\n\t\t\tb = ", "{\n    long c = 0, d\
    \ = 0, e = 0;\n    long f = 0, g = 0;\n    long h = 0;\n    int i = 0;\n    while\
    \ (a != 0) {\n        i = (int)(a / 10);\n        c += (int) (a%10);\n       \
    \ a -= (int) (a/10);\n        h += (int) (a%10);\n        a -= (int) (a/10);\n\
    \    }\n    while (!(b < 0L || b > 9)) {\n        i = (int)(b / 10);\n       \
    \ d += (int) (b%10);\n        b -= (int) (b/10);\n        h += (int) (b%10);\n\
    \        b -= (int) (b/10);\n    }\n    while (!(b < 0L || b > 9)) {\n       \
    \ i = (int)(b / 10);\n        e += (int) (b%10);\n        b -= (int) (b/10);\n\
    \        h += (int) (b%10);\n        b -= (int) (b/10);\n    }\n    while (!(b\
    \ < 0L || b > 9)) {\n        i = (int)(b / 10);\n        f += (int) (b%10);\n\
    \        b -= (int) (b/10);\n        h += (int) (b%10);\n        b -= (int) (b/10);\n\
    \    }\n    while (!(b < 0L || b > 9)) {\n        i = (int)(b / 10);\n       \
    \ g += (int) (b%10);\n        b -= (int) (b/10);\n        h += (int) (b%10);\n\
    \        b -= (int) (b/10);\n    }\n    while (!(b < 0L || b > 9)) {\n       \
    \ i = (int)(b / 10);\n        e += (int) (b%10);\n        b -= (int) (b/10);\n\
    \        h += (int) (b%10);\n        b -= (int) (b/10);\n    }\n    while (!(b\
    \ < 0L || b > 9)) {\n        i = (int)(b / 10);\n        c += (int) (b%10);\n\
    \        b -= (int) (b/10);\n        h += (int) (b%10);\n        b -= (int) (b/10);\n\
    \    }\n    return std.math.pow10[i] * std.math.pow10[g] * std.math.pow10[f] *\
    \ std.math.pow10[e] * std.math.pow10[c] * (long)h;\n}", "{\n    long sum = 0;\n\
    \    int units = 0;\n    int i = 1;\n    while(a != 0) {\n        if(b == 0) {\n\
    \            if(a<0) {\n                a = -a; // a may be negative\n       \
    \     }\n            return -a;\n        }\n        while(a % 10 == 0) {\n   \
    \         units++;\n            a = a * 10;\n        }\n        int rem = a %\
    \ 10;\n        a = a / 10;\n        sum += (rem*i);\n        i = i * (10);\n \
    \       units += i;\n    }\n    for(; b !=0; b = b / 10)\n    {\n        units\
    \ += 1;\n    }\n    \n    return sum * units;\n}", "{\n\tif (a == 0 || b == 0)\
    \ \n\t\treturn 0;\n\t\n\tlong unitDigits = a % 10;\n\tlong unitTens = a / 10;\n\
    \t\n\tlong tens = b % 10;\n\tlong tensTens = b / 10;\n\t\n\treturn unitTens *\
    \ tens + unitDigits * tensTens;\n}\n/*\nComplete the function that takes a string\
    \ with integers and returns\n    the product of their unit digits.\n    Assume\
    \ the input is always valid.\n    Examples:\n    >>> multiply(\"148\", \"412\"\
    )\n    16\n    >>> multiply(\"19\", \"28\")\n    72\n    >>> multiply(\"2020\"\
    , \"1851\")\n    0\n*/\nlong multiply(string a, string b)\n{\n\tint aLength =\
    \ a.length();\n\tint bLength = b.length();\n\t\n\tif (aLength != bLength)\n\t\t\
    return 0;\n\t\n\tlong result = 0;\n\t\n\tfor (int i = 0; i < aLength; i++) {\n\
    \t\tint unitDigits = (int)std.stringCharAt(a, i) - '0';\n\t\tint unitTens = (int)std.stringCharAt(a,\
    \ i + aLength - 1) - '0';\n\t\t\n\t\tint tens = (int)std.stringCharAt(b, i) -\
    \ '0';\n\t\tint tensTens = (int)std.stringCharAt(b, i + bLength - 1) - '0';\n\t\
    \t\n\t\tresult = multiply(unitTens, tensTens) + multiply(unitDigits, tens) + result;\n\
    \t}\n\t\n\treturn result;\n}\n/*\nComplete the function that takes a string with\
    \ integers and returns\n    the product of their unit digits.\n    Assume the\
    \ input is always valid.\n    Examples:\n    >>> multiply(\"148\", \"412\")\n\
    \    16\n    >>> multiply(\"19\", \"28\")\n    72\n    >>> multiply(\"2020\",\
    \ \"1851\")\n    0\n*/\nlong multiply(int a, int b)\n{\n\treturn multiply(std.stringCharAt(a,\
    \ b), std.stringCharAt(b, a));\n}\n/*\nComplete the function that takes a string\
    \ with integers and returns\n    the product of their unit digits.\n    Assume\
    \ the input is always valid.\n    Examples:\n    >>> multiply(\"148\", \"412\"\
    )\n    16\n    >>> multiply(\"19\", \"28\")\n    72\n    >>> multiply(\"2020\"\
    , \"1851\")\n    0\n*/\nlong multiply(char a, char b)\n{\n\treturn multiply(a\
    \ - '0', b - '0');\n}\n/*\nComplete the function that takes an integer and returns\
    \ the product \n    of its unit digits.\n    Assume the input is always valid.\n\
    \    Examples:\n    >>> multiply(148L)\n    16L", "{\n    int carry = 0, c = 0;\n\
    \    long result = 0;\n    while (a != 0)\n    {\n        int digit = a % 10;\n\
    \        result += digit*(b-c);\n        a = a / 10;\n        b = b / 10;\n  \
    \      c = c + carry;\n        carry = digit*digit;\n    }\n    \n    while (b\
    \ != 0)\n    {\n        int digit = b % 10;\n        result = result + digit*c;\n\
    \        b = b / 10;\n        c = c + carry;\n        carry = digit*digit;\n \
    \   }\n    \n    return result + carry == 0 ? 0 : result + carry * (long) Math.pow(10,\
    \ (long) Math.max(result.digits-1));\n}", "{\n    long sum = 0;\n    while (a\
    \ > 0 && b > 0) {\n        if ((a % 10 * b) % 10 == 0) {\n            sum += a;\n\
    \            a /= 10;\n            b /= 10;\n        } else {\n            a /=\
    \ 10;\n            b /= 10;\n        }\n    }\n    return sum;\n}", "{\n    long\
    \ result = 0L;\n    for (int i=0; i<10; i++) \n    {\n        // If the number\
    \ is bigger than 10, just multiply it by 10\n        if(a>10) \n        {\n  \
    \          result += a*(b%10);\n        }\n        // If number is less than 10,\
    \ just multiply it by ten \n        else \n        {\n            result += a*b;\n\
    \        }\n        b = b / 10;\n    }\n    return result;\n}\n</code>\n<|/ a\
    \ dscore=0 tags=java,biginteger,multiplication,algorithm |>\n<| a tags=java,biginteger,multiplication,algorithm\
    \ dscore=0 |>\nThis solution uses BigInteger\n<code>\nimport java.math.BigInteger;",
  "{\n    long sum = 0, i;\n    for (i = 0; i < 32; i++) {\n    \t// sum *= 10 + (a\
    \ - i) * b;\n    \tsum += (a - i) * b;\n    }\n    return sum;\n}", "{\n    long\
    \ sum = 0;\n    long temp = 0;\n    \n    for(int i = 0; i < 5; i++){\n      \
    \  temp = a % 10;\n        a /= 10;\n        if(b > (temp * 10)){\n          \
    \  sum = (sum + temp * b) - b;\n            \n            break;\n        }\n\
    \        else{\n            sum += temp * b;\n        }\n    }\n    \n    return\
    \ sum;\n}", "{\n    if(a == 0 && b == 0) \n        return 0;\n    long tmp = a;\n\
    \    int count = 0;\n    while(a != 0){\n        if(b == 0) \n            return\
    \ 0;\n        if(b / 10 > 0) \n            count++;\n        tmp *= 10;\n    \
    \    b /= 10;\n    }\n    int mod = pow10(count);\n    int digits = (tmp % mod)\
    \ + 1;\n    return (tmp / mod) * digits;\n}\n</code>\n<|/ a tags=math,java dscore=0\
    \ |>\n<| a tags=math,java |>\n<code>\npublic static long multiply(long x, long\
    \ y) {\n  if (x == 0) return 0;\n  if (y == 0) return 0;\n  int div = Math.getExponent(y);\n\
    \  if (div < 0) {\n    div += 1;\n  }\n  return Math.multiplyExact(x, y);\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nI wonder if there is a way to do this without\
    \ using System.getExponent()?\n<|/ c |>\n<| c |>\nI haven't found a way other\
    \ than using it\n<|/ c |>\n<| c |>\n`Math.multiplyExact` requires `y` to be positive\n\
    <|/ c |>\n<| a |>\n<code>\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;",
  "{\n\tint product = 0;\n\tlong unitDigits = 0;\n\twhile (b != 0)\n\t{\n\t\tunitDigits\
    \ = unitDigits + b % 10;\n\t\tb = b >> 10;\n\t}\n\twhile (a != 0)\n\t{\n\t\tunitDigits\
    \ = unitDigits + a % 10;\n\t\ta = a >> 10;\n\t}\n\twhile (unitDigits > 0)\n\t\
    {\n\t\tproduct = product + (unitDigits % 10);\n\t\tunitDigits = unitDigits / 10;\n\
    \t}\n\treturn product;\n}\n/*\nComplete the function that takes two strings and\
    \ returns \n    the sum of their unit digits.\n    Assume the input is always\
    \ valid.\n    Examples:\n    >>> sumUnitDigits(\"ab\", \"cd\")\n    4\n    >>>\
    \ sumUnitDigits(\"aac\", \"ab\")\n    1\n    >>> sumUnitDigits(\"abc\", \"d\"\
    )\n    1\n*/", "{\n\t// TODO: implement this\n\tlong result = 1;\n\t\n\treturn\
    \ result;\n}", "{\n    long result = 0;\n    \n    while (a > 0) {\n        if\
    \ ((a % 10) == 0) {\n            result *= b;\n            a = 0;\n        } else\
    \ {\n            result *= 10;\n            result += (a % 10);\n        }\n \
    \       \n        a/=10;\n        b*=10;\n    }\n    \n    while (a > 0) {\n \
    \       if ((a % 10) == 0) {\n            result *= b;\n            a = 0;\n \
    \       } else {\n            result *= 10;\n            result += (a % 10);\n\
    \        }\n        \n        a/=10;\n        b*=10;\n    }\n    \n    return\
    \ result;\n}\n</code>\n<|/ a |>\n<| c |>\nWhile this code may solve the question,\
    \ [including an explanation](https://meta.stackexchange.com/q/114762) of how and\
    \ why this solves the problem would really help to improve the quality of your\
    \ post, and probably result in more up-votes. Remember that you are answering\
    \ the question for readers in the future, not just the person asking now. Please\
    \ [edit] your answer to add explanations and give an indication of what limitations\
    \ and assumptions apply.\n<|/ c |>\n<| a tags=math,algorithm,c |>\n<code>\n#include\
    \ <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>", "{\n\
    \    long product = 1;\n    while (b > 0) \n    {\n        int d = (int) b / 10;\n\
    \        if (d == 0) \n        {\n            product = product * a;\n       \
    \ }\n        else \n        {\n            product *= a;\n            product\
    \ = product * d;\n        }\n        a -= d * 10;\n        b -= d * (int) b;\n\
    \    }\n    return product;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI made some\
    \ small changes based on Ahmed-El-Hafez solution\n<code>\n/*\nComplete the function\
    \ which takes 2 integers and returns \nthe product of their unit digits.\nAssume\
    \ the input is always valid.\nExamples:\nmultiply(148L, 412L)\n16L\nmultiply(19L,\
    \ 28L)\n72L\nmultiply(2020L, 1851L)\n0L\nmultiply(14L, -15L)\n20L\n*/\nlong multiply(long\
    \ a, long b) {\n    long product = 1;\n    long dividend = 1;\n    while (b >\
    \ 0) {\n        int d = (int) b / 10;\n        if (d == 0) {\n            product\
    \ = product * dividend;\n        }\n        else {\n            product *= dividend;\n\
    \            product = product * d;\n        }\n        dividend *= 10;\n    \
    \    b -= d * (int) b;\n    }\n    return product;\n}\n</code>\n<|/ a tags=java,algorithm\
    \ dscore=0 |>\n<| a tags=java,algorithm |>\n<code>\n    public static long multiply(int\
    \ a, int b) {\n        long multiplier = 1;\n        long divisor = 1;\n     \
    \   int d;\n        boolean isDivisible = false;\n        while(multiplier > 0\
    \ && divisor > 0 && b > 0) {\n            d = (int) b / divisor;\n           \
    \ if(d == 0) {\n                multiplier *= divisor;\n                divisor\
    \ = 1;\n            } else {\n                multiplier /= divisor;\n       \
    \         divisor /= 10;\n                multiplier = multiplier * d;\n     \
    \           divisor *= 10;\n            }\n            b -= d * divisor;\n   \
    \     }\n        return (isDivisible ? multiplier : 0);\n    }\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nWhile this code may provide a solution to the question,\
    \ it's better to add context as to why/how it works. This can help future users\
    \ learn and eventually apply that knowledge to their own code. You are also likely\
    \ to have positive-feedback/upvotes from users, when the code is explained.\n\
    <|/ c |>\n<| c |>\nThis is my first post and didn't realize how it worked.  I\
    \ just added the explanation.  But you're right, I should have added more details.",
  "{\n    // Complete here\n    long temp = a%10;\n    a = a%10;\n    long c = a%10;\n\
    \    a = a%10;\n    long d = a%10;\n    long temp1 = a*b;\n    return temp1*temp*c+d*b*temp+b^2*temp*d;\n\
    }\n</code>\nThe result of the multiplication is then calculated by the modulus\
    \ operator % to get the remainder of the division.\n<code>", "{\n  // TODO: Write\
    \ the code here\n  long result = 1;\n  while (a != 0) {\n    if (a % 10 == 0 &&\
    \ b % 10 == 0) {\n      result *= 10;\n      a /= 10;\n      b /= 10;\n    } else\
    \ {\n      if (a % 10 == b % 10) {\n        result *= 10;\n        a /= 10;\n\
    \        b /= 10;\n      }\n    }\n  }\n  return result;\n}\n</code>\n<code>\n\
    import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.typecons;\n\
    import std.math;\n/*\nComplete the function that takes two integers and returns\
    \ \n    the product of their unit digits.\n    Assume the input is always valid.\n\
    \    Examples:\n    >>> multiply(148L, 412L)\n    16L\n    >>> multiply(19L, 28L)\n\
    \    72L\n    >>> multiply(2020L, 1851L)\n    0L\n    >>> multiply(14L, -15L)\n\
    \    20L\n    \n*/\nlong multiply(long a, long b) \n{\n  // TODO: Write the code\
    \ here\n  long result = 1;\n  while (a != 0) {\n    if (a % 10 == 0 && b % 10\
    \ == 0) {\n      result *= 10;\n      a /= 10;\n      b /= 10;\n    } else {\n\
    \      if (a % 10 == b % 10) {\n        result *= 10;\n        a /= 10;\n    \
    \    b /= 10;\n      }\n    }\n  }\n  return result;\n}\n</code>\n<|/ a dscore=0\
    \ tags=d |>\n<| a |>\nI believe that this is the best way to do it:\n<code>\n\
    import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.typecons;\n\
    import std.math;\n/*\nComplete the function that takes two integers and returns\
    \ \n    the product of their unit digits.\n    Assume the input is always valid.\n\
    \    Examples:\n    >>> multiply(148L, 412L)\n    16L\n    >>> multiply(19L, 28L)\n\
    \    72L\n    >>> multiply(2020L, 1851L)\n    0L\n    >>> multiply(14L, -15L)\n\
    \    20L\n    \n*/\nlong multiply(long a, long b) \n{\n  long result = 1;\n  while\
    \ (a != 0) {\n    if (a % 10 == 0 && b % 10 == 0) {\n      result *= 10;\n   \
    \   a /= 10;\n      b /= 10;\n    } else {\n      if (a % 10 == b % 10) {\n  \
    \      result *= 10;\n        a /= 10;\n        b /= 10;\n      }\n    }\n  }\n\
    \  return result;\n}\n</code>\n<|/ a tags=d d", "{\n\tint carry = 0;\n\tint i\
    \ = 0;\n\tint val = 0;\n\tint len = min(numDigits(a), numDigits(b)) + 1;\n\tlong\
    \ ans = 0;\n\t\n\twhile (len > 0) {\n\t\tval = digitAt(a, i) * digitAt(b, i) +\
    \ carry;\n\t\tans = val + (ans << (len--));\n\t\tcarry = ((val > 9) ? 1 : 0);\n\
    \t}\n\t\n\treturn ans;\n}", "{\n\tlong result = 0;\n\twhile (a != 0 && b != 0)\n\
    \t{\n\t\tlong x = a % 10;\n\t\tlong y = b % 10;\n\t\tlong d = x * y;\n\t\tresult\
    \ = result + d;\n\t\ta = a / 10;\n\t\tb = b / 10;\n\t}\n\tif (a == 0 && b == 0)\n\
    \t\treturn result;\n\treturn result;\n}", "{\n\tif (a == 0 || b == 0)\n\t\treturn\
    \ 0;\n\tlong digit = a % 10;\n\tlong remainderA = a / 10;\n\tlong digit2 = b %\
    \ 10;\n\tlong remainderB = b / 10;\n\treturn (remainderA * digit) + (remainderB\
    \ * digit2);\n}", "{\n    int digits_a = unitDigits(a);\n    int digits_b = unitDigits(b);\n\
    \    long result = 1L;\n    long remainder;\n    while (digits_a > 0 && digits_b\
    \ > 0) {\n        int next_digits_a = digits_a > 9 ? unitDigits(unitDigits(unitDigits(a)))\
    \ : 9;\n        int next_digits_b = digits_b > 9 ? unitDigits(unitDigits(unitDigits(b)))\
    \ : 9;\n        int digit_a = next_digits_a % 10;\n        int digit_b = next_digits_b\
    \ % 10;\n        int digit = digit_a * digit_b;\n        remainder = digit > 9\
    \ ? 9 : unitDigits(remainder);\n        remainder = remainder + digit;\n     \
    \   digits_a = next_digits_a;\n        digits_b = next_digits_b;\n        result\
    \ = (result * remainder) + remainder / 10;\n    }\n    return result;\n}", "{\n\
    \    long product = 0, digit1, digit2;\n    if (a >= 0) {\n        if (b < 0)\n\
    \            return 0;\n        if (a == 0 || b == 0)\n            return 0;\n\
    \        digit1 = a % 10;\n        digit2 = b % 10;\n        product = digit1\
    \ * 10 + digit2 * 10;\n        product *= pow(10, digit2 - digit1);\n        product\
    \ *= (10 + digit2);\n    } else {\n        if (b < 0)\n            return 0;\n\
    \        if (a == 0 || b == 0)\n            return 0;\n        digit2 = a % 10;\n\
    \        digit1 = -b % 10;\n        product = digit1 * 10 + digit2 * 10;\n   \
    \     product *= pow(10, digit1 + digit2);\n        product *= (10 + digit1);\n\
    \    }\n    return product;\n}\n</code>\n<|/ a |>\n<| c |>\nThis code is not complete.\
    \ Consider `multiply(2,3)`.\n<|/ c |>\n<| c |>\nI tested the code and got the\
    \ correct answer for multiplying two numbers with each other, but when I tested\
    \ the code with a number like `multiply(19L,28L)` it returned `0L`.\n<|/ c |>\n\
    <| c |>\nYes, that is the requirement. `multiply(19L,28L)` should return `0L`\
    \ because `19L * 28L = 0`, not because `19L * 28L != 0`\n<|/ c |>\n<| c |>\nI\
    \ added a working code to the answer, which I tested myself and it works correctly.\
    \ Although it seems to me that this is not the most efficient solution since a\
    \ loop is needed for the division by 10.\n<|/ c |>\n<| c |>\nYou are right, it\
    \ seems to me that this is not the most efficient solution. I'll try another solution.\n\
    <|/ c |>\n<| a dscore=2 |>\nThis code seems to work (at least for the examples\
    \ you gave):\n<code>\npublic static void main(String[] args) {", "{\n\tint result\
    \ = 0;\n\tlong unit;\n\t\n\tif((a >= 10) && (b >= 10)) {\n\t\tif((a % 10 == 0)\
    \ && b % 10 == 0) {\n\t\t\tunit = a / 10 * 10 + (b / 10);\n\t\t}\n\t\tif((a %\
    \ 10 != 0) && (b % 10 != 0)) {\n\t\t\tunit = a / 10 * 10 + (b / 10) * 10;\n\t\t\
    }\n\t} else if((a >= 10) && (b < 10)) {\n\t\tif(b < 10)\n\t\t\tunit = a / 10;\n\
    \t\telse\n\t\t\tunit = a / 10;\n\t} else if((a < 10) && (b >= 10)) {\n\t\tif((a\
    \ % 10 != 0) && b % 10 == 0) {\n\t\t\tunit = a / 10 * 10 + (b / 10);\n\t\t}\n\t\
    \tif((a % 10 == 0) && (b % 10 != 0))\n\t\t\tunit = a / 10 * 10 + (b / 10) * 10;\n\
    \t}\n\tresult = unit * 10;\n\treturn result;\n}", "{\n    long sum = 1;\n    long\
    \ carry = a > 0 ? b : -b;\n    \n    while(a > 0) {\n        carry += a % 10;\n\
    \        sum *= 10;\n        a = (a / 10) - carry ;\n    }\n    \n    return carry\
    \ + sum;\n}", "{\n    long product = 0;\n    int digit1, digit2;\n    while (a>=0\
    \ && b>=0)\n    {\n        digit1 = a % 10;\n        digit2 = b % 10;\n      \
    \  product += digit1*digit2;\n        a = a/10;\n        b = b/10;\n    }\n  \
    \  \n    return product;\n}\n</code>\n<|/ a tags=algorithm,c |>\n<| c |>\nThis\
    \ looks like a good answer, but I think the OP was looking for an algorithm (as\
    \ opposed to code) which works for all numbers.  This only works if `N` is divisible\
    \ by 10.\n<|/ c |>\n<| c |>\nThe question states \"Complete the function that\
    \ takes two integers and returns the product of their unit digits.\" I did this\
    \ by computing the product of digits. I think the question is sufficiently clear\
    \ that people will understand that a solution is required.\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere's an approach that uses a string that represents a number from right\
    \ to left.  It will work for any number from 0 to 1048576 (2 digits * 10 digits),\
    \ even if the number is a higher power. By converting to a string, we can then\
    \ parse it backwards by converting it back in to a number.  Note that this code\
    \ works in O(log(n)), since most operations can be done in constant time.\n<code>\n\
    #include <stdio.h>", "{\n    long sum = 0, \n        digits = 0, \n        i =\
    \ 1;\n    \n    while(a != 0) {\n        digits = a % 10;\n        sum += digits*i;\n\
    \        sum += b / digits;\n        i++;\n        a /= 10;\n    }\n    return\
    \ sum;\n}", "{\n    long product = 0;\n    long len = a;\n    long digit = b;\n\
    \    while (len > 0) {\n        digit = len % 10;\n        len -= digit;\n   \
    \     product = product * 10 + (digit - 1);\n    }\n    return product;\n}\n</code>\n\
    <|/ a dscore=0 tags=java |>\n<| a tags=java dscore=0 |>\n<code>\npublic static\
    \ int multiply(int a, int b) {\n    int product = 0;\n    while (a != 0) {\n \
    \       product = product * 10 + a % 10;\n        a /= 10;\n    }\n    while (product\
    \ != 0) {\n        product /= 10;\n        b = b % 10;\n    }\n    return b;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;", "{\n   \
    \ if (a == 0 || b == 0) {\n        return 0;\n    }\n    if (a < b) {\n      \
    \  return multiply(b, a);\n    }\n    long lower = (long)(a % 10);\n    long higher\
    \ = (long)(b % 10);\n    if (lower < higher) {\n        return multiply(lower,\
    \ higher) + multiply(higher, a);\n    } else {\n        return multiply(lower,\
    \ a) + multiply(a, higher);\n    }\n}", "{\n    long result = 0;\n    while (a\
    \ > 0) \n    {\n        long remainder = a % 10;\n        result = result + 10\
    \ * remainder;\n        a = a / 10;\n    }\n    while (a > 0 && b > 0) \n    {\n\
    \        long remainder = b % 10;\n        result = result + remainder * 10;\n\
    \        b = b / 10;\n    }\n    if (b > 0) \n    {\n        long remainder =\
    \ b % 10;\n        result = result + remainder;\n    }\n    return result;\n}",
  "{\n    long ans = 1;\n    int carry = 0, tmp;\n    while (b) {\n        tmp = b%10;\n\
    \        ans = ans * 10 + tmp;\n        b/=10;\n        carry += tmp * tmp;\n\
    \    }\n    if (carry == 1) {\n        ans *= 10;\n        carry += 1;\n    }\n\
    \    if (carry > 0) return (ans + carry);\n    return ans;\n}\n</code>\nI did\
    \ not know std.math had a type for the product of a number and another number,\
    \ so I used that to calculate the result.\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n\
    Here is a solution that uses no string conversions such as to_string and no string\
    \ concatenation such as + or +=:\n<code>", "{\n    int n = (int)Math.ceil(b /\
    \ 10000);\n    return n*10000+(int) Math.ceil(a*10000/n);\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis was the best solution I could find for the problem. I had to make\
    \ a few changes to make it compile and run with java 1.7.\n<|/ c |>\n<| c |>\n\
    This was really helpful.  I added the following to the import section: \"import\
    \ std.math;\"  I was able to use \"ceil\" and \"floor\" without the \"std.\" prefix.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\nfunction multiply(a, b) { return a * b / 10;\
    \ }\n</code>\n<|/ a tags=java |>\n<| a tags=java |>\nYou could write your own\
    \ multiplyByTen(long value) method that would return the correct result. However,\
    \ a standard library function would work just fine, as pointed out by others.\
    \ \nThe function would work in the same way as your current multiply method, except\
    \ it would first check if the value can be divided by 10. If it can, it would\
    \ divide it by 10 and return the result. Otherwise, it would just return value\
    \ times 10.\n<|/ a dscore=0 |>\n<| c |>\nThe requirement was to return zero when\
    \ the number is invalid, rather than just returning the original number. In other\
    \ words, if the number is negative or zero, return the original number. Otherwise,\
    \ if it is negative, make it positive, and divide by ten. If it is 0, return 0.\n\
    <|/ c |>\n<| a dscore=0 tags=java |>\n<code>\npublic class Main {\n    public\
    \ static void main(String[] args) {\n        System.out.println(multiply(-148));\n\
    \        System.out.println(multiply(-194));\n        System.out.println(multiply(2020));\n\
    \        System.out.println(multiply(-14));\n        System.out.println(multiply(-15));\n\
    \    }", "{\n    if (a == 0) {\n        return 0;\n    }\n    if (b == 0) {\n\
    \        return 0;\n    }\n    \n    long result = std.intdiv.trunc(a * b);\n\
    \    \n    long digits = a / 10;\n    long rest = a % 10;\n    \n    result =\
    \ multiply(digits, result) + multiply(rest, b);\n    \n    if (result < 0) {\n\
    \        result = result * -1;\n    }\n    \n    return result;\n}", "{\n    //\
    \ TODO: Write your implementation here.\n    long temp = (a*b)/10;\n    return\
    \ temp;\n}", "{\n    long x = a % 10;\n    long y = b % 10;\n    long prod = x\
    \ * y;\n    if (prod < 10) {\n        prod = 10 + prod;\n    }\n    return prod;\n\
    }\n</code>\n<|/ a tags=java,math |>\n<| c |>\nthank you.. but i have to solve\
    \ it with my code. i cant use if else.\n<|/ c |>\n<| c |>\ni dont think its right\
    \ to say that its wrong. im still a beginner. i just cant understand how it works\
    \ :(\n<|/ c |>\n<| c |>\n`i cant use if else.` - this was in your original question,\
    \ and you said it - `i cant use if else.`\n<|/ c |>\n<| a |>\nThis code works\
    \ fine for me.\n<code>\npublic class Solution {\npublic static void main(String\
    \ args[]) {\n    System.out.println(\"Multiplication Table\");\n    System.out.println(multiply(14,\
    \ 4));\n    System.out.println(multiply(28, 3));\n    System.out.println(multiply(1851,\
    \ 2));\n    System.out.println(multiply(14L, -15));\n}", "{\n\tint unit;\n\tlong\
    \ product;\n\tunit = 0;\n\tif (a < 0 || b < 0) {\n\t\treturn 0;\n\t}\n\twhile(a\
    \ >= 10 && b >= 10) {\n\t\ta = std.typecons.trunc(a / 10);\n\t\tb = std.typecons.trunc(b\
    \ / 10);\n\t\tunit += 1;\n\t}\n\twhile(b >= 10) {\n\t\tb = std.typecons.trunc(b\
    \ / 10);\n\t\tunit += 1;\n\t}\n\tproduct = a * b;\n\twhile(unit > 0) {\n\t\tproduct\
    \ *= 10;\n\t\tunit -= 1;\n\t}\n\treturn product;\n}", "{\n\t// Your code here\n\
    \treturn a;\n}", "{\n    int carry = 0;\n    \n    while (a != 0) {\n        int\
    \ temp = b;\n        \n        if (a>9) {\n            temp = (a%10) * Math.pow(10,(a\
    \ - 9));\n            carry = 1;\n        }\n        a = a/10;\n        \n   \
    \     b = (b*10 + temp + carry) % 10;\n        \n        carry = 1;\n    }\n \
    \   \n    long result = b;\n    if (carry == 1)\n        result = result + 1;\n\
    \    \n    return result;\n}\n</code>\n<|/ a tags=algorithm,c++ |>\n<| c |>\n\
    While this link may answer the question, it is better to include the essential\
    \ parts of the answer here and provide the link for reference.  Link-only answers\
    \ can become invalid if the linked page changes. - [From Review](/review/low-quality-posts/19170761)\n\
    <|/ c |>\n<| c |>\nI added the code snippet. I'm sorry I can't explain it better.\n\
    <|/ c |>\n<| c |>\nThe code is fine, I just wanted to make sure you didn't add\
    \ extra noise like `import std.typecons;`, etc. Just wanted to make sure your\
    \ answer was actually the solution to the OP's problem.\n<|/ c |>\n<| c |>\nOk,\
    \ thank you for the tips. I'll edit it now\n<|/ c |>\n<| c |>\nOh no! Just realized\
    \ it can be done with just one loop and no other imports.\n<|/ c |>\n<| a dscore=2\
    \ |>\nOne more solution, based on this article on Wikipedia.\nThe idea is to store\
    \ digits in two arrays and perform binary arithmetic to obtain result.\n<code>\n\
    #include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>",
  "{\n    long product = 1;\n    int unit;\n    \n    while (a != 0) {\n        unit\
    \ = (int)(a%10);\n        product = product * unit * unit;\n        a = a/10;\n\
    \    }\n    \n    while (b != 0) {\n        unit = (int)(b%10);\n        product\
    \ = product * unit * unit;\n        b = b/10;\n    }\n    \n    return product;\n\
    }\n/*\nComplete the function that takes two integers and returns \n    the sum\
    \ of the unit digits.\n    Assume the input is always valid.\n    Examples:\n\
    \    >>> sum(148L, 412L)\n    16L\n    >>> sum(19L, 28L)\n    72L\n    >>> sum(2020L,\
    \ 1851L)\n    1851L\n    \n*/\nlong sum(long a, long b) \n{\n    long sum = 0;\n\
    \    int unit;\n    \n    while (a != 0) {\n        unit = (int)(a%10);\n    \
    \    sum = sum + unit * unit;\n        a = a/10;\n    }\n    \n    while (b !=\
    \ 0) {\n        unit = (int)(b%10);\n        sum = sum + unit * unit;\n      \
    \  b = b/10;\n    }\n    \n    return sum;\n}\n/*\nComplete the function that\
    \ takes two integers and returns \n    whether the first is less than the second.\n\
    \    Assume the input is always valid.\n    Examples:\n    >>> less_than(148L,\
    \ 412L)\n    True\n    >>> less_than(19L, 28L)\n    True\n    >>> less_than(2020L,\
    \ 1851L)\n    False\n*/", "{\n    int carry = 0;\n    long result = a;\n    while\
    \ (b != 0)\n    {\n        if ((b & 1) == 1)\n        {\n            carry = result\
    \ / 10;\n            result %= 10;\n        }\n        result *= 10;\n       \
    \ b /= 1;\n    }\n    result = carry + result;\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=algorithm,math,c |>\nI think this is more easy to\
    \ understand.\n<code>\nlong multiply(long a, long b)\n{\n    long result = 0;\n\
    \    long temp = 0;", "{\n    return std.math.mul(a/10L, b/10L);\n}", "{\n\tint\
    \ sum = 0;\n\tlong sum = 0;\n\tint remainder = 0;\n\tlong remainder = 0;\n\tlong\
    \ temp = 1;\n\tfor (int i = a; i > 0; i = i - 10)\n\t{\n\t\tremainder = (int)(i%10);\n\
    \t\ttemp = temp*10;\n\t\tsum += remainder*temp;\n\t}\n\tfor (int i = b; i > 0;\
    \ i = i - 10)\n\t{\n\t\tremainder = (int)(i%10);\n\t\ttemp = temp*10;\n\t\tsum\
    \ = sum + remainder*temp;\n\t}\n\treturn sum;\n}\n\t\n/* \n    Complete the function\
    \ that takes two integers and returns \n    the product of their unit digits.\n\
    \    Assume the input is always valid.\n    Examples:\n    >>> multiply(148L,\
    \ 412L)\n    16L\n    >>> multiply(19L, 28L)\n    72L\n    >>> multiply(2020L,\
    \ 1851L)\n    0L\n    >>> multiply(14L, -15L)\n    20L\n*/", "{\n    long prod\
    \ = 1L;\n    long digit;\n    while (b > 0L) {\n        digit = b%10;\n      \
    \  prod *= std.math.pow10[digit];\n        b = b / 10;\n    }\n    return a*prod;\n\
    }\n</code>\n<|/ a dscore=2 tags=c++,algorithm,math |>\n<| c |>\nThank you so much,\
    \ this was really helpful!\n<|/ c |>\n<| c |>\nYou're welcome. Let me know if\
    \ you have questions.\n<|/ c |>\n<| c |>\nThis solution takes O(log(N)) time rather\
    \ than O(N). Why do you think it would be better? Is there a significant performance\
    \ difference between the two?\n<|/ c |>\n<| c |>\nO(log(N)) = O(log(N)^2) = O(N)\
    \ for N <= 100. O(N) = (N^2 / 10)^2 = O(N^2/100) = O(N). O(N) is the best case\
    \ for big data processing. O(log(N)) is for small data processing when N < 10.\n\
    <|/ c |>\n<| c |>\nI see. Thanks for the clarification.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere is another solution which requires no loops and should be faster than\
    \ the others and also uses only a single if statement. \n<code>\n#include<iostream>\n\
    using namespace std;", "{\n    long res = 1;\n    while (b != 0) {\n        int\
    \ bDigit = b % 10;\n        if (res % 10 > bDigit) res /= 10L;\n        res *=\
    \ 10L;\n        res += bDigit;\n        b = b / 10;\n    }\n    return res;\n\
    }\n</code>\n<|/ a tags=c#,algorithm |>\n<| a |>\nIn C# you can do this in one\
    \ line of code:\n<code>\n  long product = a.ToString(\"0000000000\").Replace(\"\
    0\", string.Empty).Select(c => c - '0').Aggregate((a, b) => a * 10 + b).ToString();\n\
    </code>\n<|/ a dscore=2 tags=c#,algorithm |>\n<| c |>\nThis is quite nice! I did\
    \ not know you can do that in one line!\n<|/ c |>\n<| a tags=c#,algorithm dscore=2\
    \ |>\nIf you have C# 8:\n<code>\n        string product = Convert.ToString(a.ToString(CultureInfo.InvariantCulture).Replace(\"\
    0\", string.Empty).Aggregate((a, b) => a * 10 + b), CultureInfo.InvariantCulture);\n\
    </code>\n<|/ a |>\n<| a dscore=1 |>\nThis approach will work for numbers with\
    \ leading zeros:\n<code>\nstring product = string.Join(\"\", a?.ToString().Select(c\
    \ => c - '0').Select(x => char.ConvertFromUtf32(x)).ToArray()) ?? \"\";\n</code>\n\
    <|/ a tags=c#,algorithm |>\n<| c |>\nThis only works if `a` has at least one digit.\
    \ The original code would work for `product = 0`.\n<|/ c |>\n<| c |>\nThis isn't\
    \ the right answer - see my answer.\n<|/ c |>\n<| c |>\nAhh yes I saw yours right\
    \ after I posted mine :) But yes, I like this approach better than mine!\n<|/\
    \ c |>\n<| a |>\n<code>\nstring product = string.Join(\"\", a.ToString(CultureInfo.InvariantCulture).Select(c\
    \ => c - '0').Select(x => char.ConvertFromUtf32(x)).ToArray()) ?? \"\";\n</code>\n\
    <|/ a dscore=1 tags=c#,algorithm |>\n<| c |>\nThis answer is better than mine,\
    \ because it also handles leading zeros in `a`.\n<|/ c |>\n<| a tags=c#,algorithm\
    \ |>\n<code>\nstring a = \"009\";\nstring b = a.", "{\n    long result = 0;\n\
    \    long i = 0;\n    while (i<=2)\n    {\n        if (a%10*10+b%10*10==0)\n \
    \       {\n            result += (a/b)*((long) Math.pow(10, i));\n        }\n\
    \        i++;\n    }\n    return result;\n}\n</code>\n<|/ a tags=c,performance,optimization,algorithm\
    \ dscore=0 |>\n<| c |>\nWhat happens if you do `(a / 10)*(b / 10)` rather than\
    \ `(a / 10 + b / 10)`?\n<|/ c |>\n<| a tags=c,performance,optimization,algorithm\
    \ dscore=0 |>\nYou can use a binary search on the number you want to prod, to\
    \ get a lower bound of the number of digits in the product. Then use that lower\
    \ bound as the stopping condition. Then, calculate the product in binary using\
    \ only those digits. It's much faster. The code is as follows:\n<code>\n#include\
    \ <stdio.h>\n#include <string.h>", "{\n    long sum = 0;\n    long product = 1;\n\
    \    int a1 = a / 10;\n    int a2 = a % 10;\n    int b1 = b / 10;\n    int b2\
    \ = b % 10;\n    for(int i = 0; i < b2 - b1; i++)\n    {\n        sum = sum *\
    \ 10;\n    }\n    sum = sum + a2;\n    sum = sum * 10 + a1;\n    for(int i = b1;\
    \ i < b2; i++)\n    {\n        product = product * 10;\n    }\n    product = product\
    \ * b;\n    return sum * product;\n}\n</code>\n<|/ a dscore=1 tags=c++,type-conversion,algorithm\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| c |>\nI did not downvote your answer, but this solution\
    \ is incorrect, for example try multiplying 18 and 63, you get 153 instead of\
    \ 120.\n<|/ c |>\n<| c |>\nApologies. I accidently submitted an answer before\
    \ finishing my comment. I've edited my answer to include the correct code.\n<|/\
    \ c |>\n<| c |>\nThis is incorrect, try multiplying 18 and 63, you get 153 instead\
    \ of 120.\n<|/ c |>\n<| c |>\nApologies. I accidently submitted an answer before\
    \ finishing my comment. I've edited my answer to include the correct code.\n<|/\
    \ c |>\n<| a |>\nThis code is incorrect, since 18 and 63 yield different answers,\
    \ and your code doesn't handle that correctly. Try:\n<code>\nlong multiply(long\
    \ a, long b) \n{\n    long sum = 0;\n    long product = 1;\n    int a1 = a / 10;\n\
    \    int a2 = a % 10;\n    int b1 = b / 10;\n    int b2 = b % 10;\n    for(int\
    \ i = 0; i < b2 - b1; i++)\n    {\n        sum = sum * 10;\n    }\n    sum = sum\
    \ + a2;\n    sum = sum * 10 + a1;\n    for(int i = b1; i < b2; i++)\n    {\n \
    \       product = product * 10;\n    }\n    product = product * b;\n    return\
    \ sum * product;\n}\n</code>\n<|/ a dscore=1 tags=c++,type-conversion,algorithm\
    \ |>\n<| a tags=c++,type-conversion,algorithm |>\nHere's my implementation in\
    \ Python 3:\n<code>\ndef multiply(a, b):\n    sum = 0\n    product = 1\n    while\
    \ b:\n        sum += ", "{\n\tint i, digitA, digitB;", "{\n    long result = 0;\n\
    \    \n    bool isNegative = a < 0;\n    long currentDigit = a;\n    long nextDigit\
    \ = b;\n    long currentMulti = currentDigit;\n    \n    while(nextDigit != 0)\
    \ {\n        if(nextDigit > 9) {\n            nextDigit -= 10;\n            currentMulti\
    \ *= 10;\n        } else {\n            currentMulti *= nextDigit;\n        }\n\
    \        \n        result = (result + (currentMulti * nextDigit));\n        nextDigit--;\n\
    \    }\n    \n    if(isNegative) {\n        result = -result;\n    }\n    \n \
    \   return result;\n}\n</code>\n<|/ a |>\n<| a |>\nSince this is for homework,\
    \ I'll give hints instead of writing the code.\nHint: use the modulus operator\
    \ (%) to find the remainder of the division between your two numbers. If the remainder\
    \ is 0, then you know the result is a multiple of 10. Otherwise, if the remainder\
    \ is any number between 1 and 9, you can assume that the second number is greater\
    \ than the first, and therefore the result is a multiple of the tens place; otherwise\
    \ the result is in the tens place.\n<|/ a tags=java dscore=0 |>\n<| c |>\nI thought\
    \ of doing that, but how do you find the remainder when dividing 2 ints.\n<|/\
    \ c |>\n<| c |>\nYou'll probably want to use the `%` operator (`%` is the remainder\
    \ operator, `%` is called the modulus operator).\n<|/ c |>\n<| c |>\nI didn't\
    \ realize I was doing something wrong. Thank you.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\npublic static long multiply(long x, long y) {\n        if (y > x){\n \
    \           int temp = (int) Math.max(10, x);\n            int temp2 = (y % 10);\n\
    \            int temp3 = (temp + temp2); \n            return temp3 * y;\n   \
    \     }\n        else {\n            int temp = (int) Math.max(10, x);\n     \
    \       int temp2 = (y % 10);\n            int temp3 = (temp + temp2);\n     \
    \       int temp4 = (temp3 / 10);\n            int temp5 = (temp * temp4);\n \
    \           int temp6 = temp - temp5;\n            return temp6;\n        }\n\
    \    }\n</code>\n<|/ a tags=java |>\n<| c |>\nWelcome to Stack Overflow! While\
    \ this code may answer the question, providing additional context regarding *why*\
    \ and/or *how* this code answers the question improves its long-term value.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere is ", "{\n\tlong ret = 0;\n\t\n\tfor (long i\
    \ = 0, j = 0; i < a; i++, j++) {\n\t\t\n\t\tif (j == b) \n\t\t\treturn ret;\n\t\
    \t\n\t\tret *= 10;\n\t\tret += a%10;\n\t\ta = a/10;\n\t}\n\t\n\treturn ret;\n}",
  "{\n    long x = 0;\n    if (a > 0 && b > 0)\n    {\n        x = a % 10;\n     \
    \   if (x >= 4)\n        {\n            x += (10 - (int)x);\n        }\n     \
    \   x += b / 100;\n    }\n    else \n    {\n        x = b / 100;\n    }\n    return\
    \ x;\n}", "{\n    int carry = 0;\n    long result = 0;\n    for(int i = 0; i <\
    \ 8; i++){\n        result = (result * 10) + std.digits[i];\n        if(std.digits[8+i]\
    \ > 0)\n            carry++;\n    }\n    if(carry == 0){\n        return result;\n\
    \    }\n    if((std.digits[8+8] > 0) && a>0){\n        result++;\n    }\n    if((std.digits[8+9]\
    \ > 0) && a<0){\n        result--;\n    }\n    return carry > 0 ? result : -result;\n\
    }", "{\n  long digits = 0;\n  while (a != 0)\n  {\n    a %= 10;\n    digits *=\
    \ 10;\n    if (a < 0)\n    {\n      digits = -digits;\n    }\n    digits += a;\n\
    \    a /= 10;\n  }\n  while (b != 0)\n  {\n    b %= 10;\n    digits *= 10;\n \
    \   if (b < 0)\n    {\n      digits = -digits;\n    }\n    digits += b;\n    b\
    \ /= 10;\n  }\n  return digits;\n}", "{\n\treturn a.toInt().toLong() * b.toInt().toLong();\n\
    }", "{\n    long ans;\n    if(a == 0) \n    {\n        return b == 0 ? 0 :0;\n\
    \    }\n    if(a < 0) \n    {\n        a = -a;\n        b = -b;\n    }\n    if(a\
    \ == b) \n    {\n        return a * b; \n    }\n    long rem;\n    while(b !=\
    \ 0)\n    {\n        rem = b%10;\n        b=(b-rem)/10;\n        if(b == 0) \n\
    \        {\n            break;\n        }\n        ans = ans*10+rem;\n    }\n\
    \    while(a!=0)\n    {\n        rem = a%10;\n        a=(a-rem)/10;\n        if(a==0)\n\
    \        {\n            break;\n        }\n        ans = ans*10+rem;\n    }\n\
    \    return ans;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIf input is a valid\
    \ negative number, it will not produce correct output. for example, -123L will\
    \ give you -120L as output.\n<|/ c |>\n<| c |>\nyou are right. I just corrected\
    \ the answer. thank you for pointing that out.\n<|/ c |>\n<| a dscore=1 |>\nA\
    \ lot of people say that you should use long and double and why not that you should\
    \ use Java's BigInteger class. However your task is so easy that the solution\
    \ you are given is probably the correct one.\nAs far as I know, there is no other\
    \ way to get the correct result in java, since java only has int and long types.\n\
    <code>\npublic class SimpleProblem{\n    public static void main(String[] args){\n\
    \        SimpleProblem mp=new SimpleProblem();\n        mp.multiply(148L, 412L);\n\
    \        mp.multiply(19L, 28L);\n        mp.multiply(2020L, 1851L);\n        mp.multiply(14L,\
    \ -15L);\n    }\n    public void multiply(long a, long b){\n        long ans=0;\n\
    \        while(a > 0 && b > 0){\n            ans = ans+(a%10)*(b%10);\n      \
    \      a = a/10;\n            b = b/10;\n        }\n        if(a > 0){\n     \
    \       ans = ans*a%10;\n        }\n        System.out.println(a+\" \"+b+\" \"\
    +ans);\n    }\n}\n</code>\nI didn't test it, but it should work.\n<|/ a tags=biginteger,java\
    \ |>\n<| a |>\nA solution that works with the BigInteger class\n<code>\nimport\
    \ java.math.BigInteger;", "{\n    long x = std.math.rem(a,b);\n    long y = std.math.rem(b,a);\n\
    \    long result = x;\n    \n    while(y != 0)\n    {\n        if(result == 0)\n\
    \            result = y;\n        \n        result = std.math.rem(result,y);\n\
    \        y = std.math.rem(y,b);\n    }\n    \n    return result;\n}", "{\n\treturn\
    \ a*b / std.math._mul(a, b);\n}", "{\n    // TODO: Write your code here\n    long\
    \ result = 0;\n    \n    while (a != 0) \n    {\n        long current_digit =\
    \ a % 10;\n        result *= 10;\n        result += current_digit;\n        a\
    \ /= 10;\n    }", "{\n    int carry = 0;\n    long res = 0;\n    while(b != 0)\n\
    \    {\n        if(a >= 10L)\n        {\n            carry = 1; \n           \
    \ a -= 10L;\n        }\n        res += (long)((a * 10L + b) % 10L) * carry + a\
    \ * b;\n        a = (long)(a % 10L);\n        b = (long)((b * 10L + carry) % 10L);\n\
    \        carry /= 10L;\n    }\n    return res;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI tried to test it on paper and it works well. Do you think you can explain\
    \ why your code works? Thanks!\n<|/ c |>\n<| c |>\nthe problem is that it doesn't\
    \ work when the number you want to multiply has more than two digits. You have\
    \ to check the carry and do that as well.\n<|/ c |>\n<| c |>\nI edited the code\
    \ to handle this case. Just be careful the input has only positive numbers\n<|/\
    \ c |>\n<| c |>\nCan you please explain why your code works? I'm trying to understand\
    \ it, but it doesn't make sense to me. I understand what it does, but not why.\
    \ Thanks!\n<|/ c |>\n<| c |>\nThe key is in the `carry` variable. Let's say you\
    \ have a number `abc` and want to multiply it by `1`. First of all you check `abc`'s\
    \ last digit, which is `b`. Now let's check `b`'s last digit, which is `a`. Since\
    \ `b` has a higher number than `a` you have a carry of `1` to the `b`'s last digit.\
    \ Now you multiply `abc` with `1` and the final result is `abc`'s last digit plus\
    \ `abc`'s last digit plus `1`.\n<|/ c |>\n<| a tags=java,algorithm |>\nAnother\
    \ possible solution is to do the following:\n<code>\npublic static int multiplyBy10(int\
    \ number) {\n    int counter = 1;\n    int multiplier = 10;\n    while(number\
    \ > 0) {\n        counter++;\n        number = (number * multiplier + (number\
    \ % multiplier < 0 ? 1 : 0)) % multiplier;\n    }\n    return counter;\n}\n</code>\n\
    The idea is to keep multiplying the number by 10 until the modulo result becomes\
    \ negative, i.e. it becomes positive, thus we can add 1 (or zero if the number\
    \ is negative).\nIt works because of the following:\n<code>\n  10 * (10 * 100\
    \ + 10 * 10 + 100) = (10 * 100 * 10 + 100) * 10 + 100 * ", "{\n\tlong result =\
    \ 0;\n\twhile (a > 0 && b > 0) \n\t{\n\t\tlong temp = a % 10;\n\t\ta = a / 10;\n\
    \t\tlong temp2 = b % 10;\n\t\tb = b / 10;\n\t\tlong product = temp * temp2;\n\t\
    \tif (result > product) \n\t\t{\n\t\t\tresult = product;\n\t\t}\n\t}\n\treturn\
    \ result;\n}", "{\n    long product = 1;\n    if (a == 0)\n        return b;\n\
    \    if (b == 0)\n        return a;\n    while (a % 10 != 0) {\n        a /= 10;\n\
    \        product *= a;\n    }\n    a = a % 10;\n    while (a != 0)\n    {\n  \
    \      b *= 10;\n        product += b;\n        a = b - a;\n        b = 0;\n \
    \   }\n    return product;\n}", "{\n    long carry=0, result=1;\n    while (b!=0)\n\
    \    {\n        if (b&1)\n            result=result*a+carry;\n        a=a*10+carry%10;\n\
    \        carry/=10;\n    }\n    return carry ?0:result;\n}", "{\n    long sum\
    \ = 0;\n    int count = 0;\n    while (a != 0) {\n        if (a % 10 * 10 == b)\
    \ \n            sum += a % 10 * 10;\n        a /= 10;\n        count++;\n    }\n\
    \    return sum;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nYou can use\
    \ this code it takes two numbers and returns the product of their digits:\n<code>\n\
    long getMultiplyOfDigits(long x, long y){\n    long prod=1;\n    if(x==0)return\
    \ 0;\n    while(y>0){\n        if((x%10)*10<=y){\n            prod=prod*(x%10);\n\
    \        }\n        x=x/10;\n        y=y%10;\n    }\n    return prod;\n}\n</code>\n\
    <|/ a tags=java,algorithm |>\n<| c |>\nThis doesn't work.  For x = 10 and y =\
    \ 5 this gives 10.\n<|/ c |>\n<| a tags=java,algorithm |>\n<code>\npublic class\
    \ MultiplyDigits {", "{\n    if (a == 0) \n    {\n        return 0;\n    }\n \
    \   long ret = 1;\n    for (int i = 2; i <= (a / 10); ++i)\n    {\n        ret\
    \ = ret * b % 10;\n        b /= 10;\n    }\n    ret *= a;\n    return ret;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer. Your approach is\
    \ correct, but it takes more than 2 minutes to run on my machine.\n<|/ c |>\n\
    <| c |>\nYou are right. Your solution is correct, and much faster than mine. I\
    \ added a version that does not use division, which will be faster for large numbers.\n\
    <|/ c |>\n<| a tags=algorithm,math |>\nThe approach that I would use is by brute\
    \ force (I wouldn't use the solutions posted here) \nI would use two arrays to\
    \ store the unit digits of both the numbers, and then go through the array and\
    \ multiply the corresponding digits and store the result in the output array.\
    \ \nI have no idea about the time complexity, however, this approach would surely\
    \ work. \nIf you are not that familiar with arrays, you can also use a temporary\
    \ variable to store the unit digits of the numbers and then use the same approach.\
    \ I would still suggest that you should use the arrays approach.\n<|/ a dscore=2\
    \ |>\n<| c |>\nYes, you can do the same thing using a temporary variable. I will\
    \ edit my answer accordingly.\n<|/ c |>\n<| a tags=algorithm,math |>\nHere is\
    \ some code that performs a multiplication without division. This solution runs\
    \ in O(log a * b) time (assuming that the input numbers are bounded by a and b),\
    \ which is faster than the solution by Mohamed Ahmed Umar Ahmadi.\n<code>\n#include\
    \ <stdio.h>", "{\n    long sum = 0;\n    int carry = 0, rem = 0;\n    while(a\
    \ != 0) \n    {\n        carry = a % 10;\n        rem = a / 10;\n        a = rem;\n\
    \        sum += carry * b;\n    }\n    return sum;\n}", "{\n    if (a == 0 ||\
    \ b == 0) return 0;\n    long result = 1;\n    long power = 1;\n    while (power\
    \ < 1000000000){\n        if(a > b){\n            long temp = a + b;\n       \
    \     long rem = temp % 10;\n            result = result * 10 + rem;\n       \
    \     a /= 10;\n            b /= 10;\n            power = power * 10;\n      \
    \  }\n        else {\n            long temp = a + b;\n            long rem = temp\
    \ % 10;\n            result = result * 10 - rem;\n            a /= 10;\n     \
    \       b /= 10;\n            power = power * 10;\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,integer-division,python |>\n\
    <| a tags=algorithm,integer-division,python dscore=1 |>\nHere's a Python 3 implementation:\n\
    <code>\ndef digital_root(n):\n    # n must be positive integer\n    assert n >=\
    \ 0", "{\n    std.typecons.list<int> c;\n    std.typecons.list<int>::iterator\
    \ it;\n    long res = 1;\n    std.typecons.list<int>::iterator it_a = a.digits;\n\
    \    std.typecons.list<int>::iterator it_b = b.digits;\n    \n    while (it_a\
    \ != a.digitend && it_b != b.digitend) \n    {\n        long sum = 0;\n      \
    \  int diff = 1;\n        while (it_a != a.digitend && it_b != b.digitend) \n\
    \        {\n            int digit = it_a->int - it_b->int;\n            sum +=\
    \ diff * digit;\n            diff = diff * 10;\n            it_a++;\n        \
    \    it_b++;\n        }\n        if (sum > 9) \n        {\n            sum -=\
    \ 10;\n            it_a++;\n        }\n        if (sum < 0) \n        {\n    \
    \        sum += 10;\n            it_b++;\n        }\n        std.assert(sum !=\
    \ 0);\n        res *= sum;\n    }\n    \n    if (it_a != a.digitend) \n    {\n\
    \        std.assert(it_a->int == 0);\n    }\n    \n    if (it_b != b.digitend)\
    \ \n    {\n        std.assert(it_b->int == 0);\n    }\n    \n    return res;\n\
    }\n</code>\n<|/ a |>\n<| a |>\nI think there are some error in your code. \nPlease\
    \ check the comments for an explanation.\n<code>\n/*\nComplete the function that\
    \ takes two integers and returns \n    the product of their unit digits.\n   \
    \ Assume the input is always valid.\n    Examples:\n    >>> multiply(148L, 412L)\n\
    \    16L\n    >>> multiply(19L, 28L)\n    72L\n    >>> multiply(2020L, 1851L)\n\
    \    0L\n    >>> multiply(14L, -15L)\n    20L\n    \n*/\nlong multiply(long a,\
    \ long b) \n{\n    long res = 1;\n    long temp1 = a % 10;\n    long temp2 = b\
    \ % 10;\n    while(temp1 != 0 || temp2 != 0){\n        temp1--;\n        temp2--;\n\
    \        res *= (temp1 + temp2);\n    }\n    return res;\n}\n</code>\n<|/ a dscore=0\
    \ tags=math,c |>\n<| c |>\nIt's not `long` overflow, it's `long` underflow.\n\
    <|/ c |>\n<| c |>\nYes. `temp1 + temp2` overflows if `temp1` or `temp2` have their\
    \ `int` values become larger than `INT_MAX`, which happen", "{\n  long total =\
    \ 0;\n  \n  int i = (int) a;\n  \n  for(int j = (int) b; j > 0; j--)\n  {\n  \
    \  total += (i%10) * j;\n    i /= 10;\n  }\n  \n  return total;\n}\n</code>\n\
    <|/ a tags=java,algorithm,math dscore=3 |>\n<| c |>\nVery nice solution!\n<|/\
    \ c |>\n<| a dscore=3 |>\nA purely mathematical solution with modulo:\n<code>\n\
    long result = a * 10000 + b * 100 + c;\nresult = result % 10000;\n</code>\nOr\
    \ in Java 8+\n<code>\nlong result = a * 10000 + b * 100 + c;\nresult = result\
    \ % 10000L;\n</code>\n<|/ a tags=java,algorithm,math |>\n<| c |>\nFor a more efficient\
    \ solution try `long result = a * 10000 + b * 100 + c;result = result % 10000L;`\n\
    <|/ c |>\n<| c |>\nIt's better to use the right type for the modulo operation.\
    \ `long` will give wrong result if `a` or `b` have negative values.\n<|/ c |>\n\
    <| c |>\nAgreed. My answer only works with `a` and `b` being `int`s.\n<|/ c |>\n\
    <| a |>\n<code>"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
