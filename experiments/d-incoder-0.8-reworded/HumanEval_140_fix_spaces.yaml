name: HumanEval_140_fix_spaces
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given a string text, replace\
  \ all spaces in it with underscores, \n    and if a string has more than 2 consecutive\
  \ spaces, \n    then replace all consecutive spaces with - \n    \n    >>> fix_spaces(\"\
  \ Example\")\n    \"Example\"\n    >>> fix_spaces(\" Example 1\")\n    \"Example_1\"\
  \n    >>> fix_spaces(\" Example 2\")\n    \"_Example_2\"\n    >>> fix_spaces(\"\
  \ Example 3\")\n    \"_Example-3\"\n    \n*/\nstring fix_spaces(string text) \n"
tests: "unittest\n{\n    alias candidate = fix_spaces;\n\n    assert(candidate(\"\
  Example\") == \"Example\");\n    assert(candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\"\
  );\n    assert(candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\"\
  );\n    assert(candidate(\"Exa   mple\") == \"Exa-mple\");\n    assert(candidate(\"\
  \   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\");\n}\nvoid main(){}"
completions: ["{\n    for(int i = 0; i < text.length(); i++)\n    {\n        if(text[i]\
    \ == ' ')\n        {\n            text[i] = '_';\n        }\n    }\n    for(int\
    \ i = 0; i < text.length(); i++)\n    {\n        if(text[i] == ' ' && \n     \
    \      i + 1 < text.length() && \n           text[i + 1] == ' ')\n        {\n\
    \            text[i + 1] = '-';\n        }\n    }\n    return text;\n}\n</code>\n\
    The first for loop converts all the spaces to underscores. \nThe second for loop\
    \ converts consecutive spaces to -.\n<|/ a dscore=0 |>\n<| a tags=string,c++ dscore=0\
    \ |>\n<code>\n#include <iostream>\n#include <string>\nusing namespace std;", "{\n\
    \    int i = 0;\n    int n = 0;\n    \n    while ((i < text.lenght) && (n < 2))\
    \ \n    {\n        if (isspace(text[i])) \n        {\n            i++;\n     \
    \       n++;\n        }\n        else \n        {\n            n = 1;\n      \
    \  }\n    }\n    \n    if (i > text.lenght) \n    {\n        text = \"\";\n  \
    \  }\n    else if (n == 2) \n    {\n        text = replace_all(text, \"  \", \"\
    _\");\n    }\n    \n    return text;\n}", "{\n    \n    string result = text;\n\
    \    \n    for(int i = 0; i < result.length(); i++) {\n        char c = result[i];\n\
    \        if (c == ' ') {\n            result[i] = '_';\n        }\n    }\n   \
    \ \n    int count = 0;\n    for(int i = 0; i < result.length(); i++) {\n     \
    \   if (result[i] == ' ') {\n            count++;\n        }\n        else {\n\
    \            if (count > 1) {\n                result.replace(i, i + 1, \"-\"\
    );\n            }\n            count = 0;\n        }\n    }\n    \n    return\
    \ result;\n}\n</cell>\n<text>\nImplement find_all_substrings", "{\n  if(text.size()>2)\
    \ return \"\";\n  \n  int len = text.size();\n  for(int i=0; i<len; i++)\n  {\n\
    \    if(text.at(i) == ' ')\n    {\n      text = text.substr(0,i) + \"_\" + text.substr(i+1);\n\
    \      len = len - 1;\n    }\n  }\n  return text;\n}", "{\n\tfor (size_t i = 0;\
    \ i < text.length(); i++) {\n\t\tchar c = text[i];\n\t\tif (c == ' ') \n\t\t\t\
    text[i] = '_';\n\t}\n\t\n\tsize_t i = 0;\n\tsize_t j = 0;\n\twhile (i < text.length())\
    \ {\n\t\tchar c = text[i];\n\t\tif (j != i && c == ' ' && j + 1 < text.length()\
    \ && text[j + 1] == c) \n\t\t\ttext[j] = '_';\n\t\ti++;\n\t\tj++;\n\t}\n\t\n\t\
    return text;\n}", "{\n  text = text.replaceAll(' ', '_');\n  if(text.indexOf('\
    \  ') != -1) \n    text = text.replaceAll('  ', '_');\n  return text;\n}\n</code>\n\
    <|/ a dscore=5 tags=c#,.net,string |>\n<| c |>\nHad to do this to eliminate `'\\\
    n'` line breaks from emails. Thanks!\n<|/ c |>\n<| c |>\nThank you for including\
    \ a link to my [FixSpaces method](http://stackoverflow.com/a/3654397/268093) I\
    \ wrote based on your code. It doesn't have the bug that would cause [TomTom to\
    \ not recognize email addresses as valid input](http://stackoverflow.com/a/3654397/268093).\n\
    <|/ c |>\n<| a dscore=5 |>\nJust for completeness, I find that these solutions\
    \ don't work well for UTF-8, since they use regular expressions, which do match\
    \ \"any character\", which means they also match accented characters and emojis.\n\
    Instead I recommend using TextInfo.ToTitleCase to convert a text to title case,\
    \ which is exactly what the asker is trying to accomplish.\n<|/ a tags=c#,.net,string\
    \ |>\n<| c |>\nThis also solved my problem which was converting a camel case string\
    \ to upper camel case (i.e. `ToTitleCase(\"helloWorld\")` -> `HelloWorld`).\n\
    <|/ c |>\n<| c |>\nThis was a lifesaver\n<|/ c |>\n<| c |>\nThis is great for\
    \ people who have non-English names, like \"John Smith\".\n<|/ c |>\n<| c |>\n\
    this doesn't work properly with non-English names such as \"M\xE4rcius Sch\xE4\
    fner\" which turns into \"M\xE4rcius Sch\xDFfner\"\n<|/ c |>\n<| c |>\n: Okay,\
    \ I added support for that (but it's just a small helper method).\n<|/ c |>\n\
    <| a dscore=5 |>\nIf you already have some code that is already working and you\
    \ want to improve it, the best way to improve it is to write a new method based\
    \ on it. \nFor example - \n<code>\n    private static string ConvertToSnakeCase(string\
    \ input)\n    {\n        string s = string.Empty;\n        char[] chars = input.ToCharArray();\n\
    \        for (int i = 0; i < chars.Length; i++)\n        {\n            if (chars[i].ToString()\
    \ != chars[i].ToUpper() && chars[i].ToString() != chars[i].ToLower())\n      \
    \      {\n                if (chars[i].ToString() == ", "{\n  int len = text.length();\n\
    \  for(int i = 0; i < len; i++) {\n    if(text[i] == ' ') {\n      text += '_';\n\
    \      i -= 1;\n    } else {\n      text += text[i];\n    }\n  }\n  if(len > 2)\
    \ {\n    for(int i = len-1; i > 2; i--) {\n      if(text[i] == ' ') {\n      \
    \  text += '-';\n      }\n    }\n  }\n  return text;\n}", "{\n    for(int i =\
    \ 0; i < text.length(); i++) {\n        if(text[i] == ' ') {\n            text\
    \ = text.substr(0, i) + \"_\" + text.substr(i + 1, text.length());\n        }\n\
    \    }\n    \n    int i = 0;\n    while(i < text.length() - 1) {\n        if(text[i]\
    \ == ' ' && text[i + 1] == ' ') {\n            string first = text.substr(0, i);\n\
    \            text = text.substr(0, i) + text.substr(i + 2, text.length());\n \
    \           text = text.substr(0, i) + first + \"_\" + text.substr(i + 1, text.length());\n\
    \            i += 2;\n        }\n        else \n            i++;\n    }\n    \n\
    \    return text;\n}\n/*", "{\n    string::iterator iter = text.begin();\n   \
    \ string::const_iterator end_iter = text.end();\n    \n    while(iter != end_iter\
    \ && isspace(*iter))\n        ++iter;\n    \n    string fixed = text;\n    \n\
    \    while(iter != end_iter && isspace(*iter))\n    {\n        *iter = '_';\n\
    \        ++iter;\n    }\n    \n    string::iterator end_iter_2 = text.end();\n\
    \    \n    while(iter != end_iter_2)\n    {\n        if(*iter != ' ')\n      \
    \  {\n            *iter = '-';\n        }\n        else\n        {\n         \
    \   ++iter;\n        }\n    }\n    \n    return fixed;\n}", "{\n    string replaced\
    \ = text;\n    replaced.replace(\"  \", \"_\");\n    replaced.replace(\"  \",\
    \ \"_\");\n    replaced = replaced.replace(\"  \", \"_\");\n    return replaced;\n\
    }", "{\n    // We do some extra checking for single spaces\n    if (!text.empty()\
    \ && isspace(text[0]))\n        return text;\n        \n    // If text is empty\
    \ or consists of only one space\n    if (text.empty() || text.length() == 1)\n\
    \        return text;", "{\n    stringstream ss(text);\n    string out;\n    char\
    \ c;\n    while (ss >> c)\n    {\n        if (c == ' ')\n        {\n         \
    \   out += '_';\n        }\n        else if (c == ' ' && out != '')\n        {\n\
    \            out += '-';\n        }\n        else\n        {\n            out\
    \ += c;\n        }\n    }\n    return out;\n}", "{\n    auto start = text.find_first_not_of(\"\
    \ \");\n    if (start != string::npos)\n        text.erase(start, text.find_first_of(\"\
    \ \", start));\n    if (text.find_first_of(\" \", string::npos) == string::npos)\n\
    \        text += \"-\";\n    return text;\n}", "{\n    size_t len = text.len();\n\
    \    size_t i = 0;\n    while(i < len) \n    {\n        if(text[i] == ' ')\n \
    \       {\n            text[i] = '_';\n        }\n        else if((text[i] ==\
    \ ' ') && (text[i+1] == ' '))\n        {\n            text[i] = '-';\n       \
    \ }\n        i++;\n    }\n    return text;\n}\n</code>\n<|/ a tags=string,replace,c++\
    \ |>\n<| c |>\nYou should add some explanations, don't you think?\n<|/ c |>\n\
    <| c |>\nI don't think you should add more explanations since this is already\
    \ pretty verbose.\n<|/ c |>\n<| a dscore=5 tags=string,replace,c++ |>\nMy solution:\n\
    <code>\n#include <algorithm>\n#include <iterator>\n#include <cctype>", "{\n  \
    \  const auto first_space = text.find_first_of(\" \");\n    const auto last_space\
    \ = text.find_last_of(\" \");\n    if(first_space == last_space) \n    {\n   \
    \     return text;\n    }\n    const auto len = text.length();\n    if(first_space\
    \ != string::npos && first_space != len-1)\n    {\n        return text.substr(0,\
    \ first_space) + text.substr(last_space+1);\n    }\n    if(first_space != string::npos\
    \ && first_space == len-1)\n    {\n        return text.substr(0, first_space);\n\
    \    }\n    return text;\n}", "{\n  string s = text;\n  for(int i = 0; i < s.length();\
    \ i++)\n  {\n    if(s[i] == ' ')\n    {\n      s[i] = '_';\n      for (int j =\
    \ i + 1; j < s.length(); j++)\n      {\n        if(s[j] == ' ')\n        {\n \
    \         s[j] = '-';\n        }\n      }\n    }\n  }\n  return s;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a dscore=2 |>\nHere is a simple JavaScript solution using\
    \ String.replace with a regex\n<code>\nfunction fixSpaces(str) {\n    return str.replace(/^\\\
    s+|\\s+$/g, \"\").replace(/\\s+/g, \"-\");\n}\n</code>\n<|/ a tags=replace,c++,space,string\
    \ |>\n<| a dscore=2 tags=replace,c++,space,string |>\nA similar solution which\
    \ works in C++:\n<code>\nstd::string myString = \"strings with multiple spaces\"\
    ;\nmyString.replace( std::regex(\"\\\\s+\"), std::string(\" \") );\n</code>\n\
    This would replace multiple spaces with a single space.\n<|/ a |>\n<| a |>\n<code>\n\
    std::string FixSpaces(std::string s) {\n    std::replace(s.begin(), s.end(), '\
    \ ', '-');\n    return s;\n}\n</code>\n<|/ a dscore=1 tags=replace,c++,space,string\
    \ |>\n<| a dscore=1 |>\nIn Java you can just use replaceAll(\" \",\"-\").\n<|/\
    \ a tags=replace,c++,space,string |>\n<| a dscore=1 |>\nThis simple solution in\
    \ C# works perfectly for me:\n<code>\nString str1 = \"hello world\";\nString str2\
    \ = str1.Replace(\" \", \"-\");\n</code>\n<|/ a tags=replace,c++,space,string\
    \ |>\n<| a tags=replace,c++,space,string |>\nIn C#:\n<code>\nstring str = \"strings\
    \ with multiple spaces\";\nstr=Regex.Replace(str, \" \", \"-\");\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=replace,c++,space,string |>\n<code>\n#include <iostream>\n\
    #include <string>", "{\n    while(text.len() > 2 && text.rfind(\"  \", 0) != string::npos)\
    \ {\n        text.erase(0, text.find(\"  \", 0));\n        text.insert(0, \"_\"\
    );\n    }\n    while(text.find(\" \", text.len() - 1) != string::npos && text.find(\"\
    \  \", text.len() - 1) != string::npos)\n        text.erase(text.find(\"  \",\
    \ text.len() - 1), text.len());\n    return text;\n}\nstring fix_spaces(string\
    \ text)\n{\n    while(text.find(\" \", text.len() - 1) != string::npos && text.find(\"\
    \  \", text.len() - 1) != string::npos)\n        text.erase(text.find(\"  \",\
    \ text.len() - 1), text.len());\n    return text;\n}", "{\n  // TODO: Implement\
    \ me!\n  return text;\n}", "{\n    int i;\n    int j;\n    string fixed_text;\n\
    \    int spaces = 0;\n    \n    // Replace spaces with underscores\n    for(i\
    \ = 0; i < text.size(); ++i)\n    {\n        if(text[i] == ' ')\n        {\n \
    \           fixed_text += text[i];\n            ++spaces;\n        }\n       \
    \ else\n        {\n            fixed_text += '_';\n            ++spaces;\n   \
    \     }\n    }\n    if(spaces < 2)\n        return text;\n    \n    // Replace\
    \ underscores with spaces\n    for(i = 0; i < text.size(); ++i)\n    {\n     \
    \   if(text[i] == '_')\n        {\n            fixed_text += text[i];\n      \
    \      ++spaces;\n        }\n        else\n        {\n            fixed_text +=\
    \ text[i];\n            ++spaces;\n        }\n    }\n    return fixed_text;\n}",
  "{\n  while(!text.endsWith(\" \"))\n  {\n    text = text.tail();\n  }\n  \n  int\
    \ text_len = text.length();\n  \n  while(text_len > 2 && text[text_len-2] == '\
    \ ')\n  {\n    text = text.tail();\n    text_len--;\n  }\n  \n  if(text_len >\
    \ 2)\n  {\n    int spaces_to_add = text_len - 2;\n    \n    while(spaces_to_add)\n\
    \    {\n      if(!text.endsWith(\" \"))\n      {\n        text = text.tail();\n\
    \      }\n      spaces_to_add--;\n    }\n  }\n  \n  return text;\n}", "{\n   \
    \ int i=0, j=0;\n    string fixed_text=text;\n    if (text.size()==0) return text;",
  "{\n    // TODO Make this more robust\n    int space_count = text.find_first_not_of(\"\
    \ \");\n    string result;", "{\n    string::iterator it = text.begin();\n   \
    \ \n    bool done = false;\n    string result = \"\";\n    \n    while (!done)\n\
    \    {\n        if (it == text.end()) \n        {\n            done = true;\n\
    \        }\n        else\n        {\n            result += *it;\n            ++it;\n\
    \        }\n        \n        if (it == text.end())\n        {\n            done\
    \ = true;\n        }\n        else\n        {\n            if (*it == ' ' && it\
    \ + 1 < text.end())\n            {\n                result += \"_\";\n       \
    \         ++it;\n            }\n            else\n            {\n            \
    \    result += *it;\n                ++it;\n            }\n        }\n    }\n\
    \    \n    return result;\n}", "{\n    string str = text;\n    map<string, int>\
    \ map;\n    map[\"  \"] = 1;\n    map[\"  \"] = 2;\n    map[\"  \"] = 3;\n   \
    \ map[\"  \"] = 4;\n    map[\"  \"] = 5;\n    map[\"  \"] = 6;\n    map[\"  \"\
    ] = 7;\n    map[\"  \"] = 8;\n    map[\"  \"] = 9;\n    map[\"  \"] = 10;\n  \
    \  map[\"  \"] = 11;\n    map[\"  \"] = 12;\n    map[\"  \"] = 13;\n    map[\"\
    \  \"] = 14;\n    map[\"  \"] = 15;\n    map[\"  \"] = 16;\n    map[\"  \"] =\
    \ 17;\n    map[\"  \"] = 18;\n    map[\"  \"] = 19;\n    map[\"  \"] = 20;\n \
    \   map[\"  \"] = 21;\n    map[\"  \"] = 22;\n    map[\"  \"] = 23;\n    map[\"\
    \  \"] = 24;\n    map[\"  \"] = 25;\n    map[\"  \"] = 26;\n    map[\"  \"] =\
    \ 27;\n    map[\"  \"] = 28;\n    map[\"  \"] = 29;\n    map[\"  \"] = 30;\n \
    \   map[\"  \"] = 31;\n    map[\"  \"] = 32;\n    map[\"  \"] = 33;\n    map[\"\
    \  \"] = 34;\n    map[\"  \"] = 35;\n    map[\"  \"] = 36;\n    map[\"  \"] =\
    \ 37;\n    map[\"  \"] = 38;\n    map[\"  \"] = 39;\n    map[\"  \"] = 40;\n \
    \   map[\"  \"] = 41;\n    map[\"  \"] = 42;\n    map[\"  \"] = 43;\n    map[\"\
    \  \"] = 44;\n    map[\"  \"] = 45;\n    map[\"  \"] = 46;\n    map[\"  \"] =\
    \ 47;\n    map[\"  \"] = 48;\n    map[\"  \"] = 49;\n    map[\"  \"] = 50;\n \
    \   map[\"  \"] = 51;\n    map[\"  \"] = 52;\n    map[\"  \"] = 53;\n    map[\"\
    \  \"] = 54;\n    map[\"  \"] = 55;\n    map[\"  \"] = 56;\n    map[\"  \"] =\
    \ 57;\n    map[\"  \"] = 58;\n    map[\"  \"] = 59;\n    map[\"  \"] = 60;\n \
    \   map[\"  \"] = 61;\n    map[\"  \"] = 62;\n    map[\"  \"] = 63;\n    map[\"\
    \  \"] = 64;\n    ", "{\n    auto space = text.find(' ');\n    while (space !=\
    \ string::npos)\n    {\n        auto next = find_if(text.begin(), text.end(),\
    \ isspace);\n        text.replace(space, next - space, ' ');\n        space =\
    \ text.find(' ', next + 1);\n    }\n    return text;\n}", "{\n    unsigned i;\n\
    \    unsigned len;\n    string s;\n    \n    // Check for empty string\n    if\
    \ (text == \"\")\n        return text;\n    \n    // Replace all spaces with underscores\n\
    \    s = text;\n    len = s.length();\n    for(i = 0; i < len; ++i)\n    {\n \
    \       if (!isspace(s[i]))\n            s[i] = '_';\n    }\n    return s;\n}",
  "{\n    // Replace multiple spaces with a single _\n    vector<int> offsets;\n \
    \   \n    string spaces = \"[ \\t]+\";\n    \n    // Scan the string\n    for(int\
    \ i = 0; i < text.length(); ++i)\n    {\n        \n        // If we're not at\
    \ the beginning of the string\n        // and we're not at a space character...\n\
    \        if(i != 0 && !isspace(text[i]) && text[i] == \" \")\n        {\n    \
    \        // Add 1 to the offsets vector\n            offsets.push_back(i);\n \
    \       }\n        \n        // Otherwise, if we are at the start of the string\n\
    \        // or we're at a space character...\n        else\n        {\n      \
    \      // If we're not at the start of text...\n            if(i != 0 && text[0]\
    \ == \" \")\n            {\n                // Then add 0 to offsets...\n    \
    \            offsets.push_back(0);\n            }\n            \n            //\
    \ Otherwise, if we're at the start of text...\n            else if(text[0] ==\
    \ \" \")\n            {\n                // Then, if the length of the text is\
    \ 1 more than the offsets...\n                if(i != text.length() - 1 && text[i\
    \ + 1] == \" \")\n                {\n                    // Then add 0 to offsets...\n\
    \                    offsets.push_back(0);\n                }\n              \
    \  \n                // Otherwise, add 1 to the offsets...\n                else\n\
    \                {\n                    offsets.push_back(1);\n              \
    \  }\n            }\n            \n            // Otherwise, add 1 to offsets...\n\
    \            else\n            {\n                offsets.push_back(1);\n    \
    \        }\n        }\n    }\n    \n    // Replace spaces with _\n    for(int\
    \ i = 0; i < offsets.size(); ++i)\n    {\n        // If offsets[i] is greater\
    \ than or equal to 1...\n        if(offsets[i] > 1)\n        {\n            for(int\
    \ j = 0; j < offsets[i] - 1; ++j)\n            {\n                text = replace(text,\
    \ spaces, \"_\");\n            }\n        }\n    }\n    \n    // Return the text\
    \ with the spaces fixed\n    return text;\n}", "{\n    \n    string s = text;\n\
    \    int pos = 0;\n    int length = s.length();\n    while(pos < length) {\n \
    \       \n        char c = s[pos];\n        if (c == ' ') {\n            \n  \
    \          if (pos != 0)\n                s[pos-1] = '_';\n            else\n\
    \                s[pos] = '_';\n        }\n        \n        pos++;\n    }\n \
    \   \n    return s;\n}", "{\n  string space = \" \";\n  string dash = \"-\";\n\
    \  int i = 0;\n  string result = \"\";\n  while (i<text.length)\n  {\n    if (text[i]\
    \ == space) {\n      result += dash;\n      i++;\n    }\n    else {\n      result\
    \ += text[i];\n      i++;\n    }\n  }\n  return result;\n}", "{\n    auto spaces\
    \ = string::find_first_of(' ');\n    auto spaces_len = spaces == string::npos\
    \ ? 0 : spaces - text;\n    \n    if (spaces_len == 0)\n        return text;\n\
    \    \n    auto spaces_len_prev = spaces_len;\n    auto spaces_len_next = spaces_len;\n\
    \    for (size_t i = 0; i < spaces_len; ++i)\n    {\n        auto space_pos =\
    \ text.find(' ', i);\n        auto spaces_prev = spaces_len < i ? 0 : spaces_len\
    \ - i;\n        auto spaces_next = spaces_len < i ? 0 : spaces_len - (i + 1);\n\
    \        \n        if (space_pos != string::npos)\n        {\n            if (spaces_len\
    \ > i + 1)\n                text.replace(space_pos, 1, \"_\");\n            \n\
    \            if (spaces_prev > i)\n                text.replace(spaces_prev, 1,\
    \ \"-\");\n            \n            if (spaces_next > i + 1)\n              \
    \  text.replace(spaces_next, 1, \"-\");\n            \n            i += space_pos\
    \ - spaces_len + 1;\n            spaces_len = (space_pos == string::npos ? i :\
    \ space_pos - spaces_len);\n        }\n    }\n    \n    return text;\n}", "{\n\
    \    auto result = text;\n    \n    int spaces_pos = 0;\n    int spaces_count\
    \ = 2;\n    for(int i = 0; i != result.size(); ++i)\n    {\n        if(result[i]\
    \ == ' ')\n        {\n            ++spaces_count;\n            if(spaces_count\
    \ == 2)\n            {\n                result[spaces_pos++] = result[i];\n  \
    \              result[spaces_pos++] = result[i];\n                spaces_count\
    \ = 1;\n            }\n        }\n        else\n        {\n            spaces_count\
    \ = 2;\n        }\n    }\n    \n    for(int i = 0; i != spaces_pos; ++i)\n   \
    \ {\n        result[i] = '-';\n    }\n    \n    return result;\n}", "{\n    string\
    \ result = text;\n    for(int i = 0; i < text.size(); ++i)\n    {\n        if\
    \ (text[i] == ' ')\n        {\n            result += '_';\n        }\n       \
    \ else if (text[i] == ' ')\n        {\n            result += '-';\n        }\n\
    \    }\n    return result;\n}", "{\n    string result = \"\";\n    for(int i=0;i<text.size();i++)\
    \ {\n        char ch = text[i];\n        if(ch == ' ') {\n            result +=\
    \ \"_\";\n        }\n        else {\n            result += ch;\n        }\n  \
    \  }\n    if(result.size() > 2) {\n        result = replace_all(result,\" \",\"\
    -\");\n    }\n    return result;\n}", "{\n    int[] spaces = {-1, 0, 1, -1};\n\
    \    for(int i = 0; i < text.size(); ++i)\n    {\n        if(text[i] == ' ')\n\
    \        {\n            text[i] = '_';\n            for(int j = 0; j < 4; ++j)\n\
    \            {\n                if(text[i + spaces[j]] == ' ')\n             \
    \   {\n                    text[i + spaces[j]] = '-';\n                }\n   \
    \         }\n            i += 4;\n        }\n    }\n    return text;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=string,php,algorithm |>\nHere's another solution\
    \ using preg_replace_callback function:\n<code>\nfunction replaceSpaces($value)\
    \ {\n    $result = preg_replace_callback('#(\\s)\\s+#', function($m) {\n     \
    \   return str_repeat('-', $m[1] == '' ? 1 : 2);\n    }, $value);\n    return\
    \ str_replace(' ', '_', $result);\n}\n</code>\nI hope it helps someone else too.\n\
    <|/ a dscore=1 |>\n<| c |>\nHi Kazi! Can you please explain how this works?\n\
    <|/ c |>\n<| a |>\nFor those that do not want to mess with regex, this works:\n\
    <code>\npublic function removeSpaces($value)\n{\n    return str_replace(\" \"\
    ,\"-\", preg_replace(\"/\\s\\s+/\",\"\",$value));\n}\n</code>\n<|/ a dscore=1\
    \ tags=string,php,algorithm |>\n<| a tags=string,php,algorithm |>\nHere is how\
    \ I solved it.\n<code>\n$str = \"This has spaces and spaces before and after\"\
    ;\n$str = str_replace(',','',$str);\n$str = preg_replace('/\\s+/','',$str);\n\
    $str = str_replace(',','',$str);\n$str = str_replace(' ','-',$str);\n$str = str_replace('\"\
    ','',$str);\n$str = str_replace(\"'\",'',$str);\n$str = str_replace('\"','',$str);\n\
    $str = str_replace(\"'\",'',$str);\n$str = str_replace('\"','',$str);\n$str =\
    \ str_replace(\"'\",'',$str);\n$str = str_replace('\"','',$str);\n$str = str_replace(\"\
    '\",'',$str);\n$str = str_replace(\"'\",'',$str);\n$str = str_replace('\"','',$str);\n\
    $str = str_replace(\"'\",'',$str);\n$str = str_replace(\"'\",'',$str);\n$str =\
    \ str_replace(\"'\",'',$str);\n$", "{\n  int i = 0;\n  int j = 0;\n  string result\
    \ = \"\";\n  while (i<text.length()) \n  {\n    if (text[i] == ' ')\n    {\n \
    \     j++;\n      if (j>2)\n        j = 1;\n    }\n    else\n    {\n      result\
    \ += text[i];\n      i++;\n      j = 1;\n    }\n  }\n  \n  while (i<text.length())\
    \ \n  {\n    if (text[i]==' ')\n      result+=\"-\";\n    i++;\n  }\n  \n  return\
    \ result;\n}", "{\n    string::iterator it = text.begin();\n    \n    while (*it\
    \ == ' ')\n        ++it;\n    \n    while (it != text.end()) {\n        if (*it\
    \ == ' ') {\n            *it = '_';\n            ++it;\n        } else if (*it\
    \ == ' ') {\n            *it = '-';\n            ++it;\n        } else {\n   \
    \         ++it;\n        }\n    }\n    \n    return text;\n}", "{\n    int spaces\
    \ = count(text.begin(), text.end(), ' ');\n    if(spaces > 1)\n        for(int\
    \ i = 0; i < spaces-1; i++)\n            text = replace_substring(text, \" \"\
    , \"_\", 0, spaces - 1);\n    return text;\n}\n</code>\n<|/ a tags=string,c++,replace,substring\
    \ |>\n<| a dscore=2 |>\n<code>", "{\n    for(int i = 0; i < text.length(); i++)\
    \ {\n        char c = text.at(i);\n        if(c == ' ') {\n            text +=\
    \ c;\n            text += \"_\";\n        }\n        else if(i > 0 && c == ' '\
    \ && text.at(i - 1) == '_') {\n            text += \"-\";\n        }\n    }\n\
    \    return text;\n}\n</code>\n<|/ a |>\n<| c |>\nI believe this should have been\
    \ a comment, instead of an answer.\n<|/ c |>\n<| c |>\nIt is not an answer. There\
    \ is no code to support it. If you want to have this as an answer, please add\
    \ some explanation.\n<|/ c |>\n<| c |>\nThank you for this. I used your code and\
    \ added an answer below. As mentioned below by \"Hammer\" I have been looking\
    \ at your answer and am trying to understand where you went wrong.\n<|/ c |>\n\
    <| c |>\nThanks, I thought it could be a good idea.\n<|/ c |>\n<| a tags=algorithm,string\
    \ |>\nI have modified Hammer's answer a bit. Here I give my version of the algorithm.\
    \ As I do not know Java or C++ I hope it works as intended.\n<code>\n#include\
    \ <string>\n#include <sstream>", "{\n   const int l = text.size();\n   if (l ==\
    \ 0)\n      return text;\n   for (int i = 0; i < l; ++i)\n      text[i] = replace_char(text[i],\
    \ ' ', '_');\n   int count = 0;\n   for (int i = l - 1; i >= 0; --i)\n   {\n \
    \     if (text[i] == ' ')\n      {\n         ++count;\n         text[i] = '_';\n\
    \      }\n      else if (count == 2)\n      {\n         text[i] = '-';\n     \
    \    count = 0;\n      }\n   }\n   return text;\n}\n*/\n#endif", "{\n\tstring\
    \ result = \"\";\n\tint spaceCount = 0;\n\t\n\tfor (int i = 0; i < text.size();\
    \ i++)\n\t{\n\t\tchar c = text[i];\n\t\t\n\t\tif (c == '_')\n\t\t\tspaceCount++;\n\
    \t\telse\n\t\t{\n\t\t\tif (spaceCount > 1)\n\t\t\t{\n\t\t\t\tresult += \"_\";\n\
    \t\t\t\tspaceCount = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tresult += c;\n\t\t}\n\t\
    }\n\t\n\tif (spaceCount > 1)\n\t\tresult += \"_\";\n\t\n\treturn result;\n}",
  "{\n    for(int i = 0; i < text.length; i++) \n    {\n        if (text[i] == ' ')\
    \ \n        {\n            text[i] = '_';\n        }\n        else if (i!=text.length-1\
    \ && text[i] == text[i+1] && text[i]==' ')\n        {\n            text[i] = '-';\n\
    \        }\n    }\n    return text;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\nimport std.algorithm;\nimport std.array;\nimport std.conv;\nimport\
    \ std.string.format;", "{\n    if(text.contains(\"\\t\"))\n    {\n        string\
    \ out = text.replace(\"\\t\", \"_\");\n        for(int i=1; i<text.size(); i++)\n\
    \        {\n            if(text.at(i) == \" \" && text.at(i-1) == \" \")\n   \
    \         {\n                out = out.substring(0, out.length()-1);\n       \
    \         break;\n            }\n        }\n        return out;\n    }\n    else\n\
    \    {\n        return text;\n    }\n}", "{\n    int num_spaces = 0;\n    for(int\
    \ i = 0; i < text.lengh(); ++i)\n    {\n        if(text.charAt(i) == ' ')\n  \
    \      {\n            num_spaces++;\n        }\n        else\n        {\n    \
    \        if((num_spaces > 0) && \n                (num_spaces == 2))\n       \
    \     {\n                text.Replace(\" \",\"_\");\n            }\n         \
    \   num_spaces = 0;\n        }\n    }\n    return text;\n}\n</code>\n<|/ a tags=c#\
    \ |>\n<| c |>\nPlease consider adding an explanation to your answer. Code-only\
    \ answers are not as useful as those that explain what was wrong with the OP's\
    \ code.\n<|/ c |>\n<| a tags=c# |>\nIn case you like LINQ:\n<code>\nusing System;\n\
    using System.Linq;", "{\n    for(int i=0;i<text.length();i++)\n    {\n       \
    \ if(text.data()[i]==' ')\n        {\n            text.data()[i]='_';\n      \
    \  }\n        if(text.data()[i]=='\\n' || text.data()[i]==' ' && text.data()[i+1]=='\\\
    n')\n        {\n            text.data()[i]='-';\n        }\n    }\n    return\
    \ text;\n}\n/*", "{\n    size_t len = text.length();\n    for(size_t i = 0; i\
    \ < len; i++)\n    {\n        if(text[i] == ' ' && i + 1 < len && text[i + 1]\
    \ == ' ')\n        {\n            int index = i - 1;\n            int len = len\
    \ - 1;\n            for(size_t j = i; j < len; j++)\n            {\n         \
    \       text[j] = '_';\n            }\n            i = index - 1;\n        }\n\
    \    }\n    return text;\n}", "{\n    for (int i = 0; i < text.length(); i++)\n\
    \    {\n        if (isspace(text[i])) \n        {\n            text[i] = '_';\n\
    \        }\n    }", "{\n\tauto i = text.find(\"  \");\n\twhile(i != string::npos)\n\
    \t{\n\t\tauto j = text.find(\"  \", i + 2);\n\t\ttext.replace(i, j - i, \" \"\
    );\n\t\ti = text.find(\"  \", j);\n\t}\n\treturn text;\n}", "{\n  for(int i =\
    \ 0; i < text.size(); ++i)\n    if(text[i] == ' ') \n      text[i] = '_';\n  for(int\
    \ i = 2; i < text.size()-1; ++i)\n    if(text[i] == ' ')\n      text[i] = '-';\n\
    \  return text;\n}", "{\n    if (text.is_empty()) return text;\n    \n    int\
    \ len = text.length();\n    if (len == 1) return text;", "{\n\t// TODO: Remove\
    \ me\n\treturn text;\n}", "{\n    \n    int i = 0;\n    int j = 0;\n    int k\
    \ = 0;\n    \n    for(i = 0; i < text.size() - 1; i++)\n    {\n        if(isspace(text[i])\
    \ && isspace(text[i+1]))\n        {\n            for(j = i+1; j < text.size()-1;\
    \ j++)\n            {\n                if(isspace(text[j]))\n                {\n\
    \                    text[j] = '-';\n                    k++;\n              \
    \  }\n                else\n                    break;\n            }\n      \
    \  }\n        else\n            break;\n    }\n    \n    string s = text;\n  \
    \  \n    for(int t = 0; t < text.size(); t++)\n    {\n        if(isspace(text[t]))\n\
    \        {\n            s[t] = '-';\n        }\n    }\n    \n    return s;\n}",
  "{\n    string::iterator itr = text.begin();\n    string::iterator end = text.end();\n\
    \    \n    while(itr != end)\n    {\n        bool whitespace = *itr == ' ';\n\
    \        bool consecutive = whitespace && *(itr+1) == ' ';\n        \n       \
    \ if(!whitespace && consecutive)\n        {\n            *(itr-1) = '-';\n   \
    \     }\n        else if(!consecutive)\n        {\n            ++itr;\n      \
    \  }\n        else if(!whitespace)\n        {\n            ++itr;\n        }\n\
    \        else\n        {\n            ++itr;\n            ++itr;\n        }\n\
    \    }\n    \n    return text;\n}", "{\n    size_t pos = 0;\n    \n    while (pos\
    \ < text.length()) \n    {\n        while (pos < text.length() && \n         \
    \     isspace(text[pos]))\n            pos++;\n    \n        if (pos >= text.length()\
    \ || text[pos] != ' ')\n            text += \"_\";\n        else if (pos == 0\
    \ || \n                 (pos == text.length() - 1 && \n                  text[pos-1]\
    \ == ' '))\n        {\n            text += \"-\";\n            pos = pos + 1;\n\
    \        }\n        else\n            text += \"-\";\n    }\n    \n    return\
    \ text;\n}", "{\n    size_t pos = 0;\n    string result = \"\";\n    while (pos\
    \ < text.length())\n    {\n        while (pos < text.length() && text[pos] ==\
    \ ' ')\n        {\n            pos++;\n        }\n        if (pos < text.length())\n\
    \        {\n            if (text[pos] == '_')\n            {\n               \
    \ result = result + \"-\";\n            }\n            else\n            {\n \
    \               result = result + \"_\";\n            }\n        }\n    }\n  \
    \  if (result != \"\")\n    {\n        result = result.substr(0, result.length()\
    \ - 1);\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1 tags=regex,python,c++,string\
    \ |>\n<| a tags=regex,python,c++,string |>\nThis answer is only here because it\
    \ is too long for a comment. I am also not so familiar with Python but I thought\
    \ it would be useful to show the C++ solutions I have come up with. Although I\
    \ am not sure if they are the best/fastest solutions.\n<code>\n#include <string>\n\
    #include <cstring>\n#include <iostream>", "{\n    string result;\n    for(var\
    \ i = 0; i < text.length(); i++)\n    {\n        if(text[i] == \" \")\n      \
    \  {\n            result += underscore;\n        }\n        else\n        {\n\
    \            result += text[i];\n        }\n    }\n    return result;\n}", "{\n\
    \    auto first = true;\n    for (size_t i = 0; i < text.size(); i++) {\n    \
    \    if (!isspace(text[i])) {\n            first = false;\n        }\n       \
    \ else if (first && text.size() > i + 1 && isspace(text[i + 1])) {\n         \
    \   text[i] = '_';\n        }\n    }\n    for (size_t i = 0; i < text.size();\
    \ i++) {\n        if (isalnum(text[i])) {\n            if (text[i] != '_') {\n\
    \                text[i] = '_';\n            }\n        }\n    }\n    return text;\n\
    }", "{\n    \n    bool flag = true;\n    int count = 0;\n    char c;\n    string\
    \ s = text;\n    \n    for(int i = 0; i < s.length(); ++i)\n    {\n        c =\
    \ s[i];\n        \n        if (c == ' ')\n        {\n            if (flag)\n \
    \           {\n                count += 1;\n            }\n            else\n\
    \            {\n                count = 1;\n                flag = false;\n  \
    \          }\n        }\n        else if (flag)\n        {\n            if (count\
    \ == 2)\n            {\n                string replaced = s.substr(0, i) + \"\
    -\";\n                s = replaced;\n                i += 1;\n            }\n\
    \            else if (count == 1)\n            {\n                string replaced\
    \ = s.substr(0, i) + \"-\";\n                s = replaced;\n            }\n  \
    \          \n            flag = false;\n        }\n    }\n    \n    return s;\n\
    }", "{\n    const int MAX_SPACES = 2;", "{\n    string::iterator it = text.begin();\n\
    \    \n    while (it != text.end()) {\n        if (*it == ' ') {\n           \
    \ ++it;\n            while (it != text.end() && is_space(*it)) {\n           \
    \     ++it;\n            }\n            if (it != text.end() && is_space(*it))\
    \ {\n                *it = '_';\n            }\n        }\n        else\n    \
    \        ++it;\n    }\n    \n    return text;\n}", "{\n    for(auto c : text)\
    \ \n    {\n        if(c == ' ' || c == ',' || c == '\\n') \n        {\n      \
    \      c = fix_spaces('_' + c);\n        }\n    }\n    return text;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| a dscore=3 |>\nI got another way to do this using regex\n\
    <code>\n#include <iostream>\n#include <string>\n#include <regex>", "{\n\t// Replace\
    \ each space with an underscore\n\tstring result = text;\n\tauto spaces = result.find_first_of(\"\
    \ \");\n\twhile (spaces != string::npos)\n\t{\n\t\tauto end = result.find_first_not_of(\"\
    \ \", spaces+1);\n\t\tif (end == string::npos)\n\t\t\tend = result.size();\n\t\
    \tresult.insert(end, \"_\");\n\t\tspaces = result.find_first_of(\" \", spaces+1);\n\
    \t}\n\t\n\t// If a string has more than 2 consecutive spaces, replace them with\
    \ -\n\tauto spaces = result.find_first_of(\" \", result.size()-1);\n\twhile (spaces\
    \ != string::npos)\n\t{\n\t\tauto end = result.find_first_not_of(\" \", spaces+1);\n\
    \t\tif (end == string::npos)\n\t\t\tend = result.size();\n\t\tresult.insert(end,\
    \ \"-\");\n\t\tspaces = result.find_first_of(\" \", spaces+1);\n\t}\n\t\n\treturn\
    \ result;\n}", "{\n    string::iterator it = text.begin();\n    string::iterator\
    \ end = text.end();\n    for(; it != end; ++it){\n        if (*it == ' ') {\n\
    \            *it = '_';\n        }\n        if (*it == ' ' && it + 1 != end &&\
    \ *(it+1) == ' ' && (it+2) != end){\n            *it = '_';\n            ++it;\n\
    \        }\n    }\n    return text;\n}", "{\n    return replace_all(text, \" \"\
    , \"_\");\n}", "{\n    return replace_all(text, \" \", \"_\");\n}", "{\n    string\
    \ result = text;\n    size_t pos = 0;\n    size_t index = 0;\n    while((pos =\
    \ result.find(\"  \", index)) != string::npos) \n    {\n        index = pos +\
    \ 2;\n        result.replace(pos, 2, \" \");\n    }\n    pos = 0;\n    while((pos\
    \ = result.find(\"  \", index)) != string::npos) \n    {\n        index = pos\
    \ + 2;\n        result.replace(pos, 2, \"_\");\n    }\n    return result;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nI tested it and it works very well. I had\
    \ to change result.replace(pos, 2, \" \"); to result.replace(pos, 2, \" _\");\
    \ in the second while loop. Can you please explain the logic behind the code?\n\
    <|/ c |>\n<| c |>\nThanks, I've fixed it.\n<|/ c |>\n<| c |>\nI have just tested\
    \ it, and it works very well. I just changed the first while loop to while(index\
    \ != string::npos && index != result.length()). Thanks again.\n<|/ c |>\n<| a\
    \ tags=string,c++ dscore=2 |>\nThis code will replace all sequences of spaces\
    \ followed by another space or tab (which might or might not be preceded by a\
    \ non-whitespace character) with - in the beginning of the string and beginning\
    \ of the next line:\n<code>", "{\n    string result = \"\";\n    \n    for(int\
    \ i = 0; i < text.length(); ++i)\n    {\n        char c = text[i];\n        \n\
    \        if(isspace(c))\n        {\n            result += \"_\";\n        }\n\
    \        else if(i > 0 && isspace(text[i - 1]))\n        {\n            result\
    \ += \"-\";\n        }\n    }\n    \n    return result;\n}", "{\n  auto words\
    \ = split(\" \", text);\n  \n  // If there is only 1 space, return the string\n\
    \  if (words.length() == 1) {\n    return words[0];\n  }\n  \n  // If there are\
    \ more than 2 consecutive spaces, replace them with -\n  if (words.length() >\
    \ 2) {\n    int length = words.length();\n    for (int i = 0; i < (length - 2);\
    \ i++) {\n      auto a = words[i];\n      auto b = words[i+1];\n      if (a ==\
    \ b) {\n        words[i] = \"_\" + b;\n        words[i+1] = \"\";\n        words[length-2]\
    \ = \"\";\n      }\n    }\n  }\n  \n  // Concatenate the words\n  string result\
    \ = \"\";\n  for (auto word : words) {\n    result += word;\n  }\n  \n  // Return\
    \ result\n  return result;\n}", "{\n    string s = text;\n    size_t pos = 0;\n\
    \    while (true)\n    {\n        pos = s.find(' ', pos);\n        if (pos ==\
    \ string::npos) \n        {\n            s = s + '-';\n        }\n        else\n\
    \        {\n            ++pos;\n            size_t prev = 0;\n            size_t\
    \ cur = pos;\n            while (true)\n            {\n                cur = s.find('\
    \ ', cur);\n                if (cur == string::npos) \n                {\n   \
    \                 size_t t = s[prev];\n                    s[prev] = s[cur];\n\
    \                    s[cur] = t;\n                    break;\n               \
    \ }\n                else\n                {\n                    prev = cur;\n\
    \                    ++cur;\n                }\n            }\n        }\n   \
    \     ++pos;\n    }\n    return s;\n}", "{\n    for(int i = 0; i < text.length();\
    \ i++)\n    {\n        char c = text[i];\n        if(c == ' ')\n        {\n  \
    \          text += \"_\";\n        }\n        else if (c == '_')\n        {\n\
    \            if(text.substr(i-1, 1) == \"_\" && text.substr(i+2, 1) == \"_\")\n\
    \            {\n                text = text.substr(0, i) + \"-\" + text.substr(i+2,\
    \ text.length()-i+2);\n            }\n        }\n    }\n    \n    return text;\n\
    }\n// end::replace_spaces[]", "{\n  // TODO: replace multiple spaces with single\
    \ _\n  text.erase(remove_if(text.begin(), text.end(), space), text.end());\n \
    \ \n  int index = 0;\n  for(int i = 0; i < text.length(); ++i) {\n    if(text[i]\
    \ == ' ') {\n      if(index == 0) {\n        index = 1;\n      } else {\n    \
    \    index = 0;\n      }\n    }\n  }\n  \n  if(index > 2) {\n    text.erase(remove_if(text.begin(),\
    \ text.end(), space), text.end());\n    text.insert(0, \"_\");\n  }\n  \n  return\
    \ text;\n}", "{\n    size_t i, j;\n    char c;", "{\n    for(int i = 0; i < text.length;\
    \ i++)\n    {\n        if(text[i] == ' ')\n        {\n            text[i] = '_';\n\
    \        }\n        if(i > 0 && text[i-1] == ' ')\n        {\n            text[i-1]\
    \ = '-';\n        }\n    }\n    return text;\n}\n</code>\n<|/ a dscore=1 tags=replace,php,string\
    \ |>\n<| a tags=replace,php,string |>\n<code>\n$string = str_replace(' ', '_',\
    \ $string);\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis does not provide an answer\
    \ to the question. To critique or request clarification from an author, leave\
    \ a comment below their post.\n<|/ c |>\n<| c |>\nSorry for not explaining enough.\
    \ I thought I was a guy who wanted to replace spaces with underscores, that's\
    \ why I posted an answer. He wanted the exact code so I just posted that.\n<|/\
    \ c |>\n<| c |>\n- this answer is actually the answer to the question asked. \
    \ I ran this and it worked.  He said he wanted to replace spaces with underscores\
    \ but he also said \"if there are more than 2 consecutive spaces, replace all\
    \ consecutive spaces with -\".\n<|/ c |>\n<| c |>\nYes, but he said `str_replace`\
    \ replaces spaces with underscores, whereas he wants dashes instead, and he didn't\
    \ specify that he wanted dashes instead of spaces. Your code does exactly that.\
    \ Your code doesn't answer his question. I also ran his code and it works. He\
    \ said he didn't want to use regexes, he said he didn't want to use regexes, and\
    \ he said he didn't want to use regexes either. He asked how to replace spaces\
    \ with underscores. Your answer doesn't answer that, and it doesn't explain why\
    \ `str_replace` works. You even say \"you only need the str_replace function\"\
    , but then don't tell him how to do it without regexes.\n<|/ c |>\n<| c |>\n-\
    \ I appreciate you taking the time for explaining things and providing me with\
    \ a code sample. I learned something new today!\n<|/ c |>\n<| a tags=replace,php,string\
    \ |>\n<code>\n$string = str_replace(\" \", \"-\", $string);\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=replace,php,string |>\nTry this:\n<code>\nstr_replace(' ', '_',\
    \ $string);\n</code>\n<|/ a dscore=0 |>\n<| a tags=replace,php,string dscore=0 ",
  "{\n\tif (text == \"\")\n\t\treturn text;\n\tif (text.find(\"  \") != string::npos)\n\
    \t{\n\t\tstring t = text;\n\t\tint i = 0;\n\t\tint len = text.length();\n\t\t\
    while (i<len)\n\t\t{\n\t\t\tchar c = t.at(len);\n\t\t\tif (c == '\\n' || c ==\
    \ '\\r')\n\t\t\t\tbreak;\n\t\t\tlen--;\n\t\t}\n\t\tif (i == len)\n\t\t\treturn\
    \ text;\n\t\t\n\t\tstring t1 = text.substr(0, i);\n\t\tstring t2 = text.substr(i+1);\n\
    \t\tint nSpaces = 0;\n\t\tfor (int k=0; k<i; k++)\n\t\t\tif (text.at(k) == ' ')\n\
    \t\t\t\tnSpaces++;\n\t\t\n\t\tif (nSpaces > 1)\n\t\t\tt1 = t1.replace(\"  \",\
    \ \" \");\n\t\telse\n\t\t\tt1 = t1.replace(\" \", \"-\");\n\t\t\n\t\treturn t1\
    \ + t2;\n\t}\n\telse\n\t\treturn text;\n}", "{\n    // Make sure there is at least\
    \ 2 consecutive spaces and that there is at least one space.\n    if (text.find_first_not_of(\"\
    \ \") == -1 || text.find_last_not_of(\" \") == -1 || text.size() < 4) return text;\n\
    \    \n    size_t first_space = text.find_first_not_of(\" \");\n    size_t last_space\
    \ = text.find_last_not_of(\" \");\n    size_t space_count = last_space - first_space;\n\
    \    \n    string result = text;\n    \n    // If there are more than 2 spaces,\
    \ replace all spaces with _\n    if (space_count > 1) \n    {\n        result\
    \ += _.rep(\" \", space_count);\n    }\n    \n    return result;\n}", "{\n\tfor(int\
    \ i=0; i < text.length(); i++) {\n\t\tif(isspace(text[i])) {\n\t\t\ttext = replace(text,\
    \ text[i], \"_\");\n\t\t}\n\t}\n\tif(text.find(\" \") != string::npos) {\n\t\t\
    text = replace(text, \" \", \"-\");\n\t}\n\t\n\treturn text;\n}", "{\n    string\
    \ result = text;\n    size_t i = 0;\n    while (i < result.length()) {\n     \
    \   if (result[i] == ' ') {\n            result[i] = '_';\n            i += 1;\n\
    \        }\n        else if (result[i] != ' ' && i > 0 && result[i-1] != ' ')\
    \ {\n            result[i] = '-';\n            i += 1;\n        }\n        i +=\
    \ 1;\n    }\n    while (i < result.length() && result[i] == ' ') {\n        result[i]\
    \ = '_';\n        i += 1;\n    }\n    return result;\n}", "{\n    for(var i =\
    \ 0; i < text.length; i++)\n    {\n        if(text[i] == ' ')\n        {\n   \
    \         int j = i;\n            while(j < text.length && text[j] == ' ')\n \
    \           {\n                j++;\n            }\n            if(j - i > 2)\n\
    \            {\n                int k = i;\n                while(i < j && text[i]\
    \ == ' ')\n                {\n                    i++;\n                }\n  \
    \              if(k - j > 2)\n                {\n                    string temp\
    \ = \"_\";\n                    for(int j = i; j < k; j++)\n                 \
    \   {\n                        temp += text[j];\n                    }\n     \
    \               temp = temp + \"-\";\n                    for(int j = k; j < j\
    \ + 2; j++)\n                    {\n                        temp += text[j];\n\
    \                    }\n                    temp = temp;\n                   \
    \ i = j;\n                }\n            }\n        }\n        text[i] = \"_\"\
    ;\n    }\n    return text;\n}\n</code>\n<|/ a tags=replace,string,java,substring\
    \ dscore=1 |>\n<| c |>\nCan you please explain why you are using \"replaceAll(\"\
    \\\\s+\", \"_\")\" ? I thought that is the regex for spaces.\n<|/ c |>\n<| c |>\n\
    The replaceAll(\"\\\\s+\", \"_\") is just a replacement for spaces. You might\
    \ want to use replaceAll or replace instead. replaceAll is more efficient since\
    \ it only needs to iterate over the string once. Replace replaces every occurrence\
    \ of the substring and so has to iterate over the string twice. \nSo if the string\
    \ \"A   B   C\" is the input, then replaceAll(\"\\\\s+\", \"_\") would first replace\
    \ all spaces to underscores resulting in \"A_B_C\" then it replaces all spaces\
    \ to underscores again resulting in the final string \"A_B_C\"\n<|/ c |>\n<| a\
    \ dscore=1 |>\nThis solution works perfectly for me:\n<code>\nprivate void setUnderscores(String\
    \ str, String word) {\n    String regex = \"(^|\\\\s)\" + word + \"(\\\\s|$)\"\
    ;\n    str = str.replaceAll(regex, \"$1_$2\");\n    str = str.replaceAll(regex,\
    \ \"-$2\");\n    str = str.replaceAll(regex, \"$2\");\n}\n</code>\n<|/ a tags=replace,string,java,substring\
    \ |>\n<| a dscore=1 |>\nFor those who came here from google, I came up with a\
    \ different approach, using a regex to match the spaces. \n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;",
  "{\n    const char* firstspace = text.find_first_of(\" \");\n    const char* lastspace\
    \ = text.find_last_of(\" \");\n    if (firstspace != lastspace) {\n        const\
    \ int numspaces = lastspace-firstspace+1;\n        for (int i=0; i < numspaces;\
    \ ++i) {\n            int offset = i-numspaces;\n            if (offset > 0) {\n\
    \                text += \"-\";\n            }\n            text += firstspace\
    \ + offset;\n        }\n    }\n    return text;\n}\n</code>\n<|/ a tags=string,c++,char\
    \ dscore=1 |>\n<| a dscore=0 |>\nThis is my solution:\n<code>\n#include <iostream>\n\
    #include <cstring>", "{\n\ttext.find_first_not_of(\" \", string::npos);\n\twhile(text.find_first_not_of(\"\
    \ \", string::npos) != string::npos)\n\t{\n\t\ttext.replace_first(\" \", \"_\"\
    );\n\t}\n\ttext.find_first_not_of(\" \", string::npos);\n\twhile(text.find_first_not_of(\"\
    \ \", string::npos) != string::npos)\n\t{\n\t\ttext.replace_first(\"  \", \"_\"\
    );\n\t}\n\treturn text;\n}", "{\n    string::size_type pos = 0;\n    \n    while\
    \ (pos < text.size())\n    {\n        string substr = text.substr(pos, text.size()-pos);\n\
    \        \n        bool has_space = false;\n        \n        for (unsigned i\
    \ = 0; i < substr.size(); ++i)\n        {\n            if (substr[i] == ' ')\n\
    \            {\n                has_space = true;\n                break;\n  \
    \          }\n        }\n        \n        if (has_space)\n        {\n       \
    \     string::size_type i = 1;\n            while (i + 1 < substr.size() && substr[i]\
    \ == ' ')\n                ++i;\n            substr = substr.substr(0, i) + \"\
    _\" + substr.substr(i + 1);\n        }\n        \n        if (substr.size() >\
    \ 2)\n        {\n            pos = 0;\n            while (pos < substr.size()\
    \ && substr[pos] == ' ')\n                ++pos;\n            \n            string\
    \ new_substr = substr.substr(0, pos);\n            string new_str = \"\";\n  \
    \          for (unsigned i = 0; i < new_substr.size(); ++i)\n            {\n \
    \               if (new_substr[i] == ' ')\n                {\n               \
    \     new_str += \"-\";\n                }\n                else\n           \
    \         new_str += new_substr[i];\n            }\n            \n           \
    \ substr = new_str;\n        }\n        \n        text += substr;\n        ++pos;\n\
    \    }\n    \n    return text;\n}", "{\n\tfor(int i=0;i<text.size();i++)\n\t{\n\
    \t\tif (text[i]==' ') text[i]='_';\n\t\tif (i==0 && text[i]!=' ')\n\t\t{\n\t\t\
    \ttext[i-1]='_';\n\t\t}\n\t\tif (i>0 && text[i-1]==' ' && text[i]==' ')\n\t\t\
    {\n\t\t\ttext[i]='-';\n\t\t}\n\t}\n\t\n\treturn text;\n}", "{\n    int i;\n  \
    \  bool first = true;\n    \n    for(i = 0; i < text.length(); i++)\n    {\n \
    \       if(text[i] == ' ' && first)\n        {\n            first = false;\n \
    \       }\n        else if(text[i] == ' ')\n        {\n            if(i != text.length()\
    \ - 1 && text[i+1] == ' ')\n            {\n                text[i] = '_';\n  \
    \          }\n        }\n    }\n    \n    return text;\n}", "{\n    for(auto c\
    \ : text) \n        if(!isspace(c)) \n        {\n            if(text.size() >\
    \ 2 && c == ' ' && text[1] == ' ') \n                text = text.substr(0, 1)\
    \ + \"_\" + text.substr(1);\n            break;\n        }\n    return text;\n\
    }", "{\n    vector<int> space_indexes;\n    \n    for (int i = 0; i < text.size();\
    \ ++i)\n    {\n        if (text[i] == ' ')\n        {\n            space_indexes.push_back(i);\n\
    \        }\n    }\n    \n    for (auto space_index : space_indexes)\n    {\n \
    \       auto first = space_index;\n        auto last = space_index + 1;\n    \
    \    \n        while (last < text.size() && text[last] == ' ')\n            ++last;\n\
    \        \n        if (first != last)\n        {\n            char tmp = text[first];\n\
    \            \n            for (auto iter = first; iter < last; ++iter)\n    \
    \            text[iter] = tmp;\n            \n            text.erase(first, last);\n\
    \            \n            if (last == text.size())\n            {\n         \
    \       char lastchar = text[last];\n                \n                for (auto\
    \ iter = last + 1; iter < text.size(); ++iter)\n                {\n          \
    \          char c = text[iter];\n                    \n                    if\
    \ (c != ' ' || lastchar == ' ')\n                    {\n                     \
    \   text.erase(iter, last + 1);\n                        break;\n            \
    \        }\n                    \n                    lastchar = c; \n       \
    \         }\n            }\n        }\n    }\n    \n    return replace_all(text,\
    \ \" \", \"_\");\n}", "{\n    \n    size_t len = length(text);\n    for (size_t\
    \ i = 0; i < len; i++)\n    {\n        if (text[i] == ' ')\n        {\n      \
    \      size_t j = i;\n            while (j < len && text[j] == ' ')\n        \
    \        j++;\n            while (j > 0 && text[j - 1] == ' ')\n             \
    \   j--;\n            if (j > 0)\n            {\n                string result\
    \ = text.substr(0, i) + \"_\" + text.substr(i, j - i);\n                size_t\
    \ start = 0;\n                while (i < j)\n                {\n             \
    \       result[start] = text[i];\n                    start++;\n             \
    \       i++;\n                }\n                text = result;\n            }\n\
    \        }\n    }\n    \n    if (text.length() > 2)\n    {\n        size_t start\
    \ = 0;\n        size_t last = 0;\n        size_t len = text.length();\n      \
    \  while (last != len - 1)\n        {\n            if (text[last] == ' ')\n  \
    \          {\n                string result = text.substr(start, last - start);\n\
    \                size_t len2 = text.length();\n                while (last !=\
    \ len2 - 1 && text[last + 1] == ' ')\n                    last++;\n          \
    \      if (last != len2)\n                {\n                    result += text.substr(last,\
    \ len - last);\n                    start = last + 1;\n                }\n   \
    \             else\n                {\n                    result += text.substr(start,\
    \ len - start);\n                    start = len;\n                }\n       \
    \         text = result;\n            }\n            last++;\n        }\n    }\n\
    \    \n    return text;\n}\n/*", "{\n    for(auto i = text.length() - 1; text[i]\
    \ == ' '; i--)\n    {\n        text = text.insert(0, '_');\n    }\n    for(auto\
    \ i = text.find(' '); i != text.npos && text[i + 1] == ' '; i--)\n    {\n    \
    \    text = text.insert(0, '_');\n    }\n    \n    return text;\n}", "{\n    size_t\
    \ i;\n    size_t nspaces = text.find_last_of(' ', 0);\n    size_t newlen = text.length();\n\
    \    string newtext;\n    \n    for(i = 0; i < nspaces; i++)\n        newtext.push_back('_');\n\
    \    \n    newtext.push_back(' ');\n    for(i = 0; i < nspaces; i++) {\n     \
    \   newtext.push_back('_');\n    }\n    \n    if(newlen > text.length())\n   \
    \     newtext = newtext.subpiece(0, newlen - text.length());\n    else\n     \
    \   newtext = newtext.subpiece(0, newlen);\n    \n    return newtext;\n}\n</code>\n\
    I didn't think it would be too hard to implement the other versions of the method...\n\
    <|/ a dscore=2 |>\n<| c |>\nYou got it! Thanks heaps! I tried to implement the\
    \ other versions and then came up with my own version using the above methods.\
    \ Very neat!\n<|/ c |>\n<| a dscore=2 tags=string,algorithm,c++ |>\n<code>\n#include\
    \ <iostream>\n#include <algorithm>", "{\n    stringstream ss(text);\n    string\
    \ word;\n    int num_spaces = 0;\n    while(ss.good())\n    {\n        ss >> word;\n\
    \        while(ss.good() && word.empty())\n            ss >> word;\n        \n\
    \        switch(word.size())\n        {\n        case 0:\n        case 1:\n  \
    \      case 2:\n        case 3:\n        case 4:\n        case 5:\n        case\
    \ 6:\n        case 7:\n        case 8:\n        case 9:\n        case 10:\n  \
    \      case 11:\n        case 12:\n        case 13:\n        case 14:\n      \
    \  case 15:\n        case 16:\n        case 17:\n        case 18:\n        case\
    \ 19:\n            ss << \"-\";\n            break;\n        case 20:\n      \
    \      ss << \"-\";\n            break;\n        default:\n            ss << word;\n\
    \            break;\n        }\n        ss << \" \";\n        num_spaces = 0;\n\
    \    }\n    return ss.str();\n}", "{\n    int spaceIndex = 0;\n    int currentIndex\
    \ = 0;\n    string fixedText = text;\n    while ((currentIndex < fixedText.length())\
    \ && (fixedText[currentIndex] == ' '))\n    {\n        spaceIndex = currentIndex;\n\
    \        currentIndex++;\n    }", "{\n    auto s = text;\n    \n    while (s.length()\
    \ > 0) {\n        if (is_space(s[0]))\n            s = s.slice(1);\n        else\
    \ {\n            s = s.slice(1);\n            if (s.length() > 1)\n          \
    \      s = s + \"-\";\n        }\n    }\n    \n    return s;\n}", "{\n    int\
    \ num_spaces = text.find_first_of(\" \");\n    \n    for (int i = 0; i < num_spaces;\
    \ i++) {\n        auto new_pos = text.find_first_not_of(\" \", i);\n        \n\
    \        if (new_pos != i) {\n            auto new_space_pos = text.find_first_of(\"\
    \ \", new_pos);\n            auto new_space_end = text.find_first_not_of(\" \"\
    , new_space_pos);\n            \n            if (new_space_end != new_space_pos\
    \ + 1) {\n                text = text.substr(0, new_pos) + \"_\" + text.substr(new_space_pos\
    \ + 1);\n            } else {\n                text = text.substr(0, new_pos);\n\
    \            }\n        }\n    }\n    \n    for (int i = 0; i < num_spaces; i++)\
    \ {\n        auto new_pos = text.find_first_not_of(\" \", i);\n        \n    \
    \    if (new_pos != i) {\n            auto new_space_pos = text.find_first_of(\"\
    \ \", new_pos);\n            auto new_space_end = text.find_first_not_of(\" \"\
    , new_space_pos);\n            \n            if (new_space_end != new_space_pos\
    \ + 1) {\n                text = text.substr(0, new_pos) + \"-\" + text.substr(new_space_pos\
    \ + 1);\n            } else {\n                text = text.substr(0, new_pos);\n\
    \            }\n        }\n    }\n    \n    return text;\n}", "{\n  int len =\
    \ text.length();\n  int i;\n  \n  for (i=0; i<len; ++i)\n    if (text[i] == '\
    \ ') \n      text[i] = '_';\n    else \n      break;\n  \n  i--;\n  if (i > 0\
    \ && text[i - 1] == ' ') \n  {\n    size_t j = len - 1;\n    \n    while (j >\
    \ 0 && text[j] == ' ')\n      j--;\n    \n    j = j + 1;\n    \n    while (j <\
    \ len && text[j] == ' ')\n      j++;\n    \n    if (j < len)\n    {\n      if\
    \ (j == len - 1 && text[len] == ' ')\n      {\n        text[len] = '_';\n    \
    \  }\n      else\n      {\n        if (text[i] == ' ')\n          text[i] = '-';\n\
    \        else if (text[i] == ' ')\n          text[i] = '_';\n        else\n  \
    \        text[i] = '-';\n      }\n      \n      for (i = j+1; i<len; ++i)\n  \
    \      if (text[i] == ' ')\n          text[i] = '_';\n        else\n         \
    \ break;\n    }\n  }\n  \n  return text;\n}", "{\n    size_t len = length(text);\n\
    \    for (size_t i = 0; i < len; i++) {\n        char ch = text[i];\n        if\
    \ (ch == ' ') {\n            char ch2 = text[i + 1];\n            if (ch2 == '\
    \ ') {\n                if (i + 2 < len) {\n                    text[i] = '_';\n\
    \                    text[i + 1] = '-';\n                    i += 2;\n       \
    \         }\n            }\n        }\n    }\n    return text;\n}", "{\n    //\
    \ replace all spaces\n    vector<char> chars;\n    for (auto i : text) {\n   \
    \     if (i == 32) {\n            chars.push_back('_');\n        } else {\n  \
    \          chars.push_back(i);\n        }\n    }\n    return join(chars);\n}",
  "{\n    return replace_string(text, \" \", \"_\");\n}", "{\n  auto pos = 0;\n  while(pos\
    \ < text.length())\n  {\n    auto c = text[pos];\n    if(c != ' ' && c != '\\\
    t')\n      text.insert(pos, \"_\");\n    ++pos;\n  }\n  auto pos = 0;\n  while(pos\
    \ < text.length())\n  {\n    auto c = text[pos];\n    if(c != ' ' && c != '\\\
    t')\n      text.insert(pos, \"-\");\n    ++pos;\n  }\n  return text;\n}", "{\n\
    \  string result = text;\n  // Fix double space case \n  result = replace_all(result,\
    \ \"  \", \"_\");\n  // Fix multiple consecutive spaces\n  int i = 0;\n  while\
    \ (i < result.length()) \n  {\n    char c = result[i];\n    // Ignore spaces before\
    \ first character or after last character\n    if (c == ' ' && i > 0 && result[i-1]\
    \ == ' ') continue;\n    if (c == ' ' && i < result.length() - 1 && result[i+1]\
    \ == ' ') continue;\n    result[i] = '_';\n    ++i;\n  }\n  return result;\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| a tags=string,replace,c#,.net dscore=4 |>\nThe\
    \ answers given so far do not provide any solution for replacing multiple spaces\
    \ with single spaces in the middle of the string. Also the solution has problems\
    \ when there are multiple consecutive spaces.\nThe following solution replaces\
    \ multiple consecutive spaces with a single space and a single space with a single\
    \ space:\n<code>\nprivate string RemoveMultipleSpaces(string str)\n{\n    var\
    \ result = Regex.Replace(str, \"\\\\s+\", \" \");\n    result = Regex.Replace(result,\
    \ \"\\\\s+\", \" \");\n    return result;\n}\n</code>\n<|/ a |>\n<| a |>\nI ended\
    \ up solving this problem by using the Regex.Replace method with a regular expression\
    \ of:\n<code>\nstring replace = Regex.Replace(myString, @\"\\s+\", \" \");\n</code>\n\
    <|/ a tags=string,replace,c#,.net dscore=4 |>\n<| a dscore=3 |>\nI used the String.Replace\
    \ function with Regex.\nI replaced more than one space with one space, and one\
    \ space with one space.\n<code>\nstring replaced = Regex.Replace(text, @\"\\s+\"\
    , \" \");\n</code>\n<|/ a tags=string,replace,c#,.net |>\n<| a dscore=3 |>\nYou\
    \ can use Regex.Replace with lookahead and lookbehind assertion like this:\n<code>\n\
    var result = Regex.Replace(text, @\"\\s+\", \" \", RegexOptions.Compiled | RegexOptions.IgnoreCase);\n\
    </code>\n<|/ a tags=string,replace,c#,.net |>\n<| a |>\n<code>\n  string replace\
    \ = Regex.Replace(\"hello world how are you\", @\"\\s+\", \" \");\n</code>\n<|/\
    \ a dscore=3 tags=string,replace,c#,.net |>\n<| a tags=string,replace,c#,.net\
    \ |>\n<code>\nstring result = Regex.Replace(\"hello world how are you\", @\"\\\
    s+\", \" \");\n</code>\n<|/ a dscore", "{\n    text.trim();\n    vector<string>\
    \ spaces = split_on(text, \" \");\n    string res = \"\";\n    for(auto space\
    \ : spaces) {\n        if(space.size() > 2 && space[0] == space[1]) {\n      \
    \      res += \"-\";\n        } else {\n            res += \"_\";\n        }\n\
    \    }\n    return res;\n}", "{\n\tauto result = \"\";\n\tfor(auto c: text)\n\t\
    {\n\t\tif(c != \" \" && c != \"\\t\")\n\t\t\tresult += c;\n\t\telse\n\t\t\tresult\
    \ += \"_\";\n\t}\n\t\n\tauto last_space_index = result.find_last_of(' ', 1);\n\
    \tif(last_space_index != string::npos)\n\t\tresult[last_space_index + 1] = '-';\n\
    \t\n\treturn result;\n}", "{\n    for(int i = 0; i < text.size(); ++i)\n    {\n\
    \        char ch = text[i];\n        switch(ch)\n        {\n            case '\
    \ ':\n                text[i] = '-';\n                break;\n            case\
    \ ' ':\n            case ',':\n            case ';':\n            case '(':\n\
    \            case ')':\n            case '[':\n            case ']':\n       \
    \     case '{':\n            case '}':\n            case '!':\n            case\
    \ '~':\n            case '*':\n            case '%':\n            case '$':\n\
    \            case '#':\n            case '&':\n            case '+':\n       \
    \     case '.':\n            case '/':\n            case '%':\n            case\
    \ '\"':\n            case '@':\n            case '#':\n            case '=':\n\
    \            case '&':\n            case '<':\n            case '>':\n       \
    \     case '[':\n            case ']':\n            case '{':\n            case\
    \ '}':\n            case '(':\n            case ')':\n            case '!':\n\
    \            case '~':\n            case '*':\n            case '?':\n       \
    \     case '`':\n                text[i] = '_';\n                break;\n    \
    \    }\n    }\n    \n    return text;\n}\n</code>\n<|/ a tags=c++,algorithm,string\
    \ |>\n<| a dscore=1 |>\nMy solution to this would be to use an iterator. The iterator\
    \ would go through each character and decide if it is a whitespace character or\
    \ an alphanumeric character.\n<|/ a tags=c++,algorithm,string |>\n<| c |>\nHow\
    \ do you decide whether the character is whitespace or not? `isspace` checks against\
    \ the ASCII value of space.\n<|/ c |>\n<| c |>\nYou could use `std::isspace`.\n\
    <|/ c |>\n<| c |>\n: You just need to check against `' '`. If you mean ASCII,\
    \ then you need to do that on each character you get. Check this link http://www.cplusplus.com/reference/cctype/isspace/\n\
    <|/ c |>\n<| c |>\nThanks for your answer. I think this answer is a bit complicated\
    \ compared to the other answers. But it is good to know the existence of the function\
    \ `isspace`.\n<|/ c |>\n<| a dscore=0 |>\nThe approach I would take is this:",
  "{\n\tauto result = text;\n\t\n\tfor (auto &c : text)\n\t{\n\t\tif (isspace(c))\n\
    \t\t\tresult = replace_spaces(result, \" \", \"_\");\n\t\telse\n\t\t\tresult +=\
    \ c;\n\t}\n\t\n\treturn result;\n}", "{\n    string::iterator it = text.begin();\n\
    \    string::iterator end = text.end();\n    \n    while(it != end) {\n      \
    \  if(*it == ' ') {\n            *it = '_';\n            ++it;\n        }\n  \
    \      else if(*it == ' ') {\n            *it = '-';\n            ++it;\n    \
    \    }\n        ++it;\n    }\n    \n    return text;\n}\n/*\n \n    Determine\
    \ if string is even or odd\n    \n    >>> is_even(\"Even\")\n    True\n    >>>\
    \ is_even(\"Odd\")\n    False\n    \n*/", "{\n    while(text.find(\"  \")!=-1)\
    \ \n        text = text.replace(\"  \",\"_\");\n    while(text.find(\"  \")!=string::npos)\
    \ \n        text = text.replace(\" \",\"-\");\n    return text;\n}", "{\n    int\
    \ space_count = text.find_first_of(' ');\n    while (space_count != -1) \n   \
    \ {\n        string new_string = text.substr(0, space_count);\n        new_string\
    \ += \"_\";\n        string tail = text.substr(space_count + 1);\n        if (tail.find_first_of('\
    \ ') != -1) \n        {\n            new_string += \"_\" + tail;\n        }\n\
    \        else \n        {\n            new_string += tail;\n        }\n      \
    \  text = new_string;\n        space_count = text.find_first_of(' ');\n    }\n\
    \    return text;\n}\n</code>\n<|/ a tags=c++,string,algorithm |>\n<| c |>\nThat\
    \ would be a good answer! But as I understood, the OP wants to replace all occurrences\
    \ of consecutive spaces with a dash only if the original string contains at least\
    \ two spaces. So `\" Example 1 \"` should result into `\" Example-1\"`\n<|/ c\
    \ |>\n<| c |>\nThanks for the answer but it doesn't work exactly as i want.",
  "{\n    string spaces = \" \";\n    size_t pos = 0;\n    size_t length = text.length();\n\
    \    while (pos < length)\n    {\n        size_t next = find_if(text.begin() +\
    \ pos, text.end(), [&spaces](int c) \n        {\n            return c == spaces;\n\
    \        });\n        \n        string substr = substr(text, pos, next - pos);\n\
    \        size_t count = substr.length();\n        if (count > 1)\n        {\n\
    \            string substr_no_spaces = remove_if(substr, \n                [&spaces](int\
    \ c) { \n                    return c == spaces; \n                });\n     \
    \       string substr_no_spaces_rev = substr_no_spaces.rbegin();\n           \
    \ if (is_space(substr_no_spaces_rev.front()))\n            {\n               \
    \ string replace = \"_\";\n                string replace_with = \"\";\n     \
    \           substr_no_spaces = remove(substr_no_spaces, substr_no_spaces_rev,\
    \ \n                    [&replace, &replace_with](int c) { \n                \
    \        return c == replace; \n                    });\n                size_t\
    \ num_spaces = substr_no_spaces.length();\n                string result = \n\
    \                    substr_no_spaces + \n                    replace_with(substr_no_spaces,\
    \ num_spaces - 1, replace, replace_with);\n                \n                if\
    \ (substr_no_spaces == result)\n                {\n                    result\
    \ += replace_with(substr_no_spaces, \n                        num_spaces - 1,\
    \ replace, replace_with);\n                    result += replace_with(result,\
    \ \n                        num_spaces - 1, replace, replace_with);\n        \
    \        }\n                \n                return result;\n            }\n\
    \        }\n        \n        pos += count + 1;\n    }\n    \n    return text;\n\
    }", "{\n    string newtext;\n    int i;\n    \n    for(i = 0; i < text.size();\
    \ ++i)\n    {\n        if(text[i] == ' ')\n            newtext += \"_\";\n   \
    \     else\n            newtext += text[i];\n    }\n    \n    for(i = 0; i < text.size();\
    \ i++)\n    {\n        if(text[i] == ' ' && i > 0 && text[i-1] == ' ')\n     \
    \       newtext += \"-\";\n    }\n    \n    return newtext;\n}", "{\n    \n  \
    \  string::iterator it = text.begin();\n    \n    // skip all spaces at the start\
    \ of the text\n    while(it != text.begin() && isspace(*it)) ++it;\n    \n   \
    \ string result = \"\";\n    \n    while(it != text.end())\n    {\n        if(*it\
    \ == ' ' && it + 1 != text.end() && isspace(*(it + 1)))\n        {\n         \
    \   result += '_';\n            ++it;\n        }\n        else if(*it == ' ' &&\
    \ it + 1 < text.end() && !isspace(*(it + 1)))\n        {\n            result +=\
    \ '-';\n            ++it;\n        }\n        result += *it++;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a |>\n<| c |>\nI think your solution would be better\
    \ if the variable 'it' was defined outside the loop like that: \n  \n     `string::iterator\
    \ it = text.begin();` \n  \n`for(;it != text.end();++it)` \n  \n    `{`\n    \
    \ `if(*it == ' ' && it + 1 != text.end() && isspace(*(it + 1))){`\n      `result\
    \ += '_';`\n      `++it;`\n`    }`\n`else if(*it == ' ' && it + 1 < text.end()\
    \ && !isspace(*(it + 1))){`\n   `result += '-';`\n      `++it;`\n`}`\n    `result\
    \ += *it++;`\n`}`\n<|/ c |>\n<| c |>\n: It makes no difference in C++ -- any decent\
    \ compiler would optimize it out anyway; it makes a difference in C, where the\
    \ compiler would probably be better at detecting when a variable is never modified.\n\
    <|/ c |>\n<| a tags=string,c++ |>\n<code>\nstring cleanText(const string &s) {\n\
    \    string s2(s);\n    s2.replace(s.find(\" \"), 1 + s2.find(\" \"), \" \");\n\
    \    s2.replace(s2.find_first_not_of(' '), s2.find_last_not_of(' '), \"-\");\n\
    \    return s2;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThanks. I was able to\
    \ use your solution to fix this bug with strings in other languages: http://stackoverflow.com/questions/4845764/c-replace-a-char-from-a-string/4846054#4846054\n\
    <|/ c |>\n<| a dscore=4 tags=string,c++ |>\nThis should do the trick.\n<code>\n\
    string fixspaces(string ", "{\n    // Remove all spaces\n    text.erase(remove_if(text.begin(),\
    \ text.end(), [](int ch) {\n\treturn isspace(ch);\n    }), text.end());\n    \n\
    \    int n = text.size();\n    \n    // Replace all sequences of more than two\
    \ spaces with underscores\n    text.erase(find_if(text.begin(), text.end(), [](int\
    \ ch) {\n\treturn (isspace(ch) && isspace(text.at(n - 2)));\n    }), text.end());\n\
    \    \n    return text;\n}", "{\n    for (int i = 0, last = text.size() - 1; i\
    \ < last; i++) \n    {\n        char c = text[i];\n        if (char.IsWhiteSpace(c))\
    \ \n        {\n            text += \"_\";\n        }\n        else if (i > 0 &&\
    \ text[i-1] == ' ' && text[i+1] == ' ') \n        {\n            text += \"-\"\
    ;\n        }\n    }\n    return text;\n}\n/*", "{\n    for (int i = 0; i < text.size();\
    \ i++)\n    {\n        if (text[i] == ' ' || text[i] == '\\t')\n            text[i]\
    \ = '_';\n    }\n    \n    int consecutive_spaces = 0;\n    int last_space = text.size()\
    \ - 1;\n    \n    for(int i = 0; i < text.size(); i++)\n    {\n        if (text[i]\
    \ == ' ')\n        {\n            consecutive_spaces++;\n        }\n        else\n\
    \        {\n            consecutive_spaces = 0;\n        }\n        \n       \
    \ if (consecutive_spaces == 2)\n        {\n            last_space = i;\n     \
    \       consecutive_spaces = 0;\n            \n            for (int j = last_space\
    \ + 1; j < text.size(); j++)\n            {\n                if (text[j] == '\
    \ ')\n                {\n                    text[j] = '_';\n                }\n\
    \            }\n        }\n    }\n    \n    return text;\n}", "{\n    for(int\
    \ i = 0; i < text.length(); i++) \n    {\n        char c = text[i];\n        if(c\
    \ == ' ')\n        {\n            if(!(i + 1 < text.length() && text[i+1] == '\
    \ '))\n                text[i] = '_';\n        }\n        else if(c == '\\n' ||\
    \ c == '\\r')\n            text = \"_\" + text;\n    }\n    \n    int new_length\
    \ = 0;\n    for(int i = 0; i < text.length(); i++) \n    {\n        char c = text[i];\n\
    \        if(c == '_')\n            new_length++;\n        else if(c == ' ')\n\
    \        {\n            text[i] = '_';\n            new_length++;\n        }\n\
    \        else\n            break;\n    }\n    \n    return text.substr(0, new_length);\n\
    }\n/*", "{\n    for(int i=0; i < text.lengh - 1; i++) \n    {\n        if(text[i]\
    \ == ' ') \n        {\n            text[i] = '_';\n        } \n        else if(text[i+1]\
    \ == ' ') \n        {\n            text[i+1] = '-';\n        }\n    }\n    return\
    \ text;\n}", "{\n\t// Look for the first space\n\tint i;\n\tfor(i=0; i < text.size();\
    \ ++i)\n\t{\n\t\tif(text[i] == ' ') break;\n\t}\n\t\n\t// Get the number of consecutive\
    \ spaces\n\tint num_spaces = text.size() - (i+1);", "{\n    size_t nspace = 0;\n\
    \    size_t pos = 0;\n    \n    string result = \"\";\n    \n    while (pos <\
    \ text.size())\n    {\n        // Find position of first space\n        while\
    \ (pos < text.size() && text[pos] == ' ')\n            ++pos;\n        \n    \
    \    // Check if first space has already been replaced\n        if (nspace &&\
    \ pos != text.size() - (nspace + 1))\n            result += '_';\n        \n \
    \       // Replace all spaces with underscores if more than two spaces\n     \
    \   if (pos != text.size() - (nspace + 2))\n            result += text[pos];\n\
    \        \n        // Update the number of spaces\n        size_t nspace = pos\
    \ == text.size() - (nspace + 2) ? 1 : 0;\n        \n        // Find position of\
    \ next space\n        while (pos < text.size() && text[pos] == ' ')\n        \
    \    ++pos;\n    }\n    \n    return result;\n}", "{\n    foreach(char c, text)\
    \ {\n        if(c == ' ') {\n            if(c == ' ')\n                c = '_';\n\
    \            else\n                text = text.replace(c, \"\");\n        }\n\
    \    }\n    \n    int n = text.find_first_not_of(' ', text.size());\n    if(n\
    \ != text.size())\n        text = text.replace(n, text.size());\n    \n    return\
    \ text;\n}", "{\n    stringstream ss(text);\n    string new_text = \"\";", "{\n\
    \  // replace spaces with underscores\n  text = replace(text, \" \", \"_\");\n\
    \  \n  // replace two or more consecutive spaces with -\n  while (text.find(\"\
    \  \", 0) > 0) {\n    text = replace(text, \"  \", \"-\");\n  }\n  \n  return\
    \ text;\n}", "{\n    auto words = text.toWords();\n    for (auto &w : words)\n\
    \        w.replaceAll(\" \", \"_\");\n    \n    auto &lastSpace = words.back();\n\
    \    int i = 0;\n    while (i < lastSpace.length() && lastSpace[i] == ' ') {\n\
    \        lastSpace.replace(i, 1, \"-\");\n        i += 1;\n    }\n    \n    string\
    \ result;\n    for (auto &w : words)\n        result += w + \"-\";\n    \n   \
    \ return result;\n}", "{\n    auto spaces = text.length() - 1;\n    if (spaces\
    \ < 2) return text;\n    \n    auto last_space = text.find_last_of(' ');\n   \
    \ if (last_space == text.length()) return text;\n    \n    for (auto i = last_space;\
    \ i > 0; --i) {\n        auto c = text[i];\n        auto c_prev = text[i-1];\n\
    \        if (c == ' ' && c_prev == ' ') {\n            text.erase(i, 1);\n   \
    \         spaces -= 1;\n        } else {\n            if (spaces == 0) return\
    \ text;\n            text.insert(i, ' ');\n            spaces -= 1;\n        }\n\
    \    }\n    return text;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is a great\
    \ solution but I think OP should still check his questions before answering them\
    \ - and if he doesn't give enough details, he might not get an answer that he\
    \ can use :) So it's good that you posted a solution, but don't just give up on\
    \ the question before answering it.\n<|/ c |>\n<| c |>\nYou would think that someone\
    \ could use Google to find the answers to problems people have, but unfortunately,\
    \ the answer is more complicated than you think, and not many people have looked\
    \ for it. :) ", "{\n    auto len = length(text);\n    for (auto i = 0; i < len;\
    \ ++i) {\n        char c = text[i];\n        if (c.isspace()) \n            continue;\n\
    \        else if (i + 1 < len && text[i + 1] == ' ') \n            text[i] = '_';\n\
    \        else if (i + 2 < len && text[i + 1] == ' ' && text[i + 2] == ' ')\n \
    \           text[i] = '-';\n    }\n    return text;\n}", "{\n    /*\n        Make\
    \ all spaces lowercase\n    */\n    string fixed = to_lower(text);", "{\n    string\
    \ result = text;\n    size_t i, len;\n    for(i = 0; i < text.size(); ++i)\n \
    \   {\n        if(text[i] == ' ')\n        {\n            result += \"_\";\n \
    \       }\n        else if(i < text.size() - 1 && text[i] == text[i + 1] && text[i]\
    \ != ' ')\n        {\n            result += \"-\";\n        }\n    }\n    return\
    \ result;\n}", "{\n  string::iterator it = text.begin();\n  while (it != text.end())\
    \ {\n    if (*it == ' ') {\n      *it = '_';\n    } else {\n      ++it;\n    }\n\
    \  }\n  return text;\n}", "{\n    string res = text;\n    res = std.regex(\" \"\
    , \"_\", res);\n    if (res.find_first_of(' ') != string::npos)\n    {\n     \
    \   res = std.regex(\" \", \"_\", res);\n    }\n    return res;\n}", "{\n    string\
    \ result = \"\";\n    for(uint i = 0; i < text.size(); i++){\n        if(text[i]\
    \ == ' ') {\n            result += \"_\";\n        }\n        else if(text[i]\
    \ == ' '){\n            result += \" \";\n        }\n        else{\n         \
    \   result += text[i];\n        }\n    }\n    \n    return result.substr(0, result.size()-1);\n\
    }", "{\n    if(text.length() <= 2)\n        return text;\n    \n    int len =\
    \ text.length();\n    \n    for(int i = 1; i < len; ++i) {\n        if(text.at(i)\
    \ != text.at(i - 1))\n            break;\n    }\n    \n    int j = 0;\n    \n\
    \    while(j < len - 1 && text.at(j) == text.at(j + 1))\n        ++j;\n    \n\
    \    for(int i = j; i != len - 1; ++i) {\n        if(text.at(i) != text.at(i +\
    \ 1))\n            break;\n    }\n    \n    for(int i = j; i != len - 1; ++i)\
    \ {\n        text.at(i - 1) = text.at(i - 1) + text.at(i + 1);\n        text.at(i\
    \ + 1) = text.at(i - 1);\n    }\n    \n    return text;\n}\n    \n//#include <stdint.h>\n\
    //#include <inttypes.h>\n//#include <cstdlib>\n//#include <stdlib.h>\n//#include\
    \ <unistd.h>\n//#include <stdio.h>\n//#include <string.h>\n//#include <sys/types.h>\n\
    //#include <sys/stat.h>\n//#include <fcntl.h>\n//\n//int main()\n//{\n//    using\
    \ namespace std;\n//\n//    int64_t a = 123456789;\n//    int64_t b = 456789;\n\
    //\n//    int64_t diff = a - b;\n//    \n//    cout << \"a is \" << a << endl;\n\
    //    cout << \"b is \" << b << endl;\n//    cout << \"diff is \" << diff << endl;\n\
    //\n//    int64_t c = (int64_t)diff;\n//    \n//    cout << \"c is \" << c <<\
    \ endl;\n//    \n//    int64_t d = c - a;\n//    \n//    cout << \"diff is \"\
    \ << d << endl;\n//    \n//    int64_t e = (int64_t)d;\n//    \n//    cout <<\
    \ \"e is \" << e << endl;\n//    \n//    int64_t f = e - b;\n//    \n//    cout\
    \ << \"diff is \" << f << endl;\n//    \n//    int64_t g = (int64_t)f;\n//\n//\
    \    cout << \"diff is \" << g << endl;\n//    \n//    int64_t h = (int64_t)g;\n\
    //\n//    cout << \"diff is \" << h << endl;\n//}", "{\n    // Check for spaces\n\
    \    size_t pos = 0;\n    while ((pos = text.find_first_of(' ')) != string::npos)\
    \ {\n        // Replace spaces with underscores\n        size_t next = text.find_first_of('\
    \ ', pos + 1);\n        text.erase(pos, next - pos + 1);\n        text.insert(pos,\
    \ \"_\");\n    }\n    return text;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThanks\
    \ for the `string` version of my code!\n<|/ c |>\n<| a tags=c++,replace |>\nFor\
    \ me the code in this answer doesn't work for the string \"hello world hello\"\
    . If I input \"hello world hello\" it outputs \"h e l l o w _l o w _h e l l o\
    \ w _h e l l o w _h e l l o w _h e l l o w _h e l l o w _h e l l o w _h e l l\
    \ o w\" It replaces the spaces with _ but I want it to output \"h_e_l_l_o_w__l_o_w__h_e_l_l_o_w__h_e_l_l_o_w__h_e_l_l_o_w__h_e_l_l_o_w__h_e_l_l_o_w__h_e_l_l_o_w__h_e_l_l_o_w__h_e_l_l_o_w\"\
    . I can't understand why it doesn't work.\nThis is my code:\n<code>\n#include\
    \ <string>\n#include <iostream>\nusing namespace std;", "{\n    for(int i=0;i<text.size();++i)\n\
    \    {\n        if(text[i]==' ')\n        {\n            text[i]='_';\n      \
    \  }\n    }\n    if(text.size()>2)\n    {\n        for(int i=0;i<text.size()-2;++i)\n\
    \        {\n            if(text[i]==' ')\n            {\n                text[i]='-';\n\
    \            }\n        }\n    }\n    return text;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThe third version uses `isspace()` to avoid the need for `==' '`.\n\
    <|/ c |>\n<| c |>\nYes, but the OP wanted to have \"_Example-2\"... so this one\
    \ would need `==' '`\n<|/ c |>\n<| a dscore=2 |>\n<code>\n// replace spaces with\
    \ \"_\"\nstring space_change(string input) {\n    input = replace_if(input,[](char\
    \ c){return c==' ';});\n    input = replace_if(input,[](char c){return !isspace(c);});\n\
    \    input = replace_if(input,[](char c){return !isalpha(c);});\n    return input;\n\
    }", "{\n    size_t len = string.length();\n    size_t i = 0;\n    size_t spaces\
    \ = 0;\n    size_t space_len = 0;\n    \n    // If we have less than 3 spaces,\
    \ there is no need to process\n    if (len < 3) return text;\n    \n    while(i<len)\
    \ \n    {\n        char ch = text[i];\n        if (ch == ' ') \n        {\n  \
    \          spaces++;\n            space_len = 0;\n        }\n        \n      \
    \  if (spaces > 1)\n        {\n            space_len++;\n            if (space_len\
    \ > 2)\n                space_len = 2;\n        }\n        \n        i++;\n  \
    \  }\n    \n    for (; i < len; i++)\n    {\n        char ch = text[i];\n    \
    \    \n        if (ch == ' ') \n        {\n            if (spaces > 1)\n     \
    \       {\n                spaces--;\n                space_len--;\n         \
    \   }\n        }\n        else\n        {\n            text[i] = '_';\n      \
    \  }\n    }\n    return text;\n}\n</code>\n<|/ a tags=c++,string,trim |>\n<| a\
    \ tags=c++,string,trim |>\nA simple solution using regex:\n<code>\nstd::string\
    \ trim(std::string s) {\n  static const std::regex e(\"\\\\s+\");\n  std::cmatch\
    \ m;\n  return std::regex_replace(s, e, \"_\", std::regex_constants::match_any);\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nDoesn't work, gives me `regex_error: 'regex_constants::match_not_eol'\
    \ flag not set`\n<|/ c |>\n<| a tags=c++,string,trim |>\n<code>\n#include <boost/algorithm/string/trim.hpp>\n\
    #include <boost/algorithm/string/regex.hpp>\n</code>\nIn c++11:\n<code>\nstring\
    \ trim(string str) {\n  return boost::algorithm::trim(str, \"_\");\n}\n</code>\n\
    In c++03:\n<code>\nstring trim(string str) {\n  boost::algorithm::trim(str, \"\
    _\");\n}\n</code>\n<|/ a dscore=4 |>\n<| a dscore=3 tags=c++,string,trim |>\n\
    A single loop:\n<code>\nsize_t pos = 0;\nwhile (pos < string.length() && string[pos]\
    \ != ' ') {\n    ++pos;\n}\nstring.replace(pos, string.length() - pos, \"_\");\n\
    </code>\n<|/ a |>\n<| a |>\n<code>\nstring s = \" Example \";\nsize_t pos;\nwhile\
    \ ( (pos = s.find(\" \", pos)) != string::npos)\n{\n    s.erase(pos);\n}\ncout\
    \ << s << endl;\n</code>", "{\n    size_t len = text.length();\n    if (len ==\
    \ 0)\n    {\n        return text;\n    }\n    bool inSpace = false;\n    size_t\
    \ i = 0;\n    string rep = \" \";\n    \n    while (i < len) \n    {\n       \
    \ if (inSpace)\n        {\n            if (text[i] == ' ')\n            {\n  \
    \              rep += \"_\";\n            }\n            else\n            {\n\
    \                rep += text[i];\n            }\n            \n            if\
    \ (i+1 < len && text[i] == ' ')\n            {\n                rep += \"-\";\n\
    \                inSpace = false;\n                i += 1;\n            }\n  \
    \      }\n        \n        if (text[i] != ' ')\n        {\n            inSpace\
    \ = true;\n        }\n        \n        i += 1;\n    }\n    \n    return rep;\n\
    }", "{\n  stringstream ss;\n  ss << text;\n  string word;\n  \n  for (string line;\
    \ getline(ss, line, '\\n')) {\n    for (auto c : line) {\n      if (!isspace(c))\
    \ \n        word += c;\n      else\n        word += string(2,\"_\");\n    }\n\
    \    replace(word.size(), word.end(), \"_\", ' ');\n  }\n  return ss.str();\n}",
  "{\n    int num_spaces = 0;\n    for(int i=0; i<text.length(); i++)\n        if(text.at(i)\
    \ == ' ')\n            num_spaces++;\n    \n    int count = 0;\n    for(int i=0;\
    \ i<text.length(); i++)\n        if(text.at(i) == ' ' && count < 2)\n        \
    \    count++;\n    \n    string res = \"\";\n    for(int i=0; i<text.length();\
    \ i++)\n        if(text.at(i) == ' ')\n            if(!is_ws(text.sub(i+1,i+2)))\n\
    \                res = res + text.at(i);\n    \n    res = res + text.substr(0,num_spaces);\n\
    \    \n    if(num_spaces > 2 && text.length() > num_spaces+2)\n        res = res\
    \ + text.substr(num_spaces+1, text.length() - num_spaces-1);\n    \n    return\
    \ res;\n}", "{\n    string result = text;\n    size_t count = 0;\n    size_t start\
    \ = 0;\n    size_t end = result.size() - 1;\n    while(start < end) {\n      \
    \  count += 1;\n        if(result[start] == ' ') {\n            if(count > 2)\
    \ {\n                string replace = std.replace_if(text, \"  +\", \"_\");\n\
    \                string replaced = std.replace_if(replace, \"  \", \"_\");\n \
    \               result = std.replace_if(replaced, \"_+\", \"_\");\n          \
    \  } else {\n                result = std.replace_if(text, \"  \", \"_\");\n \
    \           }\n            start = result.find_first_of(\"_\");\n            end\
    \ = result.find_last_of(\"_\");\n        } else {\n            start = result.find_first_not_of(\"\
    \ \");\n            end = result.find_last_not_of(\" \");\n        }\n    }\n\
    \    return result;\n}", "{\n    for(int i = 0; i < text.length(); ++i)\n    {\n\
    \        if(text[i] == ' ')\n            text[i] = '_';\n    }\n    \n    for(int\
    \ i = 0; i < text.length(); ++i)\n    {\n        \n        if(text[i] == ' ')\n\
    \        {\n            if(text.find(\"  \", i) == i)\n            {\n       \
    \         text[i] = '_';\n                ++i;\n            }\n        }\n   \
    \ }\n    \n    for(int i = 0; i < text.length(); ++i)\n    {\n        if(text[i]\
    \ == '_')\n        {\n            if(text.find(\"__\", i) == i)\n            {\n\
    \                text[i] = ' ';\n                --i;\n            }\n       \
    \ }\n    }\n    \n    return text;\n}", "{\n    for(int i=0; i<text.length();\
    \ ++i)\n        if(text[i] == ' ') \n            text[i] = '_';\n        else\
    \ if(text[i] == ' ')\n            for(int j=i+1; j<text.length(); ++j)\n     \
    \           if(text[j] == ' ') \n                    text[j] = '-';\n        \n\
    \    return text;\n}", "{\n\tauto space = \" \";\n\tauto twoSpaces = \"  \";\n\
    \tauto dashes = \"-\";\n\tauto result = text;\n\t\n\tsize_t index = 0;\n\tsize_t\
    \ indexLastSpace = text.find(space);\n\t\n\twhile(indexLastSpace != string::npos)\n\
    \t{\n\t\tauto spaceToInsert = \"\";\n\t\t\n\t\tsize_t indexNextSpace = text.find(space,\
    \ indexLastSpace+1);\n\t\t\n\t\tif(indexNextSpace == string::npos)\n\t\t{\n\t\t\
    \tspaceToInsert = \"\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(indexLastSpace != 0)\n\
    \t\t\t{\n\t\t\t\tspaceToInsert = space;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\
    if(text.substr(indexNextSpace, 1).find(space) != string::npos)\n\t\t\t\t{\n\t\t\
    \t\t\tspaceToInsert = twoSpaces;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\
    \tspaceToInsert = dashes;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult = result\
    \ + spaceToInsert + text.substr(indexLastSpace+1, indexNextSpace-indexLastSpace-1);\n\
    \t\tindexLastSpace = text.find(space, indexNextSpace);\n\t\tindexNextSpace = text.find(space,\
    \ indexNextSpace+1);\n\t}\n\t\n\treturn result;\n}", "{\n    bool is_space = !text.empty();\n\
    \    \n    if(is_space && text.front()==' ') \n    {\n        bool is_two_spaces\
    \ = text[1]==' ' && text[2]==' ';\n        if(is_two_spaces) \n        {\n   \
    \         text = text.substr(0,2)+\"-\"+text.substr(3);\n        }\n    }\n  \
    \  \n    for(int i=0; i<text.size(); ++i) \n    {\n        if(is_space && text[i]=='\
    \ ') \n        {\n            text = text.substr(0,i)+\"_\"+text.substr(i);\n\
    \            i += 1;\n        }\n    }\n    \n    return text;\n}", "{\n    size_t\
    \ text_size = text.length();\n    size_t space_count = count(text.begin(), text.end(),\
    \ ' ');\n    if (space_count > 2)\n        return replace_all(text, [&]() {\n\
    \            if (text.find(' ') == string::npos)\n                return ' ';\n\
    \            return '_';\n        });\n    else\n        return text;\n}", "{\n\
    \    int len = text.length();\n    int i;\n    \n    for(i = 0; i < len; i++)\n\
    \    {\n        if(text[i] == ' ')\n        {\n            if(i < len - 1)\n \
    \           {\n                if(text[i + 1] == ' ')\n                    text[i\
    \ + 1] = '-';\n            }\n        }\n    }\n    \n    return text;\n}", "{\n\
    \    int i, length = text.length();\n    string result = \"\";\n    \n    for\
    \ (i=0; i<length; i++)\n    {\n        char c = text[i];\n        if (c == ' ')\
    \ {\n            if (result.length() > 0) \n            {\n                if\
    \ (result.length() < 2) {\n                    result += \"_\";\n            \
    \    } else {\n                    result += \".\";\n                }\n     \
    \       }\n        } else if (c != ' ') {\n            result += c;\n        }\n\
    \    }\n    return result;\n}", "{\n    for(int i = 0; i < text.length(); i++)\n\
    \    {\n        if(text[i] == \" \")\n        {\n            text += \"_\";\n\
    \        }\n        if(text[i] == \" \" && i < text.length()-1)\n        {\n \
    \           text += \"-\";\n        }\n    }\n    return text;\n}\n</code>\n<|/\
    \ a dscore=2 tags=c++,string,split,c++11 |>\n<| a |>\nThe other answers have given\
    \ good ways to do this, but if you want a straight forward answer try this:\n\
    <code>", "{\n    string result = \"\";\n    \n    for(int i = 0; i < text.length();\
    \ i++) \n    {\n        char c = text[i];\n        if (c == ' ')\n           \
    \ result += c;\n        else \n            result += c;\n    }\n    \n    for(int\
    \ i = 0; i < result.length()-1; i++)\n    {\n        char c = result[i];\n   \
    \     if (c == ' ')\n            result[i] = '_';\n    }\n    \n    if (result.length()\
    \ > 2 && \n        !std.string.replace(result, \" \", \"_\").empty()) \n    {\n\
    \        std.string.replace(result, \" \", \"_\");\n        result += '-';\n \
    \   }\n    \n    return result;\n}\n'''", "{\n    int index = 0;\n    string result\
    \ = \"\";\n    while (index < text.length()) {\n        int c = text.at(index);\n\
    \        if (c == ' ') {\n            if (index+1 < text.length()) {\n       \
    \         int next_c = text.at(index+1);\n                if ((c == ' ' && next_c\
    \ == ' ') || (c == ',' && next_c == ',') || (c == ';' && next_c == ';')) {\n \
    \                   result += '_';\n                }\n                else {\n\
    \                    result += c;\n                }\n            }\n        \
    \    else {\n                result += '_';\n            }\n            index++;\n\
    \        }\n        else {\n            result += c;\n            index++;\n \
    \       }\n    }\n    return result;\n}", "{\n    \n    // Find the first non-space\
    \ character\n    int i = 0;\n    while (text[i] != ' ') i++;", "{\n  \n  // replace\
    \ any spaces with underscore\n  text = string_replaceAll(text, \" \", \"_\");",
  "{\n    \n    for (int i = 0; i < text.length(); i++) {\n        char c = text[i];\n\
    \        if (c == ' ') {\n            \n            text.remove(c, 1);\n     \
    \       text.remove(c, 1);\n            text.remove(c, 1);\n            \n   \
    \         if (text.length() >= 2) {\n                text.remove(c, 1);\n    \
    \            text.remove(c, 1);\n                text.remove(c, 1);\n        \
    \    }\n            \n        }\n    }\n    \n    return text;\n}", "{\n    foreach(char\
    \ c in text)\n    {\n        if(c == ' ' || c == ',' || c == '\\n' || c == '\\\
    r')\n        {\n            text += c;\n        }\n        else\n        {\n \
    \           text += '_';\n        }\n    }\n    return text;\n}\n</code>\n<|/\
    \ a dscore=5 tags=c++,string,stl,c |>\n<| c |>\nI tested it and it is indeed faster\
    \ than boost::replace_all_with_commas, at least with my test data (replaced only\
    \ 2 spaces with commas and it still won by a large margin). But I still like the\
    \ regex approach more. Thanks so much for your answer.\n<|/ c |>\n<| a |>\nI did\
    \ a quick test on this, it works fine, it's fast and very simple and does the\
    \ job:\n<code>", "{\n    \n    for(int i = 0; i < text.length(); i++) {\n    \
    \    if (text[i] == ' ') {\n            string temp = text[i];\n            text[i]\
    \ = '_';\n            text[i] += '_';\n            text[i+2] = temp;\n       \
    \ }\n    }\n    int space_count = text.length() - text.Replace(\" \", \"\").length();\n\
    \    \n    if (space_count >= 2){\n        for(int i = 0; i < text.length(); i++)\
    \ {\n            if (text[i] == ' ') {\n                string temp = text[i];\n\
    \                text[i] = '-';\n                text[i] += '-';\n           \
    \     text[i+2] = temp;\n            }\n        }\n    }\n    \n    return text;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| a dscore=1 |>\nI used the previous answers but\
    \ I wanted to be more specific on the space and underscore character replacement.\
    \ I am not sure if this counts as my own answer but it is different in some ways.\n\
    <code>\npublic static string FixSpaceUnderscores(string text)\n{\n    string replace\
    \ = string.Empty;\n    bool check;\n    int spaceCount = text.Count(x => x ==\
    \ ' ');\n    if (spaceCount >= 2)\n    {\n        replace = \"-\";\n        check\
    \ = true;\n    }\n    else\n    {\n        replace = \" \";\n        check = false;\n\
    \    }\n    for (int i = 0; i < text.Length; i++)\n    {\n        if (check)\n\
    \        {\n            if (text[i] == ' ')\n            {\n                text[i]\
    \ = replace[0];\n                text[i+1] = replace[1];\n                text[i+2]\
    \ = replace[2];\n                i += 2;\n            }\n        }\n    }", "{\n\
    \    auto n = text.size();\n    \n    for(auto i = 0; i < n; i++){\n        char\
    \ c = text[i];\n        \n        if(c == ' ')\n        {\n            text[i]\
    \ = '_';\n        }\n        else if(i > 0 && c == ' ')\n        {\n         \
    \   text[i-1] = '-';\n        }\n    }\n    \n    if(n > 1){\n        auto first\
    \ = text.begin();\n        auto last = text.end();\n        \n        while(first\
    \ != last){\n            if(*first != ' '){\n                ++first;\n      \
    \          break;\n            }\n        }\n        \n        while(first !=\
    \ last){\n            char c = *first;\n            \n            if(c == ' ')\n\
    \            {\n                first = first + 1;\n                break;\n \
    \           }\n            \n            else\n            {\n               \
    \ first++;\n            }\n        }\n        \n        if(first != last)\n  \
    \      {\n            for(auto i = first; i != last; ++i)\n            {\n   \
    \             char c = *i;\n                \n                if(c == ' ')\n \
    \               {\n                    *i = '_';\n                }\n        \
    \    }\n        }\n    }\n    \n    return text;\n}\n</code>\n<|/ a tags=c++,c++11\
    \ |>\n<| c |>\n`std::string::size` can return a negative number, so you could\
    \ use `auto n = text.size();`\n<|/ c |>\n<| c |>\n`while(first != last){\n   \
    \         if(*first != ' '){\n                ++first;\n                break;\n\
    \            }\n        }\n        \n        while(first != last){\n         \
    \   char c = *first;\n            \n            if(c == ' ')\n            {\n\
    \                first = first + 1;\n                break;\n            }\n \
    \           \n            else\n            {\n                first++;\n    \
    \        }\n        }\n`", "{\n    for(int i=1; i<text.length(); i++) {\n    \
    \    if(text.charAt(i) == ' ') {\n            for(int j=1; j<i; j++) {\n     \
    \           if(text.charAt(i) == ' ') {\n                    char c = text.charAt(j);\n\
    \                    text.splice(j, 1);\n                    text.splice(i, 0,\
    \ c);\n                    break;\n                }\n            }\n        }\n\
    \    }\n    \n    if(text.length() > 2) {\n        for(int i=1; i<text.length();\
    \ i++) {\n            if(text.charAt(i) == ' ') {\n                for(int j=i+1;\
    \ j<text.length(); j++) {\n                    if(text.charAt(i) == ' ') {\n \
    \                       char c = text.charAt(j);\n                        text.splice(j,\
    \ 1);\n                        text.splice(i, 0, c);\n                       \
    \ break;\n                    }\n                }\n            }\n        }\n\
    \    }\n    \n    return text;\n}", "{\n    \n    if (text.empty())\n        return\
    \ text;", "{\n    size_t pos = 0;\n    size_t prev_pos = 0;\n    size_t len =\
    \ text.length();\n    string repl;\n    \n    while(pos < len) {\n        if(text.substr(pos,\
    \ 1) == \" \") {\n            if(pos - prev_pos > 2) {\n                repl =\
    \ text.substr(prev_pos, pos - prev_pos);\n                repl = repl.substr(0,\
    \ repl.length() - 1) + repl.substr(repl.length() - 1);\n            } else {\n\
    \                repl = \"_\";\n            }\n            text = text.substr(0,\
    \ prev_pos) + repl + text.substr(pos + 1);\n            prev_pos = pos + 1;\n\
    \            len -= 1;\n        } else if(text.substr(pos, 1) == \" \") {\n  \
    \          repl = text.substr(pos, 1);\n            text += repl;\n          \
    \  pos += 1;\n        } else {\n            text += text[pos];\n            pos\
    \ += 1;\n        }\n    }\n    return text;\n}", "{\n    auto spaces = [&](char\
    \ c)->bool{return c == ' ';};\n    auto consecutive = [&](char a, char b)->bool{return\
    \ a == b && (a == '\\n' || b == '\\n');};\n    \n    size_t start = 0;\n    size_t\
    \ count = 0;\n    \n    bool changed = false;\n    \n    for(size_t i=0;i<text.length();i++)\
    \ {\n        if(spaces(text[i])) {\n            changed = true;\n            count++;\n\
    \            start = i;\n        } else if(!consecutive(text[i], text[i+1])) {\n\
    \            if(count > 1) {\n                text.replace(start, count, \"_\"\
    );\n                changed = true;\n                count = 1;\n            }\n\
    \        } else {\n            count = 1;\n        }\n    }\n    \n    if(!changed)\
    \ {\n        return text;\n    }\n    \n    if(count > 2) {\n        changed =\
    \ true;\n        text.replace(start, count, \"-\");\n    }\n    \n    return text;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>\n#include <stdio.h>\nusing namespace std;",
  "{\n    size_t space_count = text.find_first_of(\"  \");\n    \n    if(space_count\
    \ != string::npos)\n    {\n        string new_text;\n        new_text.reserve(text.size());",
  "{\n    int start = 0;\n    int end = 0;\n    int i;\n    \n    while ((i = text.find(\"\
    \ \", start)) != -1) \n    {\n        end = i + 1;\n        while (end < text.size()\
    \ && text[end] == \" \")\n            end++;\n        string sub = text.substr(start,\
    \ end - start);\n        if (sub.size() > 2) \n            text = text.replace(sub,\
    \ \"_\");\n        else \n            text = text.replace(sub, \"\");\n      \
    \  start = end + 1;\n    }\n    return text;\n}", "{\n    size_t i;\n    size_t\
    \ j = text.length();\n    \n    while (j < text.length() && text[j] == ' ') j++;\n\
    \    \n    for (i = 0; i < j; i++) {\n        if (i == 0) continue;\n        if\
    \ (text[i] == ' ' && text[i+1] == ' ') {\n            text[i] = '_';\n       \
    \     text[i+1] = '-';\n        }\n    }\n    \n    return text;\n}", "{\n   \
    \ string::iterator it(text.begin());\n    string::iterator itEnd(text.end());\n\
    \    \n    for(; it != itEnd; ++it)\n    {\n        if(isspace(*it))\n       \
    \     *it = char('_'[0]);\n        else\n            *it = char(*it);\n    }\n\
    \    \n    if(text.length() > 2)\n    {\n        for(string::iterator it(text.begin());\
    \ it != itEnd; ++it)\n        {\n            if(isspace(*it))\n              \
    \  *it = char('-');\n        }\n    }\n    \n    return text;\n}", "{\n    if\
    \ (text.Length > 2)\n    {\n        text += \"-\";\n    }\n    for (int i = 0;\
    \ i < text.Length; i++)\n    {\n        char c = text[i];\n        if (c == '\
    \ ')\n        {\n            text += \"_\";\n        }\n    }\n    return text;\n\
    }\n</code>\n<|/ a tags=.net,c# |>\n<| a dscore=2 tags=.net,c# |>\nThis seems to\
    \ work fine.  You could even call this from Javascript using an ActiveX object\
    \ I believe.\n<code>\n        private static string FixSpaces(string str)\n  \
    \      {\n            // replace spaces with \"_\"\n            str = str.Replace(\"\
    \ \", \"_\");", "{\n  \n  // Remove leading and trailing spaces - they are only\
    \ necessary before \n  // or after we make the change. \n  while (text.StartsWith(\"\
    \ \"))\n  {\n    text = text.substr(1);\n  }\n  while (text.EndsWith(\" \"))\n\
    \  {\n    text = text.substr(0, text.Length() - 1);\n  }", "{\n\tauto end = text.find_last_not_of('\
    \ ');\n\tauto start = text.find_first_not_of(' ');", "{\n    string result = text;\n\
    \    size_t space_count = text.find_first_of(' ');\n    if (space_count != string::npos)\
    \ {\n        result = text.substr(0, space_count);\n    }\n    if (result.find_first_of('\
    \ ') != string::npos) {\n        size_t gap = result.find_last_of(' ');\n    \
    \    result = result.substr(0, gap);\n    }\n    size_t i = result.find_last_of('_');\n\
    \    if (i != string::npos) {\n        result = result.substr(0, i);\n    }\n\
    \    size_t j = result.find_first_of('_');\n    if (j != string::npos) {\n   \
    \     result = result.substr(j+1);\n    }\n    while (result.find_first_of(' ',\
    \ 0) != string::npos) {\n        result = result.substr(1);\n    }\n    return\
    \ result;\n}", "{\n\t// fix spaces\n\tfor(int i = 0; i < text.length(); i++)\n\
    \t{\n\t\tif(text[i] == ' ') \n\t\t{\n\t\t\tswitch(i)\n\t\t\t{\n\t\t\t\tcase 0:\
    \ text[0] = '_';\n\t\t\t\tcase 1: text[1] = '_';\n\t\t\t\tcase 2: text[text.length()-2]\
    \ = '_';\n\t\t\t\tdefault:\n\t\t\t\t\tfor(int j = i+1; j < text.length(); j++)\n\
    \t\t\t\t\t{\n\t\t\t\t\t\tif(text[j] == ' ') \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttext[j]\
    \ = '-';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn text;\n}\n\
    /*\n    \n    Strip out all non-alphanumeric characters\n    \n    \n    >>> strip_non_alphanumeric(\"\
    abc123def456\")\n    \"abcde\"\n    \n*/\nstring strip_non_alphanumeric(string\
    \ text)\n{\n\ttext = text.toLowerCase();\n\tfor(int i = 0; i < text.length();\
    \ i++)\n\t{\n\t\tif(text[i] >= 'a' && text[i] <= 'z' && text[i] >= '0' && text[i]\
    \ <= '9')\n\t\t{\n\t\t\tswitch(i)\n\t\t\t{\n\t\t\t\tcase 0: text[0] = '_';\n\t\
    \t\t\tcase 1: text[1] = '_';\n\t\t\t\tcase 2: text[text.length()-2] = '_';\n\t\
    \t\t\tdefault:\n\t\t\t\t\tfor(int j = i+1; j < text.length(); j++)\n\t\t\t\t\t\
    {\n\t\t\t\t\t\tif(text[j] >= 'a' && text[j] <= 'z' && text[j] >= '0' && text[j]\
    \ <= '9')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttext[j] = '-';\n\t\t\t\t\t\t}\n\t\t\t\t\
    \t}\n\t\t\t}\n\t\t}\n\t}\n\treturn text;\n}", "{\n    return text.trim().replaceAll(\"\
    \ \", \"_\");\n}", "{\n    string s = text;\n    int count = 0;\n    for(int i\
    \ = 0; i < s.length(); i++)\n    {\n        if(s[i] != ' ')\n        {\n     \
    \       s = replace_char(s, '_', count);\n            count = 1;\n        }\n\
    \        else\n        {\n            count++;\n        }\n    }\n    s = replace_char(s,\
    \ '_', count);\n    return s;\n}\n</code>\n<|/ a tags=c,string |>\n<| c |>\nHmm...\
    \ The question says specifically that the string must not contain more than one\
    \ consecutive spaces. Your answer doesn't meet that requirement.\n<|/ c |>\n<|\
    \ c |>\nHe has done the check in his function, why not use it in your code?\n\
    <|/ c |>\n<| c |>\n\"The question says specifically that the string must not contain\
    \ more than one consecutive spaces. Your answer doesn't meet that requirement.\"\
    \ Sorry, I'm confused.\n<|/ c |>\n<| a tags=c,string |>\n<code>\n#include <stdio.h>",
  "{\n    for(int i = 0; i < text.length(); i++)\n    {\n        if(text[i] == ' ')\n\
    \            text.erase(i, 1);\n        else\n            text.insert(i, '_');\n\
    \    }\n    for(int i = 0; i < text.length(); i++)\n    {\n        if(text[i]\
    \ == '_')\n            text.erase(i, 1);\n    }\n    for(int i = 0; i < text.length();\
    \ i++)\n    {\n        if(text[i] == ' ')\n            text.erase(i, 1);\n   \
    \     else\n            text.insert(i, '-');\n    }\n    return text;\n}", "{\n\
    \  // Replace spaces with underscores\n  string result = text.trim();\n  if(!result.empty())\
    \ \n    result = result.strReplaceAll(\" \", \"_\");\n  // Replace consecutive\
    \ spaces with a single dash\n  result = result.trim();\n  if(result.size() > 1\
    \ && !result.empty()) \n    result = result.strReplaceAll(\" \", \"-\");\n  return\
    \ result;\n}", "{\n    size_t pos;\n    string result = \"\";\n    while (!std.isEmpty(text))\
    \ \n    {\n        pos = text.find_first_of(\"  \");\n        if (pos != string::npos)\n\
    \            result += text.substr(0, pos);\n        else\n            result\
    \ += text;\n        text = text.substr(pos);\n    }\n    return result + \"-\"\
    ;\n}\n</cell>\n<cell>\nstd.log(\"\\n\\n***** IMPORTS *****\");\n</cell>\n<cell>\n\
    import std.log;\nimport std.random;\nimport std.array;\nimport std.file;\nimport\
    \ std.string;\nimport std.array;\nimport std.conv;\nimport std.algorithms;\nimport\
    \ std.env;\nimport std.file;\nimport std.conv;\nimport std.algorithms;\nimport\
    \ std.env;\nimport std.random;\nimport std.math;\nimport std.typecons;\nimport\
    \ std.math;\n/*", "{\n    auto text_begin = text.begin();\n    auto text_end =\
    \ text.end();\n    auto space_pos = 0;\n    \n    for (auto ch = text_begin; ch\
    \ != text_end; ++ch) {\n        if (*ch == ' ') {\n            space_pos = ch;\n\
    \        }\n        else if (space_pos > 0 && space_pos != ch) {\n           \
    \ *ch = char(tolower[*space_pos] - 32);\n        }\n    }\n    \n    return text;\n\
    }", "{\n    // Replace spaces with underscores\n    vector<char> v(text.begin(),\
    \ text.end());\n    transform(v.begin(), v.end(), v.begin(), ::tolower);\n   \
    \ transform(v.begin(), v.end(), v.begin(), ::toupper);\n    replace(v.begin(),\
    \ v.begin() + text.size(), v.end(), ' ');\n    replace(v.begin(), v.begin() +\
    \ text.size(), v.end(), '_');\n    replace(v.begin(), v.begin() + text.size(),\
    \ v.end(), ' ');\n    string result = to_string(v);\n    \n    // If string has\
    \ more than 2 consecutive spaces, replace consecutive\n    // spaces with dashes\n\
    \    auto pos = result.find_first_of(' ');\n    while (pos != string::npos)\n\
    \    {\n        if (pos != result.find_first_of(' ', pos + 1))\n        {\n  \
    \          result = result.substr(0, pos) + \"-\" + result.substr(pos + 1);\n\
    \            break;\n        }\n        pos += 1;\n    }", "{\n    size_t len\
    \ = text.length();\n    size_t max_spaces = 2;\n    size_t pos = 0;\n    string\
    \ spaces = \"_\";\n    \n    while (pos < len) {\n        size_t next = text.find_first_of(spaces,\
    \ pos);\n        if (next == string::npos) {\n            next = len;\n      \
    \  }\n        \n        size_t len = next - pos;\n        \n        if (len >\
    \ max_spaces) {\n            while (pos < len) {\n                size_t next\
    \ = text.find_first_of(spaces, pos + 1);\n                size_t len = next -\
    \ pos;\n                \n                if (len > max_spaces) {\n          \
    \          text.replace(pos, len, \"-\");\n                    pos += len + 1;\n\
    \                } else {\n                    text.replace(pos, len, spaces);\n\
    \                    pos += len + 1;\n                }\n            }\n     \
    \   }\n        \n        pos = next;\n    }\n    \n    return text;\n}\n</code>\n\
    <|/ a tags=c++,replace,string dscore=4 |>\n<| a |>\n<code>\nconst string str =\
    \ \"This is a test string\";\nconst string newstr = str.replace(\" \", \"_\");\n\
    </code>\n<|/ a dscore=4 tags=c++,replace,string |>\n<| c |>\nPlease add some explanation\
    \ as to why this should work. Code only answers are not as useful as answers that\
    \ document the code and why it addresses the problem in the question. See also\
    \ [Explaining entirely code-based answers](https://meta.stackexchange.com/questions/114762/explaining-entirely-%E2%80%8C%E2%80%8Bcode-based-answers)\n\
    <|/ c |>\n<| a |>\nIn C++17, std::string_view is available. With this, you can\
    \ do:\n<code>\n#include <string_view>", "{\n    for(int i=0;i<text.length();++i)\n\
    \    {\n        switch(text[i])\n        {\n            case ' ':\n          \
    \      text[i] = '_';\n                break;\n            default:\n        \
    \        break;\n        }\n    }", "{\n    auto space_position = text.find('\
    \ ');\n    while(space_position != string::npos)\n    {\n        if(space_position\
    \ > 2)\n        {\n            string result = text;\n            for(auto i :\
    \ std.range::view::reverse(string::view(_text, space_position + 1, space_position\
    \ + 2)))\n            {\n                result = result.replace(space_position\
    \ + 1, 1, \"_\");\n            }\n            text = result;\n        }\n    \
    \    else\n        {\n            string result = text;\n            for(auto\
    \ i : std.range::view::reverse(string::view(_text, space_position + 1, space_position\
    \ + 1)))\n            {\n                result = result.replace(space_position\
    \ + 1, 1, \"_\");\n            }\n            text = result;\n        }\n    \
    \    space_position = text.find(' ', space_position);\n    }\n    return text;\n\
    }", "{\n    //assert(text != null);\n    \n    size_t length = text.length();\n\
    \    \n    string result = text;\n    \n    for (int i = 0; i < length; ++i)\n\
    \    {\n        char c = result[i];\n        \n        if (c != ' ')\n       \
    \ {\n            result[i] = '_';\n        }\n    }\n    \n    int i = length\
    \ - 1;\n    \n    while (i >= 0 && result[i] == ' ')\n    {\n        result[i]\
    \ = '_';\n        --i;\n    }\n    \n    return result;\n}", "{\n    size_t len\
    \ = length(text);\n    size_t i = 0, j = 0, k;\n    \n    while (i < len) {\n\
    \        \n        for (j = i; j < len; j++)\n            if (text[j] == ' ')\
    \ {\n                for (k = j; k < len; k++) \n                    text[k] =\
    \ '_';\n                i = j + 1;\n                break;\n            }\n  \
    \      \n        if (i == j) \n            break;\n        \n        if (j - i\
    \ != 2)\n            break;\n        \n        for (k = j - 1; k >= i; k--) \n\
    \            text[k] = '_';\n        i = j + 1;\n    }\n    \n    return text;\n\
    }", "{\n    for(int i = 0; i < text.length(); i++) {\n        if(text[i] == '\
    \ ') {\n            for(int j = i+1; j < text.length(); j++) {\n             \
    \   if(text[j] == ' ') {\n                    text[i] = '_';\n               \
    \     text[j] = '_';\n                    i--;\n                    j--;\n   \
    \             }\n            }\n        }\n    }\n    \n    for(int i = 0; i <\
    \ text.length(); i++) {\n        if(text[i] == ' ') {\n            if(i+1 < text.length()\
    \ && (i+1 < text.length() || text[i+1] != ' ')) {\n                text[i] = '_';\n\
    \                i++;\n            }\n        }\n    }", "{\n    auto spaces =\
    \ text.find_first_of(' ');\n    while(spaces != string::npos)\n    {\n       \
    \ // check if there are more than one consecutive spaces\n        if(text.find_first_not_of('\
    \ ') == spaces)\n        {\n            auto last = text.find_last_not_of(' ');\n\
    \            string fixed = text.substr(0, last);\n            fixed += \"-\"\
    ;\n            string rest = text.substr(spaces, text.length() - spaces);\n  \
    \          text += fixed;\n            spaces = text.find_first_of(' ');\n   \
    \     }\n        else\n        {\n            text += \"_\";\n            spaces\
    \ = text.find_first_of(' ');\n        }\n    }\n    return text;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 tags=c++,string,algorithm |>\nHere is my approach\
    \ to the problem:\n<code>\n#include <iostream>\n#include <string>\n#include <sstream>\n\
    #include <vector>", "{\n    int i, lastSpaceIndex = text.find_first_of(\" \");\n\
    \    while (lastSpaceIndex != string::npos) {\n        // Replace the first space\
    \ with the _\n        // and delete one space from the end \n        text = text.substr(0,lastSpaceIndex)\
    \ + \"_\" + text.substr(lastSpaceIndex+1);\n        \n        lastSpaceIndex =\
    \ text.find_first_of(\" \",lastSpaceIndex+1);\n    }\n    return text;\n}", "{\n\
    \  int count = 0;\n  for (int i = 0; i < text.size(); i++) \n  {\n    if (text[i]\
    \ == ' ') \n    {\n      count++;\n      if (count == 2) \n      {\n        text[i]\
    \ = '_';\n      }\n      else if (count > 2) \n      {\n        for (j = i + 1;\
    \ j < text.size(); j++) \n        {\n          if (text[j] == ' ') \n        \
    \  {\n            text[j] = '_';\n            break;\n          }\n        }\n\
    \      }\n    }\n  }\n  return text;\n}", "{\n    int i = 0;\n    for(i = 0; i\
    \ < text.size(); i++)\n    {\n        if(text[i] == ' ')\n        {\n        \
    \    if(!(i + 1 < text.size() \n                && text[i + 1] == ' '))\n    \
    \        {\n                text[i] = '-';\n            }\n            else\n\
    \            {\n                text[i] = '_';\n            }\n        }\n   \
    \ }\n    return text;\n}", "{\n    size_t start_pos = 0;\n    size_t end_pos =\
    \ 0;\n    size_t start_space = 0;\n    size_t end_space = 0;\n    size_t space_count\
    \ = 0;\n    string result = \"\";\n    for (size_t i = 0;  i < text.length();\
    \  ++i) {\n        switch (text[i])\n        {\n            case ' ':\n      \
    \          end_space = i;\n                end_pos = i + 1;\n                space_count\
    \ = space_count + 1;\n                break;\n            case '.':\n        \
    \        if (end_space == 0)\n                    result += &text[start_pos];\n\
    \                break;\n            default:\n                start_space = i;\n\
    \                start_pos = i + 1;\n                space_count = 0;\n      \
    \          break;\n        }\n        if (space_count > 1) {\n            result\
    \ += \"-\";\n            space_count = 0;\n        }\n    }\n    \n    if (end_space\
    \ > 0)\n        result += &text[end_pos];\n    \n    return result;\n}\n/*\n \
    \   \n    This function will replace all multiple underscores with a single \n\
    \    space. ", "{\n    if(text.length() == 0)\n        return text;\n    \n  \
    \  int i = 0;\n    int j = 0;\n    \n    while (i < text.length() && j < 2)\n\
    \    {\n        if(isspace(text[i]))\n            i++;\n        else\n       \
    \ {\n            while(isspace(text[i]))\n                i++;\n            while(j\
    \ < 2 && text[i] == ' ')\n                i++;\n            j++;\n           \
    \ while(j > 0 && isspace(text[i]))\n                i++;\n            while(j\
    \ < 2 && text[i] == ' ')\n                i++;\n            j--;\n           \
    \ while(j > 0 && isspace(text[i]))\n                i++;\n        }\n    }\n \
    \   \n    while(j < 2)\n    {\n        string temp = text;\n        j = j - 1;\n\
    \        while(text[i] == ' ')\n            i++;\n        temp = temp.replace(text.substr(i,\
    \ j), \"\");\n        string temp2 = text;\n        temp2 = temp2.replace(text.substr(i,\
    \ j), \"\");\n        temp = temp + temp2;\n        text = temp;\n    }\n    \n\
    \    return text;\n}", "{\n    if(text.length() == 0)\n        return text;\n\
    \    int spaceIndex = text.find(' ');\n    if(spaceIndex > -1)\n    {\n      \
    \  int nextSpaceIndex = text.find(' ', spaceIndex);\n        if(nextSpaceIndex\
    \ > -1)\n            text = text.substr(0, spaceIndex) + text.substr(nextSpaceIndex).replaceAll(\"\
    \ \", \"_\");\n    }\n    return text;\n}\n/*", "{\n    for(int i = 0; i < text.size();\
    \ ++i)\n    {\n        if(text[i] == ' ')\n        {\n            text[i] = '_';\n\
    \        }\n        if(text[i] == ' ')\n        {\n            text[i] = '_';\n\
    \        }\n    }\n    return text;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    You should put a space after the `+` operator (`text += ` would also work), otherwise\
    \ the += operator will return the old value instead of updating it in-place.\n\
    <|/ c |>\n<| c |>\nThe assignment operator returns what it assigns because that's\
    \ what the assignment operator does. So why would it be wrong?\n<|/ c |>\n<| c\
    \ |>\nBecause the `+=` operator returns the value of the left-hand-side expression,\
    \ and it's perfectly fine to assign the return value to something else, so it\
    \ is perfectly fine to do it this way. But it would be a very bad idea to do it\
    \ any other way.\n<|/ c |>\n<| a |>\nI believe you're looking for String::replace\n\
    <code>\nstring.replace(\" \",\"_\",\"Example\")\n</code>\n<|/ a tags=string,c++\
    \ dscore=1 |>\n<| c |>\nNot quite. As shown in the example code above, I want\
    \ to replace the spaces with underscores regardless of where they occur in the\
    \ string. ", "{\n    string result = \"\";\n    for(int i = 0; i < text.size();\
    \ ++i)\n    {\n        if(text[i] == ' ')\n        {\n            result += text[i];\n\
    \        }\n        else \n        {\n            result += '_';\n        }\n\
    \    }\n    if (result.size() > 2) \n    {\n        for(int i = result.size()-2;\
    \ i > 0; --i) \n        {\n            if (result[i] != ' ') \n            {\n\
    \                break;\n            }\n            else\n            {\n    \
    \            result += result[i-1];\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n    string result = \"\";", "{\n  int length = text.length();\n\
    \  if (length == 0) \n    return \"\";\n  \n  string result = \"\";\n  \n  for\
    \ (int i = 0; i < length; i++) \n  {\n    char c = text[i];\n    if ( c == ' '\
    \ ) \n    {\n      result += c;\n      result += '_';\n    }\n    else if (c ==\
    \ ' ' && i > 0 && text[i - 1] == ' ') \n    {\n      result += '-';\n    }\n \
    \ }\n  \n  return result;\n}", "{\n  text = replace_all(text, \" \", \"_\");\n\
    \  text = replace(text, \" \", \"_\");\n  text = replace(text, \"  \", \"_\");\n\
    \  text = replace_all(text, \" \", \"-\");\n  text = replace(text, \" \", \"-\"\
    );\n  text = replace(text, \"  \", \"-\");\n  return text;\n}", "{\n    size_t\
    \ space_index = 0;\n    size_t replaced_space_index = 0;\n    size_t consecutive_spaces\
    \ = 0;\n    \n    // Find how many spaces there are in the string\n    while (text.length()\
    \ > space_index)\n    {\n        if (text.at(space_index) == ' ') \n        {\n\
    \            space_index++;\n        }\n        else \n        {\n           \
    \ space_index = 0;\n        }\n    }\n    \n    while (space_index < text.length())\n\
    \    {\n        if (text.at(space_index) == ' ')\n        {\n            if (consecutive_spaces\
    \ > 1)\n            {\n                replace(replaced_space_index,\n       \
    \                 text.length() - space_index,\n                        text.at(replaced_space_index),\n\
    \                        ' ');\n                consecutive_spaces--;\n      \
    \      }\n            else\n            {\n                replace(replaced_space_index,\n\
    \                        text.length() - space_index,\n                      \
    \  text.at(replaced_space_index),\n                        '_');\n           \
    \     consecutive_spaces = 2;\n            }\n            replaced_space_index++;\n\
    \            space_index++;\n        }\n        else\n        {\n            replaced_space_index++;\n\
    \            consecutive_spaces++;\n        }\n    }\n    \n    return text;\n\
    }\n</code>\n<|/ a dscore=0 tags=string,c++,stl,replace,algorithm |>\n<| a dscore=0\
    \ tags=string,c++,stl,replace,algorithm |>\nIf you're looking for a generic replace-all\
    \ function - and you don't care about the length of the string - you can use something\
    \ like this:\n<code>", "{\n\tsize_t i, j;\n\tsize_t len = text.size();\n\t\n\t\
    for(i = 0; i < len; i++)\n\t{\n\t\tchar c = text[i];\n\t\t\n\t\tif(c == ' ') {\n\
    \t\t\tfor(j = i + 1; j < len; ++j)\n\t\t\t\tif(text[j] == ' ')\n\t\t\t\t\ttext[j]\
    \ = '-';\n\t\t}\n\t}\n\t\n\treturn text;\n}", "{\n  auto it = text.rbegin(); \n\
    \  auto end = text.rend();\n  auto next = it;\n  \n  for (; it != end; ++it, ++next)\
    \ \n  {\n    string r = string((*it).begin(), (*it).end());\n    if (r.size()\
    \ > 2) \n    {\n      r.erase(std::remove(r.begin(), r.end(), ' '), r.end());\n\
    \    }\n    else \n    {\n      r.insert(r.end(), '_');\n    }\n    \n    *next\
    \ = r;\n  }\n  \n  return text;\n}", "{\n    int len = text.length();\n    bool\
    \ hasSpace = false;\n    for (int i=0; i < len; ++i)\n    {\n        char c =\
    \ text[i];\n        if (c == ' ')\n        {\n            hasSpace = true;\n \
    \       }\n        else if ((i == 0) || ((hasSpace && c == ' '))) \n        {\n\
    \            if (c != ' ')\n                text += '_';\n        }\n    }\n \
    \   return text;\n}", "{\n    for(auto i : text)\n    {\n        if(i != ' ')\
    \ \n        {\n            for(auto j : text) \n            {\n              \
    \  if(j == ' ')\n                {\n                    text.insert(i, j, '_');\n\
    \                    text.erase(i, i + 1);\n                }\n            }\n\
    \        }\n    }\n    \n    if(!text.empty() && text.back() == ' ')\n    {\n\
    \        text.push_back('_');\n    }\n    \n    return text;\n}\n/*", "{\n   \
    \ for(int i=0; i<text.size(); ++i)\n    {\n        if(text[i] == ' ') \n     \
    \   {\n            text.swap(i,i+1);\n            text.swap(i,i+2);\n        }\n\
    \    }\n    return text;\n}", "{\n    for(int i = 0; i < text.length(); i++)\n\
    \    {\n        if(text[i] == ' ')\n        {\n            for(int j = i; j <\
    \ text.length(); j++)\n            {\n                if(text[j] == ' ')\n   \
    \             {\n                    text[j] = '_';\n                }\n     \
    \       }\n        }\n    }\n    \n    for(int i = 0; i < text.length(); i++)\n\
    \    {\n        if(text[i] == ' ')\n        {\n            for(int j = i; j <\
    \ text.length(); j++)\n            {\n                if(text[j] != ' ')\n   \
    \             {\n                    break;\n                }\n            }\n\
    \            \n            for(int j = i; j < text.length(); j++)\n          \
    \  {\n                if(text[j] == ' ')\n                {\n                \
    \    text[j] = '_';\n                }\n            }\n        }\n    }\n    \n\
    \    return text;\n}", "{\n    string result = text;\n    for(int i = 0; i < result.length();\
    \ i++)\n    {\n        char c = result[i];\n        if(!isspace(c))\n        {\n\
    \            result[i] = '_';\n        }\n    }\n    for(int i = 0; i < result.length();\
    \ i++)\n    {\n        char c = result[i];\n        if(c == ' ')\n        {\n\
    \            int j = i + 1;\n            while(j < result.length())\n        \
    \    {\n                if(result[j] == ' ')\n                {\n            \
    \        result[j] = '_';\n                }\n                j++;\n         \
    \   }\n        }\n    }\n    int count = 1;\n    for(int i = 0; i < result.length();\
    \ i++)\n    {\n        if(result[i] == '_')\n        {\n            count++;\n\
    \        }\n        else\n        {\n            break;\n        }\n    }\n  \
    \  string ret = \"_\";\n    if(count == 1)\n    {\n        ret = result;\n   \
    \ }\n    else\n    {\n        for(int i = 0; i < result.length(); i++)\n     \
    \   {\n            if(result[i] == '_')\n            {\n                result[i]\
    \ = '_' + count;\n                count++;\n            }\n        }\n       \
    \ ret = result;\n    }\n    return ret;\n}", "{\n    for(int i = 0; i < text.size();\
    \ ++i)\n    {\n        char c = text[i];\n        if(c == ' ' && text.size() >\
    \ i + 1 && text[i + 1] == ' ')\n        {\n            text[i] = '_';\n      \
    \  }\n    }\n    \n    for(int i = 0; i < text.size() - 1; ++i)\n    {\n     \
    \   char c = text[i];\n        if(c == ' ')\n        {\n            if(i + 1 <\
    \ text.size() && text[i + 1] == ' ')\n            {\n                text[i] =\
    \ '_';\n                text[i + 1] = '-';\n            }\n        }\n    }\n\
    \    \n    return text;\n}", "{\n    // Remove all spaces first\n    text.erase(remove(text.begin(),\
    \ text.end(), ' '), text.end());\n    \n    // If there are more than two spaces,\
    \ remove all but the last two \n    // spaces \n    if(text.size() > 2)\n    \
    \    text.erase(remove(text.begin(), text.end(), ' '), text.end() - 2);\n    \
    \    \n    // Return text\n    return text;\n}", "{\n    size_t len = text.length();\n\
    \    \n    size_t space_idx = 0, back_idx = 0;\n    \n    while (space_idx < len)\
    \ {\n        auto c = text[space_idx];\n        \n        if (c == ' ') \n   \
    \     {\n            back_idx = space_idx;\n            space_idx++;\n       \
    \ } \n        else \n        {\n            space_idx = back_idx;\n        }\n\
    \        \n        if (space_idx < len) \n            back_idx++;\n    }\n   \
    \ \n    auto result = \"\";\n    \n    while (space_idx < len) {\n        auto\
    \ c = text[space_idx];\n        \n        if (c == ' ') \n        {\n        \
    \    result += \"_\";\n            space_idx++;\n        } \n        else \n \
    \       {\n            result += c;\n            space_idx++;\n        }\n   \
    \ }\n    \n    return result;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis solution\
    \ is incorrect, if there is a word that has a space in it, then it is considered\
    \ a space by `fix_spaces` as well, but after that it is just a space and `fix_spaces`\
    \ will not find any more spaces. Example: \"Happy Days 2016\" becomes Happy_Days_2016\
    \ and then _2016, so the function will not find any more spaces.\n<|/ c |>\n<|\
    \ c |>\nI wrote this for someone else who needed it and it worked for me - I thought\
    \ it was worth posting.\n<|/ c |>\n<| c |>\nI do not understand. How do you know\
    \ when to stop splitting? What is the logic that would allow you to split this\
    \ sentence into two sentences?\n<|/ c |>\n<| c |>\nThe example I gave was for\
    \ one sentence that had no spaces, but I added a second example where this wouldn't\
    \ work. So I added a third example.\n<|/ c |>\n<| a tags=string,c++ |>\n<code>\n\
    #include <iostream>\n#include <string>\n#include <algorithm>", "{\n    bool replaced\
    \ = false;\n    int i = 0;\n    int j = text.length() - 1;\n    int count = 0;\n\
    \    \n    while (!replaced) {\n        if (i == j) \n            break;\n   \
    \     if (text[i] == ' ') {\n            count++;\n        }\n        else if\
    \ (text[i] == text[j]) {\n            count--;\n        }\n        else if (count\
    \ > 2) {\n            replaced = true;\n            i++;\n        }\n        else\
    \ if (count < 2) {\n            replaced = true;\n            j--;\n        }\n\
    \    }\n    \n    if (replaced) {\n        int k = i;\n        while (i != j)\
    \ {\n            text[k++] = text[i];\n            i++;\n        }\n        text.length\
    \ = k;\n    }\n    \n    return text;\n}", "{\n    \n    foreach(char,text)\n\
    \    {\n        if(char == ' ')\n            text += \"_\";\n        else\n  \
    \          text += char;\n    }\n    \n    if(text.find(\"  \")!=string::npos)\n\
    \    {\n        for(int i = 2; i <= text.find(\"  \")-1; i++)\n            text\
    \ += \"-\";\n    }\n    \n    return text;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
