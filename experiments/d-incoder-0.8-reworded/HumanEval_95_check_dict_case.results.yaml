language: d
name: HumanEval_95_check_dict_case
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key key, value dict) \n    {\n        bool is_string\
    \ = (value ?? \"\").length == 0;\n        if (!is_string)\n        {\n       \
    \     auto lower_string = value.toCString();\n            auto upper_string =\
    \ lower_string.upcase();\n            if (key != upper_string)\n            {\n\
    \                return false;\n            }\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8fp5gz0a.d(23): Error: found \'')\'' when expecting \'';\''\n/tmp/tmp8fp5gz0a.d(25):
    Error: expression expected, not \''?\''\n/tmp/tmp8fp5gz0a.d(25): Error: found
    \''""\'' when expecting \'':\''\n/tmp/tmp8fp5gz0a.d(25): Error: expression expected,
    not \'')\''\n/tmp/tmp8fp5gz0a.d(25): Error: found \'';\'' when expecting \'')\''\n/tmp/tmp8fp5gz0a.d(26):
    Error: semicolon expected, not \''if\''\n/tmp/tmp8fp5gz0a.d(36): Error: found
    \''return\'' when expecting \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp8fp5gz0a.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    var n = 0;\n    var first = true;\n    for (var v in dict)\n\
    \    {\n        if (v is int)\n        {\n            if (first)\n           \
    \ {\n                first = false;\n                continue;\n            }\n\
    \            n++;\n        }\n        else if (v is string)\n        {\n     \
    \       if (first)\n            {\n                first = false;\n          \
    \      continue;\n            }\n            n++;\n        }\n        else\n \
    \       {\n            return false;\n        }\n    }\n    if (n == 0)\n    {\n\
    \        return true;\n    }\n    else\n    {\n        return false;\n    }\n\
    }\n\"\"\"\n</cell>\n<text>\nis_valid_int\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4dqy54p9.d(25): Error: semicolon expected, not \''in\''\n/tmp/tmp4dqy54p9.d(25):
    Error: expression expected, not \''in\''\n/tmp/tmp4dqy54p9.d(25): Error: found
    \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmp4dqy54p9.d(27):
    Error: found \'')\'' when expecting \''.\'' following int\n/tmp/tmp4dqy54p9.d(28):
    Error: found \''{\'' when expecting identifier following \''int.\''\n/tmp/tmp4dqy54p9.d(29):
    Error: found \''if\'' when expecting \'')\''\n/tmp/tmp4dqy54p9.d(34): Error: found
    \''n\'' when expecting \'';\'' following statement\n/tmp/tmp4dqy54p9.d(34): Error:
    expression expected, not \'';\''\n/tmp/tmp4dqy54p9.d(35): Error: found \''}\''
    when expecting \'';\'' following statement\n/tmp/tmp4dqy54p9.d(36): Error: found
    \''else\'' instead of statement\n/tmp/tmp4dqy54p9.d(45): Error: Declaration expected,
    not \''else\''\n/tmp/tmp4dqy54p9.d(48): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4dqy54p9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        bool strcase = is(lower(k),\
    \ lower(v));\n        bool strupper = is(upper(k), upper(v));\n        if(!strcase\
    \ && !strupper) return false; // return false is empty \n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnn5vp450.d(23): Error: no identifier for declarator v\n/tmp/tmpnn5vp450.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpnn5vp450.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmpnn5vp450.d(23): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmpnn5vp450.d(25): Error: function declaration without return type.
    (Note that constructors are always named \''this\'')\n/tmp/tmpnn5vp450.d(25):
    Error: found \'',\'' when expecting \'')\''\n/tmp/tmpnn5vp450.d(25): Error: semicolon
    expected, not \''lower\''\n/tmp/tmpnn5vp450.d(25): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmpnn5vp450.d(26): Error: function declaration
    without return type. (Note that constructors are always named \''this\'')\n/tmp/tmpnn5vp450.d(26):
    Error: found \'',\'' when expecting \'')\''\n/tmp/tmpnn5vp450.d(26): Error: semicolon
    expected, not \''upper\''\n/tmp/tmpnn5vp450.d(26): Error: found \'')\'' when expecting
    \'';\'' following statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnn5vp450.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull)\n    {\n        throw new Exception(\"invalid\
    \ empty dict\");\n    }\n    KeyValuePair!(string, string) kv;\n    for (KeyValuePair!(const\
    \ string& key, const string& val) in dict)\n    {\n        if (!isLower(key))\n\
    \        {\n            return false;\n        }\n        if (!isUpper(key))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptsm3mmfi.d(28): Error: (arguments) expected following const(string)\n/tmp/tmptsm3mmfi.d(28):
    Error: (arguments) expected following const(string)\n/tmp/tmptsm3mmfi.d(28): Error:
    found \'')\'' when expecting \'';\'' following statement\n/tmp/tmptsm3mmfi.d(39):
    Error: found \''return\'' when expecting \'';\'' following for condition\n/tmp/tmptsm3mmfi.d(39):
    Error: found \'';\'' when expecting \'')\''\n/tmp/tmptsm3mmfi.d(40): Error: found
    \''}\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptsm3mmfi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !(dict.len() == 0);\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm9vldqid.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v: dict)\n    {\n        if(v.isNull)\n        {\n\
    \            return false;\n        }\n        if(!v.asString().isLower())\n \
    \       {\n            return false;\n        }\n    }\n    \n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvc9ilivn.d(23): Error: no identifier for declarator v\n/tmp/tmpvc9ilivn.d(23):
    Error: found \'':\'' when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpvc9ilivn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.isNull;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq0seq92w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict.length == 0) \n        return true;\n    \n    auto it\
    \ = dict.begin();\n    auto itEnd = dict.end();\n    \n    for(; it != itEnd;\
    \ ++it)\n    {\n        if(it.key.islower() != it.value.islower())\n         \
    \   return false;\n    }\n    \n    for(; it != itEnd; ++it)\n    {\n        if(it.key.isupper()\
    \ != it.value.isupper())\n            return false;\n    }\n    \n    return true;\n\
    }\n\"\"\"\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe7g24_vg.d(43): Error: Declaration expected, not \''""\''\n/tmp/tmpe7g24_vg.d(53):
    Error: unterminated string constant starting at /tmp/tmpe7g24_vg.d(53)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe7g24_vg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int i = 0;\n    while (!is_null(dict[i]))\n    {\n        if\
    \ (!is_null(dict[i]))\n        {\n            if (dict[i].islower())\n       \
    \         return false;\n            else if (dict[i].isupper())\n           \
    \     return false;\n        }\n        ++i;\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpibiduzpe.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  int count = 0;\n  for (auto it : dict) {\n    string key = it.first.as_string();\n\
    \    string val = it.second.as_string();\n    if (key == \"State\" || key == \"\
    Zip\")\n      count++;\n    else if (key == \"Name\" || key == \"Age\")\n    \
    \  count++;\n  }\n  if (count == 0) {\n    return true;\n  } else {\n    return\
    \ false;\n  }\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsry2gtyy.d(24): Error: no identifier for declarator it\n/tmp/tmpsry2gtyy.d(24):
    Error: expression expected, not \'':\''\n/tmp/tmpsry2gtyy.d(24): Error: found
    \''dict\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpsry2gtyy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(key in dict) {\n        if(!key.key.hasCaseInsensitive())\
    \ {\n            return false;\n        }\n        if(!key.value.hasCaseInsensitive())\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    This has the additional advantage that you can easily test if the given value\
    \ is nullable or not.\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0l_tv5pv.d(23): Error: no identifier for declarator key\n/tmp/tmp0l_tv5pv.d(23):
    Error: found \''in\'' when expecting \'';\''\n/tmp/tmp0l_tv5pv.d(33): Error: Declaration
    expected, not \''<\''\n/tmp/tmp0l_tv5pv.d(40): Error: Declaration expected, not
    \''assert\''\n/tmp/tmp0l_tv5pv.d(41): Error: Declaration expected, not \''assert\''\n/tmp/tmp0l_tv5pv.d(42):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp0l_tv5pv.d(43): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp0l_tv5pv.d(44): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp0l_tv5pv.d(45): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp0l_tv5pv.d(46): Error: Declaration expected, not \''assert\''\n/tmp/tmp0l_tv5pv.d(47):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0l_tv5pv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return is(dict.keys);\n}\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm5ppps39.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull)\n    {\n        return false;\n    }\n    var\
    \ keys = dict.getKeys();\n    for (var i = 0, len = keys.size(); i < len; ++i)\n\
    \    {\n        string key = keys[i];\n        if (key.isLower())\n        {\n\
    \            return true;\n        }\n        if (key.isUpper())\n        {\n\
    \            return true;\n        }\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjjb627ao.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null) {\n        return false;\n    }\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps01rg1az.d(26): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps01rg1az.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    // TODO: implement\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppccpdvaa.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for (auto key : dict)\n    {\n        auto key_case = key.key();\n\
    \        if (key_case != key_case.toLower())\n            return false;\n    }\n\
    \    return true;\n}\n</code>\n<|/ a tags=d,static-methods,associative-array,dictionary\
    \ |>\n<| a dscore=2 tags=d,static-methods,associative-array,dictionary |>\nWith\
    \ DMD and std.algorithm.search, it's very simple:\n<code>\nimport std.algorithm;\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphd7a2g1w.d(23): Error: no identifier for declarator key\n/tmp/tmphd7a2g1w.d(23):
    Error: expression expected, not \'':\''\n/tmp/tmphd7a2g1w.d(23): Error: found
    \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmphd7a2g1w.d(31):
    Error: Declaration expected, not \''<\''\n/tmp/tmphd7a2g1w.d(34): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphd7a2g1w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !is_null(dict);\n}\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjtap3gn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    var _case = dict[\"A\"] == null && dict[\"B\"] == null && dict[\"\
    C\"] == null;\n    return _case;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqtdqd92t.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    forall key in dict[string]\n        if\n            not(isLower(key)\
    \ || isUpper(key))\n        then \n            false\n        else \n        \
    \    true\n}\n\"\"\")\n    return CheckDict({\n        \"nullable\": Nullable(lambda\
    \ key: len(key) == 0)\n    })\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphdnx1qfn.d(23): Error: semicolon expected, not \''in\''\n/tmp/tmphdnx1qfn.d(23):
    Error: found \''in\'' instead of statement\n/tmp/tmphdnx1qfn.d(31): Error: Declaration
    expected, not \''""\''\n/tmp/tmphdnx1qfn.d(44): Error: unterminated string constant
    starting at /tmp/tmphdnx1qfn.d(44)\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmphdnx1qfn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(auto kv : dict)\n    {\n        if(kv.first().length != kv.second().length())\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </cell>\n<cell>\n// Test\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpr6hi2irn.d(23): Error: no identifier for declarator kv\n/tmp/tmpr6hi2irn.d(23):
    Error: expression expected, not \'':\''\n/tmp/tmpr6hi2irn.d(23): Error: found
    \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmpr6hi2irn.d(32):
    Error: Declaration expected, not \''<\''\n/tmp/tmpr6hi2irn.d(39): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpr6hi2irn.d(40): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpr6hi2irn.d(41): Error: Declaration expected, not \''assert\''\n/tmp/tmpr6hi2irn.d(42):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpr6hi2irn.d(43): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpr6hi2irn.d(44): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpr6hi2irn.d(45): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpr6hi2irn.d(46): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr6hi2irn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, val) in dict do\n    {\n        bool result = toLower(key)\
    \ == toLower(val);\n        if (!result)\n            return false;\n    }\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe0ph990o.d(23): Error: no identifier for declarator val\n/tmp/tmpe0ph990o.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpe0ph990o.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmpe0ph990o.d(23): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmpe0ph990o.d(29): Error: found \''unittest\'' when expecting \''while\''\n/tmp/tmpe0ph990o.d(30):
    Error: found \''{\'' when expecting \''(\''\n/tmp/tmpe0ph990o.d(31): Error: expression
    expected, not \''alias\''\n/tmp/tmpe0ph990o.d(31): Error: found \''candidate\''
    when expecting \'')\''\n/tmp/tmpe0ph990o.d(31): Deprecation: do-while statement
    without terminating ; is deprecated\n/tmp/tmpe0ph990o.d(31): Error: found \''=\''
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe0ph990o.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k in dict) \n    {\n        bool is_upper = k.getString().getChar(0)\
    \ >= 'A' && k.getString().getChar(0) <= 'Z';\n        if(!is_upper) \n       \
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpapi4va4_.d(23): Error: no identifier for declarator k\n/tmp/tmpapi4va4_.d(23):
    Error: found \''in\'' when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpapi4va4_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool flag = false;\n        if(!dict?[k])\
    \ \n        {\n            flag = true;\n        }\n        else if(!dict?[k].isUppercase)\
    \ \n        {\n            flag = true;\n        }\n        if(flag)\n       \
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nTo make it more clear to understand I created\
    \ the following function, which takes array of associative array and checks if\
    \ all the keys are lowercase\n<code>\nimport std.algorithm; \nimport std.array;\n\
    import std.conv;\nimport std.conv;\nimport std.string;\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv6nsgidr.d(23): Error: no identifier for declarator v\n/tmp/tmpv6nsgidr.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpv6nsgidr.d(26): Error: found
    \'')\'' when expecting \'':\''\n/tmp/tmpv6nsgidr.d(30): Error: found \''else\''
    when expecting \'')\''\n/tmp/tmpv6nsgidr.d(30): Error: found \'')\'' when expecting
    \'':\''\n/tmp/tmpv6nsgidr.d(34): Error: found \''if\'' when expecting \'')\''\n/tmp/tmpv6nsgidr.d(38):
    Error: found \''}\'' when expecting \'';\'' following statement\n/tmp/tmpv6nsgidr.d(41):
    Error: expression expected, not \''/\''\n/tmp/tmpv6nsgidr.d(41): Error: found
    \''code\'' when expecting \'')\''\n/tmp/tmpv6nsgidr.d(41): Error: found \''>\''
    instead of statement\n/tmp/tmpv6nsgidr.d(51): Error: found \''unittest\'' instead
    of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6nsgidr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(Keys key: dict)\n    {\n        if(!(isInfix(key) && isCaseInsensitive(key)))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nYou can write a simple function\
    \ to check the existence of any key in a dictionary:\n<code>\ndef exist(dict,\
    \ key)\n    dict.has_key?(key)\nend\n</code>\n<|/ a tags=null,ruby,hash |>\n<|\
    \ a dscore=2 tags=null,ruby,hash |>\nUsing Ruby 2.5.x, you can use the Hash#key?\
    \ method.\n<code>\nd = { \"a\" => 1, 2 => 3 }\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppnb7jy2w.d(23): Error: found \''key\'' when expecting \'';\''
    following statement\n/tmp/tmppnb7jy2w.d(23): Error: expression expected, not \'':\''\n/tmp/tmppnb7jy2w.d(23):
    Error: found \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmppnb7jy2w.d(32):
    Error: Declaration expected, not \''<\''\n/tmp/tmppnb7jy2w.d(50): Error: Declaration
    expected, not \''assert\''\n/tmp/tmppnb7jy2w.d(51): Error: Declaration expected,
    not \''assert\''\n/tmp/tmppnb7jy2w.d(52): Error: Declaration expected, not \''assert\''\n/tmp/tmppnb7jy2w.d(53):
    Error: Declaration expected, not \''assert\''\n/tmp/tmppnb7jy2w.d(54): Error:
    Declaration expected, not \''assert\''\n/tmp/tmppnb7jy2w.d(55): Error: Declaration
    expected, not \''assert\''\n/tmp/tmppnb7jy2w.d(56): Error: Declaration expected,
    not \''assert\''\n/tmp/tmppnb7jy2w.d(57): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppnb7jy2w.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return true;\n    auto dict_of_strings = dict.asMap();\n\
    \    for (auto pair : dict_of_strings) {\n        if (!pair.second.isString) \n\
    \            return false;\n        if (pair.second.asString().length() != 1)\
    \ \n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt3almvji.d(25): Error: no identifier for declarator pair\n/tmp/tmpt3almvji.d(25):
    Error: expression expected, not \'':\''\n/tmp/tmpt3almvji.d(25): Error: found
    \''dict_of_strings\'' when expecting \'';\'' following for condition\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt3almvji.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.isEmpty && dict.keys.all(key => \n        {\n  \
    \          if (toLower(key).equals(toLower(toUpper(key))))\n                return\
    \ true;\n            else\n                return false;\n        });\n}\n</code>\n\
    <|/ a tags=swift dscore=3 |>\n<| a dscore=3 tags=swift |>\nUsing Swift 4.2\n<code>\n\
    func isNullable<Value: Hashable, HashableKey>(fromDictionary dictionary: [HashableKey:\
    \ Value?]) -> (Bool, Dictionary<HashableKey, Value>?) {\n    guard let keys =\
    \ dictionary.keys,\n        keys.contains(where: { $0.hashValue == HashableKey.hashValue\
    \ }),\n        let lastKey = keys.last,\n        let lastValue: Value = dictionary[keys.last!]\
    \ else {\n            return (true, nil)\n    }\n    guard let firstValue = dictionary[keys.first!]\
    \ else {\n        return (true, Dictionary<HashableKey, Value>(nil))\n    }\n\
    \    return (true, Dictionary<HashableKey, Value>([lastKey : lastValue, firstKey\
    \ : firstValue]))\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nHere is a simple solution\
    \ based on Antonio's answer. It avoids using a dictionary at all as it is just\
    \ a key-value pair array.\n<code>\nfunc isNullable<Value: Hashable, HashableKey>(fromDictionary\
    \ dictionary: [HashableKey: Value?]) -> (Bool, Dictionary<HashableKey, Value>?)\
    \ {\n    guard let keys = dictionary.keys,\n        keys.contains(where: { $0.hashValue\
    \ == HashableKey.hashValue }),\n        let lastKey = keys.last,\n        let\
    \ lastValue: Value = dictionary[keys.last!] else {\n            return (true,\
    \ nil)\n    }\n    guard let firstValue = dictionary[keys.first!] else {\n   \
    \     return (true, Dictionary<HashableKey, Value>(nil))\n    }\n    return (true,\
    \ Dictionary<HashableKey, Value>([lastKey : lastValue, firstKey : firstValue]))\n\
    }\n</code>\n<|/ a tags=swift |>\n<| a dscore=1 tags=swift |>\n<code>\nfunc isNullable<Value:\
    \ Hashable>(fromDictionary dictionary: [Value : Value?]) -> (Bool, Dictionary<Value,\
    \ Value>?) {\n    let values = dictionary.values.filter({ $0 == nil })\n    return\
    \ (values.isEmpty, values != nil && Dictionary <Value, Value>(dictionary: dictionary.map\
    \ {\n        (_, value) -> Value in (value: $0, value: value)\n    }))\n\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpie4cugo9.d(31): Error: Declaration expected, not \''<\''\n/tmp/tmpie4cugo9.d(51):
    Error: unterminated character constant\n/tmp/tmpie4cugo9.d(79): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpie4cugo9.d(80): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpie4cugo9.d(81): Error: Declaration expected, not \''assert\''\n/tmp/tmpie4cugo9.d(82):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpie4cugo9.d(83): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpie4cugo9.d(84): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpie4cugo9.d(85): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpie4cugo9.d(86): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpie4cugo9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if( !dict.isNotNull() )\n    {\n        return false;\n    }\n\
    \    \n    // If dict is empty all keys must be in lower case.\n    // If dict\
    \ is empty all keys must be in upper case.\n    foreach( k : dict.keys() )\n \
    \   {\n        if( !string_compare(k.as_string(), k.as_string().to_lowercase())\
    \ )\n        {\n            return false;\n        }\n        if( !string_compare(k.as_string(),\
    \ k.as_string().to_uppercase()) )\n        {\n            return false;\n    \
    \    }\n    }\n    \n    return true;\n}\n\"\"\"\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkgaoqjjw.d(30): Error: no identifier for declarator k\n/tmp/tmpkgaoqjjw.d(30):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpkgaoqjjw.d(44): Error: Declaration
    expected, not \''""\''\n/tmp/tmpkgaoqjjw.d(55): Error: unterminated string constant
    starting at /tmp/tmpkgaoqjjw.d(55)\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpkgaoqjjw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, val) in dict {\n        if (!(is_string(key) &&\
    \ is_string(val))) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n'''\n)\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz759b7hc.d(23): Error: no identifier for declarator val\n/tmp/tmpz759b7hc.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpz759b7hc.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmpz759b7hc.d(23): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmpz759b7hc.d(30): Error: unterminated character constant\n/tmp/tmpz759b7hc.d(30):
    Error: Declaration expected, not \''16162320U\''\n/tmp/tmpz759b7hc.d(30): Error:
    unterminated character constant\n/tmp/tmpz759b7hc.d(36): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpz759b7hc.d(37): Error: Declaration expected, not \''assert\''\n/tmp/tmpz759b7hc.d(38):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpz759b7hc.d(39): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpz759b7hc.d(40): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpz759b7hc.d(41): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpz759b7hc.d(42): Error: Declaration expected, not \''assert\''\n/tmp/tmpz759b7hc.d(43):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz759b7hc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(string k in dict.keys) {\n        auto case1 = toupper(k);\n\
    \        auto case2 = k.toUpper();\n        if (case1 != case2 || dict[k] == null)\
    \ \n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp993zyacr.d(23): Error: found \''in\'' when expecting \'';\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp993zyacr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k in dict) {\n        if (!is_string(k)) return false;\
    \ // all keys not strings\n    }\n    return !dict.isNull;\n}\n\"\"\")\n    \n\
    def gen_stl_map(template):\n    stl_map_t = template.add_type('stl_map_t', \"\"\
    \"\ntypedef map<string, int> stl_map_t;\n\"\"\")\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwg2tl594.d(23): Error: no identifier for declarator k\n/tmp/tmpwg2tl594.d(23):
    Error: found \''in\'' when expecting \'';\''\n/tmp/tmpwg2tl594.d(28): Error: Declaration
    expected, not \''""\''\n/tmp/tmpwg2tl594.d(33): Error: Declaration expected, not
    \''""\''\n/tmp/tmpwg2tl594.d(43): Error: unterminated string constant starting
    at /tmp/tmpwg2tl594.d(43)\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwg2tl594.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    assert(!dict.isNull());\n    int count = 0;\n    foreach(string\
    \ key, dict) \n    {\n        if (count(key.c_str()) == 0)\n        {\n      \
    \      count = count + 1;\n        }\n    }\n    return count == 0;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nBased on your requirement, it looks like you just\
    \ want to check for existence of keys, and you are not interested in checking\
    \ their values (i.e. nullability of a key)\nSo you just need to check for existence\
    \ of keys in your associative array and you are done\n<code>\nunittest\n{\n  \
    \  alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaob9gjes.d(25): Error: no identifier for declarator dict\n/tmp/tmpaob9gjes.d(25):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpaob9gjes.d(32): Error: found
    \''return\'' when expecting \'')\''\n/tmp/tmpaob9gjes.d(34): Error: Declaration
    expected, not \''<\''\n/tmp/tmpaob9gjes.d(44): Error: Declaration expected, not
    \''assert\''\n/tmp/tmpaob9gjes.d(45): Error: Declaration expected, not \''assert\''\n/tmp/tmpaob9gjes.d(46):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpaob9gjes.d(47): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpaob9gjes.d(48): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpaob9gjes.d(49): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpaob9gjes.d(50): Error: Declaration expected, not \''assert\''\n/tmp/tmpaob9gjes.d(51):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaob9gjes.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.isEmpty && dict[\"a\"] == \"apple\" && dict[\"A\"\
    ] == \"banana\";\n}\n</code>\n<|/ a tags=d,struct,associative-array,arrays,std\
    \ |>\n<| c |>\nThe last example in the question is a good one. This should be\
    \ made more explicit. `const` may have some side effects.\n<|/ c |>\n<| c |>\n\
    This doesn't work if your dictionary keys may have numeric suffixes like `1`,\
    \ `2`, `3`.  Also, I don't think this solution correctly handles duplicate keys.\n\
    <|/ c |>\n<| c |>\nI fixed my solution. It also handles duplicate keys.\n<|/ c\
    \ |>\n<| c |>\n`!dict.isEmpty` looks unnecessary in the loop condition, since\
    \ `dict[]` returns `null` if the key doesn't exist.\n<|/ c |>\n<| a dscore=2 |>\n\
    If your array is not too big, you can simply loop through it and check the keys\
    \ for case-sensitive matches:\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4sa7l6wy.d(25): Error: Declaration expected, not \''<\''\n/tmp/tmp4sa7l6wy.d(31):
    Error: unterminated character constant\n/tmp/tmp4sa7l6wy.d(31): Error: unterminated
    character constant\n/tmp/tmp4sa7l6wy.d(37): Error: unterminated character constant\n/tmp/tmp4sa7l6wy.d(46):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp4sa7l6wy.d(47): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp4sa7l6wy.d(48): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp4sa7l6wy.d(49): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp4sa7l6wy.d(50): Error: Declaration expected, not \''assert\''\n/tmp/tmp4sa7l6wy.d(51):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp4sa7l6wy.d(52): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp4sa7l6wy.d(53): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4sa7l6wy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool valid = true;\n    for (int i=0; i<len(dict); ++i)\n   \
    \ {\n        string key = dict[i].first;\n        string value = (string)dict[i].second;\n\
    \        \n        if (key.equals(\"state\") || key.equals(\"postalcode\"))\n\
    \            continue;\n        \n        if (!value.isEmpty())\n            valid\
    \ = false;\n    }\n    return valid;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnf_s2o5g.d(27): Error: C style cast illegal, use cast(string)dict[i].second\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnf_s2o5g.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tforeach(string str in dict){\n\t\tint len = length(dict[str]);\n\
    \t\tif (len != 1){\n\t\t\terror(\"Invalid dictionary for check_dict_case\");\n\
    \t\t}\n\t\tif (isupper(str) || islower(str)){\n\t\t\treturn false;\n\t\t}\n\t\
    }\n\treturn true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp27zyupt1.d(23): Error: found \''in\'' when expecting \'';\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp27zyupt1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, value) in dict do\n    {\n        if (std.typecons.isLower(key)\
    \ || std.typecons.isUpper(key))\n        {\n            return false;\n      \
    \  }\n    }\n    return true;\n}\n\"\"\"\n</cell>\n<cell>\n!./bin/bash ../Helper/BiomarkerGuy/Helper/Scripts/check_dict_case.sh\n\
    </cell>\n<text>\ncheck_dict_case({\"a\": \"apple\", \"b\": \"banana\"})\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7mfqqlif.d(23): Error: no identifier for declarator value\n/tmp/tmp7mfqqlif.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp7mfqqlif.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmp7mfqqlif.d(23): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmp7mfqqlif.d(30): Error: found \''return\'' when expecting \''while\''\n/tmp/tmp7mfqqlif.d(30):
    Error: found \''true\'' when expecting \''(\''\n/tmp/tmp7mfqqlif.d(30): Error:
    expression expected, not \'';\''\n/tmp/tmp7mfqqlif.d(31): Error: found \''}\''
    when expecting \'')\''\n/tmp/tmp7mfqqlif.d(32): Deprecation: do-while statement
    without terminating ; is deprecated\n/tmp/tmp7mfqqlif.d(38): Error: found \''a\''
    when expecting \'';\'' following statement\n/tmp/tmp7mfqqlif.d(38): Error: found
    \''apple\'' when expecting \'';\'' following statement\n/tmp/tmp7mfqqlif.d(38):
    Error: found \''b\'' when expecting \'';\'' following statement\n/tmp/tmp7mfqqlif.d(38):
    Error: found \''banana\'' when expecting \'';\'' following statement\n/tmp/tmp7mfqqlif.d(43):
    Error: found \''p\'' when expecting \'';\'' following statement\n/tmp/tmp7mfqqlif.d(43):
    Error: found \''pineapple\'' when expecting \'';\'' following statement\n/tmp/tmp7mfqqlif.d(43):
    Error: found \''b\'' when expecting \'';\'' following statement\n/tmp/tmp7mfqqlif.d(43):
    Error: found \''banana\'' when expecting \'';\'' following statement\n/tmp/tmp7mfqqlif.d(44):
    Error: found \''p\'' when expecting \'';\'' following statement\n/tmp/tmp7mfqqlif.d(44):
    Error: found \''pineapple\'' when expecting \'';\'' following statement\n/tmp/tmp7mfqqlif.d(44):
    Error: found \''A\'' when expecting \'';\'' following statement\n/tmp/tmp7mfqqlif.d(44):
    Error: found \''banana\'' when expecting \'';\'' following statement\n/tmp/tmp7mfqqlif.d(44):
    Error: found \''B\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp7mfqqlif.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.hasKey(null);\n}\n\"\"\"\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp06738k38.d(25): Error: Declaration expected, not \''""\''\n/tmp/tmp06738k38.d(35):
    Error: unterminated string constant starting at /tmp/tmp06738k38.d(35)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp06738k38.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    \n    for(auto &v: dict)\n        if(!is_str(v) && is_str(v.value)\
    \ || !is_str(v) && !is_str(v.value))\n            return false;\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpar9nhkbt.d(24): Error: basic type expected, not &\n/tmp/tmpar9nhkbt.d(24):
    Error: no identifier for declarator int\n/tmp/tmpar9nhkbt.d(24): Error: found
    \'':\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpar9nhkbt.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(!dict.isNull)\n    {\n        bool result = true;\n      \
    \  for(auto v: dict)\n        {\n            if(!v.key.isUpperCase && v.key.isLowercase)\n\
    \            {\n                result = false;\n                break;\n    \
    \        }\n            else if(v.key.isUpperCase && !v.key.isLowercase)\n   \
    \         {\n                result = false;\n                break;\n       \
    \     }\n        }\n        return result;\n    }\n    else\n    {\n        return\
    \ false;\n    }\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_kxg2b4u.d(26): Error: no identifier for declarator v\n/tmp/tmp_kxg2b4u.d(26):
    Error: expression expected, not \'':\''\n/tmp/tmp_kxg2b4u.d(26): Error: found
    \''dict\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_kxg2b4u.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tauto iter = dict.begin();\n\tauto end= dict.end();\n\tfor (; iter\
    \ != end; ++iter) {\n\t\tif (!(iter.key().toLower() == iter.key().toUpper()))\
    \ return false;\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp18g88k_7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(key in dict, value){\n        if (!strcasecmp(key.get(),\
    \ key.get().c_str()))\n            return false;\n        if (typeof(dict[key])\
    \ <> typeof(Nullable!(string[string]))) return false;\n    }\n    return true;\n\
    }\n</code>\nIt uses the fact that Nullable is a value type that can be null. \n\
    It also uses the fact that an std::map has a type that is an std::pair and that\
    \ std::pair has a type that is std::pair and that is also Nullable!(string[string]).\n\
    <|/ a tags=dictionary,python,c++,boost |>\n<| c |>\nHow would the code look if\
    \ we wanted to add `if (key.get().empty()) return false; else return true;`?\n\
    <|/ c |>\n<| c |>\n, I added a second version. It should now be clear.\n<|/ c\
    \ |>\n<| a dscore=2 |>\nI modified ChristopheD's solution slightly to handle key\
    \ collisions:\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjowghv15.d(23): Error: no identifier for declarator key\n/tmp/tmpjowghv15.d(23):
    Error: found \''in\'' when expecting \'';\''\n/tmp/tmpjowghv15.d(30): Error: Declaration
    expected, not \''<\''\n/tmp/tmpjowghv15.d(41): Error: unterminated character constant\n/tmp/tmpjowghv15.d(47):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpjowghv15.d(48): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpjowghv15.d(49): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpjowghv15.d(50): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpjowghv15.d(51): Error: Declaration expected, not \''assert\''\n/tmp/tmpjowghv15.d(52):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpjowghv15.d(53): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpjowghv15.d(54): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjowghv15.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(!dict)\n    {\n        throw new ArgumentError.value(dict,\
    \ \"dict\", \"Dictionary cannot be empty\");\n    }\n    for (key in dict)\n \
    \   {\n        if (std.isLower(key))\n        {\n            return true;\n  \
    \      }\n        if (std.isUpper(key))\n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwdv6zphi.d(27): Error: found \'')\'' when expecting \'';\''
    following statement\n/tmp/tmpwdv6zphi.d(38): Error: found \''return\'' when expecting
    \'';\'' following for condition\n/tmp/tmpwdv6zphi.d(38): Error: found \'';\''
    when expecting \'')\''\n/tmp/tmpwdv6zphi.d(39): Error: found \''}\'' instead of
    statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwdv6zphi.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  // TODO: Complete this function\n  return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcdecrpkd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.empty()) return false;\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2hmuagaz.d(24): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2hmuagaz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tforeach(k, v) dict += k as string;\n\treturn dict[\"A\"] != dict[\"\
    a\"] || dict[\"B\"] != dict[\"b\"];\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmponobviho.d(23): Error: no identifier for declarator v\n/tmp/tmponobviho.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmponobviho.d(23): Error: found
    \''as\'' when expecting \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmponobviho.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if (k as string in Lower(k)) \n\
    \        {\n            if (k as string in Upper(k))\n            {\n        \
    \        return false;\n            }\n            else\n            {\n     \
    \           return true;\n            }\n        }\n        else\n        {\n\
    \            return true;\n        }\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmg4ly1gb.d(23): Error: no identifier for declarator v\n/tmp/tmpmg4ly1gb.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpmg4ly1gb.d(25): Error: found
    \''as\'' when expecting \'')\''\n/tmp/tmpmg4ly1gb.d(25): Error: found \'')\''
    when expecting \'';\'' following statement\n/tmp/tmpmg4ly1gb.d(27): Error: found
    \''as\'' when expecting \'')\''\n/tmp/tmpmg4ly1gb.d(27): Error: found \'')\''
    when expecting \'';\'' following statement\n/tmp/tmpmg4ly1gb.d(31): Error: found
    \''else\'' instead of statement\n/tmp/tmpmg4ly1gb.d(36): Error: found \''else\''
    when expecting \'')\''\n/tmp/tmpmg4ly1gb.d(41): Error: Declaration expected, not
    \''return\''\n/tmp/tmpmg4ly1gb.d(42): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmg4ly1gb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(!dict.is_empty())\n    {\n        foreach(k, v |v in dict)\n\
    \        {\n            if(is_lower(k) || is_upper(k))\n                return\
    \ true;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph26n6pgl.d(25): Error: no identifier for declarator v\n/tmp/tmph26n6pgl.d(25):
    Error: found \''|\'' when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmph26n6pgl.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null) {\n        return true;\n    }\n    auto keyList\
    \ = dict.keys;\n    auto valueList = dict.values;\n    auto keyLength = (size_t)keyList.size();\n\
    \    auto valueLength = (size_t)valueList.size();\n    // If there are any non-string\
    \ or non-number keys, return false\n    for (size_t i = 0; i < keyLength; ++i)\
    \ {\n        if (!is_string_or_number(keyList[i])) {\n            return false;\n\
    \        }\n    }\n    for (size_t i = 0; i < valueLength; ++i) {\n        if\
    \ (!is_string_or_number(valueList[i])) {\n            return false;\n        }\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsetqa9qd.d(28): Error: C style cast illegal, use cast(size_t)keyList.size()\n/tmp/tmpsetqa9qd.d(29):
    Error: C style cast illegal, use cast(size_t)valueList.size()\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpsetqa9qd.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !std.typecons.is_nil(dict.key) || !std.typecons.is_nil(dict.value.keys());\n\
    }\n'''\nchecker_dict['check_dict_case'] = check_dict_case\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwv_0mdoi.d(25): Error: unterminated character constant\n/tmp/tmpwv_0mdoi.d(25):
    Error: Declaration expected, not \''38479888U\''\n/tmp/tmpwv_0mdoi.d(25): Error:
    unterminated character constant\n/tmp/tmpwv_0mdoi.d(26): Error: unterminated character
    constant\n/tmp/tmpwv_0mdoi.d(26): Error: unterminated character constant\n/tmp/tmpwv_0mdoi.d(31):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpwv_0mdoi.d(32): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpwv_0mdoi.d(33): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpwv_0mdoi.d(34): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpwv_0mdoi.d(35): Error: Declaration expected, not \''assert\''\n/tmp/tmpwv_0mdoi.d(36):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpwv_0mdoi.d(37): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpwv_0mdoi.d(38): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwv_0mdoi.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.IsEmpty) \n    { \n        return false; \n    } \n\
    \    \n    for (auto& [key, value] : dict)\n    {\n        if (!(is_string(value)\
    \ || is_string(key)))\n        {\n            return false; \n        } \n   \
    \ }\n    return true; \n} \n/*\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuwdnnapi.d(28): Error: basic type expected, not &\n/tmp/tmpuwdnnapi.d(28):
    Error: no identifier for declarator int\n/tmp/tmpuwdnnapi.d(28): Error: found
    \'':\'' when expecting \'';\'' following for condition\n/tmp/tmpuwdnnapi.d(37):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuwdnnapi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return true;\n    auto lowercase = [](string\
    \ s) { return s.lower(); };\n    auto uppercase = [](string s) { return s.upper();\
    \ };\n    return std::all_of(dict.dict.begin(), dict.dict.end(), [&](pair<string,\
    \ string> p){\n        return p.first.isNull() && p.second.isNull() ? true :\n\
    \            check(lowercase(p.first), p.second) ||\n            check(uppercase(p.first),\
    \ p.second);\n    });\n}\n</code>\n<|/ a tags=dictionary,c++,stl,stdmap |>\n<|\
    \ c |>\nThis is a much more idiomatic approach than the one I proposed.\n<|/ c\
    \ |>\n<| c |>\nIt actually uses less memory then my solution -- I used `std::set`\
    \ as I couldn't use my own hash function and I didn't want to use Boost hash_set\
    \ as it is unavailable in some environments\n<|/ c |>\n<| c |>\nI wrote a similar\
    \ solution a while back using C++03 constructs and I believe it can handle any\
    \ type with implicit conversion to `string`.  Though it's also more complicated\
    \ than it needs to be.  I'll add it back in if it doesn't work\n<|/ c |>\n<| c\
    \ |>\nI added a version that works with C++03 constructs, and also an example\
    \ showing that it works with non-`string` keys\n<|/ c |>\n<| a tags=dictionary,c++,stl,stdmap\
    \ |>\nI think it's best to use an unordered_map or unordered_set - no doubt you'll\
    \ get better performance.\n<|/ a dscore=1 |>\n<| c |>\nBut it uses more memory,\
    \ since each entry must be stored twice. Also, if you use custom hash functions\
    \ with unordered_set/unordered_map you may get incorrect results (see http://www.boost.org/doc/libs/1_45_0/doc/html/unordered/containers.html)\n\
    <|/ c |>\n<| c |>\n: Yes, but with C++0x unordered_map/unordered_set can take\
    \ an allocator as a template parameter.\n<|/ c |>\n<| c |>\n: I believe the memory\
    \ usage is pretty much the same, since a map or set has pointers pointing to its\
    \ elements.\n<|/ c |>\n<| c |>\n: Also, just realized that boost::unordered_map/unordered_set\
    \ can take an allocator as a template parameter.\n<|/ c |>\n<| a dscore=1 |>\n\
    I'd like to throw in something based on Brad's ideas that I've used before.  It's\
    \ \nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpeecfjp24.d(24): Error: found \''s\'' when expecting \'',\''\n/tmp/tmpeecfjp24.d(24):
    Error: semicolon expected following auto declaration, not \''{\''\n/tmp/tmpeecfjp24.d(25):
    Error: found \''s\'' when expecting \'',\''\n/tmp/tmpeecfjp24.d(25): Error: semicolon
    expected following auto declaration, not \''{\''\n/tmp/tmpeecfjp24.d(26): Error:
    found \'':\'' when expecting \'';\'' following return statement\n/tmp/tmpeecfjp24.d(26):
    Error: found \'':\'' instead of statement\n/tmp/tmpeecfjp24.d(30): Error: Declaration
    expected, not \'')\''\n/tmp/tmpeecfjp24.d(31): Error: unrecognized declaration\n/tmp/tmpeecfjp24.d(38):
    Error: unterminated character constant\n/tmp/tmpeecfjp24.d(38): Error: unterminated
    character constant\n/tmp/tmpeecfjp24.d(41): Error: unterminated character constant\n/tmp/tmpeecfjp24.d(41):
    Error: unterminated character constant\n/tmp/tmpeecfjp24.d(41): Error: unterminated
    character constant\n/tmp/tmpeecfjp24.d(47): Error: unterminated character constant\n/tmp/tmpeecfjp24.d(47):
    Error: unterminated character constant\n/tmp/tmpeecfjp24.d(62): Error: unterminated
    character constant\n/tmp/tmpeecfjp24.d(62): Error: unterminated character constant\n/tmp/tmpeecfjp24.d(62):
    Error: unterminated character constant\n/tmp/tmpeecfjp24.d(62): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeecfjp24.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto keys = dict.keys();\n    for(auto itr = keys.begin(); itr\
    \ != keys.end(); ++itr) {\n        auto ktype = key_type(*itr);\n        auto\
    \ vtype = value_type(*itr);\n        if(ktype == std.typecons.std_string_t.type())\
    \ {\n            if(vtype == std.typecons.std_string_t.type()) {\n           \
    \     // all keys are in lower case\n            } else {\n                //\
    \ all keys are in upper case\n            }\n        } else {\n            if(vtype\
    \ == std.typecons.std_string_t.type()) {\n                // all keys are in upper\
    \ case\n            } else {\n                // all keys are in lower case\n\
    \            }\n        }\n    }\n    return dict.has_elements();\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=swift,dictionary,associative-array,arrays |>\n<code>\n\
    public static func isDictionary(_ object: Any?) -> Bool {\n    switch object!\
    \ {\n    case is Dictionary<String, Any?>:\n        return true\n    case is Array:\n\
    \        return false\n    case is String:\n        return true\n    case is Int:\n\
    \        return false\n    case is Float:\n        return false\n    case is Dictionary:\n\
    \        return false\n    case is [AnyObject]:\n        return false\n    case\
    \ is AnyObject:\n        return false\n    default:\n        return false\n  \
    \  }\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks. I added this as another\
    \ answer to this question: https://stackoverflow.com/a/63785627/1888901\n<|/ c\
    \ |>\n<| a dscore=2 |>\nSwift 5.1 added two new methods to Dictionary to check\
    \ whether it contains a key or value, and whether it contains an entry for the\
    \ key or value. These are all checked at compile time, rather than run time, so\
    \ it can be used for static type checking.\n<code>\nextension Dictionary {\n \
    \   func containsKey(_ key: Key) -> Bool\n    {\n        return contains(key)\
    \ || self[key].isEmpty == false\n    }\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp28q0wkh4.d(43): Error: Declaration expected, not \''<\''\n/tmp/tmp28q0wkh4.d(86):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp28q0wkh4.d(87): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp28q0wkh4.d(88): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp28q0wkh4.d(89): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp28q0wkh4.d(90): Error: Declaration expected, not \''assert\''\n/tmp/tmp28q0wkh4.d(91):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp28q0wkh4.d(92): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp28q0wkh4.d(93): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp28q0wkh4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isEmpty()) return false;\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3uo4lvm9.d(24): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3uo4lvm9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isEmpty)\n        throw \"check_dict_case() called with\
    \ empty associative array!\";\n    for (KeyValuePair!(string,string) entry in\
    \ dict)\n    {\n        if (entry.key.equalsCaseInsensitive(\"lower\")) // convert\
    \ key from upper to lower\n            return true;\n        else if (entry.key.equalsCaseInsensitive(\"\
    upper\")) // convert key from lower to upper\n            return false;\n    \
    \    else \n            throw \"KeyValuePair!(string,string) dictionary does not\
    \ contain correct key name!\";\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph9bpm0yo.d(25): Error: semicolon expected, not \''in\''\n/tmp/tmph9bpm0yo.d(25):
    Error: expression expected, not \''in\''\n/tmp/tmph9bpm0yo.d(25): Error: found
    \''dict\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmph9bpm0yo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int: foreach ( key, value ) in dict do \n    {\n        // ignore\
    \ keys that aren't strings\n        if( key !is string ) then\n            return\
    \ false;\n        // ignore keys that aren't all lower case\n        if( value\
    \ !is string[string] ) then\n            return false;\n        \n        if(\
    \ value !islower ) then\n            return false;\n        \n        if( value\
    \ !isequal value.toUpper ) then\n            return false;\n        \n    } \n\
    \    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp11ulfp6i.d(23): Error: no identifier for declarator int\n/tmp/tmp11ulfp6i.d(23):
    Error: found \'':\'' instead of statement\n/tmp/tmp11ulfp6i.d(30): Error: found
    \''return\'' when expecting \'';\'' following statement\n/tmp/tmp11ulfp6i.d(33):
    Error: found \''return\'' when expecting \'';\'' following statement\n/tmp/tmp11ulfp6i.d(35):
    Error: found \''value\'' when expecting \'')\''\n/tmp/tmp11ulfp6i.d(35): Error:
    found \'')\'' when expecting \'';\'' following statement\n/tmp/tmp11ulfp6i.d(36):
    Error: found \''return\'' when expecting \'';\'' following statement\n/tmp/tmp11ulfp6i.d(39):
    Error: Declaration expected, not \''return\''\n/tmp/tmp11ulfp6i.d(40): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp11ulfp6i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) dict += Nullable!(string) k + Nullable!(string)\
    \ v;\n    \n    int cnt = 0;\n    \n    foreach(k, v) if (k == toUpper(v)) cnt++;\n\
    \    foreach(k, v) if (k == toLower(v)) cnt++;\n    \n    bool result = cnt >\
    \ 0 && cnt == dict.count();\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzcvq9qks.d(23): Error: no identifier for declarator v\n/tmp/tmpzcvq9qks.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpzcvq9qks.d(23): Error: found
    \''k\'' when expecting \'')\''\n/tmp/tmpzcvq9qks.d(23): Error: found \''v\'' when
    expecting \'';\'' following statement\n/tmp/tmpzcvq9qks.d(27): Error: no identifier
    for declarator v\n/tmp/tmpzcvq9qks.d(27): Error: found \'')\'' when expecting
    \'';\''\n/tmp/tmpzcvq9qks.d(27): Error: expression expected, not \''if\''\n/tmp/tmpzcvq9qks.d(27):
    Error: found \''cnt\'' when expecting \'')\''\n/tmp/tmpzcvq9qks.d(27): Error:
    expression expected, not \'';\''\n/tmp/tmpzcvq9qks.d(28): Error: found \''foreach\''
    when expecting \'';\'' following statement\n/tmp/tmpzcvq9qks.d(28): Error: found
    \''if\'' when expecting \'';\'' following statement\n/tmp/tmpzcvq9qks.d(28): Error:
    found \''cnt\'' when expecting \'';\'' following statement\n/tmp/tmpzcvq9qks.d(28):
    Error: expression expected, not \'';\''\n/tmp/tmpzcvq9qks.d(30): Error: found
    \''bool\'' when expecting \'';\'' following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpzcvq9qks.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    Nullable!(string) first;\n    Nullable!(string) second;\n   \
    \ bool result = false;\n    if (dict.isNull())\n        return true;\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvrfoz8ct.d(28): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvrfoz8ct.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n   if(not dict)\n       return true;\n   foreach(e, dict)\n   {\n\
    \       if(!is_string(e))\n       {\n           return false;\n       }\n    \
    \   if(!is_string(e))\n       {\n           return false;\n       }\n   }\n  \
    \ return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n   \
    \ assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7wgewsgn.d(23): Error: found \''dict\'' when expecting \'')\''\n/tmp/tmp7wgewsgn.d(23):
    Error: found \'')\'' instead of statement\n/tmp/tmp7wgewsgn.d(25): Error: no identifier
    for declarator dict\n/tmp/tmp7wgewsgn.d(25): Error: found \'')\'' when expecting
    \'';\''\n/tmp/tmp7wgewsgn.d(36): Error: found \''return\'' when expecting \'')\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7wgewsgn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    // If dict is an empty dictionary return true\n    if(!dict ||\
    \ !dict.isEmpty) return true;\n    \n    // Get all the keys and convert to lowercase\n\
    \    string[] keys = (string[])dict.toList().toArray();\n    \n    // If the first\
    \ key's value is null or empty, return false\n    if(!keys[0].isEmpty()) return\
    \ false;\n    \n    // If the keys are all upper case return true\n    foreach(i\
    \ in keys.indices){\n        if(!keys[i].isUppercase()) return false;\n    }\n\
    \    \n    // If all the keys are upper case return true\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfi4ibihh.d(27): Error: C style cast illegal, use cast(string[])dict.toList().toArray()\n/tmp/tmpfi4ibihh.d(33):
    Error: no identifier for declarator i\n/tmp/tmpfi4ibihh.d(33): Error: found \''in\''
    when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfi4ibihh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for (auto it : dict)\n        if (it.key as string in \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n            if (it.key as string in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n     \
    \           return false;\n    return true;\n}\n</code>\nThis doesn't take into\
    \ account the case where you have a dictionary with a key of \"a\" and \"a\" and\
    \ the value \"a\" though.\n<|/ a tags=types,ocaml,functional-programming,dictionary,comparison\
    \ |>\n<| c |>\nThank you! The use of a `for` loop is something I should probably\
    \ get familiar with more closely.\n<|/ c |>\n<| a dscore=1 tags=types,ocaml,functional-programming,dictionary,comparison\
    \ |>\nHere is another method using pattern matching. This one doesn't rely on\
    \ nullable types. Although it also doesn't check if the dictionary is empty.\n\
    <code>\ntype 'a dict = {\n    mutable mutable dict : 'a -> 'a;\n    mutable mutable\
    \ count : int;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n   \
    \ assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdvyr0_g8.d(23): Error: no identifier for declarator it\n/tmp/tmpdvyr0_g8.d(23):
    Error: expression expected, not \'':\''\n/tmp/tmpdvyr0_g8.d(23): Error: found
    \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmpdvyr0_g8.d(24):
    Error: found \''as\'' when expecting \'')\''\n/tmp/tmpdvyr0_g8.d(24): Error: found
    \'')\'' when expecting \'';\'' following statement\n/tmp/tmpdvyr0_g8.d(25): Error:
    found \''as\'' when expecting \'')\''\n/tmp/tmpdvyr0_g8.d(25): Error: found \'')\''
    when expecting \'';\'' following statement\n/tmp/tmpdvyr0_g8.d(29): Error: Declaration
    expected, not \''<\''\n/tmp/tmpdvyr0_g8.d(30): Error: unterminated character constant\n/tmp/tmpdvyr0_g8.d(36):
    Error: unterminated character constant\n/tmp/tmpdvyr0_g8.d(36): Error: unterminated
    character constant\n/tmp/tmpdvyr0_g8.d(38): Error: unterminated character constant\n/tmp/tmpdvyr0_g8.d(39):
    Error: unterminated character constant\n/tmp/tmpdvyr0_g8.d(39): Error: unterminated
    character constant\n/tmp/tmpdvyr0_g8.d(40): Error: semicolon expected, not \''count\''\n/tmp/tmpdvyr0_g8.d(40):
    Error: no identifier for declarator count\n/tmp/tmpdvyr0_g8.d(40): Error: Declaration
    expected, not \'':\''\n/tmp/tmpdvyr0_g8.d(41): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdvyr0_g8.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = true;\n    foreach(k, v : {!dict}) {\n        bool\
    \ isString = !is_null(v);\n        if (!isString || !k) {\n            result\
    \ = false;\n        } else {\n            string key = k;\n            string\
    \ lowerCase = key.lower;\n            string upperCase = key.upper;\n        \
    \    if (isString) {\n                bool result = false;\n                if\
    \ (lowerCase != upperCase) {\n                    result = true;\n           \
    \     }\n                else {\n                    string lowerUpper = key.lower\
    \ + key.upper;\n                    bool result = false;\n                   \
    \ if (lowerUpper != lowerCase) {\n                        result = true;\n   \
    \                 }\n                    else {\n                        string\
    \ upperLower = key.upper + key.lower;\n                        bool result = false;\n\
    \                        if (lowerUpper != upperCase) {\n                    \
    \        result = true;\n                        }\n                        else\
    \ {\n                            string lowerUpperNoSpace = key.lower.replace(\"\
    \ \", \"\");\n                            bool result = false;\n             \
    \               if (lowerUpper != lowerUpperNoSpace) {\n                     \
    \           result = true;\n                            }\n                  \
    \          else {\n                                string upperLowerNoSpace =\
    \ key.upper.replace(\" \", \"\");\n                                bool result\
    \ = false;\n                                if (upperLower != upperLowerNoSpace)\
    \ {\n                                    result = true;\n                    \
    \            }\n                                else {\n                     \
    \               string noSpace = key.replace(\" \", \"\");\n                 \
    \                   bool result = false;\n                                   \
    \ if (noSpace != lowerUpperNoSpace) {\n                                      \
    \  result = true;\n                                    }\n                   \
    \             }\n                            }\n                        }\n  \
    \                  }\n                }\n            }\n            else {\n \
    \               result = false;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0_jvgaiy.d(24): Error: no identifier for declarator v\n/tmp/tmp0_jvgaiy.d(24):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp0_jvgaiy.d(24): Error: found
    \''}\'' when expecting \'';\'' following statement\n/tmp/tmp0_jvgaiy.d(24): Error:
    found \'')\'' instead of statement\n/tmp/tmp0_jvgaiy.d(78): Error: found \''return\''
    when expecting \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0_jvgaiy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.length == 0) {\n        return true;\n    }\n    auto\
    \ iter = dict.begin();\n    string key = (*iter).first;\n    auto end = dict.end();\n\
    \    for(++iter; iter != end; ++iter) {\n        if (iter->first.lexeme != key)\
    \ {\n            return false;\n        }\n        if (iter->first.upper != key)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    And a little test:\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2p7bd2sc.d(30): Error: expression expected, not \''>\''\n/tmp/tmp2p7bd2sc.d(30):
    Error: found \''first\'' when expecting \'')\''\n/tmp/tmp2p7bd2sc.d(30): Error:
    found \'')\'' when expecting \'';\'' following statement\n/tmp/tmp2p7bd2sc.d(33):
    Error: expression expected, not \''>\''\n/tmp/tmp2p7bd2sc.d(33): Error: found
    \''first\'' when expecting \'')\''\n/tmp/tmp2p7bd2sc.d(33): Error: found \'')\''
    when expecting \'';\'' following statement\n/tmp/tmp2p7bd2sc.d(39): Error: Declaration
    expected, not \''<\''\n/tmp/tmp2p7bd2sc.d(46): Error: Declaration expected, not
    \''assert\''\n/tmp/tmp2p7bd2sc.d(47): Error: Declaration expected, not \''assert\''\n/tmp/tmp2p7bd2sc.d(48):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp2p7bd2sc.d(49): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp2p7bd2sc.d(50): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp2p7bd2sc.d(51): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp2p7bd2sc.d(52): Error: Declaration expected, not \''assert\''\n/tmp/tmp2p7bd2sc.d(53):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2p7bd2sc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  if(dict.IsEmpty)\n  {\n    return false;\n  }\n  foreach(string\
    \ key in dict.Keys)\n  {\n    bool result = is_lower_case(key) || is_upper_case(key);\
    \ \n    if(!result)\n    {\n      return false;\n    }\n  }\n  return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5l4owezb.d(27): Error: found \''in\'' when expecting \'';\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5l4owezb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == Nullable!(string[string])) return true;\n    \n \
    \   foreach(ref key, ref val; dict) {\n        if (!is_string(key)) return false;\n\
    \        if (!is_string(val)) return false;\n    }\n    \n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4qlp2ji1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return false;\n    foreach (key, value) in dict\n\
    \        if (value.isNull) return false;\n    foreach (key, value) in dict\n \
    \       if (!value.isString) return false;\n    return true;\n}\n\"\"\"\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpltre0g0c.d(24): Error: no identifier for declarator value\n/tmp/tmpltre0g0c.d(24):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpltre0g0c.d(24): Error: expression
    expected, not \''in\''\n/tmp/tmpltre0g0c.d(24): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmpltre0g0c.d(26): Error: no identifier for declarator value\n/tmp/tmpltre0g0c.d(26):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpltre0g0c.d(26): Error: expression
    expected, not \''in\''\n/tmp/tmpltre0g0c.d(26): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmpltre0g0c.d(30): Error: Declaration expected, not \''""\''\n/tmp/tmpltre0g0c.d(40):
    Error: unterminated string constant starting at /tmp/tmpltre0g0c.d(40)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpltre0g0c.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (kv in dict)\n    {\n        if (!is_string(kv))\n  \
    \      {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvahjvnin.d(23): Error: no identifier for declarator kv\n/tmp/tmpvahjvnin.d(23):
    Error: found \''in\'' when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpvahjvnin.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull)\n    {\n        return false;\n    }\n    for\
    \ (auto key : string.keys(dict))\n    {\n        if (key.isLowercase())\n    \
    \    {\n            continue;\n        }\n        if (key.isUppercase())\n   \
    \     {\n            continue;\n        }\n        return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprrdzql33.d(27): Error: no identifier for declarator key\n/tmp/tmprrdzql33.d(27):
    Error: expression expected, not \'':\''\n/tmp/tmprrdzql33.d(27): Error: found
    \''string\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmprrdzql33.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  require(dict != null);\n  for(auto it : dict)\n  {\n    require(it.key!=null);\n\
    \    require(it.key!=\"\");\n    require(it.key!='\\0');\n    require(it.key!=it);\n\
    \  }\n  return !dict.empty();\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjsmdhqif.d(24): Error: no identifier for declarator it\n/tmp/tmpjsmdhqif.d(24):
    Error: expression expected, not \'':\''\n/tmp/tmpjsmdhqif.d(24): Error: found
    \''dict\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpjsmdhqif.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (pair!(string[string], string) entry in dict) \n    {\n\
    \        if (!(check_type(Nullable!(string[string]))))\n        {\n          \
    \  return false;\n        }\n        if (!(check_type(string)))\n        {\n \
    \           return false;\n        }\n        if (!(check_strings(entry.key)))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3cg86d_k.d(23): Error: found \''in\'' when expecting \'';\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3cg86d_k.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = false;\n    if (dict.has_value())\n    {\n    \
    \    for (auto [key, value] : dict)\n        {\n            if (is_string(value))\n\
    \            {\n                result = true;\n                break;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9dzva_1v.d(26): Error: basic type expected, not [\n/tmp/tmp9dzva_1v.d(26):
    Error: found \'',\'' when expecting \'']\''\n/tmp/tmp9dzva_1v.d(26): Error: semicolon
    expected, not \'']\''\n/tmp/tmp9dzva_1v.d(26): Error: expression expected, not
    \'']\''\n/tmp/tmp9dzva_1v.d(26): Error: found \'':\'' when expecting \'';\'' following
    for condition\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9dzva_1v.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(x, dict) \n    {\n        \n        if (!isa(x, String)\
    \ || toLower(x) != x)\n        {\n            return false;\n        }\n    }\n\
    \    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp31rpqw3a.d(23): Error: no identifier for declarator dict\n/tmp/tmp31rpqw3a.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp31rpqw3a.d(31): Error: found
    \''return\'' when expecting \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp31rpqw3a.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (string k in dict) \n    {\n        if (!(k.toLower()\
    \ == k.toUpper()))\n        {\n            return false;\n        }\n    }\n \
    \   return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n \
    \   assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptm5yepxq.d(23): Error: found \''in\'' when expecting \'';\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptm5yepxq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return true;\n    foreach(string key in dict)\
    \ \n    {\n        if (!(typeof(key) == string)) return false;\n        if (!isLowercase(key.c_str()))\
    \ return false;\n    }\n    \n    return true;\n}\n</code>\n<|/ a dscore=1 tags=c,c++,types,python\
    \ |>\n<| a |>\nI came up with this solution which works on C and C++:\n<code>\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc18gtwy2.d(24): Error: found \''in\'' when expecting \'';\''\n/tmp/tmpc18gtwy2.d(32):
    Error: Declaration expected, not \''<\''\n/tmp/tmpc18gtwy2.d(41): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpc18gtwy2.d(42): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpc18gtwy2.d(43): Error: Declaration expected, not \''assert\''\n/tmp/tmpc18gtwy2.d(44):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpc18gtwy2.d(45): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpc18gtwy2.d(46): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpc18gtwy2.d(47): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpc18gtwy2.d(48): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc18gtwy2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    intraref keys (dict);\n    bool b = false;\n    keys.foreach((Key!(string)\
    \ key){\n        if (key == key)\n            b = True;\n    });\n    return b;\n\
    }\n</code>\n<|/ a tags=c#,dictionary,string,.net,types dscore=0 |>\n<| a dscore=0\
    \ |>\nI wrote the following function:\n<code>\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk512wj8r.d(25): Error: identifier expected following \''.\'',
    not \''foreach\''\n/tmp/tmpk512wj8r.d(31): Error: Declaration expected, not \''<\''\n/tmp/tmpk512wj8r.d(40):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpk512wj8r.d(41): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpk512wj8r.d(42): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpk512wj8r.d(43): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpk512wj8r.d(44): Error: Declaration expected, not \''assert\''\n/tmp/tmpk512wj8r.d(45):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpk512wj8r.d(46): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpk512wj8r.d(47): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk512wj8r.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for (auto key : dict)\n    {\n        bool isLowerCase = key.to<string>().toLower();\n\
    \        bool isUpperCase = key.to<string>().toUpper();\n        \n        if\
    \ (key.hasValue() && isLowerCase == isUpperCase)\n            return true;\n \
    \   }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprjbz8xhm.d(23): Error: no identifier for declarator key\n/tmp/tmprjbz8xhm.d(23):
    Error: expression expected, not \'':\''\n/tmp/tmprjbz8xhm.d(23): Error: found
    \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmprjbz8xhm.d(25):
    Error: semicolon expected, not \''>\''\n/tmp/tmprjbz8xhm.d(25): Error: found \''>\''
    instead of statement\n/tmp/tmprjbz8xhm.d(26): Error: semicolon expected, not \''>\''\n/tmp/tmprjbz8xhm.d(26):
    Error: found \''>\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmprjbz8xhm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return false; \n    foreach (var key in dict.keys)\
    \ {\n        if (!key.has_case_change()) return false;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdwj5qj7p.d(24): Error: found \''in\'' when expecting \'';\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdwj5qj7p.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  int count = 0;\n  foreach(key,value) in dict {\n    count += 1;\n\
    \    if (key.upper) {\n      return false;\n    }\n    if (key.lower) {\n    \
    \  return false;\n    }\n  }\n  return count == 0;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4xrdprl5.d(24): Error: no identifier for declarator value\n/tmp/tmp4xrdprl5.d(24):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp4xrdprl5.d(24): Error: expression
    expected, not \''in\''\n/tmp/tmp4xrdprl5.d(24): Error: found \''dict\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4xrdprl5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (kk, v) in dict \n    {\n        if (typeof(kk) != typeof(string))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\n''');\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcag13ak7.d(23): Error: no identifier for declarator v\n/tmp/tmpcag13ak7.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpcag13ak7.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmpcag13ak7.d(23): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmpcag13ak7.d(32): Error: unterminated character constant\n/tmp/tmpcag13ak7.d(32):
    Error: Declaration expected, not \''37170704U\''\n/tmp/tmpcag13ak7.d(32): Error:
    unterminated character constant\n/tmp/tmpcag13ak7.d(33): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcag13ak7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tforeach (string key in dict)\n\t{\n\t\tif (!dict[key])\n\t\t{\n\
    \t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!string.IsNullOrWhiteSpace(dict[key]))\n\
    \t\t{\n\t\t\tif (dict[key].ToLowerInvariant() != key)\n\t\t\t{\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\t\n\t\t\tstring temp = dict[key].ToLowerInvariant();\n\
    \t\t\t\n\t\t\tif (temp != key)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\
    }\n\t}\n\t\n\treturn true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptiqg8eyt.d(23): Error: found \''in\'' when expecting \'';\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptiqg8eyt.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    map<string, string> toUpper = {\n        \"a\": \"A\", \"b\"\
    : \"B\", \"c\": \"C\", \"d\": \"D\", \"e\": \"E\", \"f\": \"F\", \"g\": \"G\"\
    , \"h\": \"H\", \"i\": \"I\", \"j\": \"J\", \"k\": \"K\", \"l\": \"L\", \"m\"\
    : \"M\", \"n\": \"N\", \"o\": \"O\", \"p\": \"P\", \"q\": \"Q\", \"r\": \"R\"\
    , \"s\": \"S\", \"t\": \"T\", \"u\": \"U\", \"v\": \"V\", \"w\": \"W\", \"x\"\
    : \"X\", \"y\": \"Y\", \"z\": \"Z\", \n    };\n    map<string, string> toLower\
    \ = {\n        \"a\": \"a\", \"b\": \"b\", \"c\": \"c\", \"d\": \"d\", \"e\":\
    \ \"e\", \"f\": \"f\", \"g\": \"g\", \"h\": \"h\", \"i\": \"i\", \"j\": \"j\"\
    , \"k\": \"k\", \"l\": \"l\", \"m\": \"m\", \"n\": \"n\", \"o\": \"o\", \"p\"\
    : \"p\", \"q\": \"q\", \"r\": \"r\", \"s\": \"s\", \"t\": \"t\", \"u\": \"u\"\
    , \"v\": \"v\", \"w\": \"w\", \"x\": \"x\", \"y\": \"y\", \"z\": \"z\",\n    };\n\
    \    for (auto it: dict)\n    {\n        if (it.first.first != it.first.second)\n\
    \            return false;\n        if (toUpper[it.first.first] == it.first.second)\n\
    \            return false;\n        if (toLower[it.first.first] == it.first.second)\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuc6k5zak.d(24): Error: found \'':\'' when expecting \'';\''
    following statement\n/tmp/tmpuc6k5zak.d(24): Error: found \'':\'' when expecting
    \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24): Error: found \'':\'' when
    expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24): Error: found \'':\''
    when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24): Error: found
    \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24): Error:
    found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\n/tmp/tmpuc6k5zak.d(24):
    Error: found \'':\'' when expecting \'';\'' following statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpuc6k5zak.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (k, v) in dict \n    {\n        if ( k.toLowerCase()\
    \ in Nullable!(string[string].t) ) \n        {\n            return false;\n  \
    \      }\n    }\n    return true;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=dictionary,python\
    \ |>\nThis solution uses dict.__contains__ to check for existence of a key. \n\
    <code>\ndef check_dict_case(d):\n    for k,v in d.items():\n        if isinstance(k,str)\
    \ and k.islower():\n            return False\n        elif isinstance(k,str) and\
    \ k.isupper():\n            return False\n    return True\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=dictionary,python |>\nMy first approach would be to iterate over\
    \ all keys and check if each one is a string with islower() and isupper() methods.\
    \ \n<code>\ndef check_dict_case(dictionary):\n    for key, value in dictionary.items():\n\
    \        if type(value) is str:\n            if (key.islower() or key.isupper())\
    \ == True:\n                return False\n    return True\n</code>\nIt would return\
    \ True if all keys are lowercase or all keys are uppercase. \nIt will also return\
    \ True if the dictionary is empty, thus returning False\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 |>\nI think it would be more efficient if you check only keys instead\
    \ of whole dictionary\n<code>\ndef check_dict_case(dictionary):\n    for key,\
    \ value in dictionary.items():\n        if not isinstance(key,str) and not isinstance(value,str):\n\
    \            return False\n    return True\n</code>\n<|/ a tags=dictionary,python\
    \ |>\n<| a dscore=0 |>\nYou can make a function to check:\n<code>\ndef string_checker(str):\n\
    \  for i in str[::-1]:\n    if ord(i) >= 97 and ord(i) <= 122:\n      if ord(i)\
    \ - 32 > 25:\n        return False\n  return True\n</code>\nThen check all the\
    \ keys and values like this:\n<code>\nfor key, value in dictionary.items():\n\
    \  if type(value) is str:\n    if not string_checker(key):\n      return False\n\
    \  if not string_checker(value):\n    return False\nreturn True\n</code>\n<|/\
    \ a tags=dictionary,python |>\n<| c |>\nHow about `return (ord(i) - 32) > 25`?\n\
    <|/ c |>\n<| a tags=dictionary,python dscore=0 |>\nI assume that you are not allowed\
    \ to use any built-in function, including len(), isupper(), islower(), etc.\n\
    <code>\ndef checkDict(d):\n    for key, value in d.items():\n        if isinstance(key,str)\
    \ and key.isupper() and isinstance(value,str) and value.isupper():\n         \
    \   return False\n        elif key.islower() and value.islower():\n          \
    \  return False\n    return True\n</code>\n<|/ a |>\n<| a tags=dictionary,python\
    \ |>\nI \nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppjmayxo7.d(23): Error: no identifier for declarator v\n/tmp/tmppjmayxo7.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmppjmayxo7.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmppjmayxo7.d(23): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmppjmayxo7.d(32): Error: Declaration expected, not \''<\''\n/tmp/tmppjmayxo7.d(111):
    Error: Declaration expected, not \''assert\''\n/tmp/tmppjmayxo7.d(112): Error:
    Declaration expected, not \''assert\''\n/tmp/tmppjmayxo7.d(113): Error: Declaration
    expected, not \''assert\''\n/tmp/tmppjmayxo7.d(114): Error: Declaration expected,
    not \''assert\''\n/tmp/tmppjmayxo7.d(115): Error: Declaration expected, not \''assert\''\n/tmp/tmppjmayxo7.d(116):
    Error: Declaration expected, not \''assert\''\n/tmp/tmppjmayxo7.d(117): Error:
    Declaration expected, not \''assert\''\n/tmp/tmppjmayxo7.d(118): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppjmayxo7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(auto iter : dict) {\n        auto [key, value] = iter;\n\
    \        if (key.size() != value.size() || key < 'a' || key > 'z') return false;\n\
    \    }\n    return true;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=dictionary,python\
    \ |>\nThe above accepted answer from Rudi is correct in that it is only checking\
    \ to ensure that the key is upper case or lower case. \nThis is my way of handling\
    \ the problem:\n<code>\nif all(k.isupper() or k.islower() for k in dict_of_values.keys()):\n\
    \    return True\nelse:\n    return False\n</code>\n<|/ a dscore=1 |>\n<| a tags=dictionary,python\
    \ |>\nHere are some ways I can think of. My answer is in Python, but I hope it\
    \ helps.\nIn Java, the following code would work.\n<code>\npublic class CheckKeysAreInLowerCase\
    \ {\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpceoqz7l5.d(23): Error: no identifier for declarator iter\n/tmp/tmpceoqz7l5.d(23):
    Error: expression expected, not \'':\''\n/tmp/tmpceoqz7l5.d(23): Error: found
    \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmpceoqz7l5.d(24):
    Error: basic type expected, not [\n/tmp/tmpceoqz7l5.d(24): Error: found \'',\''
    when expecting \'']\''\n/tmp/tmpceoqz7l5.d(24): Error: semicolon expected, not
    \'']\''\n/tmp/tmpceoqz7l5.d(24): Error: found \'']\'' instead of statement\n/tmp/tmpceoqz7l5.d(29):
    Error: Declaration expected, not \''<\''\n/tmp/tmpceoqz7l5.d(50): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpceoqz7l5.d(51): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpceoqz7l5.d(52): Error: Declaration expected, not \''assert\''\n/tmp/tmpceoqz7l5.d(53):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpceoqz7l5.d(54): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpceoqz7l5.d(55): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpceoqz7l5.d(56): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpceoqz7l5.d(57): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpceoqz7l5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(key of dict)\n    {\n        foreach(char(char) in key)\n\
    \        {\n            if(islower(char))\n                throw \"Invalid dictionary\
    \ key for case check.\";\n            if(isupper(char))\n                throw\
    \ \"Invalid dictionary key for case check.\";\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9jdxthqu.d(23): Error: found \''dict\'' when expecting \'';\''\n/tmp/tmp9jdxthqu.d(23):
    Error: expression expected, not \'')\''\n/tmp/tmp9jdxthqu.d(24): Error: found
    \''{\'' when expecting \'')\''\n/tmp/tmp9jdxthqu.d(25): Error: function declaration
    without return type. (Note that constructors are always named \''this\'')\n/tmp/tmp9jdxthqu.d(25):
    Error: no identifier for declarator char(char)\n/tmp/tmp9jdxthqu.d(25): Error:
    found \''in\'' when expecting \'';\''\n/tmp/tmp9jdxthqu.d(27): Error: found \'')\''
    when expecting \''.\'' following char\n/tmp/tmp9jdxthqu.d(27): Error: found \'')\''
    when expecting identifier following \''char.\''\n/tmp/tmp9jdxthqu.d(28): Error:
    found \''throw\'' when expecting \'',\''\n/tmp/tmp9jdxthqu.d(28): Error: found
    \'';\'' when expecting \'',\''\n/tmp/tmp9jdxthqu.d(29): Error: expression expected,
    not \''if\''\n/tmp/tmp9jdxthqu.d(29): Error: found \'')\'' when expecting \''.\''
    following char\n/tmp/tmp9jdxthqu.d(29): Error: found \'')\'' when expecting identifier
    following \''char.\''\n/tmp/tmp9jdxthqu.d(30): Error: found \''throw\'' when expecting
    \'',\''\n/tmp/tmp9jdxthqu.d(30): Error: found \'';\'' when expecting \'',\''\n/tmp/tmp9jdxthqu.d(31):
    Error: expression expected, not \''}\''\n/tmp/tmp9jdxthqu.d(32): Error: found
    \''}\'' when expecting \'',\''\n/tmp/tmp9jdxthqu.d(33): Error: expression expected,
    not \''return\''\n/tmp/tmp9jdxthqu.d(33): Error: found \''true\'' when expecting
    \'',\''\n/tmp/tmp9jdxthqu.d(33): Error: expression expected, not \'';\''\n/tmp/tmp9jdxthqu.d(34):
    Error: found \''}\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp9jdxthqu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (!dict)\n        return false;\n    if (dict.size() == 0)\n\
    \        return false;\n    \n    foreach (key, value) in dict {\n        if (!is_string(value)\
    \ || !is_string(key))\n            return false;\n        \n        if (value.toLower()\
    \ != key)\n            return false;\n    }\n    return true;\n}\n\"\"\")\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqomvi8e7.d(28): Error: no identifier for declarator value\n/tmp/tmpqomvi8e7.d(28):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpqomvi8e7.d(28): Error: expression
    expected, not \''in\''\n/tmp/tmpqomvi8e7.d(28): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmpqomvi8e7.d(37): Error: Declaration expected, not \''""\''\n/tmp/tmpqomvi8e7.d(47):
    Error: unterminated string constant starting at /tmp/tmpqomvi8e7.d(47)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqomvi8e7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  // check dict\n  if (dict == null || dict.isNull) return true;\n\
    \  \n  // check key\n  auto keys = dict.keys;\n  for (auto key : keys) \n  {\n\
    \    if (key.isString() && !key.isLower() && !key.isUpper()) return false; \n\
    \  }\n  \n  return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2vzyzqnr.d(28): Error: no identifier for declarator key\n/tmp/tmp2vzyzqnr.d(28):
    Error: expression expected, not \'':\''\n/tmp/tmp2vzyzqnr.d(28): Error: found
    \''keys\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp2vzyzqnr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    // TODO: Support dictionaries with non-string keys\n    return\
    \ !dict.empty;\n}\n\"\"\"\n)\n</cell>\n<cell>\ncheck_dict_case([\"Name\": \"John\"\
    , \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n</cell>\n<cell>\ncheck_dict_case({})\n\
    </cell>\n<cell>\ncheck_dict_case({\"a\": \"apple\", \"b\": \"banana\"})\n</cell>\n\
    <cell>\ncheck_dict_case({\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"\
    })\n</cell>\n<cell>\ncheck_dict_case({\"a\": \"apple\", 8L: \"banana\", \"a\"\
    : \"apple\"})\n</cell>\n<cell>\ncheck_dict_case({\"a\": \"apple\", \"Name\": \"\
    John\", \"Age\": \"36\", \"City\": \"Houston\"})\n</cell>\n<cell>\ncheck_dict_case({\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n</cell>\n<text>\n\
    Exercise 9\nWrite a function that accepts a nullable integer and returns it if\
    \ it's in between 0 and 10, else returns null.\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiev8quyz.d(26): Error: Declaration expected, not \''""\''\n/tmp/tmpiev8quyz.d(62):
    Error: unterminated string constant starting at /tmp/tmpiev8quyz.d(62)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiev8quyz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    var res = true;\n    for (string k in dict) {\n        if (!isLowercase(k)\
    \ && !isUppercase(k)) {\n            res = false;\n            break;\n      \
    \  }\n    }\n    return res;\n}\n\"\"\")\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp02otchkf.d(24): Error: semicolon expected, not \''in\''\n/tmp/tmp02otchkf.d(24):
    Error: expression expected, not \''in\''\n/tmp/tmp02otchkf.d(24): Error: found
    \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmp02otchkf.d(32):
    Error: Declaration expected, not \''""\''\n/tmp/tmp02otchkf.d(42): Error: unterminated
    string constant starting at /tmp/tmp02otchkf.d(42)\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp02otchkf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tforeach ( key in dict) \n\t{\n\t\tif (!is_string(key)) return false;\n\
    \t\tif (!is_string(dict[key]))return false;\n\t}\n\treturn true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl2tipmb5.d(23): Error: no identifier for declarator key\n/tmp/tmpl2tipmb5.d(23):
    Error: found \''in\'' when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpl2tipmb5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v: dict)\n        if (!is_string(k))\n        {\n\
    \            return false;\n        }\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa00sb6ns.d(23): Error: no identifier for declarator v\n/tmp/tmpa00sb6ns.d(23):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpa00sb6ns.d(28): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpa00sb6ns.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.is_empty())\n        return true;\n    auto iter = dict.key_map().begin();\n\
    \    auto end = dict.key_map().end();\n    for (; iter != end; ++iter) {\n   \
    \     auto s = iter->first;\n        auto l = s.length();\n        auto us = s.c_str();\n\
    \        auto ul = us.length();\n        if (ul < l)\n            return false;\n\
    \        if (ul == l)\n            continue;\n        auto s0 = s.c_str();\n \
    \       auto l0 = l-1;\n        for (; s0 >= l0 && ul >= l0; --s0, --ul)\n   \
    \         if (*s0 == *us)\n                continue;\n        return false;\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgvkiesoq.d(28): Error: expression expected, not \''>\''\n/tmp/tmpgvkiesoq.d(28):
    Error: semicolon expected following auto declaration, not \''first\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgvkiesoq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(var key in dict)\n    {\n        if (!is_string(key))\
    \ return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpffl53djy.d(23): Error: found \''in\'' when expecting \'';\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpffl53djy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\treturn dict.isNotEmpty && all( key=> \n\t\t(dict[key] instanceof\
    \ String && key.toLowerCase().isLowerOrEqual(\"name\") || dict[key] instanceof\
    \ String && key.toUpperCase().isLowerOrEqual(\"name\")));\n}\nunittest\n{\n  \
    \  alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4fwlwg_2.d(24): Error: found \''instanceof\'' when expecting
    \'')\''\n/tmp/tmp4fwlwg_2.d(24): Error: found \''String\'' when expecting \'',\''\n/tmp/tmp4fwlwg_2.d(24):
    Error: expression expected, not \''&&\''\n/tmp/tmp4fwlwg_2.d(24): Error: found
    \''key\'' when expecting \'',\''\n/tmp/tmp4fwlwg_2.d(24): Error: found \''instanceof\''
    when expecting \'',\''\n/tmp/tmp4fwlwg_2.d(24): Error: found \'')\'' when expecting
    \'';\'' following return statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp4fwlwg_2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.length == 0)\n    {\n        return true;\n    }\n \
    \   else \n    {\n        for (int i = 0; i < dict.length; i++) \n        {\n\
    \            if (dict[\"a\"].toString() == dict[\"A\"].toString() || dict[\"B\"\
    ].toString() == dict[\"B\"].toString() || dict[\"A\"].toString() == dict[\"a\"\
    ].toString()) \n            {\n                continue;\n            }\n    \
    \        else \n            {\n                return false;\n            }\n\
    \        }\n        return true;\n    }\n}\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkhzvpw5e.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int sz = dict.size;\n    for(int i = 0; i < sz; i++) \n    {\n\
    \        string key = dict.keys[i];\n        if(key.empty())\n            return\
    \ false;\n        \n        auto c = toupper(key[0]);\n        if(c == key[0])\
    \ \n        {\n            key = key[1];\n        }\n        \n        auto cased\
    \ = std.casefold2(key);\n        if(c == cased) \n        {\n            dict.keys[i]\
    \ = key;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpilxb_1h6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (string key in dict) {\n        if (!(key in string))\
    \ {\n            return false;\n        }\n        if (!islower(key) || !isupper(key))\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\"\"\"\n\
    \        \n    def nullable(self):\n        return \"\"\"\nimport std.array;\n\
    import std.range;\nimport std.function;\nimport std.stdio;\nimport std.string;\n\
    import std.typecons;\nimport std.math;\n/*\n    \n    Check all keys in a dictionary\
    \ are either strings or ints.\n    Return true if the given dictionary is nullable\
    \ (all keys are either strings or ints),\n    else return false. The function\
    \ should return false if the given dictionary is empty.\n    \n    Examples:\n\
    \    >>> check_nullable_dict([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"\
    Houston\"].nullable)\n    true\n    >>> check_nullable_dict([\"Name\": \"John\"\
    , \"Age\": \"36\", \"City\": \"Houston\", 8L: \"banana\"].nullable)\n    false\n\
    \    >>> check_nullable_dict([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"\
    Houston\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    \n*/\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphzkwj3lz.d(23): Error: found \''in\'' when expecting \'';\''\n/tmp/tmphzkwj3lz.d(33):
    Error: Declaration expected, not \''""\''\n/tmp/tmphzkwj3lz.d(39): Error: identifier
    expected following package\n/tmp/tmphzkwj3lz.d(39): Error: \'';\'' expected\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphzkwj3lz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.isNull;\n}\n'''\n)\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps3j6dr3o.d(25): Error: unterminated character constant\n/tmp/tmps3j6dr3o.d(25):
    Error: Declaration expected, not \''21139520U\''\n/tmp/tmps3j6dr3o.d(25): Error:
    unterminated character constant\n/tmp/tmps3j6dr3o.d(31): Error: Declaration expected,
    not \''assert\''\n/tmp/tmps3j6dr3o.d(32): Error: Declaration expected, not \''assert\''\n/tmp/tmps3j6dr3o.d(33):
    Error: Declaration expected, not \''assert\''\n/tmp/tmps3j6dr3o.d(34): Error:
    Declaration expected, not \''assert\''\n/tmp/tmps3j6dr3o.d(35): Error: Declaration
    expected, not \''assert\''\n/tmp/tmps3j6dr3o.d(36): Error: Declaration expected,
    not \''assert\''\n/tmp/tmps3j6dr3o.d(37): Error: Declaration expected, not \''assert\''\n/tmp/tmps3j6dr3o.d(38):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps3j6dr3o.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if( !dict.exists ) \n    {\n        return false;\n    }\n  \
    \  return ( !dict.keys.any() || !dict.values.any() ) ? false : true;\n}\n\"\"\"\
    )\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2osdundo.d(29): Error: Declaration expected, not \''""\''\n/tmp/tmp2osdundo.d(39):
    Error: unterminated string constant starting at /tmp/tmp2osdundo.d(39)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2osdundo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto keys_to_lower: array<char, str> =\n    {\n        'A', 'B',\
    \ 'C', 'D', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    };\n    auto keys_to_upper:\
    \ array<char, str> =\n    {\n        'A', 'B', 'C', 'D', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\
    \ 'Y', 'Z',\n        'a', 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n\
    \    };\n    auto keys_unset: array<char, str> =\n    {\n        'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z',\n        'a', 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z',\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n    };\n\
    \    auto keys_exist: array<char, str> =\n    {\n        'A', 'B', 'C', 'D', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T',\
    \ 'U', 'V', 'W', 'X', 'Y', 'Z',\n        'a', 'b', 'c', 'd', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z',\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\
    \    };\n    auto keys_exist1: array<char, str> =\n    {\n        'A', 'B', 'C',\
    \ 'D', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R',\
    \ 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n        'a', 'b', 'c', 'd', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z',\n        '0', '1', '2', '3', '4', '5', '6', '7', '8',\
    \ '9',\n        'a', 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n\
    \        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n       \
    \ '0', '1', '2', '\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnq8sgavb.d(23): Error: no identifier for declarator keys_to_lower\n/tmp/tmpnq8sgavb.d(23):
    Error: found \'':\'' instead of statement\n/tmp/tmpnq8sgavb.d(28): Error: no identifier
    for declarator keys_to_upper\n/tmp/tmpnq8sgavb.d(28): Error: Declaration expected,
    not \'':\''\n/tmp/tmpnq8sgavb.d(35): Error: no identifier for declarator keys_unset\n/tmp/tmpnq8sgavb.d(35):
    Error: Declaration expected, not \'':\''\n/tmp/tmpnq8sgavb.d(42): Error: no identifier
    for declarator keys_exist\n/tmp/tmpnq8sgavb.d(42): Error: Declaration expected,
    not \'':\''\n/tmp/tmpnq8sgavb.d(50): Error: no identifier for declarator keys_exist1\n/tmp/tmpnq8sgavb.d(50):
    Error: Declaration expected, not \'':\''\n/tmp/tmpnq8sgavb.d(59): Error: unterminated
    character constant\n/tmp/tmpnq8sgavb.d(64): Error: Declaration expected, not \''assert\''\n/tmp/tmpnq8sgavb.d(65):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpnq8sgavb.d(66): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpnq8sgavb.d(67): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpnq8sgavb.d(68): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpnq8sgavb.d(69): Error: Declaration expected, not \''assert\''\n/tmp/tmpnq8sgavb.d(70):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpnq8sgavb.d(71): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnq8sgavb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return true;\n    \n    // check if all keys\
    \ are lowercase\n    int numLower = 0;\n    for (string key in dict) {\n     \
    \   string value = dict[key];\n        if (value.isNull) return true;\n      \
    \  if (!value.compareToIgnoreCase(key)) {\n            numLower++;\n        }\n\
    \    }\n    \n    // check if all keys are uppercase\n    int numUpper = 0;\n\
    \    for (string key in dict) {\n        string value = dict[key];\n        if\
    \ (value.isNull) return true;\n        if (!value.compareToIgnoreCase(key)) {\n\
    \            numUpper++;\n        }\n    }\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8tcnv3va.d(27): Error: semicolon expected, not \''in\''\n/tmp/tmp8tcnv3va.d(27):
    Error: expression expected, not \''in\''\n/tmp/tmp8tcnv3va.d(27): Error: found
    \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmp8tcnv3va.d(37):
    Error: semicolon expected, not \''in\''\n/tmp/tmp8tcnv3va.d(37): Error: expression
    expected, not \''in\''\n/tmp/tmp8tcnv3va.d(37): Error: found \''dict\'' when expecting
    \'';\'' following for condition\n/tmp/tmp8tcnv3va.d(44): Error: found \''unittest\''
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8tcnv3va.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tauto key = dict.get_fields();\n\tbool allStrings = true;\n\t\n\t\
    for (auto& v : key) {\n\t\tif (not is_str(v.first)) {\n\t\t\tallStrings = false;\n\
    \t\t}\n\t}\n\t\n\treturn allStrings;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxqlpttti.d(26): Error: basic type expected, not &\n/tmp/tmpxqlpttti.d(26):
    Error: no identifier for declarator int\n/tmp/tmpxqlpttti.d(26): Error: found
    \'':\'' when expecting \'';\'' following for condition\n/tmp/tmpxqlpttti.d(27):
    Error: found \''is_str\'' when expecting \'')\''\n/tmp/tmpxqlpttti.d(27): Error:
    found \'')\'' when expecting \'';\'' following statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpxqlpttti.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  foreach(key in dict, key < \"A\"){\n    bool isLower = true;\n\
    \    foreach(key2 in dict, key2 < \"a\"){\n      if(!(isLower && key2 != key &&\
    \ key2.toupper() == key2) || (!isLower && key2 != key && key2.tolower() == key2))\n\
    \        return false\n    }\n  }\n  return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpr3qw631w.d(23): Error: no identifier for declarator key\n/tmp/tmpr3qw631w.d(23):
    Error: found \''in\'' when expecting \'';\''\n/tmp/tmpr3qw631w.d(25): Error: no
    identifier for declarator key2\n/tmp/tmpr3qw631w.d(25): Error: found \''in\''
    when expecting \'';\''\n/tmp/tmpr3qw631w.d(28): Error: found \''}\'' when expecting
    \'';\'' following return statement\n/tmp/tmpr3qw631w.d(32): Error: found \''unittest\''
    instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr3qw631w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tforeach (k,v) in dict \n\t{\n\t\tif (isNull(to!string(k))) \n\t\
    \t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgp6gvzkp.d(23): Error: no identifier for declarator v\n/tmp/tmpgp6gvzkp.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpgp6gvzkp.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmpgp6gvzkp.d(23): Error: found \''dict\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgp6gvzkp.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    Nullable!(string) strKeys = dict.get_keys()\n    if !strKeys.is_empty()\
    \ then \n    {\n        for (string strKey in strKeys) \n        { \n        \
    \    if strKey.length() > 0 && !strKey.is_lowercase() \n                && !strKey.is_uppercase()\
    \ \n                return false\n        }\n    }\n    else \n    {\n       \
    \ return false\n    }\n    return true\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=c#,null,tuples,dictionary\
    \ |>\nI had a similar problem recently (in a different context) and I ended up\
    \ writing a custom method to determine if all elements in a dictionary are null.\n\
    <code>\npublic static bool AllElementsNull(Dictionary<string, object> dict)\n\
    {\n    foreach (var key in dict.Keys)\n    {\n        if (dict[key] == null)\n\
    \            return false;\n    }\n    return true;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=c#,null,tuples,dictionary |>\n<code>\npublic static bool IsAllNull(IDictionary<string,object>\
    \ values)\n{\n    var nonNullCount = values.Where(v => v != null).Count();\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpr5w14t8h.d(24): Error: semicolon expected, not \''if\''\n/tmp/tmpr5w14t8h.d(24):
    Error: found \''!\'' when expecting \''(\''\n/tmp/tmpr5w14t8h.d(24): Error: found
    \''then\'' when expecting \'')\''\n/tmp/tmpr5w14t8h.d(26): Error: semicolon expected,
    not \''in\''\n/tmp/tmpr5w14t8h.d(26): Error: expression expected, not \''in\''\n/tmp/tmpr5w14t8h.d(26):
    Error: found \''strKeys\'' when expecting \'';\'' following for condition\n/tmp/tmpr5w14t8h.d(28):
    Error: found \''strKey\'' when expecting \''(\''\n/tmp/tmpr5w14t8h.d(30): Error:
    found \''return\'' when expecting \'')\''\n/tmp/tmpr5w14t8h.d(31): Error: found
    \''}\'' when expecting \'';\'' following statement\n/tmp/tmpr5w14t8h.d(33): Error:
    found \''else\'' instead of statement\n/tmp/tmpr5w14t8h.d(38): Error: found \''}\''
    when expecting \'';\'' following return statement\n/tmp/tmpr5w14t8h.d(39): Error:
    found \''<\'' instead of statement\n/tmp/tmpr5w14t8h.d(51): Error: Declaration
    expected, not \''return\''\n/tmp/tmpr5w14t8h.d(52): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr5w14t8h.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, val) in dict {\n        if (!typeof(key) is string)\
    \ return false;\n        if (!typeof(val) is string) return false;\n    }\n  \
    \  return true;\n}\n</code>\n<|/ a tags=dictionary,c# |>\n<| a |>\n<code>\npublic\
    \ static bool AreDictionariesEqual(Dictionary<string, string> dict1, Dictionary<string,\
    \ string> dict2)\n{\n    var keysAreEqual = Equals(dict1.Keys, dict2.Keys);\n\
    \    foreach (var item in dict1.Where(kv => !dict2.ContainsKey(kv.Key))) \n  \
    \  {\n        keysAreEqual = false;\n        break;\n    }\n    return keysAreEqual;\n\
    }\n</code>\n<|/ a tags=dictionary,c# dscore=2 |>\n<| c |>\nIf you're using C#\
    \ 7 you can use the built-in `IsEqual` method instead of manually doing this and\
    \ returning a boolean.\n<|/ c |>\n<| c |>\nThis code will misbehave when keys\
    \ are compared with null.\n<|/ c |>\n<| a tags=dictionary,c# |>\nAs this question\
    \ has already been answered, I thought I would add a solution I came up with,\
    \ using LINQ.\n<code>\npublic static bool AreDictionariesEqual(Dictionary<string,\
    \ string> dict1, Dictionary<string, string> dict2)\n{\n    return dict1.Keys.All(k\
    \ => dict2.ContainsKey(k) && dict1[k] == dict2[k]);\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 tags=dictionary,c# |>\nHere is a way I came up with to compare\
    \ two dictionaries, even though it might be inefficient. \n<code>\npublic static\
    \ bool AreDictionariesEqual(Dictionary<string, string> dict1, Dictionary<string,\
    \ string> dict2)\n{\n    foreach(var key1 in dict1.Keys)\n    {\n        bool\
    \ match = false;\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5ynlaqwx.d(23): Error: no identifier for declarator val\n/tmp/tmp5ynlaqwx.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp5ynlaqwx.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmp5ynlaqwx.d(23): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmp5ynlaqwx.d(29): Error: Declaration expected, not \''<\''\n/tmp/tmp5ynlaqwx.d(36):
    Error: Declaration expected, not \''foreach\''\n/tmp/tmp5ynlaqwx.d(39): Error:
    Declaration expected, not \''break\''\n/tmp/tmp5ynlaqwx.d(40): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5ynlaqwx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(var k in dict) \n        if(!(is_string(k) || is_string(tostring(k))))\n\
    \            return false;\n    return true;\n}\n</code>\n<|/ a |>\n<| a dscore=1\
    \ tags=c# |>\nThis seems to work for me and is less verbose than some of the other\
    \ solutions:\n<code>\nprivate bool IsDictEmpty(Dictionary<string, object> dict)\n\
    {\n    return dict.Count < 1;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n\
    using System.Collections.Generic;\n...\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfz4bx405.d(23): Error: found \''in\'' when expecting \'';\''\n/tmp/tmpfz4bx405.d(28):
    Error: Declaration expected, not \''<\''\n/tmp/tmpfz4bx405.d(36): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfz4bx405.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict do\n       if  not (v is! string)  or \
    \ \n          not (str.toLower(k) == v) or\n          not (str.toUpper(k) == v)\n\
    \           then \n           return false;\n    return true;\n}\n</code>\n<|/\
    \ a tags=d,language-agnostic |>\n<| c |>\nI believe that the OP wants to return\
    \ `false` if the dictionary is empty, or not only containing strings (i.e. no\
    \ number or other data types)\n<|/ c |>\n<| c |>\nYou can't use `.nullable` on\
    \ a `string` array.\n<|/ c |>\n<| c |>\nI believe that \"string\" array means\
    \ null terminated array of chars (array of strings).\n<|/ c |>\n<| c |>\nI thought\
    \ it was a pointer to a std.array.\n<|/ c |>\n<| c |>\nI meant a string array.\
    \ Sorry if that wasn't clear.\n<|/ c |>\n<| a tags=d,language-agnostic |>\nI wrote\
    \ a simple function in C#:\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpguyjmrve.d(23): Error: no identifier for declarator v\n/tmp/tmpguyjmrve.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpguyjmrve.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmpguyjmrve.d(23): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmpguyjmrve.d(24): Error: found \''not\'' when expecting \''(\''\n/tmp/tmpguyjmrve.d(24):
    Error: found \''or\'' when expecting \'')\''\n/tmp/tmpguyjmrve.d(25): Error: found
    \''or\'' when expecting \'';\'' following statement\n/tmp/tmpguyjmrve.d(26): Error:
    found \''not\'' when expecting \''while\''\n/tmp/tmpguyjmrve.d(27): Deprecation:
    do-while statement without terminating ; is deprecated\n/tmp/tmpguyjmrve.d(28):
    Error: found \''return\'' when expecting \'';\'' following statement\n/tmp/tmpguyjmrve.d(31):
    Error: Declaration expected, not \''<\''\n/tmp/tmpguyjmrve.d(37): Error: unterminated
    character constant\n/tmp/tmpguyjmrve.d(46): Error: unterminated character constant\n/tmp/tmpguyjmrve.d(55):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpguyjmrve.d(56): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpguyjmrve.d(57): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpguyjmrve.d(58): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpguyjmrve.d(59): Error: Declaration expected, not \''assert\''\n/tmp/tmpguyjmrve.d(60):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpguyjmrve.d(61): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpguyjmrve.d(62): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpguyjmrve.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    \n    for (auto k : dict)\n    {\n        //assert (k.length()\
    \ == 2); // TODO\n        auto l = k.toLowerCase();\n        if (!std::equal(l.begin(),\
    \ l.end(), k.begin(), k.end()))\n            return false;\n    }\n    return\
    \ true;\n}\n\"\"\")\nunittest\n{\n    alias candidate = check_dict_case;\n\n \
    \   assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuftb2a_3.d(24): Error: no identifier for declarator k\n/tmp/tmpuftb2a_3.d(24):
    Error: expression expected, not \'':\''\n/tmp/tmpuftb2a_3.d(24): Error: found
    \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmpuftb2a_3.d(28):
    Error: found \'':\'' when expecting \'')\''\n/tmp/tmpuftb2a_3.d(28): Error: found
    \'':\'' instead of statement\n/tmp/tmpuftb2a_3.d(33): Error: Declaration expected,
    not \''""\''\n/tmp/tmpuftb2a_3.d(43): Error: unterminated string constant starting
    at /tmp/tmpuftb2a_3.d(43)\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuftb2a_3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool success = true;\n    foreach(auto it, dict)\n        success\
    \ = success && islower(it) || isupper(it);\n    return success;\n}\n</code>\n\
    <|/ a |>\n<| c |>\n`check_dict_case(\"A\") == \"a\"` will fail (`is_lower` returns\
    \ true if the char is not a letter, which is probably not what you want).\n<|/\
    \ c |>\n<| c |>\nI agree. Fixed the typo now\n<|/ c |>\n<| c |>\nI appreciate\
    \ the effort to explain the code and give an example. While this solution does\
    \ solve the problem at hand, I'm afraid that someone might come up with a solution\
    \ that is more elegant and more scalable. Also, I guess you missed the fact that\
    \ this solution requires C++17. Thank you anyways!\n<|/ c |>\n<| a tags=c++,std,c++17\
    \ |>\nYou can use std::all_of() with a lambda expression:\n<code>\n#include <algorithm>\n\
    #include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp379ky9v1.d(24): Error: basic type expected, not auto\n/tmp/tmp379ky9v1.d(24):
    Error: no identifier for declarator int\n/tmp/tmp379ky9v1.d(24): Error: found
    \''auto\'' when expecting \'';\''\n/tmp/tmp379ky9v1.d(28): Error: Declaration
    expected, not \''<\''\n/tmp/tmp379ky9v1.d(37): Error: unterminated character constant\n/tmp/tmp379ky9v1.d(51):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp379ky9v1.d(52): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp379ky9v1.d(53): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp379ky9v1.d(54): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp379ky9v1.d(55): Error: Declaration expected, not \''assert\''\n/tmp/tmp379ky9v1.d(56):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp379ky9v1.d(57): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp379ky9v1.d(58): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp379ky9v1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null || !dict.isEmpty)\n        return false; \n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuui55trw.d(25): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuui55trw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tif(dict.isNull) \n\t\treturn false;\n\tif(dict.type == \"dict\"\
    ){\n\t\tfor(string key in dict.keys){\n\t\t\tif(key.lower() == key){\n\t\t\t\t\
    return false;\n\t\t\t}else if(key.upper() == key){\n\t\t\t\treturn false;\n\t\t\
    \t}\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuewcus64.d(26): Error: semicolon expected, not \''in\''\n/tmp/tmpuewcus64.d(26):
    Error: expression expected, not \''in\''\n/tmp/tmpuewcus64.d(26): Error: found
    \''dict\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpuewcus64.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  if (dict.empty()) return true;\n  auto first = dict.keys().begin();\n\
    \  auto last = dict.keys().end();\n  for(auto it = first != last ; ++it )\n  {\n\
    \    auto key = *it;\n    \n    auto lower = string::to_lower(key);\n    auto\
    \ upper = string::to_upper(key);\n    \n    if (lower != key) \n    {\n      return\
    \ false;\n    }\n    if (upper != key)\n    {\n      return false;\n    }\n  }\n\
    \  return true;\n}\n</code>\n<|/ a tags=associative-array,std,c++,containers,c++11\
    \ |>\n<| a tags=associative-array,std,c++,containers,c++11 |>\nFor what it's worth,\
    \ I wrote a small library that can compare C++ map containers with STL containers:\n\
    <code>\n#include <map>\n#include <iostream>\n#include <string>\n#include <list>\n\
    #include <algorithm>\n#include <iterator>\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfgo91pvm.d(26): Error: found \'')\'' when expecting \'';\''
    following for condition\n/tmp/tmpfgo91pvm.d(30): Error: semicolon expected following
    auto declaration, not \'':\''\n/tmp/tmpfgo91pvm.d(30): Error: found \'':\'' instead
    of statement\n/tmp/tmpfgo91pvm.d(31): Error: semicolon expected following auto
    declaration, not \'':\''\n/tmp/tmpfgo91pvm.d(31): Error: found \'':\'' instead
    of statement\n/tmp/tmpfgo91pvm.d(42): Error: found \''return\'' when expecting
    \'')\''\n/tmp/tmpfgo91pvm.d(44): Error: Declaration expected, not \''<\''\n/tmp/tmpfgo91pvm.d(47):
    Error: unterminated character constant\n/tmp/tmpfgo91pvm.d(59): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpfgo91pvm.d(60): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpfgo91pvm.d(61): Error: Declaration expected, not \''assert\''\n/tmp/tmpfgo91pvm.d(62):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpfgo91pvm.d(63): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpfgo91pvm.d(64): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpfgo91pvm.d(65): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpfgo91pvm.d(66): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfgo91pvm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict {\n        if(isNull(k)) {\n          \
    \  return false;\n        }\n        \n        if(k.toCString().isUpper()) {\n\
    \            return false;\n        }\n        \n        if(!k.toCString().isLower())\
    \ {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmd1d09hr.d(23): Error: no identifier for declarator v\n/tmp/tmpmd1d09hr.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpmd1d09hr.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmpmd1d09hr.d(23): Error: found \''dict\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmd1d09hr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    forall(dict, key -> key.key.type.isString() || key.key.type.isUppercaseString());\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphjz04v0w.d(23): Error: expression expected, not \''>\''\n/tmp/tmphjz04v0w.d(23):
    Error: found \''key\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmphjz04v0w.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = false;\n    if (dict)\n    {\n        for (auto\
    \ it : dict)\n        {\n            string key = it.first;\n            if (is_string(key))\n\
    \            {\n                if (!is_string(it.second))\n                {\n\
    \                    result = false;\n                    break;\n           \
    \     }\n            }\n            else\n            {\n                if (is_string(it.second))\n\
    \                {\n                    result = false;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa1hfopnc.d(26): Error: no identifier for declarator it\n/tmp/tmpa1hfopnc.d(26):
    Error: expression expected, not \'':\''\n/tmp/tmpa1hfopnc.d(26): Error: found
    \''dict\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpa1hfopnc.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, val) in dict \n    {\n        if (std.typecons.isUpper(std.string.upcase(k)))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5lf494ml.d(23): Error: no identifier for declarator val\n/tmp/tmp5lf494ml.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp5lf494ml.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmp5lf494ml.d(23): Error: found \''dict\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5lf494ml.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    assert(dict != null);\n    return !dict.hasKey(\"Name\") && !dict.hasKey(8L);\n\
    }\n\"\"\")\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptf7dn_hm.d(26): Error: Declaration expected, not \''""\''\n/tmp/tmptf7dn_hm.d(36):
    Error: unterminated string constant starting at /tmp/tmptf7dn_hm.d(36)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptf7dn_hm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(string str in dict) {\n        if(str.isLowercase())\
    \ return true;\n        if(str.isUppercase()) return true;\n    }\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxnc4hpcs.d(23): Error: found \''in\'' when expecting \'';\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxnc4hpcs.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull)\n        return false; \n    \n    auto &dict\
    \ = dict.get_ref();\n    for (auto &&v : dict) {\n        if (!(v.first.type.isString()\
    \ || v.first.type.isEnum()))\n            return false; \n    } \n    return true;\
    \ \n}\n''';\n$code = '#include \"std.hpp\"';\n$code .= '\n/*\nunittest\n{\n  \
    \  alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2zlkgt_7.d(26): Error: basic type expected, not &\n/tmp/tmp2zlkgt_7.d(26):
    Error: no identifier for declarator int\n/tmp/tmp2zlkgt_7.d(26): Error: found
    \''&\'' instead of statement\n/tmp/tmp2zlkgt_7.d(27): Error: basic type expected,
    not &&\n/tmp/tmp2zlkgt_7.d(27): Error: no identifier for declarator int\n/tmp/tmp2zlkgt_7.d(27):
    Error: expression expected, not \''&&\''\n/tmp/tmp2zlkgt_7.d(27): Error: found
    \''v\'' when expecting \'';\'' following for condition\n/tmp/tmp2zlkgt_7.d(27):
    Error: expression expected, not \'':\''\n/tmp/tmp2zlkgt_7.d(27): Error: found
    \''dict\'' when expecting \'')\''\n/tmp/tmp2zlkgt_7.d(27): Error: found \'')\''
    instead of statement\n/tmp/tmp2zlkgt_7.d(31): Error: Declaration expected, not
    \''return\''\n/tmp/tmp2zlkgt_7.d(32): Error: unrecognized declaration\n/tmp/tmp2zlkgt_7.d(33):
    Error: unterminated character constant\n/tmp/tmp2zlkgt_7.d(33): Error: unterminated
    character constant\n/tmp/tmp2zlkgt_7.d(34): Error: unterminated character constant\n/tmp/tmp2zlkgt_7.d(34):
    Error: unterminated character constant\n/tmp/tmp2zlkgt_7.d(35): Error: unterminated
    character constant\n/tmp/tmp2zlkgt_7.d(36): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2zlkgt_7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tif(dict.empty())\n\t\treturn true;\n\tauto keys = dict.keys;\n\t\
    for(auto it = keys.begin(); it != keys.end(); ++it) \n\t{\n\t\tauto &key = *it;\n\
    \t\tauto &value = dict[key];\n\t\tif(key.length() != value.len) \n\t\t\treturn\
    \ false;\n\t\tauto c = tolower(key[0]);\n\t\tif(c >= 'a' && c <= 'z') \n\t\t\t\
    continue;\n\t\telse \n\t\t\treturn false;\n\t}\n\treturn true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9hexqpdh.d(28): Error: basic type expected, not &\n/tmp/tmp9hexqpdh.d(28):
    Error: no identifier for declarator int\n/tmp/tmp9hexqpdh.d(28): Error: found
    \''&\'' instead of statement\n/tmp/tmp9hexqpdh.d(29): Error: basic type expected,
    not &\n/tmp/tmp9hexqpdh.d(29): Error: no identifier for declarator int\n/tmp/tmp9hexqpdh.d(29):
    Error: found \''&\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp9hexqpdh.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return true;\n    for (auto v : dict)\n    \
    \    if (v.key.isLower()) continue;\n        else if (v.key.isUpper()) continue;\n\
    \        else return false;\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy891pv7o.d(24): Error: no identifier for declarator v\n/tmp/tmpy891pv7o.d(24):
    Error: expression expected, not \'':\''\n/tmp/tmpy891pv7o.d(24): Error: found
    \''dict\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpy891pv7o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = true;\n    for (auto key: string.range(dict.keys))\n\
    \    {\n        string val = dict[key];\n        auto is_upper = string::caseInsensitiveCompare(val,\
    \ key) == 0;\n        auto is_lower = string::caseInsensitiveCompare(key, val)\
    \ == 0;\n        if (!is_upper && !is_lower)\n        {\n            result =\
    \ false;\n            break;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbaz22lbb.d(24): Error: no identifier for declarator key\n/tmp/tmpbaz22lbb.d(24):
    Error: expression expected, not \'':\''\n/tmp/tmpbaz22lbb.d(24): Error: found
    \''string\'' when expecting \'';\'' following for condition\n/tmp/tmpbaz22lbb.d(27):
    Error: semicolon expected following auto declaration, not \'':\''\n/tmp/tmpbaz22lbb.d(27):
    Error: found \'':\'' instead of statement\n/tmp/tmpbaz22lbb.d(28): Error: semicolon
    expected following auto declaration, not \'':\''\n/tmp/tmpbaz22lbb.d(28): Error:
    found \'':\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpbaz22lbb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto it = dict.begin();\n    if (it == dict.end()) {\n      \
    \  return false;\n    }\n    ++it;\n    for(auto it2 = dict.begin(); it2 != dict.end();\
    \ ++it2) {\n        if (!(Stringify(it->first) == Stringify(it2->first))) {\n\
    \            return false;\n        }\n        ++it2;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpwzmg5ewo.d(29): Error: expression expected, not \''>\''\n/tmp/tmpwzmg5ewo.d(29):
    Error: found \''first\'' when expecting \'',\''\n/tmp/tmpwzmg5ewo.d(29): Error:
    expression expected, not \''>\''\n/tmp/tmpwzmg5ewo.d(29): Error: found \''first\''
    when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwzmg5ewo.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tbool flag = true;\n\tforeach(i32 i=1, i<len(dict); i++) {\n\t\t\
    flag &= str.islower(dict[tostring(i)])\n\t\tflag &= str.isupper(dict[tostring(i)])\n\
    \t}\n\t\n\treturn flag;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbbqj9w12.d(24): Error: found \''=\'' when expecting \'';\''\n/tmp/tmpbbqj9w12.d(24):
    Error: found \'';\'' when expecting \'')\''\n/tmp/tmpbbqj9w12.d(24): Error: found
    \'')\'' when expecting \'';\'' following statement\n/tmp/tmpbbqj9w12.d(26): Error:
    found \''flag\'' when expecting \'';\'' following statement\n/tmp/tmpbbqj9w12.d(26):
    Error: found \''&=\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpbbqj9w12.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) {\n        if (string) k = std.tolowercase(k);\n\
    \        if (string) k = std.touppercase(k);\n        if (!dict.is(k)) return\
    \ false;\n    }\n    return true;\n}\n</code>\n<|/ a tags=types,d,dmd dscore=2\
    \ |>\n<| a dscore=1 tags=types,d,dmd |>\nI've had a little bit of a play around\
    \ and came up with this that seems to work pretty well:\n<code>\nunittest\n{\n\
    \    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps66_2jq7.d(23): Error: no identifier for declarator v\n/tmp/tmps66_2jq7.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmps66_2jq7.d(26): Error: identifier
    expected following \''.\'', not \''is\''\n/tmp/tmps66_2jq7.d(28): Error: found
    \''return\'' when expecting \'')\''\n/tmp/tmps66_2jq7.d(30): Error: Declaration
    expected, not \''<\''\n/tmp/tmps66_2jq7.d(33): Error: unterminated character constant\n/tmp/tmps66_2jq7.d(39):
    Error: Declaration expected, not \''assert\''\n/tmp/tmps66_2jq7.d(40): Error:
    Declaration expected, not \''assert\''\n/tmp/tmps66_2jq7.d(41): Error: Declaration
    expected, not \''assert\''\n/tmp/tmps66_2jq7.d(42): Error: Declaration expected,
    not \''assert\''\n/tmp/tmps66_2jq7.d(43): Error: Declaration expected, not \''assert\''\n/tmp/tmps66_2jq7.d(44):
    Error: Declaration expected, not \''assert\''\n/tmp/tmps66_2jq7.d(45): Error:
    Declaration expected, not \''assert\''\n/tmp/tmps66_2jq7.d(46): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps66_2jq7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(auto iter: dict)\n    {\n        if (typeof(iter.key) !=\
    \ \"string\" && !(typeof(iter.key) != \"number\" && typeof(iter.key) != \"bool\"\
    ))\n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\n\"\"\"\n)\n</cell>\n<cell>\nfrom nbdev.export import notebook2script; notebook2script()\n\
    </cell>\n<cell>\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp60dkyhl6.d(23): Error: no identifier for declarator iter\n/tmp/tmp60dkyhl6.d(23):
    Error: expression expected, not \'':\''\n/tmp/tmp60dkyhl6.d(23): Error: found
    \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmp60dkyhl6.d(32):
    Error: Declaration expected, not \''""\''\n/tmp/tmp60dkyhl6.d(48): Error: unterminated
    string constant starting at /tmp/tmp60dkyhl6.d(48)\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp60dkyhl6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tif(!dict)\n\t\treturn false;\n\tfor(auto [key, val] : (pair!(string[string],\
    \ string))[]) \n\t{\n\t\tif(key.length() != val.length()) return false;\n\t\t\
    if(key.isUppercase() != val.isUppercase()) return false;\n\t}\n\treturn true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd9qel8mv.d(25): Error: basic type expected, not [\n/tmp/tmpd9qel8mv.d(25):
    Error: found \'',\'' when expecting \'']\''\n/tmp/tmpd9qel8mv.d(25): Error: semicolon
    expected, not \'']\''\n/tmp/tmpd9qel8mv.d(25): Error: expression expected, not
    \'']\''\n/tmp/tmpd9qel8mv.d(25): Error: found \'':\'' when expecting \'';\'' following
    for condition\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd9qel8mv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  // your code goes here\n  int i = 0;\n  bool all_strings = false;\n\
    \  while(i < dict.len) {\n    string key = dict.get(i).getName();\n    string\
    \ lower = tolower((dict.get(i).getName()))\n    bool is_lower = lower.compare(key);\n\
    \    if(is_lower) {\n      all_strings = true;\n    }\n    else {\n      all_strings\
    \ = false;\n      break;\n    }\n    i = i+1;\n  }\n  return all_strings;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nI haven't tried it yet but that's a pretty\
    \ good idea. Thanks!\n<|/ c |>\n<| c |>\nCan you tell me how this works `tolower((dict.get(i).getName()))`\n\
    <|/ c |>\n<| c |>\nHi Chris, sorry for my ignorance. I'm trying to get my head\
    \ around this. What is `tolower` doing?\n<|/ c |>\n<| c |>\n`tolower` is a function\
    \ that will lower case the string. Just like in Python. [Here's the documentation](http://www.cplusplus.com/reference/algorithm/tolower/).\n\
    <|/ c |>\n<| c |>\nOkay, but what does it do when it's applied to the key of the\
    \ dict? What is dict.get(i).getName()?\n<|/ c |>\n<| a tags=std-pair,stdmap,c++,dictionary,stl\
    \ |>\nIf you don't have access to C++20 then you can try this\n<code>\n#include\
    \ <iostream>\n#include <string>\n#include <map>\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpjh4_ifqw.d(29): Error: semicolon expected, not \''bool\''\n/tmp/tmpjh4_ifqw.d(41):
    Error: Declaration expected, not \''<\''\n/tmp/tmpjh4_ifqw.d(44): Error: unterminated
    character constant\n/tmp/tmpjh4_ifqw.d(44): Error: unterminated character constant\n/tmp/tmpjh4_ifqw.d(50):
    Error: unterminated character constant\n/tmp/tmpjh4_ifqw.d(53): Error: unterminated
    character constant\n/tmp/tmpjh4_ifqw.d(56): Error: unterminated character constant\n/tmp/tmpjh4_ifqw.d(59):
    Error: unterminated character constant\n/tmp/tmpjh4_ifqw.d(68): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpjh4_ifqw.d(69): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpjh4_ifqw.d(70): Error: Declaration expected, not \''assert\''\n/tmp/tmpjh4_ifqw.d(71):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpjh4_ifqw.d(72): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpjh4_ifqw.d(73): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpjh4_ifqw.d(74): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpjh4_ifqw.d(75): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjh4_ifqw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v: dict)\n        if(!is_integer(k) || !is_integer(v)\
    \ || k != v)\n            return false;\n    return true;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=types,haskell,associative-array |>\nThe above solutions don't\
    \ seem to play nicely with Data.Array.\nHere's a solution using Data.Array. Basically,\
    \ we're converting everything to a Data.Array.Array1 with a custom function which\
    \ allows us to perform elementwise equality checks. It's probably more efficient\
    \ than converting to a Data.Array.Array1 via Data.Array.IArray.\n<code>\nimport\
    \ qualified Data.Array.IArray as IArray\nimport qualified Data.Array as Array\n\
    import qualified Data.Array.Unboxed as UA\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp57b4hcpn.d(23): Error: no identifier for declarator v\n/tmp/tmp57b4hcpn.d(23):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp57b4hcpn.d(28): Error: Declaration
    expected, not \''<\''\n/tmp/tmp57b4hcpn.d(31): Error: unterminated character constant\n/tmp/tmp57b4hcpn.d(32):
    Error: unterminated character constant\n/tmp/tmp57b4hcpn.d(32): Error: unterminated
    character constant\n/tmp/tmp57b4hcpn.d(32): Error: unterminated character constant\n/tmp/tmp57b4hcpn.d(41):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp57b4hcpn.d(42): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp57b4hcpn.d(43): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp57b4hcpn.d(44): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp57b4hcpn.d(45): Error: Declaration expected, not \''assert\''\n/tmp/tmp57b4hcpn.d(46):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp57b4hcpn.d(47): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp57b4hcpn.d(48): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp57b4hcpn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(string key in dict)\n        if(!std.string.lower_case(key)\
    \ || !std.string.upper_case(key))\n            return false;\n    return true;\n\
    }\n</code>\n<|/ a dscore=2 tags=d,types,function |>\n<| a dscore=1 |>\nA function\
    \ that will return true if all keys in an associative array are strings in lower\
    \ case or all keys are strings in upper case, else return false:\n<code>\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmavta7dr.d(23): Error: found \''in\'' when expecting \'';\''\n/tmp/tmpmavta7dr.d(28):
    Error: Declaration expected, not \''<\''\n/tmp/tmpmavta7dr.d(37): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpmavta7dr.d(38): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpmavta7dr.d(39): Error: Declaration expected, not \''assert\''\n/tmp/tmpmavta7dr.d(40):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpmavta7dr.d(41): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpmavta7dr.d(42): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpmavta7dr.d(43): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpmavta7dr.d(44): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmavta7dr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tif(dict.length == 0)\n\t\treturn false;\n\tfor (auto it : dict)\n\
    \t{\n\t\tif(it.first < \"A\" || it.first > \"Z\")\n\t\t\treturn false;\n\t}\n\t\
    \n\tfor(auto it : dict){\n\t\tif(it.second < \"a\" || it.second > \"z\")\n\t\t\
    \treturn false;\n\t}\n\treturn true;\n}\n\"\"\"\n)\n</cell>\n<text>\nTuple\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp49zes_8p.d(25): Error: no identifier for declarator it\n/tmp/tmp49zes_8p.d(25):
    Error: expression expected, not \'':\''\n/tmp/tmp49zes_8p.d(25): Error: found
    \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmp49zes_8p.d(31):
    Error: no identifier for declarator it\n/tmp/tmp49zes_8p.d(31): Error: expression
    expected, not \'':\''\n/tmp/tmp49zes_8p.d(31): Error: found \''dict\'' when expecting
    \'';\'' following for condition\n/tmp/tmp49zes_8p.d(37): Error: Declaration expected,
    not \''""\''\n/tmp/tmp49zes_8p.d(51): Error: unterminated string constant starting
    at /tmp/tmp49zes_8p.d(51)\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp49zes_8p.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto kv = dict.keyvalues();\n    forall(kv, [&](auto pair){ \n\
    \        auto key = pair.key();\n        if (pair.key().length() == 0){\n    \
    \        error(\"Null keys are not allowed as key names in an associative array.\"\
    );\n        }\n        auto lowercase = make_tuple(string(\"a\"), string(\"A\"\
    ), string(\"b\"), string(\"B\"));\n        auto uppercase = make_tuple(string(\"\
    A\"), string(\"a\"), string(\"B\"), string(\"B\"));\n        if (is_in_tuple(key.toLowerCase(),\
    \ lowercase)){\n            if (is_in_tuple(key.toUpperCase(), uppercase)){\n\
    \                return true;\n            } else {\n                error(\"\
    Key '\" + key + \"' has different case than 'a' and 'A' where it should be either\
    \ 'a' or 'A'.\");\n            }\n        } else {\n            error(\"Key '\"\
    \ + key + \"' is not lowercase or uppercase as 'a' and 'A' where it should be\
    \ either 'a' or 'A'.\");\n        }\n        return false;\n    });\n    return\
    \ false;\n}\n#endif\n#endif\n</code>\n<|/ a |>\n<| a dscore=0 tags=c++,dictionary,std-pair\
    \ |>\nFor C++20 it's pretty easy to create a custom comparator:\n<code>\nstruct\
    \ CustomMap {\n    std::unordered_map<std::string, std::string, std::hash<std::string>,\
    \ std::equal_to<std::string>> m_map;\n};\n</code>\nTo create a comparator:\n<code>\n\
    std::function<bool(std::pair<std::string,std::string>, const CustomMap&)> compareMapKeys\n\
    {\n    using std::swap;\n    return [&](std::pair<std::string, std::string> const\
    \ &left, const CustomMap &right)\n    {\n        auto &key = left.first;\n   \
    \     if (left.first == right.m_map.end())\n        {\n            return false;\n\
    \        }\n        if (right.m_map.find(key) == right.m_map.end())\n        {\n\
    \            return true;\n        }\n        auto &value = right.m_map.find(key);\n\
    \        swap(value, left.second);\n        return true;\n    };\n}\n</code>\n\
    Then you can use this in your code:\n<code>\nstd::unordered_map<std::string, std::string,\
    \ std::hash<std::string>, std::equal_to<std::string>> map;\nCustomMap custom_map;\n\
    </code>\nYou will need to create a map constructor that takes a comparator and\
    \ use it:\n<code>\nCustomMap(CustomMap const &other, std::function<bool(std::pair<std::string,std::string>,\
    \ const CustomMap&)> comparator)\n{\n    std::for_each(other.m_map.begin(), other.m_map.end(),\
    \ [&](std::pair<std::string, std::string> const &pair)\n    {\n        map.\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkuycevfq.d(24): Error: expression expected, not \'']\''\n/tmp/tmpkuycevfq.d(24):
    Error: expression expected, not \''auto\''\n/tmp/tmpkuycevfq.d(24): Error: found
    \''pair\'' when expecting \'',\''\n/tmp/tmpkuycevfq.d(24): Error: found \''{\''
    when expecting \'',\''\n/tmp/tmpkuycevfq.d(25): Error: expression expected, not
    \''auto\''\n/tmp/tmpkuycevfq.d(25): Error: found \''key\'' when expecting \'',\''\n/tmp/tmpkuycevfq.d(25):
    Error: expression expected, not \''=\''\n/tmp/tmpkuycevfq.d(25): Error: found
    \''pair\'' when expecting \'',\''\n/tmp/tmpkuycevfq.d(25): Error: found \'';\''
    when expecting \'',\''\n/tmp/tmpkuycevfq.d(26): Error: expression expected, not
    \''if\''\n/tmp/tmpkuycevfq.d(26): Error: found \''{\'' when expecting \'',\''\n/tmp/tmpkuycevfq.d(27):
    Error: found \'';\'' when expecting \'',\''\n/tmp/tmpkuycevfq.d(28): Error: expression
    expected, not \''}\''\n/tmp/tmpkuycevfq.d(29): Error: found \''auto\'' when expecting
    \'',\''\n/tmp/tmpkuycevfq.d(29): Error: found \'';\'' when expecting \'',\''\n/tmp/tmpkuycevfq.d(30):
    Error: expression expected, not \''auto\''\n/tmp/tmpkuycevfq.d(30): Error: found
    \''uppercase\'' when expecting \'',\''\n/tmp/tmpkuycevfq.d(30): Error: expression
    expected, not \''=\''\n/tmp/tmpkuycevfq.d(30): Error: found \''make_tuple\'' when
    expecting \'',\''\n/tmp/tmpkuycevfq.d(30): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmpkuycevfq.d(31): Error: expression expected, not \''if\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkuycevfq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !is_empty(dict) && all(\n        has_key(dict, k) => k.length\
    \ == 0 || is_lower(k) || is_upper(k), \n        dict\n    );\n}\n/*\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz3n1hjs0.d(24): Error: found \''=>\'' when expecting \'',\''\n/tmp/tmpz3n1hjs0.d(28):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz3n1hjs0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.containsKey(null) && dict.containsKey(String.toLowerInvariant(null));\n\
    }\n/*\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprrszma4t.d(25): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmprrszma4t.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.length == 0) {\n        return false;\n    }\n    for\
    \ each (string key in dict) \n    {\n        if ((key.length < 1) || (key.length\
    \ > 2)) {\n            return false;\n        }\n        if (!((key.length ==\
    \ 1) && (key.isUpper))) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqlin42b1.d(26): Error: found \''each\'' when expecting \''(\''\n/tmp/tmpqlin42b1.d(26):
    Error: found \''in\'' when expecting \'')\''\n/tmp/tmpqlin42b1.d(26): Error: missing
    { ... } for function literal\n/tmp/tmpqlin42b1.d(26): Error: found \''dict\''
    when expecting \'';\'' following statement\n/tmp/tmpqlin42b1.d(26): Error: expression
    expected, not \'')\''\n/tmp/tmpqlin42b1.d(27): Error: found \''{\'' when expecting
    \'';\'' following for condition\n/tmp/tmpqlin42b1.d(28): Error: expression expected,
    not \''if\''\n/tmp/tmpqlin42b1.d(28): Error: found \''{\'' when expecting \'')\''\n/tmp/tmpqlin42b1.d(31):
    Error: Declaration expected, not \''if\''\n/tmp/tmpqlin42b1.d(33): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqlin42b1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict.IsNull)\n    {\n        return true;\n    }\n    \n \
    \   foreach(key in dict.Keys)\n    {\n        string lower = tolower(key);\n \
    \       string upper = toupper(key);\n        \n        if(lower != upper && lower\
    \ != key)\n        {\n            return false;\n        }\n    }\n    \n    return\
    \ true;\n}\n</code>\n<|/ a dscore=4 tags=c++,generics,d |>\n<| a dscore=2 tags=c++,generics,d\
    \ |>\nAnother approach is using std.algorithm package as follows:\n<code>\nimport\
    \ std.algorithm;\nimport std.array;\nimport std.conv;\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbqffh2r9.d(28): Error: no identifier for declarator key\n/tmp/tmpbqffh2r9.d(28):
    Error: found \''in\'' when expecting \'';\''\n/tmp/tmpbqffh2r9.d(41): Error: Declaration
    expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbqffh2r9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tauto itr = dict.dict.begin();\n\tbool result = true;\n\tfor (auto\
    \ itr2 = dict.dict.begin(); itr != dict.dict.end(); ++itr, ++itr2) {\n\t\tstring\
    \ key = (string) *itr;\n\t\tstring val = (string) *itr2;\n\t\tif (key.isupper())\
    \ {\n\t\t\tif (!val.compare(val.to_lower())) {\n\t\t\t\tresult = false;\n\t\t\t\
    \tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!val.compare(val.to_upper())) {\n\t\
    \t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdbnl5_1i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  bool result = true;\n  for (auto iter: dict)\n    if (!(iter.first.isUpperCase\
    \ || iter.first.isLowerCase || iter.first.isDigit))\n      result = false;\n \
    \ return result;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n \
    \   assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqpxheiaa.d(24): Error: no identifier for declarator iter\n/tmp/tmpqpxheiaa.d(24):
    Error: expression expected, not \'':\''\n/tmp/tmpqpxheiaa.d(24): Error: found
    \''dict\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpqpxheiaa.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(string key in dict)\n    {\n        if(!dict.isNull(key))\n\
    \        {\n            if(!isString(key) || !isLowerCase(key) || !isUpperCase(key))\n\
    \                return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl_3kvaf5.d(23): Error: found \''in\'' when expecting \'';\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl_3kvaf5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null || dict.size < 1) return false;\n    for (auto\
    \ it = dict.begin(); it != dict.end(); it++) {\n        if (it.key().length !=\
    \ it.value().length) return false;\n        char ch1 = it.key()[0];\n        char\
    \ ch2 = it.value()[0]\n        if (ch1 != ch2) return false;\n    }\n    return\
    \ true;\n}\n</code>\n<|/ a |>\n<| a tags=c++,stl,c++17,std,dictionary |>\nFor\
    \ a C++17 solution using std::map and std::unordered_map, the following should\
    \ work:\n<code>\n#include <cassert>\n#include <unordered_map>\n#include <algorithm>\n\
    #include <vector>\nunittest\n{\n    alias candidate = check_dict_case;\n\n   \
    \ assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprd89ko7i.d(28): Error: semicolon expected, not \''if\''\n/tmp/tmprd89ko7i.d(32):
    Error: Declaration expected, not \''<\''\n/tmp/tmprd89ko7i.d(45): Error: Declaration
    expected, not \''assert\''\n/tmp/tmprd89ko7i.d(46): Error: Declaration expected,
    not \''assert\''\n/tmp/tmprd89ko7i.d(47): Error: Declaration expected, not \''assert\''\n/tmp/tmprd89ko7i.d(48):
    Error: Declaration expected, not \''assert\''\n/tmp/tmprd89ko7i.d(49): Error:
    Declaration expected, not \''assert\''\n/tmp/tmprd89ko7i.d(50): Error: Declaration
    expected, not \''assert\''\n/tmp/tmprd89ko7i.d(51): Error: Declaration expected,
    not \''assert\''\n/tmp/tmprd89ko7i.d(52): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprd89ko7i.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(key, value) in dict \n    \n    if (\n        key.isupper()\
    \ == false && \n        \n        key.islower() == false &&\n        \n      \
    \  value.isupper() == false &&\n        \n        value.islower() == false)\n\
    \    {\n        return false;\n    }\n    \n    return true;\n}\nunittest\n{\n\
    \    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkyzyqsah.d(23): Error: no identifier for declarator value\n/tmp/tmpkyzyqsah.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpkyzyqsah.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmpkyzyqsah.d(23): Error: found \''dict\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkyzyqsah.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null || dict.isNull) return false;\n    foreach (key,\
    \ value) {\n        if (value instanceof string) {\n            if (value.toLowerCase()\
    \ !== value.toUpperCase()) return false;\n        } else if (value instanceof\
    \ long) {\n            if (value.toNumber() != value.toNumber()) return false;\n\
    \        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7bok2pwy.d(24): Error: no identifier for declarator value\n/tmp/tmp7bok2pwy.d(24):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp7bok2pwy.d(25): Error: found
    \''instanceof\'' when expecting \'')\''\n/tmp/tmp7bok2pwy.d(25): Error: found
    \'')\'' when expecting \'';\'' following statement\n/tmp/tmp7bok2pwy.d(26): Error:
    expression expected, not \''=\''\n/tmp/tmp7bok2pwy.d(26): Error: found \''value\''
    when expecting \'')\''\n/tmp/tmp7bok2pwy.d(26): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmp7bok2pwy.d(27): Error: found \''else\'' instead
    of statement\n/tmp/tmp7bok2pwy.d(30): Error: found \''}\'' when expecting \'')\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7bok2pwy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.length == 0) {\n        return false;\n    }\n    var\
    \ keyset = KeySet.create(dict);\n    foreach (var key in keyset) {\n        if\
    \ (keyset[key] == null) continue;\n        if (keyset[key].isUppercase) {\n  \
    \          return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n\
    \    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd463_l72.d(27): Error: found \''in\'' when expecting \'';\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd463_l72.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict == null)\n    {\n        return false;\n    }\n    for(string\
    \ key in dict)\n    {\n        if(key.caseInsensitive != \"true\")\n        {\n\
    \            return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk97g_ry1.d(27): Error: semicolon expected, not \''in\''\n/tmp/tmpk97g_ry1.d(27):
    Error: expression expected, not \''in\''\n/tmp/tmpk97g_ry1.d(27): Error: found
    \''dict\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpk97g_ry1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return dict.hasKeys()\n        && !std::all_of(dict.keys(), [](const\
    \ string &key){return !key.empty(); });\n}\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_zmwdgii.d(24): Error: found \'':\'' when expecting \'';\''
    following return statement\n/tmp/tmp_zmwdgii.d(24): Error: found \'':\'' instead
    of statement\n/tmp/tmp_zmwdgii.d(24): Error: Declaration expected, not \'')\''\n/tmp/tmp_zmwdgii.d(25):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_zmwdgii.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool allKeysAreLowercaseOrUppercase = true;\n    \n    for (auto\
    \ kv : dict) {\n        if (!is_string(vk)) {\n            allKeysAreLowercaseOrUppercase\
    \ = false;\n            break;\n        }\n    }\n    \n    return allKeysAreLowercaseOrUppercase;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_31ozdh0.d(25): Error: no identifier for declarator kv\n/tmp/tmp_31ozdh0.d(25):
    Error: expression expected, not \'':\''\n/tmp/tmp_31ozdh0.d(25): Error: found
    \''dict\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_31ozdh0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n        if (typeof(k) <> 'string' ||\
    \ (typeof(v) <> 'string' && v.isNull)) \n            return false;\n    return\
    \ true;\n}\n/*\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvzvzmkd4.d(23): Error: no identifier for declarator v\n/tmp/tmpvzvzmkd4.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpvzvzmkd4.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmpvzvzmkd4.d(23): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmpvzvzmkd4.d(24): Error: unterminated character constant\n/tmp/tmpvzvzmkd4.d(24):
    Error: found \''tring\'' when expecting \'')\''\n/tmp/tmpvzvzmkd4.d(24): Error:
    unterminated character constant\n/tmp/tmpvzvzmkd4.d(24): Error: unterminated character
    constant\n/tmp/tmpvzvzmkd4.d(24): Error: unterminated character constant\n/tmp/tmpvzvzmkd4.d(24):
    Error: found \''tring\'' when expecting \'')\''\n/tmp/tmpvzvzmkd4.d(24): Error:
    found \''32U\'' when expecting \'';\'' following statement\n/tmp/tmpvzvzmkd4.d(24):
    Error: found \''&&\'' instead of statement\n/tmp/tmpvzvzmkd4.d(28): Error: unterminated
    /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvzvzmkd4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict != null)\n    {\n        for (auto i : dict)\n     \
    \   {\n            if (std.typecons.isString(i.key) || std.typecons.isString(i.value.key))\n\
    \            {\n                continue;\n            }\n            else\n \
    \           {\n                return false;\n            }\n        }\n     \
    \   return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppp_rfl19.d(25): Error: no identifier for declarator i\n/tmp/tmppp_rfl19.d(25):
    Error: expression expected, not \'':\''\n/tmp/tmppp_rfl19.d(25): Error: found
    \''dict\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmppp_rfl19.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull)\n    {\n        return true;\n    }\n    \n\
    \    foreach(string k in dict)\n    {\n        if (!k.isLower)\n        {\n  \
    \          return false;\n        }\n    }\n    \n    foreach(string k in dict)\n\
    \    {\n        if (!k.isUpper)\n        {\n            return false;\n      \
    \  }\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkofexds3.d(28): Error: found \''in\'' when expecting \'';\''\n/tmp/tmpkofexds3.d(36):
    Error: found \''in\'' when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpkofexds3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict._dictionary) {\n        if (dict._dictionary.isEmpty)\n\
    \            return true;\n        var dict = dict._dictionary;\n        for (KeyValuePair!(string,string)\
    \ item in dict)\n            if (!item.key.isLowerCase && !item.key.isUpperCase\
    \ && !item.key.isDigit)\n                return false;\n        return true;\n\
    \    }\n    return false;\n}\n</code>\n<|/ a tags=swift,dictionary |>\n<| a dscore=1\
    \ |>\nHere is a solution that uses Swift's type inference and removes casting:\n\
    <code>\nimport Foundation\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpejq00xc9.d(27): Error: semicolon expected, not \''in\''\n/tmp/tmpejq00xc9.d(27):
    Error: expression expected, not \''in\''\n/tmp/tmpejq00xc9.d(27): Error: found
    \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmpejq00xc9.d(34):
    Error: Declaration expected, not \''<\''\n/tmp/tmpejq00xc9.d(37): Error: unterminated
    character constant\n/tmp/tmpejq00xc9.d(44): Error: Declaration expected, not \''assert\''\n/tmp/tmpejq00xc9.d(45):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpejq00xc9.d(46): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpejq00xc9.d(47): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpejq00xc9.d(48): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpejq00xc9.d(49): Error: Declaration expected, not \''assert\''\n/tmp/tmpejq00xc9.d(50):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpejq00xc9.d(51): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpejq00xc9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    // TODO: implement\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeavctgb7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(const auto &[k, v] : dict) \n        if(k.length() <= 1 ||\
    \ k.length() > 1 && k[0] == tolower(k[1]))\n            return false;\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpt5xcol2d.d(23): Error: basic type expected, not &\n/tmp/tmpt5xcol2d.d(23):
    Error: no identifier for declarator int\n/tmp/tmpt5xcol2d.d(23): Error: found
    \'':\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpt5xcol2d.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  if (dict == null) return false;\n  return all(k in dict | v in\
    \ dict | KeyValue(k, v) in dict);\n}\n\"\"\"\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_367sywy.d(24): Error: k in dict must be parenthesized when
    next to operator |\n/tmp/tmp_367sywy.d(24): Error: v in dict must be parenthesized
    when next to operator |\n/tmp/tmp_367sywy.d(24): Error: KeyValue(k, v) in dict
    must be parenthesized when next to operator |\n/tmp/tmp_367sywy.d(26): Error:
    Declaration expected, not \''""\''\n/tmp/tmp_367sywy.d(36): Error: unterminated
    string constant starting at /tmp/tmp_367sywy.d(36)\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp_367sywy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull)\n        return false\n    foreach (key in dict)\
    \ {\n        if (!(key is string) || !key.to_lowercase(Locale::en).startsWith(key.to_lowercase(Locale::en).toLowerCase(),\
    \ Locale::en))\n            return false\n    }\n    return true\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6om4t1k0.d(25): Error: found \''foreach\'' when expecting \'';\''
    following return statement\n/tmp/tmp6om4t1k0.d(25): Error: found \''in\'' when
    expecting \'')\''\n/tmp/tmp6om4t1k0.d(25): Error: missing { ... } for function
    literal\n/tmp/tmp6om4t1k0.d(25): Error: found \''dict\'' when expecting \'';\''
    following statement\n/tmp/tmp6om4t1k0.d(25): Error: found \'')\'' instead of statement\n/tmp/tmp6om4t1k0.d(29):
    Error: Declaration expected, not \''return\''\n/tmp/tmp6om4t1k0.d(35): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp6om4t1k0.d(36): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp6om4t1k0.d(37): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp6om4t1k0.d(38): Error: Declaration expected, not \''assert\''\n/tmp/tmp6om4t1k0.d(39):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp6om4t1k0.d(40): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp6om4t1k0.d(41): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp6om4t1k0.d(42): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6om4t1k0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int len = dict.len();\n    for(int i = 0; i < len; ++i) {\n \
    \       string key = dict[i].key();\n        if(!islower(key) && !isupper(key))\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a tags=d dscore=3 |>\n<| a |>\nThis can be done with pure D2:\n<code>\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp13km7348.d(32): Error: Declaration expected, not \''<\''\n/tmp/tmp13km7348.d(41):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp13km7348.d(42): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp13km7348.d(43): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp13km7348.d(44): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp13km7348.d(45): Error: Declaration expected, not \''assert\''\n/tmp/tmp13km7348.d(46):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp13km7348.d(47): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp13km7348.d(48): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp13km7348.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool isAllLower=true;\n    bool isAllUpper=true;\n    for (Nullable!(string[string]\
    \ key : dict)\n    {\n        if (key.tostring() !=  key.lowercase())\n      \
    \      isAllLower = false;\n        if (key.tostring() !=  key.uppercase())\n\
    \            isAllUpper = false;\n    }\n    return (isAllLower && isAllUpper);\n\
    }\n</code>\n<|/ a tags=functional-programming,dictionary,dart dscore=1 |>\n<|\
    \ a dscore=0 |>\nIn addition to the previous answers, here's a more generic approach,\
    \ using generic constraints:\n<code>\nimport 'package:collection/collection.dart';\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb2rzexqx.d(25): Error: found \''key\'' when expecting \'')\''
    following template argument list\n/tmp/tmpb2rzexqx.d(25): Error: found \'':\''
    when expecting \'';\'' following statement\n/tmp/tmpb2rzexqx.d(25): Error: found
    \'')\'' when expecting \'';\'' following for condition\n/tmp/tmpb2rzexqx.d(32):
    Error: found \''return\'' when expecting \'')\''\n/tmp/tmpb2rzexqx.d(34): Error:
    Declaration expected, not \''<\''\n/tmp/tmpb2rzexqx.d(37): Error: unterminated
    character constant\n/tmp/tmpb2rzexqx.d(39): Error: unterminated character constant\n/tmp/tmpb2rzexqx.d(39):
    Error: unterminated character constant\n/tmp/tmpb2rzexqx.d(44): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpb2rzexqx.d(45): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpb2rzexqx.d(46): Error: Declaration expected, not \''assert\''\n/tmp/tmpb2rzexqx.d(47):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpb2rzexqx.d(48): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpb2rzexqx.d(49): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpb2rzexqx.d(50): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpb2rzexqx.d(51): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb2rzexqx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    forall(dict, k => {\n        return typeof(k) == string && (k\
    \ == k.toLowerCase() || k == k.toUpperCase()); \n    });\n}\nunittest\n{\n   \
    \ alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4rl207nq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict.IsEmpty()) return true; // empty dict\n    if(!dict.IsValueSet())\
    \ return false; // non-nullable dict\n    foreach (key, value) in dict \n    {\n\
    \        if((value?.size() == 0L) && \n            !(tolower(key) == key || toupper(key)\
    \ == key)) return false;\n    }\n    return true;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=0 |>\nThe easiest way to do this is to define a function which\
    \ returns a bool indicating if a string is a valid name for a variable:\n<code>\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1twtb16o.d(25): Error: no identifier for declarator value\n/tmp/tmp1twtb16o.d(25):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp1twtb16o.d(25): Error: expression
    expected, not \''in\''\n/tmp/tmp1twtb16o.d(25): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmp1twtb16o.d(27): Error: found \'')\'' when expecting \'':\''\n/tmp/tmp1twtb16o.d(27):
    Error: expression expected, not \''&&\''\n/tmp/tmp1twtb16o.d(27): Error: found
    \''!\'' when expecting \'')\''\n/tmp/tmp1twtb16o.d(32): Error: Declaration expected,
    not \''<\''\n/tmp/tmp1twtb16o.d(41): Error: Declaration expected, not \''assert\''\n/tmp/tmp1twtb16o.d(42):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp1twtb16o.d(43): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp1twtb16o.d(44): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp1twtb16o.d(45): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp1twtb16o.d(46): Error: Declaration expected, not \''assert\''\n/tmp/tmp1twtb16o.d(47):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp1twtb16o.d(48): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1twtb16o.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(const auto &pair: dict)\n    {\n        const auto &key\
    \ = pair.key();\n        const auto &value = pair.value();\n        if(!is_string(key)\
    \ || !is_string(value))\n        {\n            return false;\n        }\n   \
    \ }\n    return true;\n}\n'''\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_ri2a8ah.d(23): Error: basic type expected, not auto\n/tmp/tmp_ri2a8ah.d(23):
    Error: no identifier for declarator int\n/tmp/tmp_ri2a8ah.d(23): Error: found
    \''auto\'' when expecting \'';\''\n/tmp/tmp_ri2a8ah.d(23): Error: found \'':\''
    when expecting \'')\''\n/tmp/tmp_ri2a8ah.d(23): Error: found \'')\'' when expecting
    \'';\'' following statement\n/tmp/tmp_ri2a8ah.d(25): Error: basic type expected,
    not &\n/tmp/tmp_ri2a8ah.d(25): Error: no identifier for declarator int\n/tmp/tmp_ri2a8ah.d(25):
    Error: found \''&\'' instead of statement\n/tmp/tmp_ri2a8ah.d(26): Error: basic
    type expected, not &\n/tmp/tmp_ri2a8ah.d(26): Error: no identifier for declarator
    int\n/tmp/tmp_ri2a8ah.d(26): Error: found \''&\'' instead of statement\n/tmp/tmp_ri2a8ah.d(34):
    Error: unterminated character constant\n/tmp/tmp_ri2a8ah.d(34): Error: Declaration
    expected, not \''16518672U\''\n/tmp/tmp_ri2a8ah.d(34): Error: unterminated character
    constant\n/tmp/tmp_ri2a8ah.d(39): Error: Declaration expected, not \''assert\''\n/tmp/tmp_ri2a8ah.d(40):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp_ri2a8ah.d(41): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp_ri2a8ah.d(42): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp_ri2a8ah.d(43): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp_ri2a8ah.d(44): Error: Declaration expected, not \''assert\''\n/tmp/tmp_ri2a8ah.d(45):
    Error: Declaration expected, not \''assert\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp_ri2a8ah.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.IsNull()) return true; \n    for (int i = 0; i < dict.NumItems();\
    \ i++)\n    {\n        if (dict[i].IsString() && dict[i].AsString().isLower())\
    \ return true;\n        if (dict[i].IsString() && dict[i].AsString().isUpper())\
    \ return true;\n    }\n    return false;\n}\n''';\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpay1pf1_e.d(31): Error: unterminated character constant\n/tmp/tmpay1pf1_e.d(31):
    Error: Declaration expected, not \''12430896U\''\n/tmp/tmpay1pf1_e.d(31): Error:
    unterminated character constant\n/tmp/tmpay1pf1_e.d(36): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpay1pf1_e.d(37): Error: Declaration expected, not \''assert\''\n/tmp/tmpay1pf1_e.d(38):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpay1pf1_e.d(39): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpay1pf1_e.d(40): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpay1pf1_e.d(41): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpay1pf1_e.d(42): Error: Declaration expected, not \''assert\''\n/tmp/tmpay1pf1_e.d(43):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpay1pf1_e.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.isEmpty() && all(k in dict as string for k in lower);\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi2mh0k16.d(23): Error: found \''as\'' when expecting \'',\''\n/tmp/tmpi2mh0k16.d(23):
    Error: found \''for\'' when expecting \'',\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpi2mh0k16.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.empty() && !any(dict.iterate(\n        [](string\
    \ key, string value) -> bool {\n            return std.isLowercase(value) || std.isUppercase(value);\n\
    \        }));\n}\n\"\"\"\n    pass\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5h7ievqq.d(24): Error: found \''key\'' when expecting \'',\''\n/tmp/tmp5h7ievqq.d(24):
    Error: expression expected, not \'',\''\n/tmp/tmp5h7ievqq.d(24): Error: found
    \''string\'' when expecting \'',\''\n/tmp/tmp5h7ievqq.d(24): Error: expression
    expected, not \''>\''\n/tmp/tmp5h7ievqq.d(24): Error: found \''bool\'' when expecting
    \'',\''\n/tmp/tmp5h7ievqq.d(28): Error: Declaration expected, not \''""\''\n/tmp/tmp5h7ievqq.d(39):
    Error: unterminated string constant starting at /tmp/tmp5h7ievqq.d(39)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5h7ievqq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null || dict.length == 0) return true;\n    for (auto\
    \ k : dict)\n        if (k.value.length != 0) return false;\n    return true;\n\
    }\n/* \n    Create a dictionary from the given associative array.\n    If the\
    \ given associative array is null, return null.\n    \n    Arguments: \n     \
    \   dict - Associative array (dictionary) to be created.\n    Returns:\n     \
    \   Nullable!(string[string]) dictionary if the given associative array is not\
    \ null, else null.\n    Example:\n        dict = create_dict([\"Name\": \"John\"\
    , \"Age\": \"36\", \"City\": \"Houston\"])\n*/\nNullable!(string[string]) create_dict(Nullable!(string[string])\
    \ dict)\n{\n    if (dict == null) \n        return Nullable!(string[string]) null;\n\
    \    \n    string[string] keys = dict.value;\n    string[string] vals = dict.key;\n\
    \    \n    Array!(string) keysa = Array!<string>(keys.length);\n    Array!(string)\
    \ valsa = Array!<string>(keys.length);\n    \n    for (auto key : keys) keysa[dict.value_index]\
    \ = key;\n    for (auto val : vals) valsa[dict.key_index] = val;\n    \n    return\
    \ Nullable!(string[string]) new Dictionary(keysa, valsa);\n}\n/* \n    Create\
    \ a dictionary from the given associative array.\n    If the given associative\
    \ array is null, return null.\n    \n    Arguments: \n        dict - Associative\
    \ array (dictionary) to be created.\n    Returns:\n        Nullable!(string[string])\
    \ dictionary if the given associative array is not null, else null.\n    Example:\n\
    \        dict = create_dict([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"\
    Houston\"])\n*/\nNullable!(string[string]) create_dict(Nullable!(string[string])\
    \ dict, string[string] key, string value)\n{\n    if (dict == null)\n        return\
    \ Nullable!(string[string]) null;\n    \n    string[string] keys = dict.value;\n\
    \    string[string] vals = dict.key;\n    \n    Array!(string) keysa = Array!<string>(keys.length);\n\
    \    Array!(string) valsa = Array!<string>(keys.length);\n    \n    for (auto\
    \ key : keys) keysa[dict.value_index] = key;\n    for (auto val : vals) valsa[dict.key_index]\
    \ = val;\n    \n    return Nullable!(string[string]) new Dictionary(keysa, valsa).put(key,\
    \ value);\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo0q8f4oq.d(24): Error: no identifier for declarator k\n/tmp/tmpo0q8f4oq.d(24):
    Error: expression expected, not \'':\''\n/tmp/tmpo0q8f4oq.d(24): Error: found
    \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmpo0q8f4oq.d(42):
    Error: found \''null\'' when expecting \'';\'' following return statement\n/tmp/tmpo0q8f4oq.d(47):
    Error: semicolon expected, not \''>\''\n/tmp/tmpo0q8f4oq.d(47): Error: found \''>\''
    instead of statement\n/tmp/tmpo0q8f4oq.d(48): Error: semicolon expected, not \''>\''\n/tmp/tmpo0q8f4oq.d(48):
    Error: found \''>\'' instead of statement\n/tmp/tmpo0q8f4oq.d(50): Error: no identifier
    for declarator key\n/tmp/tmpo0q8f4oq.d(50): Error: expression expected, not \'':\''\n/tmp/tmpo0q8f4oq.d(50):
    Error: found \''keys\'' when expecting \'';\'' following for condition\n/tmp/tmpo0q8f4oq.d(51):
    Error: no identifier for declarator val\n/tmp/tmpo0q8f4oq.d(51): Error: expression
    expected, not \'':\''\n/tmp/tmpo0q8f4oq.d(51): Error: found \''vals\'' when expecting
    \'';\'' following for condition\n/tmp/tmpo0q8f4oq.d(53): Error: found \''new\''
    when expecting \'';\'' following return statement\n/tmp/tmpo0q8f4oq.d(69): Error:
    found \''null\'' when expecting \'';\'' following return statement\n/tmp/tmpo0q8f4oq.d(74):
    Error: semicolon expected, not \''>\''\n/tmp/tmpo0q8f4oq.d(74): Error: found \''>\''
    instead of statement\n/tmp/tmpo0q8f4oq.d(75): Error: semicolon expected, not \''>\''\n/tmp/tmpo0q8f4oq.d(75):
    Error: found \''>\'' instead of statement\n/tmp/tmpo0q8f4oq.d(77): Error: no identifier
    for declarator key\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo0q8f4oq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int count = 0;\n    foreach(string key, dict){\n        if(!is_null(key)\
    \ && is_string(key))\n            count++;\n        else\n            return false;\n\
    \    }\n    return count == (dict.length()/2);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    That's really helpful! Thank you!\n<|/ c |>\n<| a tags=string,python dscore=3\
    \ |>\nTo make life a bit easier, you can define a nullable data type in Python\
    \ as follows:\n<code>\nclass Nullable:\n    def __init__(self, value):\n     \
    \   self.value = value\n    def value(self):\n        return self.value\n    def\
    \ is_null(self):\n        return not self.value\n</code>\nThe class above is just\
    \ a convenience wrapper around the primitive type, which allows you to define\
    \ methods on it:\n<code>\ndef nullable_string(str): return Nullable(str)\n</code>\n\
    And then you can use your nullable data type to enforce a constraint on your string:\n\
    <code>\ndef check_dict_case(dicts):\n    return all(Nullable(s).is_null for s\
    \ in dicts)\n</code>\n<|/ a |>\n<| c |>\nThis is how I would have done it as well.\
    \ An alternate approach is to use `isinstance(s, Nullable)` to detect nullable\
    \ types. That way, you won't need to define an additional wrapper class. Although\
    \ it is essentially the same thing. I would not recommend this approach over simply\
    \ defining a function that checks if something is a `null` string. Although in\
    \ most cases, using `isinstance` would work as well, this approach would work\
    \ even for types that don't define `__bool__` (like those returned from functions).\n\
    <|/ c |>\n<| a tags=string,python dscore=2 |>\nThe most elegant solution I found\
    \ is to use a Python decorator:\n<code>\ndef check_dict_case(nullable_string):\n\
    \    def check_func(func):\n        def func_wrapper(*args, **kwargs):\n     \
    \       return all(func(*arg, **kwarg) for arg in args) or all(nullable_string(s)\
    \ for s in kwargs)\n        return func_wrapper\n    return check_func\n</code>\n\
    Then you can use it like that:\n<code>\ndef check_dict_case(nullable_string):\n\
    \    def check_func(func):\n        def func_wrapper(*args, **kwargs):\n     \
    \       return all(func(*arg, **kwarg) for arg in args) or all(nullable_string(s)\
    \ for s in kwargs)\n        return func_wrapper\n    return check_func\n</code>\n\
    <|/ a |>\n<| c |>\nVery nice! But I would rename the function to `is_nullable`\
    \ :D\n<|/ c |>\n<| a tags=string,python |>\nHere's another solution that I find\
    \ more elegant:\n<code>\ndef is_nullable_string(s):\n    return isinstance(s,\
    \ str) and s\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc7luxn70.d(24): Error: no identifier for declarator dict\n/tmp/tmpc7luxn70.d(24):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpc7luxn70.d(30): Error: found
    \''return\'' when expecting \'')\''\n/tmp/tmpc7luxn70.d(32): Error: Declaration
    expected, not \''<\''\n/tmp/tmpc7luxn70.d(35): Error: unterminated character constant\n/tmp/tmpc7luxn70.d(59):
    Error: unterminated character constant\n/tmp/tmpc7luxn70.d(59): Error: unterminated
    character constant\n/tmp/tmpc7luxn70.d(85): Error: unterminated character constant\n/tmp/tmpc7luxn70.d(93):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpc7luxn70.d(94): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpc7luxn70.d(95): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpc7luxn70.d(96): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpc7luxn70.d(97): Error: Declaration expected, not \''assert\''\n/tmp/tmpc7luxn70.d(98):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpc7luxn70.d(99): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpc7luxn70.d(100): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc7luxn70.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    assert(!dict.isNull);\n    return !dict.isEmpty;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6kln0w23.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  \n}\n'''\n        validate_fn(check_dict_case)\n        \n    \
    \    validate_fn('''\nimport std.random;\nimport std.array;\nimport std.string;\n\
    import std.typecons;\nimport std.math;\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp24nzsugb.d(25): Error: unterminated character constant\n/tmp/tmp24nzsugb.d(25):
    Error: Declaration expected, not \''0U\''\n/tmp/tmp24nzsugb.d(25): Error: unterminated
    character constant\n/tmp/tmp24nzsugb.d(28): Error: unterminated character constant\n/tmp/tmp24nzsugb.d(28):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp24nzsugb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(string key in dict)\n    {\n        char lowerChar =\
    \ key.lower();\n        char upperChar = key.upper();\n        if (lowerChar ==\
    \ upperChar)\n            continue;\n        return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfqmk34fh.d(23): Error: found \''in\'' when expecting \'';\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfqmk34fh.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  if(!dict.IsNull) return true; \n  \n  for(auto iter = dict.begin();\
    \ iter != dict.end(); iter++) {\n    if(!iter->IsNull) \n    {\n      if (iter->isUpper)\
    \ return true;\n      else \n      {\n\tfor(auto iter2 = iter->begin(); iter2\
    \ != iter->end(); iter2++) {\n\t  if(!iter2->IsNull) return false; \n\t}\n\treturn\
    \ true;\n      }\n    }\n  }\n  return false;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp06p3gwst.d(26): Error: expression expected, not \''>\''\n/tmp/tmp06p3gwst.d(26):
    Error: found \''IsNull\'' when expecting \'')\''\n/tmp/tmp06p3gwst.d(26): Error:
    found \'')\'' instead of statement\n/tmp/tmp06p3gwst.d(31): Error: expression
    expected, not \''>\''\n/tmp/tmp06p3gwst.d(31): Error: semicolon expected following
    auto declaration, not \''begin\''\n/tmp/tmp06p3gwst.d(31): Error: expression expected,
    not \''>\''\n/tmp/tmp06p3gwst.d(31): Error: found \''end\'' when expecting \'')\''\n/tmp/tmp06p3gwst.d(31):
    Error: expression expected, not \'')\''\n/tmp/tmp06p3gwst.d(31): Error: found
    \'';\'' when expecting \'')\''\n/tmp/tmp06p3gwst.d(31): Error: found \''iter2\''
    when expecting \'';\'' following statement\n/tmp/tmp06p3gwst.d(31): Error: expression
    expected, not \'')\''\n/tmp/tmp06p3gwst.d(31): Error: found \''{\'' when expecting
    \'';\'' following statement\n/tmp/tmp06p3gwst.d(32): Error: expression expected,
    not \''>\''\n/tmp/tmp06p3gwst.d(32): Error: found \''IsNull\'' when expecting
    \'')\''\n/tmp/tmp06p3gwst.d(32): Error: found \'')\'' instead of statement\n/tmp/tmp06p3gwst.d(37):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp06p3gwst.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(d:dict | {\n        foreach(k:string in d | {\n     \
    \       if(k.length>1) return false;\n        })\n    })\n    return true;\n}\n\
    </code>\n<|/ a |>\n<| a |>\nHere's a solution without using the std.typecons module.\n\
    <code>\nuse std::collections::HashMap;\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6ea2d9oy.d(23): Error: no identifier for declarator d\n/tmp/tmp6ea2d9oy.d(23):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp6ea2d9oy.d(24): Error: no
    identifier for declarator k\n/tmp/tmp6ea2d9oy.d(24): Error: found \'':\'' when
    expecting \'';\''\n/tmp/tmp6ea2d9oy.d(24): Error: string in d must be parenthesized
    when next to operator |\n/tmp/tmp6ea2d9oy.d(27): Error: found \''}\'' instead
    of statement\n/tmp/tmp6ea2d9oy.d(30): Error: Declaration expected, not \''<\''\n/tmp/tmp6ea2d9oy.d(33):
    Error: unterminated character constant\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp6ea2d9oy.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  if(dict.isNull) return true;\n  foreach(k, v:dict)\n    if (v.isNull)\
    \ return false;\n    else if (!string(v).toLowerCase()) return false; \n    else\
    \ if (!string(v).toUpperCase()) return false;\n  return true;\n}\n'''\n)\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp0p3edeo.d(24): Error: no identifier for declarator v\n/tmp/tmpp0p3edeo.d(24):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmpp0p3edeo.d(30): Error: unterminated
    character constant\n/tmp/tmpp0p3edeo.d(30): Error: Declaration expected, not \''24612368U\''\n/tmp/tmpp0p3edeo.d(30):
    Error: unterminated character constant\n/tmp/tmpp0p3edeo.d(36): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpp0p3edeo.d(37): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpp0p3edeo.d(38): Error: Declaration expected, not \''assert\''\n/tmp/tmpp0p3edeo.d(39):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpp0p3edeo.d(40): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpp0p3edeo.d(41): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpp0p3edeo.d(42): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpp0p3edeo.d(43): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp0p3edeo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for (auto kv : dict)\n    {\n        if (to!string(kv.key) !=\
    \ to!string(kv.key))\n            return false;\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyqxhmcx_.d(23): Error: no identifier for declarator kv\n/tmp/tmpyqxhmcx_.d(23):
    Error: expression expected, not \'':\''\n/tmp/tmpyqxhmcx_.d(23): Error: found
    \''dict\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpyqxhmcx_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    forall(dict, \n    [](string key, string value) -> bool { return\
    \ check_type!(key, String) || check_type!(value, String); });\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcf8xn1f9.d(24): Error: found \''key\'' when expecting \'',\''\n/tmp/tmpcf8xn1f9.d(24):
    Error: expression expected, not \'',\''\n/tmp/tmpcf8xn1f9.d(24): Error: found
    \''string\'' when expecting \'',\''\n/tmp/tmpcf8xn1f9.d(24): Error: expression
    expected, not \''>\''\n/tmp/tmpcf8xn1f9.d(24): Error: found \''bool\'' when expecting
    \'',\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcf8xn1f9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.hasKey(\"Name\"))\n        return dict.hasKey(\"AGE\"\
    );\n    \n    foreach (key in dict.keys()) \n    {\n        string upper = key.to_uppercase();\n\
    \        bool isString = false;\n        \n        if (!dict.hasKey(upper)) \n\
    \            continue;\n        \n        string lower = key.to_lowercase();\n\
    \        \n        if (isNullable(dict[lower]))\n        {\n            isString\
    \ = true;\n        }\n        else\n        {\n            isString = dict[lower].isString;\n\
    \        }\n        \n        if (!isString)\n        {\n            return false;\n\
    \        }\n    }\n    \n    return true;\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=d,associative-array,null,string |>\nThis solution uses std.algorithm.partition,\
    \ std.algorithm.search, std.algorithm.forEach and std.algorithm.find:\n<code>\n\
    import std.algorithm : partition, search, forEach, find;\nimport std.stdio, std.stdio,\
    \ std.typecons : isNullable;\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1h64yld3.d(26): Error: no identifier for declarator key\n/tmp/tmp1h64yld3.d(26):
    Error: found \''in\'' when expecting \'';\''\n/tmp/tmp1h64yld3.d(53): Error: Declaration
    expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1h64yld3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto result = false;\n    auto it = dict.dict.begin();\n    auto\
    \ end = dict.dict.end();\n    while (it != end) {\n        auto key = (it->first);\n\
    \        bool isLower = false;\n        bool isUpper = false;\n        if (auto\
    \ key = key_of!(Nullable!(string[string]), key).first) {\n            if (auto\
    \ str = key.as<string[]>()) {\n                isLower = str[0] == str[0].to<string>();\n\
    \            } else if (auto str = key.as<String>()) {\n                isLower\
    \ = str.to<string>().to<bool>();\n            }\n        }\n        if (auto key\
    \ = key_of!(Nullable!(string[string]), key).second) {\n            if (auto str\
    \ = key.as<string[]>()) {\n                isUpper = str[1] == str[1].to<string>();\n\
    \            } else if (auto str = key.as<String>()) {\n                isUpper\
    \ = str.to<string>().to<bool>();\n            }\n        }\n        if (isLower\
    \ && isUpper) {\n            result = true;\n            break;\n        }\n \
    \       ++it;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpegxvwhqh.d(27): Error: expression expected, not \''>\''\n/tmp/tmpegxvwhqh.d(27):
    Error: found \''first\'' when expecting \'')\''\n/tmp/tmpegxvwhqh.d(27): Error:
    semicolon expected following auto declaration, not \'')\''\n/tmp/tmpegxvwhqh.d(27):
    Error: found \'')\'' instead of statement\n/tmp/tmpegxvwhqh.d(31): Error: found
    \''>\'' when expecting \'')\''\n/tmp/tmpegxvwhqh.d(31): Error: expression expected,
    not \'')\''\n/tmp/tmpegxvwhqh.d(31): Error: found \''{\'' when expecting \'';\''
    following statement\n/tmp/tmpegxvwhqh.d(32): Error: found \''<\'' when expecting
    \'';\'' following statement\n/tmp/tmpegxvwhqh.d(32): Error: expression expected,
    not \'')\''\n/tmp/tmpegxvwhqh.d(32): Error: found \'';\'' when expecting \'')\''\n/tmp/tmpegxvwhqh.d(33):
    Error: found \''}\'' when expecting \'';\'' following statement\n/tmp/tmpegxvwhqh.d(33):
    Error: found \''else\'' instead of statement\n/tmp/tmpegxvwhqh.d(38): Error: found
    \''>\'' when expecting \'')\''\n/tmp/tmpegxvwhqh.d(38): Error: expression expected,
    not \'')\''\n/tmp/tmpegxvwhqh.d(38): Error: found \''{\'' when expecting \'';\''
    following statement\n/tmp/tmpegxvwhqh.d(39): Error: found \''<\'' when expecting
    \'';\'' following statement\n/tmp/tmpegxvwhqh.d(39): Error: expression expected,
    not \'')\''\n/tmp/tmpegxvwhqh.d(39): Error: found \'';\'' when expecting \'')\''\n/tmp/tmpegxvwhqh.d(40):
    Error: found \''}\'' when expecting \'';\'' following statement\n/tmp/tmpegxvwhqh.d(40):
    Error: found \''else\'' instead of statement\n/tmp/tmpegxvwhqh.d(44): Error: Declaration
    expected, not \''if\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpegxvwhqh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int len = dict.length;\n    int i = 0;\n    while (i < len)\n\
    \    {\n        string key = dict[i].key.toLower();\n        if (key.length()\
    \ == 0)\n            return false;\n        else\n        {\n            string\
    \ lower = key[0];\n            string upper = key[0];\n            for (i = 1;\
    \ i < key.length; ++i)\n            {\n                lower = key.charAt(0).toLower()\
    \ + lower;\n                upper = key.charAt(0).toUpper() + upper;\n       \
    \     }\n            if (lower != upper)\n                return false;\n    \
    \        else\n                ++i;\n        }\n        ++i;\n    }\n    return\
    \ true;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=stl,stl,c++,dictionary |>\n\
    For what it's worth, I implemented a generic version of the function check_dict_case()\
    \ suggested by Thiago Aquino. I also added an assert statement to catch invalid\
    \ input.\n<code>\n// Test whether each key of dict is in lower or upper case.\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcna0gvpg.d(48): Error: Declaration expected, not \''<\''\n/tmp/tmpcna0gvpg.d(51):
    Error: unterminated character constant\n/tmp/tmpcna0gvpg.d(58): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpcna0gvpg.d(59): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpcna0gvpg.d(60): Error: Declaration expected, not \''assert\''\n/tmp/tmpcna0gvpg.d(61):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpcna0gvpg.d(62): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpcna0gvpg.d(63): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpcna0gvpg.d(64): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpcna0gvpg.d(65): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcna0gvpg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(i in dict, e in i.keys) {\n        if (e is string) \n\
    \            return true;\n        if (e is string) \n            return false;\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1pai_cau.d(23): Error: no identifier for declarator i\n/tmp/tmp1pai_cau.d(23):
    Error: found \''in\'' when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp1pai_cau.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(string key, dict | \n        {\n            bool isUpper\
    \ = char.isUpper(key);\n            bool isLower = char.isLower(key);\n      \
    \      if(isUpper != isLower)\n                return false;\n        });\n  \
    \  return true;\n}\n\"\"\"\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpd2sjptcu.d(23): Error: no identifier for declarator dict\n/tmp/tmpd2sjptcu.d(23):
    Error: found \''|\'' when expecting \'';\''\n/tmp/tmpd2sjptcu.d(29): Error: use
    \''{ }\'' for an empty statement, not a \'';\''\n/tmp/tmpd2sjptcu.d(32): Error:
    Declaration expected, not \''""\''\n/tmp/tmpd2sjptcu.d(42): Error: unterminated
    string constant starting at /tmp/tmpd2sjptcu.d(42)\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpd2sjptcu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tauto result = true;\n\tif(!dict.empty()) {\n\t\tstring k;\n\t\t\
    for(auto i : dict)\n\t\t\tk = i.key();\n\t\tif(k.size() == 1) {\n\t\t\tif(islower(k.front()))\
    \ {\n\t\t\t\tif(dict.find(k.front().toupper()) == dict.end())\n\t\t\t\t\tresult\
    \ = false;\n\t\t\t}\n\t\t\telse\n\t\t\t\tif(dict.find(k.front().tolower()) ==\
    \ dict.end())\n\t\t\t\t\tresult = false;\n\t\t}\n\t\telse\n\t\t\tfor(auto i :\
    \ dict)\n\t\t\t\tif(!check_dict_case(i.value()))\n\t\t\t\t\tresult = false;\n\t\
    }\n\treturn result;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmphq3tx8bj.d(26): Error: no identifier for declarator i\n/tmp/tmphq3tx8bj.d(26):
    Error: expression expected, not \'':\''\n/tmp/tmphq3tx8bj.d(26): Error: found
    \''dict\'' when expecting \'';\'' following for condition\n/tmp/tmphq3tx8bj.d(38):
    Error: no identifier for declarator i\n/tmp/tmphq3tx8bj.d(38): Error: expression
    expected, not \'':\''\n/tmp/tmphq3tx8bj.d(38): Error: found \''dict\'' when expecting
    \'';\'' following for condition\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphq3tx8bj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return dict == null ? false : \n        dict.values.all(x =>\
    \ x.is_str() || x.is_ustr()) ? true : \n        dict.values.all(x => x.is_int()\
    \ && x.is_uint()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_float()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_bool()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_char()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_float()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_double()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_char16()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_char32()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_bool()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_string()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_map()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_tuple()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_list())? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_set()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_map()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_tuple()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_list())? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_set()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_map()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_tuple()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_list())? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_set()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_map()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_tuple()) ? true : \n        dict.values.all(x => x.is_int\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp78cik9_p.d(50): Error: found \''unittest\'' when expecting \'',\''\n/tmp/tmp78cik9_p.d(62):
    Error: found \''void\'' when expecting \'',\''\n/tmp/tmp78cik9_p.d(62): Error:
    found \''{\'' when expecting \'',\''\n/tmp/tmp78cik9_p.d(62): Error: expression
    expected, not \''}\''\n/tmp/tmp78cik9_p.d(62): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmp78cik9_p.d(62): Error: found \''EOF\'' when expecting \'')\''\n/tmp/tmp78cik9_p.d(62):
    Error: found \''EOF\'' when expecting \'';\'' following return statement\n/tmp/tmp78cik9_p.d(62):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp78cik9_p.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is Nullable)\n        return check_dict_case(dict.nullable);\n\
    \    return dict == null || dict == undefined || dict.isEmpty || dict.size ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp30bu0izn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto it = dict.keys;\n    bool result = true;\n    auto next_key\
    \ = it.next();\n    while (next_key.is_some) {\n        auto key = next_key.value;\n\
    \        auto lower_key = std.string::to_lowercase(key);\n        auto upper_key\
    \ = std.string::to_uppercase(key);\n        if (!it.next().is_some) {\n      \
    \      result = !result;\n        } else if (it.next().is_some) {\n          \
    \  result = !result;\n        } else if (key == lower_key) {\n            result\
    \ = !result;\n        } else if (key == upper_key) {\n            result = !result;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpho4yjput.d(28): Error: semicolon expected following auto declaration,
    not \'':\''\n/tmp/tmpho4yjput.d(28): Error: found \'':\'' instead of statement\n/tmp/tmpho4yjput.d(29):
    Error: semicolon expected following auto declaration, not \'':\''\n/tmp/tmpho4yjput.d(29):
    Error: found \'':\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpho4yjput.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (kv in dict) {\n        if (kv.isNull) return false;\n\
    \        if (!isLowercase(kv.key)) {\n            if (isUppercase(kv.key)) {\n\
    \                return false;\n            }\n            else {\n          \
    \      return true;\n            }\n        }\n        if (!isUppercase(kv.key))\
    \ {\n            return true;\n        }\n    }\n    \n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpotveg733.d(23): Error: no identifier for declarator kv\n/tmp/tmpotveg733.d(23):
    Error: found \''in\'' when expecting \'';\''\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpotveg733.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(auto& kv : dict) {\n        // TODO: add more checks\n  \
    \      return islower(kv.key) || isupper(kv.key);\n    }\n    return false;\n\
    }\n</code>\nThis can then be used as follows:\n<code>\nimport std.typecons;\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpoyyuqjcc.d(23): Error: basic type expected, not &\n/tmp/tmpoyyuqjcc.d(23):
    Error: no identifier for declarator int\n/tmp/tmpoyyuqjcc.d(23): Error: found
    \'':\'' when expecting \'';\'' following for condition\n/tmp/tmpoyyuqjcc.d(29):
    Error: Declaration expected, not \''<\''\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpoyyuqjcc.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.isNull;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq0seq92w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(!is_dict(dict))\n        throw new ArgumentTypeError(\"Passed\
    \ argument is not a dictionary.\");\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_vgkka1_.d(25): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_vgkka1_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\treturn dict.isDefined;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph5k7932z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return isNull(dict);\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnjqcr2ee.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, value) in dict \n    {\n        if (!is_string(key)\
    \ || !is_string(value)) return false;\n    }\n    return true;\n}\n'''\n    \n\
    def check_input_dict_case(\n        dict_or_array: Union['Dict', 'Dict[]'], \n\
    \        case: Case = Case.DONT_CARE) -> 'Input':\n    '''\n    Checks that keys\
    \ or values in the given dictionary or array are strings in lower\n    case or\
    \ strings in upper case.\n    \n    The function may fail to detect invalid inputs\
    \ in the following cases:\n    \n    * Empty dictionaries\n    * Empty arrays\n\
    \    * Strings that are not valid Python identifiers (starting with underscore)\n\
    \    * Strings that are not valid Python identifiers or numbers\n    * Strings\
    \ that are not valid Python identifiers\n    \n    Examples:\n    >>> check_input_dict_case({})\n\
    \    {}\n    >>> check_input_dict_case([])\n    []\n    >>> check_input_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"])\n    {'a': 'apple', 'b': 'banana'}\n    >>>\
    \ check_input_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"\
    ])\n    {'A': 'banana', 'B': 'banana'}\n    >>> check_input_dict_case([\"a\":\
    \ \"apple\", 8L: \"banana\", \"a\": \"apple\"])\n    {'a': 8L, 'a': 'apple'}\n\
    \    >>> check_input_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"])\n    {'Name': 'John', 'Age': '36', 'City': 'Houston'}\n    \n\
    \    '''\n    if isinstance(dict_or_array, Dict):\n        dict_or_array = [dict_or_array]\n\
    \    \n    checker = CheckerContext()\n    checker.check_inputs(\n        dict_or_array,\
    \ \n        lambda i, v: check_input_dict_case(v, case), \n        lambda i, v:\
    \ check_input_dict_case(i, v, case))\n    \n    return checker.unchecked_inputs()\n\
    </cell>\n<code language=xeus-cling-cpp14>\ncheck_input_dict_case(check_input_dict_case({}))\n\
    </cell>\n<code language=xeus-cling-cpp14>\ncheck_input_dict_case(check_input_dict_case([]))\n\
    </cell>\n<code language=xeus-cling-cpp14>\ncheck_input_dict_case(check_input_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"]))\n</cell>\n<code language=xeus-cling-cpp14>\n\
    check_input_dict_case(check_input_dict_case([\"a\": \"apple\", \"A\": \"banana\"\
    , \"B\": \"banana\"]))\n</cell>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0u80nxcm.d(23): Error: no identifier for declarator value\n/tmp/tmp0u80nxcm.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp0u80nxcm.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmp0u80nxcm.d(23): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmp0u80nxcm.d(29): Error: unterminated character constant\n/tmp/tmp0u80nxcm.d(29):
    Error: Declaration expected, not \''10432016U\''\n/tmp/tmp0u80nxcm.d(29): Error:
    unterminated character constant\n/tmp/tmp0u80nxcm.d(32): Error: unterminated character
    constant\n/tmp/tmp0u80nxcm.d(32): Error: unterminated character constant\n/tmp/tmp0u80nxcm.d(32):
    Error: unterminated character constant\n/tmp/tmp0u80nxcm.d(32): Error: unterminated
    character constant\n/tmp/tmp0u80nxcm.d(33): Error: unterminated character constant\n/tmp/tmp0u80nxcm.d(33):
    Error: unterminated character constant\n/tmp/tmp0u80nxcm.d(34): Error: unterminated
    character constant\n/tmp/tmp0u80nxcm.d(34): Error: unterminated character constant\n/tmp/tmp0u80nxcm.d(52):
    Error: unterminated character constant\n/tmp/tmp0u80nxcm.d(52): Error: unterminated
    character constant\n/tmp/tmp0u80nxcm.d(52): Error: unterminated character constant\n/tmp/tmp0u80nxcm.d(52):
    Error: unterminated character constant\n/tmp/tmp0u80nxcm.d(54): Error: unterminated
    character constant\n/tmp/tmp0u80nxcm.d(54): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0u80nxcm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    forall (x in dict) \n    {\n        bool result = isinstance(x.key(),\
    \ std.typecons.char);\n        result &= isinstance(x.key(), std.typecons.char);\n\
    \        return result;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmjvd3i1g.d(24): Error: found \''{\'' when expecting \'';\''
    following statement\n/tmp/tmpmjvd3i1g.d(25): Error: identifier expected following
    \''.\'', not \''char\''\n/tmp/tmpmjvd3i1g.d(26): Error: identifier expected following
    \''.\'', not \''char\''\n/tmp/tmpmjvd3i1g.d(29): Error: Declaration expected,
    not \''return\''\n/tmp/tmpmjvd3i1g.d(30): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmjvd3i1g.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isEmpty)\n        return false;\n    // first check\
    \ key case sensitivity\n    if (dict.isDefinedAt(dict._keys.map(x => x.caseInsensitive())))\n\
    \        return true;\n    // second check value case sensitivity\n    if (dict.isDefinedAt(dict._keys.map(x\
    \ => x.caseInsensitive()).map(x => x.lowercase())))\n        return true;\n  \
    \  return false;\n}\n\"\"\")\n</cell>\n<text>\nTuples\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqv3g_ltm.d(33): Error: Declaration expected, not \''""\''\n/tmp/tmpqv3g_ltm.d(46):
    Error: unterminated string constant starting at /tmp/tmpqv3g_ltm.d(46)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqv3g_ltm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, value) in dict \n    {\n        if (!(is_string(value)\
    \ || is_string(value.toLower())))\n            return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmf_s1mgf.d(23): Error: no identifier for declarator value\n/tmp/tmpmf_s1mgf.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpmf_s1mgf.d(23): Error: expression
    expected, not \''in\''\n/tmp/tmpmf_s1mgf.d(23): Error: found \''dict\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmf_s1mgf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  if (dict == null)\n    return false;\n  \n  var keys = dict.get_keys();\n\
    \  for (var i = 0; i < keys.length; ++i)\n  {\n    var value = dict.get_value(keys[i]);\n\
    \    if (!value.is_string())\n      return false;\n  }\n  \n  return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp909xhpe9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return is_tuple(dict) && contains_all(dict.values, |e| e is Nullable!(string[string]));\n\
    }\n/*\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpj3eg3jov.d(23): Error: expression expected, not \''|\''\n/tmp/tmpj3eg3jov.d(23):
    Error: found \''e\'' when expecting \'',\''\n/tmp/tmpj3eg3jov.d(23): Error: expression
    expected, not \''|\''\n/tmp/tmpj3eg3jov.d(23): Error: found \''e\'' when expecting
    \'',\''\n/tmp/tmpj3eg3jov.d(23): Error: (type identifier : specialization) expected
    following is\n/tmp/tmpj3eg3jov.d(23): Error: found \''!\'' when expecting \'',\''\n/tmp/tmpj3eg3jov.d(25):
    Error: unterminated /* */ comment\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj3eg3jov.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = true;\n    foreach(pair!string key, pair!string\
    \ val in dict)\n    {\n        result &= key == val; \n        result &= !key.compareToIgnoreCase(val);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppidyfpfn.d(24): Error: found \''in\'' when expecting \'';\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppidyfpfn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) dict\n    {\n        if(typeof(v) != null) // null\
    \ check\n        {\n            if(!string_islower(k) || !string_isupper(k))\n\
    \                return false;\n        }\n        else\n        {\n         \
    \   if(!string_islower(k) || !string_isupper(k))\n                return false;\n\
    \        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpga70ko1o.d(23): Error: no identifier for declarator v\n/tmp/tmpga70ko1o.d(23):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmpga70ko1o.d(24): Error: found
    \''{\'' when expecting \'')\''\n/tmp/tmpga70ko1o.d(36): Error: Declaration expected,
    not \''return\''\n/tmp/tmpga70ko1o.d(37): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpga70ko1o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !is_null(dict) && is_associative(dict) && \n         \
    \  all((k, v) => (is_str(k) && is_str(v)) || \n                       (is_str(k)\
    \ && !is_str(v)));\n}\n/*\n    Determine if all keys are strings in lower case\
    \ or all keys are strings\n    in upper case, else return false.\n    The function\
    \ should return false if the keys are not all strings or the \n    value is not\
    \ null.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"\
    ].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\"\
    , \"8L\": \"banana\", \"a\": \"apple\"].nullable)\n    true\n    >>> check_dict_case([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n\
    \    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n \
    \   false\n*/\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprlgi16z8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(var key in dict) \n    {\n        if(key != null && key.length\
    \ != 0) \n        {\n            var lower = key.toLowerCase();\n            var\
    \ upper = key.toUpperCase();\n            if(!(lower in dict || upper in dict))\
    \ return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4v4hoclo.d(23): Error: semicolon expected, not \''in\''\n/tmp/tmp4v4hoclo.d(23):
    Error: expression expected, not \''in\''\n/tmp/tmp4v4hoclo.d(23): Error: found
    \''dict\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp4v4hoclo.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int num_keys = 0;\n    foreach (key, value) in dict \n    {\n\
    \        if (is_str(key) || is_str(value))\n        {\n            ++num_keys;\n\
    \        }\n    }\n    return num_keys == dict.len();\n}\n</code>\n<|/ a dscore=1\
    \ tags=dictionary,nullable,python |>\n<| a dscore=1 |>\nI needed the same thing\
    \ in my project and came up with this. Here is a version which works better with\
    \ nullable dictionary:\n<code>\ndef dict_keys_to_lowercase(dict_: dict, key_is_upper:\
    \ bool) -> dict:\n    \"\"\"Convert dictionary keys from all uppercase to lowercase\"\
    \"\"\n    # check input\n    if not isinstance(dict_, dict):\n        raise TypeError(\"\
    Argument must be dictionary\")\n    if not isinstance(key_is_upper, bool):\n \
    \       raise TypeError(\"Argument must be bool type for key conversion\")\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0boiszly.d(24): Error: no identifier for declarator value\n/tmp/tmp0boiszly.d(24):
    Error: found \'')\'' when expecting \'';\''\n/tmp/tmp0boiszly.d(24): Error: expression
    expected, not \''in\''\n/tmp/tmp0boiszly.d(24): Error: found \''dict\'' when expecting
    \'')\''\n/tmp/tmp0boiszly.d(33): Error: Declaration expected, not \''<\''\n/tmp/tmp0boiszly.d(49):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp0boiszly.d(50): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp0boiszly.d(51): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp0boiszly.d(52): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp0boiszly.d(53): Error: Declaration expected, not \''assert\''\n/tmp/tmp0boiszly.d(54):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp0boiszly.d(55): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp0boiszly.d(56): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0boiszly.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(key in dict) {\n        assert((string) key.length == 0 ||\
    \ key.length == 1);\n        assert((string) key[0] in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    );\n    }\n    \n    return true;\n}\n'''\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvopr9knu.d(23): Error: found \'')\'' when expecting \'';\''
    following statement\n/tmp/tmpvopr9knu.d(24): Error: C style cast illegal, use
    cast(string)key.length\n/tmp/tmpvopr9knu.d(25): Error: C style cast illegal, use
    cast(string)key[0]\n/tmp/tmpvopr9knu.d(28): Error: found \''return\'' when expecting
    \'';\'' following for condition\n/tmp/tmpvopr9knu.d(28): Error: found \'';\''
    when expecting \'')\''\n/tmp/tmpvopr9knu.d(29): Error: found \''}\'' instead of
    statement\n/tmp/tmpvopr9knu.d(30): Error: unterminated character constant\n/tmp/tmpvopr9knu.d(30):
    Error: Declaration expected, not \''25288208U\''\n/tmp/tmpvopr9knu.d(30): Error:
    unterminated character constant\n/tmp/tmpvopr9knu.d(35): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpvopr9knu.d(36): Error: Declaration expected, not \''assert\''\n/tmp/tmpvopr9knu.d(37):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpvopr9knu.d(38): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpvopr9knu.d(39): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpvopr9knu.d(40): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpvopr9knu.d(41): Error: Declaration expected, not \''assert\''\n/tmp/tmpvopr9knu.d(42):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvopr9knu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v: dict[string])\n    {\n        string lower = lowerCase(to!string(v));\n\
    \        string upper = upperCase(to!string(v));\n        if (upper != lower)\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    \"\"\"\n)\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp15_1287l.d(23): Error: no identifier for declarator v\n/tmp/tmp15_1287l.d(23):
    Error: found \'':\'' when expecting \'';\''\n/tmp/tmp15_1287l.d(34): Error: Declaration
    expected, not \''""\''\n/tmp/tmp15_1287l.d(45): Error: unterminated string constant
    starting at /tmp/tmp15_1287l.d(45)\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp15_1287l.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.hasKey(\"a\")) return dict.get(\"a\").isLowercase();\n\
    \    if (dict.hasKey(\"A\")) return dict.get(\"A\").isUppercase();\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwl0el3qv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    \n    for(var key in dict)\n    {\n        if(isNull(key))\n\
    \        {\n            return false;\n        }\n        if(key!=\"Name\" &&\
    \ key!=\"Age\" && key!=\"City\")\n        {\n            return false;\n     \
    \   }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo66yl949.d(24): Error: semicolon expected, not \''in\''\n/tmp/tmpo66yl949.d(24):
    Error: expression expected, not \''in\''\n/tmp/tmpo66yl949.d(24): Error: found
    \''dict\'' when expecting \'';\'' following for condition\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpo66yl949.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015380
