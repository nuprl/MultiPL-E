language: d
name: HumanEval_95_check_dict_case
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key key, value dict) \n    {\n        bool is_string\
    \ = (value ?? \"\").length == 0;\n        if (!is_string)\n        {\n       \
    \     auto lower_string = value.toCString();\n            auto upper_string =\
    \ lower_string.upcase();\n            if (key != upper_string)\n            {\n\
    \                return false;\n            }\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoq3lyas4.d(23): Error: found `)` when expecting `;`

    /tmp/tmpoq3lyas4.d(25): Error: expression expected, not `?`

    /tmp/tmpoq3lyas4.d(25): Error: found `""` when expecting `:`

    /tmp/tmpoq3lyas4.d(25): Error: expression expected, not `)`

    /tmp/tmpoq3lyas4.d(25): Error: found `;` when expecting `)`

    /tmp/tmpoq3lyas4.d(26): Error: semicolon expected, not `if`

    /tmp/tmpoq3lyas4.d(36): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoq3lyas4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    var n = 0;\n    var first = true;\n    for (var v in dict)\n\
    \    {\n        if (v is int)\n        {\n            if (first)\n           \
    \ {\n                first = false;\n                continue;\n            }\n\
    \            n++;\n        }\n        else if (v is string)\n        {\n     \
    \       if (first)\n            {\n                first = false;\n          \
    \      continue;\n            }\n            n++;\n        }\n        else\n \
    \       {\n            return false;\n        }\n    }\n    if (n == 0)\n    {\n\
    \        return true;\n    }\n    else\n    {\n        return false;\n    }\n\
    }\n\"\"\"\n</cell>\n<text>\nis_valid_int\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp80hokvzj.d(25): Error: semicolon expected, not `in`

    /tmp/tmp80hokvzj.d(25): Error: expression expected, not `in`

    /tmp/tmp80hokvzj.d(25): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmp80hokvzj.d(27): Error: found `)` when expecting `.` following int

    /tmp/tmp80hokvzj.d(28): Error: found `{` when expecting identifier following `int`.

    /tmp/tmp80hokvzj.d(29): Error: found `if` when expecting `)`

    /tmp/tmp80hokvzj.d(34): Error: found `n` when expecting `;` following statement

    /tmp/tmp80hokvzj.d(34): Error: expression expected, not `;`

    /tmp/tmp80hokvzj.d(35): Error: found `}` when expecting `;` following statement

    /tmp/tmp80hokvzj.d(36): Error: found `else` without a corresponding `if`, `version`
    or `debug` statement

    /tmp/tmp80hokvzj.d(45): Error: declaration expected, not `else`

    /tmp/tmp80hokvzj.d(48): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp80hokvzj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n    {\n        bool strcase = is(lower(k),\
    \ lower(v));\n        bool strupper = is(upper(k), upper(v));\n        if(!strcase\
    \ && !strupper) return false; // return false is empty \n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1cw88l02.d(23): Error: no identifier for declarator `v`

    /tmp/tmp1cw88l02.d(23): Error: found `)` when expecting `;`

    /tmp/tmp1cw88l02.d(23): Error: expression expected, not `in`

    /tmp/tmp1cw88l02.d(23): Error: found `dict` when expecting `)`

    /tmp/tmp1cw88l02.d(25): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmp1cw88l02.d(25): Error: found `,` when expecting `)`

    /tmp/tmp1cw88l02.d(25): Error: semicolon expected, not `lower`

    /tmp/tmp1cw88l02.d(25): Error: found `)` when expecting `;` following statement

    /tmp/tmp1cw88l02.d(25): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp1cw88l02.d(26): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmp1cw88l02.d(26): Error: found `,` when expecting `)`

    /tmp/tmp1cw88l02.d(26): Error: semicolon expected, not `upper`

    /tmp/tmp1cw88l02.d(26): Error: found `)` when expecting `;` following statement

    /tmp/tmp1cw88l02.d(26): Deprecation: use `{ }` '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull)\n    {\n        throw new Exception(\"invalid\
    \ empty dict\");\n    }\n    KeyValuePair!(string, string) kv;\n    for (KeyValuePair!(const\
    \ string& key, const string& val) in dict)\n    {\n        if (!isLower(key))\n\
    \        {\n            return false;\n        }\n        if (!isUpper(key))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdri1emiz.d(28): Error: `(arguments)` expected following `const(string)`

    /tmp/tmpdri1emiz.d(28): Error: `(arguments)` expected following `const(string)`

    /tmp/tmpdri1emiz.d(28): Error: found `)` when expecting `;` following statement

    /tmp/tmpdri1emiz.d(39): Error: found `return` when expecting `;` following `for`
    condition

    /tmp/tmpdri1emiz.d(39): Error: found `;` when expecting `)`

    /tmp/tmpdri1emiz.d(40): Error: found `}` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdri1emiz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !(dict.len() == 0);\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpepgwu1wt.d(23): Error: no property `len` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpepgwu1wt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v: dict)\n    {\n        if(v.isNull)\n        {\n\
    \            return false;\n        }\n        if(!v.asString().isLower())\n \
    \       {\n            return false;\n        }\n    }\n    \n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpglpqwbo6.d(23): Error: no identifier for declarator `v`

    /tmp/tmpglpqwbo6.d(23): Error: found `:` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpglpqwbo6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.isNull;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr32djqgh.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x457721]

    ??:? void tmpr32djqgh.__unittest_L25_C1() [0x4421eb]

    ??:? void tmpr32djqgh.__modtest() [0x45522c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x460a73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x456d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45c41d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45c4ac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45c3a9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x456d25]

    ??:? runModuleUnitTests [0x460849]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x458b2c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict.length == 0) \n        return true;\n    \n    auto it\
    \ = dict.begin();\n    auto itEnd = dict.end();\n    \n    for(; it != itEnd;\
    \ ++it)\n    {\n        if(it.key.islower() != it.value.islower())\n         \
    \   return false;\n    }\n    \n    for(; it != itEnd; ++it)\n    {\n        if(it.key.isupper()\
    \ != it.value.isupper())\n            return false;\n    }\n    \n    return true;\n\
    }\n\"\"\"\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk_v1sn53.d(43): Error: declaration expected, not `""`

    /tmp/tmpk_v1sn53.d(53): Error: unterminated string constant starting at /tmp/tmpk_v1sn53.d(53)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk_v1sn53.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int i = 0;\n    while (!is_null(dict[i]))\n    {\n        if\
    \ (!is_null(dict[i]))\n        {\n            if (dict[i].islower())\n       \
    \         return false;\n            else if (dict[i].isupper())\n           \
    \     return false;\n        }\n        ++i;\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplnji5fd7.d(24): Error: undefined identifier `is_null`

    /tmp/tmplnji5fd7.d(26): Error: undefined identifier `is_null`

    /tmp/tmplnji5fd7.d(28): Error: cannot implicitly convert expression `i` of type
    `int` to `string`

    /tmp/tmplnji5fd7.d(30): Error: cannot implicitly convert expression `i` of type
    `int` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplnji5fd7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  int count = 0;\n  for (auto it : dict) {\n    string key = it.first.as_string();\n\
    \    string val = it.second.as_string();\n    if (key == \"State\" || key == \"\
    Zip\")\n      count++;\n    else if (key == \"Name\" || key == \"Age\")\n    \
    \  count++;\n  }\n  if (count == 0) {\n    return true;\n  } else {\n    return\
    \ false;\n  }\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppot5dwch.d(24): Error: no identifier for declarator `it`

    /tmp/tmppot5dwch.d(24): Error: expression expected, not `:`

    /tmp/tmppot5dwch.d(24): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppot5dwch.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(key in dict) {\n        if(!key.key.hasCaseInsensitive())\
    \ {\n            return false;\n        }\n        if(!key.value.hasCaseInsensitive())\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    This has the additional advantage that you can easily test if the given value\
    \ is nullable or not.\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcfcfmftx.d(23): Error: no identifier for declarator `key`

    /tmp/tmpcfcfmftx.d(23): Error: found `in` when expecting `;`

    /tmp/tmpcfcfmftx.d(33): Error: declaration expected, not `<`

    /tmp/tmpcfcfmftx.d(40): Error: declaration expected, not `assert`

    /tmp/tmpcfcfmftx.d(41): Error: declaration expected, not `assert`

    /tmp/tmpcfcfmftx.d(42): Error: declaration expected, not `assert`

    /tmp/tmpcfcfmftx.d(43): Error: declaration expected, not `assert`

    /tmp/tmpcfcfmftx.d(44): Error: declaration expected, not `assert`

    /tmp/tmpcfcfmftx.d(45): Error: declaration expected, not `assert`

    /tmp/tmpcfcfmftx.d(46): Error: declaration expected, not `assert`

    /tmp/tmpcfcfmftx.d(47): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcfcfmftx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return is(dict.keys);\n}\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpu1kgyzet.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x457739]

    ??:? void tmpu1kgyzet.__unittest_L25_C1() [0x44210d]

    ??:? void tmpu1kgyzet.__modtest() [0x455244]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x460a8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x456d66]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45c435]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45c4c4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45c3c1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x456d3d]

    ??:? runModuleUnitTests [0x460861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x458b44]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull)\n    {\n        return false;\n    }\n    var\
    \ keys = dict.getKeys();\n    for (var i = 0, len = keys.size(); i < len; ++i)\n\
    \    {\n        string key = keys[i];\n        if (key.isLower())\n        {\n\
    \            return true;\n        }\n        if (key.isUpper())\n        {\n\
    \            return true;\n        }\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7f2_xh3x.d(27): Error: undefined identifier `var`

    /tmp/tmp7f2_xh3x.d(27): Error: no property `getKeys` for type `Nullable!(string[string])`

    /tmp/tmp7f2_xh3x.d(28): Error: undefined identifier `var`

    /tmp/tmp7f2_xh3x.d(28): Error: undefined identifier `var`

    /tmp/tmp7f2_xh3x.d(31): Error: no property `isLower` for type `string`

    /tmp/tmp7f2_xh3x.d(35): Error: no property `isUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7f2_xh3x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null) {\n        return false;\n    }\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe4mkt56t.d(26): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe4mkt56t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    // TODO: implement\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgrk1mfoy.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x457709]

    ??:? void tmpgrk1mfoy.__unittest_L26_C1() [0x4421d3]

    ??:? void tmpgrk1mfoy.__modtest() [0x455214]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x460a5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x456d36]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45c405]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45c494]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45c391]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x456d0d]

    ??:? runModuleUnitTests [0x460831]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x458b14]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for (auto key : dict)\n    {\n        auto key_case = key.key();\n\
    \        if (key_case != key_case.toLower())\n            return false;\n    }\n\
    \    return true;\n}\n</code>\n<|/ a tags=d,static-methods,associative-array,dictionary\
    \ |>\n<| a dscore=2 tags=d,static-methods,associative-array,dictionary |>\nWith\
    \ DMD and std.algorithm.search, it's very simple:\n<code>\nimport std.algorithm;\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv3t7as5e.d(23): Error: no identifier for declarator `key`

    /tmp/tmpv3t7as5e.d(23): Error: expression expected, not `:`

    /tmp/tmpv3t7as5e.d(23): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmpv3t7as5e.d(31): Error: declaration expected, not `<`

    /tmp/tmpv3t7as5e.d(34): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv3t7as5e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !is_null(dict);\n}\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj8mobi63.d(23): Error: undefined identifier `is_null`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj8mobi63.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    var _case = dict[\"A\"] == null && dict[\"B\"] == null && dict[\"\
    C\"] == null;\n    return _case;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfmhoihmv.d(23): Error: undefined identifier `var`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfmhoihmv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    forall key in dict[string]\n        if\n            not(isLower(key)\
    \ || isUpper(key))\n        then \n            false\n        else \n        \
    \    true\n}\n\"\"\")\n    return CheckDict({\n        \"nullable\": Nullable(lambda\
    \ key: len(key) == 0)\n    })\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz0emf4aw.d(23): Error: semicolon expected, not `in`

    /tmp/tmpz0emf4aw.d(23): Error: found `in` instead of statement

    /tmp/tmpz0emf4aw.d(31): Error: declaration expected, not `""`

    /tmp/tmpz0emf4aw.d(44): Error: unterminated string constant starting at /tmp/tmpz0emf4aw.d(44)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz0emf4aw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(auto kv : dict)\n    {\n        if(kv.first().length != kv.second().length())\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </cell>\n<cell>\n// Test\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp69wx6i28.d(23): Error: no identifier for declarator `kv`

    /tmp/tmp69wx6i28.d(23): Error: expression expected, not `:`

    /tmp/tmp69wx6i28.d(23): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmp69wx6i28.d(32): Error: declaration expected, not `<`

    /tmp/tmp69wx6i28.d(39): Error: declaration expected, not `assert`

    /tmp/tmp69wx6i28.d(40): Error: declaration expected, not `assert`

    /tmp/tmp69wx6i28.d(41): Error: declaration expected, not `assert`

    /tmp/tmp69wx6i28.d(42): Error: declaration expected, not `assert`

    /tmp/tmp69wx6i28.d(43): Error: declaration expected, not `assert`

    /tmp/tmp69wx6i28.d(44): Error: declaration expected, not `assert`

    /tmp/tmp69wx6i28.d(45): Error: declaration expected, not `assert`

    /tmp/tmp69wx6i28.d(46): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp69wx6i28.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, val) in dict do\n    {\n        bool result = toLower(key)\
    \ == toLower(val);\n        if (!result)\n            return false;\n    }\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_phq95mk.d(23): Error: no identifier for declarator `val`

    /tmp/tmp_phq95mk.d(23): Error: found `)` when expecting `;`

    /tmp/tmp_phq95mk.d(23): Error: expression expected, not `in`

    /tmp/tmp_phq95mk.d(23): Error: found `dict` when expecting `)`

    /tmp/tmp_phq95mk.d(29): Error: found `unittest` when expecting `while`

    /tmp/tmp_phq95mk.d(30): Error: found `{` when expecting `(`

    /tmp/tmp_phq95mk.d(31): Error: expression expected, not `alias`

    /tmp/tmp_phq95mk.d(31): Error: found `candidate` when expecting `)`

    /tmp/tmp_phq95mk.d(31): Error: terminating `;` required after do-while statement

    /tmp/tmp_phq95mk.d(31): Error: found `=` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_phq95mk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k in dict) \n    {\n        bool is_upper = k.getString().getChar(0)\
    \ >= 'A' && k.getString().getChar(0) <= 'Z';\n        if(!is_upper) \n       \
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp57tqa12z.d(23): Error: no identifier for declarator `k`

    /tmp/tmp57tqa12z.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp57tqa12z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        bool flag = false;\n        if(!dict?[k])\
    \ \n        {\n            flag = true;\n        }\n        else if(!dict?[k].isUppercase)\
    \ \n        {\n            flag = true;\n        }\n        if(flag)\n       \
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nTo make it more clear to understand I created\
    \ the following function, which takes array of associative array and checks if\
    \ all the keys are lowercase\n<code>\nimport std.algorithm; \nimport std.array;\n\
    import std.conv;\nimport std.conv;\nimport std.string;\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5s90ed74.d(23): Error: no identifier for declarator `v`

    /tmp/tmp5s90ed74.d(23): Error: found `)` when expecting `;`

    /tmp/tmp5s90ed74.d(26): Error: found `)` when expecting `:`

    /tmp/tmp5s90ed74.d(30): Error: found `else` when expecting `)`

    /tmp/tmp5s90ed74.d(30): Error: found `)` when expecting `:`

    /tmp/tmp5s90ed74.d(34): Error: found `if` when expecting `)`

    /tmp/tmp5s90ed74.d(38): Error: found `}` when expecting `;` following statement

    /tmp/tmp5s90ed74.d(41): Error: expression expected, not `/`

    /tmp/tmp5s90ed74.d(41): Error: found `code` when expecting `)`

    /tmp/tmp5s90ed74.d(41): Error: found `>` instead of statement

    /tmp/tmp5s90ed74.d(51): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5s90ed74.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(Keys key: dict)\n    {\n        if(!(isInfix(key) && isCaseInsensitive(key)))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nYou can write a simple function\
    \ to check the existence of any key in a dictionary:\n<code>\ndef exist(dict,\
    \ key)\n    dict.has_key?(key)\nend\n</code>\n<|/ a tags=null,ruby,hash |>\n<|\
    \ a dscore=2 tags=null,ruby,hash |>\nUsing Ruby 2.5.x, you can use the Hash#key?\
    \ method.\n<code>\nd = { \"a\" => 1, 2 => 3 }\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpajiqeda6.d(23): Error: found `key` when expecting `;` following
    statement

    /tmp/tmpajiqeda6.d(23): Error: expression expected, not `:`

    /tmp/tmpajiqeda6.d(23): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmpajiqeda6.d(32): Error: declaration expected, not `<`

    /tmp/tmpajiqeda6.d(50): Error: declaration expected, not `assert`

    /tmp/tmpajiqeda6.d(51): Error: declaration expected, not `assert`

    /tmp/tmpajiqeda6.d(52): Error: declaration expected, not `assert`

    /tmp/tmpajiqeda6.d(53): Error: declaration expected, not `assert`

    /tmp/tmpajiqeda6.d(54): Error: declaration expected, not `assert`

    /tmp/tmpajiqeda6.d(55): Error: declaration expected, not `assert`

    /tmp/tmpajiqeda6.d(56): Error: declaration expected, not `assert`

    /tmp/tmpajiqeda6.d(57): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpajiqeda6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return true;\n    auto dict_of_strings = dict.asMap();\n\
    \    for (auto pair : dict_of_strings) {\n        if (!pair.second.isString) \n\
    \            return false;\n        if (pair.second.asString().length() != 1)\
    \ \n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnnw0s5ai.d(25): Error: no identifier for declarator `pair`

    /tmp/tmpnnw0s5ai.d(25): Error: expression expected, not `:`

    /tmp/tmpnnw0s5ai.d(25): Error: found `dict_of_strings` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnnw0s5ai.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.isEmpty && dict.keys.all(key => \n        {\n  \
    \          if (toLower(key).equals(toLower(toUpper(key))))\n                return\
    \ true;\n            else\n                return false;\n        });\n}\n</code>\n\
    <|/ a tags=swift dscore=3 |>\n<| a dscore=3 tags=swift |>\nUsing Swift 4.2\n<code>\n\
    func isNullable<Value: Hashable, HashableKey>(fromDictionary dictionary: [HashableKey:\
    \ Value?]) -> (Bool, Dictionary<HashableKey, Value>?) {\n    guard let keys =\
    \ dictionary.keys,\n        keys.contains(where: { $0.hashValue == HashableKey.hashValue\
    \ }),\n        let lastKey = keys.last,\n        let lastValue: Value = dictionary[keys.last!]\
    \ else {\n            return (true, nil)\n    }\n    guard let firstValue = dictionary[keys.first!]\
    \ else {\n        return (true, Dictionary<HashableKey, Value>(nil))\n    }\n\
    \    return (true, Dictionary<HashableKey, Value>([lastKey : lastValue, firstKey\
    \ : firstValue]))\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\nHere is a simple solution\
    \ based on Antonio's answer. It avoids using a dictionary at all as it is just\
    \ a key-value pair array.\n<code>\nfunc isNullable<Value: Hashable, HashableKey>(fromDictionary\
    \ dictionary: [HashableKey: Value?]) -> (Bool, Dictionary<HashableKey, Value>?)\
    \ {\n    guard let keys = dictionary.keys,\n        keys.contains(where: { $0.hashValue\
    \ == HashableKey.hashValue }),\n        let lastKey = keys.last,\n        let\
    \ lastValue: Value = dictionary[keys.last!] else {\n            return (true,\
    \ nil)\n    }\n    guard let firstValue = dictionary[keys.first!] else {\n   \
    \     return (true, Dictionary<HashableKey, Value>(nil))\n    }\n    return (true,\
    \ Dictionary<HashableKey, Value>([lastKey : lastValue, firstKey : firstValue]))\n\
    }\n</code>\n<|/ a tags=swift |>\n<| a dscore=1 tags=swift |>\n<code>\nfunc isNullable<Value:\
    \ Hashable>(fromDictionary dictionary: [Value : Value?]) -> (Bool, Dictionary<Value,\
    \ Value>?) {\n    let values = dictionary.values.filter({ $0 == nil })\n    return\
    \ (values.isEmpty, values != nil && Dictionary <Value, Value>(dictionary: dictionary.map\
    \ {\n        (_, value) -> Value in (value: $0, value: value)\n    }))\n\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr38xj1fy.d(31): Error: declaration expected, not `<`

    /tmp/tmpr38xj1fy.d(51): Error: unterminated character constant

    /tmp/tmpr38xj1fy.d(79): Error: declaration expected, not `assert`

    /tmp/tmpr38xj1fy.d(80): Error: declaration expected, not `assert`

    /tmp/tmpr38xj1fy.d(81): Error: declaration expected, not `assert`

    /tmp/tmpr38xj1fy.d(82): Error: declaration expected, not `assert`

    /tmp/tmpr38xj1fy.d(83): Error: declaration expected, not `assert`

    /tmp/tmpr38xj1fy.d(84): Error: declaration expected, not `assert`

    /tmp/tmpr38xj1fy.d(85): Error: declaration expected, not `assert`

    /tmp/tmpr38xj1fy.d(86): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr38xj1fy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if( !dict.isNotNull() )\n    {\n        return false;\n    }\n\
    \    \n    // If dict is empty all keys must be in lower case.\n    // If dict\
    \ is empty all keys must be in upper case.\n    foreach( k : dict.keys() )\n \
    \   {\n        if( !string_compare(k.as_string(), k.as_string().to_lowercase())\
    \ )\n        {\n            return false;\n        }\n        if( !string_compare(k.as_string(),\
    \ k.as_string().to_uppercase()) )\n        {\n            return false;\n    \
    \    }\n    }\n    \n    return true;\n}\n\"\"\"\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb540q3hu.d(30): Error: no identifier for declarator `k`

    /tmp/tmpb540q3hu.d(30): Error: found `:` when expecting `;`

    /tmp/tmpb540q3hu.d(44): Error: declaration expected, not `""`

    /tmp/tmpb540q3hu.d(55): Error: unterminated string constant starting at /tmp/tmpb540q3hu.d(55)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb540q3hu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, val) in dict {\n        if (!(is_string(key) &&\
    \ is_string(val))) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n'''\n)\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxd6e7x2c.d(23): Error: no identifier for declarator `val`

    /tmp/tmpxd6e7x2c.d(23): Error: found `)` when expecting `;`

    /tmp/tmpxd6e7x2c.d(23): Error: expression expected, not `in`

    /tmp/tmpxd6e7x2c.d(23): Error: found `dict` when expecting `)`

    /tmp/tmpxd6e7x2c.d(30): Error: unterminated character constant

    /tmp/tmpxd6e7x2c.d(30): Error: declaration expected, not `63U`

    /tmp/tmpxd6e7x2c.d(30): Error: unterminated character constant

    /tmp/tmpxd6e7x2c.d(36): Error: declaration expected, not `assert`

    /tmp/tmpxd6e7x2c.d(37): Error: declaration expected, not `assert`

    /tmp/tmpxd6e7x2c.d(38): Error: declaration expected, not `assert`

    /tmp/tmpxd6e7x2c.d(39): Error: declaration expected, not `assert`

    /tmp/tmpxd6e7x2c.d(40): Error: declaration expected, not `assert`

    /tmp/tmpxd6e7x2c.d(41): Error: declaration expected, not `assert`

    /tmp/tmpxd6e7x2c.d(42): Error: declaration expected, not `assert`

    /tmp/tmpxd6e7x2c.d(43): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxd6e7x2c.d", "-I'
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(string k in dict.keys) {\n        auto case1 = toupper(k);\n\
    \        auto case2 = k.toUpper();\n        if (case1 != case2 || dict[k] == null)\
    \ \n            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8hf6vrxx.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8hf6vrxx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k in dict) {\n        if (!is_string(k)) return false;\
    \ // all keys not strings\n    }\n    return !dict.isNull;\n}\n\"\"\")\n    \n\
    def gen_stl_map(template):\n    stl_map_t = template.add_type('stl_map_t', \"\"\
    \"\ntypedef map<string, int> stl_map_t;\n\"\"\")\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbbtmziyp.d(23): Error: no identifier for declarator `k`

    /tmp/tmpbbtmziyp.d(23): Error: found `in` when expecting `;`

    /tmp/tmpbbtmziyp.d(28): Error: declaration expected, not `""`

    /tmp/tmpbbtmziyp.d(33): Error: declaration expected, not `""`

    /tmp/tmpbbtmziyp.d(43): Error: unterminated string constant starting at /tmp/tmpbbtmziyp.d(43)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbbtmziyp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    assert(!dict.isNull());\n    int count = 0;\n    foreach(string\
    \ key, dict) \n    {\n        if (count(key.c_str()) == 0)\n        {\n      \
    \      count = count + 1;\n        }\n    }\n    return count == 0;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nBased on your requirement, it looks like you just\
    \ want to check for existence of keys, and you are not interested in checking\
    \ their values (i.e. nullability of a key)\nSo you just need to check for existence\
    \ of keys in your associative array and you are done\n<code>\nunittest\n{\n  \
    \  alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoa33dwgr.d(25): Error: no identifier for declarator `dict`

    /tmp/tmpoa33dwgr.d(25): Error: found `)` when expecting `;`

    /tmp/tmpoa33dwgr.d(32): Error: found `return` when expecting `)`

    /tmp/tmpoa33dwgr.d(34): Error: declaration expected, not `<`

    /tmp/tmpoa33dwgr.d(44): Error: declaration expected, not `assert`

    /tmp/tmpoa33dwgr.d(45): Error: declaration expected, not `assert`

    /tmp/tmpoa33dwgr.d(46): Error: declaration expected, not `assert`

    /tmp/tmpoa33dwgr.d(47): Error: declaration expected, not `assert`

    /tmp/tmpoa33dwgr.d(48): Error: declaration expected, not `assert`

    /tmp/tmpoa33dwgr.d(49): Error: declaration expected, not `assert`

    /tmp/tmpoa33dwgr.d(50): Error: declaration expected, not `assert`

    /tmp/tmpoa33dwgr.d(51): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoa33dwgr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.isEmpty && dict[\"a\"] == \"apple\" && dict[\"A\"\
    ] == \"banana\";\n}\n</code>\n<|/ a tags=d,struct,associative-array,arrays,std\
    \ |>\n<| c |>\nThe last example in the question is a good one. This should be\
    \ made more explicit. `const` may have some side effects.\n<|/ c |>\n<| c |>\n\
    This doesn't work if your dictionary keys may have numeric suffixes like `1`,\
    \ `2`, `3`.  Also, I don't think this solution correctly handles duplicate keys.\n\
    <|/ c |>\n<| c |>\nI fixed my solution. It also handles duplicate keys.\n<|/ c\
    \ |>\n<| c |>\n`!dict.isEmpty` looks unnecessary in the loop condition, since\
    \ `dict[]` returns `null` if the key doesn't exist.\n<|/ c |>\n<| a dscore=2 |>\n\
    If your array is not too big, you can simply loop through it and check the keys\
    \ for case-sensitive matches:\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkif3r5e7.d(25): Error: declaration expected, not `<`

    /tmp/tmpkif3r5e7.d(31): Error: unterminated character constant

    /tmp/tmpkif3r5e7.d(31): Error: unterminated character constant

    /tmp/tmpkif3r5e7.d(37): Error: unterminated character constant

    /tmp/tmpkif3r5e7.d(46): Error: declaration expected, not `assert`

    /tmp/tmpkif3r5e7.d(47): Error: declaration expected, not `assert`

    /tmp/tmpkif3r5e7.d(48): Error: declaration expected, not `assert`

    /tmp/tmpkif3r5e7.d(49): Error: declaration expected, not `assert`

    /tmp/tmpkif3r5e7.d(50): Error: declaration expected, not `assert`

    /tmp/tmpkif3r5e7.d(51): Error: declaration expected, not `assert`

    /tmp/tmpkif3r5e7.d(52): Error: declaration expected, not `assert`

    /tmp/tmpkif3r5e7.d(53): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkif3r5e7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool valid = true;\n    for (int i=0; i<len(dict); ++i)\n   \
    \ {\n        string key = dict[i].first;\n        string value = (string)dict[i].second;\n\
    \        \n        if (key.equals(\"state\") || key.equals(\"postalcode\"))\n\
    \            continue;\n        \n        if (!value.isEmpty())\n            valid\
    \ = false;\n    }\n    return valid;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt2gponlq.d(27): Error: C style cast illegal, use `cast(string)dict[i].second`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt2gponlq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tforeach(string str in dict){\n\t\tint len = length(dict[str]);\n\
    \t\tif (len != 1){\n\t\t\terror(\"Invalid dictionary for check_dict_case\");\n\
    \t\t}\n\t\tif (isupper(str) || islower(str)){\n\t\t\treturn false;\n\t\t}\n\t\
    }\n\treturn true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp837oq12b.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp837oq12b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, value) in dict do\n    {\n        if (std.typecons.isLower(key)\
    \ || std.typecons.isUpper(key))\n        {\n            return false;\n      \
    \  }\n    }\n    return true;\n}\n\"\"\"\n</cell>\n<cell>\n!./bin/bash ../Helper/BiomarkerGuy/Helper/Scripts/check_dict_case.sh\n\
    </cell>\n<text>\ncheck_dict_case({\"a\": \"apple\", \"b\": \"banana\"})\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp35tlztrw.d(23): Error: no identifier for declarator `value`

    /tmp/tmp35tlztrw.d(23): Error: found `)` when expecting `;`

    /tmp/tmp35tlztrw.d(23): Error: expression expected, not `in`

    /tmp/tmp35tlztrw.d(23): Error: found `dict` when expecting `)`

    /tmp/tmp35tlztrw.d(30): Error: found `return` when expecting `while`

    /tmp/tmp35tlztrw.d(30): Error: found `true` when expecting `(`

    /tmp/tmp35tlztrw.d(30): Error: expression expected, not `;`

    /tmp/tmp35tlztrw.d(31): Error: found `}` when expecting `)`

    /tmp/tmp35tlztrw.d(32): Error: terminating `;` required after do-while statement

    /tmp/tmp35tlztrw.d(32): Error: Implicit string concatenation is deprecated, use
    "" ~ "\x0a</cell>\x0a<cell>\x0a!./bin/bash ../Helper/BiomarkerGuy/Helper/Scripts/check_dict_case.sh\x0a</cell>\x0a<text>\x0acheck_dict_case({"
    instead

    /tmp/tmp35tlztrw.d(38): Error: found `a` when expecting `;` following statement

    /tmp/tmp35tlztrw.d(38): Error: found `apple` when expecting `;` following statement

    /tmp/tmp35tlztrw.d(38): Error: found `b` whe'
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.hasKey(null);\n}\n\"\"\"\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4qd73qgh.d(25): Error: declaration expected, not `""`

    /tmp/tmp4qd73qgh.d(35): Error: unterminated string constant starting at /tmp/tmp4qd73qgh.d(35)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4qd73qgh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    \n    for(auto &v: dict)\n        if(!is_str(v) && is_str(v.value)\
    \ || !is_str(v) && !is_str(v.value))\n            return false;\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvn21iq64.d(24): Error: basic type expected, not `&`

    /tmp/tmpvn21iq64.d(24): Error: no identifier for declarator `_error_`

    /tmp/tmpvn21iq64.d(24): Error: found `:` when expecting `;` following `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvn21iq64.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(!dict.isNull)\n    {\n        bool result = true;\n      \
    \  for(auto v: dict)\n        {\n            if(!v.key.isUpperCase && v.key.isLowercase)\n\
    \            {\n                result = false;\n                break;\n    \
    \        }\n            else if(v.key.isUpperCase && !v.key.isLowercase)\n   \
    \         {\n                result = false;\n                break;\n       \
    \     }\n        }\n        return result;\n    }\n    else\n    {\n        return\
    \ false;\n    }\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppylns92u.d(26): Error: no identifier for declarator `v`

    /tmp/tmppylns92u.d(26): Error: expression expected, not `:`

    /tmp/tmppylns92u.d(26): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppylns92u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tauto iter = dict.begin();\n\tauto end= dict.end();\n\tfor (; iter\
    \ != end; ++iter) {\n\t\tif (!(iter.key().toLower() == iter.key().toUpper()))\
    \ return false;\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwf887vnk.d(23): Error: no property `begin` for type `Nullable!(string[string])`

    /tmp/tmpwf887vnk.d(24): Error: no property `end` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwf887vnk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(key in dict, value){\n        if (!strcasecmp(key.get(),\
    \ key.get().c_str()))\n            return false;\n        if (typeof(dict[key])\
    \ <> typeof(Nullable!(string[string]))) return false;\n    }\n    return true;\n\
    }\n</code>\nIt uses the fact that Nullable is a value type that can be null. \n\
    It also uses the fact that an std::map has a type that is an std::pair and that\
    \ std::pair has a type that is std::pair and that is also Nullable!(string[string]).\n\
    <|/ a tags=dictionary,python,c++,boost |>\n<| c |>\nHow would the code look if\
    \ we wanted to add `if (key.get().empty()) return false; else return true;`?\n\
    <|/ c |>\n<| c |>\n, I added a second version. It should now be clear.\n<|/ c\
    \ |>\n<| a dscore=2 |>\nI modified ChristopheD's solution slightly to handle key\
    \ collisions:\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9rwxa45r.d(23): Error: no identifier for declarator `key`

    /tmp/tmp9rwxa45r.d(23): Error: found `in` when expecting `;`

    /tmp/tmp9rwxa45r.d(26): Error: expression expected, not `>`

    /tmp/tmp9rwxa45r.d(26): Error: found `typeof` when expecting `)`

    /tmp/tmp9rwxa45r.d(26): Error: found `)` when expecting `;` following statement

    /tmp/tmp9rwxa45r.d(30): Error: declaration expected, not `<`

    /tmp/tmp9rwxa45r.d(41): Error: unterminated character constant

    /tmp/tmp9rwxa45r.d(47): Error: declaration expected, not `assert`

    /tmp/tmp9rwxa45r.d(48): Error: declaration expected, not `assert`

    /tmp/tmp9rwxa45r.d(49): Error: declaration expected, not `assert`

    /tmp/tmp9rwxa45r.d(50): Error: declaration expected, not `assert`

    /tmp/tmp9rwxa45r.d(51): Error: declaration expected, not `assert`

    /tmp/tmp9rwxa45r.d(52): Error: declaration expected, not `assert`

    /tmp/tmp9rwxa45r.d(53): Error: declaration expected, not `assert`

    /tmp/tmp9rwxa45r.d(54): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tm'
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(!dict)\n    {\n        throw new ArgumentError.value(dict,\
    \ \"dict\", \"Dictionary cannot be empty\");\n    }\n    for (key in dict)\n \
    \   {\n        if (std.isLower(key))\n        {\n            return true;\n  \
    \      }\n        if (std.isUpper(key))\n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiyp40nfw.d(27): Error: found `)` when expecting `;` following statement

    /tmp/tmpiyp40nfw.d(38): Error: found `return` when expecting `;` following `for`
    condition

    /tmp/tmpiyp40nfw.d(38): Error: found `;` when expecting `)`

    /tmp/tmpiyp40nfw.d(39): Error: found `}` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiyp40nfw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  // TODO: Complete this function\n  return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_4j216qs.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x457709]

    ??:? void tmp_4j216qs.__unittest_L26_C1() [0x4421d3]

    ??:? void tmp_4j216qs.__modtest() [0x455214]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x460a5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x456d36]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45c405]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45c494]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45c391]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x456d0d]

    ??:? runModuleUnitTests [0x460831]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x458b14]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.empty()) return false;\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxarfv2bs.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxarfv2bs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tforeach(k, v) dict += k as string;\n\treturn dict[\"A\"] != dict[\"\
    a\"] || dict[\"B\"] != dict[\"b\"];\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4d4esvoe.d(23): Error: no identifier for declarator `v`

    /tmp/tmp4d4esvoe.d(23): Error: found `)` when expecting `;`

    /tmp/tmp4d4esvoe.d(23): Error: found `as` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4d4esvoe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) \n    {\n        if (k as string in Lower(k)) \n\
    \        {\n            if (k as string in Upper(k))\n            {\n        \
    \        return false;\n            }\n            else\n            {\n     \
    \           return true;\n            }\n        }\n        else\n        {\n\
    \            return true;\n        }\n    }\n    return false;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp50zm6oll.d(23): Error: no identifier for declarator `v`

    /tmp/tmp50zm6oll.d(23): Error: found `)` when expecting `;`

    /tmp/tmp50zm6oll.d(25): Error: found `as` when expecting `)`

    /tmp/tmp50zm6oll.d(25): Error: found `)` when expecting `;` following statement

    /tmp/tmp50zm6oll.d(27): Error: found `as` when expecting `)`

    /tmp/tmp50zm6oll.d(27): Error: found `)` when expecting `;` following statement

    /tmp/tmp50zm6oll.d(31): Error: found `else` without a corresponding `if`, `version`
    or `debug` statement

    /tmp/tmp50zm6oll.d(36): Error: found `else` when expecting `)`

    /tmp/tmp50zm6oll.d(41): Error: declaration expected, not `return`

    /tmp/tmp50zm6oll.d(42): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp50zm6oll.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(!dict.is_empty())\n    {\n        foreach(k, v |v in dict)\n\
    \        {\n            if(is_lower(k) || is_upper(k))\n                return\
    \ true;\n        }\n    }\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2lkcwree.d(25): Error: no identifier for declarator `v`

    /tmp/tmp2lkcwree.d(25): Error: found `|` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2lkcwree.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null) {\n        return true;\n    }\n    auto keyList\
    \ = dict.keys;\n    auto valueList = dict.values;\n    auto keyLength = (size_t)keyList.size();\n\
    \    auto valueLength = (size_t)valueList.size();\n    // If there are any non-string\
    \ or non-number keys, return false\n    for (size_t i = 0; i < keyLength; ++i)\
    \ {\n        if (!is_string_or_number(keyList[i])) {\n            return false;\n\
    \        }\n    }\n    for (size_t i = 0; i < valueLength; ++i) {\n        if\
    \ (!is_string_or_number(valueList[i])) {\n            return false;\n        }\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvib161t7.d(28): Error: C style cast illegal, use `cast(size_t)keyList.size()`

    /tmp/tmpvib161t7.d(29): Error: C style cast illegal, use `cast(size_t)valueList.size()`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvib161t7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !std.typecons.is_nil(dict.key) || !std.typecons.is_nil(dict.value.keys());\n\
    }\n'''\nchecker_dict['check_dict_case'] = check_dict_case\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgm5nftgz.d(25): Error: unterminated character constant

    /tmp/tmpgm5nftgz.d(25): Error: declaration expected, not `63U`

    /tmp/tmpgm5nftgz.d(25): Error: unterminated character constant

    /tmp/tmpgm5nftgz.d(26): Error: unterminated character constant

    /tmp/tmpgm5nftgz.d(26): Error: unterminated character constant

    /tmp/tmpgm5nftgz.d(31): Error: declaration expected, not `assert`

    /tmp/tmpgm5nftgz.d(32): Error: declaration expected, not `assert`

    /tmp/tmpgm5nftgz.d(33): Error: declaration expected, not `assert`

    /tmp/tmpgm5nftgz.d(34): Error: declaration expected, not `assert`

    /tmp/tmpgm5nftgz.d(35): Error: declaration expected, not `assert`

    /tmp/tmpgm5nftgz.d(36): Error: declaration expected, not `assert`

    /tmp/tmpgm5nftgz.d(37): Error: declaration expected, not `assert`

    /tmp/tmpgm5nftgz.d(38): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgm5nftgz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.IsEmpty) \n    { \n        return false; \n    } \n\
    \    \n    for (auto& [key, value] : dict)\n    {\n        if (!(is_string(value)\
    \ || is_string(key)))\n        {\n            return false; \n        } \n   \
    \ }\n    return true; \n} \n/*\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpasthysyt.d(28): Error: basic type expected, not `&`

    /tmp/tmpasthysyt.d(28): Error: no identifier for declarator `_error_`

    /tmp/tmpasthysyt.d(28): Error: found `:` when expecting `;` following `for` condition

    /tmp/tmpasthysyt.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpasthysyt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return true;\n    auto lowercase = [](string\
    \ s) { return s.lower(); };\n    auto uppercase = [](string s) { return s.upper();\
    \ };\n    return std::all_of(dict.dict.begin(), dict.dict.end(), [&](pair<string,\
    \ string> p){\n        return p.first.isNull() && p.second.isNull() ? true :\n\
    \            check(lowercase(p.first), p.second) ||\n            check(uppercase(p.first),\
    \ p.second);\n    });\n}\n</code>\n<|/ a tags=dictionary,c++,stl,stdmap |>\n<|\
    \ c |>\nThis is a much more idiomatic approach than the one I proposed.\n<|/ c\
    \ |>\n<| c |>\nIt actually uses less memory then my solution -- I used `std::set`\
    \ as I couldn't use my own hash function and I didn't want to use Boost hash_set\
    \ as it is unavailable in some environments\n<|/ c |>\n<| c |>\nI wrote a similar\
    \ solution a while back using C++03 constructs and I believe it can handle any\
    \ type with implicit conversion to `string`.  Though it's also more complicated\
    \ than it needs to be.  I'll add it back in if it doesn't work\n<|/ c |>\n<| c\
    \ |>\nI added a version that works with C++03 constructs, and also an example\
    \ showing that it works with non-`string` keys\n<|/ c |>\n<| a tags=dictionary,c++,stl,stdmap\
    \ |>\nI think it's best to use an unordered_map or unordered_set - no doubt you'll\
    \ get better performance.\n<|/ a dscore=1 |>\n<| c |>\nBut it uses more memory,\
    \ since each entry must be stored twice. Also, if you use custom hash functions\
    \ with unordered_set/unordered_map you may get incorrect results (see http://www.boost.org/doc/libs/1_45_0/doc/html/unordered/containers.html)\n\
    <|/ c |>\n<| c |>\n: Yes, but with C++0x unordered_map/unordered_set can take\
    \ an allocator as a template parameter.\n<|/ c |>\n<| c |>\n: I believe the memory\
    \ usage is pretty much the same, since a map or set has pointers pointing to its\
    \ elements.\n<|/ c |>\n<| c |>\n: Also, just realized that boost::unordered_map/unordered_set\
    \ can take an allocator as a template parameter.\n<|/ c |>\n<| a dscore=1 |>\n\
    I'd like to throw in something based on Brad's ideas that I've used before.  It's\
    \ \nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ha51m0q.d(24): Error: found `s` when expecting `,`

    /tmp/tmp4ha51m0q.d(24): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmp4ha51m0q.d(24): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp4ha51m0q.d(25): Error: found `s` when expecting `,`

    /tmp/tmp4ha51m0q.d(25): Error: semicolon expected following auto declaration,
    not `{`

    /tmp/tmp4ha51m0q.d(25): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp4ha51m0q.d(26): Error: found `:` when expecting `;` following `return`
    statement

    /tmp/tmp4ha51m0q.d(26): Error: found `:` instead of statement

    /tmp/tmp4ha51m0q.d(30): Error: declaration expected, not `)`

    /tmp/tmp4ha51m0q.d(31): Error: unrecognized declaration

    /tmp/tmp4ha51m0q.d(38): Error: unterminated character constant

    /tmp/tmp4ha51m0q.d(38): Error: unterminated character constant

    /tmp/tmp4ha51m0q.d(41): Error: unterminated character constant

    /tmp/tmp4ha51m0q.d(41): Error: unterminated character constant

    /tmp/tmp4ha51m0q.d(41): Error: unterminated character '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto keys = dict.keys();\n    for(auto itr = keys.begin(); itr\
    \ != keys.end(); ++itr) {\n        auto ktype = key_type(*itr);\n        auto\
    \ vtype = value_type(*itr);\n        if(ktype == std.typecons.std_string_t.type())\
    \ {\n            if(vtype == std.typecons.std_string_t.type()) {\n           \
    \     // all keys are in lower case\n            } else {\n                //\
    \ all keys are in upper case\n            }\n        } else {\n            if(vtype\
    \ == std.typecons.std_string_t.type()) {\n                // all keys are in upper\
    \ case\n            } else {\n                // all keys are in lower case\n\
    \            }\n        }\n    }\n    return dict.has_elements();\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=swift,dictionary,associative-array,arrays |>\n<code>\n\
    public static func isDictionary(_ object: Any?) -> Bool {\n    switch object!\
    \ {\n    case is Dictionary<String, Any?>:\n        return true\n    case is Array:\n\
    \        return false\n    case is String:\n        return true\n    case is Int:\n\
    \        return false\n    case is Float:\n        return false\n    case is Dictionary:\n\
    \        return false\n    case is [AnyObject]:\n        return false\n    case\
    \ is AnyObject:\n        return false\n    default:\n        return false\n  \
    \  }\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks. I added this as another\
    \ answer to this question: https://stackoverflow.com/a/63785627/1888901\n<|/ c\
    \ |>\n<| a dscore=2 |>\nSwift 5.1 added two new methods to Dictionary to check\
    \ whether it contains a key or value, and whether it contains an entry for the\
    \ key or value. These are all checked at compile time, rather than run time, so\
    \ it can be used for static type checking.\n<code>\nextension Dictionary {\n \
    \   func containsKey(_ key: Key) -> Bool\n    {\n        return contains(key)\
    \ || self[key].isEmpty == false\n    }\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2_tz5r4k.d(43): Error: declaration expected, not `<`

    /tmp/tmp2_tz5r4k.d(86): Error: declaration expected, not `assert`

    /tmp/tmp2_tz5r4k.d(87): Error: declaration expected, not `assert`

    /tmp/tmp2_tz5r4k.d(88): Error: declaration expected, not `assert`

    /tmp/tmp2_tz5r4k.d(89): Error: declaration expected, not `assert`

    /tmp/tmp2_tz5r4k.d(90): Error: declaration expected, not `assert`

    /tmp/tmp2_tz5r4k.d(91): Error: declaration expected, not `assert`

    /tmp/tmp2_tz5r4k.d(92): Error: declaration expected, not `assert`

    /tmp/tmp2_tz5r4k.d(93): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2_tz5r4k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isEmpty()) return false;\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprqk1jb2g.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprqk1jb2g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isEmpty)\n        throw \"check_dict_case() called with\
    \ empty associative array!\";\n    for (KeyValuePair!(string,string) entry in\
    \ dict)\n    {\n        if (entry.key.equalsCaseInsensitive(\"lower\")) // convert\
    \ key from upper to lower\n            return true;\n        else if (entry.key.equalsCaseInsensitive(\"\
    upper\")) // convert key from lower to upper\n            return false;\n    \
    \    else \n            throw \"KeyValuePair!(string,string) dictionary does not\
    \ contain correct key name!\";\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp78o_wr5r.d(25): Error: semicolon expected, not `in`

    /tmp/tmp78o_wr5r.d(25): Error: expression expected, not `in`

    /tmp/tmp78o_wr5r.d(25): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp78o_wr5r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int: foreach ( key, value ) in dict do \n    {\n        // ignore\
    \ keys that aren't strings\n        if( key !is string ) then\n            return\
    \ false;\n        // ignore keys that aren't all lower case\n        if( value\
    \ !is string[string] ) then\n            return false;\n        \n        if(\
    \ value !islower ) then\n            return false;\n        \n        if( value\
    \ !isequal value.toUpper ) then\n            return false;\n        \n    } \n\
    \    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7k8you0s.d(23): Error: no identifier for declarator `int`

    /tmp/tmp7k8you0s.d(23): Error: found `:` instead of statement

    /tmp/tmp7k8you0s.d(30): Error: found `return` when expecting `;` following statement

    /tmp/tmp7k8you0s.d(33): Error: found `return` when expecting `;` following statement

    /tmp/tmp7k8you0s.d(35): Error: found `value` when expecting `)`

    /tmp/tmp7k8you0s.d(35): Error: found `)` when expecting `;` following statement

    /tmp/tmp7k8you0s.d(36): Error: found `return` when expecting `;` following statement

    /tmp/tmp7k8you0s.d(39): Error: declaration expected, not `return`

    /tmp/tmp7k8you0s.d(40): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7k8you0s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) dict += Nullable!(string) k + Nullable!(string)\
    \ v;\n    \n    int cnt = 0;\n    \n    foreach(k, v) if (k == toUpper(v)) cnt++;\n\
    \    foreach(k, v) if (k == toLower(v)) cnt++;\n    \n    bool result = cnt >\
    \ 0 && cnt == dict.count();\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp15j918_q.d(23): Error: no identifier for declarator `v`

    /tmp/tmp15j918_q.d(23): Error: found `)` when expecting `;`

    /tmp/tmp15j918_q.d(23): Error: found `k` when expecting `)`

    /tmp/tmp15j918_q.d(23): Error: found `v` when expecting `;` following statement

    /tmp/tmp15j918_q.d(23): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp15j918_q.d(27): Error: no identifier for declarator `v`

    /tmp/tmp15j918_q.d(27): Error: found `)` when expecting `;`

    /tmp/tmp15j918_q.d(27): Error: expression expected, not `if`

    /tmp/tmp15j918_q.d(27): Error: found `cnt` when expecting `)`

    /tmp/tmp15j918_q.d(27): Error: expression expected, not `;`

    /tmp/tmp15j918_q.d(28): Error: found `foreach` when expecting `;` following statement

    /tmp/tmp15j918_q.d(28): Error: found `if` when expecting `;` following statement

    /tmp/tmp15j918_q.d(28): Error: found `cnt` when expecting `;` following statement

    /tmp/tmp15j918_q.d(28): Error: expression expected, not `;`

    /tmp/tmp15j918_q.d(30): Error: found `bool` when expecting `;` fo'
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    Nullable!(string) first;\n    Nullable!(string) second;\n   \
    \ bool result = false;\n    if (dict.isNull())\n        return true;\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfgtwm_vn.d(28): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfgtwm_vn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n   if(not dict)\n       return true;\n   foreach(e, dict)\n   {\n\
    \       if(!is_string(e))\n       {\n           return false;\n       }\n    \
    \   if(!is_string(e))\n       {\n           return false;\n       }\n   }\n  \
    \ return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n   \
    \ assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp79hkuttx.d(23): Error: found `dict` when expecting `)`

    /tmp/tmp79hkuttx.d(23): Error: found `)` instead of statement

    /tmp/tmp79hkuttx.d(25): Error: no identifier for declarator `dict`

    /tmp/tmp79hkuttx.d(25): Error: found `)` when expecting `;`

    /tmp/tmp79hkuttx.d(36): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp79hkuttx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    // If dict is an empty dictionary return true\n    if(!dict ||\
    \ !dict.isEmpty) return true;\n    \n    // Get all the keys and convert to lowercase\n\
    \    string[] keys = (string[])dict.toList().toArray();\n    \n    // If the first\
    \ key's value is null or empty, return false\n    if(!keys[0].isEmpty()) return\
    \ false;\n    \n    // If the keys are all upper case return true\n    foreach(i\
    \ in keys.indices){\n        if(!keys[i].isUppercase()) return false;\n    }\n\
    \    \n    // If all the keys are upper case return true\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu_d_7ul8.d(27): Error: C style cast illegal, use `cast(string[])dict.toList().toArray()`

    /tmp/tmpu_d_7ul8.d(33): Error: no identifier for declarator `i`

    /tmp/tmpu_d_7ul8.d(33): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu_d_7ul8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for (auto it : dict)\n        if (it.key as string in \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n            if (it.key as string in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n     \
    \           return false;\n    return true;\n}\n</code>\nThis doesn't take into\
    \ account the case where you have a dictionary with a key of \"a\" and \"a\" and\
    \ the value \"a\" though.\n<|/ a tags=types,ocaml,functional-programming,dictionary,comparison\
    \ |>\n<| c |>\nThank you! The use of a `for` loop is something I should probably\
    \ get familiar with more closely.\n<|/ c |>\n<| a dscore=1 tags=types,ocaml,functional-programming,dictionary,comparison\
    \ |>\nHere is another method using pattern matching. This one doesn't rely on\
    \ nullable types. Although it also doesn't check if the dictionary is empty.\n\
    <code>\ntype 'a dict = {\n    mutable mutable dict : 'a -> 'a;\n    mutable mutable\
    \ count : int;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n   \
    \ assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpckwf84s4.d(23): Error: no identifier for declarator `it`

    /tmp/tmpckwf84s4.d(23): Error: expression expected, not `:`

    /tmp/tmpckwf84s4.d(23): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmpckwf84s4.d(24): Error: found `as` when expecting `)`

    /tmp/tmpckwf84s4.d(24): Error: found `)` when expecting `;` following statement

    /tmp/tmpckwf84s4.d(25): Error: found `as` when expecting `)`

    /tmp/tmpckwf84s4.d(25): Error: found `)` when expecting `;` following statement

    /tmp/tmpckwf84s4.d(29): Error: declaration expected, not `<`

    /tmp/tmpckwf84s4.d(30): Error: unterminated character constant

    /tmp/tmpckwf84s4.d(36): Error: unterminated character constant

    /tmp/tmpckwf84s4.d(36): Error: unterminated character constant

    /tmp/tmpckwf84s4.d(38): Error: unterminated character constant

    /tmp/tmpckwf84s4.d(39): Error: unterminated character constant

    /tmp/tmpckwf84s4.d(39): Error: unterminated character constant

    /tmp/tmpckwf84s4.d(40): Error: semicolon expected, not `count`

    /tmp/tmpckwf84s4.d(40): Er'
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = true;\n    foreach(k, v : {!dict}) {\n        bool\
    \ isString = !is_null(v);\n        if (!isString || !k) {\n            result\
    \ = false;\n        } else {\n            string key = k;\n            string\
    \ lowerCase = key.lower;\n            string upperCase = key.upper;\n        \
    \    if (isString) {\n                bool result = false;\n                if\
    \ (lowerCase != upperCase) {\n                    result = true;\n           \
    \     }\n                else {\n                    string lowerUpper = key.lower\
    \ + key.upper;\n                    bool result = false;\n                   \
    \ if (lowerUpper != lowerCase) {\n                        result = true;\n   \
    \                 }\n                    else {\n                        string\
    \ upperLower = key.upper + key.lower;\n                        bool result = false;\n\
    \                        if (lowerUpper != upperCase) {\n                    \
    \        result = true;\n                        }\n                        else\
    \ {\n                            string lowerUpperNoSpace = key.lower.replace(\"\
    \ \", \"\");\n                            bool result = false;\n             \
    \               if (lowerUpper != lowerUpperNoSpace) {\n                     \
    \           result = true;\n                            }\n                  \
    \          else {\n                                string upperLowerNoSpace =\
    \ key.upper.replace(\" \", \"\");\n                                bool result\
    \ = false;\n                                if (upperLower != upperLowerNoSpace)\
    \ {\n                                    result = true;\n                    \
    \            }\n                                else {\n                     \
    \               string noSpace = key.replace(\" \", \"\");\n                 \
    \                   bool result = false;\n                                   \
    \ if (noSpace != lowerUpperNoSpace) {\n                                      \
    \  result = true;\n                                    }\n                   \
    \             }\n                            }\n                        }\n  \
    \                  }\n                }\n            }\n            else {\n \
    \               result = false;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn_z7purb.d(24): Error: no identifier for declarator `v`

    /tmp/tmpn_z7purb.d(24): Error: found `:` when expecting `;`

    /tmp/tmpn_z7purb.d(24): Error: found `}` when expecting `;` following statement

    /tmp/tmpn_z7purb.d(24): Error: found `)` instead of statement

    /tmp/tmpn_z7purb.d(78): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn_z7purb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.length == 0) {\n        return true;\n    }\n    auto\
    \ iter = dict.begin();\n    string key = (*iter).first;\n    auto end = dict.end();\n\
    \    for(++iter; iter != end; ++iter) {\n        if (iter->first.lexeme != key)\
    \ {\n            return false;\n        }\n        if (iter->first.upper != key)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    And a little test:\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk4e6dj_f.d(30): Error: use `.` for member lookup, not `->`

    /tmp/tmpk4e6dj_f.d(33): Error: use `.` for member lookup, not `->`

    /tmp/tmpk4e6dj_f.d(39): Error: declaration expected, not `<`

    /tmp/tmpk4e6dj_f.d(46): Error: declaration expected, not `assert`

    /tmp/tmpk4e6dj_f.d(47): Error: declaration expected, not `assert`

    /tmp/tmpk4e6dj_f.d(48): Error: declaration expected, not `assert`

    /tmp/tmpk4e6dj_f.d(49): Error: declaration expected, not `assert`

    /tmp/tmpk4e6dj_f.d(50): Error: declaration expected, not `assert`

    /tmp/tmpk4e6dj_f.d(51): Error: declaration expected, not `assert`

    /tmp/tmpk4e6dj_f.d(52): Error: declaration expected, not `assert`

    /tmp/tmpk4e6dj_f.d(53): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk4e6dj_f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  if(dict.IsEmpty)\n  {\n    return false;\n  }\n  foreach(string\
    \ key in dict.Keys)\n  {\n    bool result = is_lower_case(key) || is_upper_case(key);\
    \ \n    if(!result)\n    {\n      return false;\n    }\n  }\n  return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp20u01c8p.d(27): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp20u01c8p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164429
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == Nullable!(string[string])) return true;\n    \n \
    \   foreach(ref key, ref val; dict) {\n        if (!is_string(key)) return false;\n\
    \        if (!is_string(val)) return false;\n    }\n    \n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptsvn5v8r.d(23): Error: incompatible types for `(dict) == (inout(string[string]))`:
    cannot use `==` with types

    /tmp/tmptsvn5v8r.d(26): Error: undefined identifier `is_string`

    /tmp/tmptsvn5v8r.d(27): Error: undefined identifier `is_string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptsvn5v8r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return false;\n    foreach (key, value) in dict\n\
    \        if (value.isNull) return false;\n    foreach (key, value) in dict\n \
    \       if (!value.isString) return false;\n    return true;\n}\n\"\"\"\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ohvlifm.d(24): Error: no identifier for declarator `value`

    /tmp/tmp8ohvlifm.d(24): Error: found `)` when expecting `;`

    /tmp/tmp8ohvlifm.d(24): Error: expression expected, not `in`

    /tmp/tmp8ohvlifm.d(24): Error: found `dict` when expecting `)`

    /tmp/tmp8ohvlifm.d(26): Error: no identifier for declarator `value`

    /tmp/tmp8ohvlifm.d(26): Error: found `)` when expecting `;`

    /tmp/tmp8ohvlifm.d(26): Error: expression expected, not `in`

    /tmp/tmp8ohvlifm.d(26): Error: found `dict` when expecting `)`

    /tmp/tmp8ohvlifm.d(30): Error: declaration expected, not `""`

    /tmp/tmp8ohvlifm.d(40): Error: unterminated string constant starting at /tmp/tmp8ohvlifm.d(40)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ohvlifm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (kv in dict)\n    {\n        if (!is_string(kv))\n  \
    \      {\n            return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcphp3xox.d(23): Error: no identifier for declarator `kv`

    /tmp/tmpcphp3xox.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcphp3xox.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull)\n    {\n        return false;\n    }\n    for\
    \ (auto key : string.keys(dict))\n    {\n        if (key.isLowercase())\n    \
    \    {\n            continue;\n        }\n        if (key.isUppercase())\n   \
    \     {\n            continue;\n        }\n        return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprdyuk7t4.d(27): Error: no identifier for declarator `key`

    /tmp/tmprdyuk7t4.d(27): Error: expression expected, not `:`

    /tmp/tmprdyuk7t4.d(27): Error: found `string` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprdyuk7t4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  require(dict != null);\n  for(auto it : dict)\n  {\n    require(it.key!=null);\n\
    \    require(it.key!=\"\");\n    require(it.key!='\\0');\n    require(it.key!=it);\n\
    \  }\n  return !dict.empty();\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw_tysodg.d(24): Error: no identifier for declarator `it`

    /tmp/tmpw_tysodg.d(24): Error: expression expected, not `:`

    /tmp/tmpw_tysodg.d(24): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw_tysodg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (pair!(string[string], string) entry in dict) \n    {\n\
    \        if (!(check_type(Nullable!(string[string]))))\n        {\n          \
    \  return false;\n        }\n        if (!(check_type(string)))\n        {\n \
    \           return false;\n        }\n        if (!(check_strings(entry.key)))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprmv02mx9.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprmv02mx9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = false;\n    if (dict.has_value())\n    {\n    \
    \    for (auto [key, value] : dict)\n        {\n            if (is_string(value))\n\
    \            {\n                result = true;\n                break;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo_xforpi.d(26): Error: basic type expected, not `[`

    /tmp/tmpo_xforpi.d(26): Error: found `,` when expecting `]`

    /tmp/tmpo_xforpi.d(26): Error: semicolon expected, not `]`

    /tmp/tmpo_xforpi.d(26): Error: expression expected, not `]`

    /tmp/tmpo_xforpi.d(26): Error: found `:` when expecting `;` following `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo_xforpi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(x, dict) \n    {\n        \n        if (!isa(x, String)\
    \ || toLower(x) != x)\n        {\n            return false;\n        }\n    }\n\
    \    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6wo2eewq.d(23): Error: no identifier for declarator `dict`

    /tmp/tmp6wo2eewq.d(23): Error: found `)` when expecting `;`

    /tmp/tmp6wo2eewq.d(31): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6wo2eewq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (string k in dict) \n    {\n        if (!(k.toLower()\
    \ == k.toUpper()))\n        {\n            return false;\n        }\n    }\n \
    \   return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n \
    \   assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpimcgiqmh.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpimcgiqmh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return true;\n    foreach(string key in dict)\
    \ \n    {\n        if (!(typeof(key) == string)) return false;\n        if (!isLowercase(key.c_str()))\
    \ return false;\n    }\n    \n    return true;\n}\n</code>\n<|/ a dscore=1 tags=c,c++,types,python\
    \ |>\n<| a |>\nI came up with this solution which works on C and C++:\n<code>\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpolag6jpc.d(24): Error: found `in` when expecting `;`

    /tmp/tmpolag6jpc.d(32): Error: declaration expected, not `<`

    /tmp/tmpolag6jpc.d(41): Error: declaration expected, not `assert`

    /tmp/tmpolag6jpc.d(42): Error: declaration expected, not `assert`

    /tmp/tmpolag6jpc.d(43): Error: declaration expected, not `assert`

    /tmp/tmpolag6jpc.d(44): Error: declaration expected, not `assert`

    /tmp/tmpolag6jpc.d(45): Error: declaration expected, not `assert`

    /tmp/tmpolag6jpc.d(46): Error: declaration expected, not `assert`

    /tmp/tmpolag6jpc.d(47): Error: declaration expected, not `assert`

    /tmp/tmpolag6jpc.d(48): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpolag6jpc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    intraref keys (dict);\n    bool b = false;\n    keys.foreach((Key!(string)\
    \ key){\n        if (key == key)\n            b = True;\n    });\n    return b;\n\
    }\n</code>\n<|/ a tags=c#,dictionary,string,.net,types dscore=0 |>\n<| a dscore=0\
    \ |>\nI wrote the following function:\n<code>\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptvq7ustw.d(25): Error: identifier expected following `.`, not `foreach`

    /tmp/tmptvq7ustw.d(31): Error: declaration expected, not `<`

    /tmp/tmptvq7ustw.d(40): Error: declaration expected, not `assert`

    /tmp/tmptvq7ustw.d(41): Error: declaration expected, not `assert`

    /tmp/tmptvq7ustw.d(42): Error: declaration expected, not `assert`

    /tmp/tmptvq7ustw.d(43): Error: declaration expected, not `assert`

    /tmp/tmptvq7ustw.d(44): Error: declaration expected, not `assert`

    /tmp/tmptvq7ustw.d(45): Error: declaration expected, not `assert`

    /tmp/tmptvq7ustw.d(46): Error: declaration expected, not `assert`

    /tmp/tmptvq7ustw.d(47): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptvq7ustw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for (auto key : dict)\n    {\n        bool isLowerCase = key.to<string>().toLower();\n\
    \        bool isUpperCase = key.to<string>().toUpper();\n        \n        if\
    \ (key.hasValue() && isLowerCase == isUpperCase)\n            return true;\n \
    \   }\n    \n    return false;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi7y08hix.d(23): Error: no identifier for declarator `key`

    /tmp/tmpi7y08hix.d(23): Error: expression expected, not `:`

    /tmp/tmpi7y08hix.d(23): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmpi7y08hix.d(25): Error: semicolon expected, not `>`

    /tmp/tmpi7y08hix.d(25): Error: found `>` instead of statement

    /tmp/tmpi7y08hix.d(26): Error: semicolon expected, not `>`

    /tmp/tmpi7y08hix.d(26): Error: found `>` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi7y08hix.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return false; \n    foreach (var key in dict.keys)\
    \ {\n        if (!key.has_case_change()) return false;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk2_zl5lm.d(24): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk2_zl5lm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  int count = 0;\n  foreach(key,value) in dict {\n    count += 1;\n\
    \    if (key.upper) {\n      return false;\n    }\n    if (key.lower) {\n    \
    \  return false;\n    }\n  }\n  return count == 0;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmproja832v.d(24): Error: no identifier for declarator `value`

    /tmp/tmproja832v.d(24): Error: found `)` when expecting `;`

    /tmp/tmproja832v.d(24): Error: expression expected, not `in`

    /tmp/tmproja832v.d(24): Error: found `dict` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmproja832v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (kk, v) in dict \n    {\n        if (typeof(kk) != typeof(string))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\n''');\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpymncg84h.d(23): Error: no identifier for declarator `v`

    /tmp/tmpymncg84h.d(23): Error: found `)` when expecting `;`

    /tmp/tmpymncg84h.d(23): Error: expression expected, not `in`

    /tmp/tmpymncg84h.d(23): Error: found `dict` when expecting `)`

    /tmp/tmpymncg84h.d(32): Error: unterminated character constant

    /tmp/tmpymncg84h.d(32): Error: declaration expected, not `63U`

    /tmp/tmpymncg84h.d(32): Error: unterminated character constant

    /tmp/tmpymncg84h.d(33): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpymncg84h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tforeach (string key in dict)\n\t{\n\t\tif (!dict[key])\n\t\t{\n\
    \t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!string.IsNullOrWhiteSpace(dict[key]))\n\
    \t\t{\n\t\t\tif (dict[key].ToLowerInvariant() != key)\n\t\t\t{\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\t\n\t\t\tstring temp = dict[key].ToLowerInvariant();\n\
    \t\t\t\n\t\t\tif (temp != key)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\
    }\n\t}\n\t\n\treturn true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptrvruzji.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptrvruzji.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    map<string, string> toUpper = {\n        \"a\": \"A\", \"b\"\
    : \"B\", \"c\": \"C\", \"d\": \"D\", \"e\": \"E\", \"f\": \"F\", \"g\": \"G\"\
    , \"h\": \"H\", \"i\": \"I\", \"j\": \"J\", \"k\": \"K\", \"l\": \"L\", \"m\"\
    : \"M\", \"n\": \"N\", \"o\": \"O\", \"p\": \"P\", \"q\": \"Q\", \"r\": \"R\"\
    , \"s\": \"S\", \"t\": \"T\", \"u\": \"U\", \"v\": \"V\", \"w\": \"W\", \"x\"\
    : \"X\", \"y\": \"Y\", \"z\": \"Z\", \n    };\n    map<string, string> toLower\
    \ = {\n        \"a\": \"a\", \"b\": \"b\", \"c\": \"c\", \"d\": \"d\", \"e\":\
    \ \"e\", \"f\": \"f\", \"g\": \"g\", \"h\": \"h\", \"i\": \"i\", \"j\": \"j\"\
    , \"k\": \"k\", \"l\": \"l\", \"m\": \"m\", \"n\": \"n\", \"o\": \"o\", \"p\"\
    : \"p\", \"q\": \"q\", \"r\": \"r\", \"s\": \"s\", \"t\": \"t\", \"u\": \"u\"\
    , \"v\": \"v\", \"w\": \"w\", \"x\": \"x\", \"y\": \"y\", \"z\": \"z\",\n    };\n\
    \    for (auto it: dict)\n    {\n        if (it.first.first != it.first.second)\n\
    \            return false;\n        if (toUpper[it.first.first] == it.first.second)\n\
    \            return false;\n        if (toLower[it.first.first] == it.first.second)\n\
    \            return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaeyq4tu7.d(24): Error: found `:` when expecting `;` following statement

    /tmp/tmpaeyq4tu7.d(24): Error: found `:` when expecting `;` following statement

    /tmp/tmpaeyq4tu7.d(24): Error: found `:` when expecting `;` following statement

    /tmp/tmpaeyq4tu7.d(24): Error: found `:` when expecting `;` following statement

    /tmp/tmpaeyq4tu7.d(24): Error: found `:` when expecting `;` following statement

    /tmp/tmpaeyq4tu7.d(24): Error: found `:` when expecting `;` following statement

    /tmp/tmpaeyq4tu7.d(24): Error: found `:` when expecting `;` following statement

    /tmp/tmpaeyq4tu7.d(24): Error: found `:` when expecting `;` following statement

    /tmp/tmpaeyq4tu7.d(24): Error: found `:` when expecting `;` following statement

    /tmp/tmpaeyq4tu7.d(24): Error: found `:` when expecting `;` following statement

    /tmp/tmpaeyq4tu7.d(24): Error: found `:` when expecting `;` following statement

    /tmp/tmpaeyq4tu7.d(24): Error: found `:` when expecting `;` following statement

    /tmp/tmpaeyq4tu7.d(24): Error: found `:` when expecting `;` foll'
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (k, v) in dict \n    {\n        if ( k.toLowerCase()\
    \ in Nullable!(string[string].t) ) \n        {\n            return false;\n  \
    \      }\n    }\n    return true;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=dictionary,python\
    \ |>\nThis solution uses dict.__contains__ to check for existence of a key. \n\
    <code>\ndef check_dict_case(d):\n    for k,v in d.items():\n        if isinstance(k,str)\
    \ and k.islower():\n            return False\n        elif isinstance(k,str) and\
    \ k.isupper():\n            return False\n    return True\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=dictionary,python |>\nMy first approach would be to iterate over\
    \ all keys and check if each one is a string with islower() and isupper() methods.\
    \ \n<code>\ndef check_dict_case(dictionary):\n    for key, value in dictionary.items():\n\
    \        if type(value) is str:\n            if (key.islower() or key.isupper())\
    \ == True:\n                return False\n    return True\n</code>\nIt would return\
    \ True if all keys are lowercase or all keys are uppercase. \nIt will also return\
    \ True if the dictionary is empty, thus returning False\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 |>\nI think it would be more efficient if you check only keys instead\
    \ of whole dictionary\n<code>\ndef check_dict_case(dictionary):\n    for key,\
    \ value in dictionary.items():\n        if not isinstance(key,str) and not isinstance(value,str):\n\
    \            return False\n    return True\n</code>\n<|/ a tags=dictionary,python\
    \ |>\n<| a dscore=0 |>\nYou can make a function to check:\n<code>\ndef string_checker(str):\n\
    \  for i in str[::-1]:\n    if ord(i) >= 97 and ord(i) <= 122:\n      if ord(i)\
    \ - 32 > 25:\n        return False\n  return True\n</code>\nThen check all the\
    \ keys and values like this:\n<code>\nfor key, value in dictionary.items():\n\
    \  if type(value) is str:\n    if not string_checker(key):\n      return False\n\
    \  if not string_checker(value):\n    return False\nreturn True\n</code>\n<|/\
    \ a tags=dictionary,python |>\n<| c |>\nHow about `return (ord(i) - 32) > 25`?\n\
    <|/ c |>\n<| a tags=dictionary,python dscore=0 |>\nI assume that you are not allowed\
    \ to use any built-in function, including len(), isupper(), islower(), etc.\n\
    <code>\ndef checkDict(d):\n    for key, value in d.items():\n        if isinstance(key,str)\
    \ and key.isupper() and isinstance(value,str) and value.isupper():\n         \
    \   return False\n        elif key.islower() and value.islower():\n          \
    \  return False\n    return True\n</code>\n<|/ a |>\n<| a tags=dictionary,python\
    \ |>\nI \nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzwmc8oq8.d(23): Error: no identifier for declarator `v`

    /tmp/tmpzwmc8oq8.d(23): Error: found `)` when expecting `;`

    /tmp/tmpzwmc8oq8.d(23): Error: expression expected, not `in`

    /tmp/tmpzwmc8oq8.d(23): Error: found `dict` when expecting `)`

    /tmp/tmpzwmc8oq8.d(32): Error: declaration expected, not `<`

    /tmp/tmpzwmc8oq8.d(111): Error: declaration expected, not `assert`

    /tmp/tmpzwmc8oq8.d(112): Error: declaration expected, not `assert`

    /tmp/tmpzwmc8oq8.d(113): Error: declaration expected, not `assert`

    /tmp/tmpzwmc8oq8.d(114): Error: declaration expected, not `assert`

    /tmp/tmpzwmc8oq8.d(115): Error: declaration expected, not `assert`

    /tmp/tmpzwmc8oq8.d(116): Error: declaration expected, not `assert`

    /tmp/tmpzwmc8oq8.d(117): Error: declaration expected, not `assert`

    /tmp/tmpzwmc8oq8.d(118): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzwmc8oq8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(auto iter : dict) {\n        auto [key, value] = iter;\n\
    \        if (key.size() != value.size() || key < 'a' || key > 'z') return false;\n\
    \    }\n    return true;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=dictionary,python\
    \ |>\nThe above accepted answer from Rudi is correct in that it is only checking\
    \ to ensure that the key is upper case or lower case. \nThis is my way of handling\
    \ the problem:\n<code>\nif all(k.isupper() or k.islower() for k in dict_of_values.keys()):\n\
    \    return True\nelse:\n    return False\n</code>\n<|/ a dscore=1 |>\n<| a tags=dictionary,python\
    \ |>\nHere are some ways I can think of. My answer is in Python, but I hope it\
    \ helps.\nIn Java, the following code would work.\n<code>\npublic class CheckKeysAreInLowerCase\
    \ {\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxoe8c4s5.d(23): Error: no identifier for declarator `iter`

    /tmp/tmpxoe8c4s5.d(23): Error: expression expected, not `:`

    /tmp/tmpxoe8c4s5.d(23): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmpxoe8c4s5.d(24): Error: basic type expected, not `[`

    /tmp/tmpxoe8c4s5.d(24): Error: found `,` when expecting `]`

    /tmp/tmpxoe8c4s5.d(24): Error: semicolon expected, not `]`

    /tmp/tmpxoe8c4s5.d(24): Error: found `]` instead of statement

    /tmp/tmpxoe8c4s5.d(29): Error: declaration expected, not `<`

    /tmp/tmpxoe8c4s5.d(50): Error: declaration expected, not `assert`

    /tmp/tmpxoe8c4s5.d(51): Error: declaration expected, not `assert`

    /tmp/tmpxoe8c4s5.d(52): Error: declaration expected, not `assert`

    /tmp/tmpxoe8c4s5.d(53): Error: declaration expected, not `assert`

    /tmp/tmpxoe8c4s5.d(54): Error: declaration expected, not `assert`

    /tmp/tmpxoe8c4s5.d(55): Error: declaration expected, not `assert`

    /tmp/tmpxoe8c4s5.d(56): Error: declaration expected, not `assert`

    /tmp/tmpxoe8c4s5.d(57): Error: unrecognized '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(key of dict)\n    {\n        foreach(char(char) in key)\n\
    \        {\n            if(islower(char))\n                throw \"Invalid dictionary\
    \ key for case check.\";\n            if(isupper(char))\n                throw\
    \ \"Invalid dictionary key for case check.\";\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp346mnx8w.d(23): Error: found `dict` when expecting `;`

    /tmp/tmp346mnx8w.d(23): Error: expression expected, not `)`

    /tmp/tmp346mnx8w.d(24): Error: found `{` when expecting `)`

    /tmp/tmp346mnx8w.d(25): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmp346mnx8w.d(25): Error: no identifier for declarator `char(char)`

    /tmp/tmp346mnx8w.d(25): Error: found `in` when expecting `;`

    /tmp/tmp346mnx8w.d(27): Error: found `)` when expecting `.` following char

    /tmp/tmp346mnx8w.d(27): Error: found `)` when expecting identifier following `char`.

    /tmp/tmp346mnx8w.d(28): Error: found `throw` when expecting `,`

    /tmp/tmp346mnx8w.d(28): Error: found `;` when expecting `,`

    /tmp/tmp346mnx8w.d(29): Error: expression expected, not `if`

    /tmp/tmp346mnx8w.d(29): Error: found `)` when expecting `.` following char

    /tmp/tmp346mnx8w.d(29): Error: found `)` when expecting identifier following `char`.

    /tmp/tmp346mnx8w.d(30): Error: found `throw` when expecting `,`

    /tmp/tmp346mnx8w'
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (!dict)\n        return false;\n    if (dict.size() == 0)\n\
    \        return false;\n    \n    foreach (key, value) in dict {\n        if (!is_string(value)\
    \ || !is_string(key))\n            return false;\n        \n        if (value.toLower()\
    \ != key)\n            return false;\n    }\n    return true;\n}\n\"\"\")\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5fdv83vt.d(28): Error: no identifier for declarator `value`

    /tmp/tmp5fdv83vt.d(28): Error: found `)` when expecting `;`

    /tmp/tmp5fdv83vt.d(28): Error: expression expected, not `in`

    /tmp/tmp5fdv83vt.d(28): Error: found `dict` when expecting `)`

    /tmp/tmp5fdv83vt.d(37): Error: declaration expected, not `""`

    /tmp/tmp5fdv83vt.d(47): Error: unterminated string constant starting at /tmp/tmp5fdv83vt.d(47)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5fdv83vt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  // check dict\n  if (dict == null || dict.isNull) return true;\n\
    \  \n  // check key\n  auto keys = dict.keys;\n  for (auto key : keys) \n  {\n\
    \    if (key.isString() && !key.isLower() && !key.isUpper()) return false; \n\
    \  }\n  \n  return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz2lsxc1j.d(28): Error: no identifier for declarator `key`

    /tmp/tmpz2lsxc1j.d(28): Error: expression expected, not `:`

    /tmp/tmpz2lsxc1j.d(28): Error: found `keys` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2lsxc1j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    // TODO: Support dictionaries with non-string keys\n    return\
    \ !dict.empty;\n}\n\"\"\"\n)\n</cell>\n<cell>\ncheck_dict_case([\"Name\": \"John\"\
    , \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n</cell>\n<cell>\ncheck_dict_case({})\n\
    </cell>\n<cell>\ncheck_dict_case({\"a\": \"apple\", \"b\": \"banana\"})\n</cell>\n\
    <cell>\ncheck_dict_case({\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"\
    })\n</cell>\n<cell>\ncheck_dict_case({\"a\": \"apple\", 8L: \"banana\", \"a\"\
    : \"apple\"})\n</cell>\n<cell>\ncheck_dict_case({\"a\": \"apple\", \"Name\": \"\
    John\", \"Age\": \"36\", \"City\": \"Houston\"})\n</cell>\n<cell>\ncheck_dict_case({\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n</cell>\n<text>\n\
    Exercise 9\nWrite a function that accepts a nullable integer and returns it if\
    \ it's in between 0 and 10, else returns null.\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_abrnijx.d(26): Error: declaration expected, not `""`

    /tmp/tmp_abrnijx.d(62): Error: unterminated string constant starting at /tmp/tmp_abrnijx.d(62)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_abrnijx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    var res = true;\n    for (string k in dict) {\n        if (!isLowercase(k)\
    \ && !isUppercase(k)) {\n            res = false;\n            break;\n      \
    \  }\n    }\n    return res;\n}\n\"\"\")\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7akdp54c.d(24): Error: semicolon expected, not `in`

    /tmp/tmp7akdp54c.d(24): Error: expression expected, not `in`

    /tmp/tmp7akdp54c.d(24): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmp7akdp54c.d(32): Error: declaration expected, not `""`

    /tmp/tmp7akdp54c.d(42): Error: unterminated string constant starting at /tmp/tmp7akdp54c.d(42)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7akdp54c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tforeach ( key in dict) \n\t{\n\t\tif (!is_string(key)) return false;\n\
    \t\tif (!is_string(dict[key]))return false;\n\t}\n\treturn true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2t9yvrt5.d(23): Error: no identifier for declarator `key`

    /tmp/tmp2t9yvrt5.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2t9yvrt5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v: dict)\n        if (!is_string(k))\n        {\n\
    \            return false;\n        }\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjkn3a6b7.d(23): Error: no identifier for declarator `v`

    /tmp/tmpjkn3a6b7.d(23): Error: found `:` when expecting `;`

    /tmp/tmpjkn3a6b7.d(28): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjkn3a6b7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.is_empty())\n        return true;\n    auto iter = dict.key_map().begin();\n\
    \    auto end = dict.key_map().end();\n    for (; iter != end; ++iter) {\n   \
    \     auto s = iter->first;\n        auto l = s.length();\n        auto us = s.c_str();\n\
    \        auto ul = us.length();\n        if (ul < l)\n            return false;\n\
    \        if (ul == l)\n            continue;\n        auto s0 = s.c_str();\n \
    \       auto l0 = l-1;\n        for (; s0 >= l0 && ul >= l0; --s0, --ul)\n   \
    \         if (*s0 == *us)\n                continue;\n        return false;\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgfk7n790.d(28): Error: use `.` for member lookup, not `->`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgfk7n790.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(var key in dict)\n    {\n        if (!is_string(key))\
    \ return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxgwgfdh0.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxgwgfdh0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\treturn dict.isNotEmpty && all( key=> \n\t\t(dict[key] instanceof\
    \ String && key.toLowerCase().isLowerOrEqual(\"name\") || dict[key] instanceof\
    \ String && key.toUpperCase().isLowerOrEqual(\"name\")));\n}\nunittest\n{\n  \
    \  alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnqw4hy99.d(24): Error: found `instanceof` when expecting `)`

    /tmp/tmpnqw4hy99.d(24): Error: found `String` when expecting `,`

    /tmp/tmpnqw4hy99.d(24): Error: expression expected, not `&&`

    /tmp/tmpnqw4hy99.d(24): Error: found `key` when expecting `,`

    /tmp/tmpnqw4hy99.d(24): Error: found `instanceof` when expecting `,`

    /tmp/tmpnqw4hy99.d(24): Error: found `)` when expecting `;` following `return`
    statement

    /tmp/tmpnqw4hy99.d(24): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnqw4hy99.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.length == 0)\n    {\n        return true;\n    }\n \
    \   else \n    {\n        for (int i = 0; i < dict.length; i++) \n        {\n\
    \            if (dict[\"a\"].toString() == dict[\"A\"].toString() || dict[\"B\"\
    ].toString() == dict[\"B\"].toString() || dict[\"A\"].toString() == dict[\"a\"\
    ].toString()) \n            {\n                continue;\n            }\n    \
    \        else \n            {\n                return false;\n            }\n\
    \        }\n        return true;\n    }\n}\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfwgvel2u.d(31): Error: no property `toString` for type `string`

    /tmp/tmpfwgvel2u.d(31): Error: no property `toString` for type `string`

    /tmp/tmpfwgvel2u.d(31): Error: no property `toString` for type `string`

    /tmp/tmpfwgvel2u.d(31): Error: no property `toString` for type `string`

    /tmp/tmpfwgvel2u.d(31): Error: no property `toString` for type `string`

    /tmp/tmpfwgvel2u.d(31): Error: no property `toString` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfwgvel2u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int sz = dict.size;\n    for(int i = 0; i < sz; i++) \n    {\n\
    \        string key = dict.keys[i];\n        if(key.empty())\n            return\
    \ false;\n        \n        auto c = toupper(key[0]);\n        if(c == key[0])\
    \ \n        {\n            key = key[1];\n        }\n        \n        auto cased\
    \ = std.casefold2(key);\n        if(c == cased) \n        {\n            dict.keys[i]\
    \ = key;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5heza2j8.d(23): Error: no property `size` for type `Nullable!(string[string])`

    /tmp/tmp5heza2j8.d(27): Error: no property `empty` for type `string`

    /tmp/tmp5heza2j8.d(30): Error: undefined identifier `toupper`

    /tmp/tmp5heza2j8.d(33): Error: cannot implicitly convert expression `key[1]` of
    type `immutable(char)` to `string`

    /tmp/tmp5heza2j8.d(36): Error: undefined identifier `casefold2` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5heza2j8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (string key in dict) {\n        if (!(key in string))\
    \ {\n            return false;\n        }\n        if (!islower(key) || !isupper(key))\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n\"\"\"\n\
    \        \n    def nullable(self):\n        return \"\"\"\nimport std.array;\n\
    import std.range;\nimport std.function;\nimport std.stdio;\nimport std.string;\n\
    import std.typecons;\nimport std.math;\n/*\n    \n    Check all keys in a dictionary\
    \ are either strings or ints.\n    Return true if the given dictionary is nullable\
    \ (all keys are either strings or ints),\n    else return false. The function\
    \ should return false if the given dictionary is empty.\n    \n    Examples:\n\
    \    >>> check_nullable_dict([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"\
    Houston\"].nullable)\n    true\n    >>> check_nullable_dict([\"Name\": \"John\"\
    , \"Age\": \"36\", \"City\": \"Houston\", 8L: \"banana\"].nullable)\n    false\n\
    \    >>> check_nullable_dict([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"\
    Houston\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    \n*/\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkd6j_mf4.d(23): Error: found `in` when expecting `;`

    /tmp/tmpkd6j_mf4.d(33): Error: declaration expected, not `""`

    /tmp/tmpkd6j_mf4.d(39): Error: identifier expected following `package`

    /tmp/tmpkd6j_mf4.d(39): Error: `;` expected

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkd6j_mf4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.isNull;\n}\n'''\n)\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsndn12uc.d(25): Error: unterminated character constant

    /tmp/tmpsndn12uc.d(25): Error: declaration expected, not `63U`

    /tmp/tmpsndn12uc.d(25): Error: unterminated character constant

    /tmp/tmpsndn12uc.d(31): Error: declaration expected, not `assert`

    /tmp/tmpsndn12uc.d(32): Error: declaration expected, not `assert`

    /tmp/tmpsndn12uc.d(33): Error: declaration expected, not `assert`

    /tmp/tmpsndn12uc.d(34): Error: declaration expected, not `assert`

    /tmp/tmpsndn12uc.d(35): Error: declaration expected, not `assert`

    /tmp/tmpsndn12uc.d(36): Error: declaration expected, not `assert`

    /tmp/tmpsndn12uc.d(37): Error: declaration expected, not `assert`

    /tmp/tmpsndn12uc.d(38): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsndn12uc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if( !dict.exists ) \n    {\n        return false;\n    }\n  \
    \  return ( !dict.keys.any() || !dict.values.any() ) ? false : true;\n}\n\"\"\"\
    )\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_wh7o_j2.d(29): Error: declaration expected, not `""`

    /tmp/tmp_wh7o_j2.d(39): Error: unterminated string constant starting at /tmp/tmp_wh7o_j2.d(39)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_wh7o_j2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto keys_to_lower: array<char, str> =\n    {\n        'A', 'B',\
    \ 'C', 'D', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    };\n    auto keys_to_upper:\
    \ array<char, str> =\n    {\n        'A', 'B', 'C', 'D', 'F', 'G', 'H', 'I', 'J',\
    \ 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\
    \ 'Y', 'Z',\n        'a', 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n\
    \    };\n    auto keys_unset: array<char, str> =\n    {\n        'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z',\n        'a', 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j',\
    \ 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z',\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n    };\n\
    \    auto keys_exist: array<char, str> =\n    {\n        'A', 'B', 'C', 'D', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T',\
    \ 'U', 'V', 'W', 'X', 'Y', 'Z',\n        'a', 'b', 'c', 'd', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z',\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\
    \    };\n    auto keys_exist1: array<char, str> =\n    {\n        'A', 'B', 'C',\
    \ 'D', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q', 'R',\
    \ 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n        'a', 'b', 'c', 'd', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z',\n        '0', '1', '2', '3', '4', '5', '6', '7', '8',\
    \ '9',\n        'a', 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n\
    \        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n       \
    \ '0', '1', '2', '\nunittest\n{\n    alias candidate = check_dict_case;\n\n  \
    \  assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4wfbmze0.d(23): Error: no identifier for declarator `keys_to_lower`

    /tmp/tmp4wfbmze0.d(23): Error: found `:` instead of statement

    /tmp/tmp4wfbmze0.d(28): Error: no identifier for declarator `keys_to_upper`

    /tmp/tmp4wfbmze0.d(28): Error: declaration expected, not `:`

    /tmp/tmp4wfbmze0.d(35): Error: no identifier for declarator `keys_unset`

    /tmp/tmp4wfbmze0.d(35): Error: declaration expected, not `:`

    /tmp/tmp4wfbmze0.d(42): Error: no identifier for declarator `keys_exist`

    /tmp/tmp4wfbmze0.d(42): Error: declaration expected, not `:`

    /tmp/tmp4wfbmze0.d(50): Error: no identifier for declarator `keys_exist1`

    /tmp/tmp4wfbmze0.d(50): Error: declaration expected, not `:`

    /tmp/tmp4wfbmze0.d(59): Error: unterminated character constant

    /tmp/tmp4wfbmze0.d(64): Error: declaration expected, not `assert`

    /tmp/tmp4wfbmze0.d(65): Error: declaration expected, not `assert`

    /tmp/tmp4wfbmze0.d(66): Error: declaration expected, not `assert`

    /tmp/tmp4wfbmze0.d(67): Error: declaration expected, not `assert`

    /tmp/tmp4wfbmze0.d('
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return true;\n    \n    // check if all keys\
    \ are lowercase\n    int numLower = 0;\n    for (string key in dict) {\n     \
    \   string value = dict[key];\n        if (value.isNull) return true;\n      \
    \  if (!value.compareToIgnoreCase(key)) {\n            numLower++;\n        }\n\
    \    }\n    \n    // check if all keys are uppercase\n    int numUpper = 0;\n\
    \    for (string key in dict) {\n        string value = dict[key];\n        if\
    \ (value.isNull) return true;\n        if (!value.compareToIgnoreCase(key)) {\n\
    \            numUpper++;\n        }\n    }\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp66lbexhe.d(27): Error: semicolon expected, not `in`

    /tmp/tmp66lbexhe.d(27): Error: expression expected, not `in`

    /tmp/tmp66lbexhe.d(27): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmp66lbexhe.d(37): Error: semicolon expected, not `in`

    /tmp/tmp66lbexhe.d(37): Error: expression expected, not `in`

    /tmp/tmp66lbexhe.d(37): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmp66lbexhe.d(44): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp66lbexhe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tauto key = dict.get_fields();\n\tbool allStrings = true;\n\t\n\t\
    for (auto& v : key) {\n\t\tif (not is_str(v.first)) {\n\t\t\tallStrings = false;\n\
    \t\t}\n\t}\n\t\n\treturn allStrings;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx9ng06_0.d(26): Error: basic type expected, not `&`

    /tmp/tmpx9ng06_0.d(26): Error: no identifier for declarator `_error_`

    /tmp/tmpx9ng06_0.d(26): Error: found `:` when expecting `;` following `for` condition

    /tmp/tmpx9ng06_0.d(27): Error: found `is_str` when expecting `)`

    /tmp/tmpx9ng06_0.d(27): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx9ng06_0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  foreach(key in dict, key < \"A\"){\n    bool isLower = true;\n\
    \    foreach(key2 in dict, key2 < \"a\"){\n      if(!(isLower && key2 != key &&\
    \ key2.toupper() == key2) || (!isLower && key2 != key && key2.tolower() == key2))\n\
    \        return false\n    }\n  }\n  return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf2s7n_86.d(23): Error: no identifier for declarator `key`

    /tmp/tmpf2s7n_86.d(23): Error: found `in` when expecting `;`

    /tmp/tmpf2s7n_86.d(25): Error: no identifier for declarator `key2`

    /tmp/tmpf2s7n_86.d(25): Error: found `in` when expecting `;`

    /tmp/tmpf2s7n_86.d(28): Error: found `}` when expecting `;` following `return`
    statement

    /tmp/tmpf2s7n_86.d(32): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf2s7n_86.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tforeach (k,v) in dict \n\t{\n\t\tif (isNull(to!string(k))) \n\t\
    \t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplj838lm8.d(23): Error: no identifier for declarator `v`

    /tmp/tmplj838lm8.d(23): Error: found `)` when expecting `;`

    /tmp/tmplj838lm8.d(23): Error: expression expected, not `in`

    /tmp/tmplj838lm8.d(23): Error: found `dict` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplj838lm8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    Nullable!(string) strKeys = dict.get_keys()\n    if !strKeys.is_empty()\
    \ then \n    {\n        for (string strKey in strKeys) \n        { \n        \
    \    if strKey.length() > 0 && !strKey.is_lowercase() \n                && !strKey.is_uppercase()\
    \ \n                return false\n        }\n    }\n    else \n    {\n       \
    \ return false\n    }\n    return true\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=c#,null,tuples,dictionary\
    \ |>\nI had a similar problem recently (in a different context) and I ended up\
    \ writing a custom method to determine if all elements in a dictionary are null.\n\
    <code>\npublic static bool AllElementsNull(Dictionary<string, object> dict)\n\
    {\n    foreach (var key in dict.Keys)\n    {\n        if (dict[key] == null)\n\
    \            return false;\n    }\n    return true;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=c#,null,tuples,dictionary |>\n<code>\npublic static bool IsAllNull(IDictionary<string,object>\
    \ values)\n{\n    var nonNullCount = values.Where(v => v != null).Count();\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp203x1go1.d(24): Error: semicolon expected, not `if`

    /tmp/tmp203x1go1.d(24): Error: found `!` when expecting `(`

    /tmp/tmp203x1go1.d(24): Error: found `then` when expecting `)`

    /tmp/tmp203x1go1.d(26): Error: semicolon expected, not `in`

    /tmp/tmp203x1go1.d(26): Error: expression expected, not `in`

    /tmp/tmp203x1go1.d(26): Error: found `strKeys` when expecting `;` following `for`
    condition

    /tmp/tmp203x1go1.d(28): Error: found `strKey` when expecting `(`

    /tmp/tmp203x1go1.d(30): Error: found `return` when expecting `)`

    /tmp/tmp203x1go1.d(31): Error: found `}` when expecting `;` following statement

    /tmp/tmp203x1go1.d(33): Error: found `else` without a corresponding `if`, `version`
    or `debug` statement

    /tmp/tmp203x1go1.d(38): Error: found `}` when expecting `;` following `return`
    statement

    /tmp/tmp203x1go1.d(39): Error: found `<` instead of statement

    /tmp/tmp203x1go1.d(51): Error: declaration expected, not `return`

    /tmp/tmp203x1go1.d(52): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-"'
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, val) in dict {\n        if (!typeof(key) is string)\
    \ return false;\n        if (!typeof(val) is string) return false;\n    }\n  \
    \  return true;\n}\n</code>\n<|/ a tags=dictionary,c# |>\n<| a |>\n<code>\npublic\
    \ static bool AreDictionariesEqual(Dictionary<string, string> dict1, Dictionary<string,\
    \ string> dict2)\n{\n    var keysAreEqual = Equals(dict1.Keys, dict2.Keys);\n\
    \    foreach (var item in dict1.Where(kv => !dict2.ContainsKey(kv.Key))) \n  \
    \  {\n        keysAreEqual = false;\n        break;\n    }\n    return keysAreEqual;\n\
    }\n</code>\n<|/ a tags=dictionary,c# dscore=2 |>\n<| c |>\nIf you're using C#\
    \ 7 you can use the built-in `IsEqual` method instead of manually doing this and\
    \ returning a boolean.\n<|/ c |>\n<| c |>\nThis code will misbehave when keys\
    \ are compared with null.\n<|/ c |>\n<| a tags=dictionary,c# |>\nAs this question\
    \ has already been answered, I thought I would add a solution I came up with,\
    \ using LINQ.\n<code>\npublic static bool AreDictionariesEqual(Dictionary<string,\
    \ string> dict1, Dictionary<string, string> dict2)\n{\n    return dict1.Keys.All(k\
    \ => dict2.ContainsKey(k) && dict1[k] == dict2[k]);\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 tags=dictionary,c# |>\nHere is a way I came up with to compare\
    \ two dictionaries, even though it might be inefficient. \n<code>\npublic static\
    \ bool AreDictionariesEqual(Dictionary<string, string> dict1, Dictionary<string,\
    \ string> dict2)\n{\n    foreach(var key1 in dict1.Keys)\n    {\n        bool\
    \ match = false;\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq8fwaerh.d(23): Error: no identifier for declarator `val`

    /tmp/tmpq8fwaerh.d(23): Error: found `)` when expecting `;`

    /tmp/tmpq8fwaerh.d(23): Error: expression expected, not `in`

    /tmp/tmpq8fwaerh.d(23): Error: found `dict` when expecting `)`

    /tmp/tmpq8fwaerh.d(29): Error: declaration expected, not `<`

    /tmp/tmpq8fwaerh.d(36): Error: declaration expected, not `foreach`

    /tmp/tmpq8fwaerh.d(39): Error: declaration expected, not `break`

    /tmp/tmpq8fwaerh.d(40): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq8fwaerh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(var k in dict) \n        if(!(is_string(k) || is_string(tostring(k))))\n\
    \            return false;\n    return true;\n}\n</code>\n<|/ a |>\n<| a dscore=1\
    \ tags=c# |>\nThis seems to work for me and is less verbose than some of the other\
    \ solutions:\n<code>\nprivate bool IsDictEmpty(Dictionary<string, object> dict)\n\
    {\n    return dict.Count < 1;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n\
    using System.Collections.Generic;\n...\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkpuww5n2.d(23): Error: found `in` when expecting `;`

    /tmp/tmpkpuww5n2.d(28): Error: declaration expected, not `<`

    /tmp/tmpkpuww5n2.d(36): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkpuww5n2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict do\n       if  not (v is! string)  or \
    \ \n          not (str.toLower(k) == v) or\n          not (str.toUpper(k) == v)\n\
    \           then \n           return false;\n    return true;\n}\n</code>\n<|/\
    \ a tags=d,language-agnostic |>\n<| c |>\nI believe that the OP wants to return\
    \ `false` if the dictionary is empty, or not only containing strings (i.e. no\
    \ number or other data types)\n<|/ c |>\n<| c |>\nYou can't use `.nullable` on\
    \ a `string` array.\n<|/ c |>\n<| c |>\nI believe that \"string\" array means\
    \ null terminated array of chars (array of strings).\n<|/ c |>\n<| c |>\nI thought\
    \ it was a pointer to a std.array.\n<|/ c |>\n<| c |>\nI meant a string array.\
    \ Sorry if that wasn't clear.\n<|/ c |>\n<| a tags=d,language-agnostic |>\nI wrote\
    \ a simple function in C#:\n<code>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxvhkq5w9.d(23): Error: no identifier for declarator `v`

    /tmp/tmpxvhkq5w9.d(23): Error: found `)` when expecting `;`

    /tmp/tmpxvhkq5w9.d(23): Error: expression expected, not `in`

    /tmp/tmpxvhkq5w9.d(23): Error: found `dict` when expecting `)`

    /tmp/tmpxvhkq5w9.d(24): Error: found `not` when expecting `(`

    /tmp/tmpxvhkq5w9.d(24): Error: found `or` when expecting `)`

    /tmp/tmpxvhkq5w9.d(25): Error: found `or` when expecting `;` following statement

    /tmp/tmpxvhkq5w9.d(26): Error: found `not` when expecting `while`

    /tmp/tmpxvhkq5w9.d(27): Error: terminating `;` required after do-while statement

    /tmp/tmpxvhkq5w9.d(28): Error: found `return` when expecting `;` following statement

    /tmp/tmpxvhkq5w9.d(31): Error: declaration expected, not `<`

    /tmp/tmpxvhkq5w9.d(37): Error: unterminated character constant

    /tmp/tmpxvhkq5w9.d(46): Error: unterminated character constant

    /tmp/tmpxvhkq5w9.d(55): Error: declaration expected, not `assert`

    /tmp/tmpxvhkq5w9.d(56): Error: declaration expected, not `assert`

    /tmp/tmpxvhkq5w9.d(57'
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    \n    for (auto k : dict)\n    {\n        //assert (k.length()\
    \ == 2); // TODO\n        auto l = k.toLowerCase();\n        if (!std::equal(l.begin(),\
    \ l.end(), k.begin(), k.end()))\n            return false;\n    }\n    return\
    \ true;\n}\n\"\"\")\nunittest\n{\n    alias candidate = check_dict_case;\n\n \
    \   assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkkkkw5zb.d(24): Error: no identifier for declarator `k`

    /tmp/tmpkkkkw5zb.d(24): Error: expression expected, not `:`

    /tmp/tmpkkkkw5zb.d(24): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmpkkkkw5zb.d(28): Error: found `:` when expecting `)`

    /tmp/tmpkkkkw5zb.d(28): Error: found `:` instead of statement

    /tmp/tmpkkkkw5zb.d(33): Error: declaration expected, not `""`

    /tmp/tmpkkkkw5zb.d(43): Error: unterminated string constant starting at /tmp/tmpkkkkw5zb.d(43)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkkkkw5zb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool success = true;\n    foreach(auto it, dict)\n        success\
    \ = success && islower(it) || isupper(it);\n    return success;\n}\n</code>\n\
    <|/ a |>\n<| c |>\n`check_dict_case(\"A\") == \"a\"` will fail (`is_lower` returns\
    \ true if the char is not a letter, which is probably not what you want).\n<|/\
    \ c |>\n<| c |>\nI agree. Fixed the typo now\n<|/ c |>\n<| c |>\nI appreciate\
    \ the effort to explain the code and give an example. While this solution does\
    \ solve the problem at hand, I'm afraid that someone might come up with a solution\
    \ that is more elegant and more scalable. Also, I guess you missed the fact that\
    \ this solution requires C++17. Thank you anyways!\n<|/ c |>\n<| a tags=c++,std,c++17\
    \ |>\nYou can use std::all_of() with a lambda expression:\n<code>\n#include <algorithm>\n\
    #include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoafevpu9.d(24): Error: basic type expected, not `auto`

    /tmp/tmpoafevpu9.d(24): Error: no identifier for declarator `_error_`

    /tmp/tmpoafevpu9.d(24): Error: found `auto` when expecting `;`

    /tmp/tmpoafevpu9.d(28): Error: declaration expected, not `<`

    /tmp/tmpoafevpu9.d(37): Error: unterminated character constant

    /tmp/tmpoafevpu9.d(51): Error: declaration expected, not `assert`

    /tmp/tmpoafevpu9.d(52): Error: declaration expected, not `assert`

    /tmp/tmpoafevpu9.d(53): Error: declaration expected, not `assert`

    /tmp/tmpoafevpu9.d(54): Error: declaration expected, not `assert`

    /tmp/tmpoafevpu9.d(55): Error: declaration expected, not `assert`

    /tmp/tmpoafevpu9.d(56): Error: declaration expected, not `assert`

    /tmp/tmpoafevpu9.d(57): Error: declaration expected, not `assert`

    /tmp/tmpoafevpu9.d(58): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoafevpu9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null || !dict.isEmpty)\n        return false; \n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpidh464ms.d(25): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpidh464ms.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tif(dict.isNull) \n\t\treturn false;\n\tif(dict.type == \"dict\"\
    ){\n\t\tfor(string key in dict.keys){\n\t\t\tif(key.lower() == key){\n\t\t\t\t\
    return false;\n\t\t\t}else if(key.upper() == key){\n\t\t\t\treturn false;\n\t\t\
    \t}\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_grdl7hx.d(26): Error: semicolon expected, not `in`

    /tmp/tmp_grdl7hx.d(26): Error: expression expected, not `in`

    /tmp/tmp_grdl7hx.d(26): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_grdl7hx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  if (dict.empty()) return true;\n  auto first = dict.keys().begin();\n\
    \  auto last = dict.keys().end();\n  for(auto it = first != last ; ++it )\n  {\n\
    \    auto key = *it;\n    \n    auto lower = string::to_lower(key);\n    auto\
    \ upper = string::to_upper(key);\n    \n    if (lower != key) \n    {\n      return\
    \ false;\n    }\n    if (upper != key)\n    {\n      return false;\n    }\n  }\n\
    \  return true;\n}\n</code>\n<|/ a tags=associative-array,std,c++,containers,c++11\
    \ |>\n<| a tags=associative-array,std,c++,containers,c++11 |>\nFor what it's worth,\
    \ I wrote a small library that can compare C++ map containers with STL containers:\n\
    <code>\n#include <map>\n#include <iostream>\n#include <string>\n#include <list>\n\
    #include <algorithm>\n#include <iterator>\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8mh4h_op.d(26): Error: found `)` when expecting `;` following `for`
    condition

    /tmp/tmp8mh4h_op.d(30): Error: semicolon expected following auto declaration,
    not `:`

    /tmp/tmp8mh4h_op.d(30): Error: found `:` instead of statement

    /tmp/tmp8mh4h_op.d(31): Error: semicolon expected following auto declaration,
    not `:`

    /tmp/tmp8mh4h_op.d(31): Error: found `:` instead of statement

    /tmp/tmp8mh4h_op.d(42): Error: found `return` when expecting `)`

    /tmp/tmp8mh4h_op.d(44): Error: declaration expected, not `<`

    /tmp/tmp8mh4h_op.d(47): Error: unterminated character constant

    /tmp/tmp8mh4h_op.d(59): Error: declaration expected, not `assert`

    /tmp/tmp8mh4h_op.d(60): Error: declaration expected, not `assert`

    /tmp/tmp8mh4h_op.d(61): Error: declaration expected, not `assert`

    /tmp/tmp8mh4h_op.d(62): Error: declaration expected, not `assert`

    /tmp/tmp8mh4h_op.d(63): Error: declaration expected, not `assert`

    /tmp/tmp8mh4h_op.d(64): Error: declaration expected, not `assert`

    /tmp/tmp8mh4h_op.d(65): Error: declaration expected, not '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict {\n        if(isNull(k)) {\n          \
    \  return false;\n        }\n        \n        if(k.toCString().isUpper()) {\n\
    \            return false;\n        }\n        \n        if(!k.toCString().isLower())\
    \ {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprz7rxfcl.d(23): Error: no identifier for declarator `v`

    /tmp/tmprz7rxfcl.d(23): Error: found `)` when expecting `;`

    /tmp/tmprz7rxfcl.d(23): Error: expression expected, not `in`

    /tmp/tmprz7rxfcl.d(23): Error: found `dict` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprz7rxfcl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    forall(dict, key -> key.key.type.isString() || key.key.type.isUppercaseString());\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpijagy_xi.d(23): Error: use `.` for member lookup, not `->`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpijagy_xi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = false;\n    if (dict)\n    {\n        for (auto\
    \ it : dict)\n        {\n            string key = it.first;\n            if (is_string(key))\n\
    \            {\n                if (!is_string(it.second))\n                {\n\
    \                    result = false;\n                    break;\n           \
    \     }\n            }\n            else\n            {\n                if (is_string(it.second))\n\
    \                {\n                    result = false;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjxyd2xmp.d(26): Error: no identifier for declarator `it`

    /tmp/tmpjxyd2xmp.d(26): Error: expression expected, not `:`

    /tmp/tmpjxyd2xmp.d(26): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjxyd2xmp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, val) in dict \n    {\n        if (std.typecons.isUpper(std.string.upcase(k)))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5qf8i35j.d(23): Error: no identifier for declarator `val`

    /tmp/tmp5qf8i35j.d(23): Error: found `)` when expecting `;`

    /tmp/tmp5qf8i35j.d(23): Error: expression expected, not `in`

    /tmp/tmp5qf8i35j.d(23): Error: found `dict` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5qf8i35j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    assert(dict != null);\n    return !dict.hasKey(\"Name\") && !dict.hasKey(8L);\n\
    }\n\"\"\")\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp35igh666.d(26): Error: declaration expected, not `""`

    /tmp/tmp35igh666.d(36): Error: unterminated string constant starting at /tmp/tmp35igh666.d(36)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp35igh666.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(string str in dict) {\n        if(str.isLowercase())\
    \ return true;\n        if(str.isUppercase()) return true;\n    }\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnkzbv44w.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnkzbv44w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull)\n        return false; \n    \n    auto &dict\
    \ = dict.get_ref();\n    for (auto &&v : dict) {\n        if (!(v.first.type.isString()\
    \ || v.first.type.isEnum()))\n            return false; \n    } \n    return true;\
    \ \n}\n''';\n$code = '#include \"std.hpp\"';\n$code .= '\n/*\nunittest\n{\n  \
    \  alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3sn2emr8.d(26): Error: basic type expected, not `&`

    /tmp/tmp3sn2emr8.d(26): Error: no identifier for declarator `_error_`

    /tmp/tmp3sn2emr8.d(26): Error: found `&` instead of statement

    /tmp/tmp3sn2emr8.d(27): Error: basic type expected, not `&&`

    /tmp/tmp3sn2emr8.d(27): Error: no identifier for declarator `_error_`

    /tmp/tmp3sn2emr8.d(27): Error: expression expected, not `&&`

    /tmp/tmp3sn2emr8.d(27): Error: found `v` when expecting `;` following `for` condition

    /tmp/tmp3sn2emr8.d(27): Error: expression expected, not `:`

    /tmp/tmp3sn2emr8.d(27): Error: found `dict` when expecting `)`

    /tmp/tmp3sn2emr8.d(27): Error: found `)` instead of statement

    /tmp/tmp3sn2emr8.d(31): Error: declaration expected, not `return`

    /tmp/tmp3sn2emr8.d(32): Error: unrecognized declaration

    /tmp/tmp3sn2emr8.d(33): Error: unterminated character constant

    /tmp/tmp3sn2emr8.d(33): Error: unterminated character constant

    /tmp/tmp3sn2emr8.d(34): Error: unterminated character constant

    /tmp/tmp3sn2emr8.d(34): Error: unterminated character cons'
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tif(dict.empty())\n\t\treturn true;\n\tauto keys = dict.keys;\n\t\
    for(auto it = keys.begin(); it != keys.end(); ++it) \n\t{\n\t\tauto &key = *it;\n\
    \t\tauto &value = dict[key];\n\t\tif(key.length() != value.len) \n\t\t\treturn\
    \ false;\n\t\tauto c = tolower(key[0]);\n\t\tif(c >= 'a' && c <= 'z') \n\t\t\t\
    continue;\n\t\telse \n\t\t\treturn false;\n\t}\n\treturn true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj8qf168q.d(28): Error: basic type expected, not `&`

    /tmp/tmpj8qf168q.d(28): Error: no identifier for declarator `_error_`

    /tmp/tmpj8qf168q.d(28): Error: found `&` instead of statement

    /tmp/tmpj8qf168q.d(29): Error: basic type expected, not `&`

    /tmp/tmpj8qf168q.d(29): Error: no identifier for declarator `_error_`

    /tmp/tmpj8qf168q.d(29): Error: found `&` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj8qf168q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull) return true;\n    for (auto v : dict)\n    \
    \    if (v.key.isLower()) continue;\n        else if (v.key.isUpper()) continue;\n\
    \        else return false;\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5n5vepet.d(24): Error: no identifier for declarator `v`

    /tmp/tmp5n5vepet.d(24): Error: expression expected, not `:`

    /tmp/tmp5n5vepet.d(24): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5n5vepet.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = true;\n    for (auto key: string.range(dict.keys))\n\
    \    {\n        string val = dict[key];\n        auto is_upper = string::caseInsensitiveCompare(val,\
    \ key) == 0;\n        auto is_lower = string::caseInsensitiveCompare(key, val)\
    \ == 0;\n        if (!is_upper && !is_lower)\n        {\n            result =\
    \ false;\n            break;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7wjo8w8r.d(24): Error: no identifier for declarator `key`

    /tmp/tmp7wjo8w8r.d(24): Error: expression expected, not `:`

    /tmp/tmp7wjo8w8r.d(24): Error: found `string` when expecting `;` following `for`
    condition

    /tmp/tmp7wjo8w8r.d(27): Error: semicolon expected following auto declaration,
    not `:`

    /tmp/tmp7wjo8w8r.d(27): Error: found `:` instead of statement

    /tmp/tmp7wjo8w8r.d(28): Error: semicolon expected following auto declaration,
    not `:`

    /tmp/tmp7wjo8w8r.d(28): Error: found `:` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7wjo8w8r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto it = dict.begin();\n    if (it == dict.end()) {\n      \
    \  return false;\n    }\n    ++it;\n    for(auto it2 = dict.begin(); it2 != dict.end();\
    \ ++it2) {\n        if (!(Stringify(it->first) == Stringify(it2->first))) {\n\
    \            return false;\n        }\n        ++it2;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps1m6wyip.d(29): Error: use `.` for member lookup, not `->`

    /tmp/tmps1m6wyip.d(29): Error: use `.` for member lookup, not `->`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps1m6wyip.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tbool flag = true;\n\tforeach(i32 i=1, i<len(dict); i++) {\n\t\t\
    flag &= str.islower(dict[tostring(i)])\n\t\tflag &= str.isupper(dict[tostring(i)])\n\
    \t}\n\t\n\treturn flag;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxyl6kn0w.d(24): Error: found `=` when expecting `;`

    /tmp/tmpxyl6kn0w.d(24): Error: found `;` when expecting `)`

    /tmp/tmpxyl6kn0w.d(24): Error: found `)` when expecting `;` following statement

    /tmp/tmpxyl6kn0w.d(26): Error: found `flag` when expecting `;` following statement

    /tmp/tmpxyl6kn0w.d(26): Error: found `&=` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxyl6kn0w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) {\n        if (string) k = std.tolowercase(k);\n\
    \        if (string) k = std.touppercase(k);\n        if (!dict.is(k)) return\
    \ false;\n    }\n    return true;\n}\n</code>\n<|/ a tags=types,d,dmd dscore=2\
    \ |>\n<| a dscore=1 tags=types,d,dmd |>\nI've had a little bit of a play around\
    \ and came up with this that seems to work pretty well:\n<code>\nunittest\n{\n\
    \    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp324lj6v0.d(23): Error: no identifier for declarator `v`

    /tmp/tmp324lj6v0.d(23): Error: found `)` when expecting `;`

    /tmp/tmp324lj6v0.d(26): Error: identifier expected following `.`, not `is`

    /tmp/tmp324lj6v0.d(28): Error: found `return` when expecting `)`

    /tmp/tmp324lj6v0.d(30): Error: declaration expected, not `<`

    /tmp/tmp324lj6v0.d(33): Error: unterminated character constant

    /tmp/tmp324lj6v0.d(39): Error: declaration expected, not `assert`

    /tmp/tmp324lj6v0.d(40): Error: declaration expected, not `assert`

    /tmp/tmp324lj6v0.d(41): Error: declaration expected, not `assert`

    /tmp/tmp324lj6v0.d(42): Error: declaration expected, not `assert`

    /tmp/tmp324lj6v0.d(43): Error: declaration expected, not `assert`

    /tmp/tmp324lj6v0.d(44): Error: declaration expected, not `assert`

    /tmp/tmp324lj6v0.d(45): Error: declaration expected, not `assert`

    /tmp/tmp324lj6v0.d(46): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp324lj6v0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(auto iter: dict)\n    {\n        if (typeof(iter.key) !=\
    \ \"string\" && !(typeof(iter.key) != \"number\" && typeof(iter.key) != \"bool\"\
    ))\n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\n\"\"\"\n)\n</cell>\n<cell>\nfrom nbdev.export import notebook2script; notebook2script()\n\
    </cell>\n<cell>\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0m_tiwg4.d(23): Error: no identifier for declarator `iter`

    /tmp/tmp0m_tiwg4.d(23): Error: expression expected, not `:`

    /tmp/tmp0m_tiwg4.d(23): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmp0m_tiwg4.d(32): Error: declaration expected, not `""`

    /tmp/tmp0m_tiwg4.d(48): Error: unterminated string constant starting at /tmp/tmp0m_tiwg4.d(48)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0m_tiwg4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tif(!dict)\n\t\treturn false;\n\tfor(auto [key, val] : (pair!(string[string],\
    \ string))[]) \n\t{\n\t\tif(key.length() != val.length()) return false;\n\t\t\
    if(key.isUppercase() != val.isUppercase()) return false;\n\t}\n\treturn true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdsd0yqvw.d(25): Error: basic type expected, not `[`

    /tmp/tmpdsd0yqvw.d(25): Error: found `,` when expecting `]`

    /tmp/tmpdsd0yqvw.d(25): Error: semicolon expected, not `]`

    /tmp/tmpdsd0yqvw.d(25): Error: expression expected, not `]`

    /tmp/tmpdsd0yqvw.d(25): Error: found `:` when expecting `;` following `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdsd0yqvw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  // your code goes here\n  int i = 0;\n  bool all_strings = false;\n\
    \  while(i < dict.len) {\n    string key = dict.get(i).getName();\n    string\
    \ lower = tolower((dict.get(i).getName()))\n    bool is_lower = lower.compare(key);\n\
    \    if(is_lower) {\n      all_strings = true;\n    }\n    else {\n      all_strings\
    \ = false;\n      break;\n    }\n    i = i+1;\n  }\n  return all_strings;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nI haven't tried it yet but that's a pretty\
    \ good idea. Thanks!\n<|/ c |>\n<| c |>\nCan you tell me how this works `tolower((dict.get(i).getName()))`\n\
    <|/ c |>\n<| c |>\nHi Chris, sorry for my ignorance. I'm trying to get my head\
    \ around this. What is `tolower` doing?\n<|/ c |>\n<| c |>\n`tolower` is a function\
    \ that will lower case the string. Just like in Python. [Here's the documentation](http://www.cplusplus.com/reference/algorithm/tolower/).\n\
    <|/ c |>\n<| c |>\nOkay, but what does it do when it's applied to the key of the\
    \ dict? What is dict.get(i).getName()?\n<|/ c |>\n<| a tags=std-pair,stdmap,c++,dictionary,stl\
    \ |>\nIf you don't have access to C++20 then you can try this\n<code>\n#include\
    \ <iostream>\n#include <string>\n#include <map>\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpehs_8eum.d(29): Error: semicolon expected, not `bool`

    /tmp/tmpehs_8eum.d(41): Error: declaration expected, not `<`

    /tmp/tmpehs_8eum.d(44): Error: unterminated character constant

    /tmp/tmpehs_8eum.d(44): Error: unterminated character constant

    /tmp/tmpehs_8eum.d(50): Error: unterminated character constant

    /tmp/tmpehs_8eum.d(53): Error: unterminated character constant

    /tmp/tmpehs_8eum.d(56): Error: unterminated character constant

    /tmp/tmpehs_8eum.d(59): Error: unterminated character constant

    /tmp/tmpehs_8eum.d(68): Error: declaration expected, not `assert`

    /tmp/tmpehs_8eum.d(69): Error: declaration expected, not `assert`

    /tmp/tmpehs_8eum.d(70): Error: declaration expected, not `assert`

    /tmp/tmpehs_8eum.d(71): Error: declaration expected, not `assert`

    /tmp/tmpehs_8eum.d(72): Error: declaration expected, not `assert`

    /tmp/tmpehs_8eum.d(73): Error: declaration expected, not `assert`

    /tmp/tmpehs_8eum.d(74): Error: declaration expected, not `assert`

    /tmp/tmpehs_8eum.d(75): Error: unrecognized declaration

    Faile'
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v: dict)\n        if(!is_integer(k) || !is_integer(v)\
    \ || k != v)\n            return false;\n    return true;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=types,haskell,associative-array |>\nThe above solutions don't\
    \ seem to play nicely with Data.Array.\nHere's a solution using Data.Array. Basically,\
    \ we're converting everything to a Data.Array.Array1 with a custom function which\
    \ allows us to perform elementwise equality checks. It's probably more efficient\
    \ than converting to a Data.Array.Array1 via Data.Array.IArray.\n<code>\nimport\
    \ qualified Data.Array.IArray as IArray\nimport qualified Data.Array as Array\n\
    import qualified Data.Array.Unboxed as UA\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnwssotxz.d(23): Error: no identifier for declarator `v`

    /tmp/tmpnwssotxz.d(23): Error: found `:` when expecting `;`

    /tmp/tmpnwssotxz.d(28): Error: declaration expected, not `<`

    /tmp/tmpnwssotxz.d(31): Error: unterminated character constant

    /tmp/tmpnwssotxz.d(32): Error: unterminated character constant

    /tmp/tmpnwssotxz.d(32): Error: unterminated character constant

    /tmp/tmpnwssotxz.d(32): Error: unterminated character constant

    /tmp/tmpnwssotxz.d(41): Error: declaration expected, not `assert`

    /tmp/tmpnwssotxz.d(42): Error: declaration expected, not `assert`

    /tmp/tmpnwssotxz.d(43): Error: declaration expected, not `assert`

    /tmp/tmpnwssotxz.d(44): Error: declaration expected, not `assert`

    /tmp/tmpnwssotxz.d(45): Error: declaration expected, not `assert`

    /tmp/tmpnwssotxz.d(46): Error: declaration expected, not `assert`

    /tmp/tmpnwssotxz.d(47): Error: declaration expected, not `assert`

    /tmp/tmpnwssotxz.d(48): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnwssotxz.d", "-I/t'
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(string key in dict)\n        if(!std.string.lower_case(key)\
    \ || !std.string.upper_case(key))\n            return false;\n    return true;\n\
    }\n</code>\n<|/ a dscore=2 tags=d,types,function |>\n<| a dscore=1 |>\nA function\
    \ that will return true if all keys in an associative array are strings in lower\
    \ case or all keys are strings in upper case, else return false:\n<code>\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl_ib5txl.d(23): Error: found `in` when expecting `;`

    /tmp/tmpl_ib5txl.d(28): Error: declaration expected, not `<`

    /tmp/tmpl_ib5txl.d(37): Error: declaration expected, not `assert`

    /tmp/tmpl_ib5txl.d(38): Error: declaration expected, not `assert`

    /tmp/tmpl_ib5txl.d(39): Error: declaration expected, not `assert`

    /tmp/tmpl_ib5txl.d(40): Error: declaration expected, not `assert`

    /tmp/tmpl_ib5txl.d(41): Error: declaration expected, not `assert`

    /tmp/tmpl_ib5txl.d(42): Error: declaration expected, not `assert`

    /tmp/tmpl_ib5txl.d(43): Error: declaration expected, not `assert`

    /tmp/tmpl_ib5txl.d(44): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl_ib5txl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tif(dict.length == 0)\n\t\treturn false;\n\tfor (auto it : dict)\n\
    \t{\n\t\tif(it.first < \"A\" || it.first > \"Z\")\n\t\t\treturn false;\n\t}\n\t\
    \n\tfor(auto it : dict){\n\t\tif(it.second < \"a\" || it.second > \"z\")\n\t\t\
    \treturn false;\n\t}\n\treturn true;\n}\n\"\"\"\n)\n</cell>\n<text>\nTuple\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbas9dyee.d(25): Error: no identifier for declarator `it`

    /tmp/tmpbas9dyee.d(25): Error: expression expected, not `:`

    /tmp/tmpbas9dyee.d(25): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmpbas9dyee.d(31): Error: no identifier for declarator `it`

    /tmp/tmpbas9dyee.d(31): Error: expression expected, not `:`

    /tmp/tmpbas9dyee.d(31): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmpbas9dyee.d(37): Error: declaration expected, not `""`

    /tmp/tmpbas9dyee.d(51): Error: unterminated string constant starting at /tmp/tmpbas9dyee.d(51)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbas9dyee.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto kv = dict.keyvalues();\n    forall(kv, [&](auto pair){ \n\
    \        auto key = pair.key();\n        if (pair.key().length() == 0){\n    \
    \        error(\"Null keys are not allowed as key names in an associative array.\"\
    );\n        }\n        auto lowercase = make_tuple(string(\"a\"), string(\"A\"\
    ), string(\"b\"), string(\"B\"));\n        auto uppercase = make_tuple(string(\"\
    A\"), string(\"a\"), string(\"B\"), string(\"B\"));\n        if (is_in_tuple(key.toLowerCase(),\
    \ lowercase)){\n            if (is_in_tuple(key.toUpperCase(), uppercase)){\n\
    \                return true;\n            } else {\n                error(\"\
    Key '\" + key + \"' has different case than 'a' and 'A' where it should be either\
    \ 'a' or 'A'.\");\n            }\n        } else {\n            error(\"Key '\"\
    \ + key + \"' is not lowercase or uppercase as 'a' and 'A' where it should be\
    \ either 'a' or 'A'.\");\n        }\n        return false;\n    });\n    return\
    \ false;\n}\n#endif\n#endif\n</code>\n<|/ a |>\n<| a dscore=0 tags=c++,dictionary,std-pair\
    \ |>\nFor C++20 it's pretty easy to create a custom comparator:\n<code>\nstruct\
    \ CustomMap {\n    std::unordered_map<std::string, std::string, std::hash<std::string>,\
    \ std::equal_to<std::string>> m_map;\n};\n</code>\nTo create a comparator:\n<code>\n\
    std::function<bool(std::pair<std::string,std::string>, const CustomMap&)> compareMapKeys\n\
    {\n    using std::swap;\n    return [&](std::pair<std::string, std::string> const\
    \ &left, const CustomMap &right)\n    {\n        auto &key = left.first;\n   \
    \     if (left.first == right.m_map.end())\n        {\n            return false;\n\
    \        }\n        if (right.m_map.find(key) == right.m_map.end())\n        {\n\
    \            return true;\n        }\n        auto &value = right.m_map.find(key);\n\
    \        swap(value, left.second);\n        return true;\n    };\n}\n</code>\n\
    Then you can use this in your code:\n<code>\nstd::unordered_map<std::string, std::string,\
    \ std::hash<std::string>, std::equal_to<std::string>> map;\nCustomMap custom_map;\n\
    </code>\nYou will need to create a map constructor that takes a comparator and\
    \ use it:\n<code>\nCustomMap(CustomMap const &other, std::function<bool(std::pair<std::string,std::string>,\
    \ const CustomMap&)> comparator)\n{\n    std::for_each(other.m_map.begin(), other.m_map.end(),\
    \ [&](std::pair<std::string, std::string> const &pair)\n    {\n        map.\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpenqa7ghq.d(24): Error: expression expected, not `]`

    /tmp/tmpenqa7ghq.d(24): Error: expression expected, not `auto`

    /tmp/tmpenqa7ghq.d(24): Error: found `pair` when expecting `,`

    /tmp/tmpenqa7ghq.d(24): Error: found `{` when expecting `,`

    /tmp/tmpenqa7ghq.d(25): Error: expression expected, not `auto`

    /tmp/tmpenqa7ghq.d(25): Error: found `key` when expecting `,`

    /tmp/tmpenqa7ghq.d(25): Error: expression expected, not `=`

    /tmp/tmpenqa7ghq.d(25): Error: found `pair` when expecting `,`

    /tmp/tmpenqa7ghq.d(25): Error: found `;` when expecting `,`

    /tmp/tmpenqa7ghq.d(26): Error: expression expected, not `if`

    /tmp/tmpenqa7ghq.d(26): Error: found `{` when expecting `,`

    /tmp/tmpenqa7ghq.d(27): Error: found `;` when expecting `,`

    /tmp/tmpenqa7ghq.d(28): Error: expression expected, not `}`

    /tmp/tmpenqa7ghq.d(29): Error: found `auto` when expecting `,`

    /tmp/tmpenqa7ghq.d(29): Error: found `;` when expecting `,`

    /tmp/tmpenqa7ghq.d(30): Error: expression expected, not `auto`

    /tmp/tmpenqa7ghq.d(30): Error: found `upper'
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !is_empty(dict) && all(\n        has_key(dict, k) => k.length\
    \ == 0 || is_lower(k) || is_upper(k), \n        dict\n    );\n}\n/*\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7o4jqdja.d(24): Error: found `=>` when expecting `,`

    /tmp/tmp7o4jqdja.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7o4jqdja.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.containsKey(null) && dict.containsKey(String.toLowerInvariant(null));\n\
    }\n/*\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbki6o1z3.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbki6o1z3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.length == 0) {\n        return false;\n    }\n    for\
    \ each (string key in dict) \n    {\n        if ((key.length < 1) || (key.length\
    \ > 2)) {\n            return false;\n        }\n        if (!((key.length ==\
    \ 1) && (key.isUpper))) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr42ltk5z.d(26): Error: found `each` when expecting `(`

    /tmp/tmpr42ltk5z.d(26): Error: found `in` when expecting `)`

    /tmp/tmpr42ltk5z.d(26): Error: missing `{ ... }` for function literal

    /tmp/tmpr42ltk5z.d(26): Error: found `dict` when expecting `;` following statement

    /tmp/tmpr42ltk5z.d(26): Error: expression expected, not `)`

    /tmp/tmpr42ltk5z.d(27): Error: found `{` when expecting `;` following `for` condition

    /tmp/tmpr42ltk5z.d(28): Error: expression expected, not `if`

    /tmp/tmpr42ltk5z.d(28): Error: found `{` when expecting `)`

    /tmp/tmpr42ltk5z.d(31): Error: declaration expected, not `if`

    /tmp/tmpr42ltk5z.d(33): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr42ltk5z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict.IsNull)\n    {\n        return true;\n    }\n    \n \
    \   foreach(key in dict.Keys)\n    {\n        string lower = tolower(key);\n \
    \       string upper = toupper(key);\n        \n        if(lower != upper && lower\
    \ != key)\n        {\n            return false;\n        }\n    }\n    \n    return\
    \ true;\n}\n</code>\n<|/ a dscore=4 tags=c++,generics,d |>\n<| a dscore=2 tags=c++,generics,d\
    \ |>\nAnother approach is using std.algorithm package as follows:\n<code>\nimport\
    \ std.algorithm;\nimport std.array;\nimport std.conv;\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjlez0agz.d(28): Error: no identifier for declarator `key`

    /tmp/tmpjlez0agz.d(28): Error: found `in` when expecting `;`

    /tmp/tmpjlez0agz.d(41): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjlez0agz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tauto itr = dict.dict.begin();\n\tbool result = true;\n\tfor (auto\
    \ itr2 = dict.dict.begin(); itr != dict.dict.end(); ++itr, ++itr2) {\n\t\tstring\
    \ key = (string) *itr;\n\t\tstring val = (string) *itr2;\n\t\tif (key.isupper())\
    \ {\n\t\t\tif (!val.compare(val.to_lower())) {\n\t\t\t\tresult = false;\n\t\t\t\
    \tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!val.compare(val.to_upper())) {\n\t\
    \t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzc_g2o9m.d(23): Error: no property `dict` for type `Nullable!(string[string])`

    /tmp/tmpzc_g2o9m.d(25): Error: no property `dict` for type `Nullable!(string[string])`

    /tmp/tmpzc_g2o9m.d(25): Error: no property `dict` for type `Nullable!(string[string])`

    /tmp/tmpzc_g2o9m.d(28): Error: no property `isupper` for type `string`

    /tmp/tmpzc_g2o9m.d(29): Error: no property `compare` for type `string`

    /tmp/tmpzc_g2o9m.d(34): Error: no property `compare` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzc_g2o9m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  bool result = true;\n  for (auto iter: dict)\n    if (!(iter.first.isUpperCase\
    \ || iter.first.isLowerCase || iter.first.isDigit))\n      result = false;\n \
    \ return result;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n \
    \   assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp22l7ozjs.d(24): Error: no identifier for declarator `iter`

    /tmp/tmp22l7ozjs.d(24): Error: expression expected, not `:`

    /tmp/tmp22l7ozjs.d(24): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp22l7ozjs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(string key in dict)\n    {\n        if(!dict.isNull(key))\n\
    \        {\n            if(!isString(key) || !isLowerCase(key) || !isUpperCase(key))\n\
    \                return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpie2cvvqn.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpie2cvvqn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null || dict.size < 1) return false;\n    for (auto\
    \ it = dict.begin(); it != dict.end(); it++) {\n        if (it.key().length !=\
    \ it.value().length) return false;\n        char ch1 = it.key()[0];\n        char\
    \ ch2 = it.value()[0]\n        if (ch1 != ch2) return false;\n    }\n    return\
    \ true;\n}\n</code>\n<|/ a |>\n<| a tags=c++,stl,c++17,std,dictionary |>\nFor\
    \ a C++17 solution using std::map and std::unordered_map, the following should\
    \ work:\n<code>\n#include <cassert>\n#include <unordered_map>\n#include <algorithm>\n\
    #include <vector>\nunittest\n{\n    alias candidate = check_dict_case;\n\n   \
    \ assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4eeumtsb.d(28): Error: semicolon expected, not `if`

    /tmp/tmp4eeumtsb.d(32): Error: declaration expected, not `<`

    /tmp/tmp4eeumtsb.d(45): Error: declaration expected, not `assert`

    /tmp/tmp4eeumtsb.d(46): Error: declaration expected, not `assert`

    /tmp/tmp4eeumtsb.d(47): Error: declaration expected, not `assert`

    /tmp/tmp4eeumtsb.d(48): Error: declaration expected, not `assert`

    /tmp/tmp4eeumtsb.d(49): Error: declaration expected, not `assert`

    /tmp/tmp4eeumtsb.d(50): Error: declaration expected, not `assert`

    /tmp/tmp4eeumtsb.d(51): Error: declaration expected, not `assert`

    /tmp/tmp4eeumtsb.d(52): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4eeumtsb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(key, value) in dict \n    \n    if (\n        key.isupper()\
    \ == false && \n        \n        key.islower() == false &&\n        \n      \
    \  value.isupper() == false &&\n        \n        value.islower() == false)\n\
    \    {\n        return false;\n    }\n    \n    return true;\n}\nunittest\n{\n\
    \    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu42pux4f.d(23): Error: no identifier for declarator `value`

    /tmp/tmpu42pux4f.d(23): Error: found `)` when expecting `;`

    /tmp/tmpu42pux4f.d(23): Error: expression expected, not `in`

    /tmp/tmpu42pux4f.d(23): Error: found `dict` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu42pux4f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null || dict.isNull) return false;\n    foreach (key,\
    \ value) {\n        if (value instanceof string) {\n            if (value.toLowerCase()\
    \ !== value.toUpperCase()) return false;\n        } else if (value instanceof\
    \ long) {\n            if (value.toNumber() != value.toNumber()) return false;\n\
    \        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpelz7yk9i.d(24): Error: no identifier for declarator `value`

    /tmp/tmpelz7yk9i.d(24): Error: found `)` when expecting `;`

    /tmp/tmpelz7yk9i.d(25): Error: found `instanceof` when expecting `)`

    /tmp/tmpelz7yk9i.d(25): Error: found `)` when expecting `;` following statement

    /tmp/tmpelz7yk9i.d(26): Error: expression expected, not `=`

    /tmp/tmpelz7yk9i.d(26): Error: found `value` when expecting `)`

    /tmp/tmpelz7yk9i.d(26): Error: found `)` when expecting `;` following statement

    /tmp/tmpelz7yk9i.d(27): Error: found `else` without a corresponding `if`, `version`
    or `debug` statement

    /tmp/tmpelz7yk9i.d(30): Error: found `}` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpelz7yk9i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.length == 0) {\n        return false;\n    }\n    var\
    \ keyset = KeySet.create(dict);\n    foreach (var key in keyset) {\n        if\
    \ (keyset[key] == null) continue;\n        if (keyset[key].isUppercase) {\n  \
    \          return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n\
    \    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfa9tllk_.d(27): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfa9tllk_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict == null)\n    {\n        return false;\n    }\n    for(string\
    \ key in dict)\n    {\n        if(key.caseInsensitive != \"true\")\n        {\n\
    \            return false;\n        }\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpav91cpqx.d(27): Error: semicolon expected, not `in`

    /tmp/tmpav91cpqx.d(27): Error: expression expected, not `in`

    /tmp/tmpav91cpqx.d(27): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpav91cpqx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return dict.hasKeys()\n        && !std::all_of(dict.keys(), [](const\
    \ string &key){return !key.empty(); });\n}\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptuz0gwm6.d(24): Error: found `:` when expecting `;` following `return`
    statement

    /tmp/tmptuz0gwm6.d(24): Error: found `:` instead of statement

    /tmp/tmptuz0gwm6.d(24): Error: declaration expected, not `)`

    /tmp/tmptuz0gwm6.d(25): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptuz0gwm6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool allKeysAreLowercaseOrUppercase = true;\n    \n    for (auto\
    \ kv : dict) {\n        if (!is_string(vk)) {\n            allKeysAreLowercaseOrUppercase\
    \ = false;\n            break;\n        }\n    }\n    \n    return allKeysAreLowercaseOrUppercase;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyde8mexb.d(25): Error: no identifier for declarator `kv`

    /tmp/tmpyde8mexb.d(25): Error: expression expected, not `:`

    /tmp/tmpyde8mexb.d(25): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyde8mexb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) in dict \n        if (typeof(k) <> 'string' ||\
    \ (typeof(v) <> 'string' && v.isNull)) \n            return false;\n    return\
    \ true;\n}\n/*\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8s_m6jb9.d(23): Error: no identifier for declarator `v`

    /tmp/tmp8s_m6jb9.d(23): Error: found `)` when expecting `;`

    /tmp/tmp8s_m6jb9.d(23): Error: expression expected, not `in`

    /tmp/tmp8s_m6jb9.d(23): Error: found `dict` when expecting `)`

    /tmp/tmp8s_m6jb9.d(24): Error: expression expected, not `>`

    /tmp/tmp8s_m6jb9.d(24): Error: unterminated character constant

    /tmp/tmp8s_m6jb9.d(24): Error: found `63U` when expecting `)`

    /tmp/tmp8s_m6jb9.d(24): Error: unterminated character constant

    /tmp/tmp8s_m6jb9.d(24): Error: found `63U` when expecting `;` following statement

    /tmp/tmp8s_m6jb9.d(24): Error: found `||` instead of statement

    /tmp/tmp8s_m6jb9.d(24): Error: unterminated character constant

    /tmp/tmp8s_m6jb9.d(24): Error: unterminated character constant

    /tmp/tmp8s_m6jb9.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8s_m6jb9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict != null)\n    {\n        for (auto i : dict)\n     \
    \   {\n            if (std.typecons.isString(i.key) || std.typecons.isString(i.value.key))\n\
    \            {\n                continue;\n            }\n            else\n \
    \           {\n                return false;\n            }\n        }\n     \
    \   return true;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5n7qvpik.d(25): Error: no identifier for declarator `i`

    /tmp/tmp5n7qvpik.d(25): Error: expression expected, not `:`

    /tmp/tmp5n7qvpik.d(25): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5n7qvpik.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull)\n    {\n        return true;\n    }\n    \n\
    \    foreach(string k in dict)\n    {\n        if (!k.isLower)\n        {\n  \
    \          return false;\n        }\n    }\n    \n    foreach(string k in dict)\n\
    \    {\n        if (!k.isUpper)\n        {\n            return false;\n      \
    \  }\n    }\n    \n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprcpo6mbm.d(28): Error: found `in` when expecting `;`

    /tmp/tmprcpo6mbm.d(36): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprcpo6mbm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict._dictionary) {\n        if (dict._dictionary.isEmpty)\n\
    \            return true;\n        var dict = dict._dictionary;\n        for (KeyValuePair!(string,string)\
    \ item in dict)\n            if (!item.key.isLowerCase && !item.key.isUpperCase\
    \ && !item.key.isDigit)\n                return false;\n        return true;\n\
    \    }\n    return false;\n}\n</code>\n<|/ a tags=swift,dictionary |>\n<| a dscore=1\
    \ |>\nHere is a solution that uses Swift's type inference and removes casting:\n\
    <code>\nimport Foundation\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsi0nxi0i.d(27): Error: semicolon expected, not `in`

    /tmp/tmpsi0nxi0i.d(27): Error: expression expected, not `in`

    /tmp/tmpsi0nxi0i.d(27): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmpsi0nxi0i.d(34): Error: declaration expected, not `<`

    /tmp/tmpsi0nxi0i.d(37): Error: unterminated character constant

    /tmp/tmpsi0nxi0i.d(44): Error: declaration expected, not `assert`

    /tmp/tmpsi0nxi0i.d(45): Error: declaration expected, not `assert`

    /tmp/tmpsi0nxi0i.d(46): Error: declaration expected, not `assert`

    /tmp/tmpsi0nxi0i.d(47): Error: declaration expected, not `assert`

    /tmp/tmpsi0nxi0i.d(48): Error: declaration expected, not `assert`

    /tmp/tmpsi0nxi0i.d(49): Error: declaration expected, not `assert`

    /tmp/tmpsi0nxi0i.d(50): Error: declaration expected, not `assert`

    /tmp/tmpsi0nxi0i.d(51): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsi0nxi0i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    // TODO: implement\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0o7cnz11.d(21): Error: function `tmp0o7cnz11.check_dict_case` has
    no `return` statement, but is expected to return a value of type `bool`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0o7cnz11.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(const auto &[k, v] : dict) \n        if(k.length() <= 1 ||\
    \ k.length() > 1 && k[0] == tolower(k[1]))\n            return false;\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6gufrlv1.d(23): Error: basic type expected, not `&`

    /tmp/tmp6gufrlv1.d(23): Error: no identifier for declarator `_error_`

    /tmp/tmp6gufrlv1.d(23): Error: found `:` when expecting `;` following `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6gufrlv1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  if (dict == null) return false;\n  return all(k in dict | v in\
    \ dict | KeyValue(k, v) in dict);\n}\n\"\"\"\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4zwe31fv.d(24): Error: `k in dict` must be parenthesized when next
    to operator `|`

    /tmp/tmp4zwe31fv.d(24): Error: `v in dict` must be parenthesized when next to
    operator `|`

    /tmp/tmp4zwe31fv.d(24): Error: `KeyValue(k, v) in dict` must be parenthesized
    when next to operator `|`

    /tmp/tmp4zwe31fv.d(26): Error: declaration expected, not `""`

    /tmp/tmp4zwe31fv.d(36): Error: unterminated string constant starting at /tmp/tmp4zwe31fv.d(36)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4zwe31fv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isNull)\n        return false\n    foreach (key in dict)\
    \ {\n        if (!(key is string) || !key.to_lowercase(Locale::en).startsWith(key.to_lowercase(Locale::en).toLowerCase(),\
    \ Locale::en))\n            return false\n    }\n    return true\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsqtmw4lb.d(25): Error: found `foreach` when expecting `;` following
    `return` statement

    /tmp/tmpsqtmw4lb.d(25): Error: found `in` when expecting `)`

    /tmp/tmpsqtmw4lb.d(25): Error: missing `{ ... }` for function literal

    /tmp/tmpsqtmw4lb.d(25): Error: found `dict` when expecting `;` following statement

    /tmp/tmpsqtmw4lb.d(25): Error: found `)` instead of statement

    /tmp/tmpsqtmw4lb.d(29): Error: declaration expected, not `return`

    /tmp/tmpsqtmw4lb.d(35): Error: declaration expected, not `assert`

    /tmp/tmpsqtmw4lb.d(36): Error: declaration expected, not `assert`

    /tmp/tmpsqtmw4lb.d(37): Error: declaration expected, not `assert`

    /tmp/tmpsqtmw4lb.d(38): Error: declaration expected, not `assert`

    /tmp/tmpsqtmw4lb.d(39): Error: declaration expected, not `assert`

    /tmp/tmpsqtmw4lb.d(40): Error: declaration expected, not `assert`

    /tmp/tmpsqtmw4lb.d(41): Error: declaration expected, not `assert`

    /tmp/tmpsqtmw4lb.d(42): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsqtmw4lb.d", "-I/t'
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int len = dict.len();\n    for(int i = 0; i < len; ++i) {\n \
    \       string key = dict[i].key();\n        if(!islower(key) && !isupper(key))\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a tags=d dscore=3 |>\n<| a |>\nThis can be done with pure D2:\n<code>\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi30siy2c.d(32): Error: declaration expected, not `<`

    /tmp/tmpi30siy2c.d(41): Error: declaration expected, not `assert`

    /tmp/tmpi30siy2c.d(42): Error: declaration expected, not `assert`

    /tmp/tmpi30siy2c.d(43): Error: declaration expected, not `assert`

    /tmp/tmpi30siy2c.d(44): Error: declaration expected, not `assert`

    /tmp/tmpi30siy2c.d(45): Error: declaration expected, not `assert`

    /tmp/tmpi30siy2c.d(46): Error: declaration expected, not `assert`

    /tmp/tmpi30siy2c.d(47): Error: declaration expected, not `assert`

    /tmp/tmpi30siy2c.d(48): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi30siy2c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool isAllLower=true;\n    bool isAllUpper=true;\n    for (Nullable!(string[string]\
    \ key : dict)\n    {\n        if (key.tostring() !=  key.lowercase())\n      \
    \      isAllLower = false;\n        if (key.tostring() !=  key.uppercase())\n\
    \            isAllUpper = false;\n    }\n    return (isAllLower && isAllUpper);\n\
    }\n</code>\n<|/ a tags=functional-programming,dictionary,dart dscore=1 |>\n<|\
    \ a dscore=0 |>\nIn addition to the previous answers, here's a more generic approach,\
    \ using generic constraints:\n<code>\nimport 'package:collection/collection.dart';\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkiqkncsb.d(25): Error: found `key` when expecting `)` following
    template argument list

    /tmp/tmpkiqkncsb.d(25): Error: found `:` when expecting `;` following statement

    /tmp/tmpkiqkncsb.d(25): Error: found `)` when expecting `;` following `for` condition

    /tmp/tmpkiqkncsb.d(32): Error: found `return` when expecting `)`

    /tmp/tmpkiqkncsb.d(34): Error: declaration expected, not `<`

    /tmp/tmpkiqkncsb.d(37): Error: unterminated character constant

    /tmp/tmpkiqkncsb.d(39): Error: unterminated character constant

    /tmp/tmpkiqkncsb.d(39): Error: unterminated character constant

    /tmp/tmpkiqkncsb.d(44): Error: declaration expected, not `assert`

    /tmp/tmpkiqkncsb.d(45): Error: declaration expected, not `assert`

    /tmp/tmpkiqkncsb.d(46): Error: declaration expected, not `assert`

    /tmp/tmpkiqkncsb.d(47): Error: declaration expected, not `assert`

    /tmp/tmpkiqkncsb.d(48): Error: declaration expected, not `assert`

    /tmp/tmpkiqkncsb.d(49): Error: declaration expected, not `assert`

    /tmp/tmpkiqkncsb.d(50): Error: declaration expected,'
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    forall(dict, k => {\n        return typeof(k) == string && (k\
    \ == k.toLowerCase() || k == k.toUpperCase()); \n    });\n}\nunittest\n{\n   \
    \ alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5v8wygiq.d(23): Error: undefined identifier `forall`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5v8wygiq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(dict.IsEmpty()) return true; // empty dict\n    if(!dict.IsValueSet())\
    \ return false; // non-nullable dict\n    foreach (key, value) in dict \n    {\n\
    \        if((value?.size() == 0L) && \n            !(tolower(key) == key || toupper(key)\
    \ == key)) return false;\n    }\n    return true;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=0 |>\nThe easiest way to do this is to define a function which\
    \ returns a bool indicating if a string is a valid name for a variable:\n<code>\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqzz77k5v.d(25): Error: no identifier for declarator `value`

    /tmp/tmpqzz77k5v.d(25): Error: found `)` when expecting `;`

    /tmp/tmpqzz77k5v.d(25): Error: expression expected, not `in`

    /tmp/tmpqzz77k5v.d(25): Error: found `dict` when expecting `)`

    /tmp/tmpqzz77k5v.d(27): Error: found `)` when expecting `:`

    /tmp/tmpqzz77k5v.d(27): Error: expression expected, not `&&`

    /tmp/tmpqzz77k5v.d(27): Error: found `!` when expecting `)`

    /tmp/tmpqzz77k5v.d(32): Error: declaration expected, not `<`

    /tmp/tmpqzz77k5v.d(41): Error: declaration expected, not `assert`

    /tmp/tmpqzz77k5v.d(42): Error: declaration expected, not `assert`

    /tmp/tmpqzz77k5v.d(43): Error: declaration expected, not `assert`

    /tmp/tmpqzz77k5v.d(44): Error: declaration expected, not `assert`

    /tmp/tmpqzz77k5v.d(45): Error: declaration expected, not `assert`

    /tmp/tmpqzz77k5v.d(46): Error: declaration expected, not `assert`

    /tmp/tmpqzz77k5v.d(47): Error: declaration expected, not `assert`

    /tmp/tmpqzz77k5v.d(48): Error: unrecognized declaration

    Failed: ["dm'
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(const auto &pair: dict)\n    {\n        const auto &key\
    \ = pair.key();\n        const auto &value = pair.value();\n        if(!is_string(key)\
    \ || !is_string(value))\n        {\n            return false;\n        }\n   \
    \ }\n    return true;\n}\n'''\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0dn0tu55.d(23): Error: basic type expected, not `auto`

    /tmp/tmp0dn0tu55.d(23): Error: no identifier for declarator `_error_`

    /tmp/tmp0dn0tu55.d(23): Error: found `auto` when expecting `;`

    /tmp/tmp0dn0tu55.d(23): Error: found `:` when expecting `)`

    /tmp/tmp0dn0tu55.d(23): Error: found `)` when expecting `;` following statement

    /tmp/tmp0dn0tu55.d(25): Error: basic type expected, not `&`

    /tmp/tmp0dn0tu55.d(25): Error: no identifier for declarator `_error_`

    /tmp/tmp0dn0tu55.d(25): Error: found `&` instead of statement

    /tmp/tmp0dn0tu55.d(26): Error: basic type expected, not `&`

    /tmp/tmp0dn0tu55.d(26): Error: no identifier for declarator `_error_`

    /tmp/tmp0dn0tu55.d(26): Error: found `&` instead of statement

    /tmp/tmp0dn0tu55.d(34): Error: unterminated character constant

    /tmp/tmp0dn0tu55.d(34): Error: declaration expected, not `63U`

    /tmp/tmp0dn0tu55.d(34): Error: unterminated character constant

    /tmp/tmp0dn0tu55.d(39): Error: declaration expected, not `assert`

    /tmp/tmp0dn0tu55.d(40): Error: declaration expect'
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.IsNull()) return true; \n    for (int i = 0; i < dict.NumItems();\
    \ i++)\n    {\n        if (dict[i].IsString() && dict[i].AsString().isLower())\
    \ return true;\n        if (dict[i].IsString() && dict[i].AsString().isUpper())\
    \ return true;\n    }\n    return false;\n}\n''';\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpma3t8vya.d(31): Error: unterminated character constant

    /tmp/tmpma3t8vya.d(31): Error: declaration expected, not `63U`

    /tmp/tmpma3t8vya.d(31): Error: unterminated character constant

    /tmp/tmpma3t8vya.d(36): Error: declaration expected, not `assert`

    /tmp/tmpma3t8vya.d(37): Error: declaration expected, not `assert`

    /tmp/tmpma3t8vya.d(38): Error: declaration expected, not `assert`

    /tmp/tmpma3t8vya.d(39): Error: declaration expected, not `assert`

    /tmp/tmpma3t8vya.d(40): Error: declaration expected, not `assert`

    /tmp/tmpma3t8vya.d(41): Error: declaration expected, not `assert`

    /tmp/tmpma3t8vya.d(42): Error: declaration expected, not `assert`

    /tmp/tmpma3t8vya.d(43): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpma3t8vya.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.isEmpty() && all(k in dict as string for k in lower);\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0hwlsrqh.d(23): Error: found `as` when expecting `,`

    /tmp/tmp0hwlsrqh.d(23): Error: found `for` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0hwlsrqh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.empty() && !any(dict.iterate(\n        [](string\
    \ key, string value) -> bool {\n            return std.isLowercase(value) || std.isUppercase(value);\n\
    \        }));\n}\n\"\"\"\n    pass\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq2e_pqim.d(24): Error: found `key` when expecting `,`

    /tmp/tmpq2e_pqim.d(24): Error: expression expected, not `,`

    /tmp/tmpq2e_pqim.d(24): Error: found `string` when expecting `,`

    /tmp/tmpq2e_pqim.d(24): Error: expression expected, not `>`

    /tmp/tmpq2e_pqim.d(24): Error: found `bool` when expecting `,`

    /tmp/tmpq2e_pqim.d(28): Error: declaration expected, not `""`

    /tmp/tmpq2e_pqim.d(39): Error: unterminated string constant starting at /tmp/tmpq2e_pqim.d(39)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq2e_pqim.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict == null || dict.length == 0) return true;\n    for (auto\
    \ k : dict)\n        if (k.value.length != 0) return false;\n    return true;\n\
    }\n/* \n    Create a dictionary from the given associative array.\n    If the\
    \ given associative array is null, return null.\n    \n    Arguments: \n     \
    \   dict - Associative array (dictionary) to be created.\n    Returns:\n     \
    \   Nullable!(string[string]) dictionary if the given associative array is not\
    \ null, else null.\n    Example:\n        dict = create_dict([\"Name\": \"John\"\
    , \"Age\": \"36\", \"City\": \"Houston\"])\n*/\nNullable!(string[string]) create_dict(Nullable!(string[string])\
    \ dict)\n{\n    if (dict == null) \n        return Nullable!(string[string]) null;\n\
    \    \n    string[string] keys = dict.value;\n    string[string] vals = dict.key;\n\
    \    \n    Array!(string) keysa = Array!<string>(keys.length);\n    Array!(string)\
    \ valsa = Array!<string>(keys.length);\n    \n    for (auto key : keys) keysa[dict.value_index]\
    \ = key;\n    for (auto val : vals) valsa[dict.key_index] = val;\n    \n    return\
    \ Nullable!(string[string]) new Dictionary(keysa, valsa);\n}\n/* \n    Create\
    \ a dictionary from the given associative array.\n    If the given associative\
    \ array is null, return null.\n    \n    Arguments: \n        dict - Associative\
    \ array (dictionary) to be created.\n    Returns:\n        Nullable!(string[string])\
    \ dictionary if the given associative array is not null, else null.\n    Example:\n\
    \        dict = create_dict([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"\
    Houston\"])\n*/\nNullable!(string[string]) create_dict(Nullable!(string[string])\
    \ dict, string[string] key, string value)\n{\n    if (dict == null)\n        return\
    \ Nullable!(string[string]) null;\n    \n    string[string] keys = dict.value;\n\
    \    string[string] vals = dict.key;\n    \n    Array!(string) keysa = Array!<string>(keys.length);\n\
    \    Array!(string) valsa = Array!<string>(keys.length);\n    \n    for (auto\
    \ key : keys) keysa[dict.value_index] = key;\n    for (auto val : vals) valsa[dict.key_index]\
    \ = val;\n    \n    return Nullable!(string[string]) new Dictionary(keysa, valsa).put(key,\
    \ value);\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbwmxblis.d(24): Error: no identifier for declarator `k`

    /tmp/tmpbwmxblis.d(24): Error: expression expected, not `:`

    /tmp/tmpbwmxblis.d(24): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmpbwmxblis.d(42): Error: found `null` when expecting `;` following `return`
    statement

    /tmp/tmpbwmxblis.d(42): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpbwmxblis.d(47): Error: template argument expected following `!`

    /tmp/tmpbwmxblis.d(47): Error: semicolon expected, not `>`

    /tmp/tmpbwmxblis.d(47): Error: found `>` instead of statement

    /tmp/tmpbwmxblis.d(48): Error: template argument expected following `!`

    /tmp/tmpbwmxblis.d(48): Error: semicolon expected, not `>`

    /tmp/tmpbwmxblis.d(48): Error: found `>` instead of statement

    /tmp/tmpbwmxblis.d(50): Error: no identifier for declarator `key`

    /tmp/tmpbwmxblis.d(50): Error: expression expected, not `:`

    /tmp/tmpbwmxblis.d(50): Error: found `keys` when expecting `;` following `for`
    condition

    /tmp/tmpbwmxblis.d(51): Error: no ident'
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int count = 0;\n    foreach(string key, dict){\n        if(!is_null(key)\
    \ && is_string(key))\n            count++;\n        else\n            return false;\n\
    \    }\n    return count == (dict.length()/2);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    That's really helpful! Thank you!\n<|/ c |>\n<| a tags=string,python dscore=3\
    \ |>\nTo make life a bit easier, you can define a nullable data type in Python\
    \ as follows:\n<code>\nclass Nullable:\n    def __init__(self, value):\n     \
    \   self.value = value\n    def value(self):\n        return self.value\n    def\
    \ is_null(self):\n        return not self.value\n</code>\nThe class above is just\
    \ a convenience wrapper around the primitive type, which allows you to define\
    \ methods on it:\n<code>\ndef nullable_string(str): return Nullable(str)\n</code>\n\
    And then you can use your nullable data type to enforce a constraint on your string:\n\
    <code>\ndef check_dict_case(dicts):\n    return all(Nullable(s).is_null for s\
    \ in dicts)\n</code>\n<|/ a |>\n<| c |>\nThis is how I would have done it as well.\
    \ An alternate approach is to use `isinstance(s, Nullable)` to detect nullable\
    \ types. That way, you won't need to define an additional wrapper class. Although\
    \ it is essentially the same thing. I would not recommend this approach over simply\
    \ defining a function that checks if something is a `null` string. Although in\
    \ most cases, using `isinstance` would work as well, this approach would work\
    \ even for types that don't define `__bool__` (like those returned from functions).\n\
    <|/ c |>\n<| a tags=string,python dscore=2 |>\nThe most elegant solution I found\
    \ is to use a Python decorator:\n<code>\ndef check_dict_case(nullable_string):\n\
    \    def check_func(func):\n        def func_wrapper(*args, **kwargs):\n     \
    \       return all(func(*arg, **kwarg) for arg in args) or all(nullable_string(s)\
    \ for s in kwargs)\n        return func_wrapper\n    return check_func\n</code>\n\
    Then you can use it like that:\n<code>\ndef check_dict_case(nullable_string):\n\
    \    def check_func(func):\n        def func_wrapper(*args, **kwargs):\n     \
    \       return all(func(*arg, **kwarg) for arg in args) or all(nullable_string(s)\
    \ for s in kwargs)\n        return func_wrapper\n    return check_func\n</code>\n\
    <|/ a |>\n<| c |>\nVery nice! But I would rename the function to `is_nullable`\
    \ :D\n<|/ c |>\n<| a tags=string,python |>\nHere's another solution that I find\
    \ more elegant:\n<code>\ndef is_nullable_string(s):\n    return isinstance(s,\
    \ str) and s\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp52ui6h1v.d(24): Error: no identifier for declarator `dict`

    /tmp/tmp52ui6h1v.d(24): Error: found `)` when expecting `;`

    /tmp/tmp52ui6h1v.d(30): Error: found `return` when expecting `)`

    /tmp/tmp52ui6h1v.d(32): Error: declaration expected, not `<`

    /tmp/tmp52ui6h1v.d(35): Error: unterminated character constant

    /tmp/tmp52ui6h1v.d(59): Error: unterminated character constant

    /tmp/tmp52ui6h1v.d(59): Error: unterminated character constant

    /tmp/tmp52ui6h1v.d(85): Error: unterminated character constant

    /tmp/tmp52ui6h1v.d(93): Error: declaration expected, not `assert`

    /tmp/tmp52ui6h1v.d(94): Error: declaration expected, not `assert`

    /tmp/tmp52ui6h1v.d(95): Error: declaration expected, not `assert`

    /tmp/tmp52ui6h1v.d(96): Error: declaration expected, not `assert`

    /tmp/tmp52ui6h1v.d(97): Error: declaration expected, not `assert`

    /tmp/tmp52ui6h1v.d(98): Error: declaration expected, not `assert`

    /tmp/tmp52ui6h1v.d(99): Error: declaration expected, not `assert`

    /tmp/tmp52ui6h1v.d(100): Error: unrecognized declaration

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    assert(!dict.isNull);\n    return !dict.isEmpty;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk9bvvwij.d(24): Error: no property `isEmpty` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk9bvvwij.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  \n}\n'''\n        validate_fn(check_dict_case)\n        \n    \
    \    validate_fn('''\nimport std.random;\nimport std.array;\nimport std.string;\n\
    import std.typecons;\nimport std.math;\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfmkgk_nn.d(25): Error: unterminated character constant

    /tmp/tmpfmkgk_nn.d(25): Error: declaration expected, not `63U`

    /tmp/tmpfmkgk_nn.d(25): Error: unterminated character constant

    /tmp/tmpfmkgk_nn.d(28): Error: unterminated character constant

    /tmp/tmpfmkgk_nn.d(28): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfmkgk_nn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(string key in dict)\n    {\n        char lowerChar =\
    \ key.lower();\n        char upperChar = key.upper();\n        if (lowerChar ==\
    \ upperChar)\n            continue;\n        return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxgok2u8d.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxgok2u8d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  if(!dict.IsNull) return true; \n  \n  for(auto iter = dict.begin();\
    \ iter != dict.end(); iter++) {\n    if(!iter->IsNull) \n    {\n      if (iter->isUpper)\
    \ return true;\n      else \n      {\n\tfor(auto iter2 = iter->begin(); iter2\
    \ != iter->end(); iter2++) {\n\t  if(!iter2->IsNull) return false; \n\t}\n\treturn\
    \ true;\n      }\n    }\n  }\n  return false;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdi10wfa6.d(26): Error: use `.` for member lookup, not `->`

    /tmp/tmpdi10wfa6.d(28): Error: use `.` for member lookup, not `->`

    /tmp/tmpdi10wfa6.d(31): Error: use `.` for member lookup, not `->`

    /tmp/tmpdi10wfa6.d(31): Error: use `.` for member lookup, not `->`

    /tmp/tmpdi10wfa6.d(32): Error: use `.` for member lookup, not `->`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdi10wfa6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(d:dict | {\n        foreach(k:string in d | {\n     \
    \       if(k.length>1) return false;\n        })\n    })\n    return true;\n}\n\
    </code>\n<|/ a |>\n<| a |>\nHere's a solution without using the std.typecons module.\n\
    <code>\nuse std::collections::HashMap;\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmkmmarho.d(23): Error: no identifier for declarator `d`

    /tmp/tmpmkmmarho.d(23): Error: found `:` when expecting `;`

    /tmp/tmpmkmmarho.d(24): Error: no identifier for declarator `k`

    /tmp/tmpmkmmarho.d(24): Error: found `:` when expecting `;`

    /tmp/tmpmkmmarho.d(24): Error: `string in d` must be parenthesized when next to
    operator `|`

    /tmp/tmpmkmmarho.d(27): Error: found `}` instead of statement

    /tmp/tmpmkmmarho.d(30): Error: declaration expected, not `<`

    /tmp/tmpmkmmarho.d(33): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmkmmarho.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164430
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  if(dict.isNull) return true;\n  foreach(k, v:dict)\n    if (v.isNull)\
    \ return false;\n    else if (!string(v).toLowerCase()) return false; \n    else\
    \ if (!string(v).toUpperCase()) return false;\n  return true;\n}\n'''\n)\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqd3cu731.d(24): Error: no identifier for declarator `v`

    /tmp/tmpqd3cu731.d(24): Error: found `:` when expecting `;`

    /tmp/tmpqd3cu731.d(30): Error: unterminated character constant

    /tmp/tmpqd3cu731.d(30): Error: declaration expected, not `63U`

    /tmp/tmpqd3cu731.d(30): Error: unterminated character constant

    /tmp/tmpqd3cu731.d(36): Error: declaration expected, not `assert`

    /tmp/tmpqd3cu731.d(37): Error: declaration expected, not `assert`

    /tmp/tmpqd3cu731.d(38): Error: declaration expected, not `assert`

    /tmp/tmpqd3cu731.d(39): Error: declaration expected, not `assert`

    /tmp/tmpqd3cu731.d(40): Error: declaration expected, not `assert`

    /tmp/tmpqd3cu731.d(41): Error: declaration expected, not `assert`

    /tmp/tmpqd3cu731.d(42): Error: declaration expected, not `assert`

    /tmp/tmpqd3cu731.d(43): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqd3cu731.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for (auto kv : dict)\n    {\n        if (to!string(kv.key) !=\
    \ to!string(kv.key))\n            return false;\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpctcndv8a.d(23): Error: no identifier for declarator `kv`

    /tmp/tmpctcndv8a.d(23): Error: expression expected, not `:`

    /tmp/tmpctcndv8a.d(23): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpctcndv8a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    forall(dict, \n    [](string key, string value) -> bool { return\
    \ check_type!(key, String) || check_type!(value, String); });\n    return true;\n\
    }\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp13na5_d_.d(24): Error: found `key` when expecting `,`

    /tmp/tmp13na5_d_.d(24): Error: expression expected, not `,`

    /tmp/tmp13na5_d_.d(24): Error: found `string` when expecting `,`

    /tmp/tmp13na5_d_.d(24): Error: expression expected, not `>`

    /tmp/tmp13na5_d_.d(24): Error: found `bool` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp13na5_d_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.hasKey(\"Name\"))\n        return dict.hasKey(\"AGE\"\
    );\n    \n    foreach (key in dict.keys()) \n    {\n        string upper = key.to_uppercase();\n\
    \        bool isString = false;\n        \n        if (!dict.hasKey(upper)) \n\
    \            continue;\n        \n        string lower = key.to_lowercase();\n\
    \        \n        if (isNullable(dict[lower]))\n        {\n            isString\
    \ = true;\n        }\n        else\n        {\n            isString = dict[lower].isString;\n\
    \        }\n        \n        if (!isString)\n        {\n            return false;\n\
    \        }\n    }\n    \n    return true;\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=d,associative-array,null,string |>\nThis solution uses std.algorithm.partition,\
    \ std.algorithm.search, std.algorithm.forEach and std.algorithm.find:\n<code>\n\
    import std.algorithm : partition, search, forEach, find;\nimport std.stdio, std.stdio,\
    \ std.typecons : isNullable;\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyyydchi3.d(26): Error: no identifier for declarator `key`

    /tmp/tmpyyydchi3.d(26): Error: found `in` when expecting `;`

    /tmp/tmpyyydchi3.d(53): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyyydchi3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto result = false;\n    auto it = dict.dict.begin();\n    auto\
    \ end = dict.dict.end();\n    while (it != end) {\n        auto key = (it->first);\n\
    \        bool isLower = false;\n        bool isUpper = false;\n        if (auto\
    \ key = key_of!(Nullable!(string[string]), key).first) {\n            if (auto\
    \ str = key.as<string[]>()) {\n                isLower = str[0] == str[0].to<string>();\n\
    \            } else if (auto str = key.as<String>()) {\n                isLower\
    \ = str.to<string>().to<bool>();\n            }\n        }\n        if (auto key\
    \ = key_of!(Nullable!(string[string]), key).second) {\n            if (auto str\
    \ = key.as<string[]>()) {\n                isUpper = str[1] == str[1].to<string>();\n\
    \            } else if (auto str = key.as<String>()) {\n                isUpper\
    \ = str.to<string>().to<bool>();\n            }\n        }\n        if (isLower\
    \ && isUpper) {\n            result = true;\n            break;\n        }\n \
    \       ++it;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz3nro_ae.d(27): Error: use `.` for member lookup, not `->`

    /tmp/tmpz3nro_ae.d(31): Error: found `>` when expecting `)`

    /tmp/tmpz3nro_ae.d(31): Error: expression expected, not `)`

    /tmp/tmpz3nro_ae.d(31): Error: found `{` when expecting `;` following statement

    /tmp/tmpz3nro_ae.d(32): Error: found `<` when expecting `;` following statement

    /tmp/tmpz3nro_ae.d(32): Error: expression expected, not `)`

    /tmp/tmpz3nro_ae.d(32): Error: found `;` when expecting `)`

    /tmp/tmpz3nro_ae.d(33): Error: found `}` when expecting `;` following statement

    /tmp/tmpz3nro_ae.d(33): Error: found `else` without a corresponding `if`, `version`
    or `debug` statement

    /tmp/tmpz3nro_ae.d(38): Error: found `>` when expecting `)`

    /tmp/tmpz3nro_ae.d(38): Error: expression expected, not `)`

    /tmp/tmpz3nro_ae.d(38): Error: found `{` when expecting `;` following statement

    /tmp/tmpz3nro_ae.d(39): Error: found `<` when expecting `;` following statement

    /tmp/tmpz3nro_ae.d(39): Error: expression expected, not `)`

    /tmp/tmpz3nro_ae.d(39): Error: f'
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int len = dict.length;\n    int i = 0;\n    while (i < len)\n\
    \    {\n        string key = dict[i].key.toLower();\n        if (key.length()\
    \ == 0)\n            return false;\n        else\n        {\n            string\
    \ lower = key[0];\n            string upper = key[0];\n            for (i = 1;\
    \ i < key.length; ++i)\n            {\n                lower = key.charAt(0).toLower()\
    \ + lower;\n                upper = key.charAt(0).toUpper() + upper;\n       \
    \     }\n            if (lower != upper)\n                return false;\n    \
    \        else\n                ++i;\n        }\n        ++i;\n    }\n    return\
    \ true;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=stl,stl,c++,dictionary |>\n\
    For what it's worth, I implemented a generic version of the function check_dict_case()\
    \ suggested by Thiago Aquino. I also added an assert statement to catch invalid\
    \ input.\n<code>\n// Test whether each key of dict is in lower or upper case.\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplthmsfm5.d(48): Error: declaration expected, not `<`

    /tmp/tmplthmsfm5.d(51): Error: unterminated character constant

    /tmp/tmplthmsfm5.d(58): Error: declaration expected, not `assert`

    /tmp/tmplthmsfm5.d(59): Error: declaration expected, not `assert`

    /tmp/tmplthmsfm5.d(60): Error: declaration expected, not `assert`

    /tmp/tmplthmsfm5.d(61): Error: declaration expected, not `assert`

    /tmp/tmplthmsfm5.d(62): Error: declaration expected, not `assert`

    /tmp/tmplthmsfm5.d(63): Error: declaration expected, not `assert`

    /tmp/tmplthmsfm5.d(64): Error: declaration expected, not `assert`

    /tmp/tmplthmsfm5.d(65): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplthmsfm5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(i in dict, e in i.keys) {\n        if (e is string) \n\
    \            return true;\n        if (e is string) \n            return false;\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn5j5dcmp.d(23): Error: no identifier for declarator `i`

    /tmp/tmpn5j5dcmp.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn5j5dcmp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(string key, dict | \n        {\n            bool isUpper\
    \ = char.isUpper(key);\n            bool isLower = char.isLower(key);\n      \
    \      if(isUpper != isLower)\n                return false;\n        });\n  \
    \  return true;\n}\n\"\"\"\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpolhdu7n9.d(23): Error: no identifier for declarator `dict`

    /tmp/tmpolhdu7n9.d(23): Error: found `|` when expecting `;`

    /tmp/tmpolhdu7n9.d(29): Error: use `{ }` for an empty statement, not `;`

    /tmp/tmpolhdu7n9.d(32): Error: declaration expected, not `""`

    /tmp/tmpolhdu7n9.d(42): Error: unterminated string constant starting at /tmp/tmpolhdu7n9.d(42)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpolhdu7n9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\tauto result = true;\n\tif(!dict.empty()) {\n\t\tstring k;\n\t\t\
    for(auto i : dict)\n\t\t\tk = i.key();\n\t\tif(k.size() == 1) {\n\t\t\tif(islower(k.front()))\
    \ {\n\t\t\t\tif(dict.find(k.front().toupper()) == dict.end())\n\t\t\t\t\tresult\
    \ = false;\n\t\t\t}\n\t\t\telse\n\t\t\t\tif(dict.find(k.front().tolower()) ==\
    \ dict.end())\n\t\t\t\t\tresult = false;\n\t\t}\n\t\telse\n\t\t\tfor(auto i :\
    \ dict)\n\t\t\t\tif(!check_dict_case(i.value()))\n\t\t\t\t\tresult = false;\n\t\
    }\n\treturn result;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n\
    \    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"\
    ].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\", \"5\": \"\
    banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"Name\"\
    : \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n   \
    \ assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpql3jtuvb.d(26): Error: no identifier for declarator `i`

    /tmp/tmpql3jtuvb.d(26): Error: expression expected, not `:`

    /tmp/tmpql3jtuvb.d(26): Error: found `dict` when expecting `;` following `for`
    condition

    /tmp/tmpql3jtuvb.d(38): Error: no identifier for declarator `i`

    /tmp/tmpql3jtuvb.d(38): Error: expression expected, not `:`

    /tmp/tmpql3jtuvb.d(38): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpql3jtuvb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return dict == null ? false : \n        dict.values.all(x =>\
    \ x.is_str() || x.is_ustr()) ? true : \n        dict.values.all(x => x.is_int()\
    \ && x.is_uint()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_float()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_bool()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_char()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_float()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_double()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_char16()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_char32()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_bool()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_string()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_map()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_tuple()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_list())? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_set()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_map()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_tuple()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_list())? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_set()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_map()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_tuple()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_list())? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_set()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_map()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_tuple()) ? true : \n        dict.values.all(x => x.is_int\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphwy3dna8.d(50): Error: found `unittest` when expecting `,`

    /tmp/tmphwy3dna8.d(62): Error: found `void` when expecting `,`

    /tmp/tmphwy3dna8.d(62): Error: found `{` when expecting `,`

    /tmp/tmphwy3dna8.d(62): Error: expression expected, not `}`

    /tmp/tmphwy3dna8.d(62): Error: found `End of File` when expecting `,`

    /tmp/tmphwy3dna8.d(62): Error: found `End of File` when expecting `)`

    /tmp/tmphwy3dna8.d(62): Error: found `End of File` when expecting `;` following
    `return` statement

    /tmp/tmphwy3dna8.d(62): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphwy3dna8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict is Nullable)\n        return check_dict_case(dict.nullable);\n\
    \    return dict == null || dict == undefined || dict.isEmpty || dict.size ==\
    \ 0;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq3x1mytd.d(23): Error: void has no value

    /tmp/tmpq3x1mytd.d(23): Error: incompatible types for `(dict) is (Nullable(T))`:
    `Nullable!(string[string])` and `void`

    /tmp/tmpq3x1mytd.d(25): Error: undefined identifier `undefined`

    /tmp/tmpq3x1mytd.d(25): Error: no property `isEmpty` for type `Nullable!(string[string])`

    /tmp/tmpq3x1mytd.d(25): Error: no property `size` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq3x1mytd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    auto it = dict.keys;\n    bool result = true;\n    auto next_key\
    \ = it.next();\n    while (next_key.is_some) {\n        auto key = next_key.value;\n\
    \        auto lower_key = std.string::to_lowercase(key);\n        auto upper_key\
    \ = std.string::to_uppercase(key);\n        if (!it.next().is_some) {\n      \
    \      result = !result;\n        } else if (it.next().is_some) {\n          \
    \  result = !result;\n        } else if (key == lower_key) {\n            result\
    \ = !result;\n        } else if (key == upper_key) {\n            result = !result;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpglx3v2n7.d(28): Error: semicolon expected following auto declaration,
    not `:`

    /tmp/tmpglx3v2n7.d(28): Error: found `:` instead of statement

    /tmp/tmpglx3v2n7.d(29): Error: semicolon expected following auto declaration,
    not `:`

    /tmp/tmpglx3v2n7.d(29): Error: found `:` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpglx3v2n7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (kv in dict) {\n        if (kv.isNull) return false;\n\
    \        if (!isLowercase(kv.key)) {\n            if (isUppercase(kv.key)) {\n\
    \                return false;\n            }\n            else {\n          \
    \      return true;\n            }\n        }\n        if (!isUppercase(kv.key))\
    \ {\n            return true;\n        }\n    }\n    \n    return true;\n}\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr81ttqcx.d(23): Error: no identifier for declarator `kv`

    /tmp/tmpr81ttqcx.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr81ttqcx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(auto& kv : dict) {\n        // TODO: add more checks\n  \
    \      return islower(kv.key) || isupper(kv.key);\n    }\n    return false;\n\
    }\n</code>\nThis can then be used as follows:\n<code>\nimport std.typecons;\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk3g2fw4i.d(23): Error: basic type expected, not `&`

    /tmp/tmpk3g2fw4i.d(23): Error: no identifier for declarator `_error_`

    /tmp/tmpk3g2fw4i.d(23): Error: found `:` when expecting `;` following `for` condition

    /tmp/tmpk3g2fw4i.d(29): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk3g2fw4i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !dict.isNull;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpr32djqgh.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x457721]

    ??:? void tmpr32djqgh.__unittest_L25_C1() [0x4421eb]

    ??:? void tmpr32djqgh.__modtest() [0x45522c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x460a73]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x456d4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x45c41d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x45c4ac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x45c3a9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x456d25]

    ??:? runModuleUnitTests [0x460849]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x458b2c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if(!is_dict(dict))\n        throw new ArgumentTypeError(\"Passed\
    \ argument is not a dictionary.\");\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_u2j__bl.d(25): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_u2j__bl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n\treturn dict.isDefined;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvrlm36p9.d(23): Error: no property `isDefined` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvrlm36p9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return isNull(dict);\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3913np_a.d(23): Error: undefined identifier `isNull`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3913np_a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, value) in dict \n    {\n        if (!is_string(key)\
    \ || !is_string(value)) return false;\n    }\n    return true;\n}\n'''\n    \n\
    def check_input_dict_case(\n        dict_or_array: Union['Dict', 'Dict[]'], \n\
    \        case: Case = Case.DONT_CARE) -> 'Input':\n    '''\n    Checks that keys\
    \ or values in the given dictionary or array are strings in lower\n    case or\
    \ strings in upper case.\n    \n    The function may fail to detect invalid inputs\
    \ in the following cases:\n    \n    * Empty dictionaries\n    * Empty arrays\n\
    \    * Strings that are not valid Python identifiers (starting with underscore)\n\
    \    * Strings that are not valid Python identifiers or numbers\n    * Strings\
    \ that are not valid Python identifiers\n    \n    Examples:\n    >>> check_input_dict_case({})\n\
    \    {}\n    >>> check_input_dict_case([])\n    []\n    >>> check_input_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"])\n    {'a': 'apple', 'b': 'banana'}\n    >>>\
    \ check_input_dict_case([\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"\
    ])\n    {'A': 'banana', 'B': 'banana'}\n    >>> check_input_dict_case([\"a\":\
    \ \"apple\", 8L: \"banana\", \"a\": \"apple\"])\n    {'a': 8L, 'a': 'apple'}\n\
    \    >>> check_input_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"])\n    {'Name': 'John', 'Age': '36', 'City': 'Houston'}\n    \n\
    \    '''\n    if isinstance(dict_or_array, Dict):\n        dict_or_array = [dict_or_array]\n\
    \    \n    checker = CheckerContext()\n    checker.check_inputs(\n        dict_or_array,\
    \ \n        lambda i, v: check_input_dict_case(v, case), \n        lambda i, v:\
    \ check_input_dict_case(i, v, case))\n    \n    return checker.unchecked_inputs()\n\
    </cell>\n<code language=xeus-cling-cpp14>\ncheck_input_dict_case(check_input_dict_case({}))\n\
    </cell>\n<code language=xeus-cling-cpp14>\ncheck_input_dict_case(check_input_dict_case([]))\n\
    </cell>\n<code language=xeus-cling-cpp14>\ncheck_input_dict_case(check_input_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"]))\n</cell>\n<code language=xeus-cling-cpp14>\n\
    check_input_dict_case(check_input_dict_case([\"a\": \"apple\", \"A\": \"banana\"\
    , \"B\": \"banana\"]))\n</cell>\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzh11iz4x.d(23): Error: no identifier for declarator `value`

    /tmp/tmpzh11iz4x.d(23): Error: found `)` when expecting `;`

    /tmp/tmpzh11iz4x.d(23): Error: expression expected, not `in`

    /tmp/tmpzh11iz4x.d(23): Error: found `dict` when expecting `)`

    /tmp/tmpzh11iz4x.d(29): Error: unterminated character constant

    /tmp/tmpzh11iz4x.d(29): Error: declaration expected, not `63U`

    /tmp/tmpzh11iz4x.d(29): Error: unterminated character constant

    /tmp/tmpzh11iz4x.d(32): Error: unterminated character constant

    /tmp/tmpzh11iz4x.d(32): Error: unterminated character constant

    /tmp/tmpzh11iz4x.d(32): Error: unterminated character constant

    /tmp/tmpzh11iz4x.d(32): Error: unterminated character constant

    /tmp/tmpzh11iz4x.d(33): Error: unterminated character constant

    /tmp/tmpzh11iz4x.d(33): Error: unterminated character constant

    /tmp/tmpzh11iz4x.d(34): Error: unterminated character constant

    /tmp/tmpzh11iz4x.d(34): Error: unterminated character constant

    /tmp/tmpzh11iz4x.d(52): Error: unterminated character constant

    /tmp/tmpzh11iz4x'
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    forall (x in dict) \n    {\n        bool result = isinstance(x.key(),\
    \ std.typecons.char);\n        result &= isinstance(x.key(), std.typecons.char);\n\
    \        return result;\n    }\n    return false;\n}\nunittest\n{\n    alias candidate\
    \ = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"\
    banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"\
    A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_cpzjjca.d(24): Error: found `{` when expecting `;` following statement

    /tmp/tmp_cpzjjca.d(25): Error: identifier expected following `.`, not `char`

    /tmp/tmp_cpzjjca.d(26): Error: identifier expected following `.`, not `char`

    /tmp/tmp_cpzjjca.d(29): Error: declaration expected, not `return`

    /tmp/tmp_cpzjjca.d(30): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_cpzjjca.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.isEmpty)\n        return false;\n    // first check\
    \ key case sensitivity\n    if (dict.isDefinedAt(dict._keys.map(x => x.caseInsensitive())))\n\
    \        return true;\n    // second check value case sensitivity\n    if (dict.isDefinedAt(dict._keys.map(x\
    \ => x.caseInsensitive()).map(x => x.lowercase())))\n        return true;\n  \
    \  return false;\n}\n\"\"\")\n</cell>\n<text>\nTuples\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx2lnyec1.d(33): Error: declaration expected, not `""`

    /tmp/tmpx2lnyec1.d(46): Error: unterminated string constant starting at /tmp/tmpx2lnyec1.d(46)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx2lnyec1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach (key, value) in dict \n    {\n        if (!(is_string(value)\
    \ || is_string(value.toLower())))\n            return false;\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5e7j1udh.d(23): Error: no identifier for declarator `value`

    /tmp/tmp5e7j1udh.d(23): Error: found `)` when expecting `;`

    /tmp/tmp5e7j1udh.d(23): Error: expression expected, not `in`

    /tmp/tmp5e7j1udh.d(23): Error: found `dict` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5e7j1udh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n  if (dict == null)\n    return false;\n  \n  var keys = dict.get_keys();\n\
    \  for (var i = 0; i < keys.length; ++i)\n  {\n    var value = dict.get_value(keys[i]);\n\
    \    if (!value.is_string())\n      return false;\n  }\n  \n  return true;\n}\n\
    unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9vde96yo.d(26): Error: undefined identifier `var`

    /tmp/tmp9vde96yo.d(26): Error: no property `get_keys` for type `Nullable!(string[string])`

    /tmp/tmp9vde96yo.d(27): Error: undefined identifier `var`

    /tmp/tmp9vde96yo.d(29): Error: undefined identifier `var`

    /tmp/tmp9vde96yo.d(29): Error: no property `get_value` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9vde96yo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return is_tuple(dict) && contains_all(dict.values, |e| e is Nullable!(string[string]));\n\
    }\n/*\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp33q0blsl.d(23): Error: expression expected, not `|`

    /tmp/tmp33q0blsl.d(23): Error: found `e` when expecting `,`

    /tmp/tmp33q0blsl.d(23): Error: expression expected, not `|`

    /tmp/tmp33q0blsl.d(23): Error: found `e` when expecting `,`

    /tmp/tmp33q0blsl.d(23): Error: `type identifier : specialization` expected following
    `is`

    /tmp/tmp33q0blsl.d(23): Error: found `!` when expecting `,`

    /tmp/tmp33q0blsl.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp33q0blsl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    bool result = true;\n    foreach(pair!string key, pair!string\
    \ val in dict)\n    {\n        result &= key == val; \n        result &= !key.compareToIgnoreCase(val);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc01n_a71.d(24): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc01n_a71.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v) dict\n    {\n        if(typeof(v) != null) // null\
    \ check\n        {\n            if(!string_islower(k) || !string_isupper(k))\n\
    \                return false;\n        }\n        else\n        {\n         \
    \   if(!string_islower(k) || !string_isupper(k))\n                return false;\n\
    \        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9ywkbo5y.d(23): Error: no identifier for declarator `v`

    /tmp/tmp9ywkbo5y.d(23): Error: found `)` when expecting `;`

    /tmp/tmp9ywkbo5y.d(24): Error: found `{` when expecting `)`

    /tmp/tmp9ywkbo5y.d(36): Error: declaration expected, not `return`

    /tmp/tmp9ywkbo5y.d(37): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ywkbo5y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    return !is_null(dict) && is_associative(dict) && \n         \
    \  all((k, v) => (is_str(k) && is_str(v)) || \n                       (is_str(k)\
    \ && !is_str(v)));\n}\n/*\n    Determine if all keys are strings in lower case\
    \ or all keys are strings\n    in upper case, else return false.\n    The function\
    \ should return false if the keys are not all strings or the \n    value is not\
    \ null.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\", \"b\": \"banana\"\
    ].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\"\
    , \"8L\": \"banana\", \"a\": \"apple\"].nullable)\n    true\n    >>> check_dict_case([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable)\n    false\n\
    \    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable)\n \
    \   false\n*/\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbxqcj8xk.d(23): Error: undefined identifier `is_null`

    /tmp/tmpbxqcj8xk.d(23): Error: undefined identifier `is_associative`

    /tmp/tmpbxqcj8xk.d(24): Error: undefined identifier `all`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbxqcj8xk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(var key in dict) \n    {\n        if(key != null && key.length\
    \ != 0) \n        {\n            var lower = key.toLowerCase();\n            var\
    \ upper = key.toUpperCase();\n            if(!(lower in dict || upper in dict))\
    \ return false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\",\
    \ \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpka7f7fw4.d(23): Error: semicolon expected, not `in`

    /tmp/tmpka7f7fw4.d(23): Error: expression expected, not `in`

    /tmp/tmpka7f7fw4.d(23): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpka7f7fw4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    int num_keys = 0;\n    foreach (key, value) in dict \n    {\n\
    \        if (is_str(key) || is_str(value))\n        {\n            ++num_keys;\n\
    \        }\n    }\n    return num_keys == dict.len();\n}\n</code>\n<|/ a dscore=1\
    \ tags=dictionary,nullable,python |>\n<| a dscore=1 |>\nI needed the same thing\
    \ in my project and came up with this. Here is a version which works better with\
    \ nullable dictionary:\n<code>\ndef dict_keys_to_lowercase(dict_: dict, key_is_upper:\
    \ bool) -> dict:\n    \"\"\"Convert dictionary keys from all uppercase to lowercase\"\
    \"\"\n    # check input\n    if not isinstance(dict_, dict):\n        raise TypeError(\"\
    Argument must be dictionary\")\n    if not isinstance(key_is_upper, bool):\n \
    \       raise TypeError(\"Argument must be bool type for key conversion\")\nunittest\n\
    {\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\"\
    , \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"\
    p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n\
    \    assert(candidate([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable) == false);\n    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"\
    ].nullable) == true);\n    assert(candidate([\"fruit\": \"Orange\", \"taste\"\
    : \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjneo154l.d(24): Error: no identifier for declarator `value`

    /tmp/tmpjneo154l.d(24): Error: found `)` when expecting `;`

    /tmp/tmpjneo154l.d(24): Error: expression expected, not `in`

    /tmp/tmpjneo154l.d(24): Error: found `dict` when expecting `)`

    /tmp/tmpjneo154l.d(33): Error: declaration expected, not `<`

    /tmp/tmpjneo154l.d(49): Error: declaration expected, not `assert`

    /tmp/tmpjneo154l.d(50): Error: declaration expected, not `assert`

    /tmp/tmpjneo154l.d(51): Error: declaration expected, not `assert`

    /tmp/tmpjneo154l.d(52): Error: declaration expected, not `assert`

    /tmp/tmpjneo154l.d(53): Error: declaration expected, not `assert`

    /tmp/tmpjneo154l.d(54): Error: declaration expected, not `assert`

    /tmp/tmpjneo154l.d(55): Error: declaration expected, not `assert`

    /tmp/tmpjneo154l.d(56): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjneo154l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    for(key in dict) {\n        assert((string) key.length == 0 ||\
    \ key.length == 1);\n        assert((string) key[0] in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    );\n    }\n    \n    return true;\n}\n'''\nunittest\n{\n    alias candidate =\
    \ check_dict_case;\n\n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"\
    ].nullable) == true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\"\
    , \"B\": \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmey8pab_.d(23): Error: found `)` when expecting `;` following statement

    /tmp/tmpmey8pab_.d(24): Error: C style cast illegal, use `cast(string)key.length`

    /tmp/tmpmey8pab_.d(25): Error: C style cast illegal, use `cast(string)key[0]`

    /tmp/tmpmey8pab_.d(28): Error: found `return` when expecting `;` following `for`
    condition

    /tmp/tmpmey8pab_.d(28): Error: found `;` when expecting `)`

    /tmp/tmpmey8pab_.d(29): Error: found `}` instead of statement

    /tmp/tmpmey8pab_.d(30): Error: unterminated character constant

    /tmp/tmpmey8pab_.d(30): Error: declaration expected, not `63U`

    /tmp/tmpmey8pab_.d(30): Error: unterminated character constant

    /tmp/tmpmey8pab_.d(35): Error: declaration expected, not `assert`

    /tmp/tmpmey8pab_.d(36): Error: declaration expected, not `assert`

    /tmp/tmpmey8pab_.d(37): Error: declaration expected, not `assert`

    /tmp/tmpmey8pab_.d(38): Error: declaration expected, not `assert`

    /tmp/tmpmey8pab_.d(39): Error: declaration expected, not `assert`

    /tmp/tmpmey8pab_.d(40): Error: declaration expected,'
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    foreach(k, v: dict[string])\n    {\n        string lower = lowerCase(to!string(v));\n\
    \        string upper = upperCase(to!string(v));\n        if (upper != lower)\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    \"\"\"\n)\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcbxvhnd9.d(23): Error: no identifier for declarator `v`

    /tmp/tmpcbxvhnd9.d(23): Error: found `:` when expecting `;`

    /tmp/tmpcbxvhnd9.d(34): Error: declaration expected, not `""`

    /tmp/tmpcbxvhnd9.d(45): Error: unterminated string constant starting at /tmp/tmpcbxvhnd9.d(45)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcbxvhnd9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    if (dict.hasKey(\"a\")) return dict.get(\"a\").isLowercase();\n\
    \    if (dict.hasKey(\"A\")) return dict.get(\"A\").isUppercase();\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
    p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
    p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
    \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
    ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\"\
    : \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
    : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
    \ == false);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeomoqsjl.d(23): Error: no property `hasKey` for type `Nullable!(string[string])`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(2852):
    Error: incompatible types for `(fallback) : (this._value)`: `inout(char[])` and
    `inout(string[string])`

    /tmp/tmpeomoqsjl.d(23): Error: template instance `std.typecons.Nullable!(string[string]).Nullable.get!(char[])`
    error instantiating

    /tmp/tmpeomoqsjl.d(24): Error: no property `hasKey` for type `Nullable!(string[string])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeomoqsjl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164432
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative\
    \ array, return true if all keys are strings in lower \n    case or all keys are\
    \ strings in upper case, else return false.\n    The function should return false\
    \ is the given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
    a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n \
    \   >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
    \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
    : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
    , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
    \ dict) \n{\n    \n    for(var key in dict)\n    {\n        if(isNull(key))\n\
    \        {\n            return false;\n        }\n        if(key!=\"Name\" &&\
    \ key!=\"Age\" && key!=\"City\")\n        {\n            return false;\n     \
    \   }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = check_dict_case;\n\
    \n    assert(candidate([\"p\": \"pineapple\", \"b\": \"banana\"].nullable) ==\
    \ true);\n    assert(candidate([\"p\": \"pineapple\", \"A\": \"banana\", \"B\"\
    : \"banana\"].nullable) == false);\n    assert(candidate([\"p\": \"pineapple\"\
    , \"5\": \"banana\", \"a\": \"apple\"].nullable) == false);\n    assert(candidate([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"].nullable) == false);\n\
    \    assert(candidate([\"STATE\": \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n\
    \    assert(candidate([\"fruit\": \"Orange\", \"taste\": \"Sweet\"].nullable)\
    \ == true);\n    assert(candidate(Nullable!(string[string]).init) == false);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpee18t2zh.d(24): Error: semicolon expected, not `in`

    /tmp/tmpee18t2zh.d(24): Error: expression expected, not `in`

    /tmp/tmpee18t2zh.d(24): Error: found `dict` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpee18t2zh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164431
