name: HumanEval_55_fib
language: d
prompt: "import std.math;\n/*\nReturn n-th Fibonacci number.\n    >>> fib(10L)\n \
  \   55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n    \n*/\nlong fib(long\
  \ n) \n"
tests: "unittest\n{\n    alias candidate = fib;\n\n    assert(candidate(10L) == 55L);\n\
  \    assert(candidate(1L) == 1L);\n    assert(candidate(8L) == 21L);\n    assert(candidate(11L)\
  \ == 89L);\n    assert(candidate(12L) == 144L);\n}\nvoid main(){}"
completions: ["{\n    long retval;\n    retval = n < 2L ? 1L : fib(n - 2L) + fib(n\
    \ - 1L);\n    return retval;\n}\n/* Return true if n is a multiple of 5 */", "{\n\
    \tlong a,b;\n\tif(n<2L)\n\t\treturn n;\n\telse if(n<3L)\n\t\treturn 1L;\n\telse\n\
    \t{\n\t\ta=1L;\n\t\tb=2L;\n\t\tfor(n-3L;n>0L;n-=4L)\n\t\t{\n\t\t\tlong c=b+a;\n\
    \t\t\ta=b;\n\t\t\tb=c;\n\t\t}\n\t\treturn a;\n\t}\n}\n/*\nImport a text file as\
    \ a vector of strings.\n    >>> text = import_file(\"testdata/test.txt\")\n  \
    \  >>> text\n    ['A', 'B', 'C']\n    \nThe function returns a vector with the\
    \ strings in the file. \n    \nIf file does not exist, function returns an empty\
    \ vector.\n*/\nvector<string> import_file(string filename)\n{\n\tvector<string>\
    \ vstr;\n\tifstream file;\n\tfile.open(filename);\n\tif (!file.is_open())\n\t\t\
    return vstr;\n\tstring line;\n\twhile (getline(file, line))\n\t{\n\t\tvstr.push_back(line);\n\
    \t}\n\treturn vstr;\n}\n/*\nSave a vector to a text file as lines.\n    >>> save_vector(\"\
    testdata/test.txt\", text)\n    >>> filesize = file_size(\"testdata/test.txt\"\
    )\n    >>> filesize\n    4\n    \nIf the file already exists, function overwrites\
    \ the file contents.\n*/", "{\n    unsigned long a, b;\n    long res;\n    double\
    \ x;\n    \n    if( n >= (unsigned long)(1) )\n    {\n        return n;\n    }\n\
    \    \n    if( n == 0 )\n    {\n        return 0;\n    }\n    \n    x = std.math.rect(1,n,'f');\n\
    \    a = std.math.fmod(x,(double)(1.0));\n    if( std.math.isnan(a) )\n    {\n\
    \        return 1;\n    }\n    \n    b = std.math.fmod(x,(double)(1.0));\n   \
    \ res = (long)(a*(b+b+b+b));\n    \n    return res;\n}\n/******************************************************************************/",
  "{\n\tif (n > 0)\n\t{\n\t\treturn fib(n-1) + fib(n-2);\n\t}\n\telse\n\t{\n\t\treturn\
    \ fib(n-2) + fib(n-1);\n\t}\n}\n/* \n * Test code\n */", "{\n    /* base cases\
    \ */\n    if (n <= 1) return n;\n    \n    /* recursive case */\n    return (fib(n\
    \ - 1) + fib(n - 2));\n}\n/*\n>>> fib(1L)\n1L\n>>> fib(7L)\n21L\n>>> fib(8L)\n\
    21L\n>>> fib(8L)\n21L\n*/\n/*\n>>> fib(35)\n113L\n>>> fib(35)\n113L\n>>> fib(35)\n\
    113L\n>>> fib(35)\n113L\n>>> fib(35)\n113L\n>>> fib(35)\n113L\n*/\n/*\n>>> fib(0)\n\
    0L\n>>> fib(1)\n1L\n>>> fib(2)\n1L\n>>> fib(7)\n21L\n>>> fib(35)\n113L\n*/", "{\n\
    \tif (n <= 2) {\n\t\treturn n;\n\t}\n\treturn fib(n - 2) + fib(n - 1);\n}\n/*\n\
    Implement fibonacci in O(log n) time\n*/\nlong fib_log(long n) \n{\n\tif (n <=\
    \ 2) {\n\t\treturn n;\n\t}\n\tlong a = 1;\n\tlong b = 2;\n\tlong c;\n\twhile ((c\
    \ = a + b) >= n) {\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn b;\n}\n/*\nImplement\
    \ fibonacci in O(1) time\n*/\nlong fib_1(long n) \n{\n\tif (n <= 2) {\n\t\treturn\
    \ n;\n\t}\n\tlong a = 1;\n\tlong b = 2;\n\tlong c;\n\twhile ((c = a + b) >= n)\
    \ {\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\n/*\nImplement fibonacci in O(n)\
    \ time\n*/\nlong fib_n(long n) \n{\n\tif (n <= 2) {\n\t\treturn n;\n\t}\n\tlong\
    \ a = 1;\n\tlong b = 2;\n\tlong c;\n\twhile ((c = a + b) >= n) {\n\t\ta = b;\n\
    \t\tb = c;\n\t}\n\treturn a;\n}", "{\n\tif (n <= 0) return 0;\n\tif (n == 1) return\
    \ 1;\n\treturn fib(n-1) + fib(n-2);\n}", "{\n    long ret;\n    ret = ((n - 2L)\
    \ % 4L + 2L) % 4L;\n    ret = ret < 2L ? 1L : ret;\n    return ret;\n}\n\"\"\"",
  "{\n    long i, a=0, b=1;\n    for (i=2; i<=n; i++)\n    {\n         a=b;\n    \
    \     b=a+b;\n    }\n    return b;\n}", "{\n\tif (n == 0)\n\t\treturn 0;\n\tif\
    \ (n == 1)\n\t\treturn 1;\n\treturn fib(n-1) + fib(n-2);\n}", "{\n    long ret\
    \ = 1;\n    long temp;\n    for(long i = 2; i <= n; i++)\n    {\n       temp =\
    \ ret;\n       ret = ret + temp;\n       }\n    return ret;\n}", "{\n\tlong a,b;\n\
    \tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn 1;\n\tif (n % 2 == 0)\
    \ {\n\t\ta = fib(n / 2);\n\t\tb = a + a;\n\t\treturn b;\n\t} else {\n\t\ta = fib(n\
    \ / 2 - 1);\n\t\tb = a + a;\n\t\treturn b;\n\t}\n}\n/*\nReturn Fibonacci number\
    \ modulo M.\n    >>> fibMod(10L, 3L)\n    2L\n    >>> fibMod(11L, 3L)\n    3L\n\
    */\nlong fibMod(long n, long m) \n{\n\tlong a,b;\n\tif (n == 0)\n\t\treturn 0;\n\
    \tif (n == 1)\n\t\treturn m;\n\tif (n % 2 == 0) {\n\t\ta = fibMod(n / 2, m);\n\
    \t\tb = a + m;\n\t\treturn b;\n\t} else {\n\t\ta = fibMod(n / 2 - 1, m);\n\t\t\
    b = a + m;\n\t\treturn b;\n\t}\n}\n/*\nReturn Fibonacci number modulo M.\n   \
    \ >>> fibMod2(10L, 3L)\n    2L\n    >>> fibMod2(11L, 3L)\n    3L\n*/\nlong fibMod2(long\
    \ n, long m) \n{\n\tlong a,b;\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\
    \treturn m;\n\tif (n % 2 == 0) {\n\t\ta = fibMod2(n / 2, m);\n\t\tb = a + m;\n\
    \t\treturn b;\n\t} else {\n\t\ta = fibMod2(n / 2 - 1, m);\n\t\tb = a + m;\n\t\t\
    return b;\n\t}\n}\n/*\nReturn Fibonacci number modulo M.\n    >>> fibMod3(10L,\
    \ 3L)\n    2L\n    >>> fibMod3(11L, 3L)\n    3L\n*/\nlong fibMod3(long n, long\
    \ m) \n{\n\tlong a,b;\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn\
    \ m;\n\tif (n % 2 == 0) {\n\t\ta = fibMod3(n / 2, m);\n\t\tb = a + m;\n\t\treturn\
    \ b;\n\t} else {\n\t\ta = fibMod3(n / 2 - 1, m);\n\t\tb = a + m;\n\t\treturn b;\n\
    \t}\n}\n/*\nReturn Fibonacci number modulo M.\n    >>> fibMod4(10L, 3L)\n    2L\n\
    \    >>> fibMod4(11L, 3L)\n    3L\n*/\nlong fibMod4(long n, long m) \n{\n\tlong\
    \ a,b;\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn m;\n\tif (n %\
    \ 2 == 0) {\n\t\ta = fibMod4(n / 2, m);\n", "{\n\tlong a = 0L;\n\tlong b = 1;\n\
    \twhile (n-- > 0) \n\t{\n\t\tlong c = a + b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\t\
    return b;\n}\n\"\"\"\n    ],\n    \"pow\": [\n        \"number pow(number base,\
    \ number exponent)\",\n        \"Returns the value of the number base^exponent.\"\
    ,\n        '',\n        '',\n    ],\n    \"powr\": [\n        \"number powr(number\
    \ base, number exponent)\",\n        \"Returns the value of the number base^exponent\
    \ rounded down.\",\n        '',\n        '',\n    ],\n    \"print\": [\n     \
    \   \"void print(string s)\",\n        \"Prints string s to standard output. If\
    \ s begins with a \\\"%\\\", it prints a percentage followed by a newline.\",\n\
    \        '',\n        '',\n    ],\n    \"printf\": [\n        \"int printf(string\
    \ format, mixed ...)\",\n        \"Prints format to standard output. printf returns\
    \ the number of characters printed. ... can be any number of arguments. Note that\
    \ printf's arguments have a higher priority than standard output.\",\n       \
    \ '',\n        '',\n    ],\n    \"putenv\": [\n        \"bool putenv(string name)\"\
    ,\n        \"Sets the value of an environment variable. If name is not present,\
    \ putenv will fail. Otherwise it returns true.\",\n        '',\n        '',\n\
    \    ],\n    \"random\": [\n        \"double random(void)\",\n        \"Returns\
    \ a double in [0, 1)\",\n        '',\n        '',\n    ],\n    \"rand\": [\n \
    \       \"int rand(mixed min, mixed max)\",\n        \"Returns a pseudo-random\
    \ number between min (inclusive) and max (exclusive)\",\n        '',\n       \
    \ '',\n    ],\n    \"range\": [\n        \"array range(mixed low, mixed high[,\
    \ long step])\",\n        \"Creates an array containing the range of integers\
    \ or characters from low to high (inclusive). The optional third parameter defines\
    \ an increment (or decrement). Characters start at low and increase to high. start\
    \ is optional. If omitted, the range starts at 0 and ends at high\",\n       \
    \ '',\n        '',\n    ],\n    \"readdir\": [\n        \"array readdir(string\
    \ path [, int sorting_order [, resource context]])\",\n        \"List the contents\
    \ of the directory passed as path.\",\n        '',\n        ''\n    ],\n    \"\
    readfile\": [\n        \"int readfile(string filename [, bool use_include_path[,\
    \ resource context]])\",\n        \"Open a file for reading. Reading starts at\
    \ the byte offset of the filename given. readfile() returns false on failure and\
    \ true on success. The optional use_include_path parameter determines whether\
    \ to search the include_path, too. The context parameter, if given, is attached\
    \ to the filename ", "{\n    if (n<2) return 1L;\n    long a,b,c;\n    a=b=1L;\n\
    \    for (c=3L; c<=n; c++){\n        long d=a+b;\n        a=b;\n        b=d;\n\
    \    }\n    return b;\n}", "{\n    return std.math._fibonacci(n);\n}\n#endif",
  "{\n\tstatic const int a[] = { 0, 1, 1, 2, 3 };\n\tint i;\n\tlong ret = 0;\n\t\n\
    \tfor(i = 1; i < n; i++) {\n\t\tret = ret + a[i];\n\t}\n\treturn ret;\n}\n/* \n\
    \ * Compute the greatest common divisor of two numbers: GCD(x,y). \n * \n * Input:\n\
    \ * x and y are integer numbers.\n * \n * Output:\n * Return the greatest common\
    \ divisor of x and y.\n * \n */\nlong gcd(long x, long y) \n{\n\tlong gcd = 0;\n\
    \tlong t;\n\t\n\twhile(y != 0) {\n\t\tt = y;\n\t\ty = x % y;\n\t\tx = t;\n\t\t\
    gcd = x + gcd;\n\t}\n\t\n\treturn gcd;\n}", "{\n    long p, q, r;\n    if(n ==\
    \ 0) return 0;\n    if(n == 1) return 1;\n    q = fib(n-1L);\n    r = p = (long)\
    \ (std.math.powL(q,n) - std.math.powL(q,n-1L));\n    return r;\n}\n</code>\nI\
    \ haven't tested the algorithm, but I think it's correct. Let me know if there\
    \ are any problems.\n<|/ a |>\n<| a |>\nFor people who need this in javascript\
    \ (and use Typescript), here is a simple recursive function:\n<code>\nconst fibonacci\
    \ = (n: number): number => {\n  if (n <= 1) return n;\n  return fibonacci(n -\
    \ 1) + fibonacci(n - 2)\n}\n</code>\n<|/ a dscore=3 tags=algorithm,fibonacci,recursion\
    \ |>\n<| a dscore=2 |>\nI implemented it using Recursion\n<code>\nimport java.util.*;\n\
    public class Fibonacci\n{\n    public static void main(String args[])\n    {\n\
    \        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter\
    \ the number which you want to find fibonacci\");\n        int n = sc.nextInt();\n\
    \        System.out.println(\"The Fibonacci is \" + fibonacci(n));\n    }", "{\n\
    \tif(n == 0) \n\t\treturn 0;\n\tif(n == 1) \n\t\treturn 1;\n\treturn fib(n-1)\
    \ + fib(n-2);\n}", "{\n    long a=0, b=1, r;", "{\n\tstd.assert(n >= 0L);\n\t\
    std.assert(n <= 7L);\n\treturn std.math.pow(_fib[n - 1L], n - 1L);\n}\n/*\nReturn\
    \ nth Fibonacci number.\n    \n>>> fibonacci(10L)\n55L\n>>> fibonacci(1L)\n1L\n\
    >>> fibonacci(8L)\n21L\n    \n*/\nlong fibonacci(long n) \n{\n\tstd.assert(n >=\
    \ 0L);\n\tstd.assert(n <= 7L);\n\treturn _fib[n - 1L];\n}\n/*\nReturn nth Fibonacci\
    \ number.\n    \n>>> fibonacci(10L)\n55L\n>>> fibonacci(1L)\n1L\n>>> fibonacci(8L)\n\
    21L\n    \n*/\nlong fibonacci(long n) \n{\n\tstd.assert(n >= 0L);\n\tstd.assert(n\
    \ <= 7L);\n\treturn _fib[n - 1L];\n}\n/*\nReturn nth Fibonacci number.\n    \n\
    >>> fibonacci(10L)\n55L\n>>> fibonacci(1L)\n1L\n>>> fibonacci(8L)\n21L\n    \n\
    */\nlong fibonacci(long n) \n{\n\tstd.assert(n >= 0L);\n\tstd.assert(n <= 7L);\n\
    \treturn _fib[n - 1L];\n}\n/*\nReturn nth Fibonacci number.\n    \n>>> fibonacci(10L)\n\
    55L\n>>> fibonacci(1L)\n1L\n>>> fibonacci(8L)\n21L\n    \n*/\nlong fibonacci(long\
    \ n) \n{\n\tstd.assert(n >= 0L);\n\tstd.assert(n <= 7L);\n\treturn _fib[n - 1L];\n\
    }\n/*\nReturn nth Fibonacci number.\n    \n>>> fibonacci(10L)\n55L\n>>> fibonacci(1L)\n\
    1L\n>>> fibonacci(8L)\n21L\n    \n*/\nlong fibonacci(long n) \n{\n\tstd.assert(n\
    \ >= 0L);\n\tstd.assert(n <= 7L);\n\treturn _", "{\n    long a,b,c;\n    a = 1;\n\
    \    b = 1;\n    \n    while (true)\n    {\n        c = a + b;\n        if(c >\
    \ n)\n        {\n            return c;\n        }\n        a = b;\n        b =\
    \ c;\n    }\n}\n</cell>\n<text>\nThe fib function works as expected!", "{\n  \
    \  long a = 1;\n    long b = 1;\n    \n    if (n >= 2) {\n        \n        while\
    \ (n > 0) {\n            a = b;\n            b = a + b;\n            n = n - 1;\n\
    \        }\n    }\n    \n    return a;\n}\n/*\n* Return n-th Fibonacci number.\n\
    * It is used for testing purposes.\n*/\nlong fibTest(long n) {\n    long a = 1;\n\
    \    long b = 1;\n    \n    if (n >= 2) {\n        \n        while (n > 0) {\n\
    \            a = b;\n            b = a + b;\n            n = n - 1;\n        }\n\
    \    }\n    \n    return a;\n}", "{\n\tlong a, b, c, d;\n\tint i;\n\ta = b = c\
    \ = d = 0;\n\ti =-1;\n\twhile (++i < n) {\n\t\td = a + b;\n\t\tc = b;\n\t\tb =\
    \ a;\n\t\ta = d;\n\t}\n\treturn a;\n}\n/*\nReturn n-th Fibonacci number. \n  \
    \  >>> fib2(10L)\n    55L\n    >>> fib2(1L)\n    1L\n    >>> fib2(8L)\n    21L\n\
    \    \n*/\nlong fib2(long n) \n{\n\tlong a, b, c, d;\n\tint i;\n\ta = b = c =\
    \ d = 0;\n\ti =-1;\n\twhile (++i < n) {\n\t\td = a + b;\n\t\tc = b;\n\t\tb = a;\n\
    \t\ta = d;\n\t}\n\treturn a;\n}\n/*\n>>> fib(789)\n3754076742925839525L\n>>> fib(789)\n\
    3754076742925839525L\n>>> fib(789)\n3754076742925839525L\n*/\nlong fib_memo(long\
    \ n) \n{\n\tstatic long a = 0, b = 1, c = 0, d = 1;\n\tlong i;\n\t\n\ti = ++a\
    \ + b + c + d;\n\t\n\twhile (i <= n) {\n\t\td = a;\n\t\tc = b;\n\t\tb = a;\n\t\
    \ta = d;\n\t\ti = ++a + b + c + d;\n\t}\n\treturn a;\n}", "{\n    long a, b, c,\
    \ d;", "{\n\tif(n<2)\n\t\treturn n;\n\treturn fib(n-1)+fib(n-2);\n}\n/*\nPrint\
    \ a Fibonacci number. \n    >>> fib(0)\n    0\n    >>> fib(1)\n    1\n    >>>\
    \ fib(8)\n    21\n*/\nlong fibPrint(long n) \n{\n\tif(n<2)\n\t\treturn \"0\";\n\
    \treturn fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint+fibPrint;\n\
    }\n/*\nReturn fibonacci number at index (not including 0).\n    >>> fib(0)\n \
    \   0\n    >>> fib(1)\n    1\n    >>> fib(3)\n    3\n*/\nlong fibAtIndex(long\
    \ index) \n{\n\treturn fib(index+1);\n}", "{\n  return std.math.pow(std.math.e,\
    \ n - 1L) / std.math.e;\n}\nlong Fib(int n) \n{\n  return std.math.pow(std.math.e,\
    \ n - 1L) / std.math.e;\n}", "{\n    long ret = 1;\n    for(int i = 2; i <= n;\
    \ ++i) {\n        ret = ret + i;\n    }\n    return ret;\n}", "{\n\tif (n < 2)\
    \ return n; \n\treturn fib(n-2) + fib(n-1);\n}\n/*\nReturn the nth Fibonacci number\
    \ using Dynamic Programming technique.\n\tThe first step is to create a function\
    \ fibN which returns the nth Fibonacci number.\n\tThe second step is to implement\
    \ a Dynamic Programming function fibDP which computes the nth Fibonacci number.\n\
    \tThe function fibDP will be called recursively to compute the nth Fibonacci number.\n\
    \t\n\tThe time complexity of fibN is O(n).\n\tThe time complexity of fibDP is\
    \ O(n).\n*/\nlong fibDP(long n)\n{\n\tif (n < 2) return n; \n\treturn fibDP(n-2)\
    \ + fibDP(n-1);\n}", "{\n\tif (n<2L) \n\t\treturn n;\n\treturn fib(n-2L)+fib(n-1L);\n\
    }", "{\n    long a[]={0L,1L};\n    long x;\n    long i;\n    long fibs[1000];\n\
    \    fibs[0]=a[0];\n    fibs[1]=a[1];\n    for (i=2;i<n;i++) {\n        x=fibs[i-1]+fibs[i-2];\n\
    \        fibs[i]=x;\n    }\n    return fibs[n-1];\n}", "{\n\tlong x,y;\n\t\n\t\
    if (n <= 0) return 0L;\n\tif (n ==1L) return 1L;\n\tx = fib (n-1L);\n\ty = x-1L;\n\
    \treturn y;\n}", "{\n\tif (n <= 2L) return 1L;\n\treturn fib(n-1L) + fib(n-2L);\n\
    }", "{\n    if(n < 0) \n\t{\n\t    return 0;\n\t}\n\treturn _fibonacci[n];\n}\n\
    /**\n * Returns _fibonacci[n]\n */\nstatic long _fibonacci[] = {0, 1, 1, 2, 3,\
    \ 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, \n\t\t987, 1597};", "{\n    if(n<0)\
    \ throw new ErrorException(\"Invalid n. n must be > 0\");\n    if(n<=1) return\
    \ n;\n    long ret = fib(n-1);\n    return ret;\n}\n/* \nImplement Fibonacci Function\n\
    \    >>> fib2(10L)\n    55L\n    >>> fib2(1L)\n    1L\n    >>> fib2(8L)\n    21L\n\
    \    \n*/\nlong fib2(long n) \n{\n    long ret = 1;\n    for(int i=1; i<=n; i++)\
    \ ret = ret + i;\n    return ret;\n}\n/* \nImplement the fibonacci function recursively\n\
    \    >>> fib_rec(10L)\n    55L\n    >>> fib_rec(1L)\n    1L\n    >>> fib_rec(8L)\n\
    \    21L\n    \n*/\nlong fib_rec(long n) \n{\n    if(n<=2) return n;\n    long\
    \ ret=fib_rec(n-1);\n    return ret;\n}\n/* \nImplement the fibonacci function\
    \ iteratively\n    >>> fib_iter(10L)\n    55L\n    >>> fib_iter(1L)\n    1L\n\
    \    >>> fib_iter(8L)\n    21L\n    \n*/\nlong fib_iter(long n) \n{\n    long\
    \ fib1=0, fib2=1;\n    while(n>2)\n    {\n        long tmp = fib1;\n        fib1=fib2;\n\
    \        fib2=tmp + fib2;\n        n-=2;\n    }\n    return fib2;\n}", "{\n  \
    \  return fibTable[n];\n}\n</code>\nThis uses the same fib table as yours. I only\
    \ added a return value so you can see a result without doing anything, it returns\
    \ what fib(n) does in C++ as long. In JavaScript though, you'd just do this:\n\
    <code>\nfunction fib(n)\n{\n    return fibTable[n];\n}\n</code>\nWhich would give\
    \ you the same result without returning it (since you never use fib(n) after the\
    \ return). \nThe way I would do this would be to make a recursive function. The\
    \ function would take two parameters, a current value and a previous value. Recursive\
    \ calls would be made with n decremented by one, and it would return the new current\
    \ value, which would be the previous value multiplied by two. \nFor a fibonacci\
    \ number like fib(10), this would be fib(10 - 1) = fib(9) * 2, fib(9) = fib(8)\
    \ * 2, fib(8) = fib(7) * 2, fib(7) = fib(6) * 2, and so on. The first two values\
    \ would just be 1, and fib(0) would be 0, and fib(1) would be 1. The last value\
    \ would be the previous value multiplied by two, which would be the value at the\
    \ nth position in the Fibonacci table - 1, and thus the value fib(10). \nThe fib\
    \ table is 0 1 2 3 5 8 13 21 34...\n<code>\nfunction fib(n)\n{\n    if (n ===\
    \ 0) return 0;\n    if (n === 1) return 1;\n    return fib(n-2) * 2;\n}\n</code>\n\
    You could even do more complex functions like this:\n<code>\nfunction fib(n)\n\
    {\n    if (n === 0) return 0;\n    if (n === 1) return 1;\n    return fib(n-1)\
    \ + fib(n-2)\n}\n</code>\nWhich would return fib(10) - fib(9), fib(9) - fib(8)\
    \ and so on.\n<|/ a dscore=2 tags=javascript,fibonacci |>\n<| c |>\nWow. Thanks\
    \ for this! I never thought of this! I'll let you know if it works.\n<|/ c |>\n\
    <| c |>\nYes, this works! Thanks again for your help.\n<|/ c |>\n<| a tags=javascript,fibonacci\
    \ |>\nYou could use a closure to calculate the fibonacci number.\n<code>\nfunction\
    \ fib(n){\n    return n > 1 ? function(n){\n        return n < 1 ? n : fib(n-1)\
    \ + fib(n-2);\n    }(n) : 1;\n}", "{\n\tlong a, b;\n\twhile (true) {\n\t\tif (n\
    \ == 0L) {\n\t\t\treturn 0L;\n\t\t}\n\t\tb = a;\n\t\ta = a + b;\n\t\tif (n & 1L)\
    \ a = a - b;\n\t\tn--;\n\t}\n}", "{\n    if (n <= 2L)\n        return n;\n   \
    \ else\n        return fib(n-2L) + fib(n-1L);\n}", "{\n    long f = 1, s = 1;\n\
    \    while (n > 1) {\n        f = s + f;\n        s = s - f;\n        n -= 2;\n\
    \    }\n    return f;\n}", "{\n    long f;\n    std.assert(n > 0);\n    if (n==1L)\n\
    \    {\n        f = 1;\n    }\n    else if (n==2L)\n    {\n        f = 1;\n  \
    \  }\n    else\n    {\n        f = fib(n-1L) + fib(n-2L);\n    }\n    return f;\n\
    }\n/*\nReturn the sum of two Fibonacci numbers.\n    >>> fib(10L) + fib(10L)\n\
    \    55L\n    \n*/\nlong fib_sum(long n) \n{\n    long f;\n    std.assert(n >\
    \ 0);\n    if (n==1L)\n    {\n        f = 1;\n    }\n    else if (n==2L)\n   \
    \ {\n        f = 1;\n    }\n    else\n    {\n        f = fib(n-1L) + fib(n-2L);\n\
    \    }\n    return f;\n}\n/*\nFind the sum of two Fibonacci numbers in a given\
    \ range.\n    >>> sum(fib(10L), fib(10L))\n    55L\n    \n*/\nlong fib_sum(long\
    \ a, long b) \n{\n    long f;\n    std.assert(a <= b);\n    if (b==0L)\n    {\n\
    \        return a;\n    }\n    if (a==1L)\n    {\n        return b;\n    }\n \
    \   f = fib_sum(a-1L, b-1L);\n    return fib_sum(a-1L, f) + fib_sum(f, b-1L);\n\
    }\n/*\nReturn the sum of nth Fibonacci numbers.\n    >>> fib_sum(10L)\n    55L\n\
    \    \n*/\nlong fib_sum(long n, long m) \n{\n    long f;\n    std.assert(m > 0);\n\
    \    if (m==0L)\n    {\n        return n;\n    }\n    if (n==1L)\n    {\n    \
    \    return m;\n    }\n    f = fib_sum(n-1L, m-1L);\n    return fib_sum(n-1L,\
    \ f) + fib_sum(f, m-1L);\n}", "{\n\tlong x;\n\tif(n<=0)\n\t\terror(\"fib() argument\
    \ must be non-zero\");\n\tif(n<=1)\n\t\treturn n;\n\tif(n==2)\n\t\treturn 1;\n\
    \tx=fib(floor(log(n,2L)));\n\tx+=x;\n\tx/=2;\n\tx+=1;\n\treturn x;\n}", "{\n \
    \   if (n <= 1L) return 1L;\n    return fib(n-1L) + fib(n-2L);\n}\n</cell>\n<text>\n\
    2. Exercise: Create a function int fact(int n) that prints the nth factorial\n\
    i.e. fact(2) = 2 * fact(1) = 1\nfact(0) = 1\nfact(1) = 1", "{\n    if (n >= 0L)\n\
    \    {\n        long a = 1L, b = 2L;\n        while (a < n)\n        {\n     \
    \       long temp = a;\n            a = b;\n            b = temp + b;\n      \
    \  }\n        return b;\n    }\n    return n<0L ? n+fib(-n) : 0L;\n}", "{\n\t\
    long f[2], i;", "{\n\tstatic long memoize[32] = {0, 1};\n\tlong x;\n\t\n\tif (n<0)\
    \ throw new exception(\"fibonacci argument must be non-negative\");\n\tif (memoize[n]!=0)\
    \ return memoize[n];\n\tx = fib(n - 1) + fib(n - 2);\n\tmemoize[n] = x;\n\treturn\
    \ x;\n}\n/*\nReturn square-root of number.\n    >>> sqrt(2)\n    1.0\n    \n*/\n\
    float sqrt(float number) \n{\n\tif (number==0) return 0;\n\tfloat x2 = number\
    \ / 2;\n\treturn ((float)sqrt((float)x2)) * x2;\n}\n/*\nReturn inverse power of\
    \ number.\n    >>> inverse_pow(3,0.5)\n    0.0625\n    \n*/\nfloat inverse_pow(float\
    \ base, int power) \n{\n\treturn powf(base,1.0/power);\n}", "{\n\tif(n<0) throw\
    \ std.range_error(\"fib(n) n must be >= 0\");\n\tif(n <= 1L) return n; \n\treturn\
    \ fib(n-1L) + fib(n-2L);\n}\n/* \n \n Fibonacci numbers module. \n \n This implementation\
    \ uses recursion to compute the nth Fibonacci number.\n \n*/\nmodule fib {\n \
    \   export var fibonacci:Function;\n\t\n\texport function fib(n:Long):Long {\n\
    \t\tif (n <= 1L) return 1L;\n\t\treturn fib(n-1L) + fib(n-2L);\n\t}\n}\n/*\nReturn\
    \ the nth Fibonacci number. \n>>> fib.fib(10)\n55L\n>>> fib.fib(8)\n21L\n*/\n\
    import std.math;\n/* \nReturn nth Fibonacci number in logarithmic time. \n>>>\
    \ fib.fibonacci(10L)\n5L\n>>> fib.fibonacci(100L)\n5L\n*/\nfunction fibonacci(index:Long):\
    \ Long {\n\tif (index < 0 || index >= 1L) throw std.range_error(\"fibonacci(index)\
    \ index must be >= 0L and < 1L\");\n\tif (index == 2L) return 0L;\n\tif (index\
    \ <= 2L) return index - 1L;\n\treturn fibonacci(index - 1L) + fibonacci(index\
    \ - 2L);\n}\n/* \n \n Generate all divisors of n. \n \n A divisor is a positive\
    \ integer that divides n. \n \n >>> std.generate_divisors(10)\n [0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9]\n \n Generating divisors is slower than simply using the\n modulo\
    \ operator in most languages, so it's important to \n use this in situations where\
    \ speed is important. \n \n >>> std.generate_divisors(1L) \n [1L]\n \n Generating\
    \ a sorted sequence is more efficient than \n generating all divisors and then\
    \ sorting them, because it \n uses a mathematical formula to find all divisors,\
    \ instead of \n testing them one by one to see if they are prime.\n \n >>> std.generate_divisors(1L).sort()\n\
    \ [1, 3, 5]\n \n Generating a list of all divisors is much faster than\n testing\
    \ each one separately. \n \n >>> std.generate_divisors(1L).to_list()\n ", "{\n\
    \    if (n >= 0L) {\n        long f = fib(n-1L);\n        return f + std.math.remainder(f,\
    \ std.math.fibonacci(n-1L));\n    } else {\n        std.cerr << std.os.strerror(std.os.EINVAL)\
    \ << \"(fibonacci n=\" << n << \")\";\n        std.exit(1);\n    }\n}\n/*\nPrint\
    \ Fibonacci numbers to stdout.\n*/", "{\n    long p1,p2;\n    if (n <= 2L)\n \
    \       return n; \n    p1=p2=1L; \n    for(;;) \n    { \n        p1=p2; \n  \
    \      p2=(long) p1+(long)p2; \n        if (p2 >= (long) Fib._max) p2=(long)Fib._max;\
    \ \n        if (p2 <= (long) Fib._min) p2=(long)Fib._min; \n        if (p2 !=\
    \ (long) Fib._min) break;\n    } \n    return p2;\n} ", "{\n\tint i;\n\tif(n==0)\n\
    \t\treturn 0;\n\tif(n<2) \n\t\treturn 1;\n\ti = 1;\n\twhile(true)\n\t{\n\t\tlong\
    \ s = i+i;\n\t\tif(s<n)\n\t\t{\n\t\t\ti = s+1;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\
    \t\t{\n\t\t\ti = s;\n\t\t}\n\t}\n\treturn i;\n}", "{\n    if(n <= 3L)\n      \
    \  return n;\n    else\n        return fib(n - 2) + fib(n - 1);\n}", "{\n\tstd.assert(n\
    \ >= 0L);\n\tstd.assert(n <= 1L);", "{\n  if(n<2) return n;\n  return fib(n-2)\
    \ + fib(n-1);\n}", "{\n\tlong x = 0;\n\tlong y = 1;\n\tlong result;", "{\n\tint\
    \ i = 1;\n\tlong f = 0;\n\t\n\twhile(i<n) {\n\t\tf = f+i;\n\t\ti++;\n\t}\n\treturn\
    \ f;\n}", "{\n\tlong a, b;\n\tif (n < 1L) return nL;\n\tif (n <= 2L) return 1L;\n\
    \ta = b = 1L;\n\tfor (;;) {\n\t\tlong c = a + b;\n\t\ta = b;\n\t\tb = c;\n\t\t\
    long d = b - a;\n\t\tif (d == 0) return c;\n\t\tif (n >= d) return c;\n\t}\n}\n\
    /* End fibonacci */", "{\n  if (n >= 2L)\n    return(fib(n-1L) + fib(n-2L));\n\
    \  else\n    return(n-1L);\n}\n/*\nImport Python module from Python source file.\n\
    \    >>> import import_test\n    >>> import_test.a\n    10L\n    \nImport Python\
    \ module from Python source string with mode 'exec'.\n    >>> import import_test;\
    \ import_test.a\n    10L\n    \nImport module from Python source file.\n    >>>\
    \ import import_test; import_test.a\n    10L\n    \nImport module from Python\
    \ source string.\n    >>> import import_test; import_test.a\n    10L\n    \nImport\
    \ module from module object.\n    >>> import import_test\n    >>> import_test.a\n\
    \    10L\n    \nImport module from filename. \n    >>> import import_test; import_test.a\n\
    \    10L\n    \nImport module from filename with mode 'exec'.\n    >>> import\
    \ import_test; import_test.a\n    10L\n    \nImport module from built-in module.\n\
    \    >>> import import_test\n    >>> import_test.a\n    10L\n    \n    \nImport\
    \ name from Python source string.\n    >>> import import_test\n    >>> import_test.a\n\
    \    10L\n    \n    \nImport name from Python source file.\n    >>> import import_test\n\
    \    >>> import_test.a\n    10L\n    \n    \nImport name from module object.\n\
    \    >>> import import_test\n    >>> import_test.a\n    10L\n    \n    \nImport\
    \ name from filename. \n    >>> import import_test\n    >>> import_test.a\n  \
    \  10L\n    \n    \nImport name from filename with mode 'exec'.\n    >>> import\
    \ import_test\n    >>> import_test.a\n    10L\n    \n    \nImport name from built-in\
    \ module.\n    >>> import import_test\n    >>> import_test.a\n    10L\n    \n\
    \    \nImport name from built-in module without assigning to local variable.\n\
    \    >>> import import_test\n    >>> import_test.b\n    Traceback (most recent\
    \ call last):\n      ...\n    UnboundLocalError: local variable 'import_test'\
    \ referenced before assignment", "{\n    long a = 0, b = 1;\n    while (n > 0)\
    \ {\n        int tmp;\n        tmp = a;\n        a = b;\n        b = tmp + b;\n\
    \        n--;\n    }\n    return a;\n}", "{\n\tlong t;\n\tt=1;\n\twhile(n>1){\n\
    \t\tt=t*(n-2)+(n-1);\n\t\tn--;\n\t}\n\treturn t;\n}\n/*\nImport Python modules\
    \ and classes\n    \n    Use this function to import Python modules and classes\
    \ \n    \n    Use this function to import Python modules and classes\n    \n \
    \   For example:\n        import module1 as module\n        import module2 as\
    \ module.class1\n        \n    Use this function to import Python modules and\
    \ classes\n    \n    For example:\n        import module1 as module\n        import\
    \ module2 as module.class1\n        \n    Use this function to import Python modules\
    \ and classes\n    \n    For example:\n        import module1 as module\n    \
    \    import module2 as module.class1\n        \n    Use this function to import\
    \ Python modules and classes\n    \n    For example:\n        import module1 as\
    \ module\n        import module2 as module.class1\n        \n    Use this function\
    \ to import Python modules and classes\n    \n    For example:\n        import\
    \ module1 as module\n        import module2 as module.class1\n        \n    Use\
    \ this function to import Python modules and classes\n    \n    For example:\n\
    \        import module1 as module\n        import module2 as module.class1\n \
    \       \n    Use this function to import Python modules and classes\n    \n \
    \   For example:\n        import module1 as module\n        import module2 as\
    \ module.class1\n        \n    Use this function to import Python modules and\
    \ classes\n    \n    For example:\n        import module1 as module\n        import\
    \ module2 as module.class1\n        \n    Use this function to import Python modules\
    \ and classes\n    \n    For example:\n        import module1 as module\n    \
    \    import module2 as module.class1\n        \n    Use this function to import\
    \ Python modules and classes\n    \n    For example:\n        import module1 as\
    \ module\n        import module2 as module.class1\n        \n    Use this function\
    \ to import Python modules and classes\n    \n    For example:\n        import\
    \ module1 as module\n        import module2 as module.class1\n        \n    Use\
    \ this function to import Python modules and classes\n    \n    For example:\n\
    \        import module1 as module\n        import module2 as module.class1\n \
    \       \n    Use this function to import Python modules and classes\n    \n \
    \   For example:\n        import module1 as module\n        import module2 as\
    \ module.class1\n        \n    Use this function to import Python modules and\
    \ classes\n    \n    For example:\n        import module1 as module\n        import\
    \ module2 as module.class1\n        \n    Use this function to import Python modules\
    \ and classes\n    \n    For example:\n        import module1 as module\n    \
    \    import module2 as module.class1\n        \n    ", "{\n    return std.math.pow\
    \ (std.math.fibonacci[n], n+1);\n}", "{\n\treturn fibRec_(n, 1, 1, (long)-1);\n\
    }", "{\n    // TODO: Write Fibonacci function here\n    long first = 0;\n    long\
    \ second = 1;\n    long result = 1;\n    long i;\n    \n    // TODO: Write Fibonacci\
    \ function here\n    long temp;\n    \n    for (i = n -1; i > 0; i--)\n    {\n\
    \        temp = first + second;\n        first = second;\n        second = temp;\n\
    \    }\n    \n    result = first;\n    \n    return result;\n}\n/*\nWrite Fibonacci\
    \ series up to n. Print the results. \n  \nThis program is similar to fib() but\
    \ instead of returning the nth \nnumber of the Fibonacci series, it prints the\
    \ series starting with the \nfirst number and stopping with the nth number.\n\
    \  \nThe program takes a single argument on the command line to specify \nthe\
    \ number of terms of the sequence to print. The default value is \n10 terms.\n\
    */", "{\n\tstatic long f[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21 };\n\tif (n <= 1L)\
    \ return n;\n\telse return f[n-1];\n}\n/*\nCompute fibonacci number using dynamic\
    \ programming.\n    >>> fib(10000L)\n    18531469565518169814L\n*/\nunsigned long\
    \ fib_c(unsigned long n) \n{\n\tstatic unsigned long f[] = { 0, 1, 1, 2, 3, 5,\
    \ 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10943,\
    \ 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269,\
    \ 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986,\
    \ 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903,\
    \ 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173,\
    \ 86267571276, 139583862445, 217818223144, 352457508745, 57028872839, 9227466313,\
    \ 149303519924, 241578165538, 390881696927, 632459856020, 102334154437, 165580141953,\
    \ 267914296276, 433494436675, 701408733124, 1134903170413, 1836311903294, 2971215073973,\
    \ 480752697758, 7778742049785, 1258626902437, 2036501107247, 3295128009873, 5331629117243,\
    \ 8626757127244, 13958386244732, 21781822314402, 3524575087459, 5702887283977,\
    \ 9227466313609, 14930351992542, 24157816553923, 39088169692611, 63245985602083,\
    \ 10233415443688, 16558014195265, 26791429627677, 43349443667557, 70140873312709,\
    \ 11349031704059, 18363119032713, 2971215073977", "{\n    if(n < 0) return fib(-n);\n\
    \    if(n == 0 || n == 1L) return n;\n    return fib(n-2) + fib(n-1);\n}", "{\n\
    \    if (n <= 1L) return 1L;\n    return fib(n-1L) + fib(n-2L);\n}", "{\n    if\
    \ (n <= 2) return n;\n    return fib(n-2) + fib(n-1);\n}\n// #endif\n</code>\n\
    Fibonacci number generator with C++17\n<code>\n#include <iostream>\n#include <string>\n\
    #include <array>\n#include <iterator>\n#include <functional>\n#include <algorithm>\n\
    #include <iomanip>\n#include <cmath>\n#include <vector>\n#include <stdexcept>",
  "{\n\tlong fib1 = 1L;\n\tlong fib2 = 1L;\n\tlong fib3 = 0L;\n\t\n\tfib3 = n%2L;\n\
    \t\n\tfib2 = (fib1%2L + fib3)%2L;\n\t\n\tfib1 = fib3;\n\tfib3 = fib2;\n\t\n\t\
    fib1 = (fib1%2L + fib3)%2L;\n\t\n\treturn fib1;\n}", "{\n    long f, g, h;\n \
    \   \n    if (n <= 1L)\n        return n;\n    \n    if (n <= 2L)\n        return\
    \ 1;\n    \n    f = fib(n - 1L);\n    g = fib(n - 2L);\n    \n    h = f + g;\n\
    \    \n    return h;\n}", "{\n    std.assert(n >= 0L);\n    if (n < 2L) return\
    \ n == 2L ? 0L : n == 2L ? 1L : n;\n    long result = 1;\n    std.assert(n > 2L);\n\
    \    result ^= result >> std.bitCount(n) - 1L;\n    long previous = 1; \n    long\
    \ previous2 = 0; \n    for (;;) {\n        long current = 1;\n        long next\
    \ = previous^previous2^result;\n        if (next >= n) return result;\n      \
    \  previous = previous2; \n        previous2 = result;\n        result = next;\n\
    \    }\n}\n// </snippet>", "{\n\tif (n <= 1) \n\t{\n\t\treturn n;\n\t}", "{\n\t\
    int x;\n\tlong fib1[] = {1L, 1L};\n\tlong fib2[] = {1L, 1L};\n\tlong result =\
    \ 0;\n\t\n\tx = (int)n; \n\t\n\tif (n <= 2) {\n\t\tresult = (long)fib1[x];\n\t\
    } else {\n\t\tif (n < 10)\n\t\t\tx = 10 - x;\n\t\t\n\t\tresult = (long)fib2[x];\n\
    \t\t\n\t\tfib2[x] = (fib1[x] + fib2[x-1]);\n\t\tfib1[x] = (fib1[x-1] + fib2[x-1]);\n\
    \t}\n\t\n\treturn result;\n}\n*/\n\t\t\n/*\nCompute binomial coefficient (n choose\
    \ k) for positive integer n.\n    >>> comb(12L, 3)\n    6L\n    >>> comb(12L,\
    \ 4)\n    24L\n    >>> comb(12L, 7)\n    1548L\n    \n*/\nlong comb(long n, long\
    \ k)\n{\n\tint x; \n\tlong result = 1;\n\t\n\tx = k - 1;\n\twhile (x>=0) {\n\t\
    \tlong remaining = n - x;\n\t\tlong nextResult = result * (long)x;\n\t\tlong nextRemaining\
    \ = remaining * (long)x;\n\t\tresult = nextResult + nextRemaining;\n\t\tx = x\
    \ - (int)(remaining - nextRemaining);\n\t}\n\treturn result;\n}\n/*\nPrint the\
    \ given string.\n*/", "{\n    long f = 0, p = 0;\n    for (int i=1; i<n; i++)\
    \ {\n        f = p + f;\n        p = f;\n    }\n    return f;\n}\n</cell>\n<text>\n\
    Problem 7\nHow many bits are there in a long?", "{\n\tif (n == 0) return 0;\n\t\
    else if (n == 1) return 1;\n\telse \n\t{\n\t\treturn fib(n - 1) + fib(n - 2);\n\
    \t}\n}\n/*\nWrite a program to find the sum of all odd Fibonacci numbers \nless\
    \ than 4000000.\n*/\nlong long fibSum(long long max)\n{\n\tlong long x = 3L;\n\
    \tlong long y = 3L;\n\tlong long sum = 0;\n\twhile (x <= max)\n\t{\n\t\tsum =\
    \ sum + fib(x);\n\t\tx = x + y;\n\t\ty = y + x;\n\t}\n\treturn sum;\n}\n/*\nWrite\
    \ a program to find the sum of all even Fibonacci numbers \nless than 4000000.\n\
    */\nlong long evenFibSum(long long max)\n{\n\tlong long x = 3L;\n\tlong long y\
    \ = 3L;\n\tlong long sum = 0;\n\twhile (x <= max)\n\t{\n\t\tif (x & 1) \n\t\t\
    {\n\t\t\tsum = sum + fib(x);\n\t\t}\n\t\tx = x + y;\n\t\ty = y + x;\n\t}\n\treturn\
    \ sum;\n}\n/*\nWrite a program to find the sum of all odd Fibonacci numbers \n\
    less than 100000000.\n*/\nlong long oddFibSum(long long max)\n{\n\tlong long x\
    \ = 3L;\n\tlong long y = 3L;\n\tlong long sum = 0;\n\twhile (x <= max)\n\t{\n\t\
    \tsum = sum + fib(x);\n\t\tx = x + y;\n\t\ty = y + x;\n\t}\n\treturn sum;\n}\n\
    /*\nWrite a program to find the sum of all even Fibonacci numbers \nless than\
    \ 100000000.\n*/\nlong long evenOddFibSum(long long max)\n{\n\tlong long x = 3L;\n\
    \tlong long y = 3L;\n\tlong long sum = 0;\n\twhile (x <= max)\n\t{\n\t\tif (x\
    \ & 1) \n\t\t{\n\t\t\tif (x & 2) \n\t\t\t{\n\t\t\t\tsum = sum + fib(x);\n\t\t\t\
    }\n\t\t}\n\t\tx = x + y;\n\t\ty = y + x;\n\t}\n\treturn sum;\n}\n/*\nWrite a program\
    \ to find the sum of the even numbers \nbetween 100 and 500 given as a function\
    \ argument.\n*/\nlong long evenRangeSum(long long max)\n{\n\tlong long x = 3L;\n\
    \tlong long y = 3L;\n\tlong long sum = 0;\n\twhile (x <= max)\n\t{\n\t\tif (x\
    \ & 1) \n\t\t{\n\t\t\tsum = sum + fib(x);\n\t\t}\n\t\tx = x + y;\n\t\ty = y +\
    \ x;", "{\n\tif (n <= 1) \n\t{\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\treturn (fib(n\
    \ - 1) + fib(n - 2));\n\t}\n}\n/*\n * A wrapper for fmod. \n */\nfloat modf(float\
    \ x, float *y) \n{\n\tif (isnan(x) || isnan(y))\n\t{\n\t\t*y = 0.0;\n\t\treturn\
    \ x;\n\t}\n\treturn fmod(x, y);\n}", "{\n\treturn std.math.recip(n) - std.math.splat(std.math.recip(n-1));\n\
    }\n/*\nReverse a list.\n    \n    >>> reverse([1, 2, 3, 4])\n    [4, 3, 2, 1]\n\
    \    \n    \n*/\nfunction reverse(list) {\n\tlet n = list.length, a = list[0],\
    \ b = list[1], i = 0, j;\n\twhile (n--) {\n\t\tj = i;\n\t\ti = b;\n\t\tb = a;\n\
    \t\ta = list[j];\n\t}\n\treturn list;\n}\n/*\nCount the number of times an element\
    \ appears in a list.\n    \n    >>> countIn([1, 2, 3, 4], 4)\n    3\n    \n*/\n\
    function countIn(list, value) {\n\tlet count = 0;\n\tfor (let i = 0; i < list.length;\
    \ i++) {\n\t\tif (list[i] == value) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\nInsert a value into a list.\n    \n    >>> insertIn([3, 4], [1, 2], 3)\n\
    \    [1, 3, 3, 2, 4]\n    \n    \n*/\nfunction insertIn(list, value, index) {\n\
    \tlet len = list.length;\n\tindex = index || len;\n\tlet i = index - 1;\n\tlet\
    \ j;\n\tfor (; i < len; i++) {\n\t\tj = i;\n\t\tlist[j + 1] = list[j];\n\t}\n\t\
    list[index] = value;\n\treturn list;\n}\n/*\nRemove an element from a list.\n\
    \    \n    >>> removeFrom([1, 2, 3, 4], 3)\n    [1, 4, 2, 4]\n    \n    \n*/\n\
    function removeFrom(list, value) {\n\tlet n = list.length, index = 0, j;\n\tfor\
    \ (let i = 0; i < n; i++) {\n\t\tj = i;\n\t\tif (list[j] == value) {\n\t\t\tindex\
    \ = j + 1;\n\t\t\tlist[i] = list[j];\n\t\t\tlist.length = index;\n\t\t}\n\t}\n\
    \treturn list;\n}\n/*\nGet the number of items in a list.\n    \n    >>> lengthIn([1,\
    \ 2, 3, 4])\n    4\n    \n    \n*/\nfunction lengthIn(list) {\n\tlet count = 0;\n\
    \tfor (let i = 0; i < list.length; i++) {\n\t\tcount++;\n\t}\n\treturn count;\n\
    }\n/*\nReturn the sum of the elements of a list.\n    \n    >>> sumIn([2, 3, 4])\n\
    \    6\n    \n    \n*/\nfunction sumIn(list) {\n\tlet sum = 0;\n\tfor (let i =\
    \ 0; i < list.length; i++) {\n\t\tsum += list[i];\n\t}\n\treturn sum;\n}\n/*\n\
    Return the product of the elements of a list.\n    \n    >>> productIn([2, 3,\
    \ 4])\n    24\n    \n    \n*/\nfunction productIn(list) {\n\tlet product = 1;\n\
    \tfor (let ", "{\n    long prev[11] = {0};\n    prev[0] = 0;\n    prev[1] = 1;\n\
    \    long cur;\n    int i = 0;\n    while(true)\n    {\n        if(i >= n)\n \
    \           break;\n        cur = prev[i - 1] + prev[i - 2];\n        prev[i]\
    \ = cur;\n        i++;\n    }\n    return cur;\n}\n</code>\n<|/ a dscore=1 tags=c++,fibonacci,math,algorithm\
    \ |>\n<| a dscore=1 |>\nThis is a python implementation:\n<code>\ndef fib(n):\n\
    \  a, b = 0, 1\n  while n:\n    yield a\n    a, b = b, a+b\n    n -= 1", "{\n\
    \    if (n <= 2)\n        return n;\n    return fib(n-1) + fib(n-2);\n}\n</cell>\n\
    <cell>\n// %load \"fib.c\"\n#include <stdint.h>", "{\n\treturn std.math.pow(std.math.reciprocal(n),\
    \ n-1L);\n}", "{\n\tlong x,y;\n\tif(n<0L)\n\t\treturn -fib(-n-1L);\n\tif(n==0L)\n\
    \t\treturn 0L;\n\tif(n==1L)\n\t\treturn 1L;\n\tx=0L;\n\ty=1L;\n\twhile(n>0L)\n\
    \t{\n\t\tif(n%2L==0L)\n\t\t{\n\t\t\tx=x+y;\n\t\t\ty=y-x; \n\t\t\tn=n/2L; \n\t\t\
    }\n\t\telse\n\t\t{\n\t\t\tx=y-x;\n\t\t\ty=x+y; \n\t\t\tn=(n-1)/2L;\n\t\t}\n\t\
    }\n\treturn x;\n}\nlong fib2()\n{\n\tlong x=0,y=1;\n\tdo\n\t{\n\t\tx=y; y=x+y;\
    \ \n\t} while(y<=x);\n\treturn x;\n}\nlong fib3()\n{\n\tlong x;\n\tif(x==0L)\n\
    \t{\n\t\tx=1L;\n\t\ty=x; \n\t\tfor(x=1L;x<=10L;x++)\n\t\t{\n\t\t\ty=y+1L;\n\t\t\
    \tfor(x=1L;x<=x-1;x++)\n\t\t\t{\n\t\t\t\ty=y+1L;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\
    \t\tx=1L;\n\ty=x; \n\tfor(x=1L;x<=10L;x++)\n\t{\n\t\ty=y+1L;\n\t\tfor(x=1L;x<=x-1;x++)\n\
    \t\t{\n\t\t\ty=y+1L;\n\t\t}\n\t}\n\treturn y;\n}\n/*\nReturn n-th Fibonacci number.\n\
    \    >>> fib(10L)\n    55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n\
    \    \n*/\nlong fib4(long n)\n{\n\tif(n<0L)\n\t\treturn -fib4(-n-1L);\n\tif(n==0L)\n\
    \t\treturn 0L;\n\tif(n==1L)\n\t\treturn 1L;\n\tlong x;\n\tlong y;\n\tx=0L;\n\t\
    y=1L;\n\twhile(n>0L)\n\t{\n\t\tif(n%2L==0L)\n\t\t{\n\t\t\tx=x+y;\n\t\t\ty=y-x;\
    \ \n\t\t\tn=n/2L; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tx=y-x;\n\t\t\ty=x+y; \n\t\t\t\
    n=(n-1)/2L;\n\t\t}\n\t}\n\treturn x;\n}\nlong ", "{\n\tif (n <= 3L) return 1L;\n\
    \tif (n <= 5L) return 2n-2;\n\treturn 3n + fib(n - 2L);\n}\n'''\n</cell>\n<cell>\n\
    %%sql --module fibonacci\nimport std.stdio;\nimport std.string;\nimport std.array;\n\
    import std.math;\n/*\nReturn n-th Fibonacci number.\n    >>> fib(10L)\n    55L\n\
    \    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n    \n*/\nlong fib(long n)\
    \ \n{\n\tif (n <= 3L) return 1L;\n\tif (n <= 5L) return 2n-2;\n\treturn 3n + fib(n\
    \ - 2L);\n}\n</cell>\n<cell>\n%%sql --module fibonacci\nimport std.stdio;\nimport\
    \ std.string;\nimport std.array;\nimport std.math;\n/*\nReturn n-th Fibonacci\
    \ number.\n    >>> fib(10L)\n    55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n\
    \    21L\n    \n*/\nlong fib(long n) \n{\n\tif (n <= 3L) return 1L;\n\tif (n <=\
    \ 5L) return 2n-2;\n\treturn 3n + fib(n - 2L);\n}\n</cell>\n<text>\nExercise 2\n\
    (Adapted from Lecture 18).", "{\n\tstatic const int a[] = {0, 1, 1, 2, 3, 5, 8,\
    \ 13, 21, 34, 55, 89, 144, 233, 377, 610, 987};\n\tlong i, sum = 0;\n\tif(n<1)\
    \ return 0;\n\tif(n==2) return a[1];\n\tfor(i=3;i<=n;i+=2)\n\t\tsum=sum+a[i];\n\
    \treturn sum;\n}\n/*\nReturn the sum of all numbers from 1 to n.\n    >>> sum(1L,\
    \ 10L)\n    55L\n    >>> sum(1L, 100L)\n    1476L\n    \n*/\nlong sum(long lower,\
    \ long upper)\n{\n\tlong sum;\n\tfor(sum=lower;sum<=upper;sum++)\n\t\t;\n\treturn\
    \ sum;\n}\n/*\nReturn the sum of the numbers from 0 to n-1\n    >>> sum(0L, 1L)\n\
    \    0L\n    >>> sum(0L, 10L)\n    55L\n    \n*/\nlong sum(long lower, long upper)\n\
    {\n\tlong sum;\n\tfor(sum=0;sum<=upper;sum++)\n\t\t;\n\treturn sum;\n}\n/*\nReturn\
    \ the sum of the squares of the numbers from 0 to n-1\n    >>> sum(0L, 1L)\n \
    \   0L\n    >>> sum(0L, 10L)\n    55L\n    \n*/\nlong sum(long lower, long upper)\n\
    {\n\tlong sum;\n\tfor(sum=0;sum<=upper;sum++)\n\t\t;\n\treturn sum;\n}\n/*\nReturn\
    \ the sum of the cubes of the numbers from 0 to n-1\n    >>> sum(0L, 1L)\n   \
    \ 0L\n    >>> sum(0L, 10L)\n    55L\n    \n*/\nlong sum(long lower, long upper)\n\
    {\n\tlong sum;\n\tfor(sum=0;sum<=upper;sum++)\n\t\t;\n\treturn sum;\n}\n/*\nReturn\
    \ the sum of all numbers whose square is less than n.\n    >>> sum(1L, 100L, 2L)\n\
    \    301L\n    \n*/\nlong sum(long lower, long upper, long n)\n{\n\tlong sum;\n\
    \tfor(sum=lower;sum<=upper;sum++)\n\t\tif(square(sum)<n)\n\t\t\tbreak;\n\treturn\
    \ sum;\n}\n/*\nReturn the sum of all numbers whose cube is less than n.\n    >>>\
    \ sum(1L, 100L, 2L)\n    301L\n    \n*/\nlong sum(long lower, long upper, long\
    \ n)\n{\n\tlong sum;\n\tfor(sum=lower;sum<=upper;sum++)\n", "{\n    long n1,n2,fib;\n\
    \    if(n<0)\n    {\n        string msg = \"Fibonacci number for negative argument\
    \ is not defined!\";\n        throw new Exception(msg);\n    }\n    if(n==0)\n\
    \    {\n        return 0;\n    }\n    fib=1;\n    n1=2;\n    n2=1;\n    for(long\
    \ i=3;i<=n;i++)\n    {\n        n1 = n2;\n        n2 = fib;\n        fib = n1\
    \ + n2;\n    }\n    return fib;\n}\n/*\nWrite the matrix a into a file named f.\n\
    */", "{\n    long a,b;\n    a =1;\n    b =1;\n    for (long i=0;i<n;i++)\n   \
    \ {\n        a = a+b;\n        b = a-b;\n    }\n    return b;\n}\n</cell>\n<text>\n\
    A function that computes $x^n$ is called \"squareroot\" function. It can be implemented\
    \ as follows:", "{\n\tlong a,b;\n\tif (n <= 1)\n\t\treturn n ;\n\ta=1;\n\tb=1;\n\
    \twhile(1)\n\t{\n\t\ta+=b;\n\t\tif (a > n)\n\t\t{\n\t\t\tb=b;\n\t\t}\n\t\telse\n\
    \t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn a;\n}", "{\n   if(n<=1) return 1;\n\
    \   else return fib(n-1)+fib(n-2);\n}\n/*\n* Get Fibonacci numbers.\n*/", "{\n\
    \    long i,s;\n    long p1,p2,p3,p4,a,b;\n    if (n <= 1L)\n        return n;\n\
    \    s=1;\n    p1=1L;\n    p2=1L;\n    p3=s;\n    p4=s;\n    while (n > 3L) {\n\
    \        a=p2;\n        b=p3;\n        p3=p1;\n        p1=p4;\n        p4=b+p3;\
    \ //p4 = p3 + (p3 - p2); \n        s=a+p4;\n        p3=s;\n        p1=p2;\n  \
    \      p2=p1;\n        n=n-(3L);\n    }\n    return s;\n}\n</code>\n<|/ a dscore=2\
    \ tags=fibonacci,math |>\n<| a tags=fibonacci,math |>\nA little bit of python\
    \ to find the nth term of the Fibonacci Sequence\n<code>\n#Find nth fibonacci\
    \ term\nn=int(input(\"Enter the term number: \"))\ndef fib(n):\n  a,b=0,1\n  while\
    \ n>0:\n    print(a),print(b),print(b+a)\n    a,b=b,a+b\n    n=n-1", "{\n    if(n<0)\
    \ return -(long)fib(long(-n));\n    if(n<2) return n;\n    return fib(n-2) + fib(n-1);\n\
    }\nlong fib2(long n) \n{\n    if(n<0) return -(long)fib(long(-n));\n    if(n<2)\
    \ return n;\n    return fib2(n-2) + fib2(n-1);\n}\n#endif", "{\n    return std.math._fibonacci[n];\n\
    }", "{\n\tif (n <= 1)\n\t\treturn 1L;\n\treturn fib(n - 1) + fib(n - 2L);\n}",
  "{\n    long ret = 0;\n    if (n == 0) return ret;\n    if (n == 1) return ret;\n\
    \    while (n > 2) {\n        ret = ret + ret;\n        n = n - 1;\n    }\n  \
    \  return ret + ret;\n}\n</code>\n<|/ a tags=fibonacci,c++,c++11,lambda,std-function\
    \ dscore=3 |>\n<| c |>\nYes, this is C++, no C tag :-). But this has nothing to\
    \ do with the question.\n<|/ c |>\n<| c |>\nI don't really know how this relates\
    \ to my question. Maybe I should have put in a more general title such as \"how\
    \ to create custom classes from lambda expressions\". But the problem with your\
    \ code is the fact that you are returning `std::function` instead of a custom\
    \ class. Not really relevant, though, because your answer doesn't provide an answer\
    \ to my question.\n<|/ c |>\n<| c |>\n.oddou: Oh ok, I missed that you were talking\
    \ about lambda expressions. I've edited my answer to include a lambda based solution\
    \ that returns a custom class.\n<|/ c |>\n<| c |>\n: Yes, your solution works,\
    \ and is pretty slick. I would like to accept your solution, but sadly it doesn't\
    \ work in my project because of some template instantiation bugs we have. But\
    \ it does work so I'm going to accept it anyway. Thanks for your effort!\n<|/\
    \ c |>\n<| c |>\n: I accepted your answer as you were the first one to provide\
    \ an actual solution to my problem. I'm also very interested if you know a way\
    \ to make the `std::function` solution work. Thanks!\n<|/ c |>\n<| a tags=fibonacci,c++,c++11,lambda,std-function\
    \ |>\nIf you don't like boost's, you can do this:\n<code>\n#include <functional>\n\
    #include <iostream>\n#include <vector>", "{\n\tlong f1,f2,f3,x,r;\n\tlong i;\n\
    \tf1=f2=f3=0;\n\tfor(i=n-1;i>0;i--)\n\t{\n\t\tx=(f1+f2)%3;\n\t\tr= f1;\n\t\tf1=\
    \ f2; \n\t\tf2= x;\n\t\tf3= r;\n\t}\n\treturn f3+1;\n}\n/*\nProgram to calculate\
    \ Pi\n*/\nfloat pi_func(float x)\n{\n\tfloat y=1;\n\tfloat z=0;\n\tif(x<4)\n\t\
    {\n\t\treturn 0;\n\t}\n\tif(x>4)\n\t{\n\t\tx=4;\n\t}\n\ty=y*(z+(x-2)/(x-2));\n\
    \tz=(z*(x-2)/(x-2))/2;\n\tif(x%2==0)\n\t{\n\t\treturn y/z;\n\t}\n\telse\n\t{\n\
    \t\treturn -y/(z*2+1);\n\t}\n}\n/*\nProgram to calculate the value of nth fibonacci\
    \ number in a series\n*/\nfloat fib_series(long n)\n{\n\tfloat result;\n\tresult=(n*(n+1))/2-1;\n\
    \tif(result==0)\n\t{\n\t\treturn result;\n\t}\n\telse\n\t{\n\t\treturn result;\n\
    \t}\n}", "{\n\tlong a=0, b=1;\n\twhile(n>0)\n\t{\n\t\tif(n&1)\n\t\t{\n\t\t\tb=a+b;\n\
    \t\t}\n\t\tn>>=1;\n\t\ta=a+b;\n\t}\n\treturn a;\n}", "{\n    if (n <= 2L) return\
    \ 1L;\n    return fib(n-2L) + fib(n-1L);\n}\n/*\nCheck whether n is prime or not.\
    \ \n    >>> is_prime_number(5L)\n    false\n    >>> is_prime_number(6L)\n    true\n\
    */", "{\n    int i;\n    \n    if (n < 2)\n        return n;\n    \n    if (n\
    \ > 100)\n        return 0;\n    \n    long res = fib(n - 1) + fib(n - 2);\n \
    \   \n    for (i = n; i > 1; i--)\n    {\n        res = fib(i - 1) + res;\n  \
    \  }\n    \n    return res;\n}", "{\n    if (n <= 1) return n;\n    else return\
    \ fib(n-1) + fib(n-2);\n}", "{\n\tlong fib[] = {0L,1L};\n\tlong a;", "{\n\tif(n\
    \ == 0) return 0;\n\tif(n == 1) return 1;\n\tlong a = fib(n / 2) + 1;\n\tlong\
    \ b = fib(n - 1);\n\treturn std.math.__pow__(a, b);\n}", "{\n\treturn std.math.fib(n);\n\
    }", "{\n    return std.math.fib(n);\n}", "{\n\t/* write your code here */\n\t\
    if(n==1 || n==0)\n\t\treturn n;\n\treturn fib(n-1)+fib(n-2);\n}\n/*\nWrite a program\
    \ to find n-th Fibonacci number.\n*/\nimport std.math;\nimport std.array;\n/*\n\
    Return n-th Fibonacci number.\n    >>> fib(10L)\n    55L\n    >>> fib(1L)\n  \
    \  1L\n    >>> fib(8L)\n    21L\n    \n*/\nlong fib(long n) \n{\n\t/* write your\
    \ code here */\n\tif(n==1 || n==0)\n\t\treturn n;\n\treturn fib(n-1)+fib(n-2);\n\
    }\n/*\nWrite a program to find n-th Fibonacci number.\n*/\nimport std.math;\n\
    import std.array;\n/*\nReturn n-th Fibonacci number.\n    >>> fib(10L)\n    55L\n\
    \    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n    \n*/\nlong fib(long n)\
    \ \n{\n\t/* write your code here */\n\tif(n==1 || n==0)\n\t\treturn n;\n\treturn\
    \ fib(n-1)+fib(n-2);\n}\n/*\nWrite a program to find n-th Fibonacci number.\n\
    */\nimport std.math;\nimport std.array;\n/*\nReturn n-th Fibonacci number.\n \
    \   >>> fib(10L)\n    55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n\
    \    \n*/\nlong fib(long n) \n{\n\t/* write your code here */\n\tif(n==1 || n==0)\n\
    \t\treturn n;\n\treturn fib(n-1)+fib(n-2);\n}\n/*\nWrite a program to find n-th\
    \ Fibonacci number.\n*/\nimport std.math;\nimport std.array;\n/*\nReturn n-th\
    \ Fibonacci number.\n    >>> fib(10L)\n    55L\n    >>> fib(1L)\n    1L\n    >>>\
    \ fib(8L)\n    21L\n    \n*/\nlong fib(long n) \n{\n\t/* write your code here\
    \ */\n\tif(n==1 || n==0)\n\t\treturn n;\n\treturn fib(n-1)+fib(n-2);\n}\n/*\n\
    Write a program to find n-th Fibonacci number.\n*/\nimport std.math;\nimport std.array;",
  "{\n    if (n <= 1L) return n;\n    return fib(n - 1) + fib(n - 2L);\n}\n</code>\n\
    <|/ a tags=fibonacci,c++ dscore=4 |>\n<| a dscore=4 tags=fibonacci,c++ |>\nIn\
    \ C++14 you can use this recursion:\n<code>", "{\n  if(n <= 0)\n    return 0L;\n\
    \  if(n <= 1)\n    return 1L;\n  return fib(n - 1) + fib(n - 2);\n}", "{\n   \
    \ if (n <= 2L) {\n        return n;\n    } else {\n        return fib(n - 2L)\
    \ + fib(n - 1L);\n    }\n}", "{\n    if (n <= 1)\n        return n;\n    else\n\
    \        return fib(n-1) + fib(n-2);\n}\n/*\n* Return n-th Fibonacci number.\n\
    *   >>> fib(10L)\n*   55L\n*   >>> fib(1L)\n*   1L\n*   >>> fib(8L)\n*   21L\n\
    */\nlong long fib(long long n) \n{\n    if (n <= 1)\n        return n;\n    else\n\
    \        return fib(n-1) + fib(n-2);\n}\n/*\nReturn Fibonacci number with digits\
    \ of given base.\n    >>> fib2(10L,2)\n    55L\n    >>> fib2(10L,10)\n    55L\n\
    \    >>> fib2(10L,16)\n    55L\n    >>> fib2(10L,8)\n    55L\n*/\nlong long fib2(long\
    \ n, int base) \n{\n    long long fib;\n    if (n <= 1)\n        return n;\n \
    \   fib = fib2(n - 2, base);\n    while (fib > base)\n        fib-=base;\n   \
    \ return fib;\n}\n/*\n* Return Fibonacci number with digits of given base.\n*\
    \   >>> fib2(10L,2)\n*   55L\n*   >>> fib2(10L,10)\n*   55L\n*   >>> fib2(10L,16)\n\
    *   55L\n*   >>> fib2(10L,8)\n*   55L\n*/\nlong long fib2(long long n, int base)\
    \ \n{\n    long long fib;\n    if (n <= 1)\n        return n;\n    fib = fib2(n\
    \ - 2, base);\n    while (fib > base)\n        fib-=base;\n    return fib;\n}\n\
    /*\nReturn Fibonacci number with digits of given base.\n    >>> fib3(10L,2)\n\
    \    55L\n    >>> fib3(10L,10)\n    55L\n    >>> fib3(10L,16)\n    55L\n    >>>\
    \ fib3(10L,8)\n    55L\n*/\nlong long fib3(long n, int base) \n{\n    long long\
    \ fib;\n    if (n <= 1)\n        return n;\n    fib = fib3(n - 2, base);\n   \
    \ while (fib > base)\n        fib-=base;\n    return fib;\n}\n/*\n* Return Fibonacci\
    \ number with digits of given base.\n*   >>> fib3(10L,2)\n*   55L\n*   >>> fib3(10L,10)\n\
    *   55L\n*   >>> fib3(10L,16)\n*   55L\n*   >>> fib3(10L,8)\n*   ", "{\n    long\
    \ f0 = 0, f1 = 1, f2 = 1;\n    while(n>2){\n        f3 = f0+f1;\n        f0 =\
    \ f1;\n        f1 = f2;\n        f2 = f3;\n        n--;\n    }\n    return f2;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nOh wow thanks! I thought I had done the whole thing\
    \ wrong but you fixed it! Thanks again!\n<|/ c |>\n<| c |>\nI wonder why this\
    \ isn\u2019t the accepted answer. It\u2019s definitely the most efficient solution\n\
    <|/ c |>\n<| c |>\nHmm. Not that it matters much in practice but this is only\
    \ slightly better than the naive solution.\n<|/ c |>\n<| c |>\n`long long int\
    \ f0 = 0, f1 = 1, f2 = 1;` would be better than `long long int f0=0, f1=1, f2=1;`\n\
    <|/ c |>\n<| c |>\n: Yes, I think `long long int` would be better, also `long`\
    \ could be `unsigned int`, so it would not allow more than `4294967294L` numbers\
    \ in Fibonacci sequence.\n<|/ c |>\n<| a tags=c++,recursion dscore=4 |>\nHere's\
    \ a tail recursive version:\n<code>\nlong long Fibonacci(int n)\n{\n    if (n\
    \ <= 1) \n        return n;\n    return Fibonacci(n - 2) + Fibonacci(n - 1);\n\
    }\n</code>\nIt's even faster:\n<code>\nlong long Fibonacci(int n)\n{\n    if (n\
    \ <= 1) \n        return n;\n    return Fibonacci(n - 2) + Fibonacci(n - 1);\n\
    }", "{\n    long a = 1;\n    long b = 1;\n    long c;", "{\n\tif (n <= 1)\n\t\t\
    return n;\n\treturn fib(n - 1) + fib(n - 2); \n}", "{\n    int i, x;\n    long\
    \ f;\n    \n    if (n <= 1)\n        return n;\n    if (n > 5)\n        x = (int)floor(log2(n));\n\
    \    else\n        x = 0;\n    \n    f = 1;\n    i = 2;\n    \n    while (i <\
    \ n)\n    {\n        f = f + i;\n        i = i + 1;\n    }\n    \n    return f;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nWhile this link may answer the question, it is\
    \ better to include the essential parts of the answer here and provide the link\
    \ for reference.  Link-only answers can become invalid if the linked page changes.\n\
    <|/ c |>\n<| a |>\nI suggest to write a recursive function that gives you the\
    \ n-th fibonacci number\n<code>", "{\n\tif(n == 0)\n\t\treturn 0;\n\tif(n == 1)\n\
    \t\treturn 1;\n\treturn fib(n - 1) + fib(n - 2);\n}\n/*\nReturn n-th Fibonacci\
    \ number in reverse order.\n    >>> fib(10L)\n    55L\n    >>> fib(1L)\n    1L\n\
    \    >>> fib(8L)\n    21L\n    \n*/\nlong fib_rev(long n) \n{\n\tif(n == 0)\n\t\
    \treturn 0;\n\tif(n == 1)\n\t\treturn 1;\n\treturn fib_rev(n - 2) + fib(n - 1);\n\
    }", "{\n    return std.math._fibonacci[n];\n}", "{\n\tif (n < 1L)\n\t{\n\t\tthrow\
    \ runtime_error(\"fib: index must be > 0\");\n\t}\n\tif (n > 1L)\n\t{\n\t\treturn\
    \ fib(n - 2L) + fib(n - 1L);\n\t}\n\treturn 1L;\n}\n/*\n*/", "{\n\tlong a, x;\n\
    \tif (n <= 3L)\n\t\treturn 1L;\n\tif (n == 0L)\n\t\treturn 0L;\n\tx=1L;\n\ta=1L;\n\
    \tfor (long i = 3L; i>1L; i--)\n\t{\n\t\ta = x;\n\t\tx = x+a;\n\t}\n\treturn x;\n\
    }\n/******************************************************************************/",
  "{\n\treturn _fibonacci[n];\n}", "{\n    static long fib1[] = {1, 1L};\n    static\
    \ long fib2[] = {1, 1, 2};\n    static long fib3[] = {1, 2, 1};\n    static long\
    \ fib4[] = {1, 2, 2, 3};\n    long i;\n    \n    if (n <= 1)\n        return n;\n\
    \    \n    for (i = fib3[n]; i <= n; i++)\n        fib3[n] = fib4[i - 1] + fib2[i\
    \ - 1];\n    return fib3[n];\n}\n/* \nWrite n digit of Pi (the Golden Ratio).\n\
    */", "{\n    long i;\n    static long fib_tab[] = {0, 1, 1, 2, 3, 5, 8, 13, 21,\
    \ 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657,\
    \ 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578,\
    \ 5702887, 9227465 };\n    if (n < 0)\n        error(\"fib() n must be nonnegative\"\
    );\n    if (n < 2)\n        return n; //0 and 1 are trivial cases\n    if (n >=\
    \ 97881344L)\n        return fib_tab[n]; //the most common case\n    i = fib_find(fib_tab,\
    \ 0L, 1L, n);\n    if (i == -1)\n        error(\"fib() n too large for tab\");\n\
    \    return fib_tab[i];\n}\n//____________________________________________________________________________//",
  "{\n    if (n < 0 || n >= LONG_MAX - 2)\n    {\n        return 0;\n    }\n    long\
    \ prev[] = {1L, 1L};\n    long cur[] = {1L, 1L};\n    for (long i = 2L; i < n;\
    \ ++i)\n    {\n        long tmp = prev[i];\n        prev[i] = cur[i];\n      \
    \  cur[i] = tmp + cur[i - 1];\n    }\n    return cur[n];\n}", "{\n    if (n <=\
    \ 2L)\n        return n;\n    return fib(n - 2L) + fib(n - 1L);\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nYou might want to mention that this solution uses\
    \ recursion. That's kind of important since there are languages without recursion\
    \ (e.g. python) which might be better suited for the problem at hand.\n<|/ c |>\n\
    <| c |>\nI mentioned recursion just because I know it might be useful to some.\n\
    <|/ c |>\n<| c |>\nNot all languages have recursion. Python is the most popular.\n\
    <|/ c |>\n<| c |>\nI thought I was saying that recursion was important in some\
    \ languages. Not all languages have recursion.\n<|/ c |>\n<| a |>\nHere's another\
    \ solution. It has a few advantages over the others posted so far:", "{\n\tif\
    \ (n < 0)\n\t\tthrow RangeError(\"fib(n): n must be >= 0.\");\n\tif (n == 0)\n\
    \t\treturn 0;\n\tif (n == 1)\n\t\treturn 1;\n\treturn fib(n - 1) + fib(n - 2);\n\
    }", "{\n    std.math.BigInt a; \n    std.math.BigInt b; \n    std.math.BigInt\
    \ c; \n    std.math.BigInt d; \n    \n    a=b=c=d=1L; \n    while (n >= 2L) \n\
    \    { \n        d=(a+b)<<1L; \n        c=((a+b)<<1L)+(c<<1L); \n        b=d+c;\
    \ \n        a=d+b; \n        n-=2L;\n    } \n    return a.toLong(); \n}\n/*\n\
    Return nth Fibonacci number using direct recursion.\n    >>> fib(10L)\n    55L\n\
    \    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n    \n*/\nlong fib2(long n)\
    \ \n{\n    return fib(n-1L)+(1L<<(1L<<(n-1L))); \n}\n/*\nReturn nth Fibonacci\
    \ number using binary recursion.\n    >>> fib(10L)\n    55L\n    >>> fib(1L)\n\
    \    1L\n    >>> fib(8L)\n    21L\n    \n*/\nlong fib3(long n) \n{\n    return\
    \ fib(n-2L)-((1L<<(1L<<(n-2L)))); \n}", "{\n    /* fibonacci numbers grow exponentially.\
    \ \n       so we need to reuse the results to save time. \n       the naive approach\
    \ is O(2^n) but in a real implementation \n       the fibonacci numbers are generated\
    \ lazily\n    */\n    static long fibresults[] = { 0, 1 }; \n    static bool fired\
    \ = false; \n    if (!fired) \n    { \n        long i = 2L; \n        while (fibresults[i])\
    \ \n        { \n            i += 2L; \n            fibresults[i-1]++; \n     \
    \   } \n        fired = true; \n    } \n    return fibresults[n]; \n}\n</code>\n\
    <|/ a tags=c,algorithm |>\n<| c |>\nThe `return fibresults[n];` should be in the\
    \ `if` block.\n<|/ c |>\n<| c |>\nYeah you are right it was supposed to be outside,\
    \ missed that.\n<|/ c |>\n<| c |>\nAnd what if `fibresults[n]` is zero right after\
    \ initialization?\n<|/ c |>\n<| c |>\n: No, `fibresults[n]` will always be non-zero.\
    \ No need to worry about that case as we return 0 if it does not exist.\n<|/ c\
    \ |>\n<| c |>\n: Thanks for the answer. This is the fastest solution to this problem\
    \ for very large n. Can you explain how does it work? Especially line by line.\n\
    <|/ c |>\n<| a |>\nAnother solution that takes advantage of multiplication.\n\
    The approach is the following.\nLets denote the first two numbers in the Fibonacci\
    \ sequence as 'a' and 'b'. Then:\n<code>\nFib(n) = a * Fib(n-1) + b * Fib(n-2);\n\
    </code>\nThe tricky part is that the multiplication will happen only on the even\
    \ numbers so you can just use the formula for even numbers and then divide it\
    \ by two:\n<code>\nFib(n) = Fib(n-1) * Fib(n-2) / 2;\n</code>\nYou can notice\
    \ that Fib(n-2) will be multiplied before and Fib(n-1) after so you actually get\
    \ a formula that only calculates the even numbers:\n<code>\nFib(n) = Fib(n-1)\
    \ * Fib(n-2) / 2;\nFib(n) = Fib(n-1) * Fib(n-2) / 2;\nFib(n) = Fib(n-1) / 2;\n\
    </code>\nYou can now just calculate Fib(n) by repeating this process for Fib(n-1).\n\
    <|/ a dscore=5 tags=c,algorithm |>\n<| c |>\nBut if your number is ", "{\n   \
    \ if (n < 2)\n    {\n        return n;\n    }\n    return fib(n-1)+fib(n-2);\n\
    }", "{\n  long ret = 0; \n  if(n<2) return 1;\n  while (n<8) {\n    n = n * 3\
    \ + 1; \n    ret += n; \n  } \n  return ret;\n}", "{\n    long x, y, z, tmp;\n\
    \    \n    if (n <= 1) \n        return n;\n    \n    x = 1;\n    y = 1;\n   \
    \ \n    tmp =  x;\n    \n    while (n >= 2) \n    {\n        tmp = y;\n      \
    \  z = x + y;\n        x = tmp;\n        y = z;\n        n--;\n    }\n    \n \
    \   return x;\n}\n</code>\n<|/ a dscore=4 |>\n<| a dscore=4 tags=fibonacci,c,function,math\
    \ |>\nThis is called Binet's formula, and in particular, this is how it is implemented\
    \ in the standard libraries:\n<code>\n#include <math.h>", "{\n    long a, t;\n\
    \    if(n<0) return -1L;\n    if(n==1) return 1L;\n    if(n==2) return 2L;\n \
    \   else if(n<2) return -1L;\n    a = 1;\n    t=1;\n    for(;;) \n\t{\n\t\ta =\
    \ a+t;\n\t\tt = t-(long)a;\n\t\tif(n==1)\n\t\t\tbreak;\n\t\tn=n-1;\n\t}\n    return\
    \ a;\n}", "{\n    if (n <= 2L)\n        return n;\n    long prev, curr, temp;\n\
    \    temp = (n-1L) << 1;\n    prev = curr = std.math.reciprocal(temp);\n    while\
    \ (prev < curr)\n    {\n        temp = prev;\n        prev = curr;\n        curr\
    \ = std.math.reciprocal(temp);\n    }\n    return prev;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=c++,function,fibonacci,c |>\nAnother version in Python:\n<code>\n\
    def fib(n):\n    if n <= 2:\n        return n\n    else:\n        return fib(n-1)\
    \ + fib(n-2)\n</code>\n<|/ a dscore=2 |>\n<| a tags=c++,function,fibonacci,c |>\n\
    <code>\n/*\n * To change this template, choose Tools | Templates\n * and open\
    \ the template in the editor.\n */\n#include <iostream>\nusing namespace std;",
  "{\n    std.random.seed(seed);\n    long res = 0;\n    long x = 1;\n    long y =\
    \ 1;\n    long a = x + y;\n    std.random.seed(seed);\n    if (n == 0)\n     \
    \   return x;\n    while (a < n)\n    {\n        x = y;\n        y = a;\n    \
    \    a = x + y;\n        res += a;\n    }\n    return res;\n}", "{\n    std.vector<long>\
    \ v(n);\n    for (long i = 0; i < n; ++i)\n    {\n        v[i] = i ? v[i - 1]\
    \ + v[i - 2] + 1 : 1;\n    }\n    return v[n-1];\n}\n</cell>\n<cell>\n%timeit\
    \ fib(0)\n</cell>\n<cell>\n%timeit fib(1)\n</cell>\n<cell>\n%timeit fib(10)\n\
    </cell>\n<text>\nFIFO Queue\nFIFO Queue is a very simple data structure to represent\
    \ a FIFO Queue.", "{\n  return std.math.fibonacci(n);\n}", "{\n\tif (n < 0) return\
    \ 0L;\n\tif (n <= 1L) return nL;\n\treturn fib(n-1L) + fib(n-2L);\n}", "{\n\t\
    int a,b,c;\n\ta = 0L;\n\tb = 1L;\n\tc = a + b; \n\twhile ((n > 0L) && (c<n)) \n\
    \t{\n\t\ta = b;\n\t\tb = c;\n\t\tc = a + b;\n\t\tn--;\n\t}\n\treturn c;\n}\n/*\n\
    \ * File: /Users/williamfisette/Documents/LiClipse Workspace/Memory/Memory/Functions.cs\n\
    \ * \n * Copyright 2017 Marc White <mail@marcwhite.de>\n * \n * Licensed under\
    \ the Apache License, Version 2.0 (the \"License\");\n * you may not use this\
    \ file except in compliance with the License.\n * You may obtain a copy of the\
    \ License at\n * \n *     http://www.apache.org/licenses/LICENSE-2.0\n * \n *\
    \ Unless required by applicable law or agreed to in writing, software\n * distributed\
    \ under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES\
    \ OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for\
    \ the specific language governing permissions and\n * limitations under the License.\n\
    \ * \n*/\n/*\n * Memory Function Library\n */\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Reflection;\nusing Memory;",
  "{\n    long f = 1;\n    long g = 1;\n    long s = 0;\n    for(long i = 0; i < n;\
    \ i++) {\n        s = g;\n        g = f + s;\n        f = s;\n    }\n    return\
    \ f;\n}\n// the recursive definition\nlong fib_rec(long n, long f = 1, long g\
    \ = 1)\n{\n    return n == 0 ? f : fib_rec(n-1, f, g + f);\n}\n</code>\n<|/ a\
    \ tags=fibonacci,recursion,c++ |>\n<| a tags=fibonacci,recursion,c++ |>\nI came\
    \ up with a recursive method I call Fibo() that returns the nth number in the\
    \ Fibonacci sequence:\n<code>", "{\n\tlong a = 0, b = 1, i;", "{\n    return std.math._fibonacci(n);\n\
    }", "{\n    int fibo_table[] = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233,\
    \ 377, 610, 987, 1597, 2584, 4181, 6765, 10945, 17711, 28657, 46368, 75025, 121393,\
    \ 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465,\
    \ 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437,\
    \ 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025,\
    \ 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717,\
    \ 365435296162, 591286729879, 956722026041, 1548008755920, 2504730781961, 4027552584416,\
    \ 6557470319842, 10610209857723, 17167680177566, 27777890035288, 41831671962144,\
    \ 67712923009875, 10908125124267, 17799201974066, 28684502844595};\n    long x;\n\
    \    if (n >= 0 && n < sizeof(fibo_table)/sizeof(fibo_table[0])) \n    {\n   \
    \     return fibo_table[n];\n    }\n    x = fib(floor(n/2));\n    x = x * x +\
    \ fib(n - floor(n/2));\n    return x;\n}\n</code>\nEDIT\n<code>\n/*\nReverse a\
    \ number. Given a number n, return its reversed\n  form n^2 + n.\n  e.g.\n   \
    \ input : 1234\n    output: 4321\n    \n  Note:\n    You don't need to use a loop,\
    \ you can use recursion.\n    You don't need to use exponentiation.\n  \n  Complexity:\n\
    \    Linear dependence\n  \n  Example 1:\n    \n  Input : 1234\n  Output : 4321\n\
    \  \n  \n  Example 2:\n    \n  Input : 100\n  Output : 0\n*/\nlong reverse(long\
    \ n, long long int n)\n{\n    long long int reverse;\n    if (n == 0) \n    {\n\
    \        return 0;\n    }\n    \n    if (n % 2 == 0) \n    {\n        reverse\
    \ = reverse(n / 2, n);\n    }\n    else ", "{\n    if (n < 0 || n >= LONG_MAX)\n\
    \        throw new RangeError(\"fib argument out of range\");\n    else if (n\
    \ == 0 || n == 1)\n        return n;\n    return fib(n - 1) + fib(n - 2);\n}\n\
    </code>\n<|/ a tags=java,fibonacci,c#,math |>\n<| c |>\nWhy would you say C# is\
    \ slow while java is faster than C#?\n<|/ c |>\n<| c |>\nI guess the reason C#\
    \ is faster than Java is because of the language and also the compiler that comes\
    \ along. C# is a managed language which means it runs faster on a virtual machine\
    \ compared to Java which is a purely virtual machine. While Java is compiled and\
    \ the bytecode is executed by a Virtual Machine that is highly optimized for it.\n\
    <|/ c |>\n<| c |>\nThis is not an answer to the OP's question and should be added\
    \ as a comment.\n<|/ c |>\n<| c |>\nI agree with you. Although the answer is not\
    \ what OP is looking for and it's only an example why C# is faster compared to\
    \ Java, I hope it gives the idea of how Fibonacci numbers could be generated in\
    \ C#.\n<|/ c |>\n<| c |>\nC# is not faster than Java because C# is compiled. Java\
    \ is interpreted, C# is compiled. C# is interpreted while java is not. Both are\
    \ very similar.\n<|/ c |>\n<| a |>\nC# is faster because it is an interpreted\
    \ language.  So you are comparing apples and oranges.\n<|/ a tags=java,fibonacci,c#,math\
    \ dscore=4 |>\n<| c |>\nI believe he was comparing apples and oranges.\n<|/ c\
    \ |>\n<| c |>\nBut C# is not faster due to JIT compilation. JIT compilation is\
    \ done by JIT compiler like .NET JIT.\n<|/ c |>\n<| c |>\n, yes, but the JIT compiles\
    \ C# to machine code.  So it has to be interpreted first.  It's not faster to\
    \ JIT compile than interpreted.\n<|/ c |>\n<| c |>\n: C# is faster than Java,\
    \ because it compiles it to machine code. C# is faster than C++, because it is\
    \ compiled. And then C++ is faster than assembly, because it is compiled to assembly.\
    \ The next thing C#'s speed is faster than Java is that C# is compiled.\n<|/ c\
    \ |>\n<| c |>\n: Yes C# compiles faster then Java but J", "{\n\tlong a,b,c;\n\t\
    if (n <= 0) return 0;\n\tc = (n > 1) ? fib(n - 2) : 1;\n\ta = 1;\n\tb = 0;\n\t\
    while (b < n) \n\t{\n\t\tc = a + b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn b;\n\
    }\n\"\"\")", "{\n\treturn std.math.fibonacci(n);\n}\n/*\nReturn n-th Fibonacci\
    \ number.\n    >>> fibonacci(10L)\n    55L\n    >>> fibonacci(1L)\n    1L\n  \
    \  >>> fibonacci(8L)\n    21L\n    \n*/\nlong fibonacci(long n) \n{\n\treturn\
    \ std.math.fibonacci(n);\n}", "{\n    if (n <= 0) \n\treturn 0;\n    long res\
    \ = 0;\n    while (n > 0)\n\tres = (res % 1000000007) + ((res % 1000000000) >>\
    \ 3L) + std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.pow(std.math.",
  "{\n\tlong result = 1L;\n\twhile (n) \n\t{\n\t\tresult = result * 2 + 1L;\n\t\t\
    n--;\n\t}\n\treturn result;\n}", "{\n\tlong f;\n\tif(n<2) return 1L;\n\tif(n==2)\
    \ return 2L;\n\tf=fib(n-1L)+fib(n-2L);\n\treturn f;\n}\n/*\nReturn Fibonacci number\
    \ at given integer power.\n    >>> fib_pow_long(5L,2L)\n    15L\n    >>> fib_pow_long(10L,3L)\n\
    \    30L\n    \n*/\nlong fib_pow_long(long n,long p)\n{\n\tif(p==0) return n;\n\
    \tif(p==1) return 1L;\n\treturn fib_pow_long(n,p-1)+fib_pow_long(n,p-2);\n}",
  "{\n    std.assert(n >= 0L);\n    std.assert(n < 5L);\n    return std.math.nth(n,\
    \ std.math.fibonacci);\n}", "{\n   long a = 0, b = 1;\n   while (n > 0) {\n  \
    \     a = (b%n==0) ? a : (b%n);\n       b = (b-n*a)/n;\n       n--;\n   }\n  \
    \ return a;\n}", "{\n    std.math.FibSum fibSum;\n    if (n <= 1)\n        return\
    \ n;\n    fibSum.s = 0;\n    fibSum.v[0] = 1;\n    fibSum.v[1] = 1;\n    long\
    \ i;\n    for (i=2; i <= n; i++)\n    {\n        fibSum.v[i] = fibSum.v[i-1] +\
    \ fibSum.v[i-2];\n    }\n    return fibSum.v[n];\n}\n#endif", "{\n\tif (n <= 1L)\
    \ return 1L;\n\treturn fib(n - 1) + fib(n - 2); \n}\n/*\nReturn Fibonacci numbers\
    \ between min (inclusive) and max (exclusive).\n*/\nlong fib_slice(long min, long\
    \ max)\n{\n\tif (min == max) return min;\n\treturn fib(max - min) + min;\n}\n\
    /*\nReturn the square root of the argument.\n*/\ndouble sqrt(double x)\n{\n\t\
    return std.math.sqrt(x);\n}\n/*\nReturn the logarithm of the argument.\n*/\ndouble\
    \ log(double x)\n{\n\treturn std.math.log(x);\n}\n/*\nReturn exponent of the argument.\n\
    */\ndouble exp(double x)\n{\n\treturn std.math.exp(x);\n}\n/*\nReturn x raised\
    \ to the power of exponent.\n*/\ndouble pow(double x, double exponent)\n{\n\t\
    return std.math.pow(x, exponent);\n}\n/*\nReturn x to the power of exponent, rounding\
    \ toward zero.\n*/\ndouble powr(double x, double exponent)\n{\n\treturn std.math.powr(x,\
    \ exponent);\n}\n/*\nReturn x raised to the power of exponent (rounding toward\
    \ zero).\n*/\ndouble powrr(double x, double exponent)\n{\n\treturn std.math.powrr(x,\
    \ exponent);\n}\n/*\nReturn inverse of x.\n*/\ndouble inv(double x)\n{\n\treturn\
    \ std.math.inv(x);\n}\n/*\nReturn the positive square root of x.\n*/\ndouble sqrt(double\
    \ x)\n{\n\treturn std.math.sqrt(x);\n}\n/*\nReturn the positive square root of\
    \ x.\n*/\ndouble sqrt(double x)\n{\n\treturn std.math.sqrt(x);\n}\n/*\nReturn\
    \ the positive square root of x.\n*/\ndouble sqrt(double x)\n{\n\treturn std.math.sqrt(x);\n\
    }\n/*\nReturn the positive square root of x.\n*/\ndouble sqrt(double x)\n{\n\t\
    return std.math.sqrt(x);\n}\n/*\nReturn the positive square root of x.\n*/\ndouble\
    \ sqrt(double x)\n{\n\treturn std.math.sqrt(x);\n}\n/*\nReturn the positive square\
    \ root of x.\n*/\ndouble sqrt(double x)\n{\n\treturn std.math.sqrt(x);\n}\n/*\n\
    Return the positive square root of x.\n*/\ndouble sqrt(double x)\n{\n\treturn\
    \ std.math.sqrt(x);\n}\n/*\nReturn the positive square root of x.\n*/\ndouble\
    \ sqrt(double x)\n{\n\treturn std.math.sqrt(x);\n}\n/*\nReturn the positive square\
    \ root of x.\n", "{\n\tif(n==0)\n\t\treturn 0;\n\tif(n==1)\n\t\treturn 1;\n\t\
    long p[n+1];\n\tp[0] = 0;\n\tp[1] = 1;\n\tfor(int i=2; i<=n; i++){\n\t\tp[i] =\
    \ p[i-1] + p[i-2];\n\t}\n\treturn p[n];\n}\n/* Write a message to the console.\n\
    */", "{\n\tlong x = 0;\n\tlong y = 1;\n\twhile(true)\n\t{\n\t\tx = y;\n\t\ty =\
    \ x + y;\n\t\tif(y>=n) break;\n\t}\n\treturn x;\n}", "{\n\tif( n <= 2L )\n\t{\n\
    \t\treturn 1L;\n\t}\n\telse if( n > 2L )\n\t{\n\t\treturn fib( n - 2L ) + fib(\
    \ n - 1L );\n\t}\n\telse\n\t{\n\t\treturn fib( n - 1L );\n\t}\n}\n/*\nReturn the\
    \ n-th Fibonacci number.\n    >>> fib(10L)\n    55L\n    >>> fib(1L)\n    1L\n\
    \    >>> fib(8L)\n    21L\n    \n*/\nunsigned long long fib(unsigned long long\
    \ n)\n{\n\tif( n <= 2ULL )\n\t{\n\t\treturn 1ULL;\n\t}\n\telse if( n > 2ULL )\n\
    \t{\n\t\treturn fib( n - 2ULL ) + fib( n - 1ULL );\n\t}\n\telse\n\t{\n\t\treturn\
    \ fib( n - 1ULL );\n\t}\n}", "{\n\tif (n == 0)\n\t\treturn 0L;\n\tif (n == 1L)\
    \ return 1L;\n\treturn fib(n - 1) + fib(n - 2L);\n}", "{\n    return std.math.fib(n);\n\
    }", "{\n\tif (n < 2)\n\t\treturn n;\n\telse {\n\t\treturn fib(n-2) + fib(n-1);\n\
    \t}\n}", "{\n    long a,b,c,d,ans;\n    if (n<2)\n        return 1;\n    a = b\
    \ = c = 1;\n    d = 2;\n    for(ans = 3; n >= d; d++){\n        c = a + b;\n \
    \       a = b;\n        b = c;\n    }\n    return ans;\n}\n/*\nReturn the sum\
    \ of two Fibonacci numbers.\n    >>> fib_sum(8L)\n    21L\n    \n*/\nlong fib_sum(long\
    \ n) \n{\n    long a,b,c,d,ans;\n    if (n<2)\n        return 0;\n    a = b =\
    \ c = 1;\n    d = 2;\n    for(ans = 3; n >= d; d++){\n        c = a + b;\n   \
    \     a = b;\n        b = c;\n        ans += c;\n    }\n    return ans;\n}\n/*\n\
    Return the Fibonacci number that starts with n. \n    >>> fib_start(2L)\n    3\n\
    \    \n*/\nlong fib_start(long n) \n{\n    long a,b,ans;\n    if (n<3)\n     \
    \   return 0;\n    a = b = 1;\n    for(ans = 2; n >= ans; ans++){\n        c =\
    \ a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n/*\nReturn\
    \ the Fibonacci number that ends with n. \n    >>> fib_end(2L)\n    5\n    \n\
    */\nlong fib_end(long n) \n{\n    long a,b,ans;\n    if (n<3)\n        return\
    \ 0;\n    a = b = 1;\n    for(ans = 2; n >= ans; ans++){\n        c = a + b;\n\
    \        a = b;\n        b = c;\n    }\n    return a;\n}\n/*\nReturn the Fibonacci\
    \ number that sums to n.\n    >>> fib_sum(5L)\n    8\n    \n*/\nlong fib_sum(long\
    \ n) \n{\n    long a,b,ans;\n    if (n<3)\n        return 0;\n    a = b = 1;\n\
    \    for(ans = 2; n >= ans; ans++){\n        c = a + b;\n        a = b;\n    \
    \    b = c;\n        ans += c;\n    }\n    return ans;\n}\n/*\nGiven a fibonacci\
    \ number, return a list containing the two Fibonacci numbers\nthat come before\
    \ it. If there are no such two Fibonacci numbers before it, return\nthe number\
    \ itself.\n    >>> fib_before(5L)\n    [8, 13]\n    \n*/\nvector< pair<long,long>\
    \ > fib_before(long fib_num) \n{\n    vector< pair<", "{\n    if (n <= 2L)\n \
    \       return n;\n    return (fib(n-1) + fib(n-2));\n}", "{\n    switch(n)\n\
    \    {\n    case 0: return 0;\n    case 1: return 1;\n    default: return fib(n-2)\
    \ + fib(n-1);\n    }\n}", "{\n    if (n >= 5L) \n\treturn std.math.fibonacci(n-5L);\n\
    \    else \n\treturn std.math.fibonacci(n);\n}", "{\n\tlong long fibo_n[55];\n\
    \tlong long fib2;\n\tfibo_n[0] = 0;\n\tfibo_n[1] = 1;\n\tfor (long i = 2; i <\
    \ n; ++i)\n\t\tfibo_n[i] = fibo_n[i-1] + fibo_n[i-2];\n\tfib2 = fibo_n[n];\n\t\
    return fib2;\n}\n/*\nImport of math library\n*/\nimport std.math;", "{\n\treturn\
    \ fibfib(n);\n}", "{\n    if (n <= 0)\n        throw new RangeError();\n    long\
    \ fib1 = 0;\n    long fib2 = 1;\n    for (long i = 0; i < n; i++)\n    {\n   \
    \     long result = fib1 + fib2;\n        fib1 = fib2;\n        fib2 = result;\n\
    \    }\n    return fib2;\n}\n</code>\n<|/ a |>\n<| c |>\nI love how you can avoid\
    \ the recursion by using iterative instead of recursive functions.\n<|/ c |>\n\
    <| a dscore=5 |>\nI wrote some code a while ago that does this in O(log n) time.\
    \  It uses dynamic programming.\n<code>\nlong fib(long n)\n{\n    long x = 0;\n\
    \    long y = 1;\n    for(long i = 2; i < n; i++)\n    {\n        long temp =\
    \ x + y;\n        x = y;\n        y = temp;\n    }\n    return x;\n}\n</code>\n\
    <|/ a tags=fibonacci,math,c#,algorithm,performance |>\n<| c |>\nI like how this\
    \ has two variables. You could implement the same code with an array and an index\
    \ variable and avoid using a temp variable.\n<|/ c |>\n<| c |>\nThis does require\
    \ O(log n) additional memory - it stores 2 numbers before it returns it. I wonder\
    \ if there is a way to do it in constant memory.\n<|/ c |>\n<| c |>\n: yes, it\
    \ does require O(log n) additional memory. You can use two pointers, one for the\
    \ array index and one for the array element and use one to find the next number.\n\
    <|/ c |>\n<| c |>\nWhat happens when you input a number greater than fib(5)?\n\
    <|/ c |>\n<| c |>\n: That's an infinite loop.  But since it does in fact require\
    \ O(log n) extra memory, it is possible to do it with a constant amount of additional\
    \ memory in some cases.  See my answer for a solution.\n<|/ c |>\n<| a tags=fibonacci,math,c#,algorithm,performance\
    \ dscore=5 |>\nHere's a solution that only requires O(log n) extra memory:\n<code>\n\
    static int[] fibArray = new int[5];", "{\n\tif (n < 2) return 1L;\n\telse if (n\
    \ == 2) return 1L;\n\treturn fib(n - 1) + fib(n - 2L);\n}", "{\n   if (n <= 2)\n\
    \      return 1L;\n   else\n      return fib(n - 1) + fib(n - 2L);\n}", "{\n \
    \   \n    long a = 0;\n    long b = 1;\n    long c;", "{\n   if(n<2) return n;\n\
    \   return(fib(n-1) + fib(n-2));\n}\n/*\nReturn Fibonacci number.\n    >>> fib(10L)\n\
    \    55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n    \n*/\nlong long\
    \ fib(long long n) \n{\n   if(n<2) return n;\n   return(fib(n-1L) + fib(n-2L));\n\
    }\n/* \nReturn nth Fibonacci number for big integer.\n    >>> fib(10L)\n    55L\n\
    \    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n    \n*/\nbigint fib(unsigned\
    \ long long n) \n{\n   if(n<2) return n;\n   return(bigint(fib(static_cast<unsigned\
    \ long>(n-1L))) + fib(bigint(n-2L)));\n}\n/*\nReturn Fibonacci number for big\
    \ integer.\n    >>> fib(10L)\n    55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n\
    \    21L\n    \n*/\nbigint fib(unsigned long long n) \n{\n   if(n<2) return n;\n\
    \   return(bigint(fib(static_cast<unsigned long>(n-1L))) + fib(bigint(n-2L)));\n\
    }\n/* \nReturn nth Fibonacci number for big integer.\n    >>> fib(10L)\n    55L\n\
    \    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n    \n*/\nbigint fib(unsigned\
    \ long long n) \n{\n   if(n<2) return n;\n   return(bigint(fib(static_cast<unsigned\
    \ long>(n-1L))) + fib(bigint(n-2L)));\n}\n/*\nReturn nth Fibonacci number.\n \
    \   >>> fib(10L)\n    55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n\
    \    \n*/\ndouble fib(double n) \n{\n   if(n<2) return n;\n   return(fib(n-1)\
    \ + fib(n-2));\n}\n/*\nReturn Fibonacci number.\n    >>> fib(10L)\n    55L\n \
    \   >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n    \n*/\ndouble fib(double\
    \ n) \n{\n   if(n<2) return n;\n", "{\n    if (n <= 2)\n        return n;\n  \
    \  return fib(n-2) + fib(n-1);\n}\n</code>\n<|/ a |>\n<| c |>\nThe last line should\
    \ be `return fib(n-2) + fib(n-1);`.\n<|/ c |>\n<| c |>\nThank you! I updated the\
    \ answer, thanks for catching that.\n<|/ c |>\n<| a |>\nA different way of doing\
    \ this:\n<code>\npublic long fibonacci(int n) {\n    long sum = 0;\n    long temp;\n\
    \    for(int i=0; i<n; i++) {\n        if (i == 0 || i == 1) {\n            temp\
    \ = i;\n        }\n        else {\n            temp = temp + i;\n        }\n \
    \       sum = sum + temp;\n    }\n    return sum;\n}\n</code>\n<|/ a dscore=3\
    \ tags=fibonacci,recursion,c++ |>\n<| c |>\nThe downside of this approach is that\
    \ it requires two multiplications.\n<|/ c |>\n<| c |>\n- That's true. I've only\
    \ written this for educational purposes. Thanks for the comment.\n<|/ c |>\n<|\
    \ a tags=fibonacci,recursion,c++ dscore=3 |>\n<code>\n#include <iostream>\nusing\
    \ namespace std;", "{\n    if (n < 2) \n    {\n        return n;\n    }\n    return\
    \ fib(n-1) + fib(n-2);\n}", "{\n    long previous = 1;\n    long current;\n  \
    \  \n    while ((n > 2) && (n % 2 == 1)) \n    {\n        previous = current;\n\
    \        current = current + previous;\n        n = n / 2;\n    }\n    \n    return\
    \ (current + previous); \n}\n/*\nWrite a program to find the n-th term of the\
    \ sequence : 1, 1, 2, 3 ...\nInput\n    Input from user : N\nOutput\n    Print\
    \ the n-th term of the sequence : \n        1 \n        1 \n        2 \n     \
    \   3 \n        5 \n        8 \n        13 \n        21 \n        34 \n      \
    \  55 \n        89 \n        144 \n        233 \n        377 \n        610 \n\
    \        987 \n        \n*/", "{\n\tif(n<0) return -fib(long(-n));\n\tif(n<2)\
    \ return n;\n\treturn fib(n-1)+fib(n-2);\n}", "{\n\tstatic long fib_cache[2];\n\
    \tstatic long last;\n\tif(n == 0) \n\t{\n\t\treturn 0L;\n\t}\n\tif(n == 1) \n\t\
    {\n\t\treturn 1L;\n\t}\n\tif(last == 0) \n\t{\n\t\tfib_cache[0] = last = 1L;\n\
    \t}\n\telse \n\t{\n\t\tlast = fib_cache[1];\n\t\tfib_cache[0] = fib_cache[1];\n\
    \t\tfib_cache[1] = last;\n\t}\n\treturn fib_cache[n];\n}\n/*\n>>> fib(10L)\n55L\n\
    >>> fib(1L)\n1L\n>>> fib(8L)\n21L\n*/", "{\n\tlong i,f,p,a,b;", "{\n    long f;\n\
    \    f =\n            (n == 0) ? 0 : ((n == 1) ? 1L : fib(n-1L) + fib(n-2L));\n\
    \    return f;\n}\n</code>\nIn your case, you can use it this way:\n<code>\nlong\
    \ factorial(int n) \n{\n    long f = 1;\n    long result = 1;\n    for (int i\
    \ = 1; i < n; i++)\n    {\n        result = factorial(i) * result;\n    }\n  \
    \  return result;\n}\n</code>\n<|/ a tags=c,fibonacci |>\n<| c |>\nThank you for\
    \ your help, but I want to calculate the fibonacci with recursion.\n<|/ c |>\n\
    <| c |>\nIf you want the factorial of a number using recursion, you can use the\
    \ recursion formula described here: http://stackoverflow.com/questions/4246725/how-to-calculate-the-factorial-of-a-number-using-recursion-in-c\n\
    <|/ c |>\n<| c |>\nThis answer does not explain how to calculate the fibonacci\
    \ with recursion.\n<|/ c |>\n<| c |>\nThis is an example how to use recursive\
    \ factorial function: https://stackoverflow.com/a/52567172/5844420\n<|/ c |>\n\
    <| c |>\n\"fib(n \u2212 1) + fib(n \u2212 2) = fib(n \u2212 1) + fib(n \u2212\
    \ 2)\"\n<|/ c |>\n<| a |>\n<code>", "{\n\tif(n<2) return 1L;\n\treturn fib(n-2)\
    \ + fib(n-1);\n}", "{\n\tif (n < 0)\n\t\terror(\"fib() n must be non-negative\"\
    );\n\tif (n == 0 || n == 1)\n\t\treturn n;\n\tlong prev, cur;\n\tcur = 1;\n\t\
    prev = cur;\n\tfor (long i = 1; i < n; ++i)\n\t{\n\t\tcur += prev;\n\t\tprev =\
    \ cur;\n\t}\n\treturn cur;\n}", "{\n\tif (n == 0) return 0;\n\tif (n == 1) return\
    \ 1;\n\treturn fib(n - 1) + fib(n - 2);\n}\n/*\n>>> fib(10000)\n92655L\n*/", "{\n\
    \    long a = 1L, b = 2L;\n    while (n--) {\n        long tmp = a;\n        a\
    \ = b;\n        b = tmp + b;\n    }\n    return a;\n}\n'''", "{\n    if (n<2)\
    \ return n;\n    long p,q,t;\n    p = q = 1L;\n    while (n>1)\n    {\n      \
    \  t = p+q;\n        q = p+q;\n        p = t;\n        n--;\n    }\n    return\
    \ p;\n}", "{\n    long a,b;\n    if (n <= 0) return 0L;\n    if (n <= 1L) return\
    \ 1L;\n    a = fib(floor(n/2.0L)); b = a;\n    if (n % 2L) a = a + b;\n    else\
    \ a = a - b;\n    return a;\n}\n</cell>\n<cell>\n%timeit fib(n)\n</cell>\n<text>\n\
    Let's use our new function:", "{\n    int retval;\n    retval = 0;\n    retval\
    \ = std.math.reciprocal(n);\n    retval = std.math.multrunc(retval, 2);\n    return\
    \ retval;\n}\n/*\nReturn the remainder of n divided by d.\n    \n>>> remainder(10,\
    \ 2)\n5\n>>> remainder(1, 2)\n0\n*/\nlong remainder(long n, long d)\n{\n    int\
    \ retval;\n    retval = (n % d);\n    return retval;\n}\n/*\nReturn the factorial\
    \ of n.\n    >>> factorial(10)\n    3628800L\n    \n*/\nlong factorial(long n)\n\
    {\n    int retval;\n    retval = 1;\n    if (n <= 1L)\n    {\n        return retval;\n\
    \    }\n    retval = n * factorial(std.math.sub(1, n));\n    return retval;\n\
    }\n/*\nReturn the GCD of n1 and n2.\n    \n>>> gcd(10, 6)\n2\n>>> gcd(10, 6)\n\
    2\n*/\nlong gcd(long n1, long n2)\n{\n    int retval;\n    long d;\n    retval\
    \ = n1;\n    d = n2;\n    while (d > 0)\n    {\n        if (std.math.mod(n1, d)\
    \ == 0)\n        {\n            retval = n1;\n            break;\n        }\n\
    \        n1 = std.math.mod(n1, d);\n        d = std.math.sub(1, d);\n    }\n \
    \   return retval;\n}\n/*\nReturn the sum of the absolute values of the elements\
    \ of xs.\n    >>> abs([10, 2, -6, 5])\n    9\n    \n*/\nlong abs(long * xs)\n\
    {\n    long retval;\n    retval = std.math.max(std.math.abs(xs[0]), std.math.abs(xs[1]));\n\
    \    retval = std.math.max(retval, std.math.abs(xs[2]));\n    return retval;\n\
    }\n/*\nReturn the sum of the absolute values of the elements of xs.\n    >>> abs([10,\
    \ 2, -6, 5])\n    9\n    \n*/\nlong abs(long * xs)\n{\n    long retval;\n    retval\
    \ = std.math.max(std.math.abs(xs[0]), std.math.abs(xs[1]));\n    retval = std.math.max(retval,\
    \ std.math.abs(xs[2]));\n    return retval;\n}\n/*\nReturn the product of the\
    \ elements of xs.\n    >>> sum([10, 2, -6, 5])\n    21\n    \n*/\nlong long int\
    \ prod(long * xs)\n{\n    long long int retval;\n    retval = 1;\n    for (long\
    \ i = 0; i < 3; i++)\n    {\n        retval = std.math.multrunc(", "{\n    long\
    \ prev1,prev2; \n    if (n<=1) \n    {\n        return n; \n    } \n    prev1=prev2\
    \ = 1L; \n    for (int i = 3; i <= n; i+=2) \n    { \n        long t = prev1+prev2;\
    \ \n        prev1=prev2; \n        prev2=t; \n    } \n    return t; \n}\n</code>\n\
    <|/ a tags=recursion,c++,fibonacci,c++11 |>\n<| a |>\nAn iterative solution:\n\
    <code>\nlong fib(long n) {\n  long previous = 0;\n  long current = 1;\n  long\
    \ sum = 0;", "{\n    if (n >= 0L)\n        return std.math.fibonacci(n);\n   \
    \ else\n    {\n        if (n < 0L)\n            throw RangeError(\"fib: negative\
    \ index\");\n        else\n            throw ArgumentError(\"fib: index is out\
    \ of range\");\n    }\n}\n/*\nReturn sum of digits of n.\n*/\nlong digitsum(long\
    \ n)\n{\n    long sum = 0;\n    long tmp = n;\n    while (tmp != 0L)\n    {\n\
    \        sum += tmp % 10L;\n        tmp /= 10L;\n    }\n    return sum;\n}\n/*\n\
    Compute greatest common divisor (GCD) of two long numbers.\n    >>> gcd (1, 20)\n\
    \    1\n    >>> gcd (1, 0)\n    1\n    >>> gcd (10, 0)\n    1\n    >>> gcd (10,\
    \ 5)\n    1\n    \n*/\nlong gcd(long a, long b)\n{\n    while (a != b)\n    {\n\
    \        if (a < b)\n            a = a - b;\n        else\n            b = b -\
    \ a;\n    }\n    return a;\n}\n/*\nReturn square root of n.\n    >>> sqrt(9)\n\
    \    3\n    >>> sqrt(49)\n    6.47722557505161E-17 \n    \n*/\ndouble sqrt(double\
    \ n) \n{\n    double x = 0;\n    double y = 1;\n    double dx = 1;\n    double\
    \ dy = x;\n    while (true)\n    {\n        double t = ((x + y * dy) / 2) / dx;\n\
    \        if (t < 1)\n            break;\n        if (t > 1)\n            y = t;\n\
    \        else\n            x = t;\n        dy = -dx;\n        dx = sqrt((x + y\
    \ * dy) / 2);\n    }\n    return x;\n}\n/*\nReturn the sum of the digits of n.\n\
    \    >>> digitsum(13L)\n    6\n    \n*/\nlong digitsum(long n)\n{\n    long sum\
    \ = 0;\n    long tmp = n;\n    while (tmp != 0L)\n    {\n        sum += tmp %\
    \ 10L;\n        tmp /= 10L;\n    }\n    return sum;\n}\n/*\nCompute sum of digits\
    \ of n (modulo 10).\n    >>> digitsum(81)\n    8\n    \n*/\nlong digitsum(long\
    \ n)\n{\n    long sum = 0;\n    long tmp = n;\n    while (tmp != 0L)\n    {\n\
    \        sum += tmp % 10L;\n        tmp /= 10L;\n    }\n    return sum;\n}\n/*\n\
    Return the sum of the digits of n.\n    >>> digitsum(8L)\n    8\n    \n*/\nlong\
    \ digitsum(long n)\n{\n    long sum = 0;\n    long ", "{\n\tlong a, b;\n\ta =\
    \ 1;\n\tb = 1;\n\twhile (n > 1) \n\t{\n\t\tlong tmp = a;\n\t\ta = b;\n\t\tb =\
    \ tmp + b;\n\t\tn--;\n\t}\n\treturn b;\n}", "{\n\t/*\n\t0\n\t1\n\t1\n\t*/\n\t\
    static long f[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 };\n\tlong r = f[n];\n\
    \treturn r;\n}\n/* \n*/\nstatic int testfib(unsigned long n)\n{\n\tint i;\n\t\
    long fi;\n\tfi = fib(n);\n\tfor(i = 0; i < fi; i++)\n\t{\n\t\tfi = fib(n);\n\t\
    \tif(fi == i)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n/*\nReturn the Fibonacci\
    \ number of a decimal number.\n*/\nlong fib(double x)\n{\n\tlong t;\n\tt = floor(log10(x));\n\
    \tt = pow(10.0, t);\n\tt = t - (int)(t * 10.0);\n\treturn fib(t - 1);\n}\n/*\n\
    Return the Fibonacci number of a decimal.\n*/\nlong fib_double(double x)\n{\n\t\
    return fib(x);\n}\n/* \n\tFunction to evaluate a mathematical expression\n\tin\
    \ string form and return the result.\n\tExample :\n\t\texp(\"2 * 4\"); // returns\
    \ 8\n*/\nlong eval(const char *str)\n{\n\tlong result;\n\tchar *s;\n\tlong n;\n\
    \tchar *saved;\n\tlong k;\n\tchar *result;\n\t\n\t/* Get string length */\n\t\
    k = 0;\n\ts = strchr(str, '*');\n\twhile(s)\n\t{\n\t\tk++;\n\t\ts = strchr(s,\
    \ '*');\n\t}\n\t\n\t/* Allocate memory */\n\tresult = malloc(sizeof(char) * (k\
    \ + 1));\n\tif(result == NULL)\n\t\treturn 0;\n\t\n\t/* Save string and replace\
    \ * with null */\n\tsaved = str;\n\twhile(*saved)\n\t{\n\t\tsaved = strchr(saved,\
    \ '*');\n\t\t*saved = '\\0';\n\t}\n\t\n\tn = strlen(saved);\n\t\n\t/* Scan string\
    \ to get number */\n\twhile(*str)\n\t{\n\t\tif(!isdigit(*str))\n\t\t{\n\t\t\t\
    result = &saved[n - 1]; /* Return last string */\n\t\t\tbreak;\n\t\t}\n\t\tn =\
    \ n * 10 + *str - '0';\n\t\tstr++;\n\t}\n\t\n\tresult = &saved[n - 1];\n\t\n\t\
    result = result - str;\n\t\n\t/* Return result */\n\t\n\t/* Free memory */\n\t\
    free(result);\n\treturn result;\n}\n/*\nPrint a string\n*/", "{\n\tint i;\n\t\
    if(n<2) return 1;\n\tlong a,b,c;\n\ta=b=1;\n\tfor(i=1;i<n;i++) {\n\t\tc=a+b;\n\
    \t\ta=b;\n\t\tb=c;\n\t}\n\treturn b;\n}", "{\n\tif (n <= 1) \n\t{\n\t\treturn\
    \ n;\n\t}\n\telse if (n > 1)\n\t{\n\t\treturn fib(n-2) + fib(n-1);\n\t}\n\telse\
    \ \n\t{\n\t\treturn 0;\n\t}\n}\n//========================================================================================\n\
    /*\nWrite Fibonacci series into stdout.\n*/", "{\n\treturn std.math.fib(n);\n}",
  "{\n    if (n <= 1) return n;\n    return fib(n-1) + fib(n-2);\n}\n\"\"\"\n    def\
    \ c_code_cache_version():\n        return (3,)", "{\n\tif (n <= 2) return n;\n\
    \treturn fib(n-1) + fib(n-2);\n}\n/*\nReturn n-th Fibonacci number.\n    >>> fib(10L)\n\
    \    55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n    \n*/\nfloat fib(float\
    \ n) \n{\n\tif (n <= 2) return n;\n\treturn fib(n-1) + fib(n-2);\n}\n/*\nReturn\
    \ n-th Fibonacci number.\n    >>> fib(10L)\n    55L\n    >>> fib(1L)\n    1L\n\
    \    >>> fib(8L)\n    21L\n    \n*/\ndouble fib(double n) \n{\n\tif (n <= 2) return\
    \ n;\n\treturn fib(n-1) + fib(n-2);\n}\n/*\nReturn n-th Fibonacci number.\n  \
    \  >>> fib(10L)\n    55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n\
    \    \n*/\nlong double fib(long double n) \n{\n\tif (n <= 2) return n;\n\treturn\
    \ fib(n-1) + fib(n-2);\n}\n#endif\n#if defined(__cplusplus) && !defined(BUILD_AS_CPP)\n\
    }\n#endif", "{\n\tlong ret,a,b;\n\ta=1;\n\tb=1;\n\tret=1;\n\twhile ( n>1 ) {\n\
    \t\ta=b;\n\t\tb=a+b;\n\t\tret=ret+1;\n\t\tn=n-1;\n\t}\n\treturn ret;\n}", "{\n\
    \treturn std.math.fibonacci(n);\n}", "{\n\tif (n <= 1)\n\t\treturn n;\n\treturn\
    \ fib(n-1) + fib(n-2);\n}\n/*\nCheck if a binary tree is binary search tree.",
  "{\n    int x;\n    long result = 1;\n    \n    for (x = 1; x <= n; x++)\n     \
    \   result *= (x - 1);\n    \n    return result;\n}", "{\n\tint i,j;\n\tlong fibArray[5];\n\
    \tstatic long a,b,c,d;\n\tif(n<2) return n==0?0:1;\n\tfor(i=0;i<4;i++){\n\t\t\
    c=b;\n\t\tb=a;\n\t\ta=c+b;\n\t\td++;\n\t\tif(d==n) return a;\n\t\tfibArray[i]=a;\n\
    \t}\n\treturn fibArray[n-1];\n}\n/*\nReturn the first `n` Fibonacci numbers of\
    \ the series", "{\n    return std.math.fibonacci(n);\n}", "{\n\tlong a=1,b=2,c;\n\
    \twhile(n>0)\n\t{\n\t\tc=a%n;\n\t\ta=b;\n\t\tb=c;\n\t\tn--;\n\t}\n\treturn a;\n\
    }\n/*\nImport a file and return the contents in string\n*/\nstring read_from_file(string\
    \ filepath)\n{\n\tstring contents;\n\tFILE *fp;\n\tfp = fopen(filepath,\"r\");\n\
    \tcontents = fread(fp,1,filesize(fp),fp);\n\tfclose(fp);\n\treturn contents;\n\
    }", "{\n    long long a, b;\n    long i;\n    \n    if (n >= 2) {\n\t    i = 0;\n\
    \t} else {\n\t    i = 1;\n\t    n--;\n\t}\n    if (n >= 2) {\n\t    a = 2;\n\t\
    \    b = 1;\n\t    while (true) {\n\t        i++;\n\t        if (i > n) {\n\t\
    \            break;\n\t        }\n\t        a = b;\n\t        b = a + b;\n\t \
    \   }\n\t    \n\t} else {\n\t    a = 1;\n\t    b = 1;\n\t    while (true) {\n\t\
    \        i++;\n\t        if (i > n) {\n\t            break;\n\t        }\n\t \
    \       b = a + b;\n\t    }\n\t    \n\t}\n\t\n    return b;\n    \n}\n/*\n   \
    \ \n  Compute Fibonacci numbers (naive version).\n    \n    >>> fibN(10)\n   \
    \ 55\n    >>> fibN(11)\n    55\n    >>> fibN(12)\n    55\n    \n  Compute Fibonacci\
    \ numbers (better version).\n    \n    >>> fibN2(10)\n    55\n    >>> fibN2(11)\n\
    \    55\n    >>> fibN2(12)\n    55\n    \n*/\nlong fibN(long n)\n{\n    long i;\n\
    \    long a, b;\n    \n    if (n >= 2) {\n\t    i = 0;\n\t} else {\n\t    i =\
    \ 1;\n\t    n--;\n\t}\n    if (n >= 2) {\n\t    a = 2;\n\t    b = 1;\n\t    while\
    \ (true) {\n\t        i++;\n\t        if (i > n) {\n\t            break;\n\t \
    \       }\n\t        a = b;\n\t        b = a + b;\n\t    }\n\t    \n\t} else {\n\
    \t    a = 1;\n\t    b = 1;\n\t    while (true) {\n\t        i++;\n\t        if\
    \ (i > n) {\n\t            break;\n\t        }\n\t        b = a + b;\n\t    }\n\
    \t    \n\t}\n\t\n    return b;\n    \n}\n/*\n    \n    \n    Compute Fibonacci\
    \ numbers (iterative version).\n    \n    >>> fibN3(10)\n    55\n    >>> fibN3(11)\n\
    \    55\n    >>> fibN3(12)\n    55\n    \n    \n*/\nlong fibN3(long n)\n{\n  \
    \  long i;\n    long a, b;\n    long count = 0;\n    \n    if (n >= 2) {\n\t \
    \   i = 0;\n\t} else {\n\t    i = 1;\n\t    n--;\n\t}\n    if (n >= 2) {\n\t \
    \   a = 2;\n\t    b = 1;\n\t    while (true) {\n\t        i++;\n\t        if (i\
    \ > n) {\n\t            break;\n\t        }\n\t        a = b;\n\t        b = a\
    \ + b;\n\t        count++;\n\t    }\n\t    \n\t} else {\n\t    a = 1;\n\t    b\
    \ = 1;\n\t    ", "{\n    long i;\n    long fibs[21];\n    fibs[0] = 1L;\n    fibs[1]\
    \ = 1L;\n    \n    for(i = 2; i <= n; i++) {\n        fibs[i] = fibs[i-1] + fibs[i-2];\n\
    \    }\n    \n    return fibs[n];\n}\n</cell>\n<text>\nExercise (10)\nFix the\
    \ fibs function to return the n-th Fibonacci number instead of the sum.", "{\n\
    \  long prev,cur,i;\n  if (n <= 1) return n;\n  prev = cur = 1L;\n  for (i = 2L\
    \ ; i <= n ; ++i) {\n    cur = prev + cur;\n    prev = cur;\n  }\n  return cur;\n\
    }\n</code>\n<|/ a tags=math,c++,fibonacci,fibonacci-heap dscore=1 |>\n<| a tags=math,c++,fibonacci,fibonacci-heap\
    \ dscore=1 |>\nA simple solution in Python:\n<code>\n def fibonacci(n):\n    a,\
    \ b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    return a\n</code>\n\
    <|/ a |>\n<| a dscore=1 tags=math,c++,fibonacci,fibonacci-heap |>\nHere is my\
    \ version implemented in C using Knuth's \"Donald Knuth's algorithm\".\n<code>\n\
    #include <stdio.h>", "{\n\tif(n<2){\n\t\treturn n;\n\t}\n\treturn fib(n-1)+fib(n-2);\n\
    }\n/*\nImport a text file with numbers separated by new lines into an array.\n\
    \    >>> importfile(\"nums.txt\",\"float\")\n    [1.1, 2.2, 3.3, 4.4, 5.5, 6.6,\
    \ 7.7, 8.8, 9.9]\n*/", "{\n    long f = 1;\n    long ret = 1;\n    while(n) {\n\
    \       f = f + ret;\n       ret = f % 5L;\n       n -= ret;\n       ret = (ret\
    \ + (ret % 5L)) % 5L;\n    }\n    return ret;\n}\n/*\nCheck whether a number is\
    \ prime or not\n    >>> is_prime(9L)\n    True\n    >>> is_prime(11L)\n    False\n\
    */", "{\n\tlong fibo = 0;\n\tif (n <= 1) return n;\n\tfibo = fib(n-1) + fib(n-2);\n\
    \treturn fibo;\n}\n/*\nThis function prints all the divisors of a number.\n*/",
  "{\n    std.array<long, 2> fib;\n    fib[1] = fib[2] = 1;\n    for (long i = 2;\
    \ i <= n; i++) {\n        fib[i] = fib[i - 1] + fib[i - 2];\n    }\n    return\
    \ fib[n];\n}\n/*\nCompute nth fibonacci number.\n    >>> fib(10L)\n    55L\n \
    \   >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n    \n*/\ndouble fibonacci(double\
    \ n)\n{\n    return fib(n);\n}", "{\n\tlong prev, curr;\n\tif (n <= 1) \n\t\t\
    return n;\n\tprev = curr = 1;\n\twhile (curr < n) {\n\t\tprev += curr;\n\t\tcurr\
    \ += prev;\n\t}\n\treturn curr;\n}\n/*\nReturn n-th Fibonacci number.\n    >>>\
    \ fib(10L)\n    55L\n    >>> fib(1L)\n    1L\n    >>> fib(8L)\n    21L\n    \n\
    */\nlong fib2(long n) \n{\n\tlong prev = 0, curr = 1;\n\twhile (curr < n) {\n\t\
    \tlong tmp = prev;\n\t\tprev = curr;\n\t\tcurr = tmp + prev;\n\t}\n\treturn curr;\n\
    }", "{\n    long prev, curr;\n    if(n == 0) {\n        return 1L;\n    }\n  \
    \  else if(n == 1) {\n        return 0;\n    }\n    prev = 0L;\n    curr = 1L;\n\
    \    for(long i = 2; i <= n; i++) {\n        curr = prev + curr;\n        prev\
    \ = curr;\n    }\n    return curr;\n}", "{\n    long prev1 = 0; long prev2 = 0;\
    \ long curr = 1;\n    \n    for(long i = 0; i < n; i++) {\n        curr = prev1\
    \ + prev2;\n        prev1 = prev2;\n        prev2 = curr;\n    }\n    \n    return\
    \ curr;\n}", "{\n    if (n <= 1)\n        return n;\n    long f1 = 1L;\n    long\
    \ f2 = 1L;\n    for (long i = 0; i < n; i++)\n    {\n        long newNum = f1\
    \ + f2;\n        f1 = f2;\n        f2 = newNum;\n    }\n    return f2;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for your answer, but what I am really looking\
    \ for is just a function that takes in a number and returns the nth Fibonacci\
    \ number in O(log n) time. I just don't know where to begin to do this.\n<|/ c\
    \ |>\n<| c |>\n: That's what O(log n) means. What you posted is O(n) by construction.\
    \ So, what you have is O(n) by construction.\n<|/ c |>\n<| c |>\nO(n) by construction\
    \ would require a pre-calculation of the first fibonacci number up to n.\n<|/\
    \ c |>\n<| c |>\n: Ok, I missed the O(log n) part. You are right that the recursive\
    \ function is O(n), but that is not what O(log n) is all about.\n<|/ c |>\n<|\
    \ c |>\n: This answer does not work at all. It does not take in account the fact\
    \ that OP is asking for `O(log n)` time complexity. It uses `O(n)` memory, and\
    \ `O(n)` time.\n<|/ c |>\n<| a dscore=1 |>\nThis code will calculate fibonacci\
    \ numbers up to n = 10000 in O(log n) time complexity.\n<code>\n/*\nCalculates\
    \ the nth fibonacci number in O(log n) time complexity.\n*/\nlong fib(int n) {\n\
    \    long num;\n    if(n<2) {\n        return 1;\n    }\n    num = fib(n-1)+fib(n-2);\n\
    \    return num;\n}\n</code>\n<|/ a tags=algorithm,recursion,fibonacci,c |>\n\
    <| c |>\nThis answer does not work at all. It does not take in account the fact\
    \ that OP is asking for `O(log n)` time complexity. It uses `O(n)` memory, and\
    \ `O(n)` time.\n<|/ c |>\n<| c |>\nYes, the previous answer used a recursive function,\
    \ which is `O(n)`. Now I think it uses `O(log n)` memory and `O(n)` time.\n<|/\
    \ c |>\n<| c |>\nNo, it does not use a recursive function. It uses recursive functions,\
    \ which uses "]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
