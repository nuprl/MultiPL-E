name: HumanEval_104_unique_digits
language: d
prompt: "import std.math;\n/*\nGiven an array of positive integers x. return a sorted\
  \ array of all \n    elements that hasn't any even digit.\n\n    Note: Returned\
  \ array should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15L,\
  \ 33L, 1422L, 1L])\n    [1L, 15L, 33L]\n    >>> unique_digits([152L, 323L, 1422L,\
  \ 10L])\n    []\n    \n*/\nlong[] unique_digits(long[] x) \n"
tests: "unittest\n{\n    alias candidate = unique_digits;\n\n    assert(candidate([15L,\
  \ 33L, 1422L, 1L]) == [1L, 15L, 33L]);\n    assert(candidate([152L, 323L, 1422L,\
  \ 10L]) == []);\n    assert(candidate([12345L, 2033L, 111L, 151L]) == [111L, 151L]);\n\
  \    assert(candidate([135L, 103L, 31L]) == [31L, 135L]);\n}\nvoid main(){}"
completions: ["{\n    long[] result = new long[x.length];\n    long last=0;\n    for(int\
    \ i=0; i<x.length; i++)\n    {\n        if(x[i]>=10)\n            last = last\
    \ + x[i]%10;\n        else\n        {\n            if(last>0)\n              \
    \  result[result.length-1] = last;\n            last = 0;\n        }\n    }\n\
    \    if(last>0)\n        result[result.length-1] = last;\n    return result;\n\
    }", "{\n\tlong[] ret = new long[x.length];\n\t\n\tfor (int i = 0; i < x.length;\
    \ i++) \n\t{\n\t\tif (!std.math.mod(x[i], 10))\n\t\t{\n\t\t\tret[i] = x[i];\n\t\
    \t}\n\t}\n\t\n\tsort(ret, ret, std.cmp.ascend);\n\t\n\treturn ret;\n}", "{\n \
    \   long n = 0;\n    long[] y = new long[x.length];\n    for(int i = 0; i < x.length;\
    \ i++)\n    {\n        n += x[i];\n    }\n    n = n % 10;\n    while(n > 0)\n\
    \    {\n        y[n] = 0;\n        n++;\n        n = n % 10;\n    }\n    Arrays.sort(y);\n\
    \    return y;\n}\n</code>\n<|/ a dscore=3 tags=java,algorithm |>\n<| c |>\nYour\
    \ algorithm has a time complexity of O(N^2). Do you know any better algorithm\
    \ without using additional space ?\n<|/ c |>\n<| a dscore=3 |>\nIf your numbers\
    \ are in a large range (say, between 2 and 3 billion), this can be easily done\
    \ in O(N) time complexity. \nThe idea is that we keep a hash map from digits to\
    \ elements. We can do this in O(N) time complexity by using simple math formula.\
    \ So, if we want to find all elements that have given digit, we simply check if\
    \ it exists among all elements with this digit. If it does exist, then we add\
    \ it to our result. \nWe will iterate through the numbers until we find the first\
    \ one which doesn't have this digit. We will start from that element and increment\
    \ until we find all elements with this digit. \nIf we reach the end of the list,\
    \ then we know that there is no such element. \nHere is the code for the same\
    \ -\n<code>\npublic List<Integer> uniqueDigits(int[] nums) {\n    int n = nums.length,\
    \ count = 1;\n    Map<Integer, Integer> digits = new HashMap<>();\n    List<Integer>\
    \ resultList = new ArrayList<>();", "{\n    long[] result = new long[x.size()];\n\
    \    for (int i = 0; i < x.size(); i++)\n    {\n        int count = 0;\n     \
    \   for (int j = 0; j < x.size(); j++)\n        {\n            if (x[i] == x[j])\n\
    \            {\n                count++;\n            }\n        }\n        if\
    \ (count == 0)\n        {\n            result[i] = x[i];\n        }\n    }\n \
    \   return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=arrays,algorithm,data-structures\
    \ |>\nA short Python solution:\n<code>\n>>> print list(set(map(lambda x: int(\"\
    \".join(x)), open(\"input.txt\").read().split(\"\\n\"))))\n[14, 22, 32, 33, 152,\
    \ 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163]\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=arrays,algorithm,data-structures dscore=0 |>\nIn Java \n<code>\n\
    String[] array= {\"14\",\"22\",\"32\",\"33\",\"152\",\"153\",\"154\",\"155\",\"\
    156\",\"157\",\"158\",\"159\",\"160\",\"161\",\"162\",\"163\",\"154\",\"155\"\
    ,\"156\",\"157\",\"158\",\"159\",\"160\",\"161\",\"162\",\"163\",\"158\",\"159\"\
    ,\"160\",\"161\",\"162\",\"163\",\"32\",\"33\",\"152\",\"153\",\"154\",\"155\"\
    ,\"156\",\"157\",\"158\",\"159\",\"160\",\"161\",\"162\",\"163\",\"154\",\"155\"\
    ,\"156\",\"157\",\"158\",\"159\",\"160\",\"161\",\"162\",\"163\",\"158\",\"159\"\
    ,\"160\",\"161\",\"162\",\"163\",\"32\",\"33\",\"152\",\"153\",\"154\",\"155\"\
    ,\"156\",\"157\",\"158\",\"159\",\"160\",\"161\",\"162\",\"163\",\"154\",\"155\"\
    ,\"156\",\"157\",\"158\",\"159\",\"160\",\"161\",\"162\",\"163\",\"158\",\"159\"\
    ,\"160\",\"161\",\"162\",\"163\"}\nArrays.sort(array);\nfor (int i=0;i<array.length-2;i++){\n\
    \    if(array[i]%2==0){\n        System.out.println(array[i]);\n    }\n}\n</code>\n\
    <|/ a |>\n<| a |>\nIn Java the following code works fine for me:\n<code>\nimport\
    \ java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\
    import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;",
  "{\n    if(x == null || x.length == 0)\n    {\n        return null;\n    }\n   \
    \ \n    int len = x.length;\n    int res = new long[len];\n    long max = 0;\n\
    \    for(int i = 0; i< len; i++)\n    {\n        if(max < x[i])\n        {\n \
    \           max = x[i];\n        }\n    }\n    \n    for(int i = 0; i< len; i++)\n\
    \    {\n        if(max != x[i])\n        {\n            res[i] = max;\n      \
    \  }\n        else\n        {\n            res[i] = x[i];\n        }\n    }\n\
    \    return res;\n}", "{\n    int n = 0;\n    long[] result = new long[x.length];\n\
    \    for (int i = 0; i < x.length; i++)\n    {\n        if (x[i] % 2 == 0)\n \
    \       {\n            if (n < i) \n            {\n                for (int j\
    \ = i; j < x.length; j++) \n                {\n                    result[n++]\
    \ = x[j];\n                }\n            }\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=algorithm dscore=0 |>\n<| c |>\nThe question is about sorted\
    \ array.\n<|/ c |>\n<| c |>\nPlease add an explanation as to why this works. You\
    \ might also want to check your variable names carefully. `unique_digits` is very\
    \ confusing because of the name alone; why not call it `unique_evens`?\n<|/ c\
    \ |>\n<| c |>\n: Yes, you are right. I will edit my answer.\n<|/ c |>\n<| a tags=algorithm\
    \ |>\nThis is more efficient than the other solutions given.\n<code>\nfunction\
    \ solution(N,A) {\n    A.sort(function(a, b){\n        return b-a;\n    });\n\
    \    var result = [];\n    for(var i=0; i<N;i++){\n        var j = 0;\n      \
    \  while(j<A.length && A[j+1]>A[j]){\n            j++;\n        }\n        result.push(A[j]);\n\
    \        A.splice(j+1);\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThe question is about sorted array.\n<|/ c |>\n<| a tags=algorithm\
    \ |>\n<code>\n#include<bits/stdc++.h>\nusing namespace std;", "{\n    long ans\
    \ = 0;\n    long ans1 = 0;\n    long ans2 = 0;\n    long ans3 = 0;\n    long ans4\
    \ = 0;\n    long ans5 = 0;\n    \n    for(int i = 0; i < x.length; i++)\n    {\n\
    \        ans1 = (x[i] % 10) % 10;\n        ans2 = (x[i] / 10) % 10;\n        ans3\
    \ = (x[i] / 100) % 10;\n        ans4 = (x[i] / 1000) % 10;\n        ans5 = (x[i]\
    \ / 10000) % 10;\n        \n        if(ans2 == 0 && ans3 == 0 && ans4 == 0 &&\
    \ ans5 == 0)\n        {\n            ans = x[i];\n        }\n        else if(ans2\
    \ == 0 && ans3 == 0 && ans4 == 0)\n        {\n            ans = ans ^ ans1; \n\
    \        }\n        else if(ans2 == 0 && ans3 == 0)\n        {\n            ans\
    \ = ans ^ ans1; \n            ans = ans ^ ans2; \n        }\n        else if(ans2\
    \ == 0)\n        {\n            ans = ans ^ ans1; \n            ans = ans ^ ans2;\
    \ \n            ans = ans ^ ans3; \n        }\n        else if(ans3 == 0)\n  \
    \      {\n            ans = ans ^ ans1; \n            ans = ans ^ ans2; \n   \
    \         ans = ans ^ ans3; \n            ans = ans ^ ans4; \n        }\n    \
    \    else if(ans4 == 0)\n        {\n            ans = ans ^ ans1; \n         \
    \   ans = ans ^ ans2; \n            ans = ans ^ ans3; \n            ans = ans\
    \ ^ ans4; \n            ans = ans ^ ans5; \n        }\n        else if(ans5 ==\
    \ 0)\n        {\n            ans = ans ^ ans1; \n            ans = ans ^ ans2;\
    \ \n            ans = ans ^ ans3; \n            ans = ans ^ ans4; \n         \
    \   ans = ans ^ ans5; \n            ans = ans ^ ans1; \n        }\n        else\n\
    \        {\n            ans = ans ^ ans1; \n            ans = ans ^ ans2; \n \
    \           ans = ans ^ ans3; \n            ans = ans ^ ans4; \n            ans\
    \ = ans ^ ans5; \n            ans = ans ^ ans1; \n            ans = ans ^ ans2;\
    \ \n            ans = ans ^ ans3; \n            ans = ans ^ ans4; \n         \
    \   an", "{\n    long[] result = new long[x.length];\n    Arrays.sort(x);\n  \
    \  long last_pos = 0;\n    long pos;\n    int count = 0;\n    for(int i = 0; i\
    \ < x.length; i++)\n    {\n        if(x[i] == 0)\n            continue;\n    \
    \    pos = i;\n        last_pos = pos;\n        while(last_pos > 0)\n        {\n\
    \            if(x[last_pos] % 2 == 0)\n            {\n                last_pos--;\n\
    \            }\n            else\n            {\n                pos = last_pos;\n\
    \                break;\n            }\n        }\n        if(last_pos - pos !=\
    \ 1)\n        {\n            result[count++] = x[pos];\n        }\n    }\n   \
    \ Arrays.sort(result);\n    return result;\n}\n</code>\n<|/ a tags=java,arrays,data-structures,algorithm\
    \ |>\n<| a tags=java,arrays,data-structures,algorithm |>\nThis is my solution\
    \ in Java. My solution works for all positive numbers.\n<code>\npublic static\
    \ void main(String[] args) {\n    long[] arr = {10, -12, -15, 1, -5, 2};\n   \
    \ long[] result = uniqueDigits(arr);\n    System.out.println(Arrays.toString(result));\n\
    }", "{\n    int size = x.length;\n    long[] res = new long[size];\n    for(int\
    \ i=0; i<size; ++i)\n        for(int j=i+1; j<size; ++j)\n            if(x[i]%10\
    \ != x[j]%10)\n                res[j-1] = res[j-1] * 10 + x[i]%10;\n    return\
    \ res;\n}", "{\n\tint N = x.length;\n\tlong[] a = new long[N];\n\tint c = 0;\n\
    \tfor (int i = 0; i < N; i++) \n\t{\n\t\tlong digit = std.math.mod(i, 10);\n\t\
    \tif (a[c] % 2 == 0 && digit % 2 == 0) \n\t\t{\n\t\t\ta[c++] = i;\n\t\t}\n\t}\n\
    \treturn a;\n}\n/*\nGiven an array of positive integers x. return a sorted array\
    \ of all \n    elements that hasn't any odd digit.", "{\n    long[] ret = new\
    \ long[x.length];\n    int pos = 0;\n    for (int i = 0; i < x.length; i++)\n\
    \    {\n        while (x[i] % 2 == 0)\n        {\n            x[i]--;\n      \
    \      pos++;\n        }\n        ret[pos++] = x[i];\n    }\n    return ret;\n\
    }\n</code>\n<|/ a tags=algorithm,sorting,arrays |>\n<| c |>\nThis solution is\
    \ O(nlogn) worst case and O(n) average case, while mine is O(n) worst case and\
    \ O(n) average case.\n<|/ c |>\n<| c |>\nI didn't say it was better, I said that\
    \ it would be \"safer\" to use the built-in sorting routines to get the job done\
    \ than to write your own sorting algorithms. It's not about \"safer\" but about\
    \ \"correct\".\n<|/ c |>\n<| a dscore=0 |>\n<code>\n// function returns number\
    \ of occurrences of x in arr[0..n]", "{\n  int i = 0;\n  int j = 0;\n  int resultLen\
    \ = x.length;\n  \n  long[] result = new long[resultLen];\n  \n  for (i = 0; i\
    \ < resultLen; ++i)\n  {\n    if ( x[i] % 2 == 0 )\n      result[j++] = x[i];\n\
    \  }\n  \n  for (i = 0; i < j; ++i)\n  {\n    result[i] = result[i+1];\n  }\n\
    \  \n  return result;\n}", "{\n    long n = x.length;\n    long d = 0;\n    long[]\
    \ ret = new long[n];\n    \n    for(int i = 0; i < n; ++i) {\n        d += (x[i]);\
    \ // add x[i] and store in d\n    }\n    \n    // return in increasing order\n\
    \    for(int i = 0; i < n; ++i) {\n        if(d % 2 == 0) {\n            ret[i]\
    \ = x[i];\n        }\n    }\n    return ret;\n}", "{\n    var ret = new long[x.Length];\n\
    \    var num = new int[x.Length];\n    var pos = 0;", "{\n    long[] y;\n    y\
    \ = new long[x.lenght];\n    int j=0;\n    for(i=0; i < x.lenght; i++ )\n    {\n\
    \        if(x[i] % 2 != 0)\n            y[j] = x[i];\n        j++;\n    }\n  \
    \  return y;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\nimport\
    \ java.util.*;", "{\n    long[] ans = new long[x.Length];\n    int i = 0;\n  \
    \  int j = 0;\n    while (i < x.Length && j < ans.Length) {\n        if (i % 2\
    \ == 0) {\n            if (std.math.mod(x[i], 10) != 0) {\n                ans[j++]\
    \ = x[i];\n            }\n        }\n        i++;\n    }\n    return ans;\n}",
  "{\n    long[] result = new long[x.length];", "{\n\tint i = 0, j = 0, N = x.length;\n\
    \tlong[] result = new long[N];\n\t\n\t// For each element in the array\n\twhile\
    \ (i < N) {\n\t\t// Initialize a flag that indicates if an odd number is found\n\
    \t\tboolean foundOdd = false;\n\t\t\n\t\t// Initialize a flag that indicates if\
    \ an even number is found\n\t\tboolean foundEven = false;\n\t\t\n\t\t// Initialize\
    \ a flag that indicates if a number is unique\n\t\tboolean foundUnique = false;\n\
    \t\t\n\t\t// For each digit in the current element\n\t\twhile (j < N && j < x.length)\
    \ {\n\t\t\t// If the current digit is not an even number,\n\t\t\t// then set foundOdd\
    \ to true \n\t\t\tif (x[j] % 2 != 0) {\n\t\t\t\tfoundOdd = true;\n\t\t\t}\n\t\t\
    \t\n\t\t\t// If the current digit is an even number,\n\t\t\t// then set foundEven\
    \ to true\n\t\t\telse {\n\t\t\t\tfoundEven = true;\n\t\t\t}\n\t\t\t\n\t\t\t//\
    \ If the current element is unique,\n\t\t\t// then set foundUnique to true\n\t\
    \t\tif (!foundEven) {\n\t\t\t\tfoundUnique = true;\n\t\t\t}\n\t\t\t\n\t\t\t//\
    \ Increment the counter\n\t\t\tj++;\n\t\t}\n\t\t\n\t\t// If foundOdd is false,\
    \ then add the element to the result array\n\t\tif (!foundOdd) {\n\t\t\tresult[i]\
    \ = x[i];\n\t\t}\n\t\t\n\t\t// If foundEven is false, then increment the counter\n\
    \t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t// Return the result array\n\treturn\
    \ result;\n}", "{\n    long min = x[0]; // find the smallest element\n    int\
    \ i = 0; // start from 0\n    long[] result = new long[x.length]; \n    for(;\
    \ i < x.length; i++)\n    {\n        if(x[i] < min)\n        {\n            min\
    \ = x[i];\n        }\n    }\n    for(; i < x.length; i++)\n    {\n        int\
    \ count = 0;\n        for(; i < x.length; i++)\n        {\n            if(x[i]\
    \ % 10 != 0)\n            {\n                count++;\n                break;\n\
    \            }\n        }\n        if(count == 0)\n        {\n            result[count-1]\
    \ = x[i];\n        }\n    }\n    sort(result);\n    return result;\n}", "{\n\t\
    int n = x.length;\n\tint counter = 0;\n\tlong[] result = new long[n];\n\tfor(int\
    \ i = 0; i < n; i++)\n\t{\n\t\tif(!std.math.mod(x[i], 10))\n\t\t{\n\t\t\tresult[i]\
    \ = x[i];\n\t\t\tcounter++;\n\t\t}\n\t}\n\tlong smallest = std.math.min(result);\n\
    \tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(result[i] == smallest && std.math.mod(result[i],\
    \ 10) == 0)\n\t\t{\n\t\t\tresult[i] = 0;\n\t\t\tcounter--;\n\t\t}\n\t}\n\treturn\
    \ result;\n}", "{\n\tlong[] y = (long[]) ArrayUtil.grow(x.clone());\n\t\n\tfor\
    \ (int i=0; i< x.length; i++)\n\t{\n\t\tif(i % 2 == 0)\n\t\t{\n\t\t\tlong a =\
    \ x[i];\n\t\t\t\n\t\t\t//swap\n\t\t\tlong tmp = a;\n\t\t\ta = a / 10;\n\t\t\t\
    tmp = tmp / 10;\n\t\t\t\n\t\t\t//check if same number\n\t\t\tif (tmp == a) y[i]\
    \ = a;\n\t\t}\n\t}\n\t\n\treturn y;\n}\n/*\nGiven an array of positive integers,\
    \ x. \n    Find a subarray of x that sums up to a specific number, n.\n    \n\
    Notes: \n    \n    - If there is no such subarray, the original array will be\
    \ returned.\n    \n    - The order of the elements in subarray should be from\
    \ \n    smallest to largest.\n    \n    - All elements in the original array will\
    \ be included in the \n    returned subarray.\n    \nExample: \n    \n    >>>\
    \ find_subarray_with_sum_upto(3, [15L, 33L, 1422L, 1L])\n    [1L, 33L, 1422L]\n\
    \    >>> find_subarray_with_sum_upto(3, [213L, 1422L, 1L])\n    []\n    \n*/\n\
    long[] find_subarray_with_sum_upto(long n, long[] x) \n{\n\tlong[] y = (long[])\
    \ ArrayUtil.grow(x.clone());\n\t\n\tfor (int i=0; i< x.length; i++)\n\t{\n\t\t\
    long a = x[i];\n\t\t\n\t\tlong sum = 0;\n\t\t\n\t\twhile (a>0)\n\t\t{\n\t\t\t\
    sum += a % 10;\n\t\t\ta = a / 10;\n\t\t}\n\t\t\n\t\tif (sum == n) y[i] = sum;\n\
    \t}\n\t\n\treturn y;\n}\n/*\nGiven an array of positive integers, x. \n    Find\
    \ a subarray of x that sums up to a specific number, n.\n    \nNotes: \n    \n\
    \    - If there is no such subarray, the original array will be returned.\n  \
    \  \n    - The order of the elements in subarray should be from \n    smallest\
    \ to largest.\n    \n    - All elements in the original array will be included\
    \ in the \n    returned subarray.\n    \nExample: \n    \n    >>> find_subarray_with_sum_upto(3,\
    \ [15L, 33L, 1422L, 1L])\n    [1L, 33L, 1422L]\n    >>> find_subarray_with_sum_upto(3,\
    \ [213L, 1422L, 1L])\n    []\n    \n*/\nlong[] find_subarray_with_sum_upto(long\
    \ n, long[] x) \n{\n\tlong[] y = (long[]) ArrayUtil.grow(", "{\n    Arrays.sort(x);\n\
    \    long ret[] = new long[x.length];\n    long count = 0;\n    for(int i = 0;\
    \ i < x.length; i++) {\n        if((count + 1) % 2 == 0) {\n            ret[count++]\
    \ = x[i];\n        }\n    }\n    return ret;\n}\n</code>\n<|/ a |>\n<| a tags=arrays,algorithm,sorting,java\
    \ dscore=1 |>\nI modified the algorithm from the comments on the following link\
    \ on how to do this: http://codereview.stackexchange.com/questions/33176/java-algorithm-to-return-all-non-repeating-elements-in-an-integer-array\n\
    <code>\npublic class UniqueElements {\n    public static int[] getUnique(int[]\
    \ arr) {\n        Arrays.sort(arr);\n        HashMap<Integer, Integer> map = new\
    \ HashMap<Integer, Integer>();\n        int n = arr.length;", "{\n    std.sort(x);\n\
    \    long[] r = new long[std.max(x) - std.min(x)];\n    for(int i=0; i<r.length;\
    \ i++) \n    {\n       long y = std.math::floor((long) x[i] + 0.5);\n       if(y\
    \ % 2 == 0) \n       {\n          r[i] = y;\n       }\n    }\n    return r;\n\
    }\n</code>\n<|/ a |>\n<| a |>\n<code>\n public static int[] unique(int[] x){\n\
    \        int count = 0;\n        for(int i=0;i<x.length;i++){\n            if(x[i]\
    \ == count){\n                count++;\n            }else{\n                x[count]\
    \ = x[i];\n                count++;\n            }\n        }\n        return\
    \ Arrays.copyOf(x, count);\n    }\n</code>\n<|/ a dscore=0 tags=c++,arrays,algorithm\
    \ |>\n<| a tags=c++,arrays,algorithm |>\nA simple solution which works in any\
    \ case (including negative numbers):\n<code>\n#include<iostream>\n#include<vector>\n\
    #include<algorithm>\nusing namespace std;", "{\n    int count = 0;\n    int len\
    \ = x.length;\n    long[] ret = new long[len];\n    \n    foreach(long element\
    \ in x)\n    {\n        long sum = 0;\n        foreach(long d in x)\n        {\n\
    \            sum += d;\n        }\n        \n        if(sum % 2 != 0 && sum !=\
    \ 0)\n        {\n            count++;\n            ret[count] = element;\n   \
    \     }\n    }\n    \n    Arrays.sort(ret);\n    \n    return ret;\n}", "{\n \
    \   int[] d = new int[x.length];\n    for(int i=0; i < x.length; ++i) {\n    \
    \    d[x[i]]++;\n    }\n    long[] res = new long[x.length];\n    for(int i=0;\
    \ i < x.length; ++i) {\n        if(d[x[i]] > 0) {\n            for(int j=0; j\
    \ < d[x[i]]; ++j) {\n                res[x.length - 1 - i] = x[i];\n         \
    \   }\n        }\n    }\n    return res;\n}\n// @DIFF\n/*\nGiven an array of integers\
    \ x. return a sorted array of all \n    elements that hasn't any even digit.",
  "{\n\tlong[] y= new long[x.length];\n\tlong z=0;\n\tlong count=0;\n\tfor(int i=0;\
    \ i<x.length; i++)\n\t{\n\t\tcount++;\n\t\tif(x[i]%10==0)\n\t\t{\n\t\t\tz++;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tif(z>0)\n\t\t\t{\n\t\t\t\ty[count-z] = x[i];\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn y;\n}", "{\n  long u = 0;\n  int n = (int) x.length;\n\
    \  long[] ret = new long[n];\n  for(int i = 0 ; i < n ; ++i)\n  {\n    u += x[i];\n\
    \    while( (u > 0) && (x[i] == 0) && (ret[i / 2] == 0) )\n    {\n      --u;\n\
    \      ret[i / 2] = 0;\n      ret[i / 2] = i;\n      ++i;\n    }\n  }\n  return\
    \ ret;\n}", "{\n    int N = x.length;\n    long[] y = new long[N];", "{\n    var\
    \ rs = new SortedSet[Long]();\n    var r = x;\n    for(var i=0; i< x.length; i++)\n\
    \    {\n        if(i % 2 == 0)\n        {\n            rs.add(r[i]);\n       \
    \ }\n    }\n    rs.sort();\n    var results = new long[r.length];\n    for(var\
    \ i=0; i< r.length; i++)\n    {\n        if(!rs.contains(r[i]))\n        {\n \
    \           results[i] = r[i];\n        }\n    }\n    return results;\n}", "{\n\
    \    long[] result = new long[x.length];\n    long[] x = std.array(x);\n    \n\
    \    var map = new std.map.array[long](x.length);\n    var i = 0;\n    foreach(var\
    \ j in x) \n    {\n        if(!map.has(j))\n        {\n            map[j] = true;\n\
    \            result[i++] = j;\n        }\n    }\n    return result;\n}", "{\n\
    \    int cnt = 0;\n    int pos = 0;\n    int ret[] = new int[x.length];\n    for(int\
    \ i = 0; i < x.length; i++) {\n        if(isEven(x[i])) {\n            cnt++;\n\
    \            if(cnt == 2) {\n                ret[pos] = x[i];\n              \
    \  pos++;\n                cnt = 0;\n            }\n        }\n    }\n    for(int\
    \ i = ret.length - 1; i >= 0; i--) {\n        if(cnt != 0 && ret[i] % 2 == 0)\
    \ {\n            cnt--;\n        }\n    }\n    return ret;\n}", "{\n\tlong[] a\
    \ = new long[x.length];\n\tArrays.sort(x);\n\tfor (int i = 0; i < x.length; i++)\
    \ {\n\t\tint xd = (int)x[i];\n\t\tint xodd = xd % 10;\n\t\twhile (true) {\n\t\t\
    \tint next = x[xd.toInt()].toInt();\n\t\t\tif (xodd == next) {\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t\tx[xd.toInt()] = next;\n\t\t\tx[xd.toInt() % 10] = xodd;\n\t\t\t\
    xodd = xodd % 10;\n\t\t}\n\t\ta[i] = x[xd.toInt()].toInt();\n\t}\n\treturn a;\n\
    }", "{\n    long[] res = new long[x.length];\n    bool flag = true;\n    for(int\
    \ i=0;i<x.length;i++)\n    {\n        for(int j=0;j<x.length;j++)\n        {\n\
    \            if(x[i]==x[j])\n            {\n                flag = false;\n  \
    \          }\n        }\n        if(flag)\n        {\n            res[i] = x[i];\n\
    \            flag = true;\n        }\n    }\n    return res;\n}\n/*\nGiven an\
    \ array of positive integers x. return a sorted array of all \n    elements that\
    \ hasn't any even digit.", "{\n    long[] result = new long[x.length];\n    for\
    \ (int i = 0; i < x.length; i++) {\n        // find out if any element has even\
    \ digit\n        for (int j = i + 1; j < x.length; j++) { \n            if (x[i]\
    \ / 10 % 10 != x[j] / 10 % 10) {\n                result[i] = result[i];\n   \
    \             break;\n            }\n        }\n    }\n    return result.sort(std.math.Ordering.LT).map(x\
    \ -> x / 10 % 10);\n}\n</code>\n<|/ a |>\n<| c |>\nPlease provide some explanation\
    \ as to how this answer solves the problem of the question.\n<|/ c |>\n<| c |>\n\
    I did not understand what he is trying to do in the first place, i think he wants\
    \ to find out the unique digits from a given array.\n<|/ c |>\n<| a tags=java,algorithm,arrays,sorting\
    \ dscore=0 |>\nTry this\n<code>\npublic class Solution {", "{\n\tint N = x.length;\n\
    \tlong xN = 0;\n\tlong[] result = new long[N];", "{\n    long[] ret = new long[x.length];\n\
    \    int j = 0;\n    long sum = 0;\n    long maxValue = long.MAX_VALUE;\n    for(int\
    \ i=0;i<x.length;i++)\n    {\n        sum += x[i];\n    }\n    for(int i=0;i<x.length;i++)\n\
    \    {\n        if(sum <= maxValue)\n        {\n            ret[j++] = x[i];\n\
    \        }\n        else\n        {\n            maxValue = sum;\n        }\n\
    \        sum -= x[i];\n    }\n    Arrays.sort(ret);\n    return ret;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for sharing. You probably don't need the \"using namespace\
    \ std;\" line. But I like the idea of creating an array containing the largest\
    \ sum of all digits and then looking at that array when looping through the array.\n\
    <|/ c |>\n<| a dscore=0 tags=algorithm,sorting,arrays,unique |>\nA C++ solution\
    \ without loops:\n<code>\n#include <bits/stdc++.h>", "{\n  int n = x.length;\n\
    \  long[] a = new long[n];\n  long[] b = new long[n];\n  for(int i = 0; i < n;\
    \ i++)\n  {\n    a[i] = x[i];\n  }\n  Arrays.sort(a);\n  for(int i = 0; i < n;\
    \ i++)\n  {\n    if(a[i] % 2 != 0)\n    {\n      b[i] = a[i];\n    }\n  }\n  return\
    \ b;\n}", "{\n    //write your code here\n    long[] res = new long[x.length];\n\
    \    long temp = 0;\n    for(int i = 0; i < x.length; i++){\n        temp = x[i];\n\
    \        while(temp > 0){\n            int d = (int)temp % 10;\n            if((int)temp\
    \ % 2 == 0){\n                break;\n            }\n            temp = temp /\
    \ 10;\n        }\n        res[i] = temp;\n    }\n    Arrays.sort(res);\n    return\
    \ res;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n    using System;\n\
    \    using System.Collections.Generic;\n    using System.Linq;\n    using System.Text;",
  "{\n    long len = x.length;\n    long[] result = new long[len];\n    int j = 0;\n\
    \    for(int i = 0; i<len; i++)\n    {\n        if(j>0 && x[i]%10==0)\n      \
    \  {\n            result[j]=x[i];\n            j++;\n        }\n        else\n\
    \        {\n            result[j]=x[i];\n            j++;\n        }\n    }\n\
    \    Arrays.sort(result);\n    return Arrays.copyOf(result,j);\n}\n</code>\n<|/\
    \ a |>\n<| a tags=arrays,sorting,java,algorithm dscore=3 |>\nI got one more solution.\
    \ Which is same as answer of, just a little shorter in code as I thought :)\n\
    <code>\nlong[] uniqueDigitsLong(long[] nums) {\n        long[] ans = new long[nums.length];\n\
    \        long temp = 1;\n        for (int i = 0; i < nums.length; i++) {\n   \
    \         if (temp < nums[i]) {\n                temp *= 10;\n               \
    \ ans[i] = nums[i] / temp;\n                ans[i] += nums[i] % temp;\n      \
    \      }\n        }\n        return ans;\n    }\n</code>\n<|/ a |>\n<| c |>\n\
    Nice and clean. Thanks!\n<|/ c |>\n<| c |>\nThis can be optimized to only loop\
    \ once: `long temp = 1; for (int i = 0; i <len; i++) ans[i] += nums[i]%temp; temp\
    \ *= 10;`\n<|/ c |>\n<| c |>\nNice one, though one problem with this one is that\
    \ it does not return an array.\n<|/ c |>\n<| c |>\nIt would be more accurate if\
    \ you move the `ans[i] = nums[i] / temp;` below `ans[i] += nums[i] % temp;`, so\
    \ you don't overwrite anything if the number itself is not unique.\n<|/ c |>\n\
    <| c |>\nI think this could be further optimized using the idea of\n<|/ c |>\n\
    <| a dscore=2 |>\nI wrote it using a simple while loop instead of recursion. It\
    \ can be done with recursion or a loop, but for me it makes it easier to see how\
    \ the array is filled, without having to think about it.\n<code>\npublic static\
    \ long[] uniqueDigits(long[] nums) {\n    long[] ans = new long[nums.length];\n\
    \    int index = 0;\n    long temp = 1;\n    while (index != nums.length) {\n\
    \        while (temp < nums[index]) {\n            temp *= 10;\n            ans[index]\
    \ = nums[index] / temp;\n            index++;\n        }\n        ans[index] =\
    \ nums[index];\n        index++;\n    }\n    return ans;\n}\n</code>\n<|/ a tags=arrays,sorting,java",
  "{\n    long[] result = new long[x.length];\n    for(int i = 0; i < x.length; i++)\n\
    \    {\n        int count = 0;\n        for(int j = 0; j < x.length; j++)\n  \
    \      {\n            if(j!=i)\n            {\n                long a = x[i];\n\
    \                long b = x[j];\n                if(a%10 != b%10)\n          \
    \      {\n                    count++;\n                    break;\n         \
    \       }\n            }\n        }\n        if(count == 0)\n        {\n     \
    \       result[i] = x[i];\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=algorithm,arrays,c# dscore=0 |>\n<| c |>\nCan you add some explanation\
    \ to your answer? Why did you make your own code? Why did you use your method?\
    \ Why is it faster than the other answers?\n<|/ c |>\n<| c |>\nThanks Hammond\
    \ - your solution also looks interesting but its not my solution but a code sample\
    \ from my professor's lecture. I tried it out in C# and it works pretty well but\
    \ i think its O(N^2)\n<|/ c |>\n<| c |>\nThis is O(n^2) but it is still better\
    \ than the other solutions. The other solutions are O(n^2) or O(n^3), mine is\
    \ O(n^2).\n<|/ c |>\n<| c |>\nThanks Hammond. Your solution is better than mine.\
    \ As you said yours solution is O(n^2) but his solution is O(n). Thanks anyways.\n\
    <|/ c |>\n<| c |>\nCan you please explain why it is better?\n<|/ c |>\n<| a tags=algorithm,arrays,c#\
    \ |>\nHere's another solution which may be more elegant and faster in some cases:\n\
    <code>\n    public static int[] GetUniqueDigits(int[] arr)\n    {\n        var\
    \ hashSet = new HashSet<int>();", "{\n\tlong results[] = new long[x.length];\n\
    \tfor(int i = 0; i < x.length; i++){\n\t\tresults[i] = x[i];\n\t}\n\tArrays.sort(results);\n\
    \tlong[] result = new long[results.length];\n\tfor(int i = 0; i < result.length;\
    \ i++){\n\t\tif(results[i] % 2 == 0)\n\t\t\tresult[i] = results[i] / 10;\n\t\t\
    else\n\t\t\tresult[i] = results[i];\n\t}\n\tArrays.sort(result);\n\treturn result;\n\
    }", "{\n\tlong tmp=0, tmp2=0;\n\tfor(int i = 0; i < x.length; i++)\n\t{\n\t\t\
    if(x[i]%2 == 0)\n\t\t{\n\t\t\ttmp += x[i];\n\t\t\ttmp2 += x[i];\n\t\t}\n\t\telse\n\
    \t\t\ttmp2 += 1;\n\t}\n\treturn new long[tmp2<tmp ? tmp2 :tmp];\n}", "{\n\tvar\
    \ r : long[] = new long[x.length];\n\tvar i : uint = 0;\n\tvar j : uint;", "{\n\
    \    long[] result = new long[x.length];\n    int[] bucket = new int[20];\n  \
    \  int count = 0;\n    for (int i = 0; i < x.length; i++)\n    {\n        int\
    \ curr = x[i];\n        while (curr != 0)\n        {\n            if (curr % 2\
    \ == 0)\n            {\n                bucket[count++] = curr;\n            \
    \    curr /= 2;\n            }\n            else\n            {\n            \
    \    curr /= 2;\n                break;\n            }\n        }\n    }\n   \
    \ for (int i = 0; i < count; i++)\n    {\n        result[i] = bucket[i];\n   \
    \ }\n    Arrays.sort(result);\n    return result;\n}\n</code>\n<|/ a tags=algorithm,sorting,arrays\
    \ dscore=0 |>\n<| a |>\nIf you can use the Java sort API, try this:\n<code>\n\
    import java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.Comparator;",
  "{\n\t// write your code in C# 6.0 with .NET 4.5 (Mono)\n\tlong[] r = new long[x.Length];\n\
    \tfor(int i = 0; i < x.Length; ++i)\n\t{\n\t\tbool found = false;\n\t\tfor(int\
    \ j = 0; j < r.Length; ++j)\n\t\t{\n\t\t\tif(x[i] % r[j] == 0)\n\t\t\t{\n\t\t\t\
    \tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!found)\n\t\t\tr[r.Length\
    \ - 1] = r[r.Length - 1] * 10 + x[i];\n\t}\n\treturn r;\n}\n/*\nGiven an array\
    \ of positive integers x. return a sorted array of all \n    elements that hasn't\
    \ any odd digit.", "{\n    //Your code here\n    long sum = 0;\n    int index\
    \ = 0;\n    int size = 0;\n    for(long i : x) \n    {\n        if(i%2 == 0)\n\
    \        {\n            sum += i;\n            size++;\n        }\n        else\n\
    \        {\n            long lastValue = sum;\n            int lastIndex = index;\n\
    \            sum = 0;\n            while(i < 10)\n            {\n            \
    \    sum += i%10;\n                i++;\n            }\n            if(sum !=\
    \ 0)\n            {\n                index = size-1;\n                sum = 0;\n\
    \                while(sum != lastValue)\n                {\n                \
    \    sum+=x[lastIndex];\n                    lastIndex--;\n                }\n\
    \                size++;\n            }\n        }\n    }\n    int num[size];\n\
    \    for(int i = 0; i < size; i++) \n    {\n        num[i] = x[i];\n    }\n  \
    \  return num;\n}", "{\n    long[] result = new long[x.length];\n    for(int i=0;\
    \ i<x.length; i++)\n    {\n        bool found = false;\n        for(int j=0; j<result.length;\
    \ j++)\n        {\n            if(x[i]%10 == result[j]%10)\n            {\n  \
    \              found = true;\n                break;\n            }\n        }\n\
    \        if(!found)\n            result[i] = x[i];\n    }\n    return result;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThis question is very similar to another\
    \ question but this one is from top of my head and I just wrote a recursive method\
    \ of getting the unique digits of a given number so thought it might be interesting\
    \ to share it.\n<code>\npublic int[] getUniqueDigits(int num) {\n    int[] arr\
    \ = new int[num / 10 + 1];\n    int i = arr.length - 1, j = 0;\n    while (i >=\
    \ 0 && num > 0) {\n        if (num % 10 == arr[i]) {\n            i--;\n     \
    \   } else {\n            arr[j++] = num % 10;\n            num /= 10;\n     \
    \   }\n    }\n    return arr;\n}\n</code>\n<|/ a tags=java,arrays,algorithm |>\n\
    <| a dscore=0 |>\nHere is my code. I'm pretty new to Java so there might be a\
    \ more efficient way to do the same thing, but this works for me:\n<code>\npublic\
    \ class UniqueDigits{", "{\n    long n = 0;\n    long[] result = new long[x.length];\n\
    \    for(int i = 0; i < x.length; i++) \n    {\n        n = x[i]%10;\n       \
    \ result[x[i]/10] = result[x[i]/10] + n;\n        x[i] = x[i]/10;\n    }\n   \
    \ return result;\n}\n/*\nGiven an array of positive integers x. return a sorted\
    \ array of all \n    elements that hasn't any even digit and in descending order.",
  "{\n    long long l = x.length;\n    int k = 0;\n    long long res = 0;\n    long[]\
    \ ans = new long[l - 1];\n    for(int i = 0; i < l - 1; i++){\n        if(x[i]\
    \ % 2 == 0){\n            res++;\n        }\n        else{\n            for(int\
    \ j = 0; j < k; j++){\n                if(x[j] % 2 == 0){\n                  \
    \  res++;\n                    break;\n                }\n            }\n    \
    \        ans[k] = res;\n            k++;\n            res = 0;\n        }\n  \
    \  }\n    for(int i = k; i < l - 1; i++){\n        ans[i] = 1;\n    }\n    return\
    \ ans;\n}", "{\n    long[] ret=new long[x.length];\n    for(int i=0;i<x.length;i++)\n\
    \    {\n        int digit=x[i]%10;\n        if(digit<0)\n        {\n         \
    \   digit=Math.abs(digit);\n        }\n        if(ret[digit]==0)\n        {\n\
    \            ret[digit]=i;\n        }\n    }\n    Arrays.sort(ret);\n    return\
    \ ret;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe code should also work for\
    \ negative numbers but the question says that it should work for positive integers.\
    \ I added a comment in the code which explicitly states that. You can try it out\
    \ by changing the first line of the code `import std.math;` to `import std.algorithm;`.\n\
    <|/ c |>\n<| c |>\nI didn't realize that `std.algorithm` was in scope. Thanks!\n\
    <|/ c |>\n<| c |>\nThanks for correcting me :) I guess I thought that since `std.algorithm`\
    \ was in scope that `std.math` should be as well. Thanks for the heads up anyway.\n\
    <|/ c |>\n<| c |>\nI did upvote your answer, but you say that your answer is wrong?\
    \ Did you test it? The code doesn't seem to work, I get a compiler error `error:\
    \ no match for 'operator<' (operand types are 'const long int' and 'const long\
    \ int')` on line 38.\n<|/ c |>\n<| c |>\nYeah, that makes sense. I got it wrong\
    \ and didn't properly test the code. I'll edit it right now. Sorry!\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\n#include <iostream>\n#include <cmath>", "{\n\tlong[]\
    \ ret = new long[x.length];\n\t\n\tfor (long i = 0; i < x.length; ++i)\n\t{\n\t\
    \tlong temp = 0;\n\t\tfor (; temp < x[i]; temp+=10)\n\t\t\t;\n\t\tif (temp%2 !=\
    \ 0)\n\t\t\tret[ret.length-1-i] = x[i];\n\t}\n\t\n\treturn ret;\n}", "{\n\tlong[]\
    \ res = new long[x.length];\n\tfor(int i = 0; i < x.length; i++) {\n\t\tlong ans\
    \ = x[i];\n\t\tfor(int j = i; j >= 0; j--) {\n\t\t\tlong val = x[j];\n\t\t\tlong\
    \ mod = val % 10;\n\t\t\tif(mod == 0)\n\t\t\t\tbreak;\n\t\t\tans = (ans*10) +\
    \ mod;\n\t\t}\n\t\tres[i] = ans;\n\t}\n\treturn res;\n}\n/*\nGiven a sorted array\
    \ of positive integers x, where every element \n    in the array is a digit of\
    \ the number. Write a function to \n    remove duplicates from the array.", "{\n\
    \    //write your code in C# here\n    HashSet<long> noEven = new HashSet<long>();\n\
    \    foreach(var i in x){\n        if(i % 2 != 0){\n            noEven.Add(i);\n\
    \        }\n    }\n    long[] ans = new long[noEven.Count];\n    int i = 0;\n\
    \    foreach(var t in noEven){\n        ans[i] = t;\n        i++;\n    }\n   \
    \ return ans;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for the help but can you\
    \ tell me the algorithm for this problem in Java? Also can you tell me how to\
    \ do this in java? I know the logic and I know how to implement it in c#. But\
    \ I want to know how to do in java.\n<|/ c |>\n<| c |>\n: Yes i can give you Java\
    \ code for that i will give it in few minutes\n<|/ c |>\n<| c |>\n: Wait i will\
    \ give you in few minutes. And its very simple so you just need two for loop to\
    \ traverse your array and one to check whether it is even or not then store it\
    \ in another array\n<|/ c |>\n<| c |>\n: Give me few minutes\n<|/ c |>\n<| c |>\n\
    I added my Java code as well.\n<|/ c |>\n<| a |>\n<code>\npublic static void main(String[]\
    \ args) {\n    // TODO Auto-generated method stub\n    long[] numbers={987654321L,\
    \ 987654321L, 987654321L};\n    System.out.println(\"Array Elements :\"+Arrays.toString(numbers));\n\
    \    sort(numbers);\n    System.out.println(\"Array Elements :\"+Arrays.toString(numbers));\n\
    }", "{\n\tlong long int i;\n\tint n=x.length;\n\tint n=x.length;\n\tlong long\
    \ int j=0;\n\tlong[] result = new long[n];\n\tfor(i=0; i<n; i++)\n\t{\n\t\twhile(x[i]>0)\n\
    \t\t{\n\t\t\tif(x[i]%10!=0)\n\t\t\t{\n\t\t\t\tx[i]=x[i]/10;\n\t\t\t\tbreak;\n\t\
    \t\t}\n\t\t\tx[i]=x[i]/10;\n\t\t}\n\t}\n\tfor(i=0;i<n;i++)\n\t{\n\t\tif(x[i]!=0)\n\
    \t\t{\n\t\t\tresult[j]=x[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tfor(i=0;i<j;i++)\n\t{\n\
    \t\tresult[i]=result[i]/10;\n\t}\n\treturn result;\n}", "{\n\tlong ret[x.length];\n\
    \t\n\tfor( int i=0; i < x.length; ++i ) \n\t{\n\t\t// check for each number if\
    \ they have even digit.\n\t\tif( x[i] % 2 == 0 ) \n\t\t\tret[x[i]/2] = x[i];\n\
    \t\telse\n\t\t\tret[i] = x[i];\n\t}\n\t\n\treturn ret;\n}", "{\n    long[] result\
    \ = new long[x.length];\n    int j = 0;\n    for (int i = 0; i < x.length; i++)\n\
    \    {\n        long val = x[i];\n        long count = 0;\n        while (val\
    \ != 0)\n        {\n            long temp = val % 10;\n            val = (long)\
    \ Math.floor(val / 10);\n            count += temp;\n        }\n        if (count\
    \ % 2 == 0)\n        {\n            result[j] = count;\n            j++;\n   \
    \     }\n    }\n    Arrays.sort(result);\n    return result;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nHi Mr David Hoelz, i have one doubt...suppose i have two integer\
    \ array [1,2,4,4,5,6,7,8]. so i want to get answer as [2,4,5,6] so how to do this???\
    \ help me\n<|/ c |>\n<| a tags=c#,algorithm |>\nI took Mr. David's excellent answer\
    \ but made it more concise.  Hopefully this version will be helpful to someone.\n\
    The key is the use of Aggregate and Comparer.  I thought I'd share in case somebody\
    \ finds this question on SO and needs more explanation.\n<code>\npublic static\
    \ int SumOfEvenNumbers(int[] numbers)\n{\n    // Sort numbers in ascending order.\n\
    \    Array.Sort(numbers);", "{\n    long i, count[100], max_count;\n    \n   \
    \ init_array(count, x.length);\n    max_count = count[0] = x[0];\n    for (i =\
    \ 1; i < x.length; i++) {\n        count[i] += count[i - 1];\n        if (count[i]\
    \ > max_count) {\n            max_count = count[i];\n        }\n    }", "{\n \
    \   long result[] = new long[x.length];", "{\n  int l = x.length;\n  long[] r\
    \ = new long[l];\n  long d = 1;\n  int p = 0;\n  for(int i=0; i<l; ++i)\n  {\n\
    \    p = x[i];\n    d*=10;\n    int v = (int) (d * p % 10);\n    int e = v % 2;\n\
    \    if(e == 0)\n    {\n      r[p] = v;\n    }\n  }\n  return(r);\n}\n</code>\n\
    <|/ a tags=sorting,arrays,java dscore=0 |>\n<| c |>\nYou should not use `double`\
    \ for this.  It doesn't add anything.\n<|/ c |>\n<| c |>\n: You do realize that\
    \ `double` adds only 8 more bits of precision to `long`?\n<|/ c |>\n<| c |>\n\
    : That's why we prefer `BigInteger` when working with large numbers :).\n<|/ c\
    \ |>\n<| c |>\n: Of course it adds 8 bits of precision.  That's why I said \"\
    a couple\".  `long` has a precision of ~15 decimal digits.  For large numbers,\
    \ `BigInteger` is almost certainly the right solution, and you should avoid `double`\
    \ when you can.\n<|/ c |>\n<| c |>\n: As I stated in my answer above, it depends\
    \ on how large the numbers are.  If they're less than one million or so, then\
    \ `double` will probably be fine.  But if they're more than a million or so, then\
    \ `BigInteger` will be fine.\n<|/ c |>\n<| a tags=sorting,arrays,java dscore=0\
    \ |>\n<code>\nimport java.util.Arrays;", "{\n    int n = x.length;\n    long[]\
    \ result = new long[n];", "{\n    int[] evenDigits = new int[x.length];\n    for(int\
    \ i = 0; i < x.length; i++)\n    {\n        long y = x[i];\n        for(int j\
    \ = i; j < x.length; j++)\n        {\n            long z = x[j];\n           \
    \ if(std.math.mod(y,z) == 0)\n            {\n                evenDigits[j] = 1;\n\
    \                break;\n            }\n        }\n    }\n    int[] result = new\
    \ int[x.length];\n    int j = 0;\n    for(int i = 0; i < x.length; i++)\n    {\n\
    \        if(evenDigits[i] == 0)\n        {\n            result[j++] = x[i];\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=arrays,algorithm\
    \ |>\n<| a tags=arrays,algorithm dscore=1 |>\nHere is my solution in JavaScript\
    \ :\n<code>\nfunction uniqueDigits(arr) {\n    let uniqueArray = Array.from(new\
    \ Set(arr));\n    let result = [];\n    let temp = 0;\n    uniqueArray.map((e)\
    \ => {\n        temp += e;\n        while(temp > 10) {\n            result.push(temp\
    \ % 10);\n            temp = Math.floor(temp / 10)\n        }\n    })\n    return\
    \ result;\n}\n</code>\n<|/ a |>\n<| a tags=arrays,algorithm dscore=1 |>\n<code>\n\
    /**\n* {number[]} nums\n* {number[]}\n*/\nconst removeNonUniqueDigits = (nums)\
    \ => {\n    let unique = [];\n    let length = nums.length;\n    for(let i=0;i<length;i++){\n\
    \        unique.push(nums[i]);\n    }\n    for(let i = length - 1; i >= 0; i--){\n\
    \        if(unique.indexOf(nums[i]) > -1) nums.splice(i, 1);\n    }\n    return\
    \ nums;\n}\n</code>\n<|/ a |>\n<| a tags=arrays,algorithm |>\nI wrote a simple\
    \ Java code to do this easily. I hope it helps.\n<code>\nprivate static final\
    \ int[] getUniqueDigits(int[] nums) {\n    int[] result = new int[nums.length];\n\
    \    int j = 0;\n    for (int i = 0; i < nums.length; i++) {\n        int val\
    \ = nums[i];\n        for (int k = 0; k < result.length; k++) {\n            if\
    \ (val % 10 == result[k]) {\n                val = 0;\n                break;\n\
    \            }\n        }\n        if (val == 0) {\n            result[j++] =\
    \ val;\n        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=arrays,algorithm |>\n<code>\nfunction uniqueDigits(arr) {\nvar uniqueArray\
    \ = Array.from(new Set(arr));\nvar result = [];\nvar temp = 0;\nuniqueArray.map((e)\
    \ => {\n    temp += e;\n    while(temp > 10) {\n        result.push(", "{\n  \
    \  List<long> result = new LinkedList<long>();", "{\n    long[] result = new long[x.length];\n\
    \    long num = 0;\n    int i = 0;\n    while(i<x.length) {\n        num += x[++i];\n\
    \        while(num>0) {\n            if(i>=x.length) break;\n            if(!std.isEven(num/10L))\
    \ {\n                num%=10L;\n                result[i] = num/10L;\n       \
    \     } else {\n                num/=10L;\n                result[i]++;\n    \
    \        }\n        }\n    }\n    return result;\n}\n/*\nGiven an integer arr[]\
    \ consists of non-negative integers and \n    returns the number of even digits\
    \ in it. ", "{\n  long[] res = new long[x.length];\n  int i, j, last;\n  for (i\
    \ = 0; i < x.length; i++) {\n    last = i;\n    for (j = i + 1; j < x.length;\
    \ j++) {\n      long a = (long)x[j];\n      if (a % 10 == 0) {\n        x[last]\
    \ = a;\n        last = j;\n      }\n    }\n  }\n  \n  \n  for (i = 0; i < x.length;\
    \ i++) {\n    long a = x[i];\n    if (a % 10 != 0) {\n      res[res.length] =\
    \ a;\n    }\n  }\n  \n  sort(res, 0, res.length);\n  return res;\n}", "{\n\tvar\
    \ result = new long[x.length];\n\tArrays.sort(x);\n\tvar cnt = 0;\n\t\n\tfor (int\
    \ i = 0; i < x.length; i++)\n\t{\n\t\tif (x[i] % 2 == 0)\n\t\t\tcontinue;", "{\n\
    \    long[] result = new long[x.length];\n    Arrays.sort(x);\n    Arrays.fill(result,\
    \ 1L);\n    int pos = 0;\n    for (int i = 0; i < x.length; i++)\n    {\n    \
    \    while (x[i] / 10 != 0)\n        {\n            ++pos;\n            if (pos\
    \ == x.length) pos = 0;\n        }\n        result[pos++] = x[i];\n    }\n   \
    \ return Arrays.copyOf(result, pos);\n}\n</code>\n<|/ a |>\n<| c |>\n`Arrays.fill`\
    \ doesn't change the size of the array that it is applied to, unlike `ArrayList`'s\
    \ `setSize`\n<|/ c |>\n<| c |>\n: Thanks for pointing that out. I modified my\
    \ answer (I hope). But this is not a problem. The size of `result` will grow as\
    \ `pos` is incremented.\n<|/ c |>\n<| c |>\nthanks for your reply, but I do not\
    \ understand the purpose of setting all elements to 1L. Would you mind explaining\
    \ this in more detail?\n<|/ c |>\n<| c |>\n: See my comment in your question.\
    \ `Arrays.fill` doesn't change the size of the array that it is applied to. So\
    \ `result` will keep growing as you go through the while loop without ever reaching\
    \ the point where `pos` is greater than `x.length`.\n<|/ c |>\n<| a tags=java,sorting\
    \ |>\n<code>\n public static void main(String[] args) {\n        int[] arr = {9,3,8,10,9,4,2,6,6,4,5,7,8,9};\n\
    \        System.out.println(Arrays.toString(sortArray(arr)));\n    }\n    public\
    \ static int[] sortArray(int[] arr){\n        int minElement=arr[0];\n       \
    \ for(int i=1;i<arr.length;i++){\n            if(minElement<arr[i]){\n       \
    \         minElement=arr[i];\n            }\n        }\n        int[] arrNew=new\
    \ int[arr.length];\n        for(int i=0;i<arr.length;i++){\n            if(arr[i]==minElement){\n\
    \                arrNew[i]=arr[i];\n            }\n            else{\n       \
    \         arrNew[i]=minElement;\n            }\n        }\n        return arrNew;\n\
    \    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this code may answer the question,\
    \ providing additional context regarding why and/or how this code answers the\
    \ question improves its long-term value.  Code-only answers tend to be of very\
    \ low quality, and are more likely to attract downvotes.\n<|/ c |>\n<| a tags=java,sorting\
    \ |>\n<code>\npublic class SortArray{\n    public static void ", "{\n\tint i =\
    \ x.length-1;\n\tint j = 0;\n\tint count = 0;\n\tlong[] result = new long[x.length];\n\
    \twhile(i >= 0){\n\t\twhile(j >= 0){\n\t\t\tif(x[j] % 10 != 0) break;\n\t\t\t\
    else{\n\t\t\t\tif(count < x.length-1){\n\t\t\t\t\tresult[i] = x[j];\n\t\t\t\t\t\
    i++;\n\t\t\t\t\tj++;\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\
    }\n\t\t}\n\t\tif(j < 0){\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn result;\n}",
  "{\n    long digits[10];\n    long sum = 0;\n    long max = 0;\n    for (int i=0;\
    \ i<x.length; i++) {\n        digits[i] = x[i]/10;\n        sum += digits[i];\n\
    \        if (max < sum) {\n            max = sum;\n        }\n    }\n    long\
    \ result[x.length];\n    for (int i=0; i<x.length; i++) {\n        if (digits[i]\
    \ % 2 == 0) {\n            result[i] = 0;\n        } else {\n            result[i]\
    \ = digits[i]%10;\n        }\n    }\n    sort(result, result, x.length);\n   \
    \ return result;\n}", "{\n\tlong max_len = max(x);\n\tlong[] result = new long[max_len];\n\
    \tArrays.sort(x);\n\tfor(int i = 0; i < x.length; i++)\n\t{\n\t\tif (x[i] % 2\
    \ != 0) \n\t\t\tresult[x[i]] = x[i];\n\t}\n\t\n\treturn result;\n}", "{\n\tlong[]\
    \ res = new long[x.length];\n\t\n\tfor (int i = 0; i < x.length; i++)\n\t{\n\t\
    \tlong a = x[i];\n\t\t\n\t\tfor (int j = i + 1; j < x.length; j++)\n\t\t{\n\t\t\
    \tlong b = x[j];\n\t\t\t\n\t\t\tif (a / 10 != b / 10)\n\t\t\t{\n\t\t\t\tint c\
    \ = a % 10;\n\t\t\t\t\n\t\t\t\tif (c != 0 && c == b)\n\t\t\t\t{\n\t\t\t\t\tres[i]\
    \ = a;\n\t\t\t\t\tres[j] = b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn res;\n\
    }", "{\n    long d = 1;\n    long[] result = new long[x.length];\n    for(int\
    \ i = 0; i < x.length; i++) {\n        if(d*10 < x[i])\n            d++;\n   \
    \     else\n            result[i] = d;\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=sorting,algorithm,arrays,c# |>\n<| a dscore=1 |>\nYou can sort the\
    \ numbers using a modified version of merge sort. Merge sort is O(nlogn), but\
    \ in your case you are not sorting numbers, but rather splitting them up into\
    \ their digits. \nIn your case, you need a merge sort algorithm. \nPseudo-code\
    \ for the general case:\n<code>\nfunction mergeSort(a[] as array):\n  if length(a)\
    \ <= 1\n    return\n  mid = length(a)/2\n  left = mergeSort(array[0:mid])\n  right\
    \ = mergeSort(array[mid:length(a)])\n  merge(left,right) ", "{\n    int N=x.length;\n\
    \    long[] ans=new long[N];\n    for(int i=0; i<N; i++){\n        int k=0;\n\
    \        for(int j=i; j<N; j++){\n            while(x[j]>=10){\n             \
    \   k++;\n                if(x[j]%10!=0) break;\n                x[j]-=10;\n \
    \           }\n            if(k>0) break;\n        }\n        if(k==0)\n     \
    \       ans[i]=x[i];\n    }\n    \n    return ans;\n}\n</cell>\n<cell>\n%%cython\n\
    cimport cython\nimport numpy as np\nfrom libc.math cimport malloc, free\nfrom\
    \ libc.stdlib cimport NULL, calloc, free", "{\n    if(x.length==0) return x;\n\
    \    long max = (x.length>0)?x.max:0;\n    long min = (x.length>0)?x.min:0;\n\
    \    \n    long result = 1;\n    \n    long last_digit = 0;\n    long last_count\
    \ = 0;\n    for(int i=0; i<x.length; ++i)\n    {\n        int x = (int)x[i];\n\
    \        last_digit = x;\n        last_count = x%10;\n        \n        for(int\
    \ j=0; j<last_count; ++j)\n        {\n            result = result * 10 + last_digit%10;\n\
    \            last_digit = last_digit/10;\n        }\n    }\n    \n    long[] res\
    \ = new long[max];\n    \n    long last_digit = 0;\n    for(int i=0; i<res.length;\
    \ ++i)\n    {\n        int x = (int)result%10;\n        long count = (int)result/10;\n\
    \        \n        if(x==last_digit)\n        {\n            res[i] = 1;\n   \
    \     }\n        else if(count>last_count)\n        {\n            res[i] = x;\n\
    \            last_digit = x;\n        }\n        \n        result = result/10;\n\
    \    }\n    \n    return res;\n}", "{\n    var res = new long[x.Length];\n   \
    \ var max = 1;\n    int cnt = 0;\n    foreach(int i in x)\n    {\n        ++cnt;\n\
    \        if (i == 0)\n            max = 1;\n        else \n        {\n       \
    \     max *= 10;\n            if (max % i != 0) max++;\n        }\n        res[cnt]\
    \ = i;\n    }\n    Array.Sort(res, new Comparison<long>((x, y) => x.CompareTo(y)));\n\
    \    int pos = 0;\n    foreach(int i in res)\n    {\n        if (++pos == cnt)\n\
    \            break;\n        if (i < max)\n            continue;\n        int\
    \ j = max;\n        while ((j /= 10) != 1)\n            if (res[pos] % j == 0)\n\
    \            {\n                res[pos] = 0;\n                break;\n      \
    \      }\n    }\n    return res;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI think\
    \ this is what you are looking for:\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.IO;", "{\n  int n = x.length;\n\
    \  long[] results = new long[n];\n  int i;\n  \n  for(i = 0; i < n; i++)\n  {\n\
    \    long d = x[i];\n    \n    if(d != 0)\n    {\n      int d = (int)d;\n    \
    \  \n      while(d % 2 == 0)\n      {\n        d /= 2;\n      }\n      \n    \
    \  results[i] = d;\n    }\n  }\n  \n  return results;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nI don't think your implementation works, as it doesn't keep track\
    \ of the positions of the even numbers. It just replaces them all with 0 in its\
    \ output. And it doesn't sort the results by decreasing order, which is not what\
    \ the OP asked for.\n<|/ c |>\n<| c |>\n, yes, you are right. I made an edit to\
    \ the code which does keep the positions of the even numbers.\n<|/ c |>\n<| c\
    \ |>\n, I don't see how the OP needs the position of the even numbers sorted in\
    \ the output. As far as I understood it, he wants an array sorted in decreasing\
    \ order of digits, and if there's a duplicate of the same digit, keep it at its\
    \ original position in the input array.\n<|/ c |>\n<| c |>\nThe OP asked for an\
    \ array of digits that has no duplicate digit. He also asked to sort the results\
    \ by decreasing order.\n<|/ c |>\n<| c |>\n, I understand that. But if he only\
    \ wants digits that has no duplicate digit, what does that have to do with the\
    \ order of the digits in the input array? The OP doesn't even specify whether\
    \ he wants the digits to be sorted or not, so I guess I missed that part.\n<|/\
    \ c |>\n<| a tags=sorting,algorithm,arrays,java |>\nJust an idea:\n<code>\nimport\
    \ java.util.ArrayList;\nimport java.util.List;", "{\n    int index = 0;\n    long[]\
    \ ans = x.clone();", "{\n\tint len=x.length;\n\tint temp=0;\n\tlong[] tempArray\
    \ = new long[len];\n\t\n\tfor(int i=0;i<len;i++)\n\t{\n\t\ttemp=x[i]%10;\n\t\t\
    \n\t\twhile(temp>0)\n\t\t{\n\t\t\ttempArray[len-i]=temp;\n\t\t\ttemp/=10;\n\t\t\
    \ttemp++;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<len;i++)\n\t{\n\t\tfor(int j=i+1;j<len;j++)\n\
    \t\t{\n\t\t\tif(tempArray[i]>tempArray[j])\n\t\t\t{\n\t\t\t\ttempArray[j]=tempArray[i];\n\
    \t\t\t}\n\t\t}\n\t}\n\t\n\treturn tempArray;\n}", "{\n    sort(x);\n    int ix\
    \ = 0, count = 0;\n    while (true)\n    {\n        int pos = count(x, ix);\n\
    \        if (pos == 0)\n        {\n            break;\n        }\n        swap(x,\
    \ ix, pos - 1);\n        ix++;\n        count--;\n    }\n    return x;\n}", "{\n\
    \    long[] result = new long[x.length];\n    int j = 0;\n    for (int i = 0;\
    \ i < x.length; i++) {\n        long c = x[i]; \n        while (c > 0) {\n   \
    \         int digit = c % 10;\n            if (result[digit] == 0) {\n       \
    \         result[digit] = 1;\n                result[j++] = digit;\n         \
    \   }\n            c /= 10;\n        }\n    }\n    result = (long[]) result.clone();\n\
    \    Arrays.sort(result);\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nIf you want a solution in Java then you can use the above code.\n<|/\
    \ c |>\n<| c |>\nThank you, I changed my code to reflect yours. Thank you, now\
    \ I understand what I was doing wrong.\n<|/ c |>\n<| c |>\nThis has helped me\
    \ get my program running and working perfectly. Thank you for this, you saved\
    \ me a lot of time.\n<|/ c |>\n<| c |>\nHow would you adapt this to return all\
    \ elements that dont have any even digit?\n<|/ c |>\n<| c |>\nHi could you please\
    \ provide an example input and output? I cant understand how you got `[1, 3, 5]`\
    \ from your input.\n<|/ c |>\n<| a tags=arrays,sorting,java dscore=1 |>\n<code>\n\
    import java.util.Arrays;\nimport java.lang.Math;\npublic class UniqueEvenDigits\
    \ {\n    public static void main(String args[]) {\n        int[] input = {1, 3,\
    \ 5, 7, 9, 11};\n        int[] input1 = {4, 9, 12, 15};\n        System.out.println(Arrays.toString(uniqueEvenDigits(input)));\n\
    \        System.out.println(Arrays.toString(uniqueEvenDigits(input1)));\n    }",
  "{\n    long[] res=new long[x.length];\n    for(int i=0;i<x.length;++i){\n     \
    \   int num=(int)x[i];\n        bool flag=false;\n        for(int j=0;j<i;++j){\n\
    \            if(num%10!=(int)x[j]){\n                flag=true;\n            \
    \    break;\n            }\n        }\n        if(flag){\n            res[i]=num;\n\
    \        }\n    }\n    Arrays.sort(res);\n    return res;\n}\n</code>\n<|/ a tags=java,sorting\
    \ |>\n<| a |>\n<code>\npublic class UniqueDigits{\n    public static long uniqueDigits(long\
    \ x) {\n        long digits[] = new long[10];\n        for(int i=0;i<10;i++) {\n\
    \            digits[i]=0;\n        }\n        digits[0] = 1;\n        while(x\
    \ != 0) {\n            digits[(int)(x / 10)%10] += 1;\n            x /= 10;\n\
    \        }\n        int ans = 0;\n        for(int i=0;i<10;i++) {\n          \
    \  if(digits[i]!=0) {\n                ans += digits[i];\n            }\n    \
    \    }\n        return ans;\n    }\n}\n</code>\n<|/ a tags=java,sorting dscore=0\
    \ |>\n<| a dscore=0 tags=java,sorting |>\n<code>\nimport java.util.*;\nimport\
    \ java.lang.*;\nimport java.io.*;", "{\n    long[] ret = new long[x.length];\n\
    \    \n    sort(x);\n    \n    for(int i=0; i<x.length; i++) \n    {\n       \
    \ if(x[i]%2 == 0) \n        {\n            ret[i] = x[i];\n        }\n    }\n\
    \    return ret;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe sorting method only\
    \ works if the array is sorted already by the `sort()` function.\n<|/ c |>\n<|\
    \ c |>\nYes, I thought about that, but I wanted my code to be as simple as possible,\
    \ without using that sort function.\n<|/ c |>\n<| c |>\nIf you don't want to use\
    \ the sort function, then you need to implement it yourself.\n<|/ c |>\n<| c |>\n\
    Yes, but how would you do that? I can't find any example that doesn't use the\
    \ sort function.\n<|/ c |>\n<| a tags=java |>\nMy solution:\n<code>\npublic class\
    \ MyClass {", "{\n    long[] result = new long[x.length];\n    int index = 0;\n\
    \    for(int i = 0; i < x.length; ++i)\n    {\n        if( x[i] % 2 == 0 ){\n\
    \            result[index++] = x[i];\n        }\n    }\n    Arrays.sort(result,\
    \ 0, index);\n    return result;\n}\n</code>\n<|/ a tags=algorithm,arrays |>\n\
    <| c |>\nNice solution.  I think it is better to keep a hash table of seen digits,\
    \ then iterate over the input list and add each non-unique digit to a new list\
    \ of seen digits (by decrementing the value of the hash table entry for that digit)\
    \ and remove it from the input list when it has been seen.  In fact, when you\
    \ see a digit, if it has been seen, you should do nothing.\n<|/ c |>\n<| c |>\n\
    This doesn't seem to be O(N), since you're sorting the full list of seen digits\
    \ each time, which is O(N log N).\n<|/ c |>\n<| a tags=algorithm,arrays dscore=2\
    \ |>\nHere's a solution that avoids sorting.  It only requires you scan the array\
    \ once and build a map.  \n<code>\n#include <iostream>\n#include <vector>\n#include\
    \ <map>", "{\n    long n = x.length;\n    long result[] = new long[n];\n    \n\
    \    int j = 0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        int count\
    \ = 0;\n        \n        for(int j = 0; j < n; j++)\n        {\n            if(x[j]\
    \ != 0)\n            {\n                if(x[j] % 10 == 0)\n                {\n\
    \                    count++;\n                    \n                    if(count\
    \ > 1)\n                    {\n                        break;\n              \
    \      }\n                }\n                else\n                {\n       \
    \             if(count > 1)\n                    {\n                        break;\n\
    \                    }\n                }\n            }\n        }\n        \n\
    \        if(count > 0)\n        {\n            result[j] = x[i];\n           \
    \ j++;\n        }\n    }\n    \n    return result;\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis answer doesn't satisfy the OP's requirement \"Note:  Returned array\
    \ should be sorted in increasing order.\"  It returns the even digits in ascending\
    \ order.\n<|/ c |>\n<| c |>\n.kambojit yes, you're right. I've edited my answer\
    \ accordingly :)\n<|/ c |>\n<| c |>\n.Kambojit thanks for feedback, I hope I've\
    \ improved my answer. Have you got any questions about my solution?\n<|/ c |>\n\
    <| c |>\nI was wondering if this was a fast algorithm to sort the array. Naive\
    \ sorting of sorted arrays would require a O(n log n) algorithm. In my code I\
    \ was able to achieve this in O(n) by not sorting the array but simply keeping\
    \ track of the counts of each digit.\n<|/ c |>\n<| a dscore=0 tags=algorithm,sorting,java\
    \ |>\nI implemented the above logic in Java to sort the array in increasing order\
    \ and also maintain the counts of each digit in the array.\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Collections;\nimport java.util.List;", "{\n    int[] arr; //\
    \ holds non-even numbers\n    int[] arr2; // holds even numbers\n    int[] darr;\
    \ // holds even digits\n    \n    int i = 0, j, k;\n    long sum;\n    \n    arr\
    \ = new int[x.length];\n    \n    for(i = 0; i < x.length; i++)\n    {\n     \
    \   // check if it's even\n        if(!(x[i] % 2))\n        {\n            for(j\
    \ = 0; j < arr.length; j++)\n            {\n                // check if there's\
    \ an even number in the array\n                // and check if the number is equal\
    \ to the current number\n                // if yes, set the number to be false\n\
    \                if(arr[j] == x[i])\n                {\n                    arr[j]\
    \ = false;\n                }\n            }\n        }\n        else\n      \
    \  {\n            arr2[i] = x[i];\n        }\n    }\n    \n    for(i = 0; i <\
    \ arr.length; i++)\n    {\n        // check if there's a number in the array\n\
    \        if(arr[i] == true)\n        {\n            // check if it's even\n  \
    \          for(j = 0; j < arr2.length; j++)\n            {\n                //\
    \ check if the current number is equal to the current number\n               \
    \ // if yes, set the number to be false\n                if(arr2[j] == arr[i])\n\
    \                {\n                    arr2[j] = false;\n                }\n\
    \            }\n        }\n    }\n    \n    sum = 0;\n    for(i = 0; i < arr2.length;\
    \ i++)\n    {\n        if(arr2[i] == true)\n        {\n            sum += arr[i];\n\
    \        }\n    }\n    \n    arr = new long[sum];\n    for(i = 0; i < arr2.length;\
    \ i++)\n    {\n        if(arr2[i] == true)\n        {\n            for(j = 0;\
    \ j < arr.length; j++)\n            {\n                if(arr[j] == arr[i])\n\
    \                {\n                    arr[j] = false;\n                }\n \
    \           }\n        }\n    }\n    \n    return arr;\n}\n</code>\n<|/ a tags=java,algorithm,math,dynamic-programming\
    \ dscore=2 |>\n<| c |>\nThis is so hard to read and understand and to understand,\
    \ and to understand... why do you even need this in Java?\n<|/ c |>\n<| c |>\n\
    Thanks for the detailed solution! I'm a Java beginner but I do understand the\
    \ general idea. It looks very complicated but it really is! I only have one question:\
    \ How would you write the code in Java? I'm having trouble with the syntax. Thanks\n\
    <|/ c |>\n<| c |>\nI've updated the code with the Java version. You shouldn't\
    \ be too hard on yourself translating it into Java. You'd have to do the same\
    \ steps (but with the appropriate data types) but this should be easier.\n<|/\
    \ c |>\n<| a tags=java,algorithm,math,dynamic-programming ", "{\n    long[] res\
    \ = new long[x.length];\n    sort(x,res);\n    long x = 0;\n    \n    for(int\
    \ i = 0; i < res.length; i++)\n    {\n        if(res[i] == x)\n            continue;\n\
    \        if(res[i] % 2 == 0)\n        {\n            x = res[i];\n           \
    \ res[i] = x;\n        }\n    }\n    \n    return res;\n}\n</code>\nThe performance\
    \ is still poor, however it is much better in general than my original solution.\n\
    <|/ a |>\n<| a tags=algorithm,sorting,java,arrays |>\nYou can do it with O(n)\
    \ space and O(1) time complexity like this:\n<code>\npublic static void main(String[]\
    \ args) {\n    System.out.println(new Solution().unique(new int[] {1, 9, 1, 7,\
    \ 9, 10, 1, 2, 9, 10, 1}));\n}", "{\n    long[] a = new long[x.length];\n    int\
    \ i = 0;\n    for(int j=0; j<a.length; j++)\n    {\n        while((x[i] % 10)\
    \ == 0)\n        {\n            a[j]++;\n            i++;\n        }\n    }\n\
    \    return a;\n}\n/*\nGiven an array of positive integers x. return a sorted\
    \ array of all \n    elements that has any even digit.", "{\n    int j;\n    int\
    \ n = x.length;\n    long[] result = new long[n];\n    bool seen[200] = { false\
    \ };\n    \n    for(int i = 0; i < n; i++) {\n        if(seen[i]) {\n        \
    \    result[i] = x[i];\n            continue;\n        }\n        int c = 0;\n\
    \        for(j = 0; j < n; j++) {\n            if(result[j] % 10 != 0) c++;\n\
    \        }\n        if(c == 1) result[i] = x[i];\n        seen[i] = true;\n  \
    \  }\n    \n    long[] x = x.clone();\n    Arrays.sort(x);\n    Arrays.fill(x,\
    \ 0L);\n    \n    int count = 0;\n    for(int i = 0; i < x.length; i++) {\n  \
    \      if(x[i] % 2 == 0) {\n            for(int j = 0; j < i; j++) {\n       \
    \         if(x[j] == x[i]) break;\n            }\n            if(x[j] == x[i])\
    \ count++;\n        }\n    }\n    \n    long[] res = new long[count];\n    count\
    \ = 0;\n    for(int i = 0; i < x.length; i++) {\n        if(x[i] % 2 == 0) {\n\
    \            for(int j = 0; j < i; j++) {\n                if(x[j] == x[i]) break;\n\
    \            }\n            if(x[j] == x[i]) res[count++] = x[i];\n        }\n\
    \    }\n    \n    Arrays.sort(res);\n    \n    return res;\n}\n</code>\n<|/ a\
    \ |>\n<| a dscore=2 |>\nHere is the python code that i wrote for a similar problem.\n\
    <code>\ndef uniqueEvens(a):\n    s=[]\n    b=[]\n    for i in a:\n        if i\
    \ not in s: s.append(i)\n    for i in s:\n        for j in s:\n            if\
    \ i==j: continue\n            if i%j==0:\n                b+=[j]\n           \
    \     break\n    return b\n</code>\n<|/ a tags=java,performance,arrays,algorithm,sorting\
    \ |>\n<| a dscore=2 |>\nJava8 solution using streams:\n<code>", "{\n    int i;\
    \ \n    long result = 0;\n    for (i = 0; i < x.length; ++i) {\n        result\
    \ += x[i];\n    }\n    result = x[0] + result;\n    for (int i = 1; i < x.length;\
    \ ++i) {\n        if (x[i] % 2 == 0) {\n            result += (2 * x[i]);\n  \
    \      } else {\n            result -= (2 * x[i]);\n        }\n    }\n    return\
    \ Long.toArray(result);\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,time-complexity,sorting,big-o\
    \ |>\nThe best time complexity you can achieve is O(n log n), you can achieve\
    \ it by sorting an array of length n and removing the duplicates in an O(n) operation.\
    \ Of course, it doesn't guarantee that each number will be in the final array\
    \ (because you only remove duplicates, but not the order).\n<|/ a dscore=2 |>\n\
    <| a tags=algorithm,time-complexity,sorting,big-o |>\nYet another one that sorts\
    \ in linear time. No doubt there is a mathematical proof for it though.\n<code>\n\
    function counting_sort(array:array<int>):array<int> {\n    array result = array.slice();\n\
    \    counting_sort(result, 0, result.length-1);\n    return result;\n}", "{\n\
    \    /*\n\t* Write your code in C# here\n\t*/\n    int sum = 0;\n    for(int i\
    \ = 0; i < x.Length; i++) {\n        sum += Math.Abs(x[i]) % 10;\n    }\n    int\
    \ res = sum;\n    long[] r = new long[x.Length];\n    int count = 0;\n    for(int\
    \ i = 0; i < x.Length; i++) {\n        if(x[i] < res) continue;\n        r[count]\
    \ = x[i];\n        count++;\n        res = res / 10;\n    }\n    return r;\n}\n\
    /*\nGiven an array of integers, return an array that contains all the \n    integers\
    \ that is NOT present in another array and sort \n    them in increasing order.\n\
    \    \n    Note: All the elements in the returned array should be unique.\n*/",
  "{\n    \n    long result = 0;\n    long[] resultArray = new long[x.length];\n \
    \   for(int i = 0; i < x.length; i++)\n    {\n        if(x[i]/10 != 0)\n     \
    \   {\n            result += (long)(x[i]/10);\n        }\n        else\n     \
    \   {\n            resultArray[i] = result;\n            result = 0;\n       \
    \ }\n    }\n    resultArray[resultArray.length-1] = result;\n    return resultArray;\n\
    }\n</code>\n<|/ a |>\n<| a tags=java,data-structures,algorithm |>\nHere is my\
    \ solution in Java:\n<code>\nimport java.util.*;", "{\n    long[] z = new long[x.length];\n\
    \    long result = 0;\n    \n    for(int i = 0; i < x.length; i++)\n    {\n  \
    \      result += x[i]%10;\n        z[i] = result;\n    }\n    \n    int j = 0;\n\
    \    int index = 0;\n    \n    for(int i = 1; i < x.length; i++)\n    {\n    \
    \    if (z[i] % 2 == 0)\n        {\n            while (j < index)\n          \
    \  {\n                z[j+1] = z[j];\n                j++;\n            }\n  \
    \          z[index] = x[i];\n            index++;\n        }\n    }\n    \n  \
    \  return z;\n}", "{\n    long[] result = new long[x.size()];\n    int i = 0,\
    \ j = 0;\n    for (; i < x.size(); i++)\n    {\n        result[j++] = x[i];\n\
    \    }\n    Arrays.sort(result);\n    return result;\n}\n</code>\n<|/ a tags=arrays,java\
    \ |>\n<| a dscore=0 tags=arrays,java |>\n<code>\nimport static java.lang.System.out;",
  "{\n    long[] result = new long[x.length];\n    \n    for(int i=0; i<x.length;\
    \ i++) \n    {\n        int c = (int)floor(x[i]);\n        result[c - 1] = (x[i\
    \ - c] != 0) ? x[i - c] : result[i - c];\n    }\n    \n    Arrays.sort(result);\n\
    \    return result;\n}\n</code>\n<|/ a tags=arrays,algorithm,sorting,java |>\n\
    <| a dscore=2 |>\nSort the array and remove all values having even digits.\n<code>",
  "{\n    int size = x.length;\n    int low = 0;\n    int high = size - 1;\n    int\
    \ mid;", "{\n    long[] ret = new long[x.length];", "{\n  long n = 0;\n  int j\
    \ = 0;\n  long[] res = new long[x.length];\n  for(int i = 0; i<x.length; i++)\n\
    \  {\n    long a = x[i];\n    if(a<10) break;\n    while(j<i)\n    {\n      if(abs(x[i]-a)\
    \ < abs(x[j]-a)) break;\n      else j++;\n    }\n    if(j<i-1)\n    {\n      int\
    \ c = abs(x[i]-a) + abs(x[j]-a);\n      while(c>1)\n      {\n        c = c//10;\n\
    \        x[j--] = a * 10 + c;\n      }\n      x[j-1] = a;\n      res[i] = x[i];\n\
    \      n++;\n    }\n  }\n  if(n > 0) return res;\n  return null;\n}", "{\n   \
    \ long res = 0L;\n    int index = 0L;\n    int size = x.length;\n    for(int i\
    \ = 0; i < size; i++)\n    {\n        int count = 1;\n        while(index < size\
    \ && x[count] == (x[index] % 10))\n        {\n            count++;\n         \
    \   index++;\n        }\n        if(count != 1) \n        {\n            res =\
    \ res | x[i];\n        }\n    }\n    long[] res = new long[1];\n    res[0] = res;\n\
    \    return res;\n}\n/*\nGiven an array of positive integers x. return a sorted\
    \ array of all \n    elements that doesn't have any digit equal to 9.", "{\n \
    \   int i = 0, j = 0, k = 0, n = x.length;\n    long[] res = new long[n];\n  \
    \  while(j < n){\n        if(x[j] % 2 == 0){\n            while(x[j] == x[k]){\n\
    \                res[j]++;\n                k++;\n            }\n            j++;\n\
    \        }\n        else{\n            while(x[j] < x[k]){\n                k++;\n\
    \            }\n            res[j] = x[j];\n            j++;\n        }\n    }\n\
    \    return res;\n}\n</cell>\n<cell>\n%%file merge_sort.dart", "{\n    int i,\
    \ j, count[x.length];\n    int[] y = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    long[]\
    \ ans = null;", "{\n    int n = x.length;\n    long re[] = new long[n];\n    int\
    \ i;", "{\n    // write your code here\n    long sum = 0;\n    for(int i = 0;\
    \ i < x.length; i++)\n    {\n        sum += x[i];\n    }\n    Arrays.sort(x);\n\
    \    long[] ans = new long[x.length];\n    int count = 0;\n    for(int i = 0;\
    \ i < x.length; i++)\n    {\n        ans[count++] = x[i];\n    }\n    for(int\
    \ i = sum; i > 0; i = i/10)\n    {\n        for(int j = 0; j < ans.length; j++)\n\
    \        {\n            if(ans[j] % i == 0)\n            {\n                ans[j]\
    \ -= i;\n            }\n        }\n    }\n    return ans;\n}\n</code>\n<|/ a tags=algorithm,arrays,c#,data-structures\
    \ |>\n<| c |>\nThanks for your answer, the output is not sorted.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nIn case you are looking for more optimized solution please refer\
    \ this link.\n<code>\n    private static long [] solution(long [] arr){\n    \
    \    int [][] dp = new int[arr.length+1][arr.length+1];\n        for(int i=0;i<arr.length;i++){\n\
    \            for(int j=0;j<arr.length;j++){\n                if(arr[i]==0){\n\
    \                    dp[i+1][j+1] = 1;\n                    continue;\n      \
    \          }\n                dp[i+1][j+1] = dp[i][j]+dp[i+1][j];\n          \
    \  }\n        }\n        long [] ret = new long[arr.length];\n        for(int\
    \ i=0;i<arr.length;i++){\n            ret[i] = dp[arr.length-1][i];\n        }\n\
    \        return ret;\n    }\n</code>\n<|/ a tags=algorithm,arrays,c#,data-structures\
    \ |>\n<| a |>\n<code>\nimport java.util.Arrays;", "{\n    long[] result = new\
    \ long[x.length];\n    int i, j, counter = 0, evenCount = 0;\n    \n    for (i\
    \ = 0; i < x.length; i++) {\n        if(isEven(x[i])) {\n            evenCount++;\n\
    \        }\n        else {\n            if (evenCount == 0) {\n              \
    \  result[j] = x[i];\n                j++;\n            }\n            evenCount\
    \ = 0;\n        }\n    }\n    return result;\n}", "{\n    int len = x.length;\n\
    \    long[] y = new long[len];\n    int pos = 0;\n    int i;\n    int j, k;\n\
    \    \n    for (i = 0; i<len; i++)\n    {\n        int count = 0;\n        for\
    \ (j = i; j<len; j++)\n        {\n            if (x[j] % 10 != 0)\n          \
    \  {\n                if (count < 2)\n                {\n                    y[i]\
    \ = x[j];\n                    count++;\n                }\n                else\n\
    \                {\n                    y[i] = x[j];\n                    y[i+1]\
    \ = x[j];\n                    pos = i+1;\n                    break;\n      \
    \          }\n            }\n        }\n    }\n    \n    for (j = len-1; j>pos;\
    \ j--)\n    {\n        y[j] = x[pos];\n    }\n    return y;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nThis does not provide an answer to the question. Once\
    \ you have sufficient [reputation](https://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](https://stackoverflow.com/help/privileges/comment);\
    \ instead, [provide answers that don't require clarification from the asker](https://meta.stackexchange.com/questions/214173/why-do-i-need-50-reputation-to-comment-what-can-i-do-instead).\
    \ - [From Review](/review/low-quality-posts/26678720)\n<|/ c |>\n<| c |>\nOkay,\
    \ I edited my answer to be more precise.\n<|/ c |>\n<| a dscore=1 tags=c# |>\n\
    <code>\nvar numbers = new [] { 11, 2, 55, 2, 33, 22, 22, 55, 33, 3, 33, 33, 33,\
    \ 55, 3, 33 };", "{\n    var xs = new List<long>(x);\n    foreach(var a in xs)\n\
    \    {\n        foreach(var b in xs)\n        {\n            if(a % 10 != b %\
    \ 10)\n            {\n                xs.Add(a % 10);\n            }\n       \
    \ }\n    }\n    return xs.ToArray();\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\n\
    This is my solution for finding the unique digits of a number in O(n) time. Hope\
    \ it helps.\n<code>\npublic class UniqueDigits\n{\n    static int uniqueDigits(int\
    \ input)\n    {\n        int count = 0;\n        HashSet<int> set = new HashSet<int>();\n\
    \        do\n        {\n            set.Add(input%10);\n            count++;\n\
    \            input /= 10;\n        }while(input != 0);\n        return count;\n\
    \    }\n}\n</code>\n<|/ a tags=algorithm,arrays,c# |>\n<| c |>\nHow will this\
    \ run on large numbers?\n<|/ c |>\n<| c |>\nWhat is the time complexity of this?\
    \ My guess is that this is O(n^2)\n<|/ c |>\n<| a dscore=0 |>\n<code>\nusing System;",
  "{\n  if(x.length < 1) return x;\n    \n  long[] ret = new long[x.length];\n  \n\
    \  for(int i = 0; i < x.length; i++) \n    ret[i] = x[i] % 10;\n    \n  Arrays.sort(ret);\n\
    \    \n  return ret;\n}\n</code>\n<|/ a tags=c++ dscore=1 |>\n<| c |>\nIt works\
    \ but it is extremely inefficient! It uses `O(n)` extra space and has a `O(n^2)`\
    \ runtime complexity, making it `O(n^2)` for the worst case scenario (when all\
    \ values are even).\n<|/ c |>\n<| c |>\n.Doe : yes you are right, it is not good\
    \ to use. thanks for the note\n<|/ c |>\n<| a dscore=1 |>\nHere is another solution\
    \ using a std::set, which requires no extra memory and runs in O(n). \n<code>\n\
    #include <algorithm>\n#include <iostream>\n#include <set>", "{\n\tint j;\n\tlong[]\
    \ ans = new long[x.length];\n\t\n\tfor (int i = 0; i < x.length; ++i) {\n\t\t\
    int index = 0;\n\t\tfor (j = 0; j < i; ++j) {\n\t\t\twhile ((x[i]/10) % 10 ==\
    \ (x[j]/10) % 10) {\n\t\t\t\t++index;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif (index\
    \ != 0) {\n\t\t\tans[i] = x[index];\n\t\t}\n\t}\n\treturn ans;\n}\n/*\nGiven an\
    \ array of strings x. return a sorted array of all \n    characters that hasn't\
    \ any even index.", "{\n\tlong[] ans;\n\tStack<int> stack = new Stack<int>();\n\
    \t\n\tfor (int i = 0; i < x.length; i++) {\n\t\tif (x[i] == 0) {\n\t\t\tans[i]\
    \ = 0;\n\t\t}\n\t\telse {\n\t\t\twhile (!stack.empty() && stack.top() > x[i])\
    \ {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\tstack.push(x[i]);\n\t\t}\n\t}\n\twhile\
    \ (!stack.empty()) {\n\t\tans[ans.length-1] = stack.top();\n\t\tstack.pop();\n\
    \t}\n\treturn ans;\n}\n/**\n * Return the first number of the array that equals\
    \ to the given number \n * in logarithmic time complexity. \n * \n * The function\
    \ will return the first number of the array that equals to the \n * given number\
    \ or -1 if there is no such number in the array.\n * \n * The order of the output\
    \ array is not defined, so you cannot assume an \n * ordering relationship between\
    \ the input and output values.\n * \n * @param array\n *            the array\
    \ of integers\n * @param value\n *            the number to find in the given\
    \ array\n * @return the number in the array that equals to the given number \n\
    \ *          or -1 if there is no such number in the array\n * @throws IllegalArgumentException\n\
    \ *             if the given array is empty or it contains less than \n *    \
    \         one element\n */", "{\n    long i,j=0,count=0;\n    long[] array=new\
    \ long[x.lengh];\n    for(i=0;i<x.lengh;i++)\n    {\n        if(std.math.mod(x[i],10)==0)\n\
    \        {\n            array[i]=x[i];\n            count++;\n        }\n    \
    \    else\n        {\n            while(j<count && std.math.mod(array[j],10)==0)\n\
    \            {\n                j++;\n            }\n            if(j<count) \n\
    \            {\n                array[j]=x[i];\n                count++;\n   \
    \         }\n        }\n    }\n    return array;\n}\n</code>\n<|/ a dscore=2 tags=arrays,sorting,algorithm\
    \ |>\n<| c |>\nYou might want to add `return array` to that function, to return\
    \ the array at the end of the function.\n<|/ c |>\n<| a dscore=2 |>\nAnother way\
    \ is to use binary search.\nIf you're sorting in increasing order (as was in your\
    \ example array), you can start by setting left = 0 and right = array.length -\
    \ 1\nThen you just need to know if array[left] or array[right] are even numbers.\
    \ If you need to return them, you can just set them to the smallest or largest\
    \ number.\nIf array[left] or array[right] are even numbers, you know that the\
    \ numbers are even because the digits are the same, so the left and right numbers\
    \ have no even digits so you don't need to search further.\nIf you need to search\
    \ further, you need to do a binary search to find the midpoint and check if the\
    \ middle number is even or odd.\n<code>\npublic static int[] oddEvenSort(int[]\
    \ arr) {\n    int left = 0, right = arr.length - 1;\n    if (arr[0] & 1 ==1) {\n\
    \        left = arr.length - 1;\n    }\n    if (arr[arr.length - 1] & 1 ==1) {\n\
    \        right = -1;\n    }\n    while (left != right) {\n        int mid = (left\
    \ + right) >>> 1;\n        if (arr[mid] & 1 == 1) {\n            if (arr[mid]\
    \ == 0) {\n                right = mid;\n            } else {\n              \
    \  left = mid;\n            }\n        } else {\n            if (arr[mid] == 0)\
    \ {\n                left = mid;\n            } else {\n                right\
    \ = mid;\n            }\n        }\n    }\n    return arr;\n}\n</code>\n<|/ a\
    \ tags=arrays,sorting,algorithm |>\n<| a |>\nYou can use Array.sort:\n<code>\n\
    Arrays.sort(arr); // arr is your array\n</code>\n<|/ a tags=arrays,sorting,algorithm\
    \ dscore=1 |>\n<| c |>\nThis will not work for his example input. He wants to\
    \ sort it in such a way that even numbers are always next to each other.\n<|/\
    \ c |>", "{\n  int n = x.length;\n  long[] y = new long[n];\n  int k = 0;\n  int\
    \ count = 0;\n  for (int i = 1; i < n; i++) \n  {\n    if (x[count + 1] % 10 !=\
    \ 0 && x[count] % 10 != 0)\n    {\n      y[k] = x[count + 1];\n      count++;\n\
    \      k++;\n    }\n    else \n    {\n      if (count > 0)\n      {\n        y[k]\
    \ = x[count + 1];\n        k++;\n        count = 0;\n      }\n    }\n  }\n  if\
    \ (count > 0)\n  {\n    y[k] = x[count + 1];\n    k++;\n  }\n  return y;\n}\n\
    </code>\n<|/ a |>\n<| a tags=arrays,c#,algorithm |>\nHere is my Python solution\
    \ which should be easy to understand and to optimize (if necessary).\n<code>\n\
    def unique_digits(array):\n    digits_set = set()\n    result = []\n    for num\
    \ in array:\n        digits_set.add(str(num))\n    for num in array:\n       \
    \ if str(num) not in digits_set:\n            result.append(num)\n    return result\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nC# code:\n<code>\npublic static\
    \ int[] unique_digits(int[] a)\n{\n    List<int> result = new List<int>();\n \
    \   for (int i = 0; i < a.Length; i++)\n    {\n        bool found = false;\n \
    \       for (int j = 0; j < result.Count; j++)\n        {\n            if (a[i]\
    \ == result[j])\n            {\n                found = true;\n              \
    \  break;\n            }\n        }\n        if (!found)\n        {\n        \
    \    result.Add(a[i]);\n        }\n    }\n    return result.ToArray();\n}\n</code>\n\
    <|/ a tags=arrays,c#,algorithm |>\n<| a dscore=0 |>\n<code>\n        List<int>\
    \ uniqueDigits = new List<int>();\n        List<int> notUniqueDigits = new List<int>();\n\
    \        foreach (int i in array)\n        {\n            int digit = i / Math.Pow(10,\
    \ i.GetBitLength() - 1);\n            if (notUniqueDigits.Contains(digit))\n \
    \           {\n                uniqueDigits.Add(i);\n            }\n         \
    \   else\n            {\n                notUniqueDigits.Add(i);\n           \
    \ }\n        }\n</code>\n<|/ a tags=arrays,c#,algorithm |>\n<| c |>\nHi and welcome\
    \ to Stack Overflow! Please avoid posting code only answers.  Please post a short\
    \ but complete example demonstrating the answer, so others can learn from it.\
    \  See [how to answer](https://stackoverflow.com/help/how-to-answer) for more\
    \ information.\n<|/ c |>\n<| a dscore=0 ", "{\n    long sum = 0;\n    long even\
    \ = 0;\n    int size = 0;", "{\n    int n = x.length;\n    long[] result = new\
    \ long[n];\n    Arrays.sort(x);\n    for(int i = 0; i < n; i++)\n    {\n     \
    \   if(i % 2 == 0)\n            result[i] = x[i];\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=c#,algorithm |>\n<| c |>\nO(n) time and O(n) space - that's\
    \ not bad. I'd like to see a solution with O(1) space. Also a quick `for` loop\
    \ to test each element and add is probably fast enough.\n<|/ c |>\n<| c |>\n-\
    \ `for` loop will take less space than a list because `List<T>` uses dynamic array\
    \ under the hood. But `for` loop is much better than `Linq`. The only reason to\
    \ use `Linq` is when you have to use it because it looks nicer.\n<|/ c |>\n<|\
    \ a tags=c#,algorithm dscore=1 |>\n<code>\nvar result = x.Where(i => i % 2 ==\
    \ 0).Select(i => i).Distinct().OrderBy(i => i).ToList();\n</code>\n<|/ a |>\n\
    <| a |>\nHere is a recursive solution.\n<code>\npublic int[] UniqueDigits(int[]\
    \ x) {\n    if (x == null || x.Length == 0) return new int[0];", "{\n    long[]\
    \ result = new long[x.length];\n    int len = x.length;\n    int count = 0;\n\
    \    long sum = 0;\n    \n    for (int i = 0; i < len; i++)\n    {\n        sum\
    \ = sum + (int) x[i];\n        if (sum % 2 != 0)\n        {\n            result[count]\
    \ = x[i];\n            count++;\n        }\n    }\n    \n    for (int i = count;\
    \ i < len; i++)\n    {\n        sum = sum + x[i];\n        if (sum % 2 == 0)\n\
    \            result[i] = x[i];\n    }\n    \n    return result;\n}", "{\n    bool\
    \ found = false;\n    long n = x.Length;\n    long[] res = new long[n];\n    long\
    \ digit = 0;\n    bool isEven = false;\n    \n    foreach(long i in x) \n    {\n\
    \        digit = i;\n        isEven = i % 2 == 0;\n        found = false;\n  \
    \      for(int j=0; j < n; j++)\n        {\n            if((j != 0) && ((j+1)\
    \ != n) && (isEven && (x [j] > x[j+1])))\n            {\n                digit\
    \ = i;\n                isEven = i % 2 == 0;\n                found = false;\n\
    \                break;\n            }\n            \n            if((j == n-1)\
    \ && ((!isEven) || (x [j] > x[j+1])))\n            {\n                res[j] =\
    \ digit;\n                found = true;\n                break;\n            }\n\
    \        }\n        \n        if(!found)\n        {\n            res[n - 1] =\
    \ digit;\n        }\n    }\n    return res;\n}", "{\n\tint result = 0;\n\tlong\
    \ min = int.MAX_VALUE;\n\tlong max = int.MIN_VALUE;", "{\n  int i,j;\n  long[]\
    \ result = new long[x.length];\n  for(i=0;i<x.length;i++){\n    j=i;\n    while(j>0\
    \ && x[j]%10==0){\n      x[j]=x[j-1];\n      j--;\n    }\n    result[i] = x[i];\n\
    \  }\n  return result;\n}\n</code>\n<|/ a tags=algorithm,arrays,c# dscore=0 |>\n\
    <| c |>\nI believe this may fail in cases of duplicates, such as [4, 2, 2, 3,\
    \ 8, 4, 9, 4, 5] resulting in [4, 2, 2, 3, 8, 4, 9, 5] which is not in the correct\
    \ order\n<|/ c |>\n<| c |>\nI didn't see that the duplicates were removed, will\
    \ update my answer now and thanks for the heads up\n<|/ c |>\n<| a tags=algorithm,arrays,c#\
    \ |>\nYou can use the linq method Distinct\n<code>\nstring[] words = {\"car\"\
    ,\"car\",\"car\",\"car\",\"bike\",\"car\"};", "{\n    int l = 0;\n    long[] y\
    \ = new long[x.length];\n    for(int i=0; i < x.length; i++) {\n        int count\
    \ = 0;\n        while(x[i] > 0) {\n            int d = (int)std.math.mod(x[i],\
    \ 10);\n            if(count < d || x[i] != d) {\n                y[l++] = x[i];\n\
    \                x[l++] = d;\n            }\n            x[i] = 0;\n         \
    \   count++;\n        }\n    }\n    for(int i=0; i < x.length; i++) {\n      \
    \  if(x[i] == 0) y[i] = 0;\n    }\n    return y;\n}", "{\n    if(x.lenth == 0)\
    \ \n        return null;\n    \n    long[] ans = new long[x.lenth];\n    \n  \
    \  long cur = 0;\n    for(int i = 0; i < x.lenth; ++i)\n    {\n        if(cur\
    \ != 0)\n        {\n            int c = std.math.mod(cur, 10);\n            if(c\
    \ != 0 && c != x[cur % 10])\n            {\n                ans[i] = x[cur % 10];\n\
    \            }\n        }\n        cur += x[i];\n    }\n    \n    return ans;\n\
    }\n/*\nGiven an array of positive integers x. return a sorted array of all \n\
    \    elements that hasn't any odd digit.", "{\n    long[] result = new long[x.length];\n\
    \    int j=0;\n    int evenIndex=0;\n    for(;j<x.length;j++)\n    {\n       \
    \ if(x[j] % 2 != 0)\n        {\n            result[evenIndex] = x[j];\n      \
    \      evenIndex++;\n        }\n    }\n    if(evenIndex != 0)\n    {\n       \
    \ for(int i=0;i<evenIndex;i++)\n        {\n            result[i] = 0;\n      \
    \  }\n    }\n    return result;\n}", "{\n\tlong[] result = new long[x.length];\n\
    \t\n\tfor (int i = 0; i < x.length; i++)\n\t{\n\t\tint dig = (int)std.math.floor(x[i]\
    \ / 10.0);\n\t\t\n\t\tif (result[dig] == 0)\n\t\t\tresult[dig] = x[i];\n\t\t\n\
    \t\telse if (result[dig] < x[i])\n\t\t\tresult[dig] = x[i];\n\t}\n\t\n\treturn\
    \ result;\n}", "{\n    long count=0;\n    long digit;\n    long[] result = new\
    \ long[x.length];\n    \n    for(int i=0;i<x.length;i++) {\n        digit = x\
    \ % 10;\n        if (digit % 2 != 0) {\n            count++;\n            result[i]\
    \ = digit;\n        }\n        x /= 10;\n    }\n    \n    return count>0? result:new\
    \ long[0];\n}", "{\n    long y = x[0];\n    long[] ret = new long[x.length];\n\
    \    for(int i = 0; i < x.length; i++)\n    {\n        if(x[i] % 2 != 0)\n   \
    \     {\n            for(int j = i; j < x.length; j++)\n            {\n      \
    \          if(y%x[j] == 0)\n                {\n                    ret[i] = x[i];\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return ret;\n}\n</code>\n<|/ a tags=java,arrays,algorithm |>\n<| c |>\n\
    What is the purpose of the `long y = x[0]` statement?\n<|/ c |>\n<| c |>\nIt's\
    \ a workaround for Java's lack of a `% 2` operator. You'll notice that it is not\
    \ in the answers here.\n<|/ c |>\n<| c |>\nIt just makes the first element of\
    \ the array the initial element of the result. Without it, it would start from\
    \ the second element.\n<|/ c |>\n<| c |>\nThis code will return the second element\
    \ if the first element has no even digit. `unique_digits([0, 0])` returns `[0]`\
    \ instead of `[]`\n<|/ c |>\n<| c |>\nThis code will produce incorrect result\
    \ for input `[15L, 33L, 1422L, 1L]`. Your algorithm returns `[1, 15L, 33L]` but\
    \ the correct result is `[1, 33L, 15L]`.\n<|/ c |>\n<| a dscore=0 |>\nThis code\
    \ should work\n<code>\npublic static long[] unique_digits(long[] x)\n{\n    long\
    \ y = x[0];\n    long[] ret = new long[x.length];\n    for(int i = 0; i < x.length;\
    \ i++)\n    {\n        if(x[i] % 2 != 0)\n        {\n            for(int j = i;\
    \ j < x.length; j++)\n            {\n                if(y%x[j] == 0)\n       \
    \         {\n                    ret[i] = x[i];\n                    ret[i] =\
    \ x[j];\n                    break;\n                }\n            }\n      \
    \  }\n    }\n    return ret;\n}\n</code>\n<|/ a tags=java,arrays,algorithm |>\n\
    <| c |>\nThis code will return the second element if the first element has no\
    \ even digit. `unique_digits([0, 0])` returns `[0]` instead of `[]`\n<|/ c |>\n\
    <| a |>\nHere is some code I wrote:\n<code>\npublic static long[] unique_digits(long[]\
    \ x)\n{\n    long y = x[0];\n    long[] ret = new long[x.length];\n    for(int\
    \ i = 0; i < x.length; i++)\n    {\n        if(x[i] % 2 != 0)\n        {\n   \
    \         int j = 0;\n            while(j < i)\n            {\n              \
    \  if(", "{\n\tif (x.length < 1)\n\t\treturn null;", "{\n    int left = 0;\n \
    \   int right = 0;\n    long[] a = new long[x.length];\n    int i = 0;\n    while(left\
    \ < right) {\n        int mid = left + (right-left)/2;\n        if(x[mid] > x[mid+1])\
    \ {\n            right = mid - 1;\n        }\n        else {\n            left\
    \ = mid + 1;\n        }\n    }\n    while(left < x.length) {\n        if(x[left]\
    \ % 2 == 0) {\n            a[i++] = x[left];\n        }\n        left++;\n   \
    \ }\n    return a;\n}\n</code>\n<|/ a |>\n<| c |>\nHi Martijn, thank you for your\
    \ answer but this is only sorting. I'm looking to remove the duplicates in my\
    \ array. Hope that makes sense\n<|/ c |>\n<| a |>\nYou could solve it with a stream\
    \ operation but that would be inefficient with larger lists:\n<code>\nlet unique\
    \ = myList.asEnumerable()\n    .SelectMany(item => item.Item2.Select(c => new[]{c.Item1,\
    \ c.Item2}).ToArray())\n    .GroupBy(c => c[0])\n    .Where(g => g.Count() ==\
    \ 1)\n    .Select(g => g.OrderBy(c => c[1]).First())\n    .ToArray();\n</code>\n\
    <|/ a tags=c# dscore=0 |>\n<| a tags=c# |>\n<code>\nclass Program\n{\n    static\
    \ void Main(string[] args)\n    {\n        int[] a = {15L, 33L, 1422L, 1L};",
  "{\n    if(x.length > 0)\n    {\n        long[] result = new long[x.length];\n \
    \       long[] result = new long[x.length];\n        long[] result = new long[x.length];\n\
    \        int[] cntx = new int[x.length];\n        int j = 0;\n        for(int\
    \ i = 0; i < x.length; i++)\n        {\n            int k = i;\n            while((k\
    \ != 0) && (k > 0))\n            {\n                if(k % 2 == 0)\n         \
    \       {\n                    cntx[--k] = 0;\n                }\n           \
    \     else\n                {\n                    cntx[k] = 0;\n            \
    \    }\n            }\n            cntx[i] = 1;\n            result[j++] = x[i];\n\
    \        }\n        for(int k = 0; k < x.length; k++)\n        {\n           \
    \ if(cntx[k] == 1)\n            {\n                result[k] = 0;\n          \
    \  }\n        }\n        return result;\n    }\n    else\n    {\n        return\
    \ new long[0];\n    }\n}\n</code>\n<|/ a tags=algorithm,arrays,sorting dscore=0\
    \ |>\n<| a |>\nTry this in python:\n<code>\ndef unique_digits(nums):\n    unique_digits\
    \ = []\n    i = 0\n    for x in nums:\n        if not str(x).isdigit():\n    \
    \        unique_digits.append(x)\n            continue\n        digit = int(x)\n\
    \        unique_digits.append(digit)\n        while i < len(unique_digits) and\
    \ digit == unique_digits[i]:\n            unique_digits.pop(i)\n            i\
    \ += 1\n    return unique_digits\n</code>\n<|/ a dscore=0 tags=algorithm,arrays,sorting\
    \ |>\n<| a dscore=0 tags=algorithm,arrays,sorting |>\nI have tried my own solution\
    \ which is O(n) time complexity and O(n) space complexity for single pass.\nIt\
    \ has two passes first pass for finding unique elements and second pass for sorting\
    \ unique elements using their indexes in another array. \n<code>", "{\n    int\
    \ j = 0;\n    long[] y = new long[x.length];\n    long z = x;\n    for(int i =\
    \ 0; i < x.length; i++)\n    {\n        if(z % 10 != 0)\n        {\n         \
    \   y[j] = z;\n            j++;\n        }\n        z = (z / 10) % 10;\n    }\n\
    \    return y;\n}\n</code>\n<|/ a tags=c++,algorithm,java,optimization |>\n<|\
    \ a |>\nI wrote a C++ implementation:\n<code>\n#include <algorithm>\n#include\
    \ <iostream>", "{\n    long i = 0, n = x.length;\n    long[] ret = new long[n];\n\
    \    long[] temp = new long[n];\n    for(int j=0; j<n; j++) \n    {\n        if(j<i)\
    \ \n        {\n            temp[j] = x[j];\n            continue;\n        }\n\
    \        if(j==i) \n        {\n            while(x[i]>0) \n            {\n   \
    \             ret[i] = x[i]%10;\n                i++;\n            }\n       \
    \     break;\n        }\n        while(x[j]>0) \n        {\n            if(j==i)\
    \ \n            {\n                ret[i] = x[i]%10;\n                i++;\n \
    \               temp[j] = x[j];\n                j++;\n                break;\n\
    \            }\n            else if(j > i) \n            {\n                temp[j]\
    \ = x[j];\n                j++;\n            }\n            else if(x[j] == x[i])\
    \ \n            {\n                while(x[i]>0)\n                {\n        \
    \            ret[i] = x[i]%10;\n                    i++;\n                }\n\
    \                break;\n            }\n            else if(x[j] < x[i]) \n  \
    \          {\n                ret[i] = x[i]%10;\n                i++;\n      \
    \      }\n            else \n            {\n                while(j>0)\n     \
    \           {\n                    temp[j] = x[j]%10;\n                    j--;\n\
    \                }\n                break;\n            }\n        }\n    }\n\
    \    for(int k=0; k<n; k++) \n    {\n        ret[k] = temp[k];\n    }\n    return\
    \ ret;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYou don't seem to have included\
    \ a comparison function for the sort algorithm\n<|/ c |>\n<| c |>\nI did include\
    \ it in the comments in the code `bool compare (int x, int y)`. How does it not\
    \ work?\n<|/ c |>\n<| c |>\nYou didn't include it in your answer. I was just commenting.\n\
    <|/ c |>\n<| c |>\nI included it, thank you! :)\n<|/ c |>\n<| c |>\nSorry, I missed\
    \ that part\n<|/ c |>\n<| a dscore=1 |>\nHere is a solution which uses no sorting\
    \ and no recursion and is O(n).\n<code>\npublic static long[] UniqueDigits(long[]\
    \ numbers)\n{\n    var uniqueDigits = new List<long>();", "{\n\t\n\tint len =\
    \ x.length;\n\tlong[] a = new long[len];\n\tlong lastEven;\n\tint pos = 0;\n\t\
    \n\tfor(int i = 0; i < len; ++i)\n\t{\n\t\tif((x[i] % 10) % 2 == 0)\n\t\t{\n\t\
    \t\ta[pos++] = x[i];\n\t\t}\n\t}\n\t\n\tsort(a, 0, a.length - 1);\n\t\n\tlastEven\
    \ = a[0];\n\t\n\tint j = 0;\n\t\n\tfor(int i = 1; i < len; ++i)\n\t{\n\t\tif((x[i]\
    \ % 10) % 2 != 0)\n\t\t{\n\t\t\ta[pos++] = x[i];\n\t\t\t\n\t\t\tif(lastEven ==\
    \ 0)\n\t\t\t{\n\t\t\t\tlastEven = x[i];\n\t\t\t\t\n\t\t\t\tj++;\n\t\t\t}\n\t\t\
    \telse\n\t\t\t{\n\t\t\t\tif(lastEven == x[i])\n\t\t\t\t{\n\t\t\t\t\tj++;\n\t\t\
    \t\t\tlastEven = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn a;\n}", "{\n\
    \    long result = 0;\n    for(int i=0; i<x.length; i++) {\n        result ^=\
    \ x[i];\n    }\n    long maxX = 0;\n    long maxY = 0;\n    int index = 0;\n \
    \   for(int i=0; i<x.length; i++) {\n        if(x[i] > maxX) {\n            maxX\
    \ = x[i];\n            maxY = index;\n        } else if(maxX == x[i]) {\n    \
    \        maxY = index;\n        }\n        index++;\n    }\n    long[] result\
    \ = new long[1];\n    result[0] = x[maxY];\n    return result;\n}\n</code>\n<|/\
    \ a tags=arrays,python dscore=1 |>\n<| a dscore=0 |>\nIn Python 3:\n<code>\ndef\
    \ unique_digits(L):\n    digits = set(map(int, str(L)))\n    return [i for i in\
    \ L if int(str(i)) != L]\n</code>\nThe advantage of the above method is that it\
    \ doesn't require sorting (which would take O(n log n) time) and it also preserves\
    \ order when there are duplicates present in the array. In the unlikely event\
    \ that duplicates are present in an array, they will be ordered after unique elements.\n\
    <|/ a tags=arrays,python |>\n<| c |>\nThis does not work, what if `L = [3, 1]`\
    \ ?\n<|/ c |>\n<| c |>\nI assume that duplicates are an acceptable assumption\
    \ for this problem. If they aren't, then this answer is wrong by all means :)\n\
    <|/ c |>\n<| c |>\nI agree. But, I am guessing that duplicates are unlikely for\
    \ his problem, hence I am mentioning it.\n<|/ c |>\n<| a tags=arrays,python |>\n\
    <code>\n# https://leetcode.com/problems/unique-numbers/\nclass Solution:\n   \
    \ def uniqueNumbers(self, nums: List[int]) -> List[int]:\n        nums = list(set(nums))\n\
    \        return sorted(nums)", "{\n\tlong len = x.length;\n\tint pos = 0;\n\t\
    int i;\n\tint j;\n\tint cnt = 0;\n\tlong[] res = new long[len];\n\tfor(i=0; i<len;\
    \ i++)\n\t{\n\t\tres[cnt] = x[i];\n\t\tcnt++;\n\t}\n\t\n\tint k;\n\t\n\tfor(j=0;\
    \ j<cnt; j++)\n\t{\n\t\tk = j;\n\t\tfor(i=j+1; i<cnt; i++)\n\t\t{\n\t\t\tif(x[i]>res[k])\n\
    \t\t\t{\n\t\t\t\tk = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(k>j)\n\t\t{\n\t\t\tres[j+1]\
    \ = res[k];\n\t\t\tres[j] = x[j];\n\t\t}\n\t}\n\t\n\treturn res;\n}", "{\n   \
    \ /*\n     Write your code here.\n    */\n    long result[] = new long[x.length];\n\
    \    int i = 0;\n    for(i = 0; i < x.length; i++)\n    {\n        int n1 = (x[i]\
    \ % 10);\n        int n2 = 0;\n        for(; i < x.length - 1; i++)\n        {\n\
    \            if(x[i] % 10 != n1)\n            {\n                n2++;\n     \
    \           break;\n            }\n        }\n        if(!(n2 > 0))\n        {\n\
    \            result[i] = x[i];\n        }\n    }\n    sort(result, result, x.length);\n\
    \    return sort(result, result, x.length);\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nthis will not return an array, it will return a sorted array.\n<|/ c |>\n\
    <| c |>\nHe doesn't ask for an array. He asks for a sorted array. He needs the\
    \ array of all numbers where the value doesn't contain an even digit.\n<|/ c |>\n\
    <| c |>\nHe asked to return all numbers without any even digit\n<|/ c |>\n<| a\
    \ |>\n<code>\npublic class UniqueDigits {\n    public static void main(String[]\
    \ args) {\n        System.out.println(getUniqueDigits(15L));\n    }\n    public\
    \ static long[] getUniqueDigits(long n) {\n        long[] result = new long[]{};\n\
    \        while (n > 0) {\n            int digit = n % 10;\n            if (result[result.length-1]\
    \ == digit) {\n                return result;\n            }\n            if (result.length\
    \ == 1) {\n                result[0] = digit;\n            } else {\n        \
    \        for (int i = 1; i < result.length; i++) {\n                    if (result[i]\
    \ == digit) {\n                        return result;\n                    }\n\
    \                }\n            }\n            n = n / 10;\n        }\n      \
    \  return result;\n    }\n}\n</code>\n<|/ a dscore=0 tags=java,arrays |>\n<| c\
    \ |>\nWhat is your comment, can you explain?\n<|/ c |>\n<| c |>\nThis does not\
    \ work.  I believe you just copied and pasted this into your IDE and tried to\
    \ run it.  It produced an error.  I fixed the errors in the code you wrote by\
    \ doing a simple change.  I added a print statement to demonstrate it working.\n\
    <|/ c |>\n<| c |>\n`result[0] = digit;`\n<|/ c |>\n<| c |>\nThis does not work.\
    \  I believe you just copied and pasted this into your IDE and tried to run it.\
    \  It produced an error.  I fixed the errors in the code you wrote by doing a\
    \ simple change.  I added a print statement to demonstrate it working.\n<|/ c\
    \ |>\n<| c |>\nI edited ", "{\n    int Nx = x.length;\n    int i;\n    long[]\
    \ ret = new long[Nx - 1];\n    \n    for (i = 0 ; i < Nx ; ++i)\n    {\n     \
    \   if (i % 2 == 0)\n        {\n            ret[i/2] = x[i];\n        }\n    \
    \    else\n        {\n            int j;\n            for (j = i ; j > 0 && x[j-1]\
    \ > x[j] ; --j)\n            {\n                ret[j] = x[j-1];\n           \
    \ }\n            ret[j] = x[j];\n        }\n    }\n    return ret;\n}", "{\n \
    \   //write your code here\n    std.sort(x);\n    long ans[] = std.unique(x.begin(),\
    \ x.end());\n    return ans;\n}", "{\n\tlong[] rs = new long[x.length];\n\tfor(int\
    \ i = 0; i < x.length; ++i)\n\t{\n\t\tlong j = x[i];\n\t\twhile(j > 0)\n\t\t{\n\
    \t\t\tlong k = (j - 1) % 10;\n\t\t\tif(k == 0)\n\t\t\t\tbreak;\n\t\t\trs[i] =\
    \ k;\n\t\t\tj = (j - k) / 10;\n\t\t\t++i;\n\t\t}\n\t}\n\tsort(rs);\n\treturn rs;\n\
    }", "{\n    long n = x.length;\n    long y = 0;\n    long[] res = new long[(int)\
    \ n];\n    \n    for(int i=0; i<n; i++)\n    {\n        while(x % 10 == 0)\n \
    \       {\n            x /= 10;\n            y++;\n        }\n        res[i] =\
    \ y;\n    }\n    return res;\n}\n</code>\n<|/ a tags=java,arrays,algorithm |>\n\
    <| a tags=java,arrays,algorithm |>\n<code>\npublic static void main(String[] args)\
    \ {", "{\n    long ans[] = new long[x.length];\n    for(int i = 0; i < x.length;\
    \ i++)\n    {\n        long n = 0;\n        for(int j = 0; j < x.length; j++)\n\
    \        {\n            if(x[i] == x[j])\n            {\n                n++;\n\
    \            }\n        }\n        if(n % 2 == 0)\n        {\n            ans[i]\
    \ = x[i];\n        }\n    }\n    return ans;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a |>\nAn alternative using two functions: \n<code>\nfunction unique_digits(num)\
    \ {\n    var digits = [],\n        ans = num.toString().split('');\n    ans.forEach(function(d)\
    \ {\n        digits.indexOf(d) === -1 && digits.push(d);\n    });\n    return\
    \ digits;\n}\n</code>\n<|/ a tags=java,algorithm,c# dscore=1 |>\n<| a dscore=0\
    \ |>\n<code>\nusing System;", "{\n    List<long> result = new LinkedList<long>();",
  "{\n    long[] res = new long[x.length];\n    \n    for(int i = 0; i < x.length;\
    \ ++i)\n    {\n        int pos = 0;\n        \n        while(pos < i && x[pos]\
    \ == 0)\n            ++pos;\n        \n        if(pos < i)\n            res[i]\
    \ = x[pos];\n        else\n            res[i] = 0;\n    }\n    return res;\n}\n\
    </code>\n<|/ a tags=c#,algorithm dscore=1 |>\n<| c |>\nThis solution also has\
    \ O(n^2) complexity which is unacceptable.\n<|/ c |>\n<| c |>\nThe `unique_digits`\
    \ function has O(n) complexity. The `unique_digits` array is reused and filled\
    \ with zeros each time the function is called.\n<|/ c |>\n<| c |>\nThis solution\
    \ has O(n^2) complexity, because the `unique_digits` function is called for each\
    \ number in the input array. There is no loop inside `unique_digits`.\n<|/ c |>\n\
    <| c |>\nThanks, that's right.\n<|/ c |>\n<| a dscore=0 |>\nI created this C#\
    \ code based on the previous solutions using the LINQ Aggregate method. \nI needed\
    \ to count the frequency of digits in an array. Thus I created an extension method\
    \ called \"FrequencyOfDigits\" that is designed to count how many times each digit\
    \ occurs in a given array.\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;", "{\n    long result = 0;\n    int n = x.length;\n    long[]\
    \ y = new long[n];\n    for(int i=0;i<n;i++){\n        y[i] = x[i];\n        if(y[i]\
    \ > result){\n            result += y[i];\n        }\n    }\n    Arrays.sort(y);\n\
    \    for(int i=0;i<n;i++){\n        if(y[i] % 2 != 0){\n            for(int j=i;j<n;j++){\n\
    \                if(y[j] % 2 == 0){\n                    y[i] = y[j];\n      \
    \              j--;\n                }else{\n                    break;\n    \
    \            }\n            }\n        }\n    }\n    return y;\n}\n</code>\n<|/\
    \ a tags=arrays,java |>\n<| c |>\nThis has O(n2) runtime complexity, just to make\
    \ it O(nlogn). Even though the question is tagged [tag:java], this is a poor solution\
    \ in C++. Also, your code doesn't work and it is unclear what your algorithm is\
    \ supposed to do.\n<|/ c |>\n<| a |>\nAs per the problem, the numbers with odd\
    \ digits are to be considered as the starting points. \nFor example, if the input\
    \ array is [12, 31, 23, 45], the array should be considered as [12, 31, 45] because\
    \ the third digit is 3 and there are only 3 digits available.\nThe following code\
    \ snippet will produce the expected output:\n<code>\npublic class DigitOddInArray\
    \ {", "{\n    //write your code in C#\n    int n = x.Length;\n    long result[]\
    \ = new long[n];\n    for (int i = 0; i < n; i++)\n    {\n        int count =\
    \ 0;\n        for (int j = 0; j < n; j++)\n        {\n            if (x[j] % 10\
    \ == 0)\n            {\n                count++;\n            }\n        }\n \
    \       if (count == 0)\n        {\n            result[i] = x[i];\n        }\n\
    \    }\n    Array.Sort(result, 0, n);\n    return result;\n}\n</code>\n<|/ a tags=arrays,c#\
    \ dscore=0 |>\n<| c |>\nI thought about doing that, but I thought the purpose\
    \ of Stackoverflow is to learn how to solve problems. Not just to get a solution\
    \ to a problem. Plus I'm more interested in learning about the language than a\
    \ solution to a problem\n<|/ c |>\n<| c |>\n: This question was asked to \"learn\
    \ the language\", so I gave an answer that focused on the actual problem. As far\
    \ as learning, the solution can be found quickly with internet searches on \"\
    c# find duplicates in array\". Stack Overflow is not for learning the language,\
    \ it's for solving problems, which is what this question was about (and what this\
    \ answer does) -- you didn't state that you wanted to learn the language, just\
    \ that the solution should include learning the language.\n<|/ c |>\n<| c |>\n\
    I understand. Thanks for your help :)\n<|/ c |>\n<| c |>\nHi Martin, would you\
    \ mind looking at the below question? If you're able to help please. http://stackoverflow.com/questions/29697108/how-to-delete-duplicate-elements-from-an-array-in-c-sharp\n\
    <|/ c |>\n<| c |>\n, it's been a while, but I think I'd try to get back to you\
    \ on this question as soon as I can. :-)\n<|/ c |>\n<| a tags=arrays,c# |>\nI\
    \ thought about doing that, but I thought the purpose of Stackoverflow is to learn\
    \ how to solve problems. Not just to get a solution to a problem. Plus I'm more\
    \ interested in learning about the language than a solution to a problem", "{\n\
    \    int N = x.length;\n    long[] result = new long[N];\n    \n    for (int i\
    \ = 0; i < N; i++)\n    {\n        int count = 0;\n        for (int j = i; j <\
    \ N; j++)\n        {\n            if (std.math.mod(x[j], 10) == 0) count++;\n\
    \        }\n        if (count == 0)\n            result[i] = x[i];\n    }\n  \
    \  return result;\n}", "{\n    int[] digits = new int[x.length];\n    for(int\
    \ i=0; i<x.length; i++){\n        int xi = x[i];\n        digits[i] = xi % 10;\n\
    \    }\n    return std.sort(digits);\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    I see what you're saying but I can't use any built in functions. I'm trying to\
    \ do this without using the built in functions. Any ideas how I could do it?\n\
    <|/ c |>\n<| a dscore=0 |>\nI'm going to assume you really can't use any built-in\
    \ functions. And that the array you're given is a JavaScript array. Also, the\
    \ array is sorted from smallest to largest.\nAs others have pointed out, you need\
    \ to keep track of the numbers that you've already seen (and the one you haven't).\n\
    Here's what your code looks like without the sorting:\n<code>\nfunction uniqueDigits(arr)\
    \ {\n    var unique = [];\n    var seen = [];\n    var unseen = [];", "{\n   \
    \ long[] ret=new long[x.length];\n    for(int i=0;i<x.length;i++)\n    {\n   \
    \     int cnt=0;\n        for(int j=0;j<x.length;j++)\n        {\n           \
    \ if((x[i]%10) == (x[j]%10))\n                cnt++;\n        }\n        if(cnt==0)\n\
    \            ret[i] = x[i];\n    }\n    Arrays.sort(ret);\n    return ret;\n}\n\
    </code>\n<|/ a |>\n<| a tags=java,arrays,sorting,algorithm |>\nAs said in the\
    \ comments, there exist a solution using a hash map which has linear complexity.\
    \ \nHowever, there is a variant of this problem where the complexity is constant.\
    \ Here is the code:\n<code>\npublic int[] removeEvens(int[] a) {\n    if (a ==\
    \ null || a.length == 0) {\n        return null;\n    }\n    HashMap<Integer,Integer>\
    \ map = new HashMap<>();\n    for (int i : a) {\n        if (map.containsKey(i))\
    \ {\n            map.put(i,map.get(i)+1);\n        } else {\n            map.put(i,\
    \ 1);\n        }\n    }\n    int[] result = new int[a.length];\n    for (int i\
    \ : map.keySet()) {\n        if (map.get(i) == 1) {\n            result[result.length-i-1]\
    \ = i;\n        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nHow do you get that linear complexity? Do you do any operations at all\
    \ on `map`?\n<|/ c |>\n<| c |>\nYes, I use the get() method of the map. As stated\
    \ [here](http://stackoverflow.com/questions/10866452/hash-map-complexity).\n<|/\
    \ c |>\n<| a dscore=1 |>\nThe simple answer is to use HashSet. Its add method\
    \ returns true if element was added and false otherwise.\n<code>\npublic static\
    \ void main(String[] args) {\n    Set<Integer> s = new HashSet<Integer>();\n \
    \   s.add(1);\n    s.add(2);\n    System.out.println(s.contains(1));\n}\n</code>\n\
    <|/ a tags=java,arrays,sorting,algorithm |>\n<| c |>\nThe question specifically\
    \ says no sets are allowed\n<|/ c |>\n<| c |>\nI assume he meant `java.util.HashSet`.\n\
    <|/ c |>\n<| c |>\nI assume he meant no `Set`s :)\n<|/ c |>\n<| c |>\nNo, he specifically\
    \ said no `Set`s and no arrays at all\n<|/ c |>\n<| c |>\nYou might want to read\
    \ the ", "{\n    long[] result = new long[x.length];\n    int i=0,j=0,k=0;\n \
    \   for(int i1=0;i1<x.length;i1++)\n    {\n        long value = x[i1];\n     \
    \   for(i=0;i<result.length;i++)\n        {\n            if(result[i]==0 && std.math.abs(value)==std.math.abs(result[i]))\n\
    \            {\n                k=i;\n                break;\n            }\n\
    \        }\n        if(k==i)\n        {\n            result[k]=value;\n      \
    \  }\n        else\n        {\n            j=result.length;\n            while(j>k)\n\
    \            {\n                result[j]=result[j-1];\n                j--;\n\
    \            }\n            result[j]=value;\n        }\n    }\n    return result;\n\
    }", "{\n    Arrays.sort(x);\n    long[] result = new long[x.length];\n    int\
    \ j = 0;\n    for(int i = 0; i < x.length; i++)\n    {\n        if(i % 2 == 0)\n\
    \            result[j] = x[i];\n        j++;\n    }\n    return result;\n}\n/*\n\
    Given an int array arr of positive integers return an array of\n    length arr.length\
    \ containing all the unique elements of\n    arr in sorted order.", "{\n    long[]\
    \ y = new long[x.length];\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < x.length; ++i) {\n        if (x[i] % 2 == 0) {\n           \
    \ flag = true;\n        }\n        else {\n            if (flag) {\n         \
    \       y[count] = x[i];\n                flag = false;\n                ++count;\n\
    \            }\n            else {\n                y[i] = x[i];\n           \
    \ }\n        }\n    }\n    return y;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    <code>\nimport java.util.*;", "{\n\t// write your code in C++11/C++14/...\t\n\t\
    return null;\n}\n/*\n    Given an array of positive integers x. return true if\
    \ \n    all elements are divisible by 2 and not divisible by 3.\n    \n    Note:\
    \ Returned array should be sorted in increasing order.\n    \n    For example:\n\
    \    >>> all_divisible_by_2([5L, 10L, 2L])\n    True\n    >>> all_divisible_by_2([5L,\
    \ 10L, 11L])\n    False\n*/", "{\n    long[] result = new long[x.length];\n  \
    \  int j = 0;\n    long xDigit = std.math.toD(x[0]);\n    for (int i = 0; i <\
    \ x.length; i++)\n    {\n        if (xDigit % 2 == 0)\n            continue;\n\
    \        xDigit = std.math.toD(x[i]);\n        if (j >= result.length)\n     \
    \       throw new IllegalArgumentException(\"Not enough digits\");\n        while\
    \ (j < result.length)\n        {\n            if (j == 0)\n                result[j]\
    \ = xDigit;\n            else if (j == result.length - 1)\n                result[j]\
    \ = std.math.toD(x[j] + xDigit);\n            else\n                result[j]\
    \ = std.math.toD(x[j]);\n            j++;\n        }\n    }\n    return result;\n\
    }\n/*\nGiven an array of integers x, return a sorted array of all even digits.",
  "{\n    long result = new long();\n    long remainder = 0;\n    bool isEven = true;\n\
    \    for (long i=0;i<x.length;i++) \n    {\n        remainder = x[i] % 10;\n \
    \       isEven = !isEven;\n        if (remainder<2 && !isEven)\n        {\n  \
    \          result = x[i];\n            break;\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=java,arrays dscore=1 |>\n<| a tags=java,arrays dscore=0\
    \ |>\nYou have to check each number in sequence for its digits, if the sum of\
    \ their digits is even, you should add them to the list in the first place.\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>\n   import java.util.*;\n    import java.lang.*;\n\
    \    public class UniqueDigits {\n        public static void main(String args[])\n\
    \        {\n            Scanner sc=new Scanner(System.in);\n            int array[]=new\
    \ int[1000];\n            int j;\n            System.out.println(\"enter the elements\"\
    );\n            for(j=0;j<array.length;j++)\n            {\n                array[j]=sc.nextInt();\n\
    \            }\n            Arrays.sort(array);\n            System.out.println(\"\
    the unique digits are\");\n            int unique=0;\n            for(int i=0;i<array.length;i++)\n\
    \            {\n                int num =array[i];\n                boolean flag=true;\n\
    \                while(flag)\n                {\n                    if(num%10==0)\n\
    \                    {\n                        unique=unique+num%10;\n      \
    \                  flag=false;\n                    }\n                    else\n\
    \                    {\n                        num=num/10;\n                \
    \    }\n                }\n                unique=unique+num;\n              \
    \  System.out.println(unique);\n            }\n        }\n    }\n</code>\n<|/\
    \ a tags=java,arrays |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;", "{\n\
    \    if (x.Length == 0) return x;\n    long [] z = new long[x.Length];\n    long\
    \ xc = 0;\n    for (int i = 0; i < x.Length; ++i) \n    {\n        xc += x[i];\
    \ \n        z[i] = xc % 10; \n        xc /= 10; \n    } \n    Array.Sort(z); \n\
    \    int c = 0;\n    for (int i = 0; i < z.Length; ++i) \n    {\n        if (!(z[i]\
    \ % 2)) \n        {\n            z[c++] = z[i]; \n        }\n    }\n    return\
    \ z; \n}\n</code>\n<|/ a tags=.net,arrays,c# |>\n<| a |>\nHere is a solution using\
    \ LINQ:\n<code>\npublic int[] findUnevenNumbers(int[] values)\n{\n    int sum\
    \ = values.Sum();\n    return values.Where(x => x % 2 == 0).TakeWhile(x => x !=\
    \ sum).ToArray();\n}\n</code>\n<|/ a dscore=2 tags=.net,arrays,c# |>\n<| a dscore=2\
    \ tags=.net,arrays,c# |>\n<code>\nclass Program\n    {\n        static void Main(string[]\
    \ args)\n        {\n            int[] ar = new int[] { 1, 6, 4, 5, 7, 4, 5 };\n\
    \            int[] result = new int[ar.Length];\n            int i = 0;\n    \
    \        int sum = 0;\n            bool flag = true;\n            while (i < ar.Length\
    \ && flag)\n            {\n                sum += ar[i];\n                flag\
    \ = false;\n                for (int j = 0; j < i; j++)\n                {\n \
    \                   if (ar[j] % 2 != 0)\n                    {\n             \
    \           flag = true;\n                        break;\n                   \
    \ }\n                }\n                if (flag)\n                {\n       \
    \             result[i] = sum;\n                    i++;\n                }\n\
    \                sum = 0;\n            }\n            foreach (int item in result)\n\
    \            {\n                Console.Write(item);\n            }\n        \
    \    Console.ReadKey();\n        }\n    }\n</code>\n<|/ a |>\n<| a tags=.net,arrays,c#\
    \ |>\nHere is my solution\n<code>\npublic static int[] FindUnEvens(int[] numbers)\n\
    \        {\n            if (numbers.Length == 0)\n            {\n            \
    \    return numbers;\n            }", "{\n    long[] result = new long[x.length];\n\
    \    long temp;\n    int i, j = 0;\n    for(i = 0; i < x.length; i++)\n    {\n\
    \        temp = x[i]%10;\n        for(; j < i; j++)\n        {\n            if(\
    \ x[j] % 10 == temp )\n            {\n                break;\n            }\n\
    \        }\n        result[i] = x[j];\n    }\n    for(i = j; i < x.length; i++)\n\
    \    {\n        result[i] = 0;\n    }\n    \n    return result;\n}", "{\n    long[]\
    \ ret = new long[x.length];\n    \n    long curr = 0, next = 0;\n    for(int i\
    \ = 0; i < x.length; i++) {\n        curr = (x[i] - '0') % 10;\n        if (next\
    \ == 0) {\n            ret[i] = curr;\n            next = curr;\n        } else\
    \ {\n            if (curr % 2 == 0) {\n                ret[i] = curr;\n      \
    \      } else {\n                if (ret[i] > curr) {\n                    ret[i]\
    \ = curr;\n                }\n            }\n        }\n    }\n    \n    return\
    \ ret;\n}\n</code>\n<|/ a tags=java,algorithm |>\n<| c |>\nThis is not correct\
    \ answer. With input of [1,2,3] it returns [1,2,3] instead of [2,3]. Your logic\
    \ works because you start with a new array and add the current elements to the\
    \ array. With this algorithm [1,2,3] gets converted to [2,3,1]\n<|/ c |>\n<| a\
    \ dscore=0 tags=java,algorithm |>\nThis is my solution which I think is more clear\
    \ and simple:\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport\
    \ java.util.stream.Collectors;", "{\n    int n=x.length;\n    long[] y = new long[n];\n\
    \    long count=0;\n    for(long i = 0; i< n; ++i)\n    {\n      for(long j=0;j<n;j++)\n\
    \      {\n        if(x[i]==x[j])\n        {\n          count++;\n          break;\n\
    \        }\n      }\n      if(i==n-1 || count!=0)\n      {\n        if(count%2!=0)\n\
    \          y[i]=x[i];\n      }\n      count=0;\n    }\n    return y;\n}\n</code>\n\
    <|/ a tags=algorithm,sorting,performance,java |>\n<| c |>\nThe above code will\
    \ work, but there are a couple of bugs (which I have fixed in my answer). However,\
    \ the above code will give incorrect results if the list is longer. For example:\
    \ If the list is `[15L, 33L, 1422L, 1L, 3L]`, then the output will be `[15L, 33L,\
    \ 1L]`, since the count of 10 in that list will add up to 4. I believe the code\
    \ should be changed to `if(count%2!=0) y[i]=x[i];`.\n<|/ c |>\n<| a dscore=2 tags=algorithm,sorting,performance,java\
    \ |>\nFor an interviewer this is more of a trick question.  My solution would\
    \ be to sort the array first and then loop through the array and if the count\
    \ of even numbers found is odd, then the number found is not unique and add it\
    \ to a new array.\n<code>", "{\n\tint len= x.length;\n\tif(len==0)\n\t\treturn\
    \ new long[0];\n\tlong[] res=new long[len];\n\tint i;\n\tfor(i=0;i<len;i++)\n\t\
    {\n\t\tint cnt=0;\n\t\twhile(x[i]>0)\n\t\t{\n\t\t\tif(x[i]%10==0)\n\t\t\t\tcnt++;\n\
    \t\t\tx[i]=x[i]/10;\n\t\t}\n\t\tif(cnt==0)\n\t\t\tres[i]=x[i];\n\t}\n\tsort(res);\n\
    \treturn res;\n}\n/**\n * Preconditions:\n * 0 <= arr[i] <= 9\n * \n * Postconditions:\n\
    \ * arr[i] == 0 \n */", "{\n  long long result = 0;\n  long long pow = 1;\n  long[]\
    \ result = new long[x.length];", "{\n    long[] result = new long[x.length];\n\
    \    std.arraysort(x);\n    \n    for(int i=0; i<x.length; i++)\n    {\n     \
    \   if(x[i] % 2 == 0)\n        {\n            for(int j=i+1; j<x.length; j++)\n\
    \            {\n                if(x[j] % 2 != 0)\n                {\n       \
    \             break;\n                }\n                else\n              \
    \  {\n                    result[i] = x[i];\n                    j--;\n      \
    \          }\n            }\n        }\n    }\n    \n    return result;\n}", "{\n\
    \    long ans[] = new long[x.length];\n    int pos = 0;\n    \n    for(int i =\
    \ 0; i < x.length; i++){\n        while(ans[pos] > 0 && x[pos] != 0){\n      \
    \      pos++;\n        }\n        if(ans[pos] == 0 && x[pos] != 0){\n        \
    \    ans[pos] = x[pos];\n        }\n        x[pos] = 0;\n    }\n    \n    return\
    \ ans;\n}\n</code>\n<|/ a tags=algorithm,c++,arrays |>\n<| c |>\nWhat about negative\
    \ numbers?\n<|/ c |>\n<| c |>\n, It will work correctly. Negative numbers are\
    \ treated as zero. For example, -7 is treated as 0.\n<|/ c |>\n<| c |>\nI understand\
    \ that, but in the example given, it is not working correctly for the input\n\
    <|/ c |>\n<| c |>\n, I updated my answer to include negative numbers as well.\
    \ If you would like to see my original answer, I will remove it.\n<|/ c |>\n<|\
    \ c |>\nthanks for your answer. Your answer works for the given input but it's\
    \ taking too much time to execute for a large input. Hence I accepted another\
    \ answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <bits/stdc++.h>\nusing\
    \ namespace std;", "{\n    Arrays.sort(x);\n    \n    long result = 0;\n    int\
    \ index = 0;\n    for(long i = 0; i < x.length; i++)\n    {\n        result =\
    \ result + x[i];\n        \n        while(result % 10 == 0 && result != 0)\n \
    \       {\n            int pos = (int)result % 10;\n            long value = result\
    \ / 10;\n            for(int j = 1; j < i; j++)\n            {\n             \
    \   if(x[j] > value)\n                {\n                    long t = x[j];\n\
    \                    x[j] = x[i];\n                    x[i] = t;\n           \
    \     }\n            }\n            result /= 10;\n            index++;\n    \
    \    }\n    }\n    return x.subarray(0, index);\n}", "{\n    int result[] = new\
    \ int[x.length];\n    int i;", "{\n    long[] result = new long[x.length];", "{\n\
    \    long result[] = Long.toArray(x);\n    Arrays.sort(result);\n    return Arrays.copyOfRange(result,\
    \ 0, result.length);\n}", "{\n    var ans = x[0];\n    for(int i = 1; i < x.length;\
    \ i++){\n        if( x[i] % 2 == 0 )\n            continue;\n        ans += x[i];\n\
    \    }\n    return ans;\n}", "{\n    /*\n    Write your code here\n    */\n  \
    \  long[] result = new long[x.length];\n    int n = x.length;\n    for(int i =\
    \ 0; i < n; i++) \n    {\n        int count = 0;\n        for(int j = 0; j < n;\
    \ j++) \n        {\n            if(x[j] == x[i] && x[j] % 10 == 0) \n        \
    \    {\n                count++;\n                \n            }\n        }\n\
    \        \n        for(int j = 0; j < count; j++) \n        {\n            result[count]\
    \ = x[i];\n            count++;\n        }\n    }\n    \n    for(int i = 0; i\
    \ < n; i++) \n    {\n        for(int j = i+1; j < n; j++) \n        {\n      \
    \      if(result[i] > result[j]) \n            {\n                int temp = result[i];\n\
    \                result[i] = result[j];\n                result[j] = temp;\n \
    \           }\n        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis is a great solution, however the algorithm is `O(n^2)`\n<|/\
    \ c |>\n<| c |>\n, Thanks for your kind suggestion. I modified the code and optimized\
    \ it.\n<|/ c |>\n<| a tags=sorting,algorithm,java,arrays |>\n<code>\n    public\
    \ class EvenDigit {\n        public static void main(String[] args) {\n      \
    \      long[] arr = { 15L, 33L, 1422L, 1L, 152L, 323L, 1422L, 10L };\n       \
    \     System.out.println(Arrays.toString(new EvenDigit().unique(arr)));\n    \
    \    }", "{\n    long len = x.length;\n    \n    int maxNum = 0;\n    for(int\
    \ i = 1; i < len; i++)\n    {\n        if(x[i] > maxNum)\n        {\n        \
    \    maxNum = x[i];\n        }\n    }\n    \n    long digit = 0;\n    for(int\
    \ i = 1; i < len; i++)\n    {\n        digit = (long) (x[i]/maxNum);\n       \
    \ if(digit % 2 == 0)\n        {\n            return x;\n        }\n        else\
    \ if(digit == maxNum)\n        {\n            x[i] = 0;\n        }\n    }\n  \
    \  \n    return x;\n}\n</code>\n<|/ a tags=c++,algorithm dscore=0 |>\n<| a |>\n\
    This can be done in O(n) by keeping track of the last number seen as you process\
    \ each number:", "{\n    long[] a = new long[x.Length];\n    int i = 0;\n    foreach\
    \ (long a in x)\n    {\n        if (i % 2 == 0)\n        {\n            a[i] =\
    \ x;\n        }\n        i++;\n    }\n    Array.Sort(a);\n    return a;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThat doesn't meet the OP's requirement that all numbers be\
    \ converted to positive integers.\n<|/ c |>\n<| c |>\nYep, you're right - I've\
    \ missed that part. I've updated my answer to support negative numbers.\n<|/ c\
    \ |>\n<| a dscore=1 |>\nThe code below will find the numbers with unique digits\
    \ and save them to an array named uniqueDigits.\n<code>\npublic static void main(String[]\
    \ args) \n{\n    ArrayList<Integer> uniqueDigits = new ArrayList<Integer>();",
  "{\n    long[] result = new long[x.length];\n    long[] result = new long[x.length];",
  "{\n    int i;\n    long result[] = new long[x.length];\n    for(i = 0; i < x.length;\
    \ i++){\n        if((int)x[i] % 2 != 0){\n            result[result.length-1]\
    \ = (long)result[result.length-1]+x[i];\n        }\n    }\n    Arrays.sort(result);\n\
    \    return result;\n}\n/*\nGiven an array of integers x, return an array with\
    \ all its elements \n    divisible by 3. \n    \n    For example:\n    >>> divisible_by_3(5L)\n\
    \    [3, 3, 3]\n    >>> divisible_by_3(10L)\n    [3, 3, 3]\n    \n*/\nlong[] divisible_by_3(long[]\
    \ x) \n{\n    long[] result = new long[x.length];\n    int i;\n    for(i = 0;\
    \ i < x.length; i++){\n        if(x[i] % 3 == 0){\n            result[result.length-1]\
    \ = x[i];\n        }\n    }\n    Arrays.sort(result);\n    return result;\n}\n\
    /*\nGiven an array of integers x, return an array with all its elements \n   \
    \ divisible by 5. \n    \n    For example:\n    >>> divisible_by_5(5L)\n    [5,\
    \ 5, 5]\n    >>> divisible_by_5(10L)\n    [5, 5, 5]\n    \n*/\nlong[] divisible_by_5(long[]\
    \ x) \n{\n    long[] result = new long[x.length];\n    int i;\n    for(i = 0;\
    \ i < x.length; i++){\n        if(x[i] % 5 == 0){\n            result[result.length-1]\
    \ = x[i];\n        }\n    }\n    Arrays.sort(result);\n    return result;\n}\n\
    /*\nGiven an array of integers x, return an array with all its elements \n   \
    \ divisible by 7. \n    \n    For example:\n    >>> divisible_by_7(5L)\n    [7,\
    \ 7, 7]\n    >>> divisible_by_7(10L)\n    [7, 7, 7]\n    \n*/\nlong[] divisible_by_7(long[]\
    \ x) \n{\n    long[] result = new long[x.length];\n    int i;\n    for(i = 0;\
    \ i < x.length; i++){\n        if(x[i] % 7 == 0){\n            result[result.length-1]\
    \ = x[i];\n        }\n    }\n    Arrays.sort(result);\n    return result;\n}\n\
    /*\nGiven an array of integers x, return an array with all its elements \n   \
    \ divisible by 9. \n    \n    For example:\n    >>> divisible_by_9(5L)\n    [9,\
    \ 9, 9]\n    >>> divisible_by_9(10L)\n    [9, 9, 9]\n    \n*/\nlong[] divisible_by_9(long[]\
    \ x) \n{\n    long[] result = new long[x.length];\n    int i;\n    for(i = 0;\
    \ i < x.length; i++){\n        if(x[i] % 9 == 0){\n            result[result.length-1]\
    \ = x[i];", "{\n    long[] result = new long[x.length];\n    Arrays.sort(x);\n\
    \    for(int i = 0; i < x.length; ++i)\n        if(i % 2 == 0)\n            result[x[i]-1]++;\n\
    \    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease don't post\
    \ answers only pointing towards an external resource without giving any explanation.\
    \ Your answer will be deleted by the system anyway if that's the case.\n<|/ c\
    \ |>\n<| c |>\nSorry about that, I thought I was the only one who thought the\
    \ code was self explanatory but after reading your comments I saw the explanation,\
    \ thank you. I'll edit my answer accordingly.\n<|/ c |>\n<| a |>\n<code>\nimport\
    \ java.util.Arrays;", "{\n    long[] res = new long[x.length];\n    for (int i\
    \ = 0; i < x.length; ++i)\n    {\n        long d = x[i];\n        int j = 0;\n\
    \        while (j < res.Length && d%10 == res[j])\n            ++j;\n        if\
    \ (j == res.Length)\n        {\n            res[j++] = d;\n        }\n    }\n\
    \    return res;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI solved this\
    \ problem using recursive approach and O(nlogn) complexity.\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Scanner;", "{\n    if(x.length==0)\n    {\n        return long.array(0);\n\
    \    }\n    \n    long[] result = new long[x.length];\n    \n    for(int i=0;\
    \ i<x.length; i++)\n    {\n        int curr = x[i];\n        \n        for(int\
    \ j=i+1; j<x.length; j++)\n        {\n            int other = x[j];\n        \
    \    \n            if(other %  curr == 0)\n            {\n                result\
    \ = std.array.append(result, other);\n                \n                if(j==i+1)\n\
    \                {\n                    x = std.array.removeAt(x, i);\n      \
    \              \n                    i = j-1;\n                }\n           \
    \ }\n        }\n    }\n    \n    return std.array.sort(result);\n}\n/*\nGiven\
    \ an array of positive integers x. return a sorted array of all \n    elements\
    \ that hasn't any odd digit.", "{\n    long temp = 0;\n    long[] result = new\
    \ long[x.Length];\n    for(int i=0; i<x.Length; i++)\n    {\n        temp = x[i]%10;\n\
    \        if(temp == 0) \n            result[i] = x[i];\n        else if(temp >\
    \ 0)\n        {\n            while(temp > 0)\n            {\n                temp\
    \ = temp/10;\n                if(temp%2 == 0)\n                    result[i] =\
    \ x[i];\n                else\n                    break;\n            }\n   \
    \     }\n    }\n    return result;\n}", "{\n    // write your code in C# 6.0 with\
    \ LINQ", "{\n\tint sz = x.length;\n\tlong[] ret = new long[sz];\n\tint[] counter\
    \ = new int[sz];\n\tfor (int i = 0; i < sz; i++)\n\t\tcounter[x[i]]++;\n\tfor\
    \ (int i = 0; i < sz; i++)\n\t{\n\t\tif (counter[i] > 1)\n\t\t{\n\t\t\tret[i]\
    \ = x[i];\n\t\t\tcounter[i] -= 2;\n\t\t}\n\t\telse\n\t\t\tcounter[i] = 0;\n\t\
    }\n\treturn ret;\n}", "{\n    long[] result = new long[x.length];\n    for(int\
    \ i = 0; i < x.length; i++)\n    {\n        long y = x[i];\n        long sum =\
    \ 0;\n        for(int j = 0; j < y; j++)\n        {\n            sum += y;\n \
    \       }\n        if(sum % 2 != 0)\n            result[i] = y;\n    }\n    Arrays.sort(result);\n\
    \    return result;\n}\n</code>\n<|/ a dscore=0 tags=java,arrays |>\n<| a dscore=0\
    \ tags=java,arrays |>\n<code>\nclass Solution {", "{\n\tbool flag = true;\n\t\
    int index = 0;\n\tlong[] res = new long[x.length];\n\tfor(int i = 0; i < x.length;\
    \ i++)\n\t{\n\t\tif(x[i] % 2 == 0)\n\t\t\tflag = false;\n\t\telse\n\t\t{\n\t\t\
    \tres[index] = x[i];\n\t\t\tindex++;\n\t\t}\n\t}\n\tif(flag)\n\t\tres[index-1]\
    \ = 0;\n\treturn res;\n}", "{\n    int n = x.length;\n    int c = 0;\n    int\
    \ l = 0;\n    long[] res = new long[n];\n    for (int i = 0; i < n; i++) {\n \
    \       while ((c < i) && (x[c] == x[l])) {\n            c += 1;\n           \
    \ if (c == i) {\n                while (c >= i) {\n                    res[i]\
    \ = x[c];\n                    c -= 1;\n                }\n                break;\n\
    \            }\n        }\n        while (c < i) {\n            res[i] = x[c];\n\
    \            c += 1;\n        }\n        l += 1;\n    }\n    return res;\n}\n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\nfunction uniqueDigits(arr) {\nlet\
    \ newArr = []\nfor(let num of arr){\n    for(let num of newArr){\n        if(num\
    \ % 10 !== 0){\n            newArr.push(num)\n            break\n        }\n \
    \   }\n}\nreturn newArr\n}\n</code>\n<|/ a tags=arrays,algorithm,java |>\n<| c\
    \ |>\nWhile this code may solve the problem, a few words of explanation would\
    \ help to improve the quality of your post. As it's currently written, it's hard\
    \ to understand your solution.\n<|/ c |>\n<| c |>\nThis code will only return\
    \ digits that are unique, not the entire number.\n<|/ c |>\n<| a |>\nHere is a\
    \ solution that finds unique digits from the input array:\n<code>\nfunction findUniqueDigits(nums)\
    \ {\n  const digitMap = {};", "{\n\tlong long ans = (x[0]%100000000L);\n\tint\
    \ len = x.length;\n\t\n\tfor(int i = 1; i < len; i++)\n\t{\n\t\tif(x[i]%100000000L\
    \ == ans)\n\t\t\tans = (x[i]%100000000L);\n\t}\n\tlong[] ans = new long[1];\n\t\
    ans[0] = ans;\n\t\n\tfor(int i = 1; i < len; i++)\n\t{\n\t\tif(x[i]%100000000L\
    \ == ans)\n\t\t{\n\t\t\tint index = 0;\n\t\t\twhile(index < 1 && x[i]%100000000L\
    \ == ans)\n\t\t\t{\n\t\t\t\tx[i] = x[i+1];\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\t\
    ans[index] = x[i];\n\t\t}\n\t}\n\t\n\treturn ans;\n}", "{\n  long[] result = new\
    \ long[x.length];\n  for(int i = 0; i < x.length; i++) {\n    long val = x[i];\n\
    \    while (val > 0) {\n      int lastDigit = val % 10;\n      if (lastDigit ==\
    \ 0) {\n        result [--i] = 0;\n      }\n      val /= 10;\n    }\n  }\n  Arrays.sort(result);\n\
    \  return result;\n}", "{\n  int N = x.length;\n  int n = 0;\n  long[] y = new\
    \ long[N];\n  for(int i = 0; i <N; ++i){\n    if(x[i] % 2 == 0) {\n      y[n]\
    \ = x[i];\n      ++n;\n    } else {\n      for(int j = 0; j < i; ++j){\n     \
    \   if(x[j] == x[i])\n          x[j] = -1;\n      }\n    }\n  }\n  return y;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis code is O(N^2) which is too much\
    \ for larger inputs. In fact, it's O(N*N) in worst case. I was thinking O(N).\n\
    <|/ c |>\n<| c |>\nYeah, I saw that too. Sorry about that.\n<|/ c |>\n<| a |>\n\
    I agree with that it is possible with BigInteger and some simple mathematics.\
    \ \nHere's a recursive solution with comments.\n<code>\nimport java.math.BigInteger;",
  "{\n    var res = new long[x.Length];\n    \n    var digits = new int[x.Length];\n\
    \    foreach (var n in x) \n    {\n        int j = n % 10;\n        digits[j]\
    \ = digits[j] + 1;\n    }\n    \n    var cnt = 0;\n    for (var j = 1; j < x.Length;\
    \ ++j)\n    {\n        if (digits[j] > 0)\n        {\n            res[cnt++] =\
    \ x[j];\n            --digits[j];\n        }\n    }\n    \n    return res;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis is an O(n) solution (assuming constant\
    \ time lookup table). How does this compare to the other solutions?\n<|/ c |>\n\
    <| c |>\n: It takes 2 loops over an array and 2 loops over an array. Since it's\
    \ an O(n) solution it also runs in O(n) time.\n<|/ c |>\n<| a |>\nHere is an O(n)\
    \ solution using O(1) space and O(n) iterations.\n<code>\nstatic long unique_digits(long[]\
    \ x) {\n    long[] digits = new long[x.Length];", "{\n\tint i, j, k;\n\tlong[]\
    \ result = new long[x.length];\n\t\n\tfor(i = 0; i < x.length; ++i)\n\t{\n\t\t\
    for(j = 0; j < i; ++j)\n\t\t{\n\t\t\tif(x[j] > x[i])\n\t\t\t\tbreak;\n\t\t}\n\t\
    \tif(j == i)\n\t\t\tresult[i] = x[i];\n\t\telse\n\t\t{\n\t\t\tk = j;\n\t\t\tfor(;\
    \ k < i; ++k)\n\t\t\t\tresult[k] = result[k + 1];\n\t\t\tresult[k] = x[i];\n\t\
    \t}\n\t}\n\treturn result;\n}", "{\n\tbool flag = false;\n\tlong count = 0;\n\t\
    long last = 0;\n\tlong i;\n\t\n\tList<long> l = new List<long>();\n\tforeach(long\
    \ l in x)\n\t{\n\t\t\n\t\tif (l.ToString().Count(x => x == '0') > 2)\n\t\t{\n\t\
    \t\tflag = false;\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag = true;\n\t\t\t\
    count = 0;\n\t\t\tlast = l;\n\t\t}\n\t\t\n\t\tif (!flag)\n\t\t{\n\t\t\tfor (i\
    \ = l; i <= last; i++)\n\t\t\t{\n\t\t\t\tif (l.ToString().Count(x => x == i) >\
    \ 2)\n\t\t\t\t{\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\
    if (flag)\n\t\t{\n\t\t\tl.Add(l);\n\t\t}\n\t}\n\treturn l.ToArray();\n}\n</code>\n\
    <|/ a tags=c#,algorithm,arrays,sorting |>\n<| a |>\nI thought I would post my\
    \ solution which involved LINQ and a little bit of creativity.\n<code>", "{\n\t\
    var result=new long[x.Length];\n\tvar count=0;\n\tfor(int i=0;i<x.Length;i++)\n\
    \t{\n\t\tvar digit=x[i]%10;\n\t\tif(digit!=0 && count<result.Length)\n\t\t{\n\t\
    \t\tresult[count]=digit;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Given an array of integers x. return a sorted array of all \n    elements that\
    \ has odd digit and that has at least one even digit.", "{\n    long[] y;\n  \
    \  y = new long[x.size()];\n    for(int i=0;i<x.size();++i){\n        int pos\
    \ = (int)std.math.abs(x[i]) / 10;\n        int count = 0;\n        for(int j=pos;j<y.length;j++){\n\
    \            int x = y[j];\n            if(x%10 == 0){\n                count++;\n\
    \            }\n            else{\n                break;\n            }\n   \
    \     }\n        if(count <= 1){\n            y[pos] = x[i];\n        }\n    \
    \    else{\n            break;\n        }\n    }\n    return y;\n}", "{\n    long[]\
    \ ret = new long[x.length];\n    long last;\n    int pos;\n    int cnt;\n    int\
    \ i;\n    for(i =0 ; i< x.length; i++)\n    {\n        cnt = 0;\n        last\
    \ = 0;\n        pos = -1;\n        for(; i< x.length; i++)\n        {\n      \
    \      if(x[i] != last)\n            {\n                if(cnt==0)\n         \
    \           ret[i] = x[i];\n                if(cnt==1)\n                    pos\
    \ = i;\n                last = x[i];\n                cnt = 1;\n            }\n\
    \            else\n            {\n                cnt++;\n            }\n    \
    \    }\n        if(cnt==1)\n            ret[i] = x[pos];\n    }\n    return ret;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice job posting an answer to your own\
    \ question, even if not an answer to the OP.\n<|/ c |>\n<| c |>\nThanks for posting\
    \ your answer. I've added some additional information based on your answer. Hopefully\
    \ it helps future SO readers :)\n<|/ c |>\n<| a |>\nHere's an optimized version\
    \ which uses a single pass through the input array rather than a nested loop (which\
    \ would require O(n^2) complexity):\n<code>\nfunction unique_digits(x) {\n   \
    \ var ret = [];\n    var pos;\n    var i;\n    for(i = 0; i < x.length; i++) {\n\
    \        pos = 0;\n        while(x[i] === x[pos]) {\n            pos++;\n    \
    \    }\n        ret.push(x[i]);\n        x[i] = x[pos];\n    }\n    return ret;\n\
    }\n</code>\n<|/ a tags=sorting,algorithm,arrays dscore=1 |>\n<| c |>\nThanks for\
    \ posting your answer. I've added some additional information based on your answer.\
    \ Hopefully it helps future SO readers :)\n<|/ c |>\n<| c |>\n: you're welcome.\
    \ I hope you like my answer and think it's good to upvote it - thanks.\n<|/ c\
    \ |>\n<| a |>\nHere is my Java solution. Just the simple method which i found\
    \ at SO itself.\n<code>\nprivate static <T> List<T> uniqueDigits(T[] arr) {\n\
    \    List<T> ret = new ArrayList<>();\n    int position = 0;\n    int i;", "{\n\
    \    long[] y = new long[x.length];\n    long carry = 0;\n    for(int i = 0; i\
    \ < x.length; i++){\n        y[i] = x[i] % 10;\n        carry = x[i]/10;\n   \
    \ }\n    y[x.length-1] = carry % 10;\n    \n    return y;\n}", "{\n\tint N = x.length;\n\
    \tlong[] result = new long[N];\n\tint k = 0;\n\tint idx = 0;\n\tfor(int i = 0;\
    \ i < N; ++i) {\n\t\tint count = 0;\n\t\twhile(idx < N && x[idx] >= 10) {\n\t\t\
    \tcount += x[idx++ % N];\n\t\t}\n\t\tresult[i] = count;\n\t}\n\tArrays.sort(result);\n\
    \treturn result;\n}", "{\n    var ans = new long[x.Length];\n    for(int i = 0;\
    \ i < x.Length; i++) ans[i] = 0;\n    for(int i = 0; i < x.Length; i++) {\n  \
    \      for(int j = 0; j < x.Length; j++) {\n            if(i == j) continue;\n\
    \            if(j > i) {\n                if(x[i] < x[j]) {\n                \
    \    ans[i] += x[j] - x[i];\n                    ans[j] = x[j] - x[i];\n     \
    \           }\n            }\n        }\n    }\n    return ans;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThank you for contributing to Stack Overflow.  While your answer\
    \ may be correct, your explanation is not.  Please consider editing your answer\
    \ to improve it by explaining why the code in the question doesn't work, and what\
    \ you did to fix it.\n<|/ c |>\n<| c |>\nI didn't say your answer is wrong. I\
    \ merely commented on its importance for people who find this question to know\
    \ why it isn't working. Thanks for your suggestion.\n<|/ c |>\n<| c |>\nThis answer\
    \ contains much more information than the accepted answer.\n<|/ c |>\n<| a dscore=3\
    \ |>\nThe correct way is to use HashSet<T> (docs)\n<code>\nusing System;\nusing\
    \ System.Linq;", "{\n    if(x.length == 0) \n    {\n        return null;\n   \
    \ }\n    long[] result = new long[x.length];\n    long counter = 0;\n    for(int\
    \ i = 0; i < x.length; i++)\n    {\n        counter += x[i];\n        if(counter\
    \ == 0) \n        {\n            result[i] = counter;\n        }\n        else\
    \ if(counter % 2 == 0)\n        {\n            result[i] = counter;\n        }\n\
    \    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThis answer doesn't\
    \ explain *why* it works, just provides the solution. The OP will need to read\
    \ the documentation for [`std::find`](http://en.cppreference.com/w/cpp/algorithm/find)\
    \ more carefully to understand why this solution works.\n<|/ c |>\n<| c |>\nIt\
    \ helps me a lot. Thanks.\n<|/ c |>\n<| a tags=arrays,c++,algorithm,sorting |>\n\
    <code>\n#include<iostream>\nusing namespace std;", "{\n\tlong[] a = new long[x.Length];\n\
    \tfor(int i = 0; i < x.Length; i++)\n\t{\n\t\tif(x[i] % 2 == 0)\n\t\t\tcontinue;\n\
    \t\telse \n\t\t{\n\t\t\ta[i] = x[i];\n\t\t}\n\t}\n\tArray.Sort(a);\n\treturn a;\n\
    }\n*/\n/*\n// Reverse a sorted array", "{\n    int i = 0, len = x.length;\n  \
    \  long[] ret = new long[len];\n    while(i < len) \n    {\n        while(i <\
    \ len && x[i] == 0) i++;\n        if(i == len) break;\n        int j = i;\n  \
    \      while(j < len && x[j] == 0) j++;\n        if(j == len) \n        {\n  \
    \          ret[i] = 0;\n            i++;\n        } \n        else \n        {\n\
    \            if(j-i > 1) \n            {\n                ret[i] = x[j] - x[i\
    \ - 1];\n            } \n            else \n            {\n                ret[i]\
    \ = x[j];\n            }\n            i++;\n        }\n    }\n    return ret;\n\
    }", "{\n    long[] result = new long[x.Length];\n    \n    foreach(int v in x)\n\
    \    {\n        long temp = (long) v;\n        if (temp < 10)\n        {\n   \
    \         result[(int)temp-1]++;\n        }\n    }\n    \n    foreach(int v in\
    \ result)\n    {\n        if (v < 2)\n        {\n            result.Remove(v);\n\
    \        }\n    }\n    \n    foreach(int v in result)\n    {\n        if (v <\
    \ 2)\n        {\n            result.Remove(v);\n        }\n    }\n    \n    return\
    \ result;\n}\n</code>\n<|/ a tags=algorithm,c#,linq,sorting |>\n<| a dscore=0\
    \ tags=algorithm,c#,linq,sorting |>\n<code>\npublic class MyComparer : IComparer<int>\n\
    {\n    public int Compare(int x, int y)\n    {\n        return string.Compare(x,\
    \ y, true, CultureInfo.InvariantCulture);\n    }\n}\n</code>\nSort the array using\
    \ Array.Sort, passing your Comparer instance in as the last parameter.\n<|/ a\
    \ |>\n<| c |>\nThis will give wrong results when the array contains duplicates.\
    \ e.g. `[1,2,2,3]`\n<|/ c |>\n<| a dscore=0 |>\nHere's a LINQ solution that doesn't\
    \ require using strings:\n<code>", "{\n    \n    long[] ans = new long[x.length];\n\
    \    bool hasEven = false;\n    long index = 0;\n    for(int i = 0; i < x.length;\
    \ i++)\n    {\n        int digit = std.int::toString(x[i]).length() - 1;\n   \
    \     if(!hasEven)\n        {\n            hasEven = digit % 2 == 0;\n       \
    \ }\n        if(hasEven)\n        {\n            ans[index] = x[i];\n        \
    \    index++;\n        }\n    }\n    return ans;\n}\n</code>\n<|/ a tags=algorithm\
    \ dscore=0 |>\n<| c |>\nThis does not work. Try it with unique_digits([152L, 323L,\
    \ 1422L, 10L]). It returns [10L], but clearly the required output is to return\
    \ [].\n<|/ c |>\n<| a tags=algorithm |>\nHere is my Python code:\n<code>\ndef\
    \ unique_digits(arr):\n    digits = [0]\n    for d in arr:\n        d = int(d)\n\
    \        digits.append(d)\n    digits.sort()\n    digits = [0] + digits[digits:]\
    \ + [0]\n    digits = [0]*(len(arr) - len(digits)) + digits\n    for i in range(len(digits)\
    \ - 1):\n        if digits[i] != digits[i+1]:\n            return False\n    return\
    \ True\n</code>\nThis uses the fact that False and True can be concatenated.\n\
    <|/ a dscore=0 |>\n<| c |>\nThis does not work. Try it with unique_digits([152L,\
    \ 323L, 1422L, 10L]). It returns [10L], but clearly the required output is to\
    \ return [].\n<|/ c |>\n<| a tags=algorithm |>\n<code>\ndef unique(arr):\n   \
    \ digit_list=[]\n    for x in arr:\n        x=int(x)\n        if x in digit_list:\n\
    \            continue\n        else:\n            digit_list.append(x)\n    digit_list.sort()\n\
    \    unique_digit=digit_list[0]\n    for i in range(1,len(digit_list)):\n    \
    \    if digit_list[i]!=unique_digit:\n            return False\n        else:\n\
    \            unique_digit=digit_list[i]\n    return True", "{\n    int[] y = std.array;\n\
    \    int[] _y;\n    long[] _x = std.array;\n    std.sort(_x);\n    _y = x.slice();\n\
    \    long i = _y.slice().reverse().skipWhile(x => x > 0).last();\n    return std.array.toArray(_y).filter(x\
    \ => (x % 2 == 0 & x != i)).sort() \n    ;\n}", "{\n    long[] result = new long[x.length];\n\
    \    int count = 0;\n    \n    for(long i : x) {\n        while(count > 0 && i\
    \ >= 10) {\n            result[count] = i / 10;\n            i %= 10;\n      \
    \      count--;\n        }\n        result[count] = i;\n        count++;\n   \
    \ }\n    \n    Arrays.sort(result);\n    return result;\n}\n</code>\n<|/ a |>\n\
    <| a |>\nHere is my approach. I think it is fairly straightforward and easy to\
    \ understand. I thought about it as an exercise to learn some new language features,\
    \ especially the map and reduce functions.\n<code>\ndef uniqueDigits(numbers:\
    \ List[Int]): List[Int] = {\n    val map = numbers.map(x => x / 10)\n    val filtered\
    \ = map.filterNot(_ % 2 == 0)\n    val reduced = filtered.reduce((a: Int, b: Int)\
    \ => (a * 10 + b).toInt)\n    map.filter(_ % 2 == 0).zip(reduced.toList.distinct).map(_.swap).toList\n\
    }\n</code>\n<|/ a dscore=1 tags=scala |>\n<| c |>\nThis solution does not work\
    \ in case of a repeated digit: 10 is seen as one digit and therefore not unique.\n\
    <|/ c |>\n<| a tags=scala |>\nThis can easily be done without recursion using\
    \ foldLeft.\n<code>\ndef uniqueDigits(nums: List[Int]): List[Int] = {\n  nums.foldLeft(List[Int]()){\
    \ (acc: List[Int], elem) => \n    val digit = elem / 10\n    if (acc.contains(digit))\
    \ {\n      acc\n    } else {\n      acc ::: List(digit)\n    }\n  }\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\nIf anyone is still searching for a way to\
    \ solve this problem without using recursion or foldLeft, I found an alternative\
    \ that uses recursion. It has O(n) time complexity and O(n) space complexity.\n\
    <code>\ndef uniqueDigits(nums: List[Int]): List[Int] = {\n  val (min, max) = (math.min(nums),\
    \ math.max(nums))\n  val digit = min / 10\n  def helper(sum: Int, digit: Int,\
    \ digits: List[Int]): List[Int] = {\n    if (sum < digit) digits\n    else if\
    \ (sum == digit) List(digit)\n    else helper(sum + digit, digit + 10, digits\
    \ :+ digit)\n  }\n  helper(0, digit, List[Int]())\n}\n</code>\n<|/ a tags=scala\
    \ |>\n<| a tags=scala |>\nA simple recursive solution", "{\n    if(x.length==0)\
    \ \n    {\n        return new long[0];\n    }\n    \n    int n=x.length;\n   \
    \ long[] a=new long[n];\n    for(int i=0; i<n; i++) \n    {\n        long d=x[i]%10;\n\
    \        a[i]=d*10+d; // convert it to a long again\n    }\n    Arrays.sort(a);\n\
    \    long[] b=new long[n];\n    int j=0;\n    for(int i=0; i<n; i++)\n    {\n\
    \        if(a[i]%2==0)\n        {\n            b[j]=x[i];\n            j++;\n\
    \        }\n    }\n    return b;\n}\n</code>\n<|/ a tags=arrays,sorting,java dscore=0\
    \ |>\n<| c |>\nThank you so much for this. I just had to change long[] to Long[]\
    \ and it worked! Thank you! It has also helped me understand a few more things\
    \ about the sorting algorithm. Although I do understand that my question was quite\
    \ confusing. I couldn't think of a better way to phrase it but thank you for you\
    \ help!\n<|/ c |>\n<| a tags=arrays,sorting,java |>\n<code>\n/**\n * Given an\
    \ array of numbers, return an array of numbers that\n * only have one even-placed\
    \ digit. No other digits can\n * be duplicated.\n *\n * Input array: [ 1, 1, 2,\
    \ 3, 4, 4, 1, 1, 7, 8 ]\n * Output: [ 1, 1, 2 ]\n *\n */", "{\n\tlong[] result\
    \ = new long[x.length];\n\t\n\tint count = 0;\n\t\n\tfor (int i = 0; i < x.length;\
    \ i++)\n\t{\n\t\tif (std.math.toInt(x[i]) % 2 == 0)\n\t\t{\n\t\t\tresult[count]\
    \ = x[i];\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\treturn result;\n}", "{\n    long[]\
    \ y = new long[x.length];\n    int count=0;\n    for(int i=0; i<x.length; ++i)\n\
    \    {\n        while(count < y && x[i] > 0)\n        {\n            y[count++]\
    \ = x[i] % 10;\n            x[i] /= 10;\n        }\n    }\n    return y;\n}",
  "{\n    long[] r = new long[x.length];\n    long temp;\n    long i;\n    int j;\n\
    \    int k = x.length - 1;\n    \n    while(k >= 0) {\n        temp = x[k];\n\
    \        for(i = 0; i < k; i++) {\n            if(x[i] == temp) {\n          \
    \      j++;\n                while(j < k && x[j] == temp) {\n                \
    \    j++;\n                }\n                if((j == k || x[j] > temp)) {\n\
    \                    r[--k] = temp;\n                }\n                break;\n\
    \            }\n        }\n    }\n    return r;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;",
  "{\n    return unique_digits(x,x);\n}", "{\n    int i1 = 0, i2 = 0;\n    long[]\
    \ result = new long[x.length];\n    bool found = false;"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
