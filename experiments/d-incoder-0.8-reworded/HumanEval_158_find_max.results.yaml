language: d
name: HumanEval_158_find_max
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string res = \"\"; \n    map<int, string> m;\n    for(int i=0;\
    \ i<words.length; i++){\n        if(m.find(words[i]) == m.end()){\n          \
    \  m[words[i].length()] += words[i];\n        }\n    }\n    int max = 0, maxI\
    \ = -1;\n    for(map<int, string>::iterator it = m.begin(); it != m.end(); ++it){\n\
    \        if(maxI < it->first){\n            max = it->first;\n            maxI\
    \ = it->first;\n            res = it->second;\n        }\n        if(max < it->first){\n\
    \            max = it->first;\n            res = it->second;\n        }\n    }\n\
    \    return res;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\nstring max;\n\
    map<int, string> m;\nfor(int i=0; i<words.length; i++){\n    if(m.find(words[i])\
    \ == m.end()){\n        m[words[i].length()] += words[i];\n    }\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp59mcsf6z.d(20): Error: found `,` when expecting `.` following int

    /tmp/tmp59mcsf6z.d(20): Error: found `>` when expecting `;` following statement

    /tmp/tmp59mcsf6z.d(27): Error: found `,` when expecting `.` following int

    /tmp/tmp59mcsf6z.d(27): Error: found `>` when expecting `;` following statement

    /tmp/tmp59mcsf6z.d(27): Error: expression expected, not `:`

    /tmp/tmp59mcsf6z.d(27): Error: found `:` when expecting `;` following `for` condition

    /tmp/tmp59mcsf6z.d(27): Error: found `it` when expecting `)`

    /tmp/tmp59mcsf6z.d(27): Error: found `=` instead of statement

    /tmp/tmp59mcsf6z.d(27): Error: found `)` when expecting `;` following statement

    /tmp/tmp59mcsf6z.d(28): Error: use `.` for member lookup, not `->`

    /tmp/tmp59mcsf6z.d(29): Error: use `.` for member lookup, not `->`

    /tmp/tmp59mcsf6z.d(30): Error: use `.` for member lookup, not `->`

    /tmp/tmp59mcsf6z.d(31): Error: use `.` for member lookup, not `->`

    /tmp/tmp59mcsf6z.d(33): Error: use `.` for member lookup, not `->`

    /tmp/tmp59mcsf6z.d(34): Error: u'
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    /*\n    Declare and initialize variable 'max' to 0.\n    Declare\
    \ and initialize variable 'counter' to 0.\n    \n    Write a loop that iterates\
    \ through the words array.\n    On each iteration, increase 'counter' by 1.\n\
    \    If 'counter' equals 'max', set 'max' to 'counter'.\n    \n    If all words\
    \ have the same number of unique characters,\n    then 'max' will be the highest\
    \ unique number.\n    \n    After the loop is done, return the word with the highest\
    \ unique number.\n    */\n    int max = 0;\n    int counter = 0;\n    \n    foreach(string\
    \ word in words)\n    {\n        counter += 1;\n        if (counter == max)\n\
    \            max = counter;\n    }\n    \n    return words[max];\n}\n/*\nWrite\
    \ a function that accepts an array of strings.\n    The array contains different\
    \ words. Return only those words that contain\n    every unique letter.\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpljes70_7.d(35): Error: found `in` when expecting `;`

    /tmp/tmpljes70_7.d(44): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpljes70_7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint max = 0, index = -1;\n\tfor(int i = 0; i < words.length; i++)\n\
    \t{\n\t\tindex = 0;\n\t\tfor(int j = 1; j < words[i].length(); j++)\n\t\t{\n\t\
    \t\tif(words[i].charAt(j) == words[i].charAt(index)) index++;\n\t\t\telse \n\t\
    \t\t{\n\t\t\t\tif(max < index) max = index;\n\t\t\t\tindex = j;\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn words[max];\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplza9i4kg.d(23): Error: no property `length` for type `string`

    /tmp/tmplza9i4kg.d(25): Error: no property `charAt` for type `string`

    /tmp/tmplza9i4kg.d(25): Error: no property `charAt` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplza9i4kg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result = \"\";\n    size_t max = 0;\n    size_t cur =\
    \ 0;\n    foreach(string word in words) \n    {\n        size_t curLen = word.length();\n\
    \        if(curLen > max) \n        {\n            max = curLen;\n           \
    \ result = word;\n        }\n        cur = cur + curLen;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=string,algorithm,string,c# |>\n<| a dscore=0 |>\nHere is\
    \ a simple solution that doesn't use dictionaries.\n<code>\n    using System;\n\
    \    using System.Collections.Generic;\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp16yjk3zo.d(22): Error: found `in` when expecting `;`

    /tmp/tmp16yjk3zo.d(34): Error: declaration expected, not `<`

    /tmp/tmp16yjk3zo.d(37): Error: unterminated character constant

    /tmp/tmp16yjk3zo.d(40): Error: semicolon expected, not `.`

    /tmp/tmp16yjk3zo.d(40): Error: no identifier for declarator `.Collections.Generic`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp16yjk3zo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string res = \"\";\n    for (int i=0; i<words.length;\
    \ ++i)\n    {\n        if (words[i].length() > max)\n        {\n            max\
    \ = words[i].length();\n            res = words[i];\n        }\n    }\n    return\
    \ res;\n}\n</code>\n<|/ a tags=sorting,algorithm,data-structures,arrays,string\
    \ |>\n<| a |>\nI thought of a solution that uses dynamic programming and a hash\
    \ map to keep track of the number of unique letters. This is O(n * m) time and\
    \ O(n) space.\n<code>\npublic class Solution {\n    public String findLongestWord(String[]\
    \ words) {\n        if (words == null || words.length == 0) return \"\";\n   \
    \     int n = words.length;\n        Map<Character, Integer> map = new HashMap<Character,\
    \ Integer>();\n        for (int i = 0; i < n; i++) {\n            String word\
    \ = words[i];\n            for (int j = 0; j < word.length(); j++) {\n       \
    \         char c = word.charAt(j);\n                if (map.containsKey(c)) {\n\
    \                    Integer count = map.get(c);\n                    map.put(c,\
    \ count + 1);\n                } else {\n                    map.put(c, 1);\n\
    \                }\n            }\n        }\n        for (int i = 0; i < n; i++)\
    \ {\n            String word = words[i];\n            int max = Integer.MIN_VALUE;\n\
    \            Character c = null;\n            for (int j = 0; j < word.length();\
    \ j++) {\n                c = Character.toUpperCase(word.charAt(j));\n       \
    \         if (map.containsKey(c)) {\n                    Integer count = map.get(c);\n\
    \                    if (max < count) max = count;\n                }\n      \
    \      }\n            if (max == Integer.MIN_VALUE) continue;\n            String\
    \ res = \"\";\n            for (int j = 0; j < word.length(); j++) {\n       \
    \         char ch = Character.toUpperCase(word.charAt(j));\n                if\
    \ (map.containsKey(ch)) {\n                    if (map.get(ch) == max) {\n   \
    \                     res += ch;\n                    }\n                }\n \
    \           }\n            return res;\n        }\n        return \"\";\n    }\n\
    }\n</code>\n<|/ a dscore=1 tags=sorting,algorithm,data-structures,arrays,string\
    \ |>\n<| c |>\nI think this solution is incorrect if the first string in the given\
    \ array is repeated twice. For example, `findLongestWord([\"a\", \"b\", \"a\"\
    , \"b\", \"c\"])` returns `\"abbc\"` rather than `\"abc\"`. Similarly, `findLongestWord([\"\
    a\", \"b\", \"c\", \"a\", \"b\", \"c\"])` returns `\"abc\"` rather than `\"acb\"\
    `.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;\nimport java.io.*;\n\
    class Main {\n    public static void main(String[] args) {\n        String[] words\
    \ = {\"name\",\"of\",\"string\"};\n        List<String> \nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp74w8rzq8.d(31): Error: declaration expected, not `<`

    /tmp/tmp74w8rzq8.d(40): Error: no identifier for declarator `Map`

    /tmp/tmp74w8rzq8.d(40): Error: declaration expected, not `<`

    /tmp/tmp74w8rzq8.d(41): Error: declaration expected, not `for`

    /tmp/tmp74w8rzq8.d(41): Error: no identifier for declarator `i`

    /tmp/tmp74w8rzq8.d(41): Error: declaration expected, not `<`

    /tmp/tmp74w8rzq8.d(41): Error: no identifier for declarator `i`

    /tmp/tmp74w8rzq8.d(41): Error: declaration expected, not `++`

    /tmp/tmp74w8rzq8.d(43): Error: declaration expected, not `for`

    /tmp/tmp74w8rzq8.d(43): Error: no identifier for declarator `j`

    /tmp/tmp74w8rzq8.d(43): Error: declaration expected, not `<`

    /tmp/tmp74w8rzq8.d(43): Error: no identifier for declarator `j`

    /tmp/tmp74w8rzq8.d(43): Error: declaration expected, not `++`

    /tmp/tmp74w8rzq8.d(45): Error: declaration expected, not `if`

    /tmp/tmp74w8rzq8.d(47): Error: unexpected `(` in declarator

    /tmp/tmp74w8rzq8.d(47): Error: found `+` when expecting `)`

    /tmp/tmp74w8rzq8.d(47): Er'
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  int maxUniqueChars;\n  string bestWord;\n  int bestIndex = 0;\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv70wvmvi.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv70wvmvi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int highest = 0;\n    int index = 0;\n    for(int i = 0; i <\
    \ words.length; i++)\n    {\n        if(words[i].length() > highest)\n       \
    \     highest = words[i].length();\n        index = i;\n    }\n    int chars =\
    \ 0;\n    for(int i = index+1; i < words.length; i++)\n    {\n        chars +=\
    \ words[i].length();\n        if(chars > highest)\n            highest = chars;\n\
    \    }\n    return words[index];\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgvndm0fi.d(23): Error: no property `length` for type `string`

    /tmp/tmpgvndm0fi.d(24): Error: no property `length` for type `string`

    /tmp/tmpgvndm0fi.d(30): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgvndm0fi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int n = words.length;\n    string strMax = null;\n    \n   \
    \ for (int i = 0; i < n; i++)\n    {\n        // find the maximum number of unique\
    \ chars in str\n        string str = words[i];\n        int count = 0;\n     \
    \   for (int j = 0; j < n; j++)\n        {\n            if (j == i) continue;\n\
    \            if (str[j] == str[j])\n                count++;\n        }\n    \
    \    if (count > strMax.length())\n        {\n            strMax = str;\n    \
    \    }\n    }\n    \n    return strMax;\n}\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7afzn26e.d(19): Error: cannot implicitly convert expression `words.length`
    of type `ulong` to `int`

    /tmp/tmp7afzn26e.d(33): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7afzn26e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  int charCounts[255];\n  for(uint i = 0; i < words.length; ++i)\n\
    \    for(uint j = 0; j < words[i].length; ++j)\n      ++charCounts[words[i][j]];\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt32pjjkj.d(19): Deprecation: instead of C-style syntax, use D-style
    syntax `int[255] charCounts`

    /tmp/tmpt32pjjkj.d(23): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt32pjjkj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    int i;\n    string tmp;\n    for(i = 0; i<words.length;\
    \ i++)\n    {\n        tmp = words[i];\n        int j = i;\n        int num =\
    \ 0;\n        while(j!=words.length && num < max)\n        {\n            int\
    \ compare = std.string.compare(words[j],tmp);\n            if(compare > 0)\n \
    \           {\n                max = num;\n            }\n            if(compare\
    \ == 0)\n            {\n                num = num + 1;\n            }\n      \
    \      else\n            {\n                num = num;\n            }\n      \
    \      j = j-1;\n        }\n    }\n    return words[max];\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis is an excellent answer because it gives us the option to test our\
    \ solutions. I really like the use of \"std.typecons\" and the \"std.math\" library,\
    \ and I've tried to implement this into my code, but I'm having trouble. I can't\
    \ seem to figure out how to get the function to use the std.math library. I don't\
    \ know what to do with the \"std.math\" library functions. I keep getting the\
    \ error \"undefined reference to `pow'\". Do you know how I can resolve this issue?\
    \ Or what I'm doing wrong here?\n<|/ c |>\n<| c |>\nI haven't used this library.\
    \ You can import it by copying the whole folder into the same folder with your\
    \ file. And then replace all the \"std.\" with \"std\". Also add \"using namespace\
    \ std\" to the beginning of your code file.\n<|/ c |>\n<| c |>\nI implemented\
    \ everything as you said, and when I run my code I get the error \"undefined reference\
    \ to pow\" and then the program ends. I looked at the \"std\" library in visual\
    \ studio and there are functions in it that I thought would be useful but I'm\
    \ obviously missing something.\n<|/ c |>\n<| c |>\nI made a mistake. std.math.pow\
    \ only works for C++ projects. To make it work for other languages, you can use\
    \ std.pow, which is a C library. Try changing all the \"std.math.pow\" to \"std.pow\"\
    .\n<|/ c |>\n<| c |>\nThanks for your help, you've been really helpful. I got\
    \ it working now. I'll post my updated code below.\n<|/ c |>\n<| a dscore=2 tags=string,max,algorithm,c++,function\
    \ |>\nI wrote this in Java. The result is the same for the most part. \n<code>\n\
    public static void main(String[] args)\n    {\n        String[] words = {\"string\"\
    , \"string\", \"string\", \"string\", \"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"string\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1tezywmy.d(47): Error: declaration expected, not `<`

    /tmp/tmp1tezywmy.d(50): Error: unterminated character constant

    /tmp/tmp1tezywmy.d(50): Error: unterminated character constant

    /tmp/tmp1tezywmy.d(50): Error: unterminated character constant

    /tmp/tmp1tezywmy.d(50): Error: unterminated character constant

    /tmp/tmp1tezywmy.d(50): Error: unterminated character constant

    /tmp/tmp1tezywmy.d(53): Error: unterminated character constant

    /tmp/tmp1tezywmy.d(56): Error: unterminated character constant

    /tmp/tmp1tezywmy.d(62): Error: unterminated character constant

    /tmp/tmp1tezywmy.d(62): Error: unterminated character constant

    /tmp/tmp1tezywmy.d(83): Error: unterminated string constant starting at /tmp/tmp1tezywmy.d(83)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1tezywmy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    if (words.length == 0)\n        return \"\";\n    if (words[0].length()\
    \ == 0)\n        return find_max(words);\n    \n    map<char, int> counter;\n\
    \    foreach (i, e) e in words) {\n        counter[e] = 1;\n    }\n    int maxIndex\
    \ = 0;\n    int maxCount = 0;\n    int maxLen = 0;\n    foreach (i, e) e in words)\
    \ {\n        int count = counter[e];\n        if (count > maxCount) {\n      \
    \      maxCount = count;\n            maxIndex = i;\n            maxLen = e.length();\n\
    \        }\n        counter[e] += 1;\n    }\n    if (maxCount == maxLen)\n   \
    \     return words[maxIndex];\n    \n    string result = \"\";\n    foreach (i,\
    \ e) e = words[maxIndex];\n    result += e;\n    return find_max(result.dropLast());\n\
    }\n</code>\n<|/ a |>\n<| a tags=string,arrays,algorithm,c++ |>\nYou can use this\
    \ algorithm\n<code>\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwrp5nr8r.d(24): Error: found `,` when expecting `.` following char

    /tmp/tmpwrp5nr8r.d(24): Error: found `int` when expecting identifier following
    `char`.

    /tmp/tmpwrp5nr8r.d(24): Error: found `>` when expecting `;` following statement

    /tmp/tmpwrp5nr8r.d(25): Error: no identifier for declarator `e`

    /tmp/tmpwrp5nr8r.d(25): Error: found `)` when expecting `;`

    /tmp/tmpwrp5nr8r.d(31): Error: no identifier for declarator `e`

    /tmp/tmpwrp5nr8r.d(31): Error: found `)` when expecting `;`

    /tmp/tmpwrp5nr8r.d(44): Error: no identifier for declarator `e`

    /tmp/tmpwrp5nr8r.d(44): Error: found `)` when expecting `;`

    /tmp/tmpwrp5nr8r.d(44): Error: found `;` when expecting `)`

    /tmp/tmpwrp5nr8r.d(48): Error: declaration expected, not `<`

    /tmp/tmpwrp5nr8r.d(57): Error: declaration expected, not `assert`

    /tmp/tmpwrp5nr8r.d(58): Error: declaration expected, not `assert`

    /tmp/tmpwrp5nr8r.d(59): Error: declaration expected, not `assert`

    /tmp/tmpwrp5nr8r.d(60): Error: declaration expected, not `assert`

    /tmp/tmpwrp5nr8r.d(61): E'
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int maxCharCount = 0;\n    for(int i = 0; i < words.length;\
    \ i++){\n        string word = words[i];\n        string charCount = \"\";\n \
    \       for(int j = 0; j < word.length(); j++){\n            charCount = charCount\
    \ + word[j];\n            \n        }\n        int currentCharCount = std.string.length(charCount);\n\
    \        if(currentCharCount > maxCharCount){\n            string result = \"\"\
    ;\n            for(int j = 0; j < word.length(); j++){\n                result\
    \ += word[j];\n            }\n            words[i] = result;\n            maxCharCount\
    \ = currentCharCount;\n        }\n    }\n    return words[std.randomInt(words.length)];\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv7wj8hjm.d(23): Error: no property `length` for type `string`

    /tmp/tmpv7wj8hjm.d(24): Error: incompatible types for `(charCount) + (word[cast(ulong)j])`:
    `string` and `immutable(char)`

    /tmp/tmpv7wj8hjm.d(27): Error: undefined identifier `string` in package `std`

    /tmp/tmpv7wj8hjm.d(30): Error: no property `length` for type `string`

    /tmp/tmpv7wj8hjm.d(31): Error: slice `result` is not mutable

    /tmp/tmpv7wj8hjm.d(37): Error: undefined identifier `randomInt` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv7wj8hjm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map <int,int> m;\n    for (int i = 0; i < words.length; ++i)\
    \ {\n        if (m.find(words[i].length()) == m.end()) {\n            m[words[i].length()]\
    \ = 0;\n        }\n        m[words[i].length()] += 1;\n    }\n    int max = 0;\n\
    \    int max_pos = -1;\n    \n    for (int i = 0; i < words.length; ++i) {\n \
    \       if (m[words[i].length()] > max) {\n            max = m[words[i].length()];\n\
    \            max_pos = i;\n        }\n    }\n    return words[max_pos];\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis isn't what the OP is looking for. You're looking\
    \ for the one with the most letters. He wants the one with the most letters alphabetically\
    \ sorted.\n<|/ c |>\n<| c |>\n, I have added a function to sort it\n<|/ c |>\n\
    <| c |>\nThe edit doesn't actually sort alphabetically. Just the string in lexicographical\
    \ order. Which is probably not what he wants.\n<|/ c |>\n<| c |>\nOh I see, thanks,\
    \ I have added a sort.\n<|/ c |>\n<| c |>\n, I am not familiar with map, but is\
    \ it possible to sort the map by the number of unique characters?\n<|/ c |>\n\
    <| a dscore=1 tags=string,algorithm,c++ |>\nThe easiest approach would be to convert\
    \ each string to a hash table:\n<code>\nstring str = \"helloworld\";\nunordered_map<char,\
    \ int> count_map;\nfor (char c : str) {\n    ++count_map[c];\n}\n</code>\nNow\
    \ you can easily find the maximum count and the word itself.\n<|/ a |>\n<| c |>\n\
    You can't convert a string to map by counting characters.\n<|/ c |>\n<| a |>\n\
    I came up with the following algorithm, where I create a map with the size of\
    \ the most common characters and then I go through all chars in the string and\
    \ update the map accordingly.\n<code>\n#include <iostream>\n#include <string>\n\
    #include <map>\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwhpx9of3.d(19): Error: found `,` when expecting `.` following int

    /tmp/tmpwhpx9of3.d(19): Error: found `int` when expecting identifier following
    `int`.

    /tmp/tmpwhpx9of3.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmpwhpx9of3.d(37): Error: declaration expected, not `<`

    /tmp/tmpwhpx9of3.d(40): Error: unterminated character constant

    /tmp/tmpwhpx9of3.d(40): Error: unterminated character constant

    /tmp/tmpwhpx9of3.d(46): Error: unterminated character constant

    /tmp/tmpwhpx9of3.d(58): Error: no identifier for declarator `unordered_map`

    /tmp/tmpwhpx9of3.d(58): Error: declaration expected, not `<`

    /tmp/tmpwhpx9of3.d(59): Error: declaration expected, not `for`

    /tmp/tmpwhpx9of3.d(61): Error: unrecognized declaration

    /tmp/tmpwhpx9of3.d(66): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwhpx9of3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int uniqueChars = count(words);\n    string result = null;\n\
    \    int max = uniqueChars;\n    for(int i = 0; i < words.length; i++)\n    {\n\
    \        string temp = words[i];\n        int newUniqueChars = count(temp);\n\
    \        if(newUniqueChars > max)\n        {\n            result = temp;\n   \
    \         max = newUniqueChars;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=arrays,c#,sorting dscore=2 |>\n<| c |>\nIt doesn't work if all strings\
    \ have the same number of unique chars.\n<|/ c |>\n<| c |>\nYes, but it is a little\
    \ unclear what the OP means by \"maximum unique characters\". I interpreted it\
    \ as \"the word that has the maximum number of unique characters\". So in this\
    \ case, the word with most characters is the right one (since the word `\"aaa\"\
    ` has three unique characters, so the word `\"aaa\"` is the correct one as far\
    \ as OP concerns).\n<|/ c |>\n<| c |>\nOkay, I just realized that OP also wants\
    \ to sort strings lexicographically if there are two or more strings with maximum\
    \ number of unique characters. But it isn't clear.\n<|/ c |>\n<| c |>\nNo, I don't\
    \ want maximum unique characters, I want maximum unique strings. In your example,\
    \ string `\"aaaa\"` has 4 unique characters and `string \"aaaaa\"` has 2 unique\
    \ characters. I don't want to sort by number of unique characters.\n<|/ c |>\n\
    <| a dscore=2 tags=arrays,c#,sorting |>\n<code>\npublic static string FindMaxString(string[]\
    \ array)\n{\n    List<string> max = new List<string>();\n    List<string> maxStrings\
    \ = new List<string>();\n    foreach (string item in array)\n    {\n        foreach\
    \ (string item in array)\n        {\n            if (item == item) continue;\n\
    \            int uniqueChars = item.Distinct().Count();\n            if (uniqueChars\
    \ == item.Length)\n            {\n                max.Add(item);\n           \
    \ }\n        }\n    }\n    string longest = max[0].ToUpper();\n    foreach (string\
    \ item in max)\n    {\n        if (longest.Length < item.Length)\n        {\n\
    \            longest = item;\n        }\n    }\n    maxStrings.Add(longest);\n\
    \    return longest;\n}\n</code>\n<|/ a |>\n<| c |>\nYeah, I know that this can\
    \ be done with nested for loops. I wanted to know if there is any better way of\
    \ doing this. Thanks for your reply.\n<|/ c |>\n<| c |>\nI guess the main problem\
    \ here is performance. `foreach\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnei8wfe3.d(34): Error: declaration expected, not `<`

    /tmp/tmpnei8wfe3.d(37): Error: unterminated character constant

    /tmp/tmpnei8wfe3.d(43): Error: unterminated character constant

    /tmp/tmpnei8wfe3.d(46): Error: unterminated character constant

    /tmp/tmpnei8wfe3.d(46): Error: unterminated character constant

    /tmp/tmpnei8wfe3.d(53): Error: no identifier for declarator `List`

    /tmp/tmpnei8wfe3.d(53): Error: declaration expected, not `<`

    /tmp/tmpnei8wfe3.d(54): Error: declaration expected, not `foreach`

    /tmp/tmpnei8wfe3.d(60): Error: declaration expected, not `if`

    /tmp/tmpnei8wfe3.d(63): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnei8wfe3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    var maxCount = 0;\n    var maxCountWord = \"\";\n    for (int\
    \ i = 0; i < words.length; ++i)\n    {\n        var count = uniqueCount(words[i]);\n\
    \        if (count > maxCount)\n        {\n            maxCount = count;\n   \
    \         maxCountWord = words[i];\n        }\n    }\n    return maxCountWord;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgl3orecu.d(19): Error: undefined identifier `var`

    /tmp/tmpgl3orecu.d(20): Error: undefined identifier `var`

    /tmp/tmpgl3orecu.d(23): Error: undefined identifier `var`

    /tmp/tmpgl3orecu.d(23): Error: undefined identifier `uniqueCount`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgl3orecu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    if(words.Length < 2) return words[0];\n    \n    map<int, string>\
    \ counts = new map<int, string>();\n    map<string, int> alphabet = new map<string,\
    \ int>();\n    map<string, string> sorted_alphabet = new map<string, string>();\n\
    \    for(int i = 0; i < words.Length; i++) {\n        string word = words[i];\n\
    \        counts[word] = counts[word] + 1;\n        alphabet[word] = alphabet[word]\
    \ + 1;\n        sorted_alphabet.insert(pair<string, string>(word,word));\n   \
    \ }\n    int max_count = counts.begin()->second;\n    string max_word = counts.begin()->first;\n\
    \    \n    map<string, int> other_counts;\n    for(int i = 0; i < words.Length;\
    \ i++) {\n        string word = words[i];\n        other_counts[word] = counts[word]\
    \ - 1;\n    }\n    \n    map<int, string> other_alphabet;\n    for(int i = 0;\
    \ i < words.Length; i++) {\n        string word = words[i];\n        other_alphabet[other_counts[word]]\
    \ += 1;\n    }\n    \n    pair<map<int, string>, map<string, int> > results;\n\
    \    if(alphabet.size() > other_alphabet.size()) {\n        results = sorted_alphabet.equal_range(max_word);\n\
    \    } else {\n        results = sorted_alphabet.equal_range(other_alphabet.begin()->first);\n\
    \    }\n    \n    string best_word = results[0].second;\n    int best_alphabet\
    \ = alphabet.at(best_word);\n    \n    for(int i = 1; i < words.Length; i++) {\n\
    \        string word = results[i].first;\n        int new_alphabet = alphabet.at(word);\n\
    \        if(new_alphabet > best_alphabet) {\n            best_alphabet = new_alphabet;\n\
    \            best_word = word;\n        }\n    }\n    \n    return best_word;\n\
    }\n</code>\n<|/ a dscore=0 tags=algorithm,c++,string |>\n<| a |>\nAs far as I\
    \ understood, the number of unique characters in the string is the string length.\
    \ \nSo, you can sort that array by string length, then for each element, check\
    \ the rest of the strings. \n<code>\nsort(words,words + words.length);\n</code>\n\
    then for each element in the array:\n<code>\nfor (int i = 0; i < words.length;\
    \ i++)\n    {\n        for (int j = i+1; j < words.length; j++)\n        {\n \
    \           if(words[i] == words[j] && j-i+1 < words.length)\n            {\n\
    \                swap(words[i],words[j]);\n            }\n        }\n    }\n</code>\n\
    This can be easily improved if you can make use of std::map to store the count\
    \ of each string in a map.\n<|/ a dscore=0 tags=algorithm,\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwsxd_apb.d(21): Error: found `,` when expecting `.` following int

    /tmp/tmpwsxd_apb.d(21): Error: found `>` when expecting `;` following statement

    /tmp/tmpwsxd_apb.d(21): Error: found `,` when expecting `.` following int

    /tmp/tmpwsxd_apb.d(21): Error: found `>` when expecting `;` following statement

    /tmp/tmpwsxd_apb.d(21): Error: expression expected, not `)`

    /tmp/tmpwsxd_apb.d(21): Error: found `;` when expecting `)`

    /tmp/tmpwsxd_apb.d(22): Error: found `map` when expecting `;` following statement

    /tmp/tmpwsxd_apb.d(22): Error: found `<` instead of statement

    /tmp/tmpwsxd_apb.d(23): Error: expression expected, not `)`

    /tmp/tmpwsxd_apb.d(23): Error: found `;` when expecting `)`

    /tmp/tmpwsxd_apb.d(24): Error: found `for` when expecting `;` following statement

    /tmp/tmpwsxd_apb.d(24): Error: found `i` when expecting `.` following int

    /tmp/tmpwsxd_apb.d(24): Error: found `=` when expecting identifier following `int`.

    /tmp/tmpwsxd_apb.d(24): Error: found `0` when expecting `)`

    /tmp/tmpwsxd_apb.d(24): Error: f'
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int maxCount = 0;\n    string max = null;\n    \n    for(int\
    \ i = 0; i < words.length; i++){\n        int uniqueCount = 0;\n        string\
    \ word = words[i];\n        \n        for(int j = 0; j < word.length(); j++){\n\
    \            if(word[j] == word[j]){\n                uniqueCount++;\n       \
    \     }\n        }\n        if(uniqueCount > maxCount){\n            maxCount\
    \ = uniqueCount;\n            max = word;\n        }\n    }\n    return max;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdp07ywtm.d(26): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdp07ywtm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    unordered_set<string> unique_chars(words.size());\n    for (unsigned\
    \ i = 0; i < words.size(); ++i) {\n        unique_chars[words[i]] += 1;\n    }\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfbfmzcf1.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmpfbfmzcf1.d(23): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfbfmzcf1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tstring max = \"\";\n\tint count = 0;\n\tint maxCount = 0;\n\t\
    for (size_t i = 0; i != words.length(); ++i)\n\t{\n\t\tstring word = words[i];\n\
    \t\tint count1 = count(word, max);\n\t\tif (count1 != count)\n\t\t{\n\t\t\tmax\
    \ = word;\n\t\t\tcount = count1;\n\t\t}\n\t\tif (count > maxCount)\n\t\t{\n\t\t\
    \tmaxCount = count;\n\t\t\tmax = word;\n\t\t}\n\t}\n\treturn max;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp40ke37un.d(22): Error: no property `length` for type `string[]`

    /tmp/tmp40ke37un.d(25): Error: function expected before `()`, not `count` of type
    `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp40ke37un.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> wordCount;\n    foreach (string w in words)\n\
    \    {\n        if (wordCount.containsKey(w))\n        {\n            wordCount[w]\
    \ = wordCount[w] + 1;\n        }\n        else\n        {\n            wordCount.put(w,\
    \ 1);\n        }\n    }\n    string maxWord = \"\";\n    int maxCount = wordCount.size();\n\
    \    foreach (string w in wordCount.keySet())\n    {\n        if (wordCount[w]\
    \ == maxCount)\n        {\n            maxWord = w;\n            break;\n    \
    \    }\n    }\n    return maxWord;\n}\n</code>\n<|/ a |>\n<| c |>\nI love it.\
    \ It's a shame that the language is so verbose and convoluted that people don't\
    \ realise that the foreach loop can act as a for loop in other languages.\n<|/\
    \ c |>\n<| c |>\nI think the point of the exercise is to learn about functional\
    \ programming techniques, rather than just using some more terse method of accomplishing\
    \ the same thing.\n<|/ c |>\n<| c |>\nYes, it's an exercise in functional programming.\
    \ And it is probably a reasonable one to learn about functional programming techniques.\
    \ I still think it's a useful exercise.\n<|/ c |>\n<| c |>\nI agree with you and\
    \ I agree that this is not an advanced example but a basic one which shows the\
    \ power of functional programming.\n<|/ c |>\n<| c |>\nThe foreach loop in F#,\
    \ like the for loop in C, has some great benefits. It is much easier to read than\
    \ the for loop and it is easy to add other things to the loop later. If you really\
    \ want to learn F# I would suggest looking at the examples on the F# website.\n\
    <|/ c |>\n<| a tags=algorithm,c#,functional-programming |>\n<code>\nstring[] words\
    \ = new string[] { \"string\", \"name\", \"of\", \"string\" };\nstring wordWithMaxNumberOfCharacter\
    \ = words[0]; \nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8cfpd7gl.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmp8cfpd7gl.d(20): Error: found `in` when expecting `;`

    /tmp/tmp8cfpd7gl.d(33): Error: found `in` when expecting `;`

    /tmp/tmp8cfpd7gl.d(43): Error: declaration expected, not `<`

    /tmp/tmp8cfpd7gl.d(46): Error: unterminated character constant

    /tmp/tmp8cfpd7gl.d(46): Error: unterminated character constant

    /tmp/tmp8cfpd7gl.d(52): Error: unterminated character constant

    /tmp/tmp8cfpd7gl.d(52): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8cfpd7gl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int count = 0;\n    int max = 0;\n    int i;\n    foreach(i,\
    \ words) {\n        count[words[i]]++;\n        if (count[words[i]] == max) {\n\
    \            max = count[words[i]];\n        }\n    }\n    foreach(i, count) {\n\
    \        if (count[i] > max)\n            return words[i];\n    }\n    return\
    \ words[words.length - 1];\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,language-agnostic,string\
    \ dscore=1 |>\nHere is C# solution with lambda expressions and LINQ:\n<code>\n\
    \ public class WordCounting\n    {\n        public static string WordWithMaxUniqueChars(string[]\
    \ words)\n        {\n            var counts = words.Select(word => new {word,\
    \ count = words.Count(c => c == word)})\n                             .GroupBy(x\
    \ => x.word)\n                             .OrderByDescending(g => g.Count())\n\
    \                             .First();\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyrce18o4.d(22): Error: no identifier for declarator `words`

    /tmp/tmpyrce18o4.d(22): Error: found `)` when expecting `;`

    /tmp/tmpyrce18o4.d(28): Error: found `foreach` when expecting `)`

    /tmp/tmpyrce18o4.d(32): Error: found `return` when expecting `;` following statement

    /tmp/tmpyrce18o4.d(34): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyrce18o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> m = Map();\n    for(int i = 0; i< words.length;\
    \ i++){\n        auto it = m.find(words[i]);\n        if (it != m.end()){\n  \
    \          it->second++;\n        }\n        else{\n            m[words[i]] =\
    \ 1;\n        }\n    }\n    \n    for (auto it = m.begin(); it != m.end(); ++it){\n\
    \        if(it->second > 1){\n            return it->first;\n        }\n    }\n\
    \    return words[0];\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n#include\
    \ <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi6rrg0c7.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmpi6rrg0c7.d(23): Error: use `.` for member lookup, not `->`

    /tmp/tmpi6rrg0c7.d(31): Error: use `.` for member lookup, not `->`

    /tmp/tmpi6rrg0c7.d(32): Error: use `.` for member lookup, not `->`

    /tmp/tmpi6rrg0c7.d(37): Error: declaration expected, not `<`

    /tmp/tmpi6rrg0c7.d(49): Error: declaration expected, not `assert`

    /tmp/tmpi6rrg0c7.d(50): Error: declaration expected, not `assert`

    /tmp/tmpi6rrg0c7.d(51): Error: declaration expected, not `assert`

    /tmp/tmpi6rrg0c7.d(52): Error: declaration expected, not `assert`

    /tmp/tmpi6rrg0c7.d(53): Error: declaration expected, not `assert`

    /tmp/tmpi6rrg0c7.d(54): Error: declaration expected, not `assert`

    /tmp/tmpi6rrg0c7.d(55): Error: declaration expected, not `assert`

    /tmp/tmpi6rrg0c7.d(56): Error: declaration expected, not `assert`

    /tmp/tmpi6rrg0c7.d(57): Error: declaration expected, not `assert`

    /tmp/tmpi6rrg0c7.d(58): Error: declaration expected, not `assert`

    /tmp/tmpi6rrg0c7.d(59): Erro'
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int n = words.length;\n    int count[26] = {0};\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpora93b6_.d(20): Deprecation: instead of C-style syntax, use D-style
    syntax `int[26] count`

    /tmp/tmpora93b6_.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpora93b6_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = -1;\n    int n = 0;\n    foreach (string word : words)\
    \ {\n        n = uniqueCharCount(word);\n        if (n >= max) {\n           \
    \ max = n;\n        } else if (n < max) {\n            return word;\n        }\n\
    \    }\n    return words[0];\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgft1g6iw.d(21): Error: found `:` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgft1g6iw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string word = null; //first word\n    int max = 0; //maximum\
    \ characters\n    int min = 0; //minimum characters\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy7l092ws.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy7l092ws.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  int max = 0;\n  int maxIndex = 0;\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy5714e1z.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy5714e1z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int maxIndex = 0;\n    string word = \"\";\nunittest\n{\n  \
    \  alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdotxv44q.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdotxv44q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max_count=0;\n    int i=0;\n    int j=words[i].length();\n\
    \    while (j>0)\n    {\n        if (words[i].substr(0, j).length()>=max_count)\n\
    \        {\n            max_count=words[i].substr(0, j).length();\n        }\n\
    \        j--;\n        i++;\n    }\n    return words[i];\n}\n</code>\n<|/ a |>\n\
    <| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n/*\nWrite a function that accepts\
    \ an array of strings.\nThe array contains different words. Return the word with\
    \ maximum number\nof unique characters. If multiple strings have maximum number\
    \ of unique\ncharacters, return the one which comes first in lexicographical order.\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo4t68_m_.d(33): Error: declaration expected, not `<`

    /tmp/tmpo4t68_m_.d(40): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo4t68_m_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int[] count = new int[256];\n    for(int i = 0; i < words.length;\
    \ i++)\n    {\n        for(int j = 0; j < words[i].length; j++)\n        {\n \
    \           count[(int)words[i][j]] += 1;\n        }\n    }\nunittest\n{\n   \
    \ alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2favqsb_.d(24): Error: C style cast illegal, use `cast(int)words[i][j]`

    /tmp/tmp2favqsb_.d(27): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2favqsb_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    \n    int max = -999;\n    int j = 0;\n    for(int i = 0; i\
    \ < words.length; i++)\n    {\n        int n = count(words[i].begin(), words[i].end());\n\
    \        if(n > max)\n        {\n            max = n;\n            j = 0;\n  \
    \      }\n    }\n    \n    return words[j];\n}\n</code>\n<|/ a tags=c++,algorithm,arrays,string\
    \ |>\n<| a tags=c++,algorithm,arrays,string |>\n<code>\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1eenlej4.d(34): Error: declaration expected, not `<`

    /tmp/tmp1eenlej4.d(42): Error: declaration expected, not `assert`

    /tmp/tmp1eenlej4.d(43): Error: declaration expected, not `assert`

    /tmp/tmp1eenlej4.d(44): Error: declaration expected, not `assert`

    /tmp/tmp1eenlej4.d(45): Error: declaration expected, not `assert`

    /tmp/tmp1eenlej4.d(46): Error: declaration expected, not `assert`

    /tmp/tmp1eenlej4.d(47): Error: declaration expected, not `assert`

    /tmp/tmp1eenlej4.d(48): Error: declaration expected, not `assert`

    /tmp/tmp1eenlej4.d(49): Error: declaration expected, not `assert`

    /tmp/tmp1eenlej4.d(50): Error: declaration expected, not `assert`

    /tmp/tmp1eenlej4.d(51): Error: declaration expected, not `assert`

    /tmp/tmp1eenlej4.d(52): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1eenlej4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int n = words.length;\n    int maxLen = words[0].len();\n  \
    \  map<int, string> mmap = new map<int, string>();\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3xruyx63.d(21): Error: found `,` when expecting `.` following int

    /tmp/tmp3xruyx63.d(21): Error: found `>` when expecting `;` following statement

    /tmp/tmp3xruyx63.d(21): Error: found `,` when expecting `.` following int

    /tmp/tmp3xruyx63.d(21): Error: found `>` when expecting `;` following statement

    /tmp/tmp3xruyx63.d(21): Error: expression expected, not `)`

    /tmp/tmp3xruyx63.d(21): Error: found `;` when expecting `)`

    /tmp/tmp3xruyx63.d(22): Error: found `unittest` when expecting `;` following statement

    /tmp/tmp3xruyx63.d(37): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3xruyx63.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    typedef map<char, int> char_map;\n    char_map cm_temp;\n  \
    \  int max_count = 0, index = -1;\n    for (auto &word: words) \n    {\n     \
    \   char_map cm;\n        for (auto &c: word) \n        {\n            if (!cm_temp.contains(c))\
    \ \n            {\n                cm[c] = 1;\n            }\n            else\
    \ \n            {\n                cm[c]++;\n                if (cm[c] > max_count)\
    \ \n                {\n                    max_count = cm[c];\n              \
    \      index = c - 'a';\n                }\n            }\n        }\n       \
    \ cm_temp = cm;\n    }\n    return words[index];\n}\n</code>\n<|/ a dscore=1 tags=string,algorithm,c++\
    \ |>\n<| a tags=string,algorithm,c++ |>\nHere is an O(n) solution.\nThe idea is\
    \ to iterate over the strings one by one and for each word get the count of unique\
    \ characters in it and keep track of the maximum count. Once you encounter a word\
    \ with a count that is greater than the maximum count, then the word with the\
    \ maximum count is your answer.\n<code>\nstring find_max(const vector<string>\
    \ &words) {\n  unordered_map<char, int> unique;\n  unordered_map<char, int> max_count;\n\
    \  for (const auto &s : words) {\n    for(auto &c : s) {\n      if (unique.count(c)\
    \ > 0)\n        unique[c]++;\n      else\n        unique[c] = 1;\n    }\n    for(auto\
    \ &c : s) {\n      if (max_count.count(c) > max_count.at(c))\n        max_count[c]\
    \ = max_count.at(c);\n      else\n        max_count[c] = unique[c];\n    }\n \
    \ }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp09gixbj5.d(19): Error: found `map` when expecting `;` following
    statement

    /tmp/tmp09gixbj5.d(19): Error: found `<` instead of statement

    /tmp/tmp09gixbj5.d(22): Error: basic type expected, not `&`

    /tmp/tmp09gixbj5.d(22): Error: no identifier for declarator `_error_`

    /tmp/tmp09gixbj5.d(22): Error: found `:` when expecting `;` following `for` condition

    /tmp/tmp09gixbj5.d(25): Error: basic type expected, not `&`

    /tmp/tmp09gixbj5.d(25): Error: no identifier for declarator `_error_`

    /tmp/tmp09gixbj5.d(25): Error: found `:` when expecting `;` following `for` condition

    /tmp/tmp09gixbj5.d(45): Error: declaration expected, not `<`

    /tmp/tmp09gixbj5.d(53): Error: no identifier for declarator `unordered_map`

    /tmp/tmp09gixbj5.d(53): Error: declaration expected, not `<`

    /tmp/tmp09gixbj5.d(54): Error: declaration expected, not `for`

    /tmp/tmp09gixbj5.d(58): Error: declaration expected, not `else`

    /tmp/tmp09gixbj5.d(60): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp09gixbj5.d", "-I'
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    int max = words[0].hashCode();\n    int length\
    \ = words.length;\n    foreach(char c in words[0]) {\n        for (int i = 0;\
    \ i < length; i++) {\n            if (words[i].hashCode() == c) continue;\n  \
    \          if (words[i].hashCode() > max) {\n                max = words[i].hashCode();\n\
    \                max = words[i];\n            }\n        }\n    }\n    return\
    \ max;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nIn addition to Kyle Rooney's answer:\n\
    This is an algorithm that would work even if you have multiple words with similar\
    \ lengths and letters. It is based on using a dictionary to map the string length\
    \ to an ordered list of strings with that length. The dictionary is then searched\
    \ for longest string with the same length as the longest string in the dictionary.\n\
    <code>\nimport java.util.LinkedList;\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuunt2dn4.d(22): Error: found `in` when expecting `;`

    /tmp/tmpuunt2dn4.d(33): Error: declaration expected, not `<`

    /tmp/tmpuunt2dn4.d(36): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuunt2dn4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int maxCount = 0;\n    string maxWord = \"\";\n    bool foundWord\
    \ = false;\n    for (int i = 0; i < words.length; ++i) {\n        string temp\
    \ = words[i];\n        int count = 0;\n        for (int j = 0; j < words.length;\
    \ ++j) {\n            if (words[j].length() > temp.length())\n               \
    \ continue;\n            count = words[j].length() - temp.length();\n        \
    \    if (count > maxCount) {\n                foundWord = true;\n            \
    \    maxCount = count;\n                maxWord = temp;\n            }\n     \
    \   }\n        if (foundWord) {\n            foundWord = false;\n        }\n \
    \   }\n    return maxWord;\n}\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_i9l0vi8.d(26): Error: no property `length` for type `string`

    /tmp/tmp_i9l0vi8.d(26): Error: no property `length` for type `string`

    /tmp/tmp_i9l0vi8.d(28): Error: no property `length` for type `string`

    /tmp/tmp_i9l0vi8.d(28): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_i9l0vi8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // Write your code here\n    map<int, string> max;\n    for(auto\
    \ w : words) {\n        auto it = max.find(w.size());\n        if(it != max.end())\n\
    \            it->second = w;\n        else\n            max.insert(pair<int, string>(w.size(),\
    \ w));\n    }\n    \n    string res = *max.rbegin().second;\n    for(auto it :\
    \ max) {\n        if(it.first > res.size()) {\n            res = it.second;\n\
    \        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7_kqvm6t.d(20): Error: found `,` when expecting `.` following int

    /tmp/tmp7_kqvm6t.d(20): Error: found `>` when expecting `;` following statement

    /tmp/tmp7_kqvm6t.d(21): Error: no identifier for declarator `w`

    /tmp/tmp7_kqvm6t.d(21): Error: expression expected, not `:`

    /tmp/tmp7_kqvm6t.d(21): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmp7_kqvm6t.d(24): Error: use `.` for member lookup, not `->`

    /tmp/tmp7_kqvm6t.d(26): Error: found `,` when expecting `.` following int

    /tmp/tmp7_kqvm6t.d(26): Error: found `>` when expecting `,`

    /tmp/tmp7_kqvm6t.d(30): Error: no identifier for declarator `it`

    /tmp/tmp7_kqvm6t.d(30): Error: expression expected, not `:`

    /tmp/tmp7_kqvm6t.d(30): Error: found `max` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7_kqvm6t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string,int> m;\n    for(int i = 0; i < words.length; ++i)\n\
    \    {\n        auto it = m.find(words[i]);\n        if(it != m.end())\n     \
    \   {\n            if(it->second > 1)\n                return words[i];\n    \
    \    }\n        else\n        {\n            map[words[i]] = 1;\n        }\n \
    \   }\n    map<string,int>::iterator it;\n    for(it = m.begin(); it != m.end();\
    \ ++it)\n    {\n        if(it->second == 1)\n            return it->first;\n \
    \   }\n    return words[0];\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThe easiest\
    \ way to solve your problem is to sort the letters in the strings. Then use std::count_if\
    \ to find the strings with the same number of letters. The second parameter of\
    \ std::count_if is a binary function that is supposed to return true if the letter\
    \ is in the string and false if not.\n<code>\n#include <algorithm>\n#include <vector>\n\
    #include <iostream>\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjev__36p.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmpjev__36p.d(25): Error: use `.` for member lookup, not `->`

    /tmp/tmpjev__36p.d(33): Error: found `>` when expecting `.` following int

    /tmp/tmpjev__36p.d(33): Error: found `:` when expecting identifier following `int`.

    /tmp/tmpjev__36p.d(33): Error: found `:` when expecting `;` following statement

    /tmp/tmpjev__36p.d(36): Error: use `.` for member lookup, not `->`

    /tmp/tmpjev__36p.d(37): Error: use `.` for member lookup, not `->`

    /tmp/tmpjev__36p.d(41): Error: declaration expected, not `<`

    /tmp/tmpjev__36p.d(53): Error: declaration expected, not `assert`

    /tmp/tmpjev__36p.d(54): Error: declaration expected, not `assert`

    /tmp/tmpjev__36p.d(55): Error: declaration expected, not `assert`

    /tmp/tmpjev__36p.d(56): Error: declaration expected, not `assert`

    /tmp/tmpjev__36p.d(57): Error: declaration expected, not `assert`

    /tmp/tmpjev__36p.d(58): Error: declaration expected, not `assert`

    /tmp/tmpjev__36p.d(59): Error: declaration expected, n'
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int counter = 0;\n    int max = 0;\n    string word = words[0];\n\
    \    \n    for (int i = 1; i < words.length; i++)\n    {\n        if(words[i].length()\
    \ > max)\n        {\n            counter = words[i].length();\n            max\
    \ = words[i].length();\n            word = words[i];\n        }\n    }\n    \n\
    \    return word;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmhfhn1ip.d(25): Error: no property `length` for type `string`

    /tmp/tmpmhfhn1ip.d(27): Error: no property `length` for type `string`

    /tmp/tmpmhfhn1ip.d(28): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmhfhn1ip.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string result = \"\";\n    for(size_t i =\
    \ 0; i < words.length; ++i)\n    {\n        auto current = words[i].size();\n\
    \        if(current > max) \n        {\n            max = current;\n         \
    \   result = words[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnwa8_evb.d(23): Error: no property `size` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnwa8_evb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    var maxCharCount = int.MaxValue;\n    var maxWord = string.Empty;\n\
    \    foreach (string word in words)\n    {\n        int charCount = 1;\n     \
    \   foreach (char c in word)\n        {\n            charCount++;\n        }\n\
    \        if (charCount > maxCharCount)\n        {\n            maxCharCount =\
    \ charCount;\n            maxWord = word;\n        }\n    }\n    return maxWord;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nthanks for posting the code but this does not answer\
    \ my question. I want the longest string to be returned and I can't use max to\
    \ find the longest string.\n<|/ c |>\n<| a dscore=0 tags=c#,string |>\n<code>\n\
    string findLongestString(string[] strings)\n{\n    string longest = string.Empty;\n\
    \    foreach (var str in strings)\n    {\n        if (str.Length > longest.Length)\n\
    \            longest = str;\n    }\n    return longest;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nthanks for posting the code but this does not answer my question. I want\
    \ the longest string to be returned and I can't use max to find the longest string.\n\
    <|/ c |>\n<| a dscore=0 tags=c#,string |>\n<code>\nstring findLongestString(string[]\
    \ strings)\n{\n    return strings.Aggregate((s, a) => s.Length > a.Length ? s\
    \ : a).ToString();\n}\n</code>\n<|/ a |>\n<| c |>\nThis only works if all strings\
    \ have the same length. If you use another string[] containing 3 strings, this\
    \ will return \"hi\" instead of \"how\" as expected. `string[] strings = { \"\
    hi\", \"ho\", \"how\" };`\n<|/ c |>\n<| a |>\n<code>\npublic static String getLongestString(String[]\
    \ strArr){\n    String longestStr = \"\";\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgity6tif.d(21): Error: found `in` when expecting `;`

    /tmp/tmpgity6tif.d(24): Error: found `in` when expecting `;`

    /tmp/tmpgity6tif.d(36): Error: declaration expected, not `<`

    /tmp/tmpgity6tif.d(39): Error: unterminated character constant

    /tmp/tmpgity6tif.d(46): Error: declaration expected, not `foreach`

    /tmp/tmpgity6tif.d(50): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgity6tif.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int[] count = new int[26];\n    int maxIndex = 0;\n    foreach\
    \ (string word in words)\n    {\n        int index = 0;\n        for (int i =\
    \ 0; i < word.length(); ++i)\n        {\n            count[word.charAt(i) - 'a']++;\n\
    \            index++;\n        }\n        if (index > maxIndex)\n        {\n \
    \           maxIndex = index;\n        }\n    }\n    \n    string result = words[maxIndex];\n\
    \    for (int i = 0; i < words.length; ++i)\n    {\n        int index = 0;\n \
    \       for (int i = 0; i < words[i].length(); ++i)\n        {\n            count[words[i].charAt(i)\
    \ - 'a']--;\n            index++;\n        }\n        if (index > maxIndex)\n\
    \        {\n            result = words[i];\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a |>\n<| a tags=c++,max,arrays |>\n<code>\n#include <iostream>\n\
    using namespace std;\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnwjnut0t.d(21): Error: found `in` when expecting `;`

    /tmp/tmpnwjnut0t.d(51): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnwjnut0t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max;\n    int count = 0;\n    for (int i = 0; i < words.length;\
    \ ++i) \n    {\n        for (int j = 0; j < words[i].length(); j++) \n       \
    \ {\n            if (words[i][j] == max[count]) \n            {\n            \
    \    count++;\n            }\n            else\n            {\n              \
    \  if (count == 0) \n                {\n                    max = words[i];\n\
    \                }\n            }\n        }\n    }\n    return max;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvb1t1oj5.d(23): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvb1t1oj5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int maxCount = 1;\n    string maxWord = words[0];\n    for(int\
    \ i=1; i<words.length; i++)\n    {\n        for(int j=0; j<words[i].length; j++)\n\
    \        {\n            if(words[i].length() > maxWord.length())\n           \
    \ {\n                maxCount = 1;\n                maxWord = words[i];\n    \
    \        }\n            else if(words[i].length() == maxWord.length())\n     \
    \       {\n                maxCount++;\n            }\n        }\n    }\n    return\
    \ maxWord;\n}\n/*\nWrite a function that accepts an array of strings containing\
    \ only digits.\n    Return an array with numbers from 0 to 99 that represent each\
    \ digit in \n    the string from right to left. For example, if the array is [\"\
    1\", \"2\", \"3\"]\n    then the returned array is [3, 2, 1]\nunittest\n{\n  \
    \  alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6ol_l_1j.d(38): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6ol_l_1j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<int, int> m;\n    int count = 0;\n    for (int i = 0; i\
    \ < words.length; i++) \n    {\n        int u = std.countChars(words[i]);\n  \
    \      m.put(u, count++);\n    }\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsms8fpu_.d(19): Error: found `,` when expecting `.` following int

    /tmp/tmpsms8fpu_.d(19): Error: found `int` when expecting identifier following
    `int`.

    /tmp/tmpsms8fpu_.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmpsms8fpu_.d(26): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsms8fpu_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max = null;\n    string word = null;\n    int count =\
    \ 0;\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp98nexxn3.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp98nexxn3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tstring result = \"no result\";\n\tfor(int i=0; i < words.length;\
    \ ++i) {\n\t\tint count = 0;\n\t\tfor(int j=0; j < words.length; ++j) {\n\t\t\t\
    if (words[j] == words[i]) ++count;\n\t\t}\n\t\tif (count > result.length()) result\
    \ = words[i];\n\t}\n\treturn result;\n}\n/*\nWrite a function that accepts an\
    \ array of ints.\n    The array contains different ints. Return the int with maximum\
    \ number\n    of unique elements. If multiple ints have maximum number of unique\
    \ elements,\n    return the one which comes first in lexicographical order.\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptg8vc_hx.d(29): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptg8vc_hx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<int, int> counter;\n    string max = \"not found\";\n  \
    \  for (string w : words)\n    {\n        int n = w.length();\n        if (counter.find(n)\
    \ == counter.end())\n        {\n            counter[n] = 1;\n        }\n     \
    \   else\n        {\n            int c = counter[n];\n            counter[n]++;\n\
    \            if (c > counter[max].second)\n            {\n                max\
    \ = w;\n            }\n        }\n    }\n    if (counter[max.length()].second\
    \ == 0)\n    {\n        max = \"not found\";\n    }\n    return max;\n}\n</code>\n\
    <|/ a tags=string,c++ |>\n<| c |>\nThanks for the help. It works in my case. I\
    \ have a doubt. As i understand, if i want to search the array with the key \"\
    a\" as in this case if the key is present i have to iterate through all the array\
    \ elements. Will the above code work if i search the key \"a\" in the 3rd array\
    \ element?\n<|/ c |>\n<| c |>\nIn that case, you would first have to search for\
    \ the `map` for the key \"a\" and then iterate through all the other elements\
    \ until you find `a`.\n<|/ c |>\n<| c |>\nOhk. Thanks alot for the help.\n<|/\
    \ c |>\n<| c |>\nWhy not use a set instead of a map?\n<|/ c |>\n<| c |>\nThat\
    \ would also work. It would require to first iterate through the map to get the\
    \ key \"a\" and then search the other elements for \"a\".\n<|/ c |>\n<| a dscore=0\
    \ tags=string,c++ |>\n<code>\n#include <iostream>\n#include <string>\n#include\
    \ <vector>\n#include <algorithm>\n#include <unordered_set>\nusing namespace std;\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplip2vcp2.d(19): Error: found `,` when expecting `.` following int

    /tmp/tmplip2vcp2.d(19): Error: found `int` when expecting identifier following
    `int`.

    /tmp/tmplip2vcp2.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmplip2vcp2.d(21): Error: found `w` when expecting `;` following statement

    /tmp/tmplip2vcp2.d(21): Error: expression expected, not `:`

    /tmp/tmplip2vcp2.d(21): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmplip2vcp2.d(44): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplip2vcp2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    if(words.length == 0) \n        return \"\";\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpls6d3vet.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpls6d3vet.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result; \n    int chars;\n    int i;\n    int max_len\
    \ = -1;\n    int counter = 0; \n    for (i = 0; i < words.length; i++)\n    {\n\
    \        chars = 0;\n        for (auto &w : words)\n            if (std.string::length(w)\
    \ == std.string::length(words[i]) && std.string::lexicographical_compare(w, words[i]))\n\
    \                chars++;\n        if (chars > max_len)\n        {\n         \
    \   result = words[i];\n            max_len = chars;\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=language-agnostic,algorithm,dynamic-programming\
    \ |>\n<| c |>\nCan you explain how this works and why it works?\n<|/ c |>\n<|\
    \ c |>\n: Please take a look at my answer.\n<|/ c |>\n<| a dscore=3 tags=language-agnostic,algorithm,dynamic-programming\
    \ |>\nHere is the C++ code for this problem\n<code>\n#include <iostream>\n#include\
    \ <algorithm>\n#include <vector>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_xek7n4d.d(27): Error: basic type expected, not `&`

    /tmp/tmp_xek7n4d.d(27): Error: no identifier for declarator `_error_`

    /tmp/tmp_xek7n4d.d(27): Error: found `:` when expecting `;` following `for` condition

    /tmp/tmp_xek7n4d.d(28): Error: found `:` when expecting `)`

    /tmp/tmp_xek7n4d.d(28): Error: found `:` instead of statement

    /tmp/tmp_xek7n4d.d(38): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_xek7n4d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> counter;\n    \n    for(int i=0; i<words.length;\
    \ ++i)\n    {\n        string word = words[i];\n        counter[word] += 1;\n\
    \    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpogfuhxre.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmpogfuhxre.d(26): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpogfuhxre.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    /*\n    Write your solution here\n    */\n}\n</code>\n<|/ a\
    \ tags=c++ |>\n<| c |>\nThis is not how SO works.  We don't want to simply tell\
    \ you the answer... We want to help you, and show you where you've gone wrong.\n\
    <|/ c |>\n<| c |>\nApologies. I've modified my answer. Should I delete this one?\
    \ I don't think the question was that bad, even if the answer was lengthy and\
    \ unclear.\n<|/ c |>\n<| c |>\nNot really.  Nothing is perfect, and you did well\
    \ to try to help.\n<|/ c |>\n<| c |>\nThank you for helping me out. This has helped\
    \ me alot !\n<|/ c |>\n<| c |>\nWelcome to Stack Overflow!  While this answer\
    \ may be correct, it's often better to include some explanatory text along with\
    \ it.  Code only answers can become invalid if the code is changed or removed\
    \ without explanation. \nThis answer will likely be deleted by the site unless\
    \ you add an explanation.\n<|/ c |>\n<| a |>\nThis is an improvement of the O(n\
    \ logn) solution posted here: https://stackoverflow.com/a/30778974/3943465\nThis\
    \ is O(n) time complexity, with O(1) space complexity.\n<code>\n#include <string>\n\
    #include <iostream>\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvpfde07d.d(23): Error: declaration expected, not `<`

    /tmp/tmpvpfde07d.d(26): Error: unterminated character constant

    /tmp/tmpvpfde07d.d(26): Error: unterminated character constant

    /tmp/tmpvpfde07d.d(29): Error: unterminated character constant

    /tmp/tmpvpfde07d.d(29): Error: unterminated character constant

    /tmp/tmpvpfde07d.d(38): Error: unterminated character constant

    /tmp/tmpvpfde07d.d(51): Error: declaration expected, not `assert`

    /tmp/tmpvpfde07d.d(52): Error: declaration expected, not `assert`

    /tmp/tmpvpfde07d.d(53): Error: declaration expected, not `assert`

    /tmp/tmpvpfde07d.d(54): Error: declaration expected, not `assert`

    /tmp/tmpvpfde07d.d(55): Error: declaration expected, not `assert`

    /tmp/tmpvpfde07d.d(56): Error: declaration expected, not `assert`

    /tmp/tmpvpfde07d.d(57): Error: declaration expected, not `assert`

    /tmp/tmpvpfde07d.d(58): Error: declaration expected, not `assert`

    /tmp/tmpvpfde07d.d(59): Error: declaration expected, not `assert`

    /tmp/tmpvpfde07d.d(60): Error: declaration expected, n'
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // TODO: write your code here\n    map<string, int> m;\n   \
    \ for(int i = 0; i < words.length; i++)\n    {\n        int count = 0;\n     \
    \   for(int j = 0; j < words.length; j++)\n        {\n            if(words[i]\
    \ == words[j])\n            {\n                count++;\n            }\n     \
    \   }\n        m[words[i]] = count;\n    }\n    map<int, string>::iterator it;\n\
    \    for(it = m.begin(); it != m.end(); it++)\n    {\n        if(it->second >\
    \ 1)\n        {\n            return it->first;\n        }\n    }\n    return words[0];\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp106ducva.d(20): Error: found `>` when expecting `.` following int

    /tmp/tmp106ducva.d(33): Error: found `,` when expecting `.` following int

    /tmp/tmp106ducva.d(33): Error: found `>` when expecting `;` following statement

    /tmp/tmp106ducva.d(33): Error: found `:` instead of statement

    /tmp/tmp106ducva.d(36): Error: use `.` for member lookup, not `->`

    /tmp/tmp106ducva.d(38): Error: use `.` for member lookup, not `->`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp106ducva.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    var counters = std.typecons.map();\n    foreach(string w in\
    \ words) {\n        foreach(char c in w) \n            counters[c] = 1 + counters[c];\n\
    \    }\n    foreach(char c in chars) {\n        foreach(string w in words) {\n\
    \            if (counters[c] >= w.length()) \n                return w;\n    \
    \    }\n    }\n    return null;\n}\n</code>\n<|/ a dscore=0 tags=ocaml,arrays,string\
    \ |>\n<| a tags=ocaml,arrays,string |>\nI like the idea of using a map of strings,\
    \ but the code is more verbose than necessary because it is so verbose. Let's\
    \ get rid of the foreach loops. We are going to iterate through the strings and\
    \ for each string find all the characters in it. In OCaml we get this behavior\
    \ for free by using the String.make function. The code becomes a lot easier to\
    \ read and debug. \n<code>\nlet max_count (str: string array) =\n  let rec get_count\
    \ (curr_index: int, curr_index : int) =\n    match str with\n    | [] -> 0\n \
    \   | head::tail -> if head = String.make 1 tail.[0] then get_count (curr_index\
    \ + 1) (curr_index + 1) else get_count (curr_index + 1) (curr_index)\n    | _::tail\
    \ -> get_count (curr_index + 1) (curr_index)\n  in \n  get_count 0 0\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 tags=ocaml,arrays,string |>\nIn OCaml you can\
    \ find the max number of unique characters in a string with just one simple function:\n\
    <code>\nlet find_max str = String.find (fun c -> String.mem c str) str\n</code>\n\
    But it seems that you also need to find the position of that character in the\
    \ string and I suggest a recursive function that counts how many times a character\
    \ appears in a string:\n<code>\nlet rec count str c =\n    match String.find c\
    \ str with\n    | None -> 0\n    | Some i -> 1 + count str (c :: i)\nlet find_max\
    \ str = count str \"\"\n</code>\nIn fact you don't need recursion at all to solve\
    \ this problem. Strings are just arrays of characters, so you can find the index\
    \ of the first character of a string in the following way:\n<code>\nlet find_max\
    \ str = \n    match String.find (fun c -> String.mem c str) str with\n    | None\
    \ -> 0\n    | Some i -> i\n</code>\nThe same logic can be used to solve your question,\
    \ but I suggest you use a map instead of a list to store the counts of each character:\n\
    \nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdh_6ayeh.d(20): Error: found `in` when expecting `;`

    /tmp/tmpdh_6ayeh.d(21): Error: found `in` when expecting `;`

    /tmp/tmpdh_6ayeh.d(24): Error: found `in` when expecting `;`

    /tmp/tmpdh_6ayeh.d(25): Error: found `in` when expecting `;`

    /tmp/tmpdh_6ayeh.d(32): Error: declaration expected, not `<`

    /tmp/tmpdh_6ayeh.d(35): Error: unterminated character constant

    /tmp/tmpdh_6ayeh.d(60): Error: unterminated character constant

    /tmp/tmpdh_6ayeh.d(73): Error: declaration expected, not `assert`

    /tmp/tmpdh_6ayeh.d(74): Error: declaration expected, not `assert`

    /tmp/tmpdh_6ayeh.d(75): Error: declaration expected, not `assert`

    /tmp/tmpdh_6ayeh.d(76): Error: declaration expected, not `assert`

    /tmp/tmpdh_6ayeh.d(77): Error: declaration expected, not `assert`

    /tmp/tmpdh_6ayeh.d(78): Error: declaration expected, not `assert`

    /tmp/tmpdh_6ayeh.d(79): Error: declaration expected, not `assert`

    /tmp/tmpdh_6ayeh.d(80): Error: declaration expected, not `assert`

    /tmp/tmpdh_6ayeh.d(81): Error: declaration expected, not `assert`'
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> freq;\n    for(auto w : words) {\n        int\
    \ c = std.countOccurrences(freq, w);\n        freq[w] = c+1;\n    }\n    return\
    \ std.max(freq.begin(), freq.end(), [] (pair<string, int> p1, pair<string, int>\
    \ p2) {\n        return p1.second < p2.second;\n    });\n}\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvl5kl6ks.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmpvl5kl6ks.d(20): Error: no identifier for declarator `w`

    /tmp/tmpvl5kl6ks.d(20): Error: expression expected, not `:`

    /tmp/tmpvl5kl6ks.d(20): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmpvl5kl6ks.d(24): Error: found `>` when expecting `.` following int

    /tmp/tmpvl5kl6ks.d(24): Error: found `>` when expecting `.` following int

    /tmp/tmpvl5kl6ks.d(24): Error: found `{` when expecting `,`

    /tmp/tmpvl5kl6ks.d(25): Error: expression expected, not `return`

    /tmp/tmpvl5kl6ks.d(25): Error: found `p1` when expecting `,`

    /tmp/tmpvl5kl6ks.d(25): Error: found `;` when expecting `,`

    /tmp/tmpvl5kl6ks.d(26): Error: expression expected, not `}`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvl5kl6ks.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int count = 1;\n    for (int i = 0; i < words.length; ++i)\n\
    \    {\n        for (int j = i; j < words.length; ++j)\n        {\n          \
    \  int num_unique_chars = 0;\n            string temp_str = words[i];\n      \
    \      for (int k = i; k < words.length; ++k)\n            {\n               \
    \ string str = words[k];\n                if (str.size() < temp_str.size())\n\
    \                {\n                    temp_str = str;\n                }\n \
    \               if (temp_str.size() == str.size())\n                {\n      \
    \              num_unique_chars += 1;\n                }\n            }\n    \
    \        if (num_unique_chars > count)\n            {\n                count =\
    \ num_unique_chars;\n                string tmp = words[i];\n                for\
    \ (int j = i; j < words.length; ++j)\n                {\n                    string\
    \ str = words[j];\n                    if (str.size() == tmp.size())\n       \
    \             {\n                        if (str.compare(tmp);\n             \
    \           {\n                            tmp = words[j];\n                 \
    \       }\n                    }\n                }\n                string out\
    \ = words[i];\n                if (out.size() < out.compare(tmp);\n          \
    \      {\n                    out = words[i];\n                }\n           \
    \ }\n        }\n    }\n    return words[count];\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 tags=c++,algorithm,string,sorting |>\nI find this interesting too\
    \ but since I already have a solution I want to share it with you.\nWhat I did\
    \ was to iterate over each character in each string and count the number of different\
    \ chars and then add the count into a map.\nThen I iterated over each string again\
    \ and iterated over each character in each string.\nFor each string I check if\
    \ the map already contains the char and if it is I return the index with maxCount\
    \ value.\n<code>\n #include <iostream>\n #include <map>\n #include <string>\n\
    \ using namespace std;\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphsjgu6dm.d(47): Error: found `;` when expecting `)`

    /tmp/tmphsjgu6dm.d(53): Error: found `out` when expecting `;` following statement

    /tmp/tmphsjgu6dm.d(53): Error: found `=` instead of statement

    /tmp/tmphsjgu6dm.d(54): Error: expression expected, not `out`

    /tmp/tmphsjgu6dm.d(54): Error: expression expected, not `out`

    /tmp/tmphsjgu6dm.d(54): Error: found `;` when expecting `)`

    /tmp/tmphsjgu6dm.d(56): Error: found `out` instead of statement

    /tmp/tmphsjgu6dm.d(63): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphsjgu6dm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string result = \"\";\n    for (int i = 0;\
    \ i < words.length; i++) {\n        char[] chars = words[i].ToCharArray();\n \
    \       Arrays.sort(chars);\n        int cur = chars.Length;\n        if (cur\
    \ > max) {\n            max = cur;\n            result = words[i];\n        }\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for\
    \ the answer! I really like how you used the sort function with a lambda. It helps\
    \ me understand how it works and helps me to better understand for loops etc!\
    \ I also appreciate the explanations so I can understand what's going on! However,\
    \ my professor specifically asked for me to use the find method that I already\
    \ used in my code. Also, what did you mean by 'sorting in ascending order' in\
    \ the last part of the answer? I tried googling that but couldn't find anything\
    \ on the subject.\n<|/ c |>\n<| c |>\nAh I misunderstood you. I thought you wanted\
    \ to sort the array in ascending order.\n<|/ c |>\n<| c |>\nAh! Thanks for the\
    \ clarification! Yeah, I realized my mistake right as I wrote my last comment\
    \ but then I realized that I can use the sort method and just switch the sorting\
    \ order of the lamba like so: Arrays.sort(chars, (x, y) => x.CompareTo(y));\n\
    <|/ c |>\n<| a tags=c# dscore=0 |>\nI believe this to be a working solution, though\
    \ it won't be particularly efficient. It uses HashSets and LINQ.\n<code>\n   \
    \ public string FindMax(List<string> words)\n    {\n        int maxCount = -1;\n\
    \        string result = null;\n        foreach (string word in words)\n     \
    \   {\n            int count = word\n                .Select(c => c.ToLowerInvariant())\n\
    \                .Distinct()\n                .Count();\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1in4o0cj.d(32): Error: declaration expected, not `<`

    /tmp/tmp1in4o0cj.d(35): Error: unterminated character constant

    /tmp/tmp1in4o0cj.d(35): Error: unterminated character constant

    /tmp/tmp1in4o0cj.d(35): Error: unterminated character constant

    /tmp/tmp1in4o0cj.d(35): Error: unterminated character constant

    /tmp/tmp1in4o0cj.d(42): Error: declaration expected, not `<`

    /tmp/tmp1in4o0cj.d(44): Error: unterminated character constant

    /tmp/tmp1in4o0cj.d(50): Error: declaration expected, not `foreach`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1in4o0cj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string wordWithMax = \"\";\n    for(int i\
    \ = 0; i < words.length; i++){\n        string word = words[i];\n        int length\
    \ = word.length;\n        int count = 1;\n        for(int j = 0; j < words.length;\
    \ j++){\n            string nextWord = words[j];\n            if(nextWord.length\
    \ == length){\n                if(nextWord > word){\n                    count\
    \ = count + 1;\n                }\n                else if(nextWord < word){\n\
    \                    count = count - 1;\n                }\n            }\n  \
    \      }\n        if(count > max){\n            max = count;\n            wordWithMax\
    \ = word;\n        }\n    }\n    return wordWithMax;\n}\n/*\nWrite a function\
    \ that accepts an array of strings.\n    The array contains different words. Return\
    \ the word with minimum number\n    of unique characters. If multiple strings\
    \ have minimum number of unique\n    characters, return the one which comes first\
    \ in lexicographical order.\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppokxh42n.d(43): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppokxh42n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> char_count;\n    \n    for (auto &it : words)\
    \ {\n        int char_count = it.size();\n        \n        auto it = char_count.find(char_count);\n\
    \        if (it != char_count.end()) {\n            if (it->second < char_count)\
    \ {\n                char_count[char_count] = it->second;\n            }\n   \
    \     }\n        else {\n            char_count[char_count] = 1;\n        }\n\
    \    }\n    \n    auto max_count = char_count.rbegin()->second;\n    auto max_index\
    \ = char_count.rbegin()->first;\n    for (auto it = char_count.begin(); it !=\
    \ char_count.end(); it++) {\n        if (it->second == max_count) {\n        \
    \    max_index = it->first;\n        }\n    }\n    return words[max_index];\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=c++,algorithm |>\nI wanted to do this\
    \ in a similar way. I'm writing this from memory so I might be missing some things\
    \ but it should be pretty close. I was also asked to do it with std::map instead\
    \ of map.\n<code>\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpedrr93a0.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmpedrr93a0.d(21): Error: basic type expected, not `&`

    /tmp/tmpedrr93a0.d(21): Error: no identifier for declarator `_error_`

    /tmp/tmpedrr93a0.d(21): Error: found `:` when expecting `;` following `for` condition

    /tmp/tmpedrr93a0.d(26): Error: use `.` for member lookup, not `->`

    /tmp/tmpedrr93a0.d(27): Error: use `.` for member lookup, not `->`

    /tmp/tmpedrr93a0.d(35): Error: expression expected, not `>`

    /tmp/tmpedrr93a0.d(35): Error: semicolon expected following auto declaration,
    not `second`

    /tmp/tmpedrr93a0.d(36): Error: expression expected, not `>`

    /tmp/tmpedrr93a0.d(36): Error: semicolon expected following auto declaration,
    not `first`

    /tmp/tmpedrr93a0.d(38): Error: use `.` for member lookup, not `->`

    /tmp/tmpedrr93a0.d(39): Error: use `.` for member lookup, not `->`

    /tmp/tmpedrr93a0.d(44): Error: declaration expected, not `<`

    /tmp/tmpedrr93a0.d(47): Error: unterminated character constant

    /tmp/tmpedrr93a0.d(53): Error: declaratio'
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result = null;\n    int maxCount = 0;\n    for (int i=0;\
    \ i<words.length; ++i) {\n        int count = length(words[i]);\n        if (count\
    \ > maxCount) {\n            result = words[i];\n            maxCount = count;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg_40noeo.d(22): Error: undefined identifier `length`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg_40noeo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<int, string> map;\n    \n    for (int i = 0; i < words.length();\
    \ ++i)\n    {\n        int c = words[i].length();\n        if (map.find(c) ==\
    \ map.end())\n        {\n            map[c] = words[i];\n        }\n        else\n\
    \        {\n            map[c] = words[i] > map[c] ? words[i] : map[c];\n    \
    \    }\n    }\n    \n    for (auto it : map)\n    {\n        \n        if (it.second\
    \ == it.first)\n        {\n            return it.second;\n        }\n    }\n \
    \   \n    return words[0];\n}\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmtursjne.d(19): Error: found `,` when expecting `.` following int

    /tmp/tmpmtursjne.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmpmtursjne.d(34): Error: no identifier for declarator `it`

    /tmp/tmpmtursjne.d(34): Error: expression expected, not `:`

    /tmp/tmpmtursjne.d(34): Error: found `map` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmtursjne.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  int max = 0, i = 0;\n  for(string[] word: words)\n  {\n    foreach(int\
    \ c, word)\n    {\n      if(max == 0)\n      {\n        max = c;\n        i =\
    \ word.indexOf(c);\n      }\n      else if(max < c)\n      {\n        max = c;\n\
    \        i = word.indexOf(c);\n      }\n    }\n  }\n  return words[i];\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=algorithm,string,c++,sorting dscore=0 |>\nI suggest\
    \ you to use std::set or std::unordered_set to keep count of letters in each word.\
    \ You can use std::unordered_map to keep word as key and count as value. \nThe\
    \ code would look like this:\n<code>\n#include <unordered_map>\n#include <set>\n\
    #include <vector>\n#include <iostream>\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqicb2uta.d(20): Error: found `word` when expecting `;` following
    statement

    /tmp/tmpqicb2uta.d(20): Error: expression expected, not `:`

    /tmp/tmpqicb2uta.d(20): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmpqicb2uta.d(22): Error: no identifier for declarator `word`

    /tmp/tmpqicb2uta.d(22): Error: found `)` when expecting `;`

    /tmp/tmpqicb2uta.d(35): Error: found `}` when expecting `)`

    /tmp/tmpqicb2uta.d(38): Error: found `<` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqicb2uta.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tstring maxWord = \"\";\n\t\n\tbool unique = true;\n\tfor (int\
    \ i = 0; i < words.length; i++)\n\t{\n\t\tint count = charCount(words[i]);\n\t\
    \tif (count > unique)\n\t\t{\n\t\t\tunique = count;\n\t\t\tmaxWord = words[i];\n\
    \t\t}\n\t}\n\t\n\treturn maxWord;\n}\n/* \nWrite a function that accepts an array\
    \ of strings.\n    The array contains different words. Return the word with minimum\
    \ number\n    of unique characters. If multiple strings have maximum number of\
    \ unique\n    characters, return the one which comes first in lexicographical\
    \ order.\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3sblfbee.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3sblfbee.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int count = 0;\n    string result = \"\";\n    int temp = 0;\n\
    \    for (int i = 0; i < words.length; i++)\n    {\n        for (int j = i + 1;\
    \ j < words.length; j++)\n        {\n            temp = count + count_char(words[i],\
    \ words[j]);\n            if (temp > count)\n            {\n                count\
    \ = temp;\n                result = words[i];\n            }\n        }\n    }\n\
    \    return result;\n}\n</code>\n<|/ a dscore=0 tags=functional-programming,python,arrays,c++,algorithm\
    \ |>\n<| c |>\nIt doesn't compile because the `count_char` method doesn't return\
    \ a value.\n<|/ c |>\n<| c |>\n, Thanks. I edited my answer.\n<|/ c |>\n<| a tags=functional-programming,python,arrays,c++,algorithm\
    \ dscore=0 |>\nHere is my solution in Scala\n<code>\ndef findLongest(str: List[String]):\
    \ String = {\n  str.foldLeft(List[String]())(_ ++ _).groupBy(_).mapValues(_.length)\n\
    \  .maxBy(_._2)._1\n}\n</code>\n<|/ a |>\n<| a tags=functional-programming,python,arrays,c++,algorithm\
    \ |>\nHere is my solution in Scala.\n<code>\ndef findLongest(str: List[String]):\
    \ String = {\n str.foldLeft(List[String]())(_ ++ _).groupBy(_).mapValues(_.length)\n\
    .maxBy(_._2)._1\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=functional-programming,python,arrays,c++,algorithm\
    \ |>\nA solution in Javascript:\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7z71ud69.d(36): Error: declaration expected, not `<`

    /tmp/tmp7z71ud69.d(39): Error: unterminated character constant

    /tmp/tmp7z71ud69.d(39): Error: unterminated character constant

    /tmp/tmp7z71ud69.d(68): Error: declaration expected, not `assert`

    /tmp/tmp7z71ud69.d(69): Error: declaration expected, not `assert`

    /tmp/tmp7z71ud69.d(70): Error: declaration expected, not `assert`

    /tmp/tmp7z71ud69.d(71): Error: declaration expected, not `assert`

    /tmp/tmp7z71ud69.d(72): Error: declaration expected, not `assert`

    /tmp/tmp7z71ud69.d(73): Error: declaration expected, not `assert`

    /tmp/tmp7z71ud69.d(74): Error: declaration expected, not `assert`

    /tmp/tmp7z71ud69.d(75): Error: declaration expected, not `assert`

    /tmp/tmp7z71ud69.d(76): Error: declaration expected, not `assert`

    /tmp/tmp7z71ud69.d(77): Error: declaration expected, not `assert`

    /tmp/tmp7z71ud69.d(78): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7z71ud69.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    \n    int max = 0;\n    int num = 0;\n    string result = \"\
    \";\n    \n    for (int i = 0; i < words.length; ++i) \n    {\n        unordered_set<char>\
    \ uniq_chars;\n        \n        for (int j = 0; j < words[i].length(); ++j)\n\
    \        {\n            uniq_chars[words[i][j]] = 1;\n        }\n        \n  \
    \      for (int j = 0; j < uniq_chars.size(); ++j)\n        {\n            ++num;\n\
    \            if (num > max)\n            {\n                max = num;\n     \
    \           result = words[i];\n            }\n        }\n    }\n    \n    return\
    \ result;\n}\n</code>\n<|/ a tags=string,c++,arrays,data-structures,sorting |>\n\
    <| c |>\nPlease add some explanation to your answer such that others can learn\
    \ from it\n<|/ c |>\n<| a tags=string,c++,arrays,data-structures,sorting |>\n\
    In C++\n<code>\nusing namespace std;\n</code>\nDeclare a string array.\n<code>\n\
    string name[] = \"Mary\"; //initializing string array\nstring name[] = \"John\"\
    ; //initializing string array\nstring name[] = \"Peter\"; //initializing string\
    \ array\nstring name[] = \"Paul\"; //initializing string array\nstring name[]\
    \ = \"Mary\"; //initializing string array\nstring name[] = \"Peter\"; //initializing\
    \ string array\nstring name[] = \"Paul\"; //initializing string array\n</code>\n\
    Use the sort function to sort the string.\n<code>\nsort(name, name + 4);\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nWhy would you suggest `using namespace std;` instead\
    \ of `using std::string;`?\n<|/ c |>\n<| c |>\nNo reason. Just a suggestion. Thanks\
    \ for the comment.\n<|/ c |>\n<| a dscore=2 |>\nIn Python:\n<code>\ndef maxInArray(array):\n\
    \    max = 0\n    index = -1\n    for i in range(len(array)):\n        if array[i]\
    \ > array[index]:\n            max = array[i]\n            index = i\n    return\
    \ array[index]\n</code>\n<|/ a tags=string,c++,arrays,data-structures,sorting\
    \ |>\n<| a dscore=2 |>\nIn C++:\n<code>\nstring s[] = {\"Mary\", \"John\", \"\
    Peter\", \"Paul\", \"Mary\", \"Peter\", \"Paul\"};\nstring max;\nfor (int i=0;\
    \ i<sizeof(s)/sizeof(s[0]); i++)\n{\n   for(int j=0; j<sizeof(s)/sizeof(s[0]);\
    \ j++)\n    {\n        if(s[i].compare(s[j]) > 0) // or < if you prefer\n    \
    \    {\n            max = s[j];\n        }\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5c8rj_o5.d(26): Error: found `>` when expecting `.` following char

    /tmp/tmp5c8rj_o5.d(46): Error: declaration expected, not `<`

    /tmp/tmp5c8rj_o5.d(55): Error: declaration expected, not `<`

    /tmp/tmp5c8rj_o5.d(59): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] name`

    /tmp/tmp5c8rj_o5.d(60): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] name`

    /tmp/tmp5c8rj_o5.d(61): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] name`

    /tmp/tmp5c8rj_o5.d(62): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] name`

    /tmp/tmp5c8rj_o5.d(63): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] name`

    /tmp/tmp5c8rj_o5.d(64): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] name`

    /tmp/tmp5c8rj_o5.d(65): Error: declaration expected, not `<`

    /tmp/tmp5c8rj_o5.d(69): Error: declaration expected, not `<`

    /tmp/tmp5c8rj_o5.d(95): Error: declaration expected, not `for`

    /tmp/tmp5c8rj_o5.d(95): Error: no identifier for'
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint max = 0;\n\tstring word = \"\";\n\tint count = 0;\n\tint index\
    \ = 0;\n\tfor (int i = 0; i < words.length(); i++)\n\t{\n\t\tcount = 1;\n\t\t\
    word = words[i];\n\t\tfor (int j = index; j < word.length(); j++)\n\t\t{\n\t\t\
    \tif (word[j] == word[i])\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count\
    \ > max)\n\t\t{\n\t\t\tmax = count;\n\t\t\tindex = i;\n\t\t}\n\t}\n\treturn word;\n\
    }\n/*\nWrite a function that accepts a string as argument.\n    Return the number\
    \ of times that the string has occurred.\n    \n    >>> count_letters(\"aaaaaaa\"\
    )\n    4\n    >>> count_letters(\"name\")\n    2\n*/\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp695zh_q0.d(23): Error: no property `length` for type `string[]`

    /tmp/tmp695zh_q0.d(27): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp695zh_q0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int maxNum = 0;\n    int max = 0;\n    int index = 0;\n    for(index\
    \ =0; index < words.length; index++) {\n        int[] charNum = new int[256];\n\
    \        int[] charMax = new int[256];\n        for(int i=0; i < words[index].length();\
    \ i++) {\n            if(charNum[words[index].charAt(i)] == 0) {\n           \
    \     charNum[words[index].charAt(i)] = 1;\n                charMax[words[index].charAt(i)]\
    \ = 1;\n            }\n            else {\n                charNum[words[index].charAt(i)]++;\n\
    \                charMax[words[index].charAt(i)]++;\n            }\n        }\n\
    \        for(int i=0; i < charNum.length; i++) {\n            if(charNum[i] >\
    \ max) {\n                max = charNum[i];\n                maxNum = i;\n   \
    \         }\n        }\n    }\n    return words[maxNum];\n}\n</code>\n<|/ a dscore=0\
    \ tags=java,algorithm |>\n<| c |>\nThis solution is O(M+N) time complexity as\
    \ per my understanding and this solution is also O(N), which is not the best case\
    \ for this problem\n<|/ c |>\n<| a |>\nThis can be done in a single pass in O(N)\
    \ time complexity where N is the number of words.\nBelow is the working code snippet\
    \ in Java.\n<code>\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn_x1_shq.d(44): Error: declaration expected, not `<`

    /tmp/tmpn_x1_shq.d(54): Error: identifier expected following `package`

    /tmp/tmpn_x1_shq.d(54): Error: `;` expected

    /tmp/tmpn_x1_shq.d(55): Error: identifier expected following `package`

    /tmp/tmpn_x1_shq.d(55): Error: `;` expected

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn_x1_shq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string,int> m;\n    for(string s: words) \n        ++m[s];\n\
    \    int max=0;\n    string maxWord=\"\";\n    foreach(string s, m)\n    {\n \
    \       if(m>max)\n        {\n            max=m[s];\n            maxWord=s;\n\
    \        }\n    }\n    return maxWord;\n}\n</code>\n<|/ a tags=c++,arrays,algorithm\
    \ dscore=0 |>\n<| a tags=c++,arrays,algorithm |>\n<code>\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzexq9hv5.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmpzexq9hv5.d(20): Error: found `s` when expecting `;` following statement

    /tmp/tmpzexq9hv5.d(20): Error: expression expected, not `:`

    /tmp/tmpzexq9hv5.d(20): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmpzexq9hv5.d(24): Error: no identifier for declarator `m`

    /tmp/tmpzexq9hv5.d(24): Error: found `)` when expecting `;`

    /tmp/tmpzexq9hv5.d(32): Error: found `return` when expecting `)`

    /tmp/tmpzexq9hv5.d(34): Error: declaration expected, not `<`

    /tmp/tmpzexq9hv5.d(42): Error: declaration expected, not `assert`

    /tmp/tmpzexq9hv5.d(43): Error: declaration expected, not `assert`

    /tmp/tmpzexq9hv5.d(44): Error: declaration expected, not `assert`

    /tmp/tmpzexq9hv5.d(45): Error: declaration expected, not `assert`

    /tmp/tmpzexq9hv5.d(46): Error: declaration expected, not `assert`

    /tmp/tmpzexq9hv5.d(47): Error: declaration expected, not `assert`

    /tmp/tmpzexq9hv5.d(48): Error: declaration expected, not `assert`

    /tmp/tmp'
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    size_t maxCount = 0;\n    string word = \"\";\n    for(auto\
    \ &w : words) \n    {\n        size_t count = std::count_if(w.begin(), w.end(),\
    \ [](char c){ return isalpha(c); });\n        if(count > maxCount) \n        {\n\
    \            word = w;\n            maxCount = count;\n        }\n    }\n    if(maxCount\
    \ > 1)\n    {\n        auto firstSort = [&](string a){return std::lexicographical_compare(a.begin(),\
    \ a.end(), word.begin(), word.end());};\n        std::sort(words.begin(), words.end(),\
    \ firstSort);\n    }\n    return word;\n}\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmputuo68n6.d(21): Error: basic type expected, not `&`

    /tmp/tmputuo68n6.d(21): Error: no identifier for declarator `_error_`

    /tmp/tmputuo68n6.d(21): Error: found `:` when expecting `;` following `for` condition

    /tmp/tmputuo68n6.d(23): Error: semicolon expected, not `:`

    /tmp/tmputuo68n6.d(23): Error: found `:` instead of statement

    /tmp/tmputuo68n6.d(23): Error: found `)` instead of statement

    /tmp/tmputuo68n6.d(30): Error: declaration expected, not `if`

    /tmp/tmputuo68n6.d(32): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmputuo68n6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int n = words.length;\n    string s = \"\";\n    int max = 1;\n\
    \    int i;\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmoz1wia7.d(23): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmoz1wia7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\t\n}\n</cell>\n<cell>\n%%writefile wordcount/main.dart\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp37g6pkm0.d(21): Error: declaration expected, not `<`

    /tmp/tmp37g6pkm0.d(28): Error: declaration expected, not `assert`

    /tmp/tmp37g6pkm0.d(29): Error: declaration expected, not `assert`

    /tmp/tmp37g6pkm0.d(30): Error: declaration expected, not `assert`

    /tmp/tmp37g6pkm0.d(31): Error: declaration expected, not `assert`

    /tmp/tmp37g6pkm0.d(32): Error: declaration expected, not `assert`

    /tmp/tmp37g6pkm0.d(33): Error: declaration expected, not `assert`

    /tmp/tmp37g6pkm0.d(34): Error: declaration expected, not `assert`

    /tmp/tmp37g6pkm0.d(35): Error: declaration expected, not `assert`

    /tmp/tmp37g6pkm0.d(36): Error: declaration expected, not `assert`

    /tmp/tmp37g6pkm0.d(37): Error: declaration expected, not `assert`

    /tmp/tmp37g6pkm0.d(38): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp37g6pkm0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int[,] count_matrix = new int[words.length, words[0].length];\n\
    \    int[,] maxcount_matrix = new int[words.length, words[0].length];\n    int\
    \ i,j;\n    \n    for(i=0; i<words.length; i++)\n    {\n        int count=0;\n\
    \        for(j=0; j<words[i].length; j++)\n            count+=count_matrix[i,j];\n\
    \        count_matrix[i,0]=count;\n    }\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd32r8b4s.d(19): Error: expression expected, not `,`

    /tmp/tmpd32r8b4s.d(19): Error: found `,` when expecting `]`

    /tmp/tmpd32r8b4s.d(19): Error: semicolon expected, not `words`

    /tmp/tmpd32r8b4s.d(19): Error: found `]` when expecting `;` following statement

    /tmp/tmpd32r8b4s.d(19): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpd32r8b4s.d(20): Error: expression expected, not `,`

    /tmp/tmpd32r8b4s.d(20): Error: found `,` when expecting `]`

    /tmp/tmpd32r8b4s.d(20): Error: semicolon expected, not `words`

    /tmp/tmpd32r8b4s.d(20): Error: found `]` when expecting `;` following statement

    /tmp/tmpd32r8b4s.d(20): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpd32r8b4s.d(30): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd32r8b4s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    var result = new string();\n    var counter = -1;\n    var max\
    \ = words[0].length;\n    foreach(var word in words)\n    {\n        if(word.Length\
    \ > max)\n        {\n            max = word.Length;\n            result = word;\n\
    \        }\n        foreach (var letter in word)\n        {\n            if(letter\
    \ == ' ' || letter == '\\n')\n                continue;\n            counter++;\n\
    \            if(counter > max)\n            {\n                result = word;\n\
    \                break;\n            }\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI appreciate this solution, but it is\
    \ very slow. I ran it on 20,000 random strings and it took 1.9 seconds. I did\
    \ some more testing and found that if I remove the foreach loop and replace it\
    \ with a while loop, it takes less than 1 second. This is still not the best solution\
    \ though.\n<|/ c |>\n<| c |>\nAh, I was working on something else when I came\
    \ back to check your solution. My solution was indeed much faster.\n<|/ c |>\n\
    <| a dscore=0 |>\nJust another way of doing it using linq:\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7lu8iu85.d(22): Error: found `in` when expecting `;`

    /tmp/tmp7lu8iu85.d(29): Error: found `in` when expecting `;`

    /tmp/tmp7lu8iu85.d(43): Error: declaration expected, not `<`

    /tmp/tmp7lu8iu85.d(55): Error: semicolon expected, not `.`

    /tmp/tmp7lu8iu85.d(55): Error: no identifier for declarator `.Collections.Generic`

    /tmp/tmp7lu8iu85.d(56): Error: semicolon expected, not `.`

    /tmp/tmp7lu8iu85.d(56): Error: no identifier for declarator `.Linq`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7lu8iu85.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint maxCount = words[0].size();\n\tint maxWord = words[0];\n\t\
    int index = 1;\n\tint wordCount = 0;\n\tfor (int i = 0; i < words.length; ++i)\n\
    \t{\n\t\tstring word = words[i];\n\t\tint wordSize = word.size();\n\t\tint count\
    \ = 0;\n\t\tfor (int j = 0; j < wordSize; ++j)\n\t\t{\n\t\t\tchar c = word[j];\n\
    \t\t\tif (std.typecons.find(chars.contains(char(c))))\n\t\t\t\t++count;\n\t\t\
    }\n\t\tif (count > maxCount)\n\t\t{\n\t\t\tmaxCount = count;\n\t\t\tmaxWord =\
    \ word;\n\t\t\tindex = i;\n\t\t}\n\t}\n\treturn maxWord;\n}\nunittest\n{\n   \
    \ alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1x9cx4j6.d(19): Error: no property `size` for type `string`

    /tmp/tmp1x9cx4j6.d(20): Error: cannot implicitly convert expression `words[0]`
    of type `string` to `int`

    /tmp/tmp1x9cx4j6.d(26): Error: no property `size` for type `string`

    /tmp/tmp1x9cx4j6.d(31): Error: undefined identifier `find` in module `std.typecons`,
    did you mean template `Bind(alias Template, args1...)`?

    /tmp/tmp1x9cx4j6.d(37): Error: cannot implicitly convert expression `word` of
    type `string` to `int`

    /tmp/tmp1x9cx4j6.d(41): Error: cannot implicitly convert expression `maxWord`
    of type `int` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1x9cx4j6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string result = \"\";\n    foreach(string\
    \ word in words)\n    {\n        int count = 0;\n        foreach(char c in word)\n\
    \        {\n            count += uniques[c];\n        }\n        if (count > max)\n\
    \        {\n            max = count;\n            result = word;\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsk0hm_yu.d(21): Error: found `in` when expecting `;`

    /tmp/tmpsk0hm_yu.d(24): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsk0hm_yu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint uniqueCount = 0, longestUnique = 0, index = 0;\n\tfor(int\
    \ i = 0; i < words.length; i++){\n\t\tfor(int j = 0; j < words[i].length(); j++){\n\
    \t\t\tuniqueCount++;\n\t\t\tif(uniqueCount == longestUnique){\n\t\t\t\tindex =\
    \ i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(uniqueCount > longestUnique){\n\t\t\t\t\
    longestUnique = uniqueCount;\n\t\t\t}\n\t\t}\n\t}\n\treturn words[index];\n}\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuzv6oc_p.d(21): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuzv6oc_p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tsort(words);\n\tfor (size_t i = 0; i < words.length; ++i)\n\t\
    {\n\t\tint counter = 0;\n\t\tfor (size_t j = 0; j < words.length; ++j)\n\t\t{\n\
    \t\t\tif (i == j) continue;\n\t\t\tif (words[i].length() < words[j].length())\n\
    \t\t\t\tcounter++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (words[i].length() == words[j].length())\n\
    \t\t\t\t{\n\t\t\t\t\tif (words[i] < words[j])\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\
    }\n\t\t\t\telse\n\t\t\t\t\tcounter--;\n\t\t\t}\n\t\t}\n\t\tif (counter == words.length)\n\
    \t\t\treturn words[i];\n\t}\n\treturn \"string\";\n}\n\t\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr9kj9m1_.d(19): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpr9kj9m1_.d(26): Error: no property `length` for type `string`

    /tmp/tmpr9kj9m1_.d(26): Error: no property `length` for type `string`

    /tmp/tmpr9kj9m1_.d(30): Error: no property `length` for type `string`

    /tmp/tmpr9kj9m1_.d(30): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr9kj9m1_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<char, int> counters = dict<char, int>();\n    for(auto w\
    \ : words) {\n        for(char c : w) {\n            counters[c] = counters[c]\
    \ + 1;\n        }\n    }\nunittest\n{\n    alias candidate = find_max;\n\n   \
    \ assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6qxlekw2.d(19): Error: found `,` when expecting `.` following char

    /tmp/tmp6qxlekw2.d(19): Error: found `int` when expecting identifier following
    `char`.

    /tmp/tmp6qxlekw2.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmp6qxlekw2.d(19): Error: found `,` when expecting `.` following char

    /tmp/tmp6qxlekw2.d(19): Error: found `int` when expecting identifier following
    `char`.

    /tmp/tmp6qxlekw2.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmp6qxlekw2.d(19): Error: expression expected, not `)`

    /tmp/tmp6qxlekw2.d(19): Error: found `;` when expecting `)`

    /tmp/tmp6qxlekw2.d(20): Error: found `for` when expecting `;` following statement

    /tmp/tmp6qxlekw2.d(20): Error: found `:` when expecting `)`

    /tmp/tmp6qxlekw2.d(20): Error: missing `{ ... }` for function literal

    /tmp/tmp6qxlekw2.d(20): Error: found `words` when expecting `;` following statement

    /tmp/tmp6qxlekw2.d(20): Error: found `)` instead of statement

    /tmp/tmp6qxlekw2.d(24): Error: unrecognized declaration

    Failed'
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result = \"\";\n    int maxCount = 0;\n    for (int i\
    \ = 0; i < words.length; i++) {\n        int count = 0;\n        for (int j =\
    \ 0; j < words[i].length(); j++) {\n            if (words[i].charAt(j) == result.charAt(j))\n\
    \                count++;\n        }\n        if (count > maxCount) {\n      \
    \      result = words[i];\n            maxCount = count;\n        }\n    }\n \
    \   \n    return maxCount < words.length ? result : words[0];\n}\n</cell>\n<code\
    \ language=.net-csharp>\n#r \"Bot.dll\"\nusing Bot;\n</cell>\n<code language=.net-csharp>\n\
    var name = \"name enam game\";\nvar words = name.Split(' ');\n</cell>\n<code language=.net-csharp>\n\
    find_max(words);\n</cell>\n<code language=.net-csharp>\nstring longest(string\
    \ words)\n{\n    string result = \"\";\n    int maxCount = 0;\n    \n    for (int\
    \ i = 0; i < words.Length; i++) {\n        int count = 0;\n        for (int j\
    \ = 0; j < words[i].Length; j++) {\n            if (words[i].Length > j)\n   \
    \             count++;\n        }\n        if (count > maxCount) {\n         \
    \   result = words[i];\n            maxCount = count;\n        }\n    }\n    \n\
    \    return maxCount < words.Length ? result : words[0];\n}\n</cell>\n<code language=.net-csharp>\n\
    longest(words);\n</cell>\n<code language=.net-csharp>\nstring longest(string words)\n\
    {\n    string result = \"\";\n    int maxCount = 0;\n    \n    for (int i = 0;\
    \ i < words.Length; i++) {\n        int count = 0;\n        for (int j = 0; j\
    \ < words[i].Length; j++) {\n            if (words[i].Length > j)\n          \
    \      count++;\n        }\n        if (count > maxCount) {\n            result\
    \ = words[i];\n            maxCount = count;\n        }\n    }\n    \n    return\
    \ maxCount < words.Length ? result : words[0];\n}\n</cell>\n<code language=.net-csharp>\n\
    var name = \"name enam game\";\nvar words = name.Split(' ');\n</cell>\n<code language=.net-csharp>\n\
    longest(words);\n</cell>\n<code language=.net-csharp>\nvar name = \"aaaaaab bb\
    \ cc\";\nvar words = name.Split(' ');\n</cell>\n<code language=.net-csharp>\n\
    longest(words);\n</cell>\n<code language=.net-csharp>\nvar name = \"aaaaaaa bb\
    \ cc\";\nvar words = name.Split(' ');\n</cell>\n<code language=.net-csharp>\n\
    longest(words);\n</cell>\n<code language=.net-csharp>\nvar name = \"aaaaaaa\"\
    ;\nvar words = name.Split('\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7uv8eu84.d(35): Error: declaration expected, not `<`

    /tmp/tmp7uv8eu84.d(39): Error: declaration expected, not `<`

    /tmp/tmp7uv8eu84.d(43): Error: declaration expected, not `<`

    /tmp/tmp7uv8eu84.d(46): Error: declaration expected, not `<`

    /tmp/tmp7uv8eu84.d(53): Error: declaration expected, not `for`

    /tmp/tmp7uv8eu84.d(53): Error: no identifier for declarator `i`

    /tmp/tmp7uv8eu84.d(53): Error: declaration expected, not `<`

    /tmp/tmp7uv8eu84.d(53): Error: no identifier for declarator `i`

    /tmp/tmp7uv8eu84.d(53): Error: declaration expected, not `++`

    /tmp/tmp7uv8eu84.d(55): Error: declaration expected, not `for`

    /tmp/tmp7uv8eu84.d(55): Error: no identifier for declarator `j`

    /tmp/tmp7uv8eu84.d(55): Error: declaration expected, not `<`

    /tmp/tmp7uv8eu84.d(55): Error: no identifier for declarator `j`

    /tmp/tmp7uv8eu84.d(55): Error: declaration expected, not `++`

    /tmp/tmp7uv8eu84.d(58): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7uv8eu84.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string best=words[0];\n    int size=words.length;\n    int i;\n\
    \    bool found=false;\n    for (i = 1; i < size; i++)\n    {\n        if (std.universe.unique(words[i])\
    \ == 1)\n        {\n            if (std.universe.compare(words[i - 1], words[i])\
    \ >= 0) \n            {\n                best=words[i];\n                found=true;\n\
    \            }\n            else\n            {\n                best=words[i\
    \ - 1];\n            }\n        }\n    }\n    if (!found) \n    {\n        return\
    \ words[0];\n    }\n    return best;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvt0etixi.d(20): Error: cannot implicitly convert expression `words.length`
    of type `ulong` to `int`

    /tmp/tmpvt0etixi.d(25): Error: undefined identifier `universe` in package `std`

    /tmp/tmpvt0etixi.d(27): Error: undefined identifier `universe` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvt0etixi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint numOfChars = 0;\n\tstring result = \"\";\n\tfor(int i = 0;\
    \ i < words.length; ++i)\n\t{\n\t\tstring curr = words[i];\n\t\tnumOfChars +=\
    \ curr.length();\n\t\tstring tmp = sortStringWithCharCount(curr);\n\t\tnumOfChars\
    \ += tmp.length();\n\t\tfor(int j = 0; j < tmp.length(); ++j)\n\t\t{\n\t\t\tif(numOfChars\
    \ < tmp.length())\n\t\t\t{\n\t\t\t\tresult = tmp;\n\t\t\t\tnumOfChars = tmp.length();\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n/*\nWrite a function that accepts an\
    \ array of strings.\n    The array contains different words. Return True if any\
    \ of words\n    has maximum number of unique characters. If multiple strings have\
    \ maximum\n    of unique characters, return True if first comes first in lexicographical\n\
    \    order.\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ovdyiz4.d(38): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ovdyiz4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164288
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int uniqueChars = 1;\n    string wordWithMaxChars = words[0];\n\
    \    for (int i = 1; i < words.length; i++)\n    {\n        int thisUniqueChars\
    \ = 0;\n        for (int j = 0; j < words[i].length(); j++)\n        {\n     \
    \       thisUniqueChars += words[i][j];\n        }\n        if (thisUniqueChars\
    \ > uniqueChars)\n        {\n            wordWithMaxChars = words[i];\n      \
    \      uniqueChars = thisUniqueChars;\n        }\n    }\n    return wordWithMaxChars;\n\
    }\n</cell>\n<text>\nExercise 15: Write a function to find the smallest number\
    \ in a list of numbers.\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3f420h_p.d(36): Error: declaration expected, not `<`

    /tmp/tmp3f420h_p.d(43): Error: declaration expected, not `assert`

    /tmp/tmp3f420h_p.d(44): Error: declaration expected, not `assert`

    /tmp/tmp3f420h_p.d(45): Error: declaration expected, not `assert`

    /tmp/tmp3f420h_p.d(46): Error: declaration expected, not `assert`

    /tmp/tmp3f420h_p.d(47): Error: declaration expected, not `assert`

    /tmp/tmp3f420h_p.d(48): Error: declaration expected, not `assert`

    /tmp/tmp3f420h_p.d(49): Error: declaration expected, not `assert`

    /tmp/tmp3f420h_p.d(50): Error: declaration expected, not `assert`

    /tmp/tmp3f420h_p.d(51): Error: declaration expected, not `assert`

    /tmp/tmp3f420h_p.d(52): Error: declaration expected, not `assert`

    /tmp/tmp3f420h_p.d(53): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3f420h_p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int counter = 1;\n    int maxCount = 0;\n    for (int i = 0;\
    \ i < words.length; i++) \n    {\n        int currentCount = counter;\n      \
    \  for (int j = 0; j < words[i].length(); j++) \n        {\n            counter++;\n\
    \            if (counter == currentCount) \n            {\n                currentCount\
    \ = 1;\n            }\n        }\n        if (maxCount < currentCount) \n    \
    \    {\n            maxCount = currentCount;\n        }\n    }\n    if (maxCount\
    \ == words.length) \n    {\n        return words[0];\n    }\n    if (maxCount\
    \ > words.length) \n    {\n        return words[words.length - 1];\n    }\n  \
    \  else \n    {\n        throw runtime_error(\"Error: No words found\");\n   \
    \ }\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa232ybhn.d(24): Error: no property `length` for type `string`

    /tmp/tmpa232ybhn.d(47): Error: undefined identifier `runtime_error`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa232ybhn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // Your code here\n    int max = 1;\n    string result = \"\"\
    ;\n    for (int i = 0; i < words.length; i++) {\n        if (words[i].length()\
    \ > max) {\n            max = words[i].length();\n            result = words[i];\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nHi there,\
    \ thanks for the solution! Can you explain the method a little bit? Like whats\
    \ going on in each line? What is the use of the max variable and how does it work?\
    \ Thanks\n<|/ c |>\n<| c |>\nHi there, sorry for the late reply. Thank you for\
    \ the solution, it makes sense to me now.\n<|/ c |>\n<| c |>\nI'm glad I was able\
    \ to help, please accept the answer. Thank you.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7tyz8u9z.d(30): Error: declaration expected, not `<`

    /tmp/tmp7tyz8u9z.d(39): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7tyz8u9z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result = \"\";\n    int count = 0;\n    foreach (string\
    \ word in words)\n    {\n        count += word.length();\n        if (count >\
    \ result.length())\n            result = word;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprmj5u_1z.d(21): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprmj5u_1z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int n = words.length;\n    int i, max = 0;\n    string maxWord\
    \ = words[0];\n    \n    for (i = 1; i < n; i++)\n    {\n        int count = 0;\n\
    \        for (j = 0; j < n; j++)\n        {\n            if (j != i && words[j].length()\
    \ > words[i].length())\n                continue;\n            if (words[j].length()\
    \ < words[i].length())\n            {\n                count ++;\n           \
    \ }\n        }\n        if (count > max)\n        {\n            max = count;\n\
    \            maxWord = words[i];\n        }\n    }\n    return maxWord;\n}\n</code>\n\
    <|/ a tags=algorithm,c++ |>\n<| c |>\nThis code is wrong, because it returns \"\
    string\" even though there are three \"string\" entries in the array.\n<|/ c |>\n\
    <| a tags=algorithm,c++ |>\nThis code will return \"string\" because there is\
    \ no entry in the array that is longer than \"string\".\nIt will also return \"\
    enam\" because there is an entry that is longer than \"enam\" in the array.\n\
    It will also return \"game\" because there is an entry that is longer than \"\
    game\" in the array.\nIt will also return \"string\" because there is an entry\
    \ that is longer than \"string\" in the array.\n<code>\n#include <iostream>\n\
    #include <algorithm>\nusing namespace std;\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw40x6jav.d(43): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw40x6jav.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint count = int();\n\t\n\tfor (int i = 0; i < words.length; ++i)\n\
    \t{\n\t\tfor (int j = i+1; j < words.length; ++j)\n\t\t{\n\t\t\tfor (int k = 0;\
    \ k < words[i].length; ++k)\n\t\t\t{\n\t\t\t\tif (words[i].chars[k] == words[j].chars[k])\n\
    \t\t\t\t{\n\t\t\t\t\tif (count < words[i].chars.length)\n\t\t\t\t\t\tcount = words[i].chars.length;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn *max<string> (words[count], words[count-1]);\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2cshc4gv.d(35): Error: found `>` when expecting `;` following `return`
    statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2cshc4gv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    var max;\n    for(int i =0; i < words.length; ++i)\n    {\n\
    \        max = i;\n        for(int j = i+1; j < words.length; ++j)\n        {\n\
    \            if(words[j].length() > words[max].length())\n            {\n    \
    \            max = j;\n            }\n        }\n        if(max != i)\n      \
    \  {\n            var temp = words[i];\n            words[i] = words[max];\n \
    \           words[max] = temp;\n        }\n    }\n    return words[words.length\
    \ - 1];\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprgs4i9dm.d(19): Error: undefined identifier `var`

    /tmp/tmprgs4i9dm.d(25): Error: no property `length` for type `string`

    /tmp/tmprgs4i9dm.d(32): Error: undefined identifier `var`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprgs4i9dm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> m;\n    for(int i=0; i<words.length; i++)\n\
    \    {\n        m[words[i]] = 1;\n    }\n    map<string, int>::iterator it;\n\
    \    for(int i=0; i<words.length; i++)\n    {\n        it = m.find(words[i]);\n\
    \        if(it != m.end())\n        {\n            if(it->second == 1)\n     \
    \       {\n                m[words[i]] = 2;\n            }\n            else\n\
    \            {\n                m[words[i]] ++;\n                if(m[words[i]]\
    \ > 1)\n                {\n                    return words[i];\n            \
    \    }\n            }\n        }\n    }\n    return words[0];\n}\n</code>\n<|/\
    \ a tags=algorithm,string,c++,arrays |>\n<| a dscore=1 tags=algorithm,string,c++,arrays\
    \ |>\nIf anyone is interested in C#, here's the solution I wrote for this, and\
    \ an explanation of how it works.\n<code>\npublic static string FindLongest(string\
    \ [] array)\n{\n    string longest = \"\";\n    int longestCount = 0;\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz2aolpj2.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmpz2aolpj2.d(24): Error: found `>` when expecting `.` following int

    /tmp/tmpz2aolpj2.d(24): Error: found `:` when expecting identifier following `int`.

    /tmp/tmpz2aolpj2.d(24): Error: found `:` when expecting `;` following statement

    /tmp/tmpz2aolpj2.d(30): Error: use `.` for member lookup, not `->`

    /tmp/tmpz2aolpj2.d(46): Error: declaration expected, not `<`

    /tmp/tmpz2aolpj2.d(49): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz2aolpj2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    bool hasDuplicates = false;\n    int counter = 1;\n    int max\
    \ = 1;\n    for(int i = 0; i < words.length; ++i)\n    {\n        int currentCounter\
    \ = 1;\n        for(int j = 0; j < words.length; ++j)\n        {\n           \
    \ if(words[i] == words[j])\n            {\n                hasDuplicates = true;\n\
    \                break;\n            }\n            else if(words[i].length()\
    \ > words[j].length())\n            {\n                currentCounter++;\n   \
    \         }\n            else if(words[i].length() < words[j].length())\n    \
    \        {\n                currentCounter--;\n            }\n        }\n    \
    \    if(currentCounter > counter)\n        {\n            counter = currentCounter;\n\
    \            max = i;\n        }\n    }\n    if(hasDuplicates)\n    {\n      \
    \  return words[max];\n    }\n    else\n    {\n        return words[max];\n  \
    \  }\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe question explicitly says that\
    \ the array will contain only unique strings, so `std::set` is irrelevant.\n<|/\
    \ c |>\n<| c |>\nI guess I misunderstood the question. I've corrected my answer.\
    \ Thanks!\n<|/ c |>\n<| c |>\nI think you understood it, but I didn't get it working\
    \ right now. Maybe I'm missing some fundamental knowledge.\n<|/ c |>\n<| c |>\n\
    Ok, now I see what is the problem. You cannot use a `while` loop because you need\
    \ to find out if the string has duplicates without actually visiting the whole\
    \ array. The solution would be to first find the duplicates and then to perform\
    \ the while loop on the duplicates.\n<|/ c |>\n<| c |>\nYou also need to check\
    \ if the number of characters of each string is greater than the maximum found\
    \ so far. If it is, you need to increase the counter.\n<|/ c |>\n<| a tags=algorithm,sorting,string,c++\
    \ dscore=0 |>\n<code>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp55x4rprd.d(56): Error: declaration expected, not `<`

    /tmp/tmp55x4rprd.d(62): Error: unterminated character constant

    /tmp/tmp55x4rprd.d(65): Error: unterminated character constant

    /tmp/tmp55x4rprd.d(65): Error: unterminated character constant

    /tmp/tmp55x4rprd.d(82): Error: declaration expected, not `assert`

    /tmp/tmp55x4rprd.d(83): Error: declaration expected, not `assert`

    /tmp/tmp55x4rprd.d(84): Error: declaration expected, not `assert`

    /tmp/tmp55x4rprd.d(85): Error: declaration expected, not `assert`

    /tmp/tmp55x4rprd.d(86): Error: declaration expected, not `assert`

    /tmp/tmp55x4rprd.d(87): Error: declaration expected, not `assert`

    /tmp/tmp55x4rprd.d(88): Error: declaration expected, not `assert`

    /tmp/tmp55x4rprd.d(89): Error: declaration expected, not `assert`

    /tmp/tmp55x4rprd.d(90): Error: declaration expected, not `assert`

    /tmp/tmp55x4rprd.d(91): Error: declaration expected, not `assert`

    /tmp/tmp55x4rprd.d(92): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp55x4rpr'
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int maxValue = 0;\n    string maxWord;\n    int maxCount = 1;\n\
    \    \n    for (int i = 0; i < words.length; i++)\n    {\n        int currentCount\
    \ = 0;\n        string currentWord = words[i];\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmnjmugkx.d(27): Error: found `unittest` instead of statement

    /tmp/tmpmnjmugkx.d(42): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmnjmugkx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int charCount[] = new int[words.length];\n    string returnWord\
    \ = \"\";\n    for(int i = 0; i < words.length; i++)\n    {\n        for(int j\
    \ = 0; j < words[i].length(); j++)\n        {\n            charCount[i]++;\n \
    \       }\n        if(charCount[i] > returnWord.length())\n        {\n       \
    \     returnWord = words[i];\n        }\n    }\n    return returnWord;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nNice.  I was thinking something similar to your first\
    \ one before reading your answer.  I like it.\n<|/ c |>\n<| a |>\n<code>\npublic\
    \ string findmax(string[] words)\n    {\n        string maxword=\"\";\n      \
    \  int maxcount=0;\n        foreach (string word in words)\n        {\n      \
    \      int count=0;\n            foreach (char c in word)\n            {\n   \
    \             if (word.Contains(c))\n                {\n                    count++;\n\
    \                }\n            }\n            if (count > maxcount)\n       \
    \     {\n                maxcount = count;\n                maxword = word;\n\
    \            }\n        }\n        return maxword;\n    }\n</code>\n<|/ a tags=c#\
    \ dscore=0 |>\n<| a tags=c# |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_rdokpx0.d(19): Deprecation: instead of C-style syntax, use D-style
    syntax `int[] charCount`

    /tmp/tmp_rdokpx0.d(34): Error: declaration expected, not `<`

    /tmp/tmp_rdokpx0.d(45): Error: declaration expected, not `foreach`

    /tmp/tmp_rdokpx0.d(48): Error: declaration expected, not `foreach`

    /tmp/tmp_rdokpx0.d(53): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_rdokpx0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint n = words.length;\n\tint m = words[0].length();\n\tint c =\
    \ 1;\n\tfor (int i = 1; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\
    \tif (std.typecons.compare(words[i], words[j]) <= 0)\n\t\t\t\tcontinue;\n\t\t\t\
    if (std.typecons.compare(words[j], words[i]) <= 0)\n\t\t\t\tbreak;\n\t\t\tif (std.math.abs(c\
    \ - std.typecons.charcount(words[i] + words[j]) - std.typecons.charcount(words[i]))\
    \ < std.math.abs(c - std.typecons.charcount(words[j] + words[i])))\n\t\t\t\tc\
    \ = std.typecons.charcount(words[i] + words[j]);\n\t\t}\n\t}\n\treturn words[std.math.abs(c\
    \ - std.typecons.charcount(words[n - 1] + words[n])) - 1];\n}\nunittest\n{\n \
    \   alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_4q2ojv6.d(19): Error: cannot implicitly convert expression `words.length`
    of type `ulong` to `int`

    /tmp/tmp_4q2ojv6.d(20): Error: no property `length` for type `string`

    /tmp/tmp_4q2ojv6.d(24): Error: undefined identifier `compare` in module `std.typecons`

    /tmp/tmp_4q2ojv6.d(26): Error: undefined identifier `compare` in module `std.typecons`

    /tmp/tmp_4q2ojv6.d(28): Error: undefined identifier `charcount` in module `std.typecons`

    /tmp/tmp_4q2ojv6.d(28): Error: undefined identifier `charcount` in module `std.typecons`

    /tmp/tmp_4q2ojv6.d(28): Error: undefined identifier `charcount` in module `std.typecons`

    /tmp/tmp_4q2ojv6.d(29): Error: undefined identifier `charcount` in module `std.typecons`

    /tmp/tmp_4q2ojv6.d(32): Error: undefined identifier `charcount` in module `std.typecons`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_4q2ojv6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tstring result = words[0];\n\tint count = 0;\n\tfor (int i = 1;\
    \ i < words.length; i++) \n\t{\n\t\tstring word = words[i];\n\t\tint n = 0;\n\t\
    \tfor (int j = 0; j < word.length(); j++) \n\t\t{\n\t\t\tchar c = word.charAt(j);\n\
    \t\t\tn = count[c] + n;\n\t\t}\n\t\tif (n > count[result])\n\t\t{\n\t\t\tresult\
    \ = word;\n\t\t\tcount[result] = n;\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnrapzocb.d(25): Error: no property `length` for type `string`

    /tmp/tmpnrapzocb.d(27): Error: no property `charAt` for type `string`

    /tmp/tmpnrapzocb.d(28): Error: only one index allowed to index `int`

    /tmp/tmpnrapzocb.d(30): Error: only one index allowed to index `int`

    /tmp/tmpnrapzocb.d(33): Error: only one index allowed to index `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnrapzocb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    int n = words.length;\n    string result =\
    \ \"\";\n    for (int i = 0; i<n; i++){\n        int x = std.string.length(words[i]);\n\
    \        if (x > max){\n            result = words[i];\n            max = x;\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nMy version for C++:\n<code>\n#include <string>\n#include <vector>\n#include\
    \ <algorithm>\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy8qc1an9.d(31): Error: declaration expected, not `<`

    /tmp/tmpy8qc1an9.d(43): Error: declaration expected, not `assert`

    /tmp/tmpy8qc1an9.d(44): Error: declaration expected, not `assert`

    /tmp/tmpy8qc1an9.d(45): Error: declaration expected, not `assert`

    /tmp/tmpy8qc1an9.d(46): Error: declaration expected, not `assert`

    /tmp/tmpy8qc1an9.d(47): Error: declaration expected, not `assert`

    /tmp/tmpy8qc1an9.d(48): Error: declaration expected, not `assert`

    /tmp/tmpy8qc1an9.d(49): Error: declaration expected, not `assert`

    /tmp/tmpy8qc1an9.d(50): Error: declaration expected, not `assert`

    /tmp/tmpy8qc1an9.d(51): Error: declaration expected, not `assert`

    /tmp/tmpy8qc1an9.d(52): Error: declaration expected, not `assert`

    /tmp/tmpy8qc1an9.d(53): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy8qc1an9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int maximum = 0;\n    int index = 0;\n    int maxIndex = 0;\n\
    \    for(int i = 0; i<words.length; i++)\n    {\n        int count = count_unique(words[i]);\n\
    \        if(count > maximum)\n        {\n            maximum = count;\n      \
    \      maxIndex = i;\n        }\n    }\n    \n    if(maxIndex < words.length-1)\n\
    \    {\n        string result = words[maxIndex];\n        for(int i = maxIndex+1;\
    \ i<words.length; i++)\n        {\n            int count = count_unique(words[i]);\n\
    \            if(count > maximum)\n            {\n                maximum = count;\n\
    \                result = words[i];\n            }\n        }\n        return\
    \ result;\n    }\n    return words[0];\n}\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2_fq215r.d(24): Error: undefined identifier `count_unique`

    /tmp/tmp2_fq215r.d(37): Error: undefined identifier `count_unique`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2_fq215r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    if(words.length == 0) {\n        throw new Exception(\"The array\
    \ cannot be empty\");\n    }\n    unordered_map<char, int> uniqueCount;\n    \n\
    \    for(int i=0; i < words.length; i++) \n    {\n        int count = 0;\n   \
    \     for(int j=0; j < words[i].length(); j++) \n        {\n            if(uniqueCount.containsKey(words[i][j]))\n\
    \            {\n                count++;\n            }\n            uniqueCount[words[i][j]]\
    \ = count;\n        }\n    }\n    \n    int maxCount = -1;\n    string maxWord\
    \ = \"\";\n    \n    foreach(auto word, uniqueCount)\n    {\n        if(uniqueCount.count(word)\
    \ > maxCount)\n        {\n            maxCount = uniqueCount.count(word);\n  \
    \          maxWord = word;\n        }\n    }\n    \n    return maxWord;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt67w3779.d(22): Error: found `,` when expecting `.` following char

    /tmp/tmpt67w3779.d(22): Error: found `int` when expecting identifier following
    `char`.

    /tmp/tmpt67w3779.d(22): Error: found `>` when expecting `;` following statement

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    if (words.length==0) {\n        return \"No word found.\";\n\
    \    }\n    map<string,int> counts;\n    for (string w : words) {\n        int\
    \ c = counts[w];\n        counts[w]=(c==0?1:c+1);\n    }\n    int max = -1;\n\
    \    string word = \"\";\n    for (map<string,int>::iterator it = counts.begin();it\
    \ != counts.end();it++) {\n        int c = it->second;\n        if (c>max) {\n\
    \            max = c;\n            word = it->first;\n        }\n    }\n    return\
    \ word;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=algorithm,string |>\n\
    My first approach would be to use a HashMap, keyed by characters, counting the\
    \ number of times a given character appears. Then use a second HashMap, keyed\
    \ by characters, to count the number of times a given character appears.\nThen\
    \ iterate over the two HashMaps, and compare the two counts and return the string\
    \ that has the higher count. This assumes that the input array is sorted.\n<|/\
    \ a |>\n<| c |>\nThis sounds interesting. But I'm not sure I understand how to\
    \ sort the HashMap by the number of times a character appears.\n<|/ c |>\n<| c\
    \ |>\nSort the keys of the second HashMap by decreasing count. Then iterate the\
    \ keys of the first HashMap and get the value for each key, and then use that\
    \ value as the count for the key in the second HashMap. Repeat until all of the\
    \ keys are processed.\n<|/ c |>\n<| c |>\nAnd what if there are multiple words\
    \ with same count (let's say for eg `a` appears twice)? The question asks for\
    \ which one to return in lexicographical order - how can we resolve this?\n<|/\
    \ c |>\n<| a dscore=1 |>\nMy solution is similar to the one given by \"Bill\"\
    . This one will also allow the user to select the desired output format and sort\
    \ by word's length, length or lexicographical order. \n<code>\nclass StringSort\
    \ {\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2i1diobe.d(22): Error: found `>` when expecting `.` following int

    /tmp/tmp2i1diobe.d(23): Error: found `w` when expecting `;` following statement

    /tmp/tmp2i1diobe.d(23): Error: expression expected, not `:`

    /tmp/tmp2i1diobe.d(23): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmp2i1diobe.d(29): Error: found `>` when expecting `.` following int

    /tmp/tmp2i1diobe.d(29): Error: found `:` when expecting identifier following `int`.

    /tmp/tmp2i1diobe.d(29): Error: found `:` when expecting `;` following statement

    /tmp/tmp2i1diobe.d(29): Error: found `it` when expecting `;` following `for` condition

    /tmp/tmp2i1diobe.d(29): Error: expression expected, not `=`

    /tmp/tmp2i1diobe.d(29): Error: found `counts` when expecting `)`

    /tmp/tmp2i1diobe.d(29): Error: found `)` when expecting `;` following statement

    /tmp/tmp2i1diobe.d(30): Error: use `.` for member lookup, not `->`

    /tmp/tmp2i1diobe.d(33): Error: use `.` for member lookup, not `->`

    /tmp/tmp2i1diobe.d(38): Error: declaration expected, not'
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint n = words.length;\n\t\n\tfor (int i = 0; i < n; ++i) \n\t\
    {\n\t\tstring word = words[i];\n\t\tint count = std::count(word.begin(), word.end(),\
    \ 'a');\n\t\tif (count > words[i].length())\n\t\t{\n\t\t\tint min = words[i].length();\n\
    \t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tif (std::count(words[j].begin(),\
    \ words[j].end(), 'a') <= min)\n\t\t\t\t{\n\t\t\t\t\tmin = std::count(words[j].begin(),\
    \ words[j].end(), 'a');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min > words[i].length())\n\
    \t\t\t{\n\t\t\t\treturn word;\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}\n/*\nWrite\
    \ a function that accepts an array of strings.\n    The array contains different\
    \ words. Return a list of all the words with\n    maximum number of unique characters.\
    \ If multiple strings have maximum number\n    of unique characters, return the\
    \ one which comes first in lexicographical order.\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvaja9ka_.d(24): Error: semicolon expected, not `:`

    /tmp/tmpvaja9ka_.d(24): Error: found `:` instead of statement

    /tmp/tmpvaja9ka_.d(30): Error: found `:` when expecting `)`

    /tmp/tmpvaja9ka_.d(30): Error: found `:` instead of statement

    /tmp/tmpvaja9ka_.d(41): Error: declaration expected, not `return`

    /tmp/tmpvaja9ka_.d(42): Error: unrecognized declaration

    /tmp/tmpvaja9ka_.d(43): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvaja9ka_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    unordered_map<char, int> m;\n    for (auto w : words) {\n  \
    \      for (int i = 0; i < w; ++i) m[w[i]]++;\n    }\n    \n    for (auto it :\
    \ m) \n        if (it.second > 1) return it.first;\n    return words[0];\n}\n\
    </code>\n<|/ a tags=string,c++,max dscore=0 |>\n<| a dscore=0 |>\n<code>\n#include\
    \ <iostream>\n#include <algorithm>\n#include <unordered_map>\nunittest\n{\n  \
    \  alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzybutqpy.d(19): Error: found `,` when expecting `.` following char

    /tmp/tmpzybutqpy.d(19): Error: found `int` when expecting identifier following
    `char`.

    /tmp/tmpzybutqpy.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmpzybutqpy.d(20): Error: no identifier for declarator `w`

    /tmp/tmpzybutqpy.d(20): Error: expression expected, not `:`

    /tmp/tmpzybutqpy.d(20): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmpzybutqpy.d(24): Error: no identifier for declarator `it`

    /tmp/tmpzybutqpy.d(24): Error: expression expected, not `:`

    /tmp/tmpzybutqpy.d(24): Error: found `m` when expecting `;` following `for` condition

    /tmp/tmpzybutqpy.d(28): Error: declaration expected, not `<`

    /tmp/tmpzybutqpy.d(39): Error: declaration expected, not `assert`

    /tmp/tmpzybutqpy.d(40): Error: declaration expected, not `assert`

    /tmp/tmpzybutqpy.d(41): Error: declaration expected, not `assert`

    /tmp/tmpzybutqpy.d(42): Error: declaration expected, not `assert`

    /tmp/tmpzybutqpy.d(43): Error: d'
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> m;\n    map<string, int>::iterator mi;\n  \
    \  int max = 0, index = 0;\n    for(int i = 0; i < words.length; ++i)\n    {\n\
    \        m[words[i]] = m[words[i]] ? m[words[i]] : 0;\n        ++m[words[i]];\n\
    \        if(m[words[i]] > max)\n        {\n            max = m[words[i]];\n  \
    \          index = i;\n        }\n    }\n    return words[index];\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt4lsrz5b.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmpt4lsrz5b.d(20): Error: found `>` when expecting `.` following int

    /tmp/tmpt4lsrz5b.d(20): Error: found `:` when expecting identifier following `int`.

    /tmp/tmpt4lsrz5b.d(20): Error: found `:` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt4lsrz5b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    unordered_map<string,int> m;\n    for (int i = 0; i < words.length;\
    \ i++) {\n        if (m.count(words[i])<1) {\n            m[words[i]]=1;\n   \
    \     } else {\n            if (m[words[i]]<m[words[i-1]]+1) {\n             \
    \   m[words[i]]=m[words[i-1]]+1;\n            } else {\n                m[words[i]]=m[words[i-1]];\n\
    \            }\n        }\n    }\n    string maxKey;\n    int maxCount=0;\n  \
    \  for (auto it=m.begin();it!=m.end();it++) {\n        if (it->second>maxCount)\
    \ {\n            maxCount=it->second;\n            maxKey=it->first;\n       \
    \ }\n    }\n    return maxKey;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm\
    \ dscore=0 |>\nHere is a simple solution in java using the stream API:\n<code>\n\
    public static String maxStringWithSameMaxChars(String[] strings) {\n    return\
    \ strings\n            .stream()\n            .max(Comparator.comparingInt(s ->\
    \ s.length()))\n            .orElseThrow(RuntimeException::new);\n}\n</code>\n\
    This uses the maximum element of the stream as the key for a HashMap to store\
    \ the counts of characters. Then it returns the key if the maximum count equals\
    \ the number of elements, or throws an exception if there is no maximum element.\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>\npackage com.company;\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmwece6tu.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmpmwece6tu.d(34): Error: use `.` for member lookup, not `->`

    /tmp/tmpmwece6tu.d(35): Error: use `.` for member lookup, not `->`

    /tmp/tmpmwece6tu.d(36): Error: use `.` for member lookup, not `->`

    /tmp/tmpmwece6tu.d(41): Error: declaration expected, not `<`

    /tmp/tmpmwece6tu.d(51): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmwece6tu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int len = words.length;\n    int max = 0; \n    string word\
    \ = \"\";\n    for(int i = 0; i < len; ++i)\n    {\n        word += words[i];\n\
    \        int count = 1;\n        for(int j = i + 1; j < len; ++j)\n        {\n\
    \            word += \" \" + words[j];\n            int c = count(word);\n   \
    \         if(c > count)\n            {\n                count = c;\n         \
    \       word = words[j];\n            }\n        }\n        if(max < count)\n\
    \        {\n            max = count;\n            word = words[i];\n        }\n\
    \    }\n    return word;\n}\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwxrjwa6t.d(19): Error: cannot implicitly convert expression `words.length`
    of type `ulong` to `int`

    /tmp/tmpwxrjwa6t.d(24): Error: slice `word` is not mutable

    /tmp/tmpwxrjwa6t.d(28): Error: invalid array operation `" " + words[cast(ulong)j]`
    (possible missing [])

    /tmp/tmpwxrjwa6t.d(29): Error: function expected before `()`, not `count` of type
    `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwxrjwa6t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    int count = 0;\n    int min = std::numeric_limits<int>::max();\n\
    \    for(int i = 0; i < words.length; ++i) {\n        string word = words[i];\n\
    \        int c = std::count_if(word.begin(), word.end(), [](char ch) {return !ch;\
    \ });\n        max = std::max(max, c);\n        count += c;\n        min = std::min(min,\
    \ c);\n    }\n    if(count > max) {\n        return words[std::count_if(words.begin(),\
    \ words.end(), [](string word) {return std::count_if(word.begin(), word.end(),\
    \ [](char ch) {return !ch; }) == max; }) - 1];\n    } else {\n        return words[std::count_if(words.begin(),\
    \ words.end(), [](string word) {return std::count_if(word.begin(), word.end(),\
    \ [](char ch) {return !ch; }) == count; }) - 1];\n    }\n}\n</code>\n<|/ a tags=c++\
    \ |>\n<| c |>\nYou should probably explain why your code is different than the\
    \ OP's code, and why it is better/faster. Especially for a beginner, it would\
    \ be a good idea to show how you think the original code should look.\n<|/ c |>\n\
    <| c |>\nI have added explanation to my answer. Thanks.\n<|/ c |>\n<| c |>\nOh\
    \ thanks a lot! I didn't know that about std::count_if. Also, I'm actually new\
    \ to C++, it's been a while since I've coded in any other language. I'm not used\
    \ to using libraries such as std.\n<|/ c |>\n<| c |>\n, If you find this answer\
    \ helpful, you can upvote it. Thanks.\n<|/ c |>\n<| c |>\n: This code is not correct.\
    \ `std::count_if` stops searching when it finds the first match. It does not count\
    \ the matches themselves.\n<|/ c |>\n<| a tags=c++ dscore=0 |>\nThis is my code\
    \ based on yours. I just changed the loop that you wrote to make it work.\n<code>\n\
    string find_max(string* words) {\n    int max = 0;\n    int count = 0;\n    int\
    \ min = std::numeric_limits<int>::max();\n    for(int i = 0; i < words.length;\
    \ ++i) {\n        int c = std::count_if(words[i].begin(), words[i].end(), [](char\
    \ ch) {return !ch; });\n        max = std::max(max, c);\n        count += c;\n\
    \        min = std::min(min, c);\n    }\n    if(count > max) {\n        return\
    \ words[std::count_if(words.begin(), words.end(), [](string word) {return std::count_if(word.begin(),\
    \ word.end(), [](char ch) {return !ch\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjsahydmx.d(21): Error: semicolon expected, not `:`

    /tmp/tmpjsahydmx.d(21): Error: found `:` instead of statement

    /tmp/tmpjsahydmx.d(24): Error: semicolon expected, not `:`

    /tmp/tmpjsahydmx.d(24): Error: found `:` instead of statement

    /tmp/tmpjsahydmx.d(24): Error: found `)` instead of statement

    /tmp/tmpjsahydmx.d(25): Error: found `:` when expecting `;` following statement

    /tmp/tmpjsahydmx.d(25): Error: found `:` instead of statement

    /tmp/tmpjsahydmx.d(27): Error: found `:` when expecting `;` following statement

    /tmp/tmpjsahydmx.d(27): Error: found `:` instead of statement

    /tmp/tmpjsahydmx.d(29): Error: declaration expected, not `if`

    /tmp/tmpjsahydmx.d(30): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjsahydmx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint res = 0;\n\tint len = words.length;\n\tint ans = 0;\n\tfor\
    \ (int i = 0; i < len; i++)\n\t{\n\t\tint count = 1;\n\t\tfor (int j = i+1; j\
    \ < len; j++)\n\t\t\tif (words[i].count(words[j])) count++;\n\t\tif (count > res)\n\
    \t\t{\n\t\t\tres = count;\n\t\t\tans = i;\n\t\t}\n\t}\n\treturn words[ans];\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0keppxcj.d(20): Error: cannot implicitly convert expression `words.length`
    of type `ulong` to `int`

    /tmp/tmp0keppxcj.d(26): Error: no property `count` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0keppxcj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    bool ismax = false;\n    int max_char = 0;\n    string maxname\
    \ = \"\";\n    for (int i = 0; i < words.length; i++){\n        for(int j = 0;\
    \ j < words[i].length(); j++){\n            if(words[i].length() > max_char){\n\
    \                max_char = words[i].length();\n                ismax = true;\n\
    \            }\n            if(words[i].length() == max_char && !ismax){\n   \
    \             ismax = true;\n                maxname = words[i];\n           \
    \ }\n            else if(words[i].length() == max_char && ismax){\n          \
    \      break;\n            }\n        }\n    }\n    return maxname;\n}\n</code>\n\
    <|/ a tags=algorithm,sorting |>\n<| c |>\nWhile this code may answer the question,\
    \ providing additional context regarding how and/or why it solves the problem\
    \ would improve the answer's long-term value.\n<|/ c |>\n<| a dscore=2 |>\nThe\
    \ most efficient and clear solution would be to implement merge sort using C++'s\
    \ STL containers. The complexity would be O(n log n) and you get an O(n) solution.\n\
    <|/ a tags=algorithm,sorting |>\n<| a tags=algorithm,sorting |>\n<code>\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo0dz3t3_.d(39): Error: declaration expected, not `<`

    /tmp/tmpo0dz3t3_.d(42): Error: unterminated character constant

    /tmp/tmpo0dz3t3_.d(45): Error: unterminated character constant

    /tmp/tmpo0dz3t3_.d(53): Error: declaration expected, not `assert`

    /tmp/tmpo0dz3t3_.d(54): Error: declaration expected, not `assert`

    /tmp/tmpo0dz3t3_.d(55): Error: declaration expected, not `assert`

    /tmp/tmpo0dz3t3_.d(56): Error: declaration expected, not `assert`

    /tmp/tmpo0dz3t3_.d(57): Error: declaration expected, not `assert`

    /tmp/tmpo0dz3t3_.d(58): Error: declaration expected, not `assert`

    /tmp/tmpo0dz3t3_.d(59): Error: declaration expected, not `assert`

    /tmp/tmpo0dz3t3_.d(60): Error: declaration expected, not `assert`

    /tmp/tmpo0dz3t3_.d(61): Error: declaration expected, not `assert`

    /tmp/tmpo0dz3t3_.d(62): Error: declaration expected, not `assert`

    /tmp/tmpo0dz3t3_.d(63): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo0dz3t3_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    return find_max(words.map<int, int>(tolower));\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6a03d6ac.d(19): Error: found `,` when expecting `.` following int

    /tmp/tmp6a03d6ac.d(19): Error: found `int` when expecting identifier following
    `int`.

    /tmp/tmp6a03d6ac.d(19): Error: found `>` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6a03d6ac.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int[] count = new int[65536];\n    for(int i = 0;i < words.length;++i)\n\
    \    {\n        count[words[i].length()]++;\n    }\n    int max = count[0];\n\
    \    int idx = 0;\n    for(;;)\n    {\n        if(count[max] != 0) break;\n  \
    \      idx++;\n        if(idx == max.bit_length()) \n        {\n            return\
    \ max.to_string() + \"a\";\n        }\n        max = (max << 1) | idx;\n    }\n\
    \    char res = max.to_string() + 'a';\n    for(;;)\n    {\n        while(idx\
    \ < max.bit_length())\n        {\n            if(count[idx] == 0) break;\n   \
    \         idx++;\n        }\n        char c = max.to_string() + 'a' - idx;\n \
    \       if(c != res) return res;\n        max = (max << 1) | idx;\n    }\n}\n\
    </code>\n<|/ a tags=algorithm,string,c,sorting dscore=0 |>\n<| c |>\nCan you please\
    \ explain what do you mean by \"lexicographical order\"?\n<|/ c |>\n<| c |>\n\
    This isn't a good solution, because you're creating a new array every time you\
    \ run the program.\n<|/ c |>\n<| c |>\nI guess he meant \"sort by alphabet\"\n\
    <|/ c |>\n<| c |>\nNo. Lexicographical order means the order in which you type\
    \ the alphabetic letters, as opposed to \"alphabetic order\" which means \"alphabetic\
    \ order\" as we normally think of it.\n<|/ c |>\n<| c |>\n: I suppose this solution\
    \ only works in one way. Let's say you have \"aaaaaaa\" and \"ab\", the \"a\"\
    \ will come first since it comes first in the alphabet, if you look at the \"\
    ab\" it will come second since it comes second in alphabet but since it's lexicographically\
    \ after \"aaaaa\" it comes first in the lexicographical order\n<|/ c |>\n<| a\
    \ |>\n<code>\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsrn0ukls.d(49): Error: declaration expected, not `<`

    /tmp/tmpsrn0ukls.d(55): Error: unterminated character constant

    /tmp/tmpsrn0ukls.d(55): Error: unterminated character constant

    /tmp/tmpsrn0ukls.d(64): Error: unterminated character constant

    /tmp/tmpsrn0ukls.d(64): Error: unterminated character constant

    /tmp/tmpsrn0ukls.d(72): Error: declaration expected, not `assert`

    /tmp/tmpsrn0ukls.d(73): Error: declaration expected, not `assert`

    /tmp/tmpsrn0ukls.d(74): Error: declaration expected, not `assert`

    /tmp/tmpsrn0ukls.d(75): Error: declaration expected, not `assert`

    /tmp/tmpsrn0ukls.d(76): Error: declaration expected, not `assert`

    /tmp/tmpsrn0ukls.d(77): Error: declaration expected, not `assert`

    /tmp/tmpsrn0ukls.d(78): Error: declaration expected, not `assert`

    /tmp/tmpsrn0ukls.d(79): Error: declaration expected, not `assert`

    /tmp/tmpsrn0ukls.d(80): Error: declaration expected, not `assert`

    /tmp/tmpsrn0ukls.d(81): Error: declaration expected, not `assert`

    /tmp/tmpsrn0ukls.d(82): Error: unrecognized declara'
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint count = 0;\n\tstring max = \"\";\n\tforeach(string word in\
    \ words)\n\t{\n\t\tforeach(int c in word)\n\t\t{\n\t\t\tif (count[c] == 0)\n\t\
    \t\t{\n\t\t\t\tcount[c] = 1;\n\t\t\t\tmax = c;\n\t\t\t}\n\t\t}\n\t}\n\tforeach(int\
    \ c in count)\n\t{\n\t\tif (count[c] > 1)\n\t\t{\n\t\t\tmax = \"\";\n\t\t\tforeach(int\
    \ c2 in count)\n\t\t\t{\n\t\t\t\tif (c2 > 1)\n\t\t\t\t{\n\t\t\t\t\tif (c2 == count[c2])\n\
    \t\t\t\t\t{\n\t\t\t\t\t\tforeach(string word2 in words)\n\t\t\t\t\t\t{\n\t\t\t\
    \t\t\t\tif (word2[c] == max)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmax = word2;\n\t\
    \t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn max;\n}\n/*\nWrite a function that accepts an array\
    \ of strings and returns a boolean value\n\tthat indicates whether all strings\
    \ in the array have the same number\n\tof unique characters.\nunittest\n{\n  \
    \  alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_bku4qmw.d(21): Error: found `in` when expecting `;`

    /tmp/tmp_bku4qmw.d(23): Error: found `in` when expecting `;`

    /tmp/tmp_bku4qmw.d(32): Error: found `in` when expecting `;`

    /tmp/tmp_bku4qmw.d(37): Error: found `in` when expecting `;`

    /tmp/tmp_bku4qmw.d(43): Error: found `in` when expecting `;`

    /tmp/tmp_bku4qmw.d(58): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_bku4qmw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max=1;\n    string most = words[0];\n    for(int i = 1;\
    \ i < words.length; i++)\n    {\n        for(int j = 0; j < most.length; j++)\n\
    \        {\n            if(words[i].length() > most.length)\n            {\n \
    \               most = words[i];\n                max = i;\n            }\n  \
    \          else if(words[i].length() == most.length)\n            {\n        \
    \        if(words[i].compare(most) < words[max].compare(most))\n             \
    \   {\n                    most = words[i];\n                    max = i;\n  \
    \              }\n            }\n        }\n    }\n    return most;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjxka9fxn.d(25): Error: no property `length` for type `string`

    /tmp/tmpjxka9fxn.d(30): Error: no property `length` for type `string`

    /tmp/tmpjxka9fxn.d(32): Error: no property `compare` for type `string`

    /tmp/tmpjxka9fxn.d(32): Error: no property `compare` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjxka9fxn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> map;\n    for (int i=0; i<words.length; i++)\n\
    \        map[words[i]] = map[words[i]] ? map[words[i]]+1 : 1;\n    map<string,\
    \ int>::iterator iter;\n    for (iter = map.begin(); iter != map.end(); ++iter)\n\
    \    {\n        int count = iter->second;\n        if (count > 1)\n          \
    \  return iter->first;\n    }\n    return \"no match\";\n}\n</code>\n<|/ a |>\n\
    <| a tags=string,c#,algorithm |>\nThis is in C#. As suggested by other folks,\
    \ you can use the string class methods, but it would be easier to do so using\
    \ some LINQ. This should work:\n<code>\nstatic string FindMax(string[] words)\n\
    {\n    return words.Max(x => x.Length).OrderByDescending(x => x).First();\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis will throw a `NullReferenceException`\
    \ if `words` is null.\n<|/ c |>\n<| c |>\nGood catch, I didn't notice he was passing\
    \ an empty string. I'll edit my answer with a more complete solution.\n<|/ c |>\n\
    <| a tags=string,c#,algorithm |>\nI would use something like this (this doesn't\
    \ use LINQ):\n<code>\npublic class WordCount\n{\n    public string Word { get;\
    \ private set; }\n    public int Count { get; private set; }\nunittest\n{\n  \
    \  alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps7aw9qiy.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmps7aw9qiy.d(22): Error: found `>` when expecting `.` following int

    /tmp/tmps7aw9qiy.d(22): Error: found `:` when expecting identifier following `int`.

    /tmp/tmps7aw9qiy.d(22): Error: found `:` when expecting `;` following statement

    /tmp/tmps7aw9qiy.d(25): Error: use `.` for member lookup, not `->`

    /tmp/tmps7aw9qiy.d(27): Error: use `.` for member lookup, not `->`

    /tmp/tmps7aw9qiy.d(31): Error: declaration expected, not `<`

    /tmp/tmps7aw9qiy.d(39): Error: unrecognized declaration

    /tmp/tmps7aw9qiy.d(46): Error: unterminated character constant

    /tmp/tmps7aw9qiy.d(46): Error: unterminated character constant

    /tmp/tmps7aw9qiy.d(49): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps7aw9qiy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    sort(words);\n    int max = words[0].length();\n    for(int\
    \ i=1; i<words.length; i++)\n    {\n        if(words[i].length() > max)\n    \
    \    {\n            max = words[i].length();\n        }\n    }\n    return words[words.length-1];\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmawt6g3z.d(19): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpmawt6g3z.d(20): Error: no property `length` for type `string`

    /tmp/tmpmawt6g3z.d(23): Error: no property `length` for type `string`

    /tmp/tmpmawt6g3z.d(25): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmawt6g3z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    //write your code here\n    int count=0;\n    int maxCharCount=0;\n\
    \    for(int i=0;i<words.length;i++){\n        if(words[i].length()>maxCharCount){\n\
    \            maxCharCount=words[i].length();\n        }\n        for(int j=0;j<words[i].length();j++){\n\
    \            if(words[i].at(j)!=words[i].at(j)){\n                count++;\n \
    \           }\n        }\n        if(count>maxCharCount){\n            string\
    \ temp=words[i];\n            words[i]=words[words[i].length-1];\n           \
    \ words[words[i].length-1]=temp;\n        }\n        count=0;\n    }\n    return\
    \ words[words.length-1];\n}\n</code>\n<|/ a |>\n<| a |>\nI modified the code and\
    \ added a function that returns the max string of the list without duplicates\n\
    <code>\nstring find_max(string[] words)\n{\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpojas2y1_.d(40): Error: declaration expected, not `<`

    /tmp/tmpojas2y1_.d(51): Error: declaration expected, not `assert`

    /tmp/tmpojas2y1_.d(52): Error: declaration expected, not `assert`

    /tmp/tmpojas2y1_.d(53): Error: declaration expected, not `assert`

    /tmp/tmpojas2y1_.d(54): Error: declaration expected, not `assert`

    /tmp/tmpojas2y1_.d(55): Error: declaration expected, not `assert`

    /tmp/tmpojas2y1_.d(56): Error: declaration expected, not `assert`

    /tmp/tmpojas2y1_.d(57): Error: declaration expected, not `assert`

    /tmp/tmpojas2y1_.d(58): Error: declaration expected, not `assert`

    /tmp/tmpojas2y1_.d(59): Error: declaration expected, not `assert`

    /tmp/tmpojas2y1_.d(60): Error: declaration expected, not `assert`

    /tmp/tmpojas2y1_.d(61): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpojas2y1_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  // code here\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1pal94c8.d(17): Error: function `tmp1pal94c8.find_max` has no `return`
    statement, but is expected to return a value of type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1pal94c8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    var maxCount:int = 0;\n    var maxWord:string;\n    foreach\
    \ (var word in words)\n    {\n        var numChars = word.length;\n        if\
    \ (numChars > maxCount) {\n            maxCount = numChars;\n            maxWord\
    \ = word;\n        }\n    }\n    return maxWord;\n}\n</code>\n<|/ a |>\n<| a tags=c#,algorithm\
    \ |>\nThis answer applies to the question title - which is ambiguous. \nIn reality\
    \ the question is about returning a string with max length, not necessarily the\
    \ strings with most occurrences.\nIn that case the answer by is correct, but here\
    \ is the C# version. \nThe code is based on Knuth's algorithm for counting sort\
    \ (http://en.wikipedia.org/wiki/Counting_sort)\nIt makes use of the StringBuilder\
    \ (http://msdn.microsoft.com/en-us/library/system.text.stringbuilder.aspx) which\
    \ should be more efficient when concatenating long strings.\n<code>\npublic string\
    \ GetLongestString(string[] array)\n{\n    var maxLength = 0;\n    var maxWord\
    \ = \"\";\n    StringBuilder builder = new StringBuilder();\n    foreach (var\
    \ item in array)\n    {\n        builder.Append(item);\n        var length = builder.Length;\n\
    \        if (length > maxLength)\n        {\n            maxLength = length;\n\
    \            maxWord = builder.ToString();\n        }\n    }\n    return maxWord;\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| a dscore=4 tags=c#,algorithm |>\nHere's an example\
    \ of using LINQ to solve this:\n<code>\npublic string GetLongestString(string[]\
    \ array)\n{\n    return array.GroupBy(s => s)\n                .OrderByDescending(s\
    \ => s.Count())\n                .First()\n                .Key;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=4 tags=c#,algorithm |>\n<code>\npublic string GetLongestString(string[]\
    \ array)\n{\n    StringBuilder sb = new StringBuilder();\n    foreach (string\
    \ str in array)\n    {\n        int count = 0;\n        foreach (char c in str)\n\
    \        {\n            if (c == '-') count = count + 1;\n        }\n        if\
    \ (count > sb.Length)\n        {\n            sb.Append(str);\n        }\n   \
    \ }\n    return sb.ToString();\n}\n</code>\n<|/ a |>\n<| c |>\nI wonder how that\
    \ performs compared to the accepted answer. Would you mind telling us which one\
    \ performs better?\n<|/ c |>\n<| c |>\n, i think this is O(n) algorithm and accepted\
    \ answer is O(n^2).\n<|/ c |>\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprjy3c0co.d(19): Error: found `maxCount` when expecting `;` following
    statement

    /tmp/tmprjy3c0co.d(19): Error: found `:` instead of statement

    /tmp/tmprjy3c0co.d(20): Error: found `maxWord` when expecting `;` following statement

    /tmp/tmprjy3c0co.d(20): Error: found `:` instead of statement

    /tmp/tmprjy3c0co.d(21): Error: found `in` when expecting `;`

    /tmp/tmprjy3c0co.d(31): Error: declaration expected, not `<`

    /tmp/tmprjy3c0co.d(37): Error: unterminated character constant

    /tmp/tmprjy3c0co.d(45): Error: declaration expected, not `foreach`

    /tmp/tmprjy3c0co.d(49): Error: declaration expected, not `if`

    /tmp/tmprjy3c0co.d(52): Error: no identifier for declarator `maxWord`

    /tmp/tmprjy3c0co.d(52): Error: declaration expected, not `=`

    /tmp/tmprjy3c0co.d(53): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprjy3c0co.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int unique_count = unordered_set<int>().size();\n    foreach\
    \ (string word in words)\n    {\n        int count = unordered_set<char>().count();\n\
    \        if (unique_count < count)\n            unique_count = count;\n    }\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf4anfwlz.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmpf4anfwlz.d(19): Error: found `(` when expecting identifier following `int`.

    /tmp/tmpf4anfwlz.d(19): Error: semicolon expected, not `)`

    /tmp/tmpf4anfwlz.d(19): Error: found `)` instead of statement

    /tmp/tmpf4anfwlz.d(20): Error: found `in` when expecting `;`

    /tmp/tmpf4anfwlz.d(22): Error: found `>` when expecting `.` following char

    /tmp/tmpf4anfwlz.d(22): Error: found `(` when expecting identifier following `char`.

    /tmp/tmpf4anfwlz.d(22): Error: semicolon expected, not `)`

    /tmp/tmpf4anfwlz.d(22): Error: found `)` instead of statement

    /tmp/tmpf4anfwlz.d(26): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf4anfwlz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\t/*\n\t1. Sort the array in lexicographical order\n\t2. Find the\
    \ first element which contains maximum count of unique characters\n\t3. Return\
    \ the word which has minimum unique characters and lexicographical order\n\t*/\n\
    \tsort(words);\n\tint index = 0;\n\tstring word;\n\tint max_count = 0, min_count\
    \ = 0, max_index = -1;\n\tint unique_count = 0;\n\t\n\tfor(int i = 0; i < words.length;\
    \ i++){\n\t\tword = words[i];\n\t\tunique_count = 0;\n\t\tfor (int j = 0; j <\
    \ word.length(); j++){\n\t\t\tunique_count = unique_count + std.string.length(words[j]);\n\
    \t\t}\n\t\tif (max_count == unique_count){\n\t\t\tmax_count = unique_count;\n\t\
    \t\tmax_index = index;\n\t\t}\n\t\tif (unique_count < min_count){\n\t\t\tmin_count\
    \ = unique_count;\n\t\t\tindex = i;\n\t\t}\n\t\tunique_count = 0;\n\t}\n\treturn\
    \ words[max_index];\n}\n/*\nWrite a function that accepts an array of strings.\n\
    \    The array contains different words. Return the word with minimum number\n\
    \    of unique characters. If multiple strings have minimum number of unique\n\
    \    characters, return the one which comes first in lexicographical order.\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphlsvwk4q.d(48): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphlsvwk4q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    sort(words);\n    int max = 1;\n    int min = words[0].length();\n\
    \    \n    for (int i = 0; i < words.length; ++i) {\n        if (words[i].length()\
    \ > max) {\n            max = words[i].length();\n        }\n    }\n    for (int\
    \ i = 0; i < words.length; ++i) {\n        if (words[i].length() == max) {\n \
    \           if (words[i].compare(words[max-1]) >= 0) {\n                return\
    \ words[i];\n            }\n        }\n    }\n    return words[0];\n}\n/*\nWrite\
    \ a function that accepts an array of strings.\n    The array contains different\
    \ words. Return all the words with maximum number\n    of unique characters. If\
    \ multiple strings have maximum number of unique\n    characters, return the one\
    \ which comes first in lexicographical order.\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6iv0jb_r.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6iv0jb_r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  \n    struct {\n        map<int, int> m;\n        map<int, int>\
    \ m1;\n    }m={{0, 0}, {0,0}};\n    int maxCount=0;\n    foreach(string word,\
    \ words) {\n        int count=0;\n        foreach(char letter, word) {\n     \
    \       int count=m.m[letter]++ ;\n            int count1=m.m1[letter]++ ;\n \
    \           m.m[letter]=count1;\n            m.m1[letter]=count;\n        }\n\
    \        if(maxCount<count){\n            foreach(char letter, word) {\n     \
    \           m.m[letter]=0;\n                m.m1[letter]=0;\n            }\n \
    \           maxCount=count;\n        }\n    }\n    \n    foreach(string word,\
    \ words) {\n        int count=0;\n        foreach(char letter, word) {\n     \
    \       int count=m.m[letter]++ ;\n            int count1=m.m1[letter]++ ;\n \
    \           m.m[letter]=count1;\n            m.m1[letter]=count;\n        }\n\
    \        if(maxCount==count){\n            if(count<word.length()) {\n       \
    \         return word;\n            }\n        }\n    }\n    return words[0];\n\
    }\n</code>\n<|/ a dscore=1 tags=algorithm,string,c++,std |>\n<| c |>\nYou don't\
    \ need to store the result as a map; if you use `std::unordered_map` the algorithm\
    \ runs in O(N) time.\n<|/ c |>\n<| c |>\nI used map because I am thinking about\
    \ implementing the same algorithm using hashmap\n<|/ c |>\n<| c |>\n`std::unordered_map`\
    \ runs in `O(1)` time (`O(N)` if the hash table is implemented with a hash table\
    \ :-)\n<|/ c |>\n<| c |>\n`unordered_map` may get you `O(N)` performance depending\
    \ on the implementation, though.\n<|/ c |>\n<| c |>\nNo, I mean that the whole\
    \ algorithm runs in `O(N)` if the hash table is implemented with a hash table\
    \ :-) But yes, it may be less efficient than a normal hash table.\n<|/ c |>\n\
    <| a dscore=1 |>\nMy simple solution: use std::map with custom comparator\n<code>\n\
    #include <iostream>\n#include <algorithm>\n#include <cctype>\n#include <string>\n\
    #include <map>\n#include <numeric>\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_tmxtfdu.d(21): Error: no identifier for declarator `map`

    /tmp/tmp_tmxtfdu.d(21): Error: declaration expected, not `<`

    /tmp/tmp_tmxtfdu.d(22): Error: no identifier for declarator `map`

    /tmp/tmp_tmxtfdu.d(22): Error: declaration expected, not `<`

    /tmp/tmp_tmxtfdu.d(23): Error: found `}` when expecting `;` following statement

    /tmp/tmp_tmxtfdu.d(23): Error: found `,` instead of statement

    /tmp/tmp_tmxtfdu.d(25): Error: no identifier for declarator `words`

    /tmp/tmp_tmxtfdu.d(25): Error: found `)` when expecting `;`

    /tmp/tmp_tmxtfdu.d(27): Error: no identifier for declarator `word`

    /tmp/tmp_tmxtfdu.d(27): Error: found `)` when expecting `;`

    /tmp/tmp_tmxtfdu.d(33): Error: found `if` when expecting `)`

    /tmp/tmp_tmxtfdu.d(33): Error: found `<` when expecting `)`

    /tmp/tmp_tmxtfdu.d(33): Error: missing `{ ... }` for function literal

    /tmp/tmp_tmxtfdu.d(33): Error: found `count` when expecting `;` following statement

    /tmp/tmp_tmxtfdu.d(33): Error: found `)` instead of statement

    /tmp/tmp_tmxtfdu.d(38): Error: found'
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int maxIndex = -1;\n    int maxNum = 0;\n    int curNum = 0;\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv35mq667.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv35mq667.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    unordered_map<char, int> m;\n    for(int i=0; i<words.length();\
    \ i++) {\n        m[words[i]]++;\n    }\n    sort(words.begin(), words.end(),\
    \ compare);\n    int best = 0;\n    for(int i=0; i<words.length(); i++) {\n  \
    \      m[words[i]]--;\n        if(m[words[i]] > best) {\n            best = m[words[i]];\n\
    \        }\n    }\n    return words[best];\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdk5p57sc.d(19): Error: found `,` when expecting `.` following char

    /tmp/tmpdk5p57sc.d(19): Error: found `int` when expecting identifier following
    `char`.

    /tmp/tmpdk5p57sc.d(19): Error: found `>` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdk5p57sc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint unique = 0;\n\tstring max = words[0];\n\tfor (int i=1; i<words.length;\
    \ i++) \n\t{\n\t\tint count = 0;\n\t\tfor (int j=0; j<words[i].length(); j++)\
    \ \n\t\t{\n\t\t\tif (words[i][j] == 'a' || words[i][j] == 'e' || words[i][j] ==\
    \ 'i' ||\n\t\t\t\twords[i][j] == 'o' || words[i][j] == 'u' || words[i][j] == 'Y')\n\
    \t\t\t\tcount++;\n\t\t}\n\t\tif (count>unique)\n\t\t\tmax = words[i];\n\t\tunique\
    \ = count;\n\t}\n\treturn max;\n}\n</cell>\n<cell>\n%nbdev_hide\n#Testing code\n\
    words = [\"hello\", \"world\", \"foo\", \"bar\", \"a\", \"foo\", \"bar\", \"foo\"\
    ]\nfind_max(words)\n</cell>\n<text>\nNone Happy Coding\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6swluz6c.d(36): Error: declaration expected, not `<`

    /tmp/tmp6swluz6c.d(49): Error: declaration expected, not `assert`

    /tmp/tmp6swluz6c.d(50): Error: declaration expected, not `assert`

    /tmp/tmp6swluz6c.d(51): Error: declaration expected, not `assert`

    /tmp/tmp6swluz6c.d(52): Error: declaration expected, not `assert`

    /tmp/tmp6swluz6c.d(53): Error: declaration expected, not `assert`

    /tmp/tmp6swluz6c.d(54): Error: declaration expected, not `assert`

    /tmp/tmp6swluz6c.d(55): Error: declaration expected, not `assert`

    /tmp/tmp6swluz6c.d(56): Error: declaration expected, not `assert`

    /tmp/tmp6swluz6c.d(57): Error: declaration expected, not `assert`

    /tmp/tmp6swluz6c.d(58): Error: declaration expected, not `assert`

    /tmp/tmp6swluz6c.d(59): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6swluz6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string maxWord = words[0];\n    for(int i\
    \ = 0; i < words.length; i++) {\n        if(words[i].length() > maxWord.length())\
    \ {\n            maxWord = words[i];\n            max = words[i].length();\n \
    \       }\n    }\n    return maxWord;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxul5w002.d(22): Error: no property `length` for type `string`

    /tmp/tmpxul5w002.d(22): Error: no property `length` for type `string`

    /tmp/tmpxul5w002.d(24): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxul5w002.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tmap<int, int> m;\n\tfor (int i = 0; i < words.length; ++i) {\n\
    \t\tm[words[i]] += 1;\n\t}\n\tfor (auto m : m) {\n\t\tif (m.second > 0) return\
    \ m.first;\n\t}\n\treturn words[0];\n}\n/*\nWrite a function that accepts an array\
    \ of integers. \nReturn a list of those elements which are divisible by 3\n(including\
    \ 0, if needed).\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu80r4q25.d(19): Error: found `,` when expecting `.` following int

    /tmp/tmpu80r4q25.d(19): Error: found `int` when expecting identifier following
    `int`.

    /tmp/tmpu80r4q25.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmpu80r4q25.d(23): Error: no identifier for declarator `m`

    /tmp/tmpu80r4q25.d(23): Error: expression expected, not `:`

    /tmp/tmpu80r4q25.d(23): Error: found `m` when expecting `;` following `for` condition

    /tmp/tmpu80r4q25.d(28): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu80r4q25.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int[,] letters = new int[words.length, words[0].length];\n \
    \   for (int i = 0; i < words.length; i++) \n    {\n        for (int j = 0; j\
    \ < words[i].length; j++) \n        {\n            if (letters[i, j] <= 0) \n\
    \            {\n                letters[i, j] = 1;\n            }\n          \
    \  else \n            {\n                letters[i, j]++;\n            }\n   \
    \     }\n    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptxhqspur.d(19): Error: expression expected, not `,`

    /tmp/tmptxhqspur.d(19): Error: found `,` when expecting `]`

    /tmp/tmptxhqspur.d(19): Error: semicolon expected, not `words`

    /tmp/tmptxhqspur.d(19): Error: found `]` when expecting `;` following statement

    /tmp/tmptxhqspur.d(19): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmptxhqspur.d(34): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxhqspur.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    size_t max = 0;\n    string temp;\n    for(auto i : words) {\n\
    \        int chars = std.string.length(i);\n        if (chars > max) {\n     \
    \       temp = i;\n            max = chars;\n        }\n    }\n    return temp;\n\
    }\n</code>\n<|/ a tags=string,c++ |>\n<| a dscore=0 |>\nSince my solution isn't\
    \ the best one, I give it a try:\n<code>\nstring find_max(string[] words) \n{\n\
    \    string results[words.length];\n    bool flags[words.length];\n    size_t\
    \ curIndex = 0;\n    size_t maxCount = words[0].length();\n    for (size_t index\
    \ = 0; index < words.length; index++)\n    {\n        flags[index] = false;\n\
    \        results[index] = words[index];\n    }\n    while (curIndex < words.length)\n\
    \    {\n        for (size_t index = 0; index < words.length; index++)\n      \
    \  {\n            if (results[index].length() > maxCount)\n            {\n   \
    \             flags[index] = true;\n                results[index] = words[index];\n\
    \                maxCount = results[index].length();\n            }\n        }\n\
    \        if (flags[curIndex])\n        {\n            curIndex++;\n        }\n\
    \    }\n    return maxCount > words[0].length() ? maxCount : words[0].length();\n\
    }\n</code>\n<|/ a tags=string,c++ |>\n<| a dscore=0 |>\n<code>\n#include <bits/stdc++.h>\n\
    using namespace std;\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplvp9scsl.d(21): Error: no identifier for declarator `i`

    /tmp/tmplvp9scsl.d(21): Error: expression expected, not `:`

    /tmp/tmplvp9scsl.d(21): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmplvp9scsl.d(30): Error: declaration expected, not `<`

    /tmp/tmplvp9scsl.d(33): Error: unterminated character constant

    /tmp/tmplvp9scsl.d(38): Deprecation: instead of C-style syntax, use D-style syntax
    `bool[words.length] flags`

    /tmp/tmplvp9scsl.d(41): Error: declaration expected, not `for`

    /tmp/tmplvp9scsl.d(41): Error: no identifier for declarator `index`

    /tmp/tmplvp9scsl.d(41): Error: declaration expected, not `<`

    /tmp/tmplvp9scsl.d(41): Error: no identifier for declarator `index`

    /tmp/tmplvp9scsl.d(41): Error: declaration expected, not `++`

    /tmp/tmplvp9scsl.d(44): Error: no identifier for declarator `results[index]`

    /tmp/tmplvp9scsl.d(44): Error: declaration expected, not `=`

    /tmp/tmplvp9scsl.d(45): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplvp9scsl.'
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int n = words.length;\n    int max = 0;\n    int maxCount =\
    \ 0;\n    bool found = false;\n    for(int i = 0; i < n; i++)\n    {\n       \
    \ found = maxCount == 0;\n        for(int j = 0; j < n; j++)\n        {\n    \
    \        if(i == j)\n            {\n                continue;\n            }\n\
    \            string word = words[j];\n            int len = word.length();\n \
    \           int count = 0;\n            for(int k = 0; k < len; k++)\n       \
    \     {\n                if(word.charAt(k) == words[i].charAt(k))\n          \
    \      {\n                    count++;\n                }\n            }\n   \
    \         if(count > maxCount)\n            {\n                max = count;\n\
    \                maxCount = count;\n                found = true;\n          \
    \  }\n        }\n        if(found)\n            break;\n    }\n    if(maxCount\
    \ == 0 && found)\n        return \"no match\";\n    return words[max];\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis solution does not handle multiple occurrences\
    \ of the same string correctly (e.g. `find_max([\"aaaaaaa\", \"aaaaa\", \"bb\"\
    , \"cc\"])` returns `\"aaaaa\"` instead of `\"aaaaaaa\"`).\n<|/ c |>\n<| c |>\n\
    Thanks for pointing out that. I was working on it and now its corrected. I will\
    \ also post the solution for multiple occurrences correctly.\n<|/ c |>\n<| c |>\n\
    The solution for multiple occurrences is now posted too.\n<|/ c |>\n<| a tags=algorithm\
    \ |>\n<code>\n//O(N) time and O(1) space\nimport java.util.HashMap;\nimport java.util.Map;\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnit3fdq0.d(56): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnit3fdq0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    stack<string> s;\n    for (int i = 0; i < (int)words.length;\
    \ i++)\n    {\n        if (s.empty() || words[i].length() != s[s.size()].length())\n\
    \        {\n            s.push(words[i]);\n        }\n        else\n        {\n\
    \            if (s[s.size()] < words[i])\n            {\n                s.push(words[i]);\n\
    \            }\n        }\n    }\n    return (!s.empty() ? s[s.size()] : \"\"\
    );\n}\n</cell>\n<cell>\n%run \"..\\\\funcs\\\\code_utils.py\"\n</cell>\n<cell>\n\
    %run \"..\\\\funcs\\\\word_analysis.py\"\n</cell>\n<cell>\n%run \"..\\\\funcs\\\
    \\find_max.py\"\n</cell>\n<cell>\n%run \"..\\\\funcs\\\\find_min.py\"\n</cell>\n\
    <cell>\n%run \"..\\\\funcs\\\\find_median.py\"\n</cell>\n<text>\nFunction for\
    \ finding kth Smallest Element\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps0ebrj3j.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmps0ebrj3j.d(20): Error: C style cast illegal, use `cast(int)words.length`

    /tmp/tmps0ebrj3j.d(36): Error: declaration expected, not `<`

    /tmp/tmps0ebrj3j.d(58): Error: declaration expected, not `assert`

    /tmp/tmps0ebrj3j.d(59): Error: declaration expected, not `assert`

    /tmp/tmps0ebrj3j.d(60): Error: declaration expected, not `assert`

    /tmp/tmps0ebrj3j.d(61): Error: declaration expected, not `assert`

    /tmp/tmps0ebrj3j.d(62): Error: declaration expected, not `assert`

    /tmp/tmps0ebrj3j.d(63): Error: declaration expected, not `assert`

    /tmp/tmps0ebrj3j.d(64): Error: declaration expected, not `assert`

    /tmp/tmps0ebrj3j.d(65): Error: declaration expected, not `assert`

    /tmp/tmps0ebrj3j.d(66): Error: declaration expected, not `assert`

    /tmp/tmps0ebrj3j.d(67): Error: declaration expected, not `assert`

    /tmp/tmps0ebrj3j.d(68): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps0ebrj3j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint max = 0;\n\tstring word = null;\n\tint count = 0;\n\tfor(int\
    \ i = 0; i < words.length; i++)\n\t{\n\t\tif(words[i].length() > max)\n\t\t{\n\
    \t\t\tmax = words[i].length();\n\t\t\tword = words[i];\n\t\t}\n\t\tif(words[i].length()\
    \ == max)\n\t\t\tcount++;\n\t}\n\t\n\treturn word;\n}\n/*\nWrite a function that\
    \ accepts an array of strings and a string. The array\ncontains different words.\
    \ Return true if and only if the array contains one or\nmore words that contain\
    \ the string in lexicographical order.\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxeyn6lf5.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxeyn6lf5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int total = 0;\n    int max;\n    for(int i = 0; i < words.length;\
    \ ++i)\n    {\n        total += std.typecons.length(words[i]);\n        if(total\
    \ > max)\n        {\n            max = total;\n        }\n    }\n    for(int i\
    \ = 0; i < words.length; ++i)\n    {\n        total -= std.typecons.length(words[i]);\n\
    \        if(total > max)\n        {\n            max = total;\n        }\n   \
    \ }\n    return words[max];\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq2w9qad_.d(23): Error: undefined identifier `length` in module
    `std.typecons`

    /tmp/tmpq2w9qad_.d(31): Error: undefined identifier `length` in module `std.typecons`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq2w9qad_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int counter = 0;\n    int max = 0;\n    string word = \"\";\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmpqke80r.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmpqke80r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int highest = words.length;\n    int max = words[0];\n    for(int\
    \ i = 1; i < words.length; i++){\n        if (words[i].length() > words[highest].length()){\n\
    \            highest = i;\n            max = words[i];\n        }\n    }\n   \
    \ return max;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is not working. I'm\
    \ getting an index out of range exception on this line: \"string max = words[0];\"\
    \n<|/ c |>\n<| c |>\nIt should work now, had an error in the logic\n<|/ c |>\n\
    <| a tags=algorithm,c# dscore=0 |>\nHere is my code\n<code>\nstatic void Main(string[]\
    \ args)\n    {\n        string[] words = new string[] { \"and\", \"a\", \"be\"\
    , \"my\", \"apple\", \"is\", \"in\", \"my\", \"family\", \"and\", \"the\", \"\
    apple\", \"is\", \"not\", \"in\", \"my\", \"family\" };\n        string word =\
    \ \"\";\n        int max = 0;\n        for (int i = 0; i < words.Length; i++)\n\
    \        {\n            if (words.Length - 1 == i) word = words[i];\n        \
    \    else word = words[i] + \" \" + words[i + 1];\n            if (word.Count(x\
    \ => x == words[i].Substring(0, word.Length - 1)) == word.Length)\n          \
    \  {\n                if (word.Count(x => x == words[i].Substring(0, word.Length\
    \ - 1)) > max)\n                {\n                    max = word.Count(x => x\
    \ == words[i].Substring(0, word.Length - 1));\n                    word = words[i];\n\
    \                }\n            }\n        }\n        Console.WriteLine(word);\n\
    \    }\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is my code:\n<code>\nclass Program\n\
    {\n    static void Main(string[] args)\n    {\n        string[] words = { \"and\"\
    , \"a\", \"be\", \"my\", \"apple\", \"is\", \"in\", \"my\", \"family\", \"and\"\
    , \"the\", \"apple\", \"is\", \"not\", \"in\", \"my\", \"family\" };\n       \
    \ string word = string.Empty;\n        int maxCount = 0;\n        int maxIndex\
    \ = -1;\n        for (int i = 0; i < words.Length; i++)\n        {\n         \
    \   if (i == 0)\n            {\n                word = words[i];\n           \
    \     continue;\n            }\n            if (words[i].Length == 0)\n      \
    \      {\n                continue;\n            }\n            string nextWord\
    \ = words[i];\n            for (int j = i + 1; j < words.Length; j++)\n      \
    \      {\n                if (j == words.Length - 1)\n                {\n    \
    \                break;\n                }\n                nextWord += \" \"\
    \ + words[j];\n            }\n            if (nextWord.Count(c => c == nextWord.Substring(0,\
    \ nextWord.Length - 1)) == nextWord.Length)\n            {\n                int\
    \ count = nextWord.Count(c => c == \nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa8ahig4o.d(29): Error: declaration expected, not `<`

    /tmp/tmpa8ahig4o.d(32): Error: unterminated character constant

    /tmp/tmpa8ahig4o.d(45): Error: declaration expected, not `for`

    /tmp/tmpa8ahig4o.d(45): Error: no identifier for declarator `i`

    /tmp/tmpa8ahig4o.d(45): Error: declaration expected, not `<`

    /tmp/tmpa8ahig4o.d(45): Error: no identifier for declarator `i`

    /tmp/tmpa8ahig4o.d(45): Error: declaration expected, not `++`

    /tmp/tmpa8ahig4o.d(48): Error: declaration expected, not `else`

    /tmp/tmpa8ahig4o.d(49): Error: declaration expected, not `if`

    /tmp/tmpa8ahig4o.d(54): Error: no identifier for declarator `word`

    /tmp/tmpa8ahig4o.d(54): Error: declaration expected, not `=`

    /tmp/tmpa8ahig4o.d(55): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa8ahig4o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint maxcount = 0;\n\t\n\tfor (int i = 0; i < words.length; i++){\n\
    \t\tint count = 0;\n\t\tfor (int j = 0; j < words[i].length(); j++){\n\t\t\tcount++;\n\
    \t\t}\n\t\tif (count > maxcount){\n\t\t\tmaxcount = count;\n\t\t}\n\t}\n\t\n\t\
    for (int i = 0; i < words.length; i++){\n\t\tint count = 0;\n\t\tfor (int j =\
    \ 0; j < words[i].length(); j++){\n\t\t\tcount++;\n\t\t}\n\t\tif (count > maxcount){\n\
    \t\t\treturn words[i];\n\t\t}\n\t}\n\treturn null;\n}\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa2chmgfe.d(23): Error: no property `length` for type `string`

    /tmp/tmpa2chmgfe.d(33): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa2chmgfe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int result = 1;\n    for(int i = 1; i < words.length; ++i)\n\
    \        result = max(result, words[i].length());\n    string result = words[0];\n\
    \    for(int i = 1; i < words.length; ++i)\n    {\n        if(words[i].length()\
    \ > result)\n            result = words[i].length();\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdwo_n3lr.d(21): Error: undefined identifier `max`, did you mean
    function `fmax`?

    /tmp/tmpdwo_n3lr.d(22): Error: declaration `tmpdwo_n3lr.find_max.result` is already
    defined

    /tmp/tmpdwo_n3lr.d(25): Error: no property `length` for type `string`

    /tmp/tmpdwo_n3lr.d(26): Error: no property `length` for type `string`

    /tmp/tmpdwo_n3lr.d(28): Error: cannot implicitly convert expression `result` of
    type `int` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdwo_n3lr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  unordered_map<string, size_t> counts;\n  vector<string> strings;\n\
    \  for (const string& word: words) {\n    size_t count = counts[word];\n    if\
    \ (count != 0) {\n      strings[count] = word;\n    }\n    counts[word] = counts.size();\n\
    \  }\n  return strings[max_element(counts.begin(), counts.end())->second];\n}\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp79iq3rol.d(20): Error: found `>` when expecting `;` following statement

    /tmp/tmp79iq3rol.d(21): Error: no identifier for declarator `string`

    /tmp/tmp79iq3rol.d(21): Error: found `:` when expecting `;` following `for` condition

    /tmp/tmp79iq3rol.d(28): Error: expression expected, not `>`

    /tmp/tmp79iq3rol.d(28): Error: found `second` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp79iq3rol.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max;\n    int counter = 0;\n    foreach (string w in\
    \ words) {\n        if(!std.is_empty(max)) {\n            int c = std.len(w);\n\
    \            if (c > std.len(max)) {\n                max = w;\n            }\n\
    \        }\n        else {\n            max = w;\n        }\n    }\n    foreach\
    \ (string w in words) {\n        int c = std.len(w);\n        if (std.is_empty(max))\
    \ {\n            return w;\n        }\n        else if (c > std.len(max)) {\n\
    \            return w;\n        }\n        else if (c == std.len(max)) {\n   \
    \         counter++;\n        }\n    }\n    if(std.is_empty(max)) {\n        return\
    \ max;\n    }\n    return max;\n}\n</code>\n<|/ a tags=string,arrays,algorithm\
    \ |>\n<| a dscore=2 |>\n<code>\n#include <stdio.h>\n#include <string.h>\n#include\
    \ <stdlib.h>\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz5_rfqqv.d(21): Error: found `in` when expecting `;`

    /tmp/tmpz5_rfqqv.d(32): Error: found `in` when expecting `;`

    /tmp/tmpz5_rfqqv.d(49): Error: declaration expected, not `<`

    /tmp/tmpz5_rfqqv.d(60): Error: declaration expected, not `assert`

    /tmp/tmpz5_rfqqv.d(61): Error: declaration expected, not `assert`

    /tmp/tmpz5_rfqqv.d(62): Error: declaration expected, not `assert`

    /tmp/tmpz5_rfqqv.d(63): Error: declaration expected, not `assert`

    /tmp/tmpz5_rfqqv.d(64): Error: declaration expected, not `assert`

    /tmp/tmpz5_rfqqv.d(65): Error: declaration expected, not `assert`

    /tmp/tmpz5_rfqqv.d(66): Error: declaration expected, not `assert`

    /tmp/tmpz5_rfqqv.d(67): Error: declaration expected, not `assert`

    /tmp/tmpz5_rfqqv.d(68): Error: declaration expected, not `assert`

    /tmp/tmpz5_rfqqv.d(69): Error: declaration expected, not `assert`

    /tmp/tmpz5_rfqqv.d(70): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz5_rfqqv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int charNum = 0;\n    string maxString = \"\";\n    for (int\
    \ i = 0; i < words.length; i++) {\n        if (charNum == 0) {\n            maxString\
    \ = words[i];\n            charNum += words[i].length();\n        }\n        else\
    \ {\n            if (words[i].length() > maxString.length()) {\n             \
    \   maxString = words[i];\n                charNum += words[i].length();\n   \
    \         }\n        }\n    }\n    return maxString;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nHi Tasos Kanavos,\nThank you very much. Would you please give me\
    \ a hint on how I could implement your code in my existing code?\n<|/ c |>\n<|\
    \ c |>\nSure, Please see my updated answer.\n<|/ c |>\n<| c |>\nHi Tasos Kanavos,\
    \ thank you very much for your help and support. I am getting the following error\
    \ message when I try to run this code: `error: cannot find symbol\n      private\
    \ void initialize(int n, int m, int t) {\n                                   \
    \    ^\n  symbol:   variable n\n  location: class LinkedList\n1 error\n`\n<|/\
    \ c |>\n<| c |>\nI am also getting a similar error when I try to run this: `error:\
    \ cannot find symbol\n        if (t == 0)\n            throw new ArithmeticException(\"\
    Error: negative value of t.\");\n            ^\n  symbol:   variable t\n  location:\
    \ class LinkedList\n1 error\n`\n<|/ c |>\n<| c |>\nI am also getting a similar\
    \ error when I try to run this: `error: cannot find symbol\n                else\
    \ {\n                    throw new ArithmeticException(\"Error: negative value\
    \ of t.\");\n                }\n                ^\n  symbol:   variable t\n  location:\
    \ class LinkedList\n1 error\n`\n<|/ c |>\n<| a dscore=0 |>\nThank you everyone\
    \ for your help and support. I ended up solving the problem in a different way,\
    \ using the solution provided by Tasos Kanavos and Toni Allison.\nHere is the\
    \ code I used - it is slightly different from Toni Allison's code since it uses\
    \ a different method of counting the characters in each word and calculating with\
    \ the longest word:\n<code>\nimport java.util.LinkedList;\npublic class MyClass\
    \ {\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd2i2pnza.d(35): Error: declaration expected, not `<`

    /tmp/tmpd2i2pnza.d(76): Error: unterminated character constant

    /tmp/tmpd2i2pnza.d(95): Error: `}` expected following members in `class` declaration
    at /tmp/tmpd2i2pnza.d(79)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd2i2pnza.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int maxChar = 0;\n    int maxIndex = -1;\n    for(int i = 0;\
    \ i < words.length(); i++)\n    {\n        int count = 0;\n        for(int j =\
    \ 0; j < words[i].length(); j++)\n        {\n            int c = words[i][j] -\
    \ 'a';\n            if(c == maxChar)\n            {\n                count++;\n\
    \            }\n            else\n            {\n                if(count > maxCount)\n\
    \                {\n                    maxChar = c;\n                    maxIndex\
    \ = i;\n                    maxCount = count;\n                }\n           \
    \ }\n        }\n    }\n    return words[maxIndex];\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis does not really answer the question asked.\n<|/ c |>\n<| c |>\nThe\
    \ question is asking for an algorithm to return the word with most number of characters.\
    \ Your algorithm only returns the most common character of the words. I'm sure\
    \ there are other issues with the algorithm. Do you have a better algorithm?\n\
    <|/ c |>\n<| c |>\nThe question was how to get the word with most number of characters.\
    \ But you still haven't answered this question yet.\n<|/ c |>\n<| c |>\nThe question\
    \ was how to get the word with most number of characters, which is what I provided\
    \ the algorithm.\n<|/ c |>\n<| c |>\nBut how does the algorithm decide if two\
    \ words have the same amount of unique characters? That's what I'm trying to understand\
    \ here.\n<|/ c |>\n<| a |>\n<code>\n// Return the word with maximum number of\
    \ unique characters.\nstring findMaxUniqueChars(string words[])\n{\n    int maxIndex\
    \ = 0;\n    int maxCharCount = 0;\n    for(int i = 0; i < words.length(); i++)\n\
    \    {\n        int count = 0;\n        for(int j = 0; j < words[i].length();\
    \ j++)\n        {\n            int c = words[i][j] - 'a';\n            if(c ==\
    \ maxCharCount)\n            {\n                count++;\n            }\n    \
    \        else\n            {\n                if(count > maxCharCount)\n     \
    \           {\n                    maxCharCount = c;\n                    maxIndex\
    \ = i;\n                }\n            }\n        }\n    }\n    return words[maxIndex];\n\
    }\n</code>\n<|/ a tags=string,algorithm,c++ dscore=1 |>\n<| c |>\nThe question\
    \ was how to get the word with most number of characters, which is what I provided\
    \ the algorithm.\n<|/ c |>\n<| c |>\nBut this doesn't solve the problem of having\
    \ the same amount of unique characters\n<|/ c |>\n<| c |>\nIt does solve the problem\
    \ of having the same amount of unique characters\n<|/ c |>\n<| a |>\nHere's an\
    \ implementation in Python:\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbyyk3muy.d(44): Error: declaration expected, not `<`

    /tmp/tmpbyyk3muy.d(50): Error: unterminated character constant

    /tmp/tmpbyyk3muy.d(53): Error: unterminated character constant

    /tmp/tmpbyyk3muy.d(59): Error: unterminated character constant

    /tmp/tmpbyyk3muy.d(59): Error: unterminated character constant

    /tmp/tmpbyyk3muy.d(68): Error: declaration expected, not `for`

    /tmp/tmpbyyk3muy.d(68): Error: no identifier for declarator `i`

    /tmp/tmpbyyk3muy.d(68): Error: declaration expected, not `<`

    /tmp/tmpbyyk3muy.d(68): Error: no identifier for declarator `i`

    /tmp/tmpbyyk3muy.d(68): Error: declaration expected, not `++`

    /tmp/tmpbyyk3muy.d(71): Error: declaration expected, not `for`

    /tmp/tmpbyyk3muy.d(71): Error: no identifier for declarator `j`

    /tmp/tmpbyyk3muy.d(71): Error: declaration expected, not `<`

    /tmp/tmpbyyk3muy.d(71): Error: no identifier for declarator `j`

    /tmp/tmpbyyk3muy.d(71): Error: declaration expected, not `++`

    /tmp/tmpbyyk3muy.d(74): Error: declaration expected, not `if`

    /tmp/tmpbyyk3muy.d(77'
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<int, int> map;\n    map<int, int>::iterator itr;\n    int\
    \ maxCount = 0;\n    foreach(string s in words)\n    {\n        itr = map.find(maxCount);\n\
    \        if(itr != map.end())\n        {\n            string temp = s;\n     \
    \       if(itr->second > 0)\n                temp = s;\n            string temp2\
    \ = s;\n            if(itr->second > 1)\n                temp2 = s;\n        \
    \    if(temp > temp2)\n                temp = s;\n        }\n        else\n  \
    \      {\n            map.insert(pair<int, int>(maxCount, s.length()));\n    \
    \    }\n        maxCount++;\n    }\n    int maxCount2 = 0;\n    foreach(string\
    \ s in words)\n    {\n        itr = map.find(maxCount2);\n        if(itr != map.end())\n\
    \        {\n            string temp = s;\n            if(itr->second > 0)\n  \
    \              temp = s;\n            string temp2 = s;\n            if(itr->second\
    \ > 1)\n                temp2 = s;\n            if(temp > temp2)\n           \
    \     temp = s;\n        }\n        else\n        {\n            map.insert(pair<int,\
    \ int>(maxCount2, s.length()));\n        }\n        maxCount2++;\n    }\n    map<int,\
    \ int>::iterator itr2;\n    string result = \"\";\n    itr2 = map.begin();\n \
    \   while(itr2 != map.end())\n    {\n        if(itr2->second > 0)\n        {\n\
    \            result += itr2->first;\n            result += \"-\";\n        }\n\
    \        itr2++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgpqeszm3.d(19): Error: found `,` when expecting `.` following int

    /tmp/tmpgpqeszm3.d(19): Error: found `int` when expecting identifier following
    `int`.

    /tmp/tmpgpqeszm3.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmpgpqeszm3.d(20): Error: found `,` when expecting `.` following int

    /tmp/tmpgpqeszm3.d(20): Error: found `int` when expecting identifier following
    `int`.

    /tmp/tmpgpqeszm3.d(20): Error: found `>` when expecting `;` following statement

    /tmp/tmpgpqeszm3.d(20): Error: found `:` instead of statement

    /tmp/tmpgpqeszm3.d(22): Error: found `in` when expecting `;`

    /tmp/tmpgpqeszm3.d(28): Error: use `.` for member lookup, not `->`

    /tmp/tmpgpqeszm3.d(31): Error: use `.` for member lookup, not `->`

    /tmp/tmpgpqeszm3.d(38): Error: found `,` when expecting `.` following int

    /tmp/tmpgpqeszm3.d(38): Error: found `int` when expecting identifier following
    `int`.

    /tmp/tmpgpqeszm3.d(38): Error: found `>` when expecting `,`

    /tmp/tmpgpqeszm3.d(43): Error: found `in` when expecting `;`

    /tmp/t'
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    size_t max = numeric_limits<size_t>::max();\n    size_t maxIndex\
    \ = 0;\n    string cur = words[maxIndex];\n    for (size_t i = 1; i < words.length;\
    \ ++i)\n    {\n        size_t count = 0;\n        for (size_t j = 0; j < words[i].length();\
    \ ++j)\n        {\n            if (words[i][j] == cur[j])\n                ++count;\n\
    \        }\n        if (count == words[i].length() && max < count)\n        {\n\
    \            max = count;\n            maxIndex = i;\n            cur = words[maxIndex];\n\
    \        }\n    }\n    return cur;\n}\n</code>\n<|/ a |>\n<| a tags=c++ |>\nHere\
    \ is a solution using STL algorithm and lambda function\n<code>\n#include <iostream>\n\
    #include <algorithm>\n#include <vector>\n#include <string>\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6wsd__43.d(19): Error: semicolon expected, not `>`

    /tmp/tmp6wsd__43.d(19): Error: found `>` instead of statement

    /tmp/tmp6wsd__43.d(39): Error: declaration expected, not `<`

    /tmp/tmp6wsd__43.d(52): Error: declaration expected, not `assert`

    /tmp/tmp6wsd__43.d(53): Error: declaration expected, not `assert`

    /tmp/tmp6wsd__43.d(54): Error: declaration expected, not `assert`

    /tmp/tmp6wsd__43.d(55): Error: declaration expected, not `assert`

    /tmp/tmp6wsd__43.d(56): Error: declaration expected, not `assert`

    /tmp/tmp6wsd__43.d(57): Error: declaration expected, not `assert`

    /tmp/tmp6wsd__43.d(58): Error: declaration expected, not `assert`

    /tmp/tmp6wsd__43.d(59): Error: declaration expected, not `assert`

    /tmp/tmp6wsd__43.d(60): Error: declaration expected, not `assert`

    /tmp/tmp6wsd__43.d(61): Error: declaration expected, not `assert`

    /tmp/tmp6wsd__43.d(62): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6wsd__43.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint maxCount = 0;\n\tstring maxWord = \"\";\nunittest\n{\n   \
    \ alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n   string maxWord = \"\";\n   if(words.length == 0)\n      return\
    \ maxWord;\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoxf02iq2.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoxf02iq2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    set <string> seen;\n    string max;\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyq2du5xd.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmpyq2du5xd.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyq2du5xd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    //Your code here\n    map<string, int> unique;\n    foreach\
    \ (word w in words) {\n        string letters = \"\";\n        int i = 0;\n  \
    \      foreach (char c in w) {\n            if (i == 0) letters += c;\n      \
    \      else if (c == letters[i - 1]) letters += c;\n            else {\n     \
    \           if (!unique.containsKey(letters)) unique[letters] += 1;\n        \
    \        else unique[letters] = max(unique[letters], 1);\n            }\n    \
    \        i++;\n        }\n    }\n    string maxKey = unique.keys().max();\n  \
    \  map<string, int> maxValue = unique[maxKey];\n    if (maxValue != 1) maxValue\
    \ += 1;\n    return maxKey;\n}\n</code>\n<|/ a |>\n<| c |>\nThis solution works\
    \ perfectly for small arrays but gives wrong results for large arrays. I changed\
    \ `maxValue = unique[maxKey]; if (maxValue != 1) maxValue += 1;` to `maxValue\
    \ = unique[maxKey];\nif (maxValue != 1) maxValue = maxValue+1;` and it worked\
    \ for me.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n// Write a function that accepts\
    \ an array of strings.\n// The array contains different words. Return the word\
    \ with maximum number\n// of unique characters. If multiple strings have maximum\
    \ number of unique\n// characters, return the one which comes first in lexicographical\
    \ order.\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxc0_7saa.d(20): Error: found `>` when expecting `.` following int

    /tmp/tmpxc0_7saa.d(21): Error: found `in` when expecting `;`

    /tmp/tmpxc0_7saa.d(24): Error: found `in` when expecting `;`

    /tmp/tmpxc0_7saa.d(35): Error: found `>` when expecting `.` following int

    /tmp/tmpxc0_7saa.d(39): Error: declaration expected, not `<`

    /tmp/tmpxc0_7saa.d(55): Error: declaration expected, not `assert`

    /tmp/tmpxc0_7saa.d(56): Error: declaration expected, not `assert`

    /tmp/tmpxc0_7saa.d(57): Error: declaration expected, not `assert`

    /tmp/tmpxc0_7saa.d(58): Error: declaration expected, not `assert`

    /tmp/tmpxc0_7saa.d(59): Error: declaration expected, not `assert`

    /tmp/tmpxc0_7saa.d(60): Error: declaration expected, not `assert`

    /tmp/tmpxc0_7saa.d(61): Error: declaration expected, not `assert`

    /tmp/tmpxc0_7saa.d(62): Error: declaration expected, not `assert`

    /tmp/tmpxc0_7saa.d(63): Error: declaration expected, not `assert`

    /tmp/tmpxc0_7saa.d(64): Error: declaration expected, not `assert`

    /tmp/tmpxc0_7saa.d(65): Error: un'
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    /*\n    TODO: Replace this block of code with your own\n   \
    \ implementation\n    */\n    int i,j,k,l=0;\n    int n = 0;\n    for (i = 0;\
    \ i < words.length; i++){\n        for (j = 0; j < words[i].length(); j++){\n\
    \            for (k = 0; k < words[i].length(); k++){\n                if (words[i][j]\
    \ == words[i][k]){\n                    n++;\n                }\n            }\n\
    \        }\n    }\n    vector<int> u;\n    u.reserve(words.length);\n    for (i\
    \ = 0; i < words.length; i++){\n        u.push_back(n);\n    }\n    sort(u.begin(),u.end());\n\
    \    return u[l];\n}\n</code>\n<|/ a dscore=0 tags=algorithm,python |>\n<| a dscore=0\
    \ |>\nThis solution is based on the fact that the words are stored in lexicographical\
    \ order, and that they only contain lowercase letters. There are some optimizations\
    \ left for you to consider.\n<code>\ndef longestCommonPrefix(words):\n    if words\
    \ == []:\n        return \"\"\n    length = len(words[0])\n    common = []\n \
    \   for i in range(length):\n        for j in range(len(words)):\n           \
    \ if words[j][i] == words[0][i]:\n                common.append(words[j][i])\n\
    \                break\n        if len(common) > length:\n            length =\
    \ len(common)\n            common = []\n    if common != []:\n        return longestCommonPrefix(common)\n\
    \    else:\n        return \"\"\n</code>\n<|/ a tags=algorithm,python |>\n<| a\
    \ dscore=0 |>\nThis code will find the longest common prefix and length of the\
    \ common prefix for multiple inputs without using any extra space for the strings.\n\
    <code>\ndef longestCommonPrefix(words):\n    if len(words) == 0:\n        return\
    \ \"\"\n    smallestWordLen = min([len(word) for word in words])\n    for word\
    \ in words:\n        if len(word) < smallestWordLen:\n            smallestWordLen\
    \ = len(word)\n    commonPrefix = [word[0] for word in words if word[:smallestWordLen]\
    \ == words[0][:smallestWordLen]]\n    return commonPrefix[commonPrefix.index(commonPrefix[0])]\n\
    </code>\n<|/ a tags=algorithm,python |>\n<| c |>\nThis does not answer the question.\
    \ Question asks about longest common prefix for multiple strings.\n<|/ c |>\n\
    <| c |>\nThis gives a different result from the OP's expected output.\n<|/ c |>\n\
    <| a tags=algorithm,python dscore=0 |>\n<code>\ndef find_prefix(string, list):\n\
    \    list = []\n    ans = \"\"\n    for i in string:\n        list.insert(0,i)\n\
    \    if len(list) < 2:\n        return \"\"\n    prefix_word = \nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2q3m29n3.d(34): Error: found `>` when expecting `.` following int

    /tmp/tmp2q3m29n3.d(42): Error: declaration expected, not `<`

    /tmp/tmp2q3m29n3.d(84): Error: unterminated character constant

    /tmp/tmp2q3m29n3.d(100): Error: declaration expected, not `assert`

    /tmp/tmp2q3m29n3.d(101): Error: declaration expected, not `assert`

    /tmp/tmp2q3m29n3.d(102): Error: declaration expected, not `assert`

    /tmp/tmp2q3m29n3.d(103): Error: declaration expected, not `assert`

    /tmp/tmp2q3m29n3.d(104): Error: declaration expected, not `assert`

    /tmp/tmp2q3m29n3.d(105): Error: declaration expected, not `assert`

    /tmp/tmp2q3m29n3.d(106): Error: declaration expected, not `assert`

    /tmp/tmp2q3m29n3.d(107): Error: declaration expected, not `assert`

    /tmp/tmp2q3m29n3.d(108): Error: declaration expected, not `assert`

    /tmp/tmp2q3m29n3.d(109): Error: declaration expected, not `assert`

    /tmp/tmp2q3m29n3.d(110): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2q3m29n3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> count;\n    for (string word : words) \n  \
    \  {\n        auto it = count.find(word);\n        if (it == count.end()) \n \
    \       {\n            count[word] = 0;\n        } \n        else \n        {\n\
    \            count[word] = count[word] + 1;\n        }\n    }\nunittest\n{\n \
    \   alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ntbccqx.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmp2ntbccqx.d(20): Error: found `word` when expecting `;` following statement

    /tmp/tmp2ntbccqx.d(20): Error: expression expected, not `:`

    /tmp/tmp2ntbccqx.d(20): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmp2ntbccqx.d(32): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ntbccqx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint maxNum = 0;\n\tstring word = \"\";\n\tfor (int i = 0; i <\
    \ words.length; i++)\n\t{\n\t\tstring temp = words[i];\n\t\tint numOfUniqueChars\
    \ = 1;\n\t\tfor (int j = 0; j < temp.length(); j++)\n\t\t{\n\t\t\tchar ch = temp.at(j);\n\
    \t\t\tif (std.typecons.contains(uniqueChars[ch]))\n\t\t\t{\n\t\t\t\tnumOfUniqueChars++;\n\
    \t\t\t}\n\t\t}\n\t\tif (numOfUniqueChars > maxNum)\n\t\t{\n\t\t\tmaxNum = numOfUniqueChars;\n\
    \t\t\tword = temp;\n\t\t}\n\t}\n\treturn word;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfor6ar1_.d(25): Error: no property `length` for type `string`

    /tmp/tmpfor6ar1_.d(27): Error: no property `at` for type `string`

    /tmp/tmpfor6ar1_.d(28): Error: undefined identifier `contains` in module `std.typecons`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfor6ar1_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    \n    map<int, char> map;\n    int maxCount = 0;\n    for(int\
    \ i=0;i<words.length; i++)\n    {\n        map[words[i]]++;\n        if (map[words[i]]>maxCount)\n\
    \        {\n            maxCount = map[words[i]];\n        }\n    }\n    \n  \
    \  bool sorted = true;\n    int index = 0;\n    while (sorted && index<words.length)\n\
    \    {\n        if (map[words[index]]>map[words[index+1]])\n        {\n      \
    \      sorted = false;\n        }\n        else\n        {\n            index++;\n\
    \        }\n    }\n    if (sorted)\n    {\n        return words[index];\n    }\n\
    \    else \n    {\n        return find_max(words,index,words[index]);\n    }\n\
    }\n</code>\n<|/ a dscore=0 tags=algorithm,sorting |>\n<| c |>\nWelcome to Stack\
    \ Overflow! While this code snippet may solve the question, [including an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| c |>\nThanks, I am new on StackOverflow\
    \ and I did not know how to do it.\n<|/ c |>\n<| a tags=algorithm,sorting |>\n\
    <code>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include\
    \ <map>\nusing namespace std;\nunittest\n{\n    alias candidate = find_max;\n\n\
    \    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9s4xx781.d(20): Error: found `,` when expecting `.` following int

    /tmp/tmp9s4xx781.d(20): Error: found `char` when expecting identifier following
    `int`.

    /tmp/tmp9s4xx781.d(20): Error: found `>` when expecting `;` following statement

    /tmp/tmp9s4xx781.d(53): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9s4xx781.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result = \"\";\n    int max = words[0].size();\n    for\
    \ (int i = 0; i < words.length; i++)\n    {\n        int len = words[i].size();\n\
    \        if (len > max)\n        {\n            max = len;\n            result\
    \ = words[i];\n        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=python,algorithm\
    \ |>\n<| c |>\nYou can't have a variable in the inner scope of the loop in the\
    \ C code.\n<|/ c |>\n<| c |>\n: Please read the post carefully. This solution\
    \ is in Python.\n<|/ c |>\n<| c |>\n: I have added a Python version as well.\n\
    <|/ c |>\n<| c |>\nThis solution is so much clearer. Thank you!\n<|/ c |>\n<|\
    \ a |>\nHere is an iterative version of the algorithm that you described in your\
    \ question. Let me know if you have any questions about how I implemented this.\
    \ I also added some test cases to the solution below.\n<code>\ndef maxLengthWord(words):\n\
    \    words = sorted(words, key=lambda w: len(w))\n    wordCounts = {}\n    longestWord\
    \ = \"\"\n    for i in range(len(words)):\n        if words[i] not in wordCounts:\n\
    \            wordCounts[words[i]] = 1\n        else:\n            wordCounts[words[i]]\
    \ += 1\n        if wordCounts[words[i]] == 1:\n            longestWord = words[i]\n\
    \        elif wordCounts[words[i]] > 1:\n            longestWord = words[i]\n\
    \    return longestWord\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkjg2v95o.d(32): Error: declaration expected, not `<`

    /tmp/tmpkjg2v95o.d(35): Error: unterminated character constant

    /tmp/tmpkjg2v95o.d(67): Error: declaration expected, not `assert`

    /tmp/tmpkjg2v95o.d(68): Error: declaration expected, not `assert`

    /tmp/tmpkjg2v95o.d(69): Error: declaration expected, not `assert`

    /tmp/tmpkjg2v95o.d(70): Error: declaration expected, not `assert`

    /tmp/tmpkjg2v95o.d(71): Error: declaration expected, not `assert`

    /tmp/tmpkjg2v95o.d(72): Error: declaration expected, not `assert`

    /tmp/tmpkjg2v95o.d(73): Error: declaration expected, not `assert`

    /tmp/tmpkjg2v95o.d(74): Error: declaration expected, not `assert`

    /tmp/tmpkjg2v95o.d(75): Error: declaration expected, not `assert`

    /tmp/tmpkjg2v95o.d(76): Error: declaration expected, not `assert`

    /tmp/tmpkjg2v95o.d(77): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkjg2v95o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string max;\n    int counter = 0;\n    bool duplicateFound =\
    \ false;\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5nk7zvs5.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5nk7zvs5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int maxCnt = 0;\n    int i = 0;\n    int j = words.length;\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbze_1l63.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbze_1l63.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int nUnique = 0;\n    int index = 0;\n    int max = words[0];\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5s8s1312.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5s8s1312.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\t\n\tstring word;\n\tint maxLength = 0;\n\tfor (int i = 0; i <\
    \ words.length; ++i)\n\t{\n\t\tword = words[i];\n\t\tint numOfChar = word.size();\n\
    \t\tif (numOfChar > maxLength)\n\t\t{\n\t\t\tmaxLength = numOfChar;\n\t\t\tword\
    \ = words[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < words.length; ++i)\n\t{\n\
    \t\tword = words[i];\n\t\tint numOfChar = word.size();\n\t\tif (numOfChar > maxLength)\n\
    \t\t{\n\t\t\tmaxLength = numOfChar;\n\t\t\tword = words[i];\n\t\t}\n\t}\n\treturn\
    \ word;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeqnsodfe.d(25): Error: no property `size` for type `string`

    /tmp/tmpeqnsodfe.d(36): Error: no property `size` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeqnsodfe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint maxLen = 0, bestIndex = -1;\n\tfor (int i = 0; i < words.length;\
    \ i++)\n\t{\n\t\tint uniqueChars = std.typecons.count_if(words.begin(), words.end(),\
    \ \n\t\t\t[=](string w){ return w.length == 0; });\n\t\tif (uniqueChars > maxLen)\n\
    \t\t{\n\t\t\tmaxLen = uniqueChars;\n\t\t\tbestIndex = i;\n\t\t}\n\t}\n\tif (maxLen\
    \ == words[bestIndex].length) return words[bestIndex];\n\telse return words[bestIndex];\n\
    }\n/*\nWrite a function that accepts an array of integers. Return the sum of the\
    \ elements.\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuhfbyqb0.d(23): Error: expression expected, not `=`

    /tmp/tmpuhfbyqb0.d(23): Error: found `w` when expecting `,`

    /tmp/tmpuhfbyqb0.d(23): Error: found `{` when expecting `,`

    /tmp/tmpuhfbyqb0.d(23): Error: expression expected, not `return`

    /tmp/tmpuhfbyqb0.d(23): Error: found `w` when expecting `,`

    /tmp/tmpuhfbyqb0.d(23): Error: found `;` when expecting `,`

    /tmp/tmpuhfbyqb0.d(23): Error: expression expected, not `}`

    /tmp/tmpuhfbyqb0.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuhfbyqb0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    /*\n    Your code here!\n    */\n    int n = words.length;\n\
    \    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(words[i].length()>words[j].length()){\n\
    \                string temp = words[i];\n                words[i] = words[j];\n\
    \                words[j] = temp;\n            }\n        }\n    }\n    int max\
    \ = 0;\n    string result=\"\";\n    for(int i=0;i<n;i++){\n        if(words[i].length()==words[max].length()){\n\
    \            if(words[i].compare(words[max])<0){\n                max = i;\n \
    \           }\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n\
    \            if(words[i].length()==words[j].length()){\n                if(words[i].compare(words[j])<0){\n\
    \                    string temp = words[i];\n                    words[i] = words[j];\n\
    \                    words[j] = temp;\n                }\n            }\n    \
    \    }\n    }\n    if(words[max].compare(words[result])>0){\n        result =\
    \ words[max];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf9qgxvar.d(22): Error: cannot implicitly convert expression `words.length`
    of type `ulong` to `int`

    /tmp/tmpf9qgxvar.d(25): Error: no property `length` for type `string`

    /tmp/tmpf9qgxvar.d(25): Error: no property `length` for type `string`

    /tmp/tmpf9qgxvar.d(35): Error: no property `length` for type `string`

    /tmp/tmpf9qgxvar.d(35): Error: no property `length` for type `string`

    /tmp/tmpf9qgxvar.d(36): Error: no property `compare` for type `string`

    /tmp/tmpf9qgxvar.d(43): Error: no property `length` for type `string`

    /tmp/tmpf9qgxvar.d(43): Error: no property `length` for type `string`

    /tmp/tmpf9qgxvar.d(44): Error: no property `compare` for type `string`

    /tmp/tmpf9qgxvar.d(52): Error: no property `compare` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf9qgxvar.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> m; // map string - number of unique chars\n\
    \    for(string word: words)\n        m[word] = m[word] ? m[word] + 1 : 1;\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoksik9ng.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmpoksik9ng.d(20): Error: found `word` when expecting `;` following statement

    /tmp/tmpoksik9ng.d(20): Error: expression expected, not `:`

    /tmp/tmpoksik9ng.d(20): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmpoksik9ng.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoksik9ng.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // code goes here\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdv278y3g.d(17): Error: function `tmpdv278y3g.find_max` has no `return`
    statement, but is expected to return a value of type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdv278y3g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  int numchars = std.typecons.int();\n  int maxchars = 0;\n  string\
    \ result = \"\";\n  foreach (string str in words) {\n    int[] uniquechars = std.math.ints(str.chars);\n\
    \    int totalchars = std.typecons.int();\n    foreach (int i in uniquechars)\
    \ totalchars += i;\n    if (totalchars > maxchars) {\n      maxchars = totalchars;\n\
    \      result = str;\n    }\n  }\n  return result;\n}\n</cell>\n<cell>\n%%swip\n\
    /*\nWrite a function that accepts an array of strings.\n    The array contains\
    \ different words. Return an array of strings which contains\n    all the words\
    \ with maximum number of unique characters. If multiple strings have\n    maximum\
    \ number of unique characters, return array of those which comes first in\n  \
    \  lexicographical order.\nunittest\n{\n    alias candidate = find_max;\n\n  \
    \  assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdm10hm38.d(19): Error: identifier expected following `.`, not `int`

    /tmp/tmpdm10hm38.d(22): Error: found `in` when expecting `;`

    /tmp/tmpdm10hm38.d(24): Error: identifier expected following `.`, not `int`

    /tmp/tmpdm10hm38.d(25): Error: found `in` when expecting `;`

    /tmp/tmpdm10hm38.d(33): Error: declaration expected, not `<`

    /tmp/tmpdm10hm38.d(36): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdm10hm38.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    sort(words);\n    int max=words[0].len();\n    for(int i=0;i<words.length;i++){\n\
    \        if(words[i].len()>max){\n            max=words[i].len();\n        }\n\
    \    }\n    return words[words.length-1];\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0by7w8uo.d(19): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmp0by7w8uo.d(20): Error: no property `len` for type `string`

    /tmp/tmp0by7w8uo.d(22): Error: no property `len` for type `string`

    /tmp/tmp0by7w8uo.d(23): Error: no property `len` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0by7w8uo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int[] counter = new int[256];\n    int max_counter = 0;\n  \
    \  int result = 0;\n    for(int i = 0; i < words.length; i++){\n        int count\
    \ = 0;\n        for(int j = 0; j < words[i].length; j++){\n            if(counter[words[i][j]]\
    \ != 0)\n                count++;\n            counter[words[i][j]] = 1;\n   \
    \     }\n        if (count > max_counter){\n            max_counter = count;\n\
    \            result = words[i];\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=algorithm,string,arrays |>\nIf we can get rid of\
    \ the extra spaces and only consider alphabets from a-z or A-Z and digits, we\
    \ can achieve this in O(n) time.\n<code>\nimport java.util.*;\nimport java.lang.*;\n\
    import java.io.*;\nclass Ideone\n{\n    public static void main (String[] args)\
    \ throws java.lang.Exception\n    {\n        ArrayList<String> words = new ArrayList<String>();\n\
    \        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext())\n \
    \       {\n            words.add(sc.next());\n        }\n        Collections.sort(words);\n\
    \        System.out.println(\"Word: \" + words.get(words.size() - 1));\n    }\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a |>\nWe can use HashMap to achieve this in\
    \ O(n) time. \nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6__a0ph5.d(36): Error: declaration expected, not `<`

    /tmp/tmp6__a0ph5.d(42): Error: identifier expected following `package`

    /tmp/tmp6__a0ph5.d(42): Error: `;` expected

    /tmp/tmp6__a0ph5.d(43): Error: identifier expected following `package`

    /tmp/tmp6__a0ph5.d(43): Error: `;` expected

    /tmp/tmp6__a0ph5.d(46): Error: semicolon expected following function declaration

    /tmp/tmp6__a0ph5.d(46): Error: semicolon expected, not `.`

    /tmp/tmp6__a0ph5.d(47): Error: no identifier for declarator `.lang.Exception`

    /tmp/tmp6__a0ph5.d(47): Error: declaration expected, not `{`

    /tmp/tmp6__a0ph5.d(49): Error: identifier expected following `.`, not `in`

    /tmp/tmp6__a0ph5.d(50): Error: declaration expected, not `while`

    /tmp/tmp6__a0ph5.d(54): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmp6__a0ph5.d(54): Error: no identifier for declarator `Collections.sort(words)`

    /tmp/tmp6__a0ph5.d(55): Error: identifier expected following `.` instead of `out`

    /tmp/tmp6__a0ph5.d(55): '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int count = 0;\n    int max = 0;\n    string maxString = \"\"\
    ;\n    foreach(var word in words) {\n        foreach(var letter in word) {\n \
    \           count++;\n        }\n        if(count == max) {\n            maxString\
    \ = word;\n            max = count;\n        }\n        count = 0;\n    }\n  \
    \  return maxString;\n}\n/*\nWrite a function that accepts an array of strings.\n\
    \    The array contains different words. Return all the words with maximum\n \
    \   number of unique characters. If multiple strings have maximum number of unique\n\
    \    characters, return the one which comes first in lexicographical order.\n\
    \    >>> find_max2([\"name\", \"of\", \"string\"])\n    \"string\"\n    >>> find_max2([\"\
    name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max2([\"aaaaaaa\", \"\
    bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring[] find_max2(string[] words)\
    \ \n{\n    int count = 0;\n    int max = 0;\n    string maxString = \"\";\n  \
    \  foreach(var word in words) {\n        foreach(var letter in word) {\n     \
    \       count++;\n        }\n        if(count == max) {\n            maxString\
    \ = word;\n            max = count;\n        }\n        count = 0;\n    }\n  \
    \  return new string[] {maxString};\n}\n/*\nWrite a function that accepts an array\
    \ of strings and integers. Return the\nstring with maximum number of unique characters.\
    \ If multiple strings have maximum\nnumber of unique characters, return the one\
    \ which comes first in lexicographical\norder.\n    >>> find_max3([\"name\", \"\
    of\", \"string\"], 3)\n    \"string\"\n    >>> find_max3([\"name\", \"enam\",\
    \ \"game\"], 2)\n    \"enam\"\n    >>> find_max3([\"aaaaaaa\", \"bb\", \"cc\"\
    ], 1)\n    \"aaaaaaa\"\n    \n*/\nstring find_max3(string[] words, int num) \n\
    {\n    int count = 0;\n    int max = 0;\n    string maxString = \"\";\n    foreach(var\
    \ word in words) {\n        foreach(var letter in word) {\n            count++;\n\
    \        }\n        if(count == max) {\n            maxString = word;\n      \
    \      max = count;\n        }\n        count = 0;\n    }\n    return maxString;\n\
    }\n/*\nWrite a function that accepts an array of strings and integers. Return\
    \ the\nstring with maximum number of unique characters. If multiple strings have\
    \ maximum\nnumber of unique characters, return the one which comes first in lexicographical\n\
    order.\n    >>> find_max4([\"name\", \"of\", \"string\"], 3)\n    \"string\"\n\
    \    >>> find_max4([\"name\", \"enam\", \"game\"], 2)\n    \"enam\"\n    >>> find_max4([\"\
    aaaaaaa\", \"bb\", \"cc\"], 1)\n    \"aaaa\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjgg3k2ow.d(22): Error: found `in` when expecting `;`

    /tmp/tmpjgg3k2ow.d(23): Error: found `in` when expecting `;`

    /tmp/tmpjgg3k2ow.d(52): Error: found `in` when expecting `;`

    /tmp/tmpjgg3k2ow.d(53): Error: found `in` when expecting `;`

    /tmp/tmpjgg3k2ow.d(62): Error: found `{` when expecting `;` following `return`
    statement

    /tmp/tmpjgg3k2ow.d(62): Error: found `}` when expecting `;` following statement

    /tmp/tmpjgg3k2ow.d(62): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpjgg3k2ow.d(82): Error: found `in` when expecting `;`

    /tmp/tmpjgg3k2ow.d(83): Error: found `in` when expecting `;`

    /tmp/tmpjgg3k2ow.d(94): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjgg3k2ow.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    struct StringCount\n    {\n        string value;\n        int\
    \ count;\n    }\n    struct StringCount* counts[100];\n    int count = 0;\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz_ed9bu5.d(24): Error: { } expected following `struct` declaration

    /tmp/tmpz_ed9bu5.d(26): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz_ed9bu5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n  int n = words.length;\n  if (n == 0)\n    throw runtime_error(\"\
    cannot find max of an empty array\");\n  int count = 0;\n  int max_count = 0;\n\
    \  int max_pos = 0;\n  for (int i = 0; i < n; i++)\n  {\n    int num_chars = count(words[i],\
    \ ' ');\n    if (num_chars > max_count)\n    {\n      max_count = num_chars;\n\
    \      max_pos = i;\n    }\n  }\n  string ret(words[max_pos]);\n  for (int i =\
    \ 0; i < n; i++)\n  {\n    if (i != max_pos)\n    {\n      int num_chars = count(words[i],\
    \ ' ');\n      if (num_chars > max_count)\n      {\n        ret.clear();\n   \
    \     ret.swap(words[i]);\n        break;\n      }\n    }\n  }\n  return ret;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppj6rrd43.d(19): Error: cannot implicitly convert expression `words.length`
    of type `ulong` to `int`

    /tmp/tmppj6rrd43.d(21): Error: undefined identifier `runtime_error`

    /tmp/tmppj6rrd43.d(27): Error: function expected before `()`, not `count` of type
    `int`

    /tmp/tmppj6rrd43.d(34): Error: `words` is used as a type

    /tmp/tmppj6rrd43.d(39): Error: function expected before `()`, not `count` of type
    `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppj6rrd43.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int res = 0;\n    int max = 0;\n    for (int i = 0; i < words.length;\
    \ i++) \n    {\n        int x = words[i].length();\n        if (x > max) \n  \
    \      {\n            max = x;\n            res = i;\n        }\n    }\n    return\
    \ words[res];\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbquqzdpp.d(23): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbquqzdpp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint[int] char_count = new int[256];\n\tfor(int i = 0; i < words.length;\
    \ i++) \n\t{\n\t\tfor(int j = 0; j < words[i].length; j++) \n\t\t{\n\t\t\tchar_count[words[i][j]]\
    \ ++;\n\t\t}\n\t}\n\tstring result = \"\";\n\tfor(int i = 0; i < 256; i++)\n\t\
    {\n\t\tif(char_count[i] == char_count[0])\n\t\t\tcontinue;\n\t\tif(char_count[i]\
    \ > char_count[0])\n\t\t\treturn words[i];\n\t}\n\t\n}\n/*\nWrite a function that\
    \ accepts an array of strings.\n    The array contains different words. Return\
    \ an array of strings which\n    contain only words with the same amount of unique\
    \ characters as in the\n    first string.\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl_i_s6ee.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl_i_s6ee.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint n = words.length;\n\tint result = int.MaxValue;\n\tint j =\
    \ 0;\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tint count = 1;\n\t\tfor(int k=0; k<j;\
    \ k++)\n\t\t{\n\t\t\tif(words[i].Length > words[k].Length)\n\t\t\t{\n\t\t\t\t\
    continue;\n\t\t\t}\n\t\t\tstring s = words[i].Substring(0,words[i].Length-1);\n\
    \t\t\tfor(int l=0; l<k; l++)\n\t\t\t{\n\t\t\t\tstring s2 = words[k].Substring(0,words[k].Length-1);\n\
    \t\t\t\tif(s == s2)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t\
    }\n\t\t\t}\n\t\t\tif(count > result)\n\t\t\t{\n\t\t\t\tresult = count;\n\t\t\t\
    \tj = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn words[j];\n}\n/*\nWrite a function that\
    \ accepts an array of strings.\n    The array contains different words. Return\
    \ the word with maximum number\n    of unique characters. If multiple strings\
    \ have maximum number of unique\n    characters, return the one which comes first\
    \ in lexicographical order.\n    \n    >>> find_max_1([\"name\", \"of\", \"string\"\
    ])\n    \"string\"\n    >>> find_max_1([\"name\", \"enam\", \"game\"])\n    \"\
    enam\"\n    >>> find_max_1([\"aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n \
    \   \n*/\nstring find_max_1(string[] words) \n{\n\tint n = words.length;\n\tint\
    \ result = int.MaxValue;\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tint count = 1;\n\t\
    \tfor(int j=0; j<i; j++)\n\t\t{\n\t\t\tif(words[i].Length > words[j].Length)\n\
    \t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring s = words[i].Substring(0,words[i].Length-1);\n\
    \t\t\tstring s2 = words[j].Substring(0,words[j].Length-1);\n\t\t\tif(s == s2)\n\
    \t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(count > result)\n\
    \t\t{\n\t\t\tresult = count;\n\t\t}\n\t}\n\treturn words[i];\n}\n/*\nWrite a function\
    \ that accepts an array of strings and returns an array of\n    strings containing\
    \ only unique strings.\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpog29pcgn.d(92): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpog29pcgn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tif (words.isEmpty()) {\n\t\tthrow new Exception(\"Error: Array\
    \ is empty.\");\n\t}\n\tchar firstChar = words[0].charAt(0);\n\tint[,] count =\
    \ new int[words.length + 1, 1];\n\tfor (int i = 0; i <= words.length; i++) {\n\
    \t\tint count = 0;\n\t\tfor (int j = 0; j < words[i].length; j++) {\n\t\t\tif\
    \ (words[i].charAt(j) == firstChar) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\t\
    count[i, 0] = count;\n\t}\n\tfor (int i = 0; i < words.length; i++) {\n\t\tint\
    \ maxCount = 0;\n\t\tfor (int j = 0; j < words[i].length; j++) {\n\t\t\tif (count[i,\
    \ 0] > maxCount) {\n\t\t\t\tmaxCount = count[i, 0];\n\t\t\t\tfirstChar = words[i].charAt(j);\n\
    \t\t\t}\n\t\t}\n\t}\n\tstring result = \"\";\n\tif (firstChar < firstChar.toLowerCase())\
    \ {\n\t\tresult = firstChar;\n\t} else {\n\t\tresult = firstChar.toLowerCase();\n\
    \t}\n\tfor (int i = 0; i < words.length; i++) {\n\t\tint maxCount = 0;\n\t\tfor\
    \ (int j = 0; j < words[i].length; j++) {\n\t\t\tif (count[i, 0] > maxCount) {\n\
    \t\t\t\tmaxCount = count[i, 0];\n\t\t\t\tresult = words[i];\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn result;\n}\n/*\nWrite a function that accepts an array of strings.\n\
    \    The array contains different words. Return the word with minimum number\n\
    \    of unique characters. If multiple strings have minimum number of unique\n\
    \    characters, return the one which comes first in lexicographical order.\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpof1cwmel.d(23): Error: expression expected, not `,`

    /tmp/tmpof1cwmel.d(23): Error: found `,` when expecting `]`

    /tmp/tmpof1cwmel.d(23): Error: semicolon expected, not `1`

    /tmp/tmpof1cwmel.d(23): Error: found `]` when expecting `;` following statement

    /tmp/tmpof1cwmel.d(23): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpof1cwmel.d(59): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpof1cwmel.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint maxchars = 1;\n\tstring maxword = words[0];\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp37rh_zv4.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp37rh_zv4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> counter;\n    for(int i = 0; i < words.length;\
    \ i++)\n    {\n        counter[words[i]] += 1;\n    }\n    auto max_count = *max_element(counter.begin(),\
    \ counter.end());\n    string max;\n    for(auto it = counter.begin(); it != counter.end();\
    \ it++)\n    {\n        if(it->second == max_count)\n        {\n            max\
    \ = it->first;\n        }\n    }\n    return max;\n}\n</code>\n<|/ a |>\n<| a\
    \ tags=arrays,c++,string dscore=2 |>\nI tried to solve the problem on paper but\
    \ could not find a way.\nThe problem is if I have 2 strings \"a\" and \"ab\",\
    \ I should return \"ab\". The only way I can think of is to keep track of number\
    \ of characters and then check which string has the maximum number of unique characters,\
    \ if I could get number of unique characters from each string, that would be a\
    \ nice solution. But I couldn't.\n<|/ a |>\n<| a tags=arrays,c++,string |>\n<code>\n\
    #include<iostream>\nusing namespace std;\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp200v9vhg.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmp200v9vhg.d(28): Error: use `.` for member lookup, not `->`

    /tmp/tmp200v9vhg.d(30): Error: use `.` for member lookup, not `->`

    /tmp/tmp200v9vhg.d(35): Error: declaration expected, not `<`

    /tmp/tmp200v9vhg.d(39): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp200v9vhg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int count[128] = {0};\n    foreach(string w in words)\n    {\n\
    \        foreach(char c in w)\n        {\n            int n = count[c];\n    \
    \        count[c] = n + 1;\n        }\n    }\n    int max = count[0];\n    int\
    \ max_index = -1;\n    foreach(char c in count)\n    {\n        if(count[c] >\
    \ max)\n        {\n            max = count[c];\n            max_index = c;\n \
    \       }\n    }\n    return words[max_index];\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nI don't think it's necessary to convert all characters to lowercase.\n\
    <|/ c |>\n<| c |>\n: Yes, it is. Otherwise the count would not be correct.\n<|/\
    \ c |>\n<| a dscore=0 |>\nWe can do that with following code in C++11.\n<code>\n\
    #include <iostream>\n#include <algorithm>\n#include <string>\n#include <unordered_map>\n\
    #include <functional>\nusing namespace std;\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwvuqkwr8.d(19): Deprecation: instead of C-style syntax, use D-style
    syntax `int[128] count`

    /tmp/tmpwvuqkwr8.d(20): Error: found `in` when expecting `;`

    /tmp/tmpwvuqkwr8.d(22): Error: found `in` when expecting `;`

    /tmp/tmpwvuqkwr8.d(30): Error: found `in` when expecting `;`

    /tmp/tmpwvuqkwr8.d(40): Error: declaration expected, not `<`

    /tmp/tmpwvuqkwr8.d(43): Error: unterminated character constant

    /tmp/tmpwvuqkwr8.d(43): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwvuqkwr8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    sort(words);\n    int count=0;\n    int maxCount=0;\n    for(string\
    \ word: words)\n    {\n        for(char c: word)\n        {\n            if(!(c\
    \ in count))\n            {\n                count[c]=0;\n            }\n    \
    \        count[c]++;\n            if(count[c]>=maxCount)\n            {\n    \
    \            maxCount=count[c];\n                string temp=word;\n         \
    \       word=word.replaceAll(count, \"\");\n                word=word.replaceAll(maxCount,\
    \ \"\");\n                sort(word);\n                word=temp+word;\n     \
    \       }\n        }\n    }\n    return words[0];\n}\n</code>\n<|/ a |>\n<| a\
    \ dscore=0 |>\n<code>\nstring find_max(string str) \n{\n    string max=\"\";\n\
    \    int maxCount=0;\n    for(int i=0;i<str.size();i++)\n    {\n        for(int\
    \ j=i;j<str.size();j++)\n        {\n            if(str[i]==str[j])\n         \
    \   {\n                maxCount++;\n                break;\n            }\n  \
    \      }\n        if(maxCount>str.size() && maxCount>maxCount-1)\n        {\n\
    \            max=str[i];\n            maxCount=str.size();\n        }\n    }\n\
    \    return max;\n}\n</code>\n<|/ a tags=c++ |>\n<| a tags=c++ dscore=0 |>\n<code>\n\
    \ int main()\n{\n    string words[5]={\"name\",\"of\",\"string\",\"enam\",\"game\"\
    };\n    sort(words);\n    for(int i=0;i<5;i++)\n    {\n        for(int j=0;j<5;j++)\n\
    \        {\n            if(i!=j)\n            {\n                if(words[i]>words[j])\n\
    \                {\n                    string temp=words[j];\n              \
    \      words[j]=words[i];\n                    words[i]=temp;\n              \
    \  }\n            }\n        }\n    }\n    for(int i=0;i<5;i++)\n    {\n     \
    \   cout<<words[i]<<endl;\n    }\n    return 0;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    The question is tagged C++, not C.  It would be useful to explain in English what\
    \ your code is doing, instead of just a block of code.\n<|/ c |>\n<| c |>\nThis\
    \ does not provide an answer to the question. Once you have sufficient [reputation](https://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](https://stackoverflow.com/help/privileges/comment);\
    \ instead, [provide answers that don't require clarification from the asker](https://meta.stackexchange.com/questions/214173/why-\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1c2elsw6.d(22): Error: found `word` when expecting `;` following
    statement

    /tmp/tmp1c2elsw6.d(22): Error: expression expected, not `:`

    /tmp/tmp1c2elsw6.d(22): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmp1c2elsw6.d(24): Error: semicolon expected, not `:`

    /tmp/tmp1c2elsw6.d(24): Error: expression expected, not `:`

    /tmp/tmp1c2elsw6.d(24): Error: found `word` when expecting `;` following `for`
    condition

    /tmp/tmp1c2elsw6.d(44): Error: declaration expected, not `<`

    /tmp/tmp1c2elsw6.d(52): Error: declaration expected, not `for`

    /tmp/tmp1c2elsw6.d(52): Error: no identifier for declarator `i`

    /tmp/tmp1c2elsw6.d(52): Error: declaration expected, not `<`

    /tmp/tmp1c2elsw6.d(52): Error: no identifier for declarator `i`

    /tmp/tmp1c2elsw6.d(52): Error: declaration expected, not `++`

    /tmp/tmp1c2elsw6.d(54): Error: no identifier for declarator `j`

    /tmp/tmp1c2elsw6.d(54): Error: declaration expected, not `<`

    /tmp/tmp1c2elsw6.d(54): Error: no identifier for declarator `j`

    /tmp/tmp1c2elsw6.d('
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int maxCharCount = 0;\n    \n    int maxCharIndex = 0;\n   \
    \ \n    string returnString = \"\";\n    \n    for (size_t i = 0; i < words.length();\
    \ i++)\n    {\n        auto ch = words[i].length();\n        if (maxCharCount\
    \ < ch)\n        {\n            maxCharCount = ch;\n            maxCharIndex =\
    \ i;\n        }\n    }\n    \n    return returnString;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nI believe this solution has time complexity of O(n * m) where n and m\
    \ are the number of elements in the array and m is the number of unique characters\
    \ in all the elements. Isn't this a better solution than O(n^2)?\n<|/ c |>\n<|\
    \ c |>\nI doubt it - for my solution you get O(n*m) but if you consider all the\
    \ possible combinations of m characters, that's just n! / (n! * n!) ~ O(n^2)\n\
    <|/ c |>\n<| c |>\nYou are right. But I thought this can be done in O(n). Thanks\
    \ anyways!\n<|/ c |>\n<| c |>\nWell I believe that it is O(n * m) where n is the\
    \ number of elements and m is the number of unique characters in all elements.\
    \ It is just a simple iteration and O(n) is O(n) because if m is big O(n) means\
    \ that it grows quicker than n. I am sorry for my mistake.\n<|/ c |>\n<| a dscore=2\
    \ |>\nFor starters, you need to be aware that sorting algorithms such as quicksort\
    \ and mergesort will take linear time in the number of elements.  Therefore, if\
    \ you want an algorithm that is linear time, you need to choose a sorting algorithm\
    \ that takes linear time in the number of elements.  As others have mentioned,\
    \ you could always take an approach like radix sort, which is linear time, in\
    \ number of elements.  Alternatively, you could use an in-place algorithm that\
    \ keeps track of the number of unique characters seen so far and updates the counter\
    \ when another character is seen.\n<|/ a tags=c++,algorithm,arrays |>\n<| a tags=c++,algorithm,arrays\
    \ dscore=2 |>\n<code>\n#include <algorithm>\n#include <bits/stdc++.h>\nusing namespace\
    \ std;\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpui_1s3pt.d(37): Error: declaration expected, not `<`

    /tmp/tmpui_1s3pt.d(40): Error: unterminated character constant

    /tmp/tmpui_1s3pt.d(43): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpui_1s3pt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> m;\n    for (string word : words) \n      \
    \  m[word] += 1;\n    string word = m[max_key(m)];\n    return word;\n}\n</code>\n\
    <|/ a |>\n<| a tags=algorithm,c,string,arrays |>\nA simple solution in C is to\
    \ use a map to count the number of occurrences of each unique character and then\
    \ iterate through the map and print the character which has the maximum number\
    \ of occurrences.\n<code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\
    #include <stdint.h>\n#include <stdbool.h>\nunittest\n{\n    alias candidate =\
    \ find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp47t3drhu.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmp47t3drhu.d(20): Error: found `word` when expecting `;` following statement

    /tmp/tmp47t3drhu.d(20): Error: expression expected, not `:`

    /tmp/tmp47t3drhu.d(20): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmp47t3drhu.d(25): Error: declaration expected, not `<`

    /tmp/tmp47t3drhu.d(39): Error: declaration expected, not `assert`

    /tmp/tmp47t3drhu.d(40): Error: declaration expected, not `assert`

    /tmp/tmp47t3drhu.d(41): Error: declaration expected, not `assert`

    /tmp/tmp47t3drhu.d(42): Error: declaration expected, not `assert`

    /tmp/tmp47t3drhu.d(43): Error: declaration expected, not `assert`

    /tmp/tmp47t3drhu.d(44): Error: declaration expected, not `assert`

    /tmp/tmp47t3drhu.d(45): Error: declaration expected, not `assert`

    /tmp/tmp47t3drhu.d(46): Error: declaration expected, not `assert`

    /tmp/tmp47t3drhu.d(47): Error: declaration expected, not `assert`

    /tmp/tmp47t3drhu.d(48): Error: declaration expected, not `asse'
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<int, int> maxCount;\n    for(auto &s : words) {\n      \
    \  int count = 0;\n        for(int i = 0; i < s.length(); i++) {\n           \
    \ count++;\n            if(maxCount.find(i) == maxCount.end()) {\n           \
    \     maxCount[i] = count;\n            } else {\n                if(maxCount[i]\
    \ < count) {\n                    maxCount[i] = count;\n                }\n  \
    \          }\n        }\n    }\n    int max = 1;\n    for(auto &s : words) {\n\
    \        if(maxCount.find(max) == maxCount.end()) {\n            max = maxCount[max];\n\
    \        } else {\n            if(maxCount[max] < maxCount[maxCount[max]]) {\n\
    \                max = maxCount[max];\n            }\n        }\n    }\n    return\
    \ max;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy8bmxgct.d(19): Error: found `,` when expecting `.` following int

    /tmp/tmpy8bmxgct.d(19): Error: found `int` when expecting identifier following
    `int`.

    /tmp/tmpy8bmxgct.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmpy8bmxgct.d(20): Error: basic type expected, not `&`

    /tmp/tmpy8bmxgct.d(20): Error: no identifier for declarator `_error_`

    /tmp/tmpy8bmxgct.d(20): Error: found `:` when expecting `;` following `for` condition

    /tmp/tmpy8bmxgct.d(34): Error: basic type expected, not `&`

    /tmp/tmpy8bmxgct.d(34): Error: no identifier for declarator `_error_`

    /tmp/tmpy8bmxgct.d(34): Error: found `:` when expecting `;` following `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy8bmxgct.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // Your code here\n    map<string, int> m;\n    foreach(word\
    \ : words) \n        m[word] = 1;\n    m[\"no\"] = 2;\n    m[\"no\"] = 1;\n  \
    \  m[\"string\"] = 2;\n    m[\"string\"] = 1;\n    m[\"string\"] = 3;\n    m[\"\
    string\"] = 4;\n    int max = 0;\n    foreach(word : words)\n    {\n        auto\
    \ it = m.find(word);\n        if(it != m.end())\n        {\n            if(it->second\
    \ > max)\n            {\n                max = it->second;\n            }\n  \
    \      }\n    }\n    foreach(word : words)\n    {\n        auto it = m.find(word);\n\
    \        if(it != m.end())\n        {\n            if(it->second == max)\n   \
    \         {\n                if(it->first < words[0])\n                    words[0]\
    \ = it->first;\n            }\n        }\n    }\n    return words[0];\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp72uhe_ob.d(20): Error: found `>` when expecting `.` following int

    /tmp/tmp72uhe_ob.d(21): Error: no identifier for declarator `word`

    /tmp/tmp72uhe_ob.d(21): Error: found `:` when expecting `;`

    /tmp/tmp72uhe_ob.d(30): Error: no identifier for declarator `word`

    /tmp/tmp72uhe_ob.d(30): Error: found `:` when expecting `;`

    /tmp/tmp72uhe_ob.d(35): Error: use `.` for member lookup, not `->`

    /tmp/tmp72uhe_ob.d(37): Error: use `.` for member lookup, not `->`

    /tmp/tmp72uhe_ob.d(41): Error: no identifier for declarator `word`

    /tmp/tmp72uhe_ob.d(41): Error: found `:` when expecting `;`

    /tmp/tmp72uhe_ob.d(46): Error: use `.` for member lookup, not `->`

    /tmp/tmp72uhe_ob.d(48): Error: use `.` for member lookup, not `->`

    /tmp/tmp72uhe_ob.d(49): Error: use `.` for member lookup, not `->`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp72uhe_ob.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string res = words[0];\n    for(unsigned i = 0; i < words.length;\
    \ ++i)\n        if(words[i].length() > res[0].length())\n            res = words[i];\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfz8re_dr.d(20): Error: undefined identifier `unsigned`, did you
    mean `uint`?

    /tmp/tmpfz8re_dr.d(21): Error: no property `length` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfz8re_dr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\tint counter = 0;\n\tstring max = words[0];\n\tfor (int i = 1;\
    \ i < words.length; i++) \n\t{\n\t\tif (words[i].Length > max)\n\t\t\tmax = words[i];\n\
    \t}\n\tfor (int i = 0; i < words.length; i++) \n\t{\n\t\tfor (int j = i + 1; j\
    \ < words.length; j++) \n\t\t{\n\t\t\tif (words[i].Length < words[j].Length) \n\
    \t\t\t{\n\t\t\t\tif (words[i].Length == max) \n\t\t\t\t{\n\t\t\t\t\treturn words[i];\n\
    \t\t\t\t}\n\t\t\t\tif (words[j].Length == max) \n\t\t\t\t{\n\t\t\t\t\treturn words[j];\n\
    \t\t\t\t}\n\t\t\t\tif (words[i].Length > words[j].Length) \n\t\t\t\t{\n\t\t\t\t\
    \tcounter = words[i].Length;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcounter\
    \ = words[j].Length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplyyl9mhx.d(23): Error: no property `Length` for type `string`

    /tmp/tmplyyl9mhx.d(30): Error: no property `Length` for type `string`

    /tmp/tmplyyl9mhx.d(30): Error: no property `Length` for type `string`

    /tmp/tmplyyl9mhx.d(32): Error: no property `Length` for type `string`

    /tmp/tmplyyl9mhx.d(36): Error: no property `Length` for type `string`

    /tmp/tmplyyl9mhx.d(40): Error: no property `Length` for type `string`

    /tmp/tmplyyl9mhx.d(40): Error: no property `Length` for type `string`

    /tmp/tmplyyl9mhx.d(42): Error: no property `Length` for type `string`

    /tmp/tmplyyl9mhx.d(46): Error: no property `Length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplyyl9mhx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0, num = 0;\n    foreach (string s in words)\n   \
    \ {\n        int c = count(s);\n        if(c>max)\n        {\n            max\
    \ = c;\n            num = s;\n        }\n    }\n    return num;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nYou should change this part:\n````\nforeach (string\
    \ s in words)\n    {\n        int c = count(s);\n        if(c>max)\n        {\n\
    \            max = c;\n            num = s;\n        }\n    }\n    return num;\n\
    }\n````\n<|/ c |>\n<| c |>\n: That is wrong. Think about it. You only want to\
    \ iterate through the array one time. Hence the foreach.\n<|/ c |>\n<| c |>\n\
    , Oh I see what you mean now. Yes, it only iterates once.\n<|/ c |>\n<| a |>\n\
    You can use the LINQ Aggregate method to do this in a very concise way:\n<code>\n\
    string maxWord = words.Aggregate((a, b) => a.Length > b.Length ? a : b);\n</code>\n\
    <|/ a tags=c#,winforms,arrays,loops dscore=1 |>\n<| a tags=c#,winforms,arrays,loops\
    \ dscore=1 |>\n<code>\nstring array = \"Hello World\";\nchar[] charArray = array.ToCharArray();\n\
    Array.Sort(charArray);\nConsole.WriteLine(charArray.Distinct().First());\n</code>\n\
    <|/ a |>\n<| c |>\nThank you for your answer, but i do not want to use any array\
    \ methods. I am looking for a solution that does not use any array methods.\n\
    <|/ c |>\n<| c |>\n: Why do you think you can't use array methods?\n<|/ c |>\n\
    <| c |>\n: They weren't in the spec? http://msdn.microsoft.com/en-us/library/vstudio/bb338049(v=vs.100).aspx\n\
    <|/ c |>\n<| c |>\n: What is the criteria for deciding whether to use array methods\
    \ or not? The most obvious solution is to not use array methods. This is obviously\
    \ a homework assignment and we have no idea what your teacher wants or needs.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nstring maxWord = string.Empty;\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj8wfmum_.d(20): Error: found `in` when expecting `;`

    /tmp/tmpj8wfmum_.d(31): Error: declaration expected, not `<`

    /tmp/tmpj8wfmum_.d(39): Error: declaration expected, not `if`

    /tmp/tmpj8wfmum_.d(42): Error: no identifier for declarator `num`

    /tmp/tmpj8wfmum_.d(42): Error: declaration expected, not `=`

    /tmp/tmpj8wfmum_.d(43): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj8wfmum_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int len = words.length;\n    if (len < 1)\n        throw new\
    \ Exception(\"Invalid input\");\n    \n    int maxChars = words[0].size();\n \
    \   for(int i = 1; i < len; i++)\n    {\n        int curChars = words[i].size();\n\
    \        if (curChars > maxChars)\n        {\n            maxChars = curChars;\n\
    \        }\n    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr3djrcet.d(32): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr3djrcet.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    bool flag = false;\n    int counts = std.typecons.max;\n   \
    \ string maxWord = \"\";\n    string maxVal = \"\";\n    foreach(string word in\
    \ words){\n        bool flag = false;\n        foreach(char c in word){\n    \
    \        if(word.count(c) == counts){\n                flag = true;\n        \
    \        maxVal = word;\n                maxWord = word;\n                counts\
    \ = std.typecons.max;\n                break;\n            }\n            else\
    \ if(word.count(c) < counts){\n                counts = word.count(c);\n     \
    \           maxVal = word;\n                maxWord = word;\n            }\n \
    \       }\n        if(flag == false){\n            foreach(char c in word){\n\
    \                if(word.count(c) == counts){\n                    flag = true;\n\
    \                    maxVal = word;\n                    maxWord = word;\n   \
    \                 counts = std.typecons.max;\n                    break;\n   \
    \             }\n            }\n        }\n    }\n    return maxWord;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpocdhcrip.d(23): Error: found `in` when expecting `;`

    /tmp/tmpocdhcrip.d(25): Error: found `in` when expecting `;`

    /tmp/tmpocdhcrip.d(40): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpocdhcrip.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int[int] counts;\n    foru(int i = 0; i < words.length; i++)\
    \ \n    {\n        counts[count(words[i])] += 1;\n    }\n    return words[argmax(counts)];\n\
    }\n</code>\n<|/ a tags=algorithm,performance,string,c++ dscore=0 |>\n<| c |>\n\
    This approach does not take advantage of the fact that the question is specifically\
    \ asking for lexicographical order as opposed to alphabetical order.\n<|/ c |>\n\
    <| c |>\nThis is exactly what I was looking for and your solution is amazing!\
    \ I'm going to study your code and understand it better but to start off I'm going\
    \ to take a guess that this approach uses some sort of hashing algorithm that\
    \ makes it so fast and efficient?\n<|/ c |>\n<| c |>\nYes I used a hash table\
    \ and I implemented it using C++.\n<|/ c |>\n<| c |>\nThe code above is very inefficient\
    \ since it computes counts[words[i]] on every iteration, whereas all you need\
    \ is to store counts[0] into counts[i] and perform a one-time assignment when\
    \ counts[0] changes. Also, it's missing a return statement, so it won't work as\
    \ written.\n<|/ c |>\n<| c |>\nI wrote it in Python. I'm not really sure whether\
    \ it's an efficient solution in C++ but I think that it is.\n<|/ c |>\n<| a |>\n\
    <code>\nstring find_max(string words[], int n, string word){\n    vector<int>\
    \ counts(word.length(), 0);\n    for(int i = 0; i < words.length; i++){\n    \
    \    for(int j = word.size(); j > 0; j--){\n            if(words[i][j-1] != word[j])\
    \ break;\n            counts[j-1]++;\n        }\n        if(counts[0] >= counts[i])\
    \ counts[0] = counts[i];\n    }\n    return words[counts[word.length()-1]];\n\
    }\n</code>\n<|/ a dscore=0 tags=algorithm,performance,string,c++ |>\n<| c |>\n\
    This approach does not take advantage of the fact that the question is specifically\
    \ asking for lexicographical order as opposed to alphabetical order.\n<|/ c |>\n\
    <| a |>\n<code>\n#include <bits/stdc++.h>\nusing namespace std;\nunittest\n{\n\
    \    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"\
    string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpccdgeo2_.d(20): Error: found `i` when expecting `.` following int

    /tmp/tmpccdgeo2_.d(20): Error: found `=` when expecting identifier following `int`.

    /tmp/tmpccdgeo2_.d(20): Error: found `0` when expecting `,`

    /tmp/tmpccdgeo2_.d(20): Error: expression expected, not `;`

    /tmp/tmpccdgeo2_.d(20): Error: found `i` when expecting `,`

    /tmp/tmpccdgeo2_.d(20): Error: expression expected, not `<`

    /tmp/tmpccdgeo2_.d(20): Error: found `words` when expecting `,`

    /tmp/tmpccdgeo2_.d(20): Error: found `;` when expecting `,`

    /tmp/tmpccdgeo2_.d(21): Error: found `{` when expecting `;` following statement

    /tmp/tmpccdgeo2_.d(24): Error: declaration expected, not `return`

    /tmp/tmpccdgeo2_.d(25): Error: unrecognized declaration

    /tmp/tmpccdgeo2_.d(32): Error: unterminated character constant

    /tmp/tmpccdgeo2_.d(32): Error: unterminated character constant

    /tmp/tmpccdgeo2_.d(38): Error: unterminated character constant

    /tmp/tmpccdgeo2_.d(38): Error: unterminated character constant

    /tmp/tmpccdgeo2_.d(41): Error: unterminated char'
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int m = 0, n = 0;\n    map<string, int> m;\n    foreach (string\
    \ w in words)\n    {\n        n = m[w];\n        if (n > m)\n        {\n     \
    \       m = n;\n        }\n        else\n        {\n            if (n < m)\n \
    \           {\n                m = n;\n            }\n        }\n        m[w]\
    \ += 1;\n    }\n    return m.keys.toArray()[0]; \n}\n</code>\n<|/ a dscore=1 tags=string,python\
    \ |>\n<| a |>\nA possible solution is to count the unique characters in each word\
    \ in the array and find the word which has the highest frequency of unique characters.\n\
    <code>\ndef find_max(words):\n    word_dict = {}\n    for i in words:\n      \
    \  unique_chars = set(i.lower())\n        if len(unique_chars) > len(word_dict):\n\
    \            word_dict = unique_chars\n    \n    return word_dict.values()\n</code>\n\
    <|/ a tags=string,python dscore=1 |>\n<| a tags=string,python |>\nTry this one:\n\
    <code>\nfrom collections import Counter\ndef find_max(words):\n    cnt = Counter()\n\
    \    for word in words:\n        cnt.update(set(word.lower()))\n    max_length\
    \ = max(cnt.values())\n    for key, value in cnt.items():\n        if value ==\
    \  max_length:\n            return key\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    You can use the collections.Counter class:\n<code>\nfrom collections import Counter\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb7_8t47i.d(20): Error: found `>` when expecting `.` following int

    /tmp/tmpb7_8t47i.d(21): Error: found `in` when expecting `;`

    /tmp/tmpb7_8t47i.d(39): Error: declaration expected, not `<`

    /tmp/tmpb7_8t47i.d(76): Error: declaration expected, not `assert`

    /tmp/tmpb7_8t47i.d(77): Error: declaration expected, not `assert`

    /tmp/tmpb7_8t47i.d(78): Error: declaration expected, not `assert`

    /tmp/tmpb7_8t47i.d(79): Error: declaration expected, not `assert`

    /tmp/tmpb7_8t47i.d(80): Error: declaration expected, not `assert`

    /tmp/tmpb7_8t47i.d(81): Error: declaration expected, not `assert`

    /tmp/tmpb7_8t47i.d(82): Error: declaration expected, not `assert`

    /tmp/tmpb7_8t47i.d(83): Error: declaration expected, not `assert`

    /tmp/tmpb7_8t47i.d(84): Error: declaration expected, not `assert`

    /tmp/tmpb7_8t47i.d(85): Error: declaration expected, not `assert`

    /tmp/tmpb7_8t47i.d(86): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb7_8t47i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 1;\n    string maxString = \"\";\n    for (int i =\
    \ 0; i < words.length; i++) \n    {\n        if (words[i].length() > max)\n  \
    \      {\n            maxString  = words[i];\n            max = words[i].length();\n\
    \        }\n    }\n    if (max == 1) return maxString;\n    \n    int min = 1;\n\
    \    for (int i = 0; i < words.length; i++) \n    {\n        if (words[i].length()\
    \ >= min) \n        {\n            if (words[i].length() > max) \n           \
    \     maxString = words[i];\n            min = words[i].length();\n        }\n\
    \    }\n    return maxString;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0schm1yy.d(23): Error: no property `length` for type `string`

    /tmp/tmp0schm1yy.d(26): Error: no property `length` for type `string`

    /tmp/tmp0schm1yy.d(34): Error: no property `length` for type `string`

    /tmp/tmp0schm1yy.d(36): Error: no property `length` for type `string`

    /tmp/tmp0schm1yy.d(38): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0schm1yy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    /*\n    Your code here\n    */\n    string result = \"\";\n\
    \    int max = 1;\n    foreach (string word in words)\n    {\n        int count\
    \ = 0;\n        foreach (char c in word)\n        {\n            if (c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n            {\n          \
    \      count += 1;\n            }\n        }\n        if (count > max)\n     \
    \   {\n            max = count;\n            result = word;\n        }\n    }\n\
    \    if (result == \"\")\n    {\n        foreach (string word in words)\n    \
    \    {\n            int count = 0;\n            foreach (char c in word)\n   \
    \         {\n                if (c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u')\n                {\n                    count += 1;\n         \
    \       }\n            }\n            if (count > max)\n            {\n      \
    \          max = count;\n                result = word;\n            }\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps_512obp.d(24): Error: found `in` when expecting `;`

    /tmp/tmps_512obp.d(27): Error: found `in` when expecting `;`

    /tmp/tmps_512obp.d(42): Error: found `in` when expecting `;`

    /tmp/tmps_512obp.d(45): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps_512obp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> map;\n    \n    for (auto word: words) {\n\
    \        map[word] = 0;\n    }\n    \n    sort(words.begin(), words.end());\n\
    \    \n    for (auto word: words) {\n        map[word]++;\n    }\n    \n    int\
    \ max = words[0].length();\n    \n    for (auto word: words) {\n        if (map[word]\
    \ > map[words[words.find(word)]]) {\n            max = map[word];\n        }\n\
    \    }\n    \n    return words[words.find(max)]; \n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 tags=c++ |>\nHere's my version. It returns the same output\
    \ as the accepted solution, although I'm sure there's a more elegant way! I've\
    \ also tried to make it as simple as possible, so it uses only one map.\n<code>\n\
    #include <string>\n#include <vector>\n#include <map>\nusing namespace std;\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe858sh5f.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmpe858sh5f.d(21): Error: no identifier for declarator `word`

    /tmp/tmpe858sh5f.d(21): Error: expression expected, not `:`

    /tmp/tmpe858sh5f.d(21): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmpe858sh5f.d(27): Error: no identifier for declarator `word`

    /tmp/tmpe858sh5f.d(27): Error: expression expected, not `:`

    /tmp/tmpe858sh5f.d(27): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmpe858sh5f.d(33): Error: no identifier for declarator `word`

    /tmp/tmpe858sh5f.d(33): Error: expression expected, not `:`

    /tmp/tmpe858sh5f.d(33): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmpe858sh5f.d(41): Error: declaration expected, not `<`

    /tmp/tmpe858sh5f.d(44): Error: unterminated character constant

    /tmp/tmpe858sh5f.d(44): Error: unterminated character constant

    /tmp/tmpe858sh5f.d(44): Error: unterminated character constant

    /tmp/tmpe858sh5f.d(44): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe858sh5f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> wordCount;\n    map<string, int> tempCount;\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    unordered_set<string> names;\n    for (auto word : words)\n\
    \    {\n        auto chars = word.length();\n        if (names.count(chars))\n\
    \        {\n            if (names.at(chars) < word)\n                names[chars]\
    \ = word;\n        }\n        else\n            names[chars] = word;\n    }\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6t0t3vs7.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmp6t0t3vs7.d(20): Error: no identifier for declarator `word`

    /tmp/tmp6t0t3vs7.d(20): Error: expression expected, not `:`

    /tmp/tmp6t0t3vs7.d(20): Error: found `words` when expecting `;` following `for`
    condition

    /tmp/tmp6t0t3vs7.d(31): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6t0t3vs7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> max_count; int max_length = 0;\n    foreach(string\
    \ word, words){\n        foreach(char c, word){\n            if(!max_count.containsKey(c)){\n\
    \                max_length++;\n                max_count.put(c,1);\n        \
    \    }\n            else{\n                max_count.get(c);\n            }\n\
    \        }\n    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsieirqk_.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmpsieirqk_.d(20): Error: no identifier for declarator `words`

    /tmp/tmpsieirqk_.d(20): Error: found `)` when expecting `;`

    /tmp/tmpsieirqk_.d(21): Error: no identifier for declarator `word`

    /tmp/tmpsieirqk_.d(21): Error: found `)` when expecting `;`

    /tmp/tmpsieirqk_.d(30): Error: found `}` when expecting `)`

    /tmp/tmpsieirqk_.d(31): Error: found `unittest` instead of statement

    /tmp/tmpsieirqk_.d(46): Error: found `void` when expecting `)`

    /tmp/tmpsieirqk_.d(46): Error: found `{` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsieirqk_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int max = 0;\n    string result = \"\";\n    for(int i = 0;\
    \ i < words.length; ++i)\n        for(int j = 1; j <= words[i].length(); j++)\n\
    \            if(words[i].length() > max)\n            {\n                max =\
    \ words[i].length();\n                result = words[i];\n            }\n    return\
    \ result;\n}\n</code>\n<|/ a |>\n<| c |>\nThe code as posted does not compile;\
    \ there are several syntax errors.\n<|/ c |>\n<| c |>\nThanks for your comment.\
    \ I edited my answer and included a full working code.\n<|/ c |>\n<| a tags=c#,sorting,arrays,unique\
    \ |>\nYou don't need a Linq solution just for that. You can do it in O(n) using\
    \ a HashSet and just iterate over the words in the dictionary and add to the HashSet.\
    \ The time complexity of the HashSet.Add is O(1) so you get an O(n) solution.\n\
    <code>\nstring findMax(string []words)\n{\n    HashSet<string> hs = new HashSet<string>();\n\
    \    string result = \"\";\n    foreach(string word in words)\n        if(!hs.Add(word))\n\
    \            result = word;\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nHe said \"with O(n) solution\", not \"without Linq solution\"\n<|/ c\
    \ |>\n<| c |>\nThanks for your comment, you are right and I corrected my answer.\n\
    <|/ c |>\n<| c |>\nO(n) solution is also the most optimal solution, because it\
    \ doesn't iterate over the input twice (once to sort, and once for finding max).\n\
    <|/ c |>\n<| a dscore=1 |>\nMy first idea was to use a dictionary to hold the\
    \ unique words with a int counter and to compare words with the same length with\
    \ the counter from the dictionary:\n<code>\nstatic string findMax(string []words)\n\
    {\n    Dictionary<string, int> dictionary = new Dictionary<string, int>();\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps9kfb32h.d(30): Error: declaration expected, not `<`

    /tmp/tmps9kfb32h.d(33): Error: semicolon expected, not `several`

    /tmp/tmps9kfb32h.d(33): Error: semicolon expected, not `errors`

    /tmp/tmps9kfb32h.d(34): Error: identifier expected following `.` instead of `<`

    /tmp/tmps9kfb32h.d(34): Error: no identifier for declarator `errors`

    /tmp/tmps9kfb32h.d(34): Error: declaration expected, not `<`

    /tmp/tmps9kfb32h.d(39): Error: unterminated character constant

    /tmp/tmps9kfb32h.d(45): Error: declaration expected, not `foreach`

    /tmp/tmps9kfb32h.d(48): Error: declaration expected, not `return`

    /tmp/tmps9kfb32h.d(49): Error: unrecognized declaration

    /tmp/tmps9kfb32h.d(59): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps9kfb32h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int n = words.length;\n    int count = std.length(words);\n\
    \    \n    int best = std.length(words[0]);\n    for(int i=1; i<n; i++)\n    {\n\
    \        int tmp = std.length(words[i]);\n        if(tmp > best)\n        {\n\
    \            best = tmp;\n            best = i;\n        }\n    }\n    \n    return\
    \ words[best];\n}\n</cell>\n<cell>\nimport std.random;\nimport std.randomstream;\n\
    /*\nWrite a function that accepts an array of strings and an integer n, \nwhere\
    \ n is the number of random words from the array of strings. Return the n random\
    \ words from the array of strings. \nIf n is not present in the array, add n random\
    \ words from other arrays to the array of strings. \nIf there are less strings\
    \ than n elements, choose all strings from array. \n*/\nunittest\n{\n    alias\
    \ candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp64m1neza.d(35): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp64m1neza.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string result;\n    int max_count = -1;\n    for(int i = 0;\
    \ i < words.length; ++i)\n    {\n        int current_count = count(words[i]);\n\
    \        if(current_count > max_count)\n        {\n            max_count = current_count;\n\
    \            result = words[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp33tky6ld.d(23): Error: undefined identifier `count`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp33tky6ld.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    var maxCharCount = 0;\n    var longest = 0;\n    foreach(string\
    \ word in words)\n    {\n        int cCount = 0;\n        foreach(char ch in word)\n\
    \        {\n            cCount += charCount(ch);\n        }\n        if(cCount\
    \ > maxCharCount)\n        {\n            maxCharCount = cCount;\n           \
    \ longest = word;\n        }\n    }\n    return longest;\n}\nunittest\n{\n   \
    \ alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5trfutcj.d(21): Error: found `in` when expecting `;`

    /tmp/tmp5trfutcj.d(24): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5trfutcj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map<string, int> m;\n    map<int, string> m2;\n    \n    map<string,\
    \ int>::iterator it;\n    int count = 0;\n    map<int, string>::iterator it2;\n\
    \    int count2 = 0;\n    \n    for(it = m.begin(); it != m.end(); it++)\n   \
    \ {\n        int n = it->second;\n        \n        for(it2 = m2.begin(); it2\
    \ != m2.end(); it2++)\n        {\n            int n2 = it2->second;\n        \
    \    \n            if(n == n2)\n            {\n                if(it2->first <\
    \ it->first)\n                {\n                    string temp = it->first;\n\
    \                    it->first = it2->first;\n                    it2->first =\
    \ temp;\n                }\n                \n                it->second++;\n\
    \                it2->second++;\n            }\n        }\n    }\n    \n    for(it\
    \ = m2.begin(); it != m2.end(); it++)\n    {\n        if(it->second > count)\n\
    \        {\n            count = it->second;\n        }\n    }\n    \n    for(it\
    \ = m2.begin(); it != m2.end(); it++)\n    {\n        if(it->second > count2)\n\
    \        {\n            count2 = it->second;\n        }\n    }\n    \n    if(count2\
    \ == count)\n    {\n        string temp = count;\n        count = count2;\n  \
    \      count2 = temp;\n    }\n    \n    return it->first;\n}\nunittest\n{\n  \
    \  alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"\
    ]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"\
    enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n\
    \    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp72sftpav.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmp72sftpav.d(20): Error: found `,` when expecting `.` following int

    /tmp/tmp72sftpav.d(20): Error: found `>` when expecting `;` following statement

    /tmp/tmp72sftpav.d(22): Error: found `>` when expecting `.` following int

    /tmp/tmp72sftpav.d(22): Error: found `:` when expecting identifier following `int`.

    /tmp/tmp72sftpav.d(22): Error: found `:` when expecting `;` following statement

    /tmp/tmp72sftpav.d(24): Error: found `,` when expecting `.` following int

    /tmp/tmp72sftpav.d(24): Error: found `>` when expecting `;` following statement

    /tmp/tmp72sftpav.d(24): Error: found `:` instead of statement

    /tmp/tmp72sftpav.d(29): Error: use `.` for member lookup, not `->`

    /tmp/tmp72sftpav.d(33): Error: use `.` for member lookup, not `->`

    /tmp/tmp72sftpav.d(37): Error: use `.` for member lookup, not `->`

    /tmp/tmp72sftpav.d(37): Error: use `.` for member lookup, not `->`

    /tmp/tmp72sftpav.d(39): Error: use `.` for member lookup, not `->`

    /tmp/tm'
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    // Write your function here\n    int max_unique = words[0].unique();\n\
    \    int max_index = -1;\n    for (int i = 1; i < words.length; ++i) {\n     \
    \   int unique = words[i].unique();\n        if (unique > max_unique) {\n    \
    \        max_unique = unique;\n            max_index = i;\n        } else if (unique\
    \ == max_unique) {\n            if (words[max_index] < words[i]) {\n         \
    \       max_index = i;\n            }\n        }\n    }\n    return words[max_index];\n\
    }\n</code>\n<|/ a dscore=3 tags=arrays,c,algorithm |>\n<| c |>\nIt would be nice\
    \ if you could add some explanation of your solution.\n<|/ c |>\n<| a tags=arrays,c,algorithm\
    \ |>\n<code>\n// Given an array of integers arr[] and a positive integer n.\n\
    // Find a pair of integers (x, y) such that x is less than or equal to\n// n and\
    \ y is greater than or equal to 0 and y is less than or equal to\n// arr[x] and\
    \ x is greater than or equal to arr[y].\n// Return x if it is possible to find\
    \ the pair otherwise return -1.\nunittest\n{\n    alias candidate = find_max;\n\
    \n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"\
    name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\"\
    , \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"])\
    \ == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"\
    footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\"\
    , \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"\
    mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"\
    a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdz4dncay.d(35): Error: declaration expected, not `<`

    /tmp/tmpdz4dncay.d(51): Error: declaration expected, not `assert`

    /tmp/tmpdz4dncay.d(52): Error: declaration expected, not `assert`

    /tmp/tmpdz4dncay.d(53): Error: declaration expected, not `assert`

    /tmp/tmpdz4dncay.d(54): Error: declaration expected, not `assert`

    /tmp/tmpdz4dncay.d(55): Error: declaration expected, not `assert`

    /tmp/tmpdz4dncay.d(56): Error: declaration expected, not `assert`

    /tmp/tmpdz4dncay.d(57): Error: declaration expected, not `assert`

    /tmp/tmpdz4dncay.d(58): Error: declaration expected, not `assert`

    /tmp/tmpdz4dncay.d(59): Error: declaration expected, not `assert`

    /tmp/tmpdz4dncay.d(60): Error: declaration expected, not `assert`

    /tmp/tmpdz4dncay.d(61): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdz4dncay.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int numChars = count(words);\n    int maxCharNum = numChars;\n\
    \    int index;\n    for(int i = 0; i < words.length; ++i) {\n        index =\
    \ numChars - 1;\n        for(int j = numChars - 1; j >= 0; --j) \n           \
    \ if(words[i].compare(words[j]) > 0) \n                index = j;\n        if(index\
    \ != numChars - 1) {\n            swap(words[i], words[index]);\n            --numChars;\n\
    \            if(numChars == 0)\n                maxCharNum = maxCharNum - 1;\n\
    \        }\n    }\n    return words[maxCharNum];\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdqb9yutl.d(19): Error: undefined identifier `count`

    /tmp/tmpdqb9yutl.d(25): Error: no property `compare` for type `string`

    /tmp/tmpdqb9yutl.d(28): Error: undefined identifier `swap`, did you mean template
    `wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdqb9yutl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n   int[] nums=new int[100];\n   int count=0;\n   foreach (string\
    \ w; words)\n   {\n      int index=0;\n      foreach(char c in w)\n         if\
    \ (nums[c]<nums[index])\n         {\n            index++;\n            if (nums[index]\
    \ > nums[c])\n            {\n               string temp=w;\n               w=words[index];\n\
    \               words[index]=temp;\n            }\n         }\n      nums[w]++;\n\
    \      count++;\n   }\n   return words[count-1];\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8p3ji7o4.d(24): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8p3ji7o4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n\t/*\n\tStart by grouping all words that have same number of unique\
    \ characters\n\tinto a single list.\n\t*/\n\tmap<string, int> countMap;\n\tfor\
    \ (int i = 0; i < words.length; i++) \n\t{\n\t\tstring curr = words[i];\n\t\t\
    int count = 0;\n\t\tfor (int j = 0; j < words.length; j++)\n\t\t{\n\t\t\tif (i\
    \ != j && curr == words[j])\n\t\t\t\tcount++;\n\t\t}\n\t\tif (count > 0) \n\t\t\
    {\n\t\t\tcountMap[curr] = count;\n\t\t}\n\t}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxsbkabvg.d(23): Error: found `>` when expecting `.` following int

    /tmp/tmpxsbkabvg.d(38): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxsbkabvg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int count=0;\n    string word = null;\n    for(int i=0;i<words.length();i++)\n\
    \    {\n        string temp = words[i];\n        for(int j=i+1;j<words.length();j++)\n\
    \        {\n            string temp = words[j];\n            int count = std.algorithmic.unique(temp);\n\
    \            if(count>count)\n            {\n                count = std.algorithmic.unique(temp);\n\
    \                word = temp;\n            }\n        }\n    }\n    return word;\n\
    }\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwqpvnb7t.d(21): Error: no property `length` for type `string[]`

    /tmp/tmpwqpvnb7t.d(24): Error: no property `length` for type `string[]`

    /tmp/tmpwqpvnb7t.d(26): Error: variable `temp` is shadowing variable `tmpwqpvnb7t.find_max.temp`

    /tmp/tmpwqpvnb7t.d(27): Error: undefined identifier `algorithmic` in package `std`

    /tmp/tmpwqpvnb7t.d(27): Error: variable `count` is shadowing variable `tmpwqpvnb7t.find_max.count`

    /tmp/tmpwqpvnb7t.d(30): Error: undefined identifier `algorithmic` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwqpvnb7t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    string maxWord = words[0];\n    int maxNum = 0;\n    int len\
    \ = words.length;\n    for(int i = 1; i < len; ++i)\n    {\n        int numUnique\
    \ = numUniqueChars(words[i]);\n        if(numUnique > maxNum)\n        {\n   \
    \         maxNum = numUnique;\n            maxWord = words[i];\n        }\n  \
    \  }\n    return maxWord;\n}\n/*\nWrite a function that accepts an array of strings\
    \ and an integer 'n'.\n    The function should return an array of strings of size\
    \ 'n' with all\n    unique characters of all the strings in the given array.\n\
    unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
    , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
    , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"\
    ]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n \
    \   assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"]) ==\
    \ \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"])\
    \ == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt15lc6b7.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt15lc6b7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int i, j, n, count_unique = 0;\n    string word;\nunittest\n\
    {\n    alias candidate = find_max;\n\n    assert(candidate([\"name\", \"of\",\
    \ \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\", \"game\"\
    ]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"\
    );\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
    play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
    we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"\
    we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
    this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"])\
    \ == \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\"\
    );\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc7l4wbnb.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc7l4wbnb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164289
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    int counter = 1;\n    for(int i = 0; i < words.length; i++)\n\
    \    {\n        if (words[i].length() > counter)\n        {\n            counter\
    \ = words[i].length();\n        }\n    }\n    \n    int max = 0;\n    for(int\
    \ i = 0; i < words.length; i++)\n    {\n        if (words[i].length() == max)\n\
    \        {\n            continue;\n        }\n        \n        if (words[i].length()\
    \ > max)\n        {\n            max = words[i].length();\n        }\n    }\n\
    \    \n    for(int i = 0; i < words.length; i++)\n    {\n        if (words[i].length()\
    \ != max)\n        {\n            continue;\n        }\n        \n        if (words[i].length()\
    \ > counter)\n        {\n            counter = words[i].length();\n        }\n\
    \    }\n    \n    for(int i = 0; i < words.length; i++)\n    {\n        if (words[i].length()\
    \ > counter)\n        {\n            counter = words[i].length();\n        }\n\
    \    }\n    \n    return words[counter];\n}\nunittest\n{\n    alias candidate\
    \ = find_max;\n\n    assert(candidate([\"name\", \"of\", \"string\"]) == \"string\"\
    );\n    assert(candidate([\"name\", \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"\
    aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"\
    cba\"]) == \"abc\");\n    assert(candidate([\"play\", \"this\", \"game\", \"of\"\
    , \"footbott\"]) == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"\
    gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"\
    a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"this\", \"\
    is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) == \"b\"\
    );\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n}\nvoid\
    \ main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2x6jagrs.d(22): Error: no property `length` for type `string`

    /tmp/tmp2x6jagrs.d(24): Error: no property `length` for type `string`

    /tmp/tmp2x6jagrs.d(31): Error: no property `length` for type `string`

    /tmp/tmp2x6jagrs.d(36): Error: no property `length` for type `string`

    /tmp/tmp2x6jagrs.d(38): Error: no property `length` for type `string`

    /tmp/tmp2x6jagrs.d(44): Error: no property `length` for type `string`

    /tmp/tmp2x6jagrs.d(49): Error: no property `length` for type `string`

    /tmp/tmp2x6jagrs.d(51): Error: no property `length` for type `string`

    /tmp/tmp2x6jagrs.d(57): Error: no property `length` for type `string`

    /tmp/tmp2x6jagrs.d(59): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2x6jagrs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164290
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
    \ an array of strings.\n    The array contains different words. Return the word\
    \ with maximum number\n    of unique characters. If multiple strings have maximum\
    \ number of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
    \ words) \n{\n    map <int, int> m = new map();\n    foreach (string word in words)\n\
    \    {\n        auto it = m.find(word.length);\n        if (it == m.end())\n \
    \       {\n            int i = 1;\n            m.insert(pair<int, int>(word.length,\
    \ i++));\n        }\n        else\n        {\n            int i = it->second;\n\
    \            it->second = i;\n        }\n    }\n    \n    int maxLen = -1;\n \
    \   int maxI = -1;\n    foreach(auto it, m)\n    {\n        if (maxLen < it->first)\n\
    \        {\n            maxLen = it->first;\n            maxI = it->second;\n\
    \        }\n    }\n    \n    return words[maxI];\n}\n</cell>\n<text>\nExercise\
    \ 3\nunittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"\
    name\", \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\",\
    \ \"enam\", \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\"\
    , \"cc\"]) == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\"\
    );\n    assert(candidate([\"play\", \"this\", \"game\", \"of\", \"footbott\"])\
    \ == \"footbott\");\n    assert(candidate([\"we\", \"are\", \"gonna\", \"rock\"\
    ]) == \"gonna\");\n    assert(candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"\
    ]) == \"nation\");\n    assert(candidate([\"this\", \"is\", \"a\", \"prrk\"])\
    \ == \"this\");\n    assert(candidate([\"b\"]) == \"b\");\n    assert(candidate([\"\
    play\", \"play\", \"play\"]) == \"play\");\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbd5j61mi.d(19): Error: found `,` when expecting `.` following int

    /tmp/tmpbd5j61mi.d(19): Error: found `int` when expecting identifier following
    `int`.

    /tmp/tmpbd5j61mi.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmpbd5j61mi.d(20): Error: found `in` when expecting `;`

    /tmp/tmpbd5j61mi.d(26): Error: found `,` when expecting `.` following int

    /tmp/tmpbd5j61mi.d(26): Error: found `int` when expecting identifier following
    `int`.

    /tmp/tmpbd5j61mi.d(26): Error: found `>` when expecting `,`

    /tmp/tmpbd5j61mi.d(30): Error: use `.` for member lookup, not `->`

    /tmp/tmpbd5j61mi.d(31): Error: use `.` for member lookup, not `->`

    /tmp/tmpbd5j61mi.d(37): Error: basic type expected, not `auto`

    /tmp/tmpbd5j61mi.d(37): Error: no identifier for declarator `_error_`

    /tmp/tmpbd5j61mi.d(37): Error: found `auto` when expecting `;`

    /tmp/tmpbd5j61mi.d(39): Error: use `.` for member lookup, not `->`

    /tmp/tmpbd5j61mi.d(41): Error: use `.` for member lookup, not `->`

    /tmp/tmpbd5j61mi.d(42): Error: use `.` '
  stdout: ''
  timestamp: 1660164289
