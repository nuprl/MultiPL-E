name: HumanEval_2_truncate_number
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Given a positive floating point\
  \ number, it can be decomposed into\n    and integer part (largest integer smaller\
  \ than given number) and decimals\n    (leftover part always smaller than 1).\n\n\
  \    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n\
  \    \n*/\nfloat truncate_number(float number) \n"
tests: "unittest\n{\n    alias candidate = truncate_number;\n\n    assert(candidate(3.5)\
  \ == 0.5);\n    assert(candidate(1.25) == 0.25);\n    assert(candidate(123.0) ==\
  \ 0.0);\n}\nvoid main(){}"
completions: ["{\n\tlong int integerPart;\n    long int decimalPart;", "{\n  int integer_part,\
    \ decimals_part;\n  float fraction;\n  \n  integer_part = trunc(number);\n  \n\
    \  fraction = number - integer_part;\n  \n  // If fraction is smaller than the\
    \ smallest float representable by float\n  // type, then it cannot be exactly\
    \ represented by float, and we return \n  // infinity instead.\n  // This means\
    \ that in case of round-to-nearest-even we will return the\n  // same float.\n\
    \  if (fraction < std::numeric_limits<float>::lowest()) {\n    return std::numeric_limits<float>::infinity();\n\
    \  }\n  \n  // We want to truncate to nearest-even which means we round down to\
    \ the\n  // same float if it can't be exactly represented. This will always work\n\
    \  // because we know that fraction is smaller than the smallest float\n  // representable\
    \ by float.\n  \n  decimals_part = round(fraction);\n  \n  return float(integer_part)\
    \ + float(decimals_part);\n}\n\"\"\"\n    return code.safe_substitute(float_number=float_number)",
  "{\n    float integer_part = floor(number);\n    float decimals    = number - integer_part;\n\
    \    return integer_part;\n}", "{\n    int\t\tfrac_part;\n\tint\t\tint_part;\n\
    \tint\t\tnum_decimals;", "{\n    if (number < 0)\n    {\n        throw new std.exception.DomainError(\n\
    \            \"truncate_number\", \"The given number can't be negative.\");\n\
    \    }\n    float trunc_part = number % 1;\n    float int_part = (number - trunc_part)\
    \ * int(number);\n    return trunc_part;\n}", "{\n    int intpart = 0;\n    int\
    \ decpart = 0;", "{\n    int i = trunc(number);\n    if (i==number)\n        return\
    \ number;\n    return i - number * trunc(number / i);\n}", "{\n    int digits\
    \ = (int)(std.math.ceil(number * std.math.pow(10.0, std.math.ceil(std.math.log((float)number)\
    \ / std.math.log10.0)) - 1.0));\n    int decimals = digits - number * std.math.pow(10.0,\
    \ std.math.floor(std.math.log((float)number) / std.math.log10.0));\n    return\
    \ number * std.math.pow(10.0, decimals);\n}", "{\n    bool isNegative = number.lessThan(0);",
  "{\n    int integer_part;\n    int decimal_part = int(number);\n    \n    if (number\
    \ >= 1)\n    {\n        integer_part = int(floor(number));\n        decimal_part\
    \ = number - integer_part;\n    }\n    else\n    {\n        integer_part = INT_MIN;\n\
    \        decimal_part = float(0);\n    }\n    \n    return float(decimal_part);\n\
    }", "{\n\tint integerPart = int(number);\n\tfloat decimalPart = number - integerPart;",
  "{\n    float remainder;\n    int decimal_part = int(number % 1);\n    number =\
    \ number * 100;\n    int integer_part = int(number % 100);\n    number = number\
    \ * 10;\n    int decimal_part_2 = int(number % 1);\n    number = number * 100;\n\
    \    int integer_part_2 = int(number % 100);\n    number = number * 10;\n    float\
    \ temp = number;\n    float decimal_part_3;\n    float integer_part_3;\n    float\
    \ decimal_part_4;\n    float integer_part_4;\n    float decimal_part_5;\n    float\
    \ integer_part_5;\n    float decimal_part_6;\n    float integer_part_6;\n    float\
    \ decimal_part_7;\n    float integer_part_7;\n    float decimal_part_8;\n    float\
    \ integer_part_8;\n    float decimal_part_9;\n    float integer_part_9;\n    float\
    \ decimal_part_10;\n    float integer_part_10;\n    float decimal_part_11;\n \
    \   float integer_part_11;\n    float decimal_part_12;\n    float integer_part_12;\n\
    \    float decimal_part_13;\n    float integer_part_13;\n    float decimal_part_14;\n\
    \    float integer_part_14;\n    float decimal_part_15;\n    float integer_part_15;\n\
    \    float decimal_part_16;\n    float integer_part_16;\n    float decimal_part_17;\n\
    \    float integer_part_17;\n    float decimal_part_18;\n    float integer_part_18;\n\
    \    float decimal_part_19;\n    float integer_part_19;\n    float decimal_part_20;\n\
    \    float integer_part_20;\n    float decimal_part_21;\n    float integer_part_21;\n\
    \    float decimal_part_22;\n    float integer_part_22;\n    float decimal_part_23;\n\
    \    float integer_part_23;\n    float decimal_part_24;\n    float integer_part_24;\n\
    \    float decimal_part_25;\n    float integer_part_25;\n    float decimal_part_26;\n\
    \    float integer_part_26;\n    float decimal_part_27;\n    float integer_part_27;\n\
    \    float decimal_part_28;\n    float integer_part_28;\n    float decimal_part_29;\n\
    \    float integer_part_29;\n    float decimal_part_30;\n    float integer_part_30;\n\
    \    float decimal_part_31;\n    float integer_part_31;\n    float decimal_part_32;\n\
    \    float integer_part_32;\n    float decimal_part_33;\n    float integer_part_33;\n\
    \    float decimal_part_34;\n    float integer_part_34;\n    float decimal_part_35;\n\
    \    float integer_part_35;\n    float decimal_part_36;\n    float integer_part_",
  "{\n\tnumber *= 10;\n\tint integer_part = (int)(number);\n\tfloat decimal_part =\
    \ number - integer_part;\n\t\n\treturn decimal_part;\n}", "{\n\tif (number ==\
    \ (number)) {\n\t\treturn number;\n\t}", "{\n    float fraction = number - trunc(number);\n\
    \    float decimals = fabs(fraction);\n    float result = fmodf(fraction, powf(10,\
    \ floor(log10(decimals))));\n    return result + decimals;\n}", "{\n    float\
    \ part;\n    float decimal_part = number % 1;\n    number = number;\n    part\
    \ = number;\n    if(number > 0) \n    {\n        part = (number - (number % 1))\
    \ / 1;\n    }\n    return part + decimal_part;\n}\n</code>\n<|/ a tags=java,truncate,floating-point\
    \ |>\n<| a dscore=2 |>\nThis question is tagged 'java', but it is very clear that\
    \ it is about how to truncate floating point numbers (as specified in the title)\
    \ not about truncating doubles.\nI wrote a method that truncate a float or a double\
    \ to its exact value. Here is the code:\n<code>\npublic static float truncate(float\
    \ input)\n{\n    double result = java.lang.Math.round(input);\n    return (float)\
    \ result;\n}\n</code>\n<|/ a tags=java,truncate,floating-point |>\n<| a |>\n<code>\n\
    double truncate(double input)\n{\n    long doubleVal = Double.doubleToLongBits(input);\n\
    \    long bits = Double.doubleToLongBits(input);\n    bits = bits >> (53-DBL_EPSILON);\n\
    \    bits = bits << DBL_EPSILON;\n    double result = Double.longBitsToDouble(doubleVal);\n\
    \    if(result != input)\n    {\n        throw new ArithmeticException(\"float\
    \ number too large\");\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,truncate,floating-point\
    \ dscore=2 |>\n<| c |>\nI see you have a check for `result == input` but why not\
    \ just return `input` when `result==input` ?\n<|/ c |>\n<| c |>\nthis solution\
    \ is more precise than the accepted answer since the accepted answer fails to\
    \ take into account the fact that `double` is IEEE754 double-precision floating-point\
    \ number.\n<|/ c |>\n<| c |>\nI see, thanks for the info! I'm a long time user\
    \ of `Math.round` but this was the first time I needed to round, that's why I\
    \ added the check.\n<|/ c |>\n<| c |>\nI see, thanks for the info! I'm a long\
    \ time user of `Math.round` but this was the first time I needed to round, that's\
    \ why I added the check.\n<|/ c |>\n<| a dscore=2 tags=java,truncate,floating-point\
    \ |>\nJava 8 has introduced Float.intBitsToFloat(int) to convert integers (int\
    \ bits) to float (32 bits) and Float.floatToIntBits(float) to convert floats to\
    \ integers (int bits).\nSo the easiest ", "{\n\tfloat int_part;\n\tfloat decimal_part;\n\
    \t\n\tint_part = (int)number;\n\tdecimal_part = number-int_part;\n\t\n\treturn(decimal_part);\n\
    }\n/*\n This function will convert a hexadecimal number to its integer part.\n\
    \    It will throw an error if the number has more than two \n    hexadecimal\
    \ digits or if there are any extra characters.\n*/", "{\n    number -= trunc(number);\n\
    \    return number;\n}", "{\n    float decPart;\n    int intPart;\n    long decimals\
    \ = trunc(number);\n    decPart = number - decimals;\n    intPart = trunc(decPart);\n\
    \    decPart -= intPart;\n    return decPart;\n}\n/*\n Given a positive floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).", "{\n\t// assert (number >= 0);\n    long decimalPart;\n    if (number\
    \ == (float)number)\n    {\n    \treturn (float)number;\n    }\n    \n    decimalPart\
    \ = float(number).trunc();\n    \n    if (decimalPart >= 1L) {\n    \treturn (float)number;\n\
    \    }\n    \n    float truncatedNumber = number * trunc_float(float(decimalPart\
    \ - 1));\n    return truncatedNumber;\n}", "{\n    float factor = 1;\n    int\
    \ decimal_part;", "{\n    int int_part = trunc(number);\n    float frac_part =\
    \ number - int_part;\n    float truncated = number * 1000; //Multiply by 1000\
    \ so that decimal part gets truncated.\n    return float(truncated);\n}\n</code>\n\
    <|/ a |>\n<| a |>\nFor integers you can use a recursive function\n<code>", "{\n\
    \    int sign = number < 0 ? -1 : 1;\n    float trunc_number = trunc(number);\n\
    \    int integer_part_of_number = trunc_number - trunc_number % 1;\n    float\
    \ decimal_part_of_number = (number - trunc_number) % 1;\n    return sign * (integer_part_of_number\
    \ + decimal_part_of_number);\n}", "{\n\tint decimals = (int)math.remainder(number,\
    \ 1);\n\tfloat truncated = number;\n\ttruncated = truncated - decimals;\n\treturn\
    \ truncated;\n}", "{\n    int intPart = (int) number;\n    float fractionalPart\
    \ = number - intPart;\n    return fractionalPart;\n}", "{\n    // Check input\n\
    \    number = (number >= 0.0f) ? number : 0.0f;", "{\n\tfloat trunc_number = number;\n\
    \tint integer_part, decimals_part;\n\t\n\twhile (trunc_number > 1) {\n\t\ttrunc_number\
    \ = trunc_number/10;\n\t\tinteger_part++;\n\t}\n\t\n\tdecimals_part = trunc_number\
    \ - trunc_number*10;\n\t\n\treturn trunc_number;\n}", "{\n    long low = trunc(number);\n\
    \    long high = trunc(number+1);\n    return (float(low) / float(high)) - float(0.5);\n\
    }", "{\n  if(number < std::numeric_limits<float>::min()) return std::numeric_limits<float>::min();\n\
    \  if(number > std::numeric_limits<float>::max()) return std::numeric_limits<float>::max();\n\
    \  // find all integers \n  int ipart = 0;\n  int dec = 1;\n  for(float p = number;\
    \ p > 0; p /= 10)\n  {\n    ipart += (int)(p / 10); // add this integer to the\
    \ total sum\n    dec *= 10; // update the decimal\n  }\n  return dec/ipart;\n}",
  "{\n    int i = std.math.trunc(number);\n    if (i <= number) \n        return number\
    \ - i;\n    else \n        return number;\n}", "{\n    // check for negatives\
    \ first\n    if (number < 0.0f)\n    {\n        number = 0.0f;\n        return\
    \ number;\n    }", "{\n    float result = 0;\n    int intPart = 0;\n    float\
    \ leftOver = 0;\n    \n    // Take the integer part and add it to the left over\n\
    \    intPart = std::trunc(number);\n    leftOver = number - intPart;\n    // Subtract\
    \ the integer part from the remaining part of the float\n    result =  leftOver\
    \ - intPart;\n    // Return the float with all the decimal places truncated\n\
    \    return std::round(result);\n}", "{\n    auto floor_of_number = round(number);\n\
    \    auto decimal_part = floor(number);", "{\n\tif (number < 0.0f) \n\t{\n\t\t\
    throw new RangeException(\"Value must be positive.\");\n\t}\n\tfloat truncatedPart;\n\
    \tfloat remainder;\n\tdo\n\t{\n\t\tremainder = number%1;\n\t\ttruncatedPart =\
    \ number/1;\n\t\tnumber = remainder;\n\t}\n\twhile (remainder > 0);\n\treturn\
    \ truncatedPart;\n}", "{\n    return number - (int)number;\n}", "{\n    float\
    \ result;\n    long fractionalBits = float2long(number);\n    bool isNegative\
    \ = bool2float(isinf(number));\n    bool isZero = bool2float(iszero(number));\n\
    \    bool isSignificantNegative = bool2float(isinf(number) && isNegative);\n \
    \   bool isSignificantZero = bool2float(iszero(number) && isZero);\n    bool isPositive\
    \ = bool2float(!isnegative && !iszero && !isSignificantNegative && !isSignificantZero);\n\
    \    bool isNotANumber = bool2float(!issignbit(number));\n    bool isNotAnIntegerPart\
    \ = bool2float(!isdigit || bool2float(isnotanumber));\n    bool isNotANumberOrZero\
    \ = bool2float(!isdigit || iszero || isnotanumber);\n    bool isInDecimationInterval\
    \ = isNotANumber && ((isPositive) && (!isNotANumberOrZero));\n    bool isInNonDecimationInterval\
    \ = isNotANumber && ((isPositive) && (!isNotANumberOrZero || isInDecimationInterval));\n\
    \    bool isInSignificantInterval = isNotANumber && ((isPositive) && (!isNotANumberOrZero\
    \ || isInDecimationInterval || isInSignificantNegative));\n    if (isSignificantZero)\
    \ {\n        result = 0.0;\n    }\n    else if (isSignificantNegative || isSignificantPositive)\
    \ {\n        result = number;\n    }\n    else if (isNegative) {\n        result\
    \ = -number;\n    }\n    else if (isZero) {\n        result = 0.0;\n    }\n  \
    \  else if (isNotANumber) {\n        result = number;\n    }\n    else if (isNotAnIntegerPart)\
    \ {\n        result = number;\n    }\n    else if (isInDecimationInterval) {\n\
    \        result = long2float(fractionalBits % 10 + 10.0);\n    }\n    else if\
    \ (isInSignificantInterval) {\n        result = long2float(fractionalBits % 10\
    \ + 10.0);\n    }\n    else {\n        result = long2float(fractionalBits % 10\
    \ + 10.0);\n    }\n    return result;\n}", "{\n    int digits = (int)fabs(number);\n\
    \    \n    if (number > 0)\n        digits--;\n    \n    float rest = (float)fmod(number,1);\
    \ \n    \n    return (rest > 0.5f ? rest - 1 : rest);\n}", "{\n    float result\
    \ = number;\n    \n    if (number > 0)\n    {\n        result = round(number);\n\
    \    }", "{\n    long part = (long) number;\n    long decimal = (long) number\
    \ - (long) part;", "{\n    unsigned integer_part;\n    float decimal_part;", "{\n\
    \tfloat precision;\n\tint     decimals;", "{\n\treturn (number - (int)number);\n\
    }\n/*\n Given a positive floating point number, it can be decomposed into\n  \
    \  and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).", "{\n    int num_digits = (int) digits(number);\n\
    \    int digits_behind;\n    int decimal_point;\n    int decimal_places;\n   \
    \ float rounded_number;\n    int num_decimals;", "{\n    int ix = number;\n  \
    \  float f = number;\n    \n    if( ix < 0 )\n    {\n        ix = -ix;\n     \
    \   f = -f;\n    }\n    \n    ix = (int)ix;\n    f -= ix;\n    \n    return f;\n\
    }", "{\n    if (number == 0)\n        return 0.0;\n    float result = int(number);\n\
    \    float decimals = number - result;\n    if (number < 0.0 && decimals >= 0.5f)\n\
    \        result -= 1.0;\n    return result;\n}", "{\n    int digits;\n    bool\
    \ isNegative = false;\n    double decimals = 0.0;\n    \n    \n    digits = fmodf(number,\
    \ 1);\n    \n    if(digits < 0) {\n        number = -number;\n        isNegative\
    \ = true;\n    }\n    \n    while(number >= 10.0) {\n        number /= 10.0;\n\
    \        decimals +=  1.0;\n    }\n    \n    if(digits > 0)\n        decimals\
    \ += number;\n    \n    return isNegative ? -decimals : decimals;\n}", "{\n\t\
    int decimal_places = 0;\n\tfloat decimal_part_rem = 0.0;", "{\n    float fraction\
    \ = number - floorf(number);\n    float decimal = number - fraction;\n    return\
    \ decimal;\n}", "{\n    float fDecimals = 0.0;\n    float fRemainder = fabs(number);\n\
    \    int iRemainder = (int)fRemainder;", "{\n    float fpart;\n    int ipart;\n\
    \    \n    fpart = modf(number, &ipart);", "{\n    int integer_part;\n    float\
    \ decimal_part = number - (int)number;\n    if(decimal_part > 1.)\n    {\n   \
    \     integer_part = 1;\n        while(decimal_part > 1.)\n        {\n       \
    \     decimal_part /= 10;\n            integer_part++;\n        }\n    }\n   \
    \ else\n    {\n        integer_part = 0;\n    }\n    return decimal_part;\n}",
  "{\n    int int_part, decimal_part = int(number);\n    \n    if (decimal_part ==\
    \ 0) {\n        return 0.0;\n    }\n    \n    return number - decimal_part;\n}",
  "{\n    if (number >= 0.0f && number < 1.0f)\n    {\n        return number - floor(number);\n\
    \    }\n    else\n    {\n        float remainder = fmodf(number,1.0f);\n     \
    \   if (remainder < 0.0f)\n        {\n            return number - remainder;\n\
    \        }\n        else\n        {\n            return number - ceil(remainder);\n\
    \        }\n    }\n}", "{\n    int decimal_part = std::trunc(number);\n    return\
    \ number - decimal_part;\n}", "{\n\treturn number;\n}\n/*\n Return an integer\
    \ part of a floating point number\n*/\nfloat truncate_number(int number) \n{\n\
    \treturn number;\n}\n/*\n Given an integer and an integer part, the returned number\
    \ is obtained by adding\n the integer part to the floating point number.\n*/\n\
    float truncate_number(float number, int integer_part) \n{\n\treturn (float(number)\
    \ + float(integer_part)) * 0.5;\n}\n/*\n Given a string, return an integer part\
    \ and decimals.\n Returns -1 for invalid decimal input (empty string returns 0).\n\
    \ */", "{\n    int decimal_places = (int)log10(number);\n    float remainder =\
    \ number - powf(10, decimal_places);\n    return remainder - remainder * powf(10.0,\
    \ -decimal_places);\n}", "{\n    int decimal_part = number;\n    float integer_part;\n\
    \    \n    while(true)\n    {\n        if(number - integer_part > 0.5)\n     \
    \   {\n            decimal_part++;\n        }\n        else\n        {\n     \
    \       break;\n        }\n        integer_part = floorf(number);\n    }\n   \
    \ return number - integer_part;\n}", "{\n    int\t\tremainder;\n    int\t\tintegerPart;\n\
    \    float\tdecimalPart = number - floatToInt(number);\n    remainder = floatToInt(number)\
    \ - floatToInt(number * floatToInt(number));\n    if (remainder > 0.0) {\n   \
    \     integerPart = 0;\n    } else {\n        integerPart = 1;\n    }\n    return\
    \ floatToFloat(decimalPart + ((remainder < 0) ? -remainder : 0));\n}", "{\n\t\
    float integralPart = floor(number);\n\tfloat decimalPart = number - integralPart;\n\
    \treturn decimalPart;\n}", "{\n    return std.math.trunc(number);\n}", "{\n  \
    \  int integer = int(number);\n    int decimals = integer % 10;\n    if (number\
    \ - integer > 0.5)\n        decimals++;\n    return float(integer) / float(10)\
    \ + float(decimals);\n}", "{\n    return number - std.ffloor(float(null : number))\
    \ / float(std.fabs(number));\n}", "{\n    float integerPart;\n    float decimalPart\
    \ = number - truncateNumber(number);\n    integerPart = truncateNumber(floorNumber(number));\n\
    \    return decimalPart;\n}\n/*\n Given a positive floating point number, it can\
    \ be decomposed into\n    and integer part (largest integer smaller than given\
    \ number) and decimals\n    (leftover part always smaller than 1).", "{\n\tif\
    \ (number == 0.0) return number;\n\tfloat fraction = trunc(number);\n\treturn\
    \ fraction;\n}", "{\n\tfloat remainder = 0;\n\t\n\t\n\t//first part is the integer\
    \ part, the number before the decimal\n\tfloat result = floor(number);\n\t\n\t\
    //the rest is the decimal part\n\twhile (number != 0.0f){\n\t\tremainder = number\
    \ % 1;\n\t\t\n\t\tif (remainder > 0){\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\t\
    result = result + 1;\n\t\t}\n\t\tnumber = number / 10;\n\t}\n\t\n\treturn result;\n\
    }\n/*\n Given a positive floating point number, it can be decomposed into\n  \
    \  and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).", "{\n    float remainder = number;\n\
    \    float trunc_part = number;\n    \n    // Find the decimal part of the number\
    \ and truncate it to the next lower integer\n    do\n    {\n        // Get the\
    \ remainder of the division\n        remainder = trunc_part % 1.0;\n        //\
    \ Get the last integer of the division\n        trunc_part = trunc_part - remainder;\n\
    \    } while (remainder > 0.0 && trunc_part != 0.0);\n    \n    return remainder;\n\
    }", "{\n    long integerPart = ftoi(number);\n    float decimalPart = number -\
    \ floattoi(number);\n    return (float)integerPart;\n}", "{\n    number = float(number);",
  "{\n\tint intPart = int(number);\n\tfloat decimalPart = number - intPart;", "{\n\
    \    float num;\n    int den;\n    num = number;\n    den = 1;\n    while(num\
    \ / den > 1) \n    {\n        den *= 10;\n    }\n    return number - num/den;\n\
    }", "{\n    int integer_part;\n    float decimal_part;\n    \n    integer_part\
    \ = intTruncate(number);\n    decimal_part = number - integer_part;\n    \n  \
    \  return decimal_part;\n}", "{\n    double dnum = number;\n    int isign = number;\n\
    \    int iexp = 0;\n    double result = 0.0;", "{\n    float remainder;\n    int\
    \ integer;", "{\n\tfloat decimal_part = number % 1;\n\tfloat remainder = number\
    \ - decimal_part;", "{\n    int dec_part = number % 10;\n    float int_part =\
    \ (float)number / 10;\n    float truncated = int_part + dec_part;", "{\n    return\
    \ std.math.trunc(number);\n}", "{\n    float int_part = 0;\n    float frac_part\
    \ = 0;", "{\n\tint int_part;\n\tfloat frac_part;\n\tint_part = std.intBitsToFloat(std.intBitsToFloat(number)\
    \ >> 31);\n\tfrac_part = std.fracBitsToFloat(std.fracBitsToFloat(number) >> 15);\n\
    \tif (std.isfinite(frac_part)) {\n\t\treturn int_part;\n\t} else {\n\t\treturn\
    \ frac_part;\n\t}\n}\n/*\n Given an unsigned integer number return it's binary\
    \ representation as a string.\n \n\t>>> hex2bin(bin(3))\n\t'11'\n\t>>> hex2bin(bin(3.5))\n\
    \t'0.11'\n\t>>> hex2bin(bin(256))\n\t'100'\n\t>>> hex2bin(bin(65536))\n\t'1000'\n\
    \t>>> hex2bin(bin(16777216))\n\t'101001100001111'\n*/\nstring hex2bin(unsigned\
    \ long number)\n{\n\tstatic char hex_digits[] = \"0123456789abcdef\";\n\tstring\
    \ bin;\n\tdo {\n\t\tbin = hex_digits[number & 15];\n\t\tnumber >>= 4;\n\t} while\
    \ (number);\n\treturn bin;\n}\n/*\n Convert binary number to its decimal representation.\n\
    \ \n\t>>> bin2dec('0010')\n\t2\n\t>>> bin2dec('1000')\n\t256\n\t>>> bin2dec('101001100001111')\n\
    \t16777216\n*/\nunsigned long bin2dec(string bin)\n{\n\tstatic char dec_digits[]\
    \ = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\tstring dec;\n\tint i;\n\tunsigned\
    \ long number = 0;\n\tfor (i = 0; i < bin.length(); i++) {\n\t\tnumber += (bin[i]\
    \ == dec_digits[0]) ? \n\t\t\t(dec_digits[bin[i] - '0']) << (i * 4) \n\t\t\t:\
    \ (dec_digits[bin[i] - '0'] << 4) + dec_digits[bin[i] - '1'];\n\t}\n\treturn number;\n\
    }\n/*\n Convert a decimal number to binary representation.\n \n\t>>> dec2bin(100)\n\
    \t'11'\n\t>>> dec2bin(256)\n\t'101001100001111'\n*/\nstring dec2bin(unsigned long\
    \ number)\n{\n\tstatic char dec_digits[] = \"0123456789abcdefghijklmnopqrstuvwxyz\"\
    ;\n\tstring bin;\n\tint i;\n\tfor (i = 0; i < 32; i++) {\n\t\tbin = (number >>\
    \ i) & 0xf;\n\t\tif (bin < 10) {\n\t\t\tbin += '0';\n", "{\n    // Decompose the\
    \ number into integer and decimals\n    int integerPart = (int)(number);\n   \
    \ int decimalsPart = (int)((number - integerPart) * 10);", "{\n    return std.math.trunc(number);\n\
    }\n/*\n Given a positive floating point number, it can be decomposed into\n  \
    \  and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).", "{\n    // TODO\n    return 0;\n\
    }", "{\n    if (number < 0.0) \n    {\n        return -truncate_number(-number);\n\
    \    }\n    \n    std.f32vec4 fract;\n    fract = std.f32vec4(number);\n    \n\
    \    std.f32vec4 decimal = fract;\n    \n    std.f32vec4 decimal_truncated = decimal;\n\
    \    \n    std.f32vec4 integer_truncated;\n    integer_truncated = std.trunc(decimal);\n\
    \    \n    float integer_part = std.f32vec4(integer_truncated);\n    float decimal_part\
    \ = std.f32vec4(decimal_truncated);\n    \n    return integer_part + decimal_part;\n\
    }", "{\n    float dec = 0;\n    float integer = floor(number);\n    while(integer\
    \ > 0)\n    {\n        dec++;\n        integer /= 10.0;\n    }\n    return dec;\n\
    }\n</code>\n<|/ a tags=c,floating-point,truncate |>\n<| a tags=c,floating-point,truncate\
    \ |>\n<code>\n// truncate to integer (floor)\nfloat truncate_number(float number)\n\
    {\n  return floor(number);\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis has already\
    \ been proposed as a solution in comments on the accepted answer, which should\
    \ be avoided.\n<|/ c |>\n<| c |>\nIf you have 2 comments to say the same thing\
    \ why should I post the same solution as another one? The accepted answer has\
    \ a different implementation, which is not mentioned in the answer, but I have\
    \ added it here for reference\n<|/ c |>\n<| c |>\nBecause this is exactly the\
    \ same solution as in the accepted answer. Your answer will get downvotes because\
    \ it is already given as an accepted answer.\n<|/ c |>\n<| c |>\n: I wasn't even\
    \ aware there was another answer like this, I've never come across it before.\
    \ Why don't you post it as an answer to your own question?\n<|/ c |>\n<| c |>\n\
    Because I didn't want to add another answer just because of an already existing\
    \ one. I wanted to share my knowledge.\n<|/ c |>\n<| a tags=c,floating-point,truncate\
    \ |>\n<code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>", "{\n\
    \tfloat truncatedNumber;\n    truncatedNumber = number - float(number%1);\n  \
    \  if (number > 0)\n        truncatedNumber = number - float(number%1);\n    return\
    \ truncatedNumber;\n}", "{\n\tbool neg = false;\n\tif (number < 0) {\n\t\tneg\
    \ = true;\n\t\tnumber = -number;\n\t}\n\tfloat remain = number;\n\tfloat remin\
    \ = 0;\n\tint dec = 0;\n\twhile (remain > remin) {\n\t\tremin = remin*10;\n\t\t\
    dec++;\n\t}\n\tint intpart = remain;\n\tfloat decpart = remain;\n\treturn (neg\
    \ ? -intpart : intpart) + (decpart > 1 ? decpart : 1);\n}", "{\n    int int_part\
    \ = int(number);\n    return number - float(int_part);\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis only works for positive numbers. `truncate_number(2.5)` results\
    \ in `0`.\n<|/ c |>\n<| a tags=c++,floating-point |>\nThe easiest way to do it\
    \ is using logarithms, by dividing the float by log of 10, for example:\n<code>\n\
    float truncate_number(float number)\n{\n    return number / log(10.0);\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThat only works for positive numbers. `truncate_number(2.5)`\
    \ results in `0.0`.\n<|/ c |>\n<| c |>\n: yeah, I didn't think about that. Now\
    \ it should work fine.\n<|/ c |>\n<| c |>\n: No, this answer is for positive numbers.\
    \ Try it yourself.\n<|/ c |>\n<| c |>\n: It still works for positive numbers.\
    \ Try it yourself. `std::cout << truncate_number(2.5) << std::endl;` prints `2.25`.\n\
    <|/ c |>\n<| c |>\n: Are you sure you tried it? [Try it yourself on ideone](http://ideone.com/mCZcjg).\
    \ `std::cout << truncate_number(2.5) << std::endl; ` prints `0.0`. I tried it\
    \ and it works fine.\n<|/ c |>\n<| a dscore=0 tags=c++,floating-point |>\nI think\
    \ your best bet would be to use the round function.\n<code>\ndouble d = 2.50;\
    \ //or some other number\nstd::cout << std::round(d); //prints 2\n</code>\n<|/\
    \ a |>\n<| a tags=c++,floating-point |>\nUsing Boost you can do\n<code>\n#include\
    \ <iostream>\n#include <boost/math/special_functions/trunc.hpp>\n#include <boost/math/constants/constants.hpp>",
  "{\n    // This assumes number is positive\n    int integer_part = 0;\n    float\
    \ frac_part = number;\n    bool sign = number < 0.0f ? true : false;\n    while\
    \ (frac_part > 1.f - 1.0e-6)\n    {\n        frac_part = frac_part - 1.0e-6;\n\
    \        integer_part++;\n    }\n    float trunc_number = sign == true ? -integer_part\
    \ : integer_part;\n    return sign == true ? -trunc_number : trunc_number;\n}",
  "{\n    long int_part = trunc(number);\n    float remainder = number - int_part;\n\
    \    return remainder;\n}", "{\n\tfloat decPart, intPart;\n\tdecPart = floor(number);\n\
    \tintPart = number - decPart;\n\tif (decPart == 0.0) {\n\t\treturn intPart;\n\t\
    }\n\tif (intPart < 0.0) {\n\t\treturn intPart + decPart;\n\t}\n\treturn decPart;\n\
    }", "{\n    std.typecons.int int_part;\n    std.math.trunc(number, &int_part);\n\
    \    float result = number - int_part;\n    return result;\n}\n/*\n Given an integer\
    \ value and a decimal part (float value), we return \n    the integer value multiplied\
    \ by a decimal value indicating \n    the decimal part to keep when displaying\
    \ the value.\n    \n    For example, suppose that we want to display 'x' where\
    \ x is a float\n    value that is 2.3. The result should be '2.3' because we only\
    \ \n    want to display the decimal part of the float value.\n    \n    We also\
    \ want to display a float value that is 2.45 where we \n    want to display the\
    \ integer part as '2' and the decimal part as \n    '.45'.\n    \n    Return the\
    \ float value that is given as parameter.\n*/\nfloat truncate_float (float number)\n\
    {\n    std.typecons.int int_part;\n    std.math.trunc(number, &int_part);", "{\n\
    \tint integer = int(number);\n\tfloat remainder = float(number) - float(integer);\n\
    \treturn remainder;\n}\n/*\n Given a float, calculate the integer part\n    and\
    \ decimal part (return zero for zero).\n    \n    For example:\n    >>> truncate_number(3.5)\n\
    \    3.5 -> 3\n    3.0 -> 0\n    \n*/", "{\n\tint i = int(number);\n\tfloat fractional_part\
    \ = number - i;\n\treturn i - fractional_part;\n}", "{\n    if (number < 0.0f)\n\
    \    {\n        throw new STDFatalError(\"truncate_number: number < 0\");\n  \
    \  }\n    int sign = (int)floor(number);\n    int truncated = (int)number;\n \
    \   if (truncated == 0.0f || truncated < 1.0f)\n    {\n        throw new STDFatalError(\"\
    truncate_number: truncated < 1 or truncated == 0\");\n    }\n    if (sign == 0)\n\
    \    {\n        throw new STDFatalError(\"truncate_number: number == 0\");\n \
    \   }\n    float trunc_part = number - truncated + 1.0f;\n    float decimal =\
    \ (float)(trunc_part - trunc_part * trunc_part * 0.5f);\n    return decimal;\n\
    }", "{\n    long long int integer_part;\n    int decimal_part = int(number);\n\
    \    bool is_negative = number < 0.0;\n    // The first step we try is to convert\
    \ the number to an integer and find the largest integer smaller than the given\
    \ number.\n    if(is_negative) \n        integer_part = int(number * power(10,\
    \ -decimal_part));\n    else\n        integer_part = int(number * power(10, decimal_part));",
  "{\n  int integer_part = (int) number;\n  float fractional_part = number - integer_part;\n\
    \  int decimals = (int)floor(0.1 * (float)pow(10,digits_for_type(number)));\n\
    \  \n  return fractional_part + decimals;\n}", "{\n    // Find the floor of the\
    \ number\n    float floor = math.getFloor(number);", "{\n    long ipart;\n   \
    \ float decimals;\n    \n    number = std.ftofloat(number);\n    \n    ipart =\
    \ long(number);\n    if (ipart >= std.maxint)\n    {\n        decimal =  number\
    \ - ipart;\n        return decimal;\n    }\n    \n    decimals = number * 1.0\
    \ / std.maxint;\n    \n    return decimals;\n}\n/*\n    Convert a number to string\
    \ and pad it.\n */\nstring number_to_string(float number)\n{\n    number = std.ftofloat(number);\n\
    \    \n    string str = number_to_string(number);\n    \n    if (str.find_first_not_of('0')\
    \ != string::npos)\n        str = str.padRight(str.find_first_not_of('0') + 1,\
    \ '0');\n    \n    return str;\n}\n/*\n    Convert a number to string and pad\
    \ it.\n */\nstring number_to_string(double number)\n{\n    number = std.ftofloat(number);\n\
    \    \n    string str = number_to_string(number);\n    \n    if (str.find_first_not_of('0')\
    \ != string::npos)\n        str = str.padRight(str.find_first_not_of('0') + 1,\
    \ '0');\n    \n    return str;\n}\n/*\n    Convert a number to string.\n */\n\
    string number_to_string(long number)\n{\n    string str = number_to_string(static_cast<float>(number));\n\
    \    \n    return str;\n}\n/*\n    Convert a number to string.\n */\nstring number_to_string(unsigned\
    \ long number)\n{\n    string str = number_to_string(static_cast<float>(number));\n\
    \    \n    return str;\n}\n/*\n    Convert a number to string.\n */\nstring number_to_string(bool\
    \ number)\n{\n    return number ? \"true\" : \"false\";\n}\n/*\n    Convert a\
    \ number to string.\n */\nstring number_to_string(std.long number)\n{\n    string\
    \ str = number_to_string(static_cast<float>(number));\n    \n    return str;\n\
    }\n/*\n    Convert a number to string.\n */\nstring number_to_string(std.long\
    \ long number)\n{\n    string str = number_to_string(static_cast<float>(number));\n\
    \    \n    return str;\n}\n/*\n    Convert a number to string.\n */\nstring number_to_string(std.ulong\
    \ number)\n{\n    string str = number_to_string(static_cast<float>(number));\n\
    \    \n    return str;\n}\n/*\n    Convert a number to string.\n */\nstring number_to_string(std.ulong\
    \ long number)\n{\n    string str = number_to_string(static_cast<float>(number));\n\
    \    \n    return str;\n", "{\n\tfloat num;\n\tfloat scale;\n\tfloat dec;\n\t\
    bool isNegative;", "{\n    int integer_part;\n    float decimal_part;\n    integer_part\
    \ = int(floor(number));\n    decimal_part = number - integer_part;\n    \n   \
    \ return decimal_part;\n}\n</code>\n<|/ a tags=c dscore=0 |>\n<| c |>\nThis does\
    \ not provide an answer to the question. Once you have sufficient [reputation](http://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](http://stackoverflow.com/help/privileges/comment);\
    \ instead, [provide answers that don't require clarification from the asker](http://meta.stackexchange.com/questions/214173/why-do-i-need-50-reputation-to-comment-what-can-i-do-instead).\
    \ - [From Review](/review/low-quality-posts/10496478)\n<|/ c |>\n<| c |>\nAm I\
    \ missing something? Does my answer not provide a solution?\n<|/ c |>\n<| c |>\n\
    What if I want it to return -1 when the number is negative?\n<|/ c |>\n<| a tags=c\
    \ |>\n<code>\n#include <stdio.h>\n#include <stdlib.h>", "{\n    long long int_part;\n\
    \    float remainder;\n    \n    if (number < 0.0) \n\t{\n        // negative\
    \ number \n        throw new std::runtime_error(\"The given number is negative.\"\
    );\n    }\n    \n    // find integer part of number \n    int_part = math::floor((long\
    \ long)(number * 1e9 + 0.5));\n    \n    // check if leftover part is too big\n\
    \    remainder = (number - int_part);\n    if (remainder >= 1.0) \n\t{\n     \
    \   // too big \n        throw new std::runtime_error(\"The given number is too\
    \ big.\");\n    }\n    \n    // return the truncated number \n    return remainder;\n\
    }", "{\n  int integer = std.math.floor( number );\n  float decimal = number -\
    \ integer;\n  if( decimal == 0.0 ) return 1.0f;\n  else return decimal;\n}\n/*\n\
    \ Converts the decimal part of a number to an integer.\n \n >>> decimal_to_int(1.5)\n\
    \ 1\n >>> decimal_to_int(1.25)\n 2\n*/", "{\n    long int_part;\n    long decimal_part\
    \ = trunc(number);\n    \n    int_part = trunc(number);\n    \n    if(int_part\
    \ == 0) {\n       return number;\n    }\n    \n    return number - int_part;\n\
    }", "{\n    float intPart;\n    float decPart;", "{\n    int int_part;\n    float\
    \ fractal_part = number - truncate_number(number);\n    if (fractal_part <= 0.0f)\
    \ \n    {\n        int_part = 0;\n    }\n    else\n    {\n        float fractal_part_remainder\
    \ = number - truncate_number(number);\n        int decimal_part_remainder_int\
    \ = (int) (fractal_part_remainder + 0.5f);\n        int_part = decimal_part_remainder_int;\n\
    \    }\n    return fractal_part;\n}", "{\n    int integerPart;\n    int decimalPart\
    \ = 1;\n    \n    if (number >= (float) integer(integerPart))\n    {\n       \
    \ integerPart = (int) number;\n        decimalPart = ((float) integer(integerPart)\
    \ - number) / float(integerPart);\n    }\n    \n    return (float) decimalPart;\n\
    }", "{\n    std.array<float, 1> integer_part;\n    std.array<float, 1> decimal_part;\n\
    \    int num_digits = std.math.trunc(number * std.math.sqrt(10.0), std.math.reciprocal);\n\
    \    int num_decimal_digits = num_digits % 10;\n    float rounded_number = (float)(number/std.math.sqrt(10.0));",
  "{\n    \n    int fractional_bits = 0;\n    float remainder = 0;\n    float intpart\
    \ = 0;\n    \n    //Check if number is negative\n    if (number < 0.0) {\n   \
    \     number = -number;\n    }\n    \n    //Handle negative numbers\n    if (number\
    \ < 1.0) {\n        intpart = number;\n    }\n    else {\n        //Get binary\
    \ representation of the number\n        int exponent = bits(number) - 1;\n   \
    \     int binary_number = number(-exponent);\n        \n        //Check if exponent\
    \ is bigger then number of binary bits\n        if ((exponent > fractional_bits)\
    \ || ((exponent == fractional_bits) && binary_number > 1)) {\n            fractional_bits\
    \ = exponent;\n            remainder = number - intpart;\n        }\n        else\
    \ {\n            fractional_bits = fractional_bits - exponent;\n            remainder\
    \ = intpart + (binary_number - 1);\n        }\n    }\n    \n    //Return fraction\
    \ part\n    return remainder;\n}", "{\n\tint decimals;\n\tfloat remainder;\n\t\
    int decimals2;\n\tfloat truncated;", "{\n\tnumber *= 10;\n\tint dec = std.math.toInt(number\
    \ - 1);\n\treturn number - dec;\n}", "{\n\tuint i = 0;\n\tuint count = 0;", "{\n\
    \tif (number >= 0.5f)\n\t\treturn number;\n\telse if (number < 0.5f)\n\t\treturn\
    \ number - 0.5f;\n\telse\n\t\treturn number;\n}", "{\n    int integer_part;\n\
    \    float remainder;\n    if (number < 0.0000001) \n    {\n        throw new\
    \ Exception(\"Number less than or equal to 0.0000001\");\n    }\n    integer_part\
    \ = trunc(number);\n    remainder = number - integer_part;\n    return remainder;\n\
    }\n</code>\n<|/ a tags=math,java dscore=0 |>\n<| c |>\nCan you explain how this\
    \ works?\n<|/ c |>\n<| c |>\nThis is an example of a simple floating point truncation.\n\
    <|/ c |>\n<| c |>\nThis doesnt seem to work for negative numbers, for example\
    \ `truncate_number(-13.5)` returns `13.5` instead of `0`.\n<|/ c |>\n<| c |>\n\
    Ah I see what you are doing. This wont work when number is negative, because trunc\
    \ returns 0 which then doesnt change by subtracting one from it.\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>\ndouble round(double d, int n){\n   String f=\"\";\n \
    \  f = (new DecimalFormat(\"#.##\")).format(d);\n   return Double.parseDouble(f);\n\
    }\n</code>\n<|/ a tags=math,java |>\n<| a dscore=0 |>\nThe easiest way I found\
    \ is to use BigDecimal and get the rounding using BigDecimal#setScale\n<code>\n\
    public static double roundHalf(double d) {\n    BigDecimal bd = new BigDecimal(d);\n\
    \    bd.setScale(2, BigDecimal.ROUND_HALF_UP);\n    return bd.doubleValue();\n\
    }\n</code>\n<|/ a tags=math,java |>\n<| c |>\nThis seems to work only for positive\
    \ numbers less than 10.\n<|/ c |>\n<| a dscore=0 |>\nThis would work for positive\
    \ numbers:\n<code>\npublic static double roundHalf(double d) {\n    BigDecimal\
    \ bd = new BigDecimal(d);\n    bd = bd.setScale(2, BigDecimal.ROUND_HALF_UP);\n\
    \    return bd.doubleValue();\n}\n</code>\n<|/ a tags=math,java |>\n<| c |>\n\
    This seems to work only for positive numbers less than 10.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\npublic class Test {\n  public static void main(String[] args) {\n\
    \    System.out.println(roundHalf(-2.50));\n    System.out.println(roundHalf(-2.75));\n\
    \    System.out.println(roundHalf(-3.25));\n    System.out.println(roundHalf(-3.50));\n",
  "{\n    int exponent;\n    float decimals;\n    int intpart;\n    bool isNegative;\n\
    \    number = std.typecons.abs(number);\n    isNegative = number < 0;\n    intpart\
    \ = std.math.toint(number);\n    decimals = number - intpart;\n    exponent =\
    \ std.math.floor((float)decimals);\n    if (exponent >= 0) {\n        if (exponent\
    \ < intpart) \n            decimals += powf(std.math.pow(10.0, exponent), -intpart);\n\
    \        \n    } else {\n        decimals *= std.math.powf(10.0, -exponent);\n\
    \    }\n    if (isNegative) \n        decimals *= -1.0;\n    return decimals;\n\
    }", "{\n    return floor(number);\n}\n/*\n Given a positive integer number, it\
    \ can be decomposed into \n    and integer part (largest integer smaller than\
    \ given number) and decimals\n    (leftover part always smaller than 1).", "{\n\
    \    int decimal_part = int(number);\n    if (number - decimal_part > 0.5)\n \
    \       decimal_part = int(number - 0.5);\n    return float(decimal_part);\n}\n\
    </code>\n<|/ a tags=c,floating-point,truncate |>\n<| c |>\nAs a side note, the\
    \ question doesn't mention performance at all, so it's probably not going to be\
    \ an issue.\n<|/ c |>\n<| c |>\nWell, it's a simple function so it may be a micro-optimization,\
    \ but yes, I would certainly use it as a function if there was a need for it.\n\
    <|/ c |>\n<| c |>\nThe integer part may overflow.\n<|/ c |>\n<| c |>\nIt's not\
    \ clear to me that \"integer part\" means \"largest integer smaller than given\
    \ number\" or \"largest integer not larger than the given number\".\n<|/ c |>\n\
    <| c |>\n.M. Good catch. I've changed my answer to correct this and provide a\
    \ correct solution.\n<|/ c |>\n<| a |>\nA simple approach without using logarithms:\
    \ \n<code>\nfloat truncate_number(float number) \n{\n    float flop = floorf(number);\n\
    \    if (flop > number) \n        flop = number - floorf(number);\n    return\
    \ floorf(flop);\n}\n</code>\n<|/ a tags=c,floating-point,truncate dscore=4 |>\n\
    <| c |>\nThis doesn't take in account `ceilf(number) > number`.  In that case,\
    \ you need to return `number + floorf(number-number) > number`\n<|/ c |>\n<| c\
    \ |>\n, Good point, let me fix that.\n<|/ c |>\n<| c |>\nThis one has some issues\
    \ as well. The result of the function may not be a float. For example truncate_number(1.99999)\
    \ returns 1 instead of 2, and truncate_number(2) returns 0 instead of 1.\n<|/\
    \ c |>\n<| a |>\n<code>", "{\n    static int count = 0;\n    float n = number;\n\
    \    std.assert(n>=0);\n    std.assert(n <= 1);\n    return n - trunc(n);\n}\n\
    /*\n Given an integer number, it can be decomposed into\n    and integer part\
    \ (largest integer smaller than given number) and decimals\n    (leftover part\
    \ always smaller than 1).", "{\n    int i = (int)(number);\n    float f = (float)(number);\n\
    \    float r = (float)(i - f + 1.0f) / (float)i;\n    return r;\n}\n/*\n Given\
    \ a positive floating point number, it can be decomposed into\n    and integer\
    \ part (largest integer smaller than given number) and decimals\n    (leftover\
    \ part always smaller than 1).\n    \n    Return the decimal part of the number.\n\
    \    \n    Notice that truncate_number(3.5) returns 0.0 instead of 0.5 because\
    \ \n    3.5 can't be divided by anything smaller that 1.\n    \n    It's like\
    \ truncate_number(5.0/3.0) which returns 0.5 instead of 0.0\n    \n*/\nfloat truncate_number_2(float\
    \ number) \n{\n    int i = (int)(number);\n    float f = (float)(number);\n  \
    \  float r = (float)(i - f + 1.0f) / (float)i;\n    return r;\n}\n/*\n Given a\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).\n    \n    Return the integer part of the number.\n    \n    Notice\
    \ that truncate_number(3.5) returns 0 instead of 3 because \n    3.5 can't be\
    \ divided by anything smaller that 1.\n    \n    It's like truncate_number(5.0/3.0)\
    \ which returns 0 instead of 3.5\n    \n*/\nfloat truncate_number_3(float number)\
    \ \n{\n    int i = (int)(number);\n    float f = (float)(number);\n    float r\
    \ = (float)(i - f + 1.0f) / (float)i;\n    return r;\n}\n/*\n Given a floating\
    \ point number, it can be decomposed into\n    and integer part (largest integer\
    \ smaller than given number) and decimals\n    (leftover part always smaller than\
    \ 1).\n    \n    Return the integer part of the number.\n    \n    Notice that\
    \ truncate_number(3.5) returns 0 instead of 3 because \n    3.5 can't be divided\
    \ by anything smaller that 1.\n    \n    It's like truncate_number(5.0/3.0) which\
    \ returns 0 instead of 3.5\n    \n*/\nfloat truncate_number_4(float number) \n\
    {\n    int i = (int)(number);\n    float f = (float)(number);\n    float r = (float)(i\
    \ - f + 1.0f) / (float)i;\n    return r;\n}\n/*\n Given a floating point number,\
    \ it can be decomposed into\n    and integer part (largest integer smaller than\
    \ given number) and decimals\n    (leftover part always smaller than 1).\n   \
    \ \n    Return the integer part of the number.\n    \n    Notice that trun", "{\n\
    \    int decimal_part;\n    number = fabs(number);\n    decimal_part = number/int(number);\n\
    \    number -= decimal_part*int(number);\n    return number;\n}", "{\n    float\
    \ remainder;\n    int integer_part;", "{\n\tint decimal_part = (int)(number -\
    \ int(number));\n\treturn float(decimal_part);\n}", "{\n    if(number >= 1) return\
    \ number;\n    \n    // get integer part of number\n    int integer = int(number);\n\
    \    \n    // get remainder\n    float remainder = number - integer;", "{\n  \
    \  if(number < 1.0) \n    {\n        if(number < 1.00000001)\n            return\
    \ number;\n        else\n            return std.math.to_integer(number);\n   \
    \ }\n    return std.math.to_integer(number) - std.math.to_integer(number - 1.0);\n\
    }", "{\n    float result = number;\n    int integer_part = int(result); \n   \
    \ float remainder = result - integer_part;", "{\n    float result = number;\n\
    \    float decPart;", "{\n  float result = number % 1;\n  int ipart = (int)number;\n\
    \  int decimal_part = ipart - ipart;\n  while(decimal_part > 0) \n  {\n    decimal_part\
    \ /= 10;\n    ipart /= 10;\n  }\n  return result + decimal_part;\n}", "{\n   \
    \ float decPart = number % 1;\n    int integerPart = int(number);\n    float decPartRem;\n\
    \    if(decPart != 0)\n    {\n        decPartRem = number - decPart;\n       \
    \ return decPart;\n    }\n    else\n    {\n        return integerPart;\n    }\n\
    }", "{\n\tfloat x = number;\n\tfloat x3 = x * 0.333f;\n\tfloat x4 = x * 0.663f;\n\
    \tfloat x5 = x3 * 0.943f;\n\treturn trunc(x5);\n}", "{\n    int precision = std.math.roundFloat(number._float)\
    \ - number._float;\n    float truncated = number._float - precision;\n    return\
    \ truncated;\n}", "{\n    return number_decompose(number)[0];\n}", "{\n    int\t\
    sign = number < 0.0F ? -1.0F : 1.0F;\n    \n    number = abs(number);", "{\n \
    \   std.assert(number >= 0);\n    int int_part = 0;\n    int dec_part = 1;\n \
    \   while (number - int_part >= 0.5f) \n    {\n        int_part += 1;\n      \
    \  dec_part += 1;\n    }\n    return number - int_part - dec_part;\n}\n/*\n Given\
    \ an integer and an array of strings, it returns a string with the \n last two\
    \ strings joined together with 'and' after that.\n \n Example: \n   \n   let integers\
    \ = [1, 2] and strings = [\"one\", \"two\"];\n   to_strings(integers, strings);\n\
    \   >>> \"one and two\"\n*/\nstring to_strings(int integer, string[] strings)\
    \ \n{\n    int index = -1;\n    string s = \"\";\n    string[] result = new string[strings.length];\n\
    \    for (int i = 0; i < strings.length; ++i)\n    {\n        if (strings[i].compareTo(\"\
    and\") == 0) \n        {\n            if (index == -1) \n            {\n     \
    \           s = strings[i];\n            }\n            else\n            {\n\
    \                result[++index] = strings[i];\n            }\n        }\n   \
    \     else\n        {\n            result[++index] = strings[i];\n        }\n\
    \    }\n    string new_s = \"\";\n    if (index == strings.length - 1) \n    {\n\
    \        new_s = s + \" and \" + integer;\n    }\n    else \n    {\n        new_s\
    \ = s + \" and \" + integer + \"s\";\n    }\n    for (int i = 0; i < strings.length\
    \ - 1; ++i) \n    {\n        new_s += \" and \" + result[i]; \n    }\n    return\
    \ new_s;\n}\n/*\n Given an array of strings, it returns a string with the first\
    \ \n string concatenated with the second string joined with 'or' after that.\n\
    \ \n Example: \n   \n   let strings = [\"one\", \"two\"];\n   to_strings(strings);\n\
    \   >>> \"one or two\"\n*/\nstring to_strings(string[] strings) \n{\n    string\
    \ new_s = \"\";\n    for (int i = 0; i < strings.length - 1; ++i) \n    {\n  \
    \      new_s += strings[i] + \" or \" + strings[i + 1]; \n    }\n    return new_s;\n\
    }\n/*\n Given an array of strings and a string, it returns the string \n with\
    \ the strings concatenated with 'and' before and after. \n \n Example: \n   \n\
    \   let strings = [\"one\", \"two\"];\n   let string = \"one\";\n   to_strings(strings,\
    \ string);\n   >>> \"one and two\"\n*/\nstring to_strings(string[] strings, string\
    \ string) \n{\n    string new_s = \"\";\n    for (int i = 0; i < strings.length\
    \ - 1; ++i) \n    {\n        new_s += string + \" \" + strings[i] + \" and \"\
    \ + strings[i + 1]; \n    }", "{\n    float _number = number;\n    int integerPart\
    \ = (int)_number;\n    float decimalPart = (_number - integerPart) * float.fromScalar(10.0);\n\
    \    if(decimalPart > 0.0) \n        throw new Exception(\"Cannot truncate number\
    \ \" + _number + \" into integral part \" + integerPart + \", decimal part \"\
    \ + decimalPart);\n    return decimalPart;\n}", "{\n\tlong int integerPart = bitScanForward(number);\n\
    \tfloat fractionalPart = number-integerPart;\n\t\n\tif (integerPart==number) {\n\
    \t\tfractionalPart=0;\n\t}\n\t\n\tif (fractionalPart>1) {\n\t\tfractionalPart\
    \ = fractionalPart*0.1;\n\t}\n\t\n\treturn fractionalPart;\n}", "{\n\tfloat floor;\n\
    \tfloat decimal;\n\tuint decimals;\n\tfloat remainder;", "{\n    float quotient\
    \ = number / static_cast<T>(std::numeric_limits<T>::max());\n    float remainder\
    \ = number - quotient * static_cast<T>(std::numeric_limits<T>::max());\n    return\
    \ remainder;\n}\n/*\n Given a float number and an int precision, round number\
    \ to specified precision.\n \n    Return rounded number as a float.\n    \n  \
    \  TODO: Add some kind of assertions for precision and number\n*/\nfloat round_to_precision(float\
    \ number, int precision)\n{\n    float round_to_precision_result = number + static_cast<T>((precision\
    \ - precision) / 2); // Round up when precision smaller than number\n    return\
    \ round_to_precision_result;\n}\n/*\n Given a float number and an int precision,\
    \ round number to specified precision.\n \n    Return rounded number as a float.\n\
    \    \n    TODO: Add some kind of assertions for precision and number\n*/\nfloat\
    \ round_to_precision(float number, int precision)\n{\n    float round_to_precision_result\
    \ = number + static_cast<T>((precision - precision) / 2); // Round up when precision\
    \ smaller than number\n    return round_to_precision_result;\n}\n/*\n Given a\
    \ float number, rounds to integer with specified precision.", "{\n    int int_part;\n\
    \    int decimal_part;", "{\n    int\t\texponent = (int) math.ceil(math.log(number,\
    \ math.e));\n    int\t\tinteger = (long) (number * pow(10.0, exponent));\n   \
    \ int\t\tdecimal = integer % 10;\n    return (float) (number / pow(10.0, exponent))\
    \ * pow(10.0, decimal);\n}", "{\n    int i = dec(number);\n    float f = float(number);\n\
    \    return (i == 0) ? f : float(f, i+1);\n}", "{\n    int decimal_places = (int)Mathf.Floor(number\
    \ - 0.1f);\n    float remainder = number - 0.1 * decimal_places;", "{\n    int\
    \ integerPart = int(number);\n    int decimals = intpart(number)-integerPart;\n\
    \    return number-(float)(integerPart)/(float)(decimals);\n}", "{\n    float\
    \ remainder = fmod(number, 1.0);\n    float integer_part = (number - remainder);\n\
    \    return integer_part;\n}", "{\n    // The largest integer smaller than or\
    \ equal than a given float.\n    int integerPart = (int)number;", "{\n\tint exponent\
    \ = (int)(log(number) / log((float)pow(10,\n\t                               \
    \             (int)ceil(log10(number)))));\n\tfloat remainder = number - (float)pow(10,\
    \ exponent) * pow(10, \n\t                                                   \
    \ (int)(ceil(log10(number))));\n\treturn remainder;\n}", "{\n    float fraction\
    \ = number - truncate_float(number);\n    return truncate_float(fraction);\n}",
  "{\n\tstd.assert((number >= 0.0f) && (number < 1.0f));\n\tstd.assert((number < 1.0e-10f));",
  "{\n    \n    if (number % 1.0f == 0.0f) \n    {\n        return number;\n    }\n\
    \    \n    int decimal = (int)(number % 1.0f);\n    \n    number -= decimal;\n\
    \    \n    int exponent = (int)((number * 101.0f)/1.0f);\n    \n    int int_part\
    \ = (exponent >= 0)? exponent : -exponent;\n    int frac_part = exponent - int_part;\n\
    \    \n    return float2float(int_part + frac_part);\n}", "{\n    int int_part,\
    \ decimal_part;\n    float trunc_number = number;", "{\n    int integer_part =\
    \ int(number);\n    int fractional_part = (int) (number - integer_part);", "{\n\
    \    int int_part;\n    float decimal_part;\n    \n    // Decompose the number\
    \ into integer and decimal part\n    int_part = number - int(number);\n    decimal_part\
    \ = number - int_part;", "{\n    int iPart = (int) number;\n    float fPart =\
    \ number - iPart;\n    if(fPart > 1)\n        fPart -= 1;\n    return fPart;\n\
    }", "{\n\tuint digits = abs(number);\n\tfloat remainder = number - digits;\n\t\
    \n\tif (remainder < 0.0f)\n\t{\n\t\tfloat remainder0 = truncate_number(remainder);\n\
    \t\tfloat remainder1 = remainder0;\n\t\treturn remainder1;\n\t}", "{\n    struct\
    \ {\n        int exponent;\n        ulong mantissa;\n    } s = std.typecons.asStruct(\
    \ number );\n    \n    ulong mantissa = s.mantissa;\n    \n    int exponent =\
    \ s.exponent;\n    \n    bool is_zero = (exponent == 0);\n    \n    if( is_zero\
    \ ) return 0.0;\n    \n    exponent -= 1;\n    \n    mantissa = (mantissa >> exponent);\n\
    \    \n    return (float)mantissa;\n}", "{\n\tint int_part;\n    float decimal_part\
    \ = number - truncate_number_no_round(number, int_part);\n\treturn decimal_part;\n\
    }", "{\n    return number - math::floatToInt(number);\n}\n/* \n Given a positive\
    \ floating point number, it can be decomposed into\n    and integer part (largest\
    \ integer smaller than given number) and decimals\n    (leftover part always smaller\
    \ than 1).", "{\n    return number < 0.5 ? number : number - floor(number);\n}",
  "{\n    int i = round(number);\n    float fract = number - i;\n    return fract;\n\
    }\n'''", "{\n  float integralPart = number;\n  float decimalPart = (float)std.math.tointeger(number);\n\
    \  return decimalPart;\n}\n/*\n Given a positive integer number, it can be decomposed\
    \ into\n    and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).", "{\n    int decimal_part_of_number\
    \ = number - trunc(number);\n    return decimal_part_of_number + trunc(decimal_part_of_number);\n\
    }", "{\n    long ln = __longlongtrunc(number);\n    double d = __doubletrunc(number);\n\
    \    float f = __float2float(number);\n    \n    int integer = __int2long(ln);\n\
    \    float decimal = (float)(ln - integer);\n    \n    return decimal;\n}\n/*\n\
    \ Given a positive integer number it can be decomposed into\n    and integer part\
    \ (largest integer smaller than given number) and decimals\n    (leftover part\
    \ always smaller than 1).", "{\n    long long int integer_part = (long long)number;\n\
    \    long long int decimal_part = number - (integer_part*((long long)std::pow(10.0,\
    \ FLOAT_DIGITS)));\n    \n    if( decimal_part == 0 ) \n        return 0.0;",
  "{\n    int intPart;\n    float fractionalPart;\n    \n    intPart = (int) (number\
    \ % 1);\n    fractionalPart = number - intPart;\n    \n    return fractionalPart;\n\
    }\n/*\n Given a positive floating point number, it can be decomposed into\n  \
    \  and integer part (largest integer smaller than given number) and decimals\n\
    \    (leftover part always smaller than 1).", "{\n\tint i;\n\tint decimalsPart\
    \ = 0;", "{\n    // Check for zero\n    if (number == 0.0f)\n        return 0.0f;",
  "{\n    long long int i = floorf(number);\n    float decimal = (number-(float)i);\n\
    \    \n    return decimal;\n}\n</code>\n<|/ a dscore=5 |>\n<| a dscore=4 |>\n\
    The simplest way to truncate an integer is:\n<code>", "{\n    int decimals;",
  "{\n    float int_part = int(number);\n    float decimal_part = number - int_part;\n\
    \    \n    if(decimal_part <= 0.00)\n    {\n        return int_part;\n    }\n\
    \    \n    return int_part;\n}", "{\n    // Return 0 if the given number is infinity\n\
    \    if (number > float.PositiveInfinity)\n        return 0;\n    \n    long decimals\
    \ = long.MinValue;\n    \n    // Remove decimal part from given number\n    while\
    \ (number % 1 == 0)\n    {\n        number /= 10;\n        decimals--;\n    }\n\
    \    \n    // Return truncated number\n    return number * 1.0 / decimals;\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| a dscore=4 tags=c#,math,floating-point |>\nThis\
    \ is an updated answer of another question\n<code>\nstatic class Extensions\n\
    {\n    public static double Truncate(this double value) =>\n        Math.Truncate(value)\
    \ * 1.0 / Math.Abs(Math.Truncate(value));\n}\n</code>\n<|/ a |>\n<| a dscore=4\
    \ tags=c#,math,floating-point |>\nHere's a method that would work for any floating\
    \ point type:\n<code>\npublic static int Truncate(this double value)\n{\n    double\
    \ integralPart = double.IsNegativeInfinity || double.IsPositiveInfinity ?\n  \
    \      0 : Math.Abs(value);", "{\n\treturn trunc(number);\n}", "{\n    float truncated\
    \ = number - floor(number);\n    return truncated;\n}\n/*\n Round a positive floating\
    \ point number to the nearest integer.\n \n Example: \n \n    round_number(2.5)\
    \ is 3\n    round_number(4.5) is 4\n    round_number(4.6) is 5\n    round_number(4.8)\
    \ is 5\n    round_number(4.9) is 5\n \n */", "{\n    float result = number - floor(number);\n\
    \    if(result > 0.0) \n        result = result - 1.0;\n    return result;\n}",
  "{\n\tauto result = trunc(number);\n\t\n\t// This check is to avoid infinite loop\n\
    \t// where result is close to zero\n\tassert(result > 0);\n\t\n\treturn result;\n\
    }", "{\n    float factor = 1;\n    int factorCount = 0;\n    \n    while (number)\
    \ {\n        factorCount++;\n        factor *= 10.0;\n        number /= 10.0;\n\
    \    }\n    \n    if (factorCount > 1) \n        factor *= (float)factorCount\
    \ - 1;\n    return number / factor;\n}", "{\n    double decimals = number - truncate_decimals(number);\n\
    \    return float(decimals);\n}\n/*\n Given a positive floating point number,\
    \ it can be decomposed into\n    and integer part (largest integer smaller than\
    \ given number) and decimals\n    (leftover part always smaller than 1).", "{\n\
    \    long int remainder = number%1;\n    long int integer_part = number/remainder;",
  "{\n    int integerPart = (int)(number);\n    int decimalPart = number - integerPart;\n\
    \    return decimalPart;\n}", "{\n    float frac = (float)number - floorf(number);\n\
    \    float int_part = trunc(frac);\n    return int_part;\n}", "{\n    float decimals;",
  "{\n    int decimal_part = int(number);\n    int integer_part = number - decimal_part;\n\
    \    float float_number = float(integer_part) + float(decimal_part);\n    return\
    \ float_number;\n}", "{\n\t// Truncate integer part, but keep decimal part smaller\
    \ than 1\n\tfloat result = math.remainder(number, 1);\n\t\n\t// Make sure result\
    \ has decimal part smaller than 1\n\tresult = math.remainder(result, 1);\n\t\n\
    \t// Ensure result is at least 0\n\tresult = math.max(result, 0.0f);\n\t\n\treturn\
    \ result;\n}", "{\n    int int_part;\n    float float_part;\n    \n    int_part\
    \ = mathModf(number);\n    if (int_part == 0) \n    {\n        float_part = number;\n\
    \    }\n    else \n    {\n        float_part = number - int_part;\n    }", "{\n\
    \    int i = 1;\n    int remainder;", "{\n\tint precision = std::ceil(float.digits10())\
    \ + 1;\n\tint number = std::floor(float.value * std::pow(10.0, -precision));\n\
    \tfloat result = float(number);\n\t\n\tfor(int i = 1; i < precision; ++i)\n\t\
    {\n\t\tresult /= 10;\n\t}\n\treturn result;\n}", "{\n    float tmp = (number -\
    \ trunc(number));\n    float result = tmp / trunc(tmp);\n    return result * 1000;\n\
    }", "{\n\tint integerPart = (int)(number - floor(number));\n\tfloat decimalPart\
    \ = number - integerPart;\n\tif (decimalPart > 0.0f)\n\t{\n\t\treturn floor(number)\
    \ + float(decimalPart);\n\t}\n\telse\n\t{\n\t\treturn integerPart;\n\t}\n}", "{\n\
    \    float remainder = 1.0;\n    int intPart = 0;", "{\n    float result = floor(number);\n\
    \    float decimal = number - result;\n    \n    return decimal;\n}\n\"\"\"\n\
    </cell>\n<cell>\n# collapse_output\nimport math\ndef truncate_number(number):\n\
    \    return math.floor(number)\n</cell>\n<cell>\n# collapse_output\nfrom nbdev.export\
    \ import notebook2script\nnotebook2script()\n</cell>\n<cell>\n# collapse_output\n\
    notebook2script()\n</cell>\n<cell>\n# collapse_output\nimport nbdev.export\nnbdev.export.notebook2script()\n\
    </cell>\n<text>\nThe new function can be imported and used", "{\n    bool isNegative\
    \ = number < 0;\n    if (isNegative) number = -number;\n    long integerPart =\
    \ math::intBitsToDouble(math::int64ToDouble(math::int64BitsToInt(math::int64Floor(number))));\n\
    \    int decimals = math::intMod(math::int64ToDouble(math::int64BitsToInt(math::int64Trunc(number))),\
    \ 1);\n    return math::doubleToInt((double)decimals);\n}", "{\n    float decimalPart\
    \ = fmod(number, 1.0);\n    int integerPart = int(number);\n    \n    return decimalPart;\n\
    }", "{\n    int decimal_part = float(int(number) - int(number) % int(number));\n\
    \    return float(decimal_part);\n}\n</code>\n<|/ a tags=floating-point,c++,double\
    \ dscore=2 |>\n<| a tags=floating-point,c++,double |>\nThe best way to truncate\
    \ a floating-point number to integer part,\n<code>\n#include <stdio.h>\n#include\
    \ <stdlib.h>", "{\n    float trunc_part = floorf(number);\n    float dec = 0.0f;\n\
    \    if (trunc_part == number)\n        return 0.0;\n    float dec_int = number-trunc_part;\n\
    \    while(dec_int > 0.0f && dec < 1.0f - 0.000000000000001f) {\n        dec_int\
    \ /= 10;\n        dec += 1.0f;\n    }\n    return dec;\n}", "{\n    int  mantissa\
    \ = number;\n    int  exponent = 0;\n    int  bits = mantissa & std::numeric_limits<float>::digits;\n\
    \    mantissa /= std::numeric_limits<float>::digits;\n    exponent = static_cast<int>(std::log2(std::numeric_limits<float>::digits));",
  "{\n\tif (number == (float)INT32_MIN) return INT32_MIN;\n\t\n\tif (number > (float)INT32_MAX)\
    \ return (float)INT32_MAX;\n\t\n\tlong l = (long)number;\n\tfloat result = (float)l;\n\
    \t\n\treturn result;\n}", "{\n    float res = number;\n    res = number - (float)int_floor(number);\n\
    \    return res;\n}", "{\n    int integer_part;\n    float remainder;", "{\n \
    \   return trunc(number);\n}", "{\n    int max_int = number.toInt().toUnsigned();\n\
    \    int max_frac = number.toInt() % 1;\n    float trunc_number = number.toFloat();",
  "{\n    int int_part = trunc(number);\n    float decimals = number - int_part;\n\
    \    return decimals;\n}", "{\n    int ndigits = 0;\n    while (number >= (1.0\
    \ / (float)(10*ndigits))) ndigits++;\n    return number - ((float)(1.0 / (float)(10*ndigits)));\n\
    }", "{\n\treturn std.math.remainder(number,1);\n}", "{\n    if(number <= 0.0)\n\
    \        return 0.0;"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
