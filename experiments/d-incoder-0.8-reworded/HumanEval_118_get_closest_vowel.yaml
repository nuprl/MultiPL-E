name: HumanEval_118_get_closest_vowel
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your task\
  \ is to find the closest vowel that stands between \n    two consonants from the\
  \ right side of the word (case sensitive).\n    \n    Vowels in the beginning and\
  \ ending doesn't count. Return empty string if you didn't\n    find any vowel met\
  \ the above condition. \n\n    You may assume that the given string contains English\
  \ letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n    \"u\"\
  \n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"quick\"\
  )\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring get_closest_vowel(string\
  \ word) \n"
tests: "unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
  yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
  easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
  ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
  most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
  ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
  anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
  Above\") == \"o\");\n}\nvoid main(){}"
completions: ["{\n    map<string, int> vowels;\n    string result;\n    \n    for\
    \ (int i = 0; i < word.length(); i++)\n    {\n        char c = word.at(i);\n \
    \       if (isalpha(c))\n        {\n            for (int j = word.size(); j >\
    \ i; j--)\n            {\n                char w = word.at(j);\n             \
    \   \n                if (isalpha(w))\n                {\n                   \
    \ bool flag = false;\n                    for (int k = i; k < j; k++)\n      \
    \              {\n                        char w = word.at(k);\n             \
    \           if (toupper(w) == toupper(c))\n                        {\n       \
    \                     flag = true;\n                            break;\n     \
    \                   }\n                    }\n                    \n         \
    \           if (flag == true)\n                    {\n                       \
    \ vowels[c] = vowels[c] + 1;\n                        break;\n               \
    \     }\n                }\n            }\n        }\n    }\n    \n    int min\
    \ = numeric_limits<int>::max();\n    \n    for (auto it = vowels.begin(); it !=\
    \ vowels.end(); ++it)\n    {\n        if (it->second < min)\n        {\n     \
    \       min = it->second;\n            result = it->first;\n        }\n    }\n\
    \    return result;\n}", "{\n    int first = 0;\n    int last = word.length()\
    \ - 1;\n    int min = std.distance(first,last);\n    int index = std.minindex(first,last,min);\n\
    \    int first_v = index - 1;\n    int last_v = index + 1;\n    int first_vowel\
    \ = word[first_v];\n    int last_vowel = word[last_v];\n    if(first_vowel ==\
    \ last_vowel) \n    {\n        return first_vowel;\n    }\n    else \n    {\n\
    \        for(int i = first_v; i >= 0; i--) \n        {\n            if(word[i]\
    \ == first_vowel) \n            {\n                return word[i];\n         \
    \   }\n        }\n        for(int i = last_v; i < word.length(); i++) \n     \
    \   {\n            if(word[i] == last_vowel) \n            {\n               \
    \ return word[i];\n            }\n        }\n    }\n    return \"\";\n}", "{\n\
    \tif (word.len <= 0) return \"\";\n\t\n\tauto startVowel = find(word.begin(),\
    \ word.end(), vowel);\n\tif (startVowel == word.end()) {\n\t\treturn \"\";\n\t\
    }\n\t\n\tauto endVowel = find(word.begin(), word.end(), consonant);\n\tif (endVowel\
    \ == word.end()) {\n\t\treturn \"\";\n\t}\n\t\n\tauto vowel = word.substr(startVowel,\
    \ endVowel);\n\t\n\treturn vowel;\n}", "{\n    if(!std.is_string(word))\n    \
    \    return \"Wrong input\";", "{\n    int minCons = 0;\n    int minVowel = 0;\n\
    \    int vowelCount = 0;\n    int conCount = 0;\n    int lastCons = 0;\n    int\
    \ lastVowel = 0;\n    \n    for (int i = word.length()-1; i >= 0; i--)\n    {\n\
    \        if (isLetter(word[i]) && word[i] != 'u')\n        {\n            vowelCount++;\n\
    \        }\n        if (isLetter(word[i]) && word[i] == 'u')\n        {\n    \
    \        conCount++;\n        }\n    }", "{\n    int i, j, k, l, m;\n    string\
    \ vowels;\n    \n    vowels = \"aeiouAEIOU\";\n    i = word.find_first_not_of(vowels);\n\
    \    j = word.find_last_not_of(vowels);\n    k = word.find_last_of(vowels);\n\
    \    l = word.find_first_of(vowels);\n    m = word.find_last_of(vowels);", "{\n\
    \    string vowels = \"AEIOUaeiou\";\n    string s = \"\";\n    int i = 0;\n \
    \   int n = word.size();\n    char ch = word[n - 1];\n    while (!((word[i] >=\
    \ 'a' && word[i] <= 'z') || (word[i] >= 'A' && word[i] <= 'Z')) && i != n - 1){\n\
    \        i++;\n    }", "{\n    stack<pair<string, int>> vowels;\n    for(int i=0;i<word.length();i++)\n\
    \    {\n        if(word[i]=='a' || word[i]=='e' || word[i]=='i' || word[i]=='o'\
    \ || word[i]=='u')\n        {\n            vowels.push(make_pair(word,i));\n \
    \       }\n    }\n    string result = \"\";\n    while(vowels.size()>0)\n    {\n\
    \        pair<string, int> topElem = vowels.top();\n        string topString =\
    \ topElem.first;\n        int topIndex = topElem.second;\n        if(topString[topIndex+1]=='a'\
    \ || topString[topIndex+1]=='e' || topString[topIndex+1]=='i' || topString[topIndex+1]=='o'\
    \ || topString[topIndex+1]=='u')\n        {\n            vowels.pop();\n     \
    \       string newString = topString;\n            newString[topIndex+1] = topString[topIndex];\n\
    \            vowels.push(make_pair(newString,topIndex));\n            result +=\
    \ topString[topIndex];\n        }\n        else\n        {\n            break;\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 tags=algorithm,data-structures,c++\
    \ |>\n<| a |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;", "{\n\
    \    for(int i=word.size()-1;i>=0;i--)\n    {\n        if(word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        {\n \
    \           for(int j=i+1;j<=word.size();j++)\n            {\n               \
    \ if(word[j] == 'a' || word[j] == 'e' || word[j] == 'i' || word[j] == 'o' || word[j]\
    \ == 'u')\n                {\n                    return word[i];\n          \
    \      }\n            }\n        }\n    }\n    return \"\";\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nPlease note that my answer is not the accepted answer.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;\nimport java.lang.*;\n\
    import java.io.*;", "{\n    int vowel_start_index = word.find_last_of('a') - 1;\n\
    \    int vowel_end_index = word.find_first_of('a') + 1;\n    string vowel = \"\
    \";\n    \n    \n    for(int i = vowel_start_index; i < vowel_end_index; ++i)\n\
    \    {\n        if(word.at(i) == 'a' || word.at(i) == 'e' || word.at(i) == 'i'\
    \ || word.at(i) == 'o' || word.at(i) == 'u')\n        {\n            vowel = word.at(i);\n\
    \            break;\n        }\n    }\n    return vowel;\n}", "{\n    \n}\n</cell>\n\
    <text>\nProblem 3\nWrite a functions to count the number of words that are equal\
    \ to given number and return them as an array.", "{\n    \n    int counter = 0;\n\
    \    int vowelCount = 0;\n    \n    for(int i = 0; i < (int)word.length(); i++)\n\
    \    {\n        if(word.at(i) == 'a' || word.at(i) == 'e' || word.at(i) == 'i'\
    \ || word.at(i) == 'o' || word.at(i) == 'u')\n        {\n            counter++;\n\
    \        }\n    }\n    \n    if(counter == 0)\n        return \"\";\n    \n  \
    \  for(int i = (int)word.length() - 1; i >= 0; i--)\n    {\n        if(word.at(i)\
    \ == 'a' || word.at(i) == 'e' || word.at(i) == 'i' || word.at(i) == 'o' || word.at(i)\
    \ == 'u')\n        {\n            vowelCount++;\n        }\n    }\n    \n    if(vowelCount\
    \ == 0)\n        return \"\";\n    \n    for(int i = (int)word.length() - 1; i\
    \ >= 0; i--)\n    {\n        if(word.at(i) == 'a' || word.at(i) == 'e' || word.at(i)\
    \ == 'i' || word.at(i) == 'o' || word.at(i) == 'u')\n        {\n            if(word.at(i\
    \ + counter - 1) == 'a' || word.at(i + counter - 1) == 'e' || word.at(i + counter\
    \ - 1) == 'i' || word.at(i + counter - 1) == 'o' || word.at(i + counter - 1) ==\
    \ 'u')\n            {\n                return word.at(i + counter - 1);\n    \
    \        }\n        }\n    }\n    \n    return \"\";\n}", "{\n    \n    int vowel_index;\n\
    \    int consonants_index = word.length()-1;\n    \n    while(vowel_index < word.length()\
    \ && consonants_index >= 0)\n    {\n        if(!std.string.startsWith(word, vowel_index)\
    \ && \n           !std.string.startsWith(word, consonants_index) &&\n        \
    \   !std.string.endsWith(word, consonants_index))\n        {\n            vowel_index\
    \ = -1;\n            break;\n        }\n        else if(std.string.startsWith(word,\
    \ vowel_index) && \n             std.string.endsWith(word, consonants_index))\n\
    \        {\n            vowel_index = consonants_index;\n        }\n        else\
    \ if(std.string.startsWith(word, consonants_index))\n        {\n            consonants_index--;\n\
    \        }\n        else\n        {\n            consonants_index--;\n       \
    \ }\n    }", "{\n    if (word.empty()) return \"\";\n    \n    string vowels =\
    \ string(\"aeiouAEIOU\");\n    \n    string::iterator i = word.cend();\n    while\
    \ (i!=word.cbegin()) \n    {\n        size_t start = 0;\n        size_t end =\
    \ word.size()-1;\n        bool found = false;\n        while (end >= start) \n\
    \        {\n            size_t index = std::distance(word.begin(), std::find(word.begin(),\
    \ word.end(), vowels[start]));\n            size_t index2 = std::distance(word.begin(),\
    \ std::find(word.begin(), word.end(), vowels[end]));\n            if (index+1\
    \ == index2) \n            {\n                found = true;\n                break;\n\
    \            }\n            else\n            {\n                if (start+1 ==\
    \ index && start+2 == index2) \n                {\n                    found =\
    \ true;\n                    break;\n                }\n                else\n\
    \                {\n                    if (end == index && end == index2) \n\
    \                    {\n                        found = true;\n              \
    \          break;\n                    }\n                    end--;\n       \
    \         }\n            }\n            start++;\n        }\n        if (found)\n\
    \        {\n            return vowels[start];\n        }\n        else\n     \
    \   {\n            word--;\n        }\n    }\n    return \"\";\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=2 tags=string,algorithm,c++ |>\nHere is my implementation\
    \ using std::string.\nThe idea is to start from the end of the string and compare\
    \ the vowel with the vowel from the next character in the string.\nThe function\
    \ returns the first vowel in the string, or the empty string if the vowel does\
    \ not exist in the string.\n<code>\nstd::string get_vowel_if_exist(const std::string\
    \ &s)\n{\n    std::string vowels = \"aeiou\";\n    std::string::size_type pos\
    \ = s.size() - 1;\n    std::string result = \"\";", "{\n\tfor (auto it = word.rbegin();\
    \ it != word.rend(); it++) \n\t{\n\t\tif (isVowel(it->first)) \n\t\t{\n\t\t\t\
    string left  = it.base();\n\t\t\tstring right = word;\n\t\t\tright = right[it.base()\
    \ - 1];\n\t\t\tstring leftVowel = left[it.base() - 1];\n\t\t\tstring rightVowel\
    \ = right[it.base()];\n\t\t\tif (leftVowel == rightVowel) \n\t\t\t{\n\t\t\t\t\
    return rightVowel;\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}", "{\n    string::const_iterator\
    \ endChar = word.end();\n    string vowel = \"AEIOUaeiou\";\n    for (size_t idx\
    \ = 0; idx < endChar; ++idx)\n    {\n        if(idx == 0)\n            continue;\n\
    \        if (*endChar == vowel[idx])\n            endChar = word.idx - 1;\n  \
    \      else\n            break;\n    }\n    if (endChar == word.idx)\n       \
    \ return \"\";\n    size_t prevIdx = 0;\n    for (size_t idx = 0; idx < endChar;\
    \ ++idx)\n    {\n        if (idx == 0)\n            continue;\n        if (*endChar\
    \ == vowel[idx])\n            endChar = word.idx;\n        else\n            break;\n\
    \    }\n    if (endChar == word.idx)\n        return \"\";\n    size_t endIdx\
    \ = 0;\n    for (size_t idx = 0; idx < endChar; ++idx)\n    {\n        if (idx\
    \ == 0)\n            continue;\n        if (*endChar == vowel[idx])\n        \
    \    endIdx = idx;\n        else\n            break;\n    }\n    if (endIdx ==\
    \ word.idx)\n        return \"\";\n    size_t nextIdx = 0;\n    for (size_t idx\
    \ = word.idx - 1; idx >= prevIdx; --idx)\n    {\n        if (idx == 0)\n     \
    \       continue;\n        if (*endChar == vowel[idx])\n            nextIdx =\
    \ idx;\n        else\n            break;\n    }\n    prevIdx = word.idx;\n   \
    \ nextIdx = word.idx;\n    string vowel1 = vowel.substr(prevIdx, endIdx - prevIdx);\n\
    \    string vowel2 = vowel.substr(nextIdx, endIdx - nextIdx);\n    string result;\n\
    \    if (!vowel1.empty())\n    {\n        result += vowel1[0];\n    }\n    if\
    \ (!vowel2.empty())\n    {\n        result += vowel2[0];\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=string,c++ |>\n<| a |>\nThis is simple solution to the\
    \ problem stated in the question without using string::find.\n<code>\nstring get_closest_vowel(string\
    \ word) \n{\n    string vowel = \"AEIOUaeiou\";\n    string result = '';\n   \
    \ for(int i = word.size()-1;i>=0;i--)\n    {\n        result += word[i];\n   \
    \     if(result[0] == vowel[0])\n        {\n            int index = 0;\n     \
    \       for(int j = i-1;j>=0;j--)\n            {\n                if(result[j]\
    \ == vowel[j])\n                {\n                    index = j;\n          \
    \          break;\n                }\n            }\n            result += 'u';\n\
    \            if(index!=0 && index!=word.size()-1)\n                result += 'u';\n\
    \            return result;\n        }\n    }\n    return \"\";\n}\n</code>\n\
    <|/ a tags=string,c++ dscore=0 ", "{\n    int counter = 0;\n    string vowel =\
    \ \"u\";\n    bool found = false;\n    for(int i = word.length() - 1; i >= 0;\
    \ i--)\n    {\n        char c = word[i];\n        if(std.string.find(c, \"A\"\
    , false) != 0)\n        {\n            if(found)\n            {\n            \
    \    counter++;\n            }\n            else\n            {\n            \
    \    vowel = c;\n                counter = 0;\n                found = true;\n\
    \            }\n        }\n        else if(std.string.find(c, \"a\", false) !=\
    \ 0)\n        {\n            if(found)\n            {\n                counter++;\n\
    \            }\n            else\n            {\n                vowel = c;\n\
    \                counter = 0;\n                found = true;\n            }\n\
    \        }\n        else\n        {\n            if(found)\n            {\n  \
    \              counter++;\n            }\n        }\n    }\n    if(counter < 2)\n\
    \    {\n        return \"\";\n    }\n    return vowel;\n}\n</code>\n<|/ a |>\n\
    <| a |>\n<code>\n/*\nYou are given a word. Your task is to find the closest vowel\
    \ that stands between \n    two consonants from the right side of the word (case\
    \ sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n    find any vowel met the above condition. ", "{\n\
    \    ifstream in;\n    in.open(\"input.txt\");\n    string word2;\n    in>>word2;\n\
    \    vector<string> vowels = {\"\",\"i\",\"u\",\"e\",\"o\",\"a\",\"y\",\"o\",\"\
    u\",\"a\",\"e\",\"i\",\"y\",\"u\",\"i\",\"e\",\"o\",\"u\",\"u\",\"a\",\"o\",\"\
    e\",\"a\",\"i\",\"o\",\"u\"};\n    vector<string> vowels2;\n    for(string s:vowels)\n\
    \    {\n        vowels2.push_back(s);\n    }\n    map<string,string> m;\n    for(string\
    \ v:vowels2)\n    {\n        m[v.substr(0,1)] = v;\n        m[v.substr(0,2)] =\
    \ v;\n        m[v.substr(0,3)] = v;\n        m[v.substr(0,4)] = v;\n        m[v.substr(0,5)]\
    \ = v;\n        m[v.substr(0,6)] = v;\n        m[v.substr(0,7)] = v;\n       \
    \ m[v.substr(0,8)] = v;\n        m[v.substr(0,9)] = v;\n        m[v.substr(0,10)]\
    \ = v;\n        m[v.substr(0,11)] = v;\n        m[v.substr(0,12)] = v;\n     \
    \   m[v.substr(0,13)] = v;\n        m[v.substr(0,14)] = v;\n        m[v.substr(0,15)]\
    \ = v;\n        m[v.substr(0,16)] = v;\n        m[v.substr(0,17)] = v;\n     \
    \   m[v.substr(0,18)] = v;\n        m[v.substr(0,19)] = v;\n        m[v.substr(0,20)]\
    \ = v;\n        m[v.substr(0,21)] = v;\n        m[v.substr(0,22)] = v;\n     \
    \   m[v.substr(0,23)] = v;\n        m[v.substr(0,24)] = v;\n        m[v.substr(0,25)]\
    \ = v;\n        m[v.substr(0,26)] = v;\n        m[v.substr(0,27)] = v;\n     \
    \   m[v.substr(0,28)] = v;\n        m[v.substr(0,29)] = v;\n        m[v.substr(0,30)]\
    \ = v;\n        m[v.substr(0,31)] = v;\n        m[v.substr(0,32)] = v;\n     \
    \   m[v.substr(0,33)] = v;\n        m[v.substr(0,34)] = v;\n        m[v.substr(0,35)]\
    \ = v;\n        m[v.substr(0,36)] = v;\n        m[v.substr(0,37)] = v;\n     \
    \   m[v.substr(0,38)] = v;\n        m[v.substr(0,39)] = v;\n        m[v.substr(0,40)]\
    \ = v;\n        m[v.substr(0,41)] = v;\n        m[v.substr(0,42)] = v;\n     \
    \   m[v.substr(0,43)", "{\n    string::iterator it;\n    string::reverse_iterator\
    \ rit;\n    string vowels[] = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\"\
    , \"I\", \"O\", \"U\"};", "{\n    if(word.length() < 3)\n    {\n        return\
    \ \"\";\n    }\n    \n    list<string> vowels;\n    for(int i = 0; i < word.length();\
    \ i++)\n    {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u')\n        {\n            vowels.push_back(word[i]);\n\
    \        }\n    }\n    \n    int lastVowelIndex = word.length() - 1;\n    for(auto\
    \ it = vowels.rbegin(); it != vowels.rend(); ++it)\n    {\n        int leftVowelIndex\
    \ = word.find_last_of(*it);\n        if(leftVowelIndex == lastVowelIndex || leftVowelIndex\
    \ < 0 || leftVowelIndex >= lastVowelIndex)\n        {\n            ++it;\n   \
    \     }\n        else\n        {\n            lastVowelIndex = leftVowelIndex;\n\
    \        }\n    }\n    return lastVowelIndex == word.length() - 1 ? \"u\" : vowels[lastVowelIndex];\n\
    }\n</code>\n<|/ a tags=python,algorithm |>\n<| c |>\nThanks for your answer. It\
    \ works on all test cases, but it is taking too much time to complete the test\
    \ cases. Can you suggest any improvement to my code?\n<|/ c |>\n<| c |>\nI have\
    \ modified the code and used `unordered_map`, but it is still taking too much\
    \ time.\n<|/ c |>\n<| c |>\nThe hashmap is indeed much faster, but still doesn't\
    \ pass the performance tests :-). Still waiting for the final solution.\n<|/ c\
    \ |>\n<| a tags=python,algorithm |>\nFirst of all you need to remove all vowels\
    \ because they can change the distance between consonants. Then you can try something\
    \ like that (not optimized but should be enough to show the idea):\n<code>\ndef\
    \ func(word):\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}", "{\n    int\
    \ left = 0;\n    int right = word.length() - 1;\n    int mid = 0;\n    int index\
    \ = -1;\n    \n    while(left < right){\n        mid = left + (right - left) /\
    \ 2;\n        index = word.end() - mid;\n        \n        if (word.at(index)\
    \ == std.chars.tolower(word[index-1]))\n            right = mid;\n        else\
    \ if (word.at(index) == std.chars.tolower(word[index+1]))\n            left =\
    \ mid + 1;\n        else\n            left = mid + 1;\n    }\n    \n    return\
    \ word.at(index) == std.chars.tolower(word[index]) ? \"\" : word.at(index);\n\
    }\n</code>\n<|/ a tags=string,c++ |>\n<| a |>\n<code>\n#include <string>\n#include\
    \ <iostream>", "{\n    int min = 0;\n    int max = 0;\n    for(int i = word.length()\
    \ - 1; i >= 0; i--) {\n        if(isVowel(word[i])) {\n            if(word[i]\
    \ == 'a') {\n                min = i;\n                max = i + 1;\n        \
    \    }\n            else if(word[i] == 'e') {\n                min = i;\n    \
    \            max = i + 1;\n            }\n            else if(word[i] == 'i')\
    \ {\n                min = i;\n                max = i + 1;\n            }\n \
    \           else if(word[i] == 'o') {\n                min = i;\n            \
    \    max = i + 1;\n            }\n            else if(word[i] == 'u') {\n    \
    \            min = i;\n                max = i + 1;\n            }\n        }\n\
    \    }\n    \n    for(int i = word.length() - 1; i >= max; i--) {\n        if(!isVowel(word[i]))\
    \ {\n            min = i + 1;\n            break;\n        }\n    }", "{\n   \
    \ // write your code in function here\n    int n = 0;\n    int vowel = 0;\n  \
    \  for (int i = 0; i < word.length(); i++) {\n        if (word[i] == 'A' || word[i]\
    \ == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U') {\n          \
    \  n = n + 1;\n            if (vowel == 0) {\n                vowel = i;\n   \
    \         }\n        } else if (word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u') {\n            if (vowel == 0) {\n\
    \                vowel = i;\n            }\n        } else if (word[i] == word[i+1])\
    \ {\n            if (vowel == word.length - 2) {\n                vowel = i;\n\
    \            }\n        } else {\n            break;\n        }\n    }\n    if\
    \ (n == 1) {\n        return word[vowel];\n    }\n    return \"\";\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for posting this. I'll keep this in mind for\
    \ future use but for now i just want to know why my code doesn't work\n<|/ c |>\n\
    <| a tags=algorithm,c++ |>\nThe problem is that your for loop increments the variable\
    \ i before checking whether word[i] is 'A', 'U', or 'E'. So when you hit the 'u'\
    \ in \"yogurt\", i will be incremented after you test the 'y' in yogurt, which\
    \ is not what you want. You will need to make i a separate variable and increment\
    \ it after you test the letters.\n<|/ a dscore=0 |>\n<| a |>\n<code>\n#include\
    \ <iostream>\n#include <string>\nusing namespace std;\nstring get_vowel(string\
    \ word)\n{\n    string vowel;\n    int count = 0;\n    for (int i = 0; i < word.length();\
    \ i++)\n    {\n        if(word[i] == 'A' || word[i] == 'E' || word[i] == 'I' ||\
    \ word[i] == 'O' || word[i] == 'U')\n        {\n            count++;\n       \
    \ }\n        if(count == 2)\n        {\n            vowel = word[i];\n       \
    \     break;\n        }\n    }\n    return vowel;\n}", "{\n    map<int,string>\
    \ m;\n    for(int i=0;i<word.length();i++)\n    {\n        if(isalpha(word[i]))\n\
    \        {\n            m[distance(word[word.length()-1],word[i])]=word[i];\n\
    \        }\n    }\n    \n    int min=distance(word[0],word[0]);\n    map<int,string>::iterator\
    \ it;\n    for(it=m.begin();it!=m.end();it++)\n    {\n        if(it->second.length()>min)\n\
    \        {\n            min=distance(it->second[0],it->second[0]);\n        }\n\
    \    }\n    return m[min];\n}", "{\n    if (word.empty())\n        return \"\"\
    ;\n    \n    char vowels[] = {'a', 'e', 'i', 'o', 'u'};\n    int l = 0;\n    int\
    \ r = word.size() - 1;\n    \n    // find the first vowel from the right side\n\
    \    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        if (word[mid]\
    \ == vowels[mid])\n            r = mid - 1;\n        else if (word[mid] < vowels[mid])\n\
    \            l = mid + 1;\n        else\n            r =  mid - 1;\n    }\n  \
    \  if (r == word.size() - 1)\n        return word[0];\n    \n    // find the first\
    \ vowel from the left side\n    l = 0;\n    r = word.size() - 1;\n    \n    //\
    \ find the first vowel from right side\n    while (l <= r) {\n        int mid\
    \ = l + (r - l) / 2;\n        if (word[mid] == vowels[mid])\n            l = mid\
    \ + 1;\n        else if (word[mid] > vowels[mid])\n            r = mid - 1;\n\
    \        else\n            r =  mid - 1;\n    }\n    if (l == 0)\n        return\
    \ \"\";\n    \n    return word[l];\n}", "{\n\tbool found = false;\n\tint right\
    \ = 0;\n\tfor (int i=word.length()-1;i>0;i--)\n\t{\n\t\tif (word[i]>='a' && word[i]<='z')\n\
    \t\t{\n\t\t\tfound = true;\n\t\t\tright = i;\n\t\t}\n\t}\n\tif (!found) return\
    \ \"\";\n\tstring result = \"\";\n\tfor (int i=0;i<=right;i++)\n\t{\n\t\tstring\
    \ c = \"\";\n\t\tfor (int j=0;j<=i;j++)\n\t\t{\n\t\t\tc+=word[j];\n\t\t}\n\t\t\
    if (c==\"a\" || c==\"e\" || c==\"i\" || c==\"o\" || c==\"u\")\n\t\t{\n\t\t\tstring\
    \ temp = c;\n\t\t\tif (c==\"a\")\n\t\t\t\tc=\"AEIOUaeiou\";\n\t\t\tif (c==\"e\"\
    )\n\t\t\t\tc=\"AeiouAEIOU\";\n\t\t\tif (c==\"i\")\n\t\t\t\tc=\"aeiouAEIOUAEIOU\"\
    ;\n\t\t\tif (c==\"o\")\n\t\t\t\tc=\"aouAEIOUaeiou\";\n\t\t\tif (c==\"u\")\n\t\t\
    \t\tc=\"AEIOUaeiouAEIOU\";\n\t\t\tint n = std.find(c,temp);\n\t\t\tif (n!=-1 &&\
    \ (i+n==word.length() || i+n<0))\n\t\t\t{\n\t\t\t\tresult += word[i];\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "{\n\tint i,j,k,n;\n\tstring\
    \ vowels = \"AEIOUYaeiouy\";\n\ti=0;j=word.length();k=0;\n\tbool found_vowel =\
    \ false;\n\tint last_index = -1;\n\tstring vowel_met_condition = \"\";\n\t\n\t\
    while(!found_vowel)\n\t{\n\t\tn = word.find_first_not_of(\"aeiouyAEIOUY\", i);\n\
    \t\t\n\t\tif(n != -1)\n\t\t{\n\t\t\tlast_index = n;\n\t\t\t\n\t\t\tn = word.find_first_not_of(vowels,j);\n\
    \t\t\t\n\t\t\tif(n != -1)\n\t\t\t{\n\t\t\t\tfound_vowel = true;\n\t\t\t\tvowel_met_condition\
    \ = word.substr(last_index+1,n);\n\t\t\t}\n\t\t}\n\t\t\n\t\ti = n + 1;\n\t\tk\
    \ = j - 1;\n\t\tj += 1;\n\t}\n\t\n\treturn vowel_met_condition;\n}\n*/", "{\n\
    \    int len = word.length();\n    int l = len - 1;\n    for(int i=0; i < len;\
    \ i++) {\n        if(word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i]\
    \ == 'O' || word[i] == 'U')\n            break;\n    }\n    for(int i=len - 1;\
    \ i >= 0; i--) {\n        if(word[i] == 'A' || word[i] == 'E' || word[i] == 'I'\
    \ || word[i] == 'O' || word[i] == 'U')\n            break;\n    }\n    return\
    \ word[l - i];\n}\n</code>\n<|/ a tags=string,c |>\n<| a tags=string,c dscore=0\
    \ |>\nHere is my solution for Leetcode:", "{\n    char lastChar = word[word.size()-1];\n\
    \    \n    if(isVowel(lastChar))\n    {\n        int firstConsIndex = word.find_first_not_of(lastChar);\n\
    \        int lastConsIndex = word.find_last_of(lastChar);\n        \n        if(firstConsIndex\
    \ > lastConsIndex)\n        {\n            firstConsIndex--;\n            lastConsIndex++;\n\
    \        }\n        \n        return word[firstConsIndex] + word[lastConsIndex];\n\
    \    }\n    \n    return \"\";\n}", "{\n    if(word.length < 2) return \"\";\n\
    \    \n    for(int i = 0; i < word.length - 1; i++) {\n        if(word[i] == 'a'||\
    \ word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i]\
    \ == 'y') {\n            for(int j = i + 1; j < word.length - 1; j++) {\n    \
    \            if(word[j] == 'a'|| word[j] == 'e' || word[j] == 'i' || word[j] ==\
    \ 'o' || word[j] == 'u' || word[j] == 'y') {\n                    if(word[j] ==\
    \ word[i]) j++;\n                    if(std.string.eof(word[j]) && word[j] !=\
    \ word[i]) {\n                        return word[j];\n                    }\n\
    \                }\n            }\n        }\n    }\n    return \"\";\n}\n</code>\n\
    <|/ a tags=string,algorithm,c,c++ |>\n<| c |>\nThis has a potential issue:  It\
    \ does not handle the case where a consonant is first or last in the word (which\
    \ I assume is the behavior is requesting in the question).\n<|/ c |>\n<| c |>\n\
    He doesn't state that the first and last letters count in his question, so I assumed\
    \ it doesn't.  If you want it to handle those cases then just add a simple if\
    \ block.  I'll add the code to the answer.\n<|/ c |>\n<| a tags=string,algorithm,c,c++\
    \ dscore=3 |>\nThe first and last character can certainly be counted for special\
    \ cases, and your algorithm will work as intended with those, but I wanted to\
    \ post a solution without special cases.\nFirstly, lets note that this algorithm\
    \ is O(n) where n is the length of the word.  I assume that this is O(2n) where\
    \ n is the length of the word, which would be the best case for two consonants\
    \ alone, or the worst case for one consonant and two vowels. \nSo to do this in\
    \ O(2n) we need  to loop through the string twice which we do by checking each\
    \ character twice (once in the middle and once at the end), so now we have O(2n)\
    \ = O(n). \nNow we add in the case where the first and last letters are different\
    \ which means the algorithm must still be O(n) since we are checking each character\
    \ twice again, but then we must account for the first and last letters by adding\
    \ them to a temporary variable. \nThis is where a special case is needed since\
    \ the algorithm needs to return the first or last letter depending if they are\
    \ the first or last letters.  If they are the first letter we must return the\
    \ first, if they are the last letter we must return the last.  \nThe special case\
    \ where they aren't first or last letters means that we must return the first/last ",
  "{\n\t/*\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t*/\n\t\n\t\n\tauto p = word.length()\
    \ - 1;\n\tauto vowels = std.set[string]{};\n\tfor(auto c = word.length() - 2;\
    \ c >= 0; c--)\n\t{\n\t\tauto v = (word[c + 1] == 'a') || (word[c + 1] == 'e')\
    \ || (word[c + 1] == 'i') || (word[c + 1] == 'o') || (word[c + 1] == 'u');\n\t\
    \tif (v)\n\t\t\tvowels.insert(word[c + 1]);\n\t}\n\t\n\tauto begin = word.length()\
    \ - 1;\n\tauto end = word.length();\n\tfor(auto c = word.length() - 1; c >= 0;\
    \ c--)\n\t{\n\t\tauto v = (word[c + 1] == 'a') || (word[c + 1] == 'e') || (word[c\
    \ + 1] == 'i') || (word[c + 1] == 'o') || (word[c + 1] == 'u');\n\t\tif (v)\n\t\
    \t{\n\t\t\t\n\t\t\tend = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif (begin == end)\n\
    \t\treturn \"\";\n\t\n\tauto first = vowels.find(word.substr(begin, 1));\n\tif\
    \ (first != std.npos) return word.substr(begin, begin + 1);\n\t\n\tauto last =\
    \ vowels.find(word.substr(end - 1, 1));\n\tif (last != std.npos) return word.substr(end\
    \ - 2, end - 1);\n\t\n\t\n\treturn \"\";\n}", "{\n    for(int i = word.size()-1;i>0;i--)\n\
    \    {\n        char c = word[i];\n        if(c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' || c == 'y')\n        {\n            return word[i];\n\
    \        }\n    }\n    return \"\";\n}\n</code>\n<|/ a |>\n<| c |>\nHow is this\
    \ different from my solution?\n<|/ c |>\n<| c |>\nThe OP has mentioned the problem\
    \ is to find the first occurrence of the closest vowel from the right side. Your\
    \ solution is finding the closest vowel to the left side.\n<|/ c |>\n<| c |>\n\
    I see. I guess I misinterpreted the question. Fixed.\n<|/ c |>\n<| c |>\nYour\
    \ solution works but the question asks *You are given a word. Your task is to\
    \ find the closest vowel that stands between two consonants from the right side\
    \ of the word (case sensitive).*\n<|/ c |>\n<| c |>\nYes, I misinterpreted the\
    \ question also. Fixed it now. Thanks for pointing out.\n<|/ c |>\n<| a tags=string,c++\
    \ dscore=0 |>\nThe first solution presented by others work well, but a more straightforward\
    \ solution involves finding the first vowel (if any) after the last vowel in the\
    \ word.\nA straightforward solution might look something like this:\n<code>\n\
    string get_closest_vowel(string word) \n{\n    int firstVowel = -1;\n    int lastVowel\
    \ = -1;\n    for (int i = 0; i < word.length(); i++) {\n        char c = word[i];\n\
    \        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y')\
    \ {\n            if (firstVowel < 0) {\n                firstVowel = i;\n    \
    \        } else if (lastVowel < 0) {\n                lastVowel = i;\n       \
    \     }\n        }\n    }\n    if (firstVowel == -1) {\n        return word;\n\
    \    }\n    string result;\n    if (lastVowel < firstVowel) {\n        result\
    \ += word.substr(0, lastVowel);\n    } else {\n        result += word.substr(firstVowel,\
    \ lastVowel - firstVowel);\n    }\n    result += get_closest_vowel(word.substr(firstVowel\
    \ + 1));\n    return result;\n}\n</code>\nThis solution will correctly detect\
    \ \"fooled\" as \"fool\" as well as \"abracadabra\". That is because of the way\
    \ the function is written, where it simply checks whether any ", "{\n    string\
    \ temp = \"\";\n    vector<char> vowels;\n    vowels.push_back('a');\n    vowels.push_back('e');\n\
    \    vowels.push_back('i');\n    vowels.push_back('o');\n    vowels.push_back('u');\n\
    \    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        for(int j = 0;\
    \ j < vowels.size(); j++)\n        {\n            if(word[i] == vowels[j])\n \
    \           {\n                temp = word[i];\n                while(i < word.length()\
    \ - 1)\n                {\n                    if(word[i + 1] == vowels[j])\n\
    \                    {\n                        break;\n                    }\n\
    \                    else\n                    {\n                        i++;\n\
    \                    }\n                }\n                break;\n          \
    \  }\n        }\n    }\n    return temp;\n}\n/*\nYou are given a word. Your task\
    \ is to find the closest consonant that stands between \n    two vowels from the\
    \ right side of the word (case sensitive). ", "{\n    auto l = word.size();\n\
    \    auto ls = word.size();\n    for (auto i = 0; i < l - 1; i = i + 1) {\n  \
    \      auto lv = std.find(word[i].begin(), word[i].end(), string(\"AEIOUaeiou\"\
    )) - word[i].begin();\n        if (lv != string::npos) {\n            if (lv >\
    \ 0) {\n                return word[i];\n            }\n            else {\n \
    \               ls = i;\n            }\n        }\n    }\n    return \"\";\n}\n\
    </code>\n<|/ a tags=string,c++ dscore=0 |>\n<| c |>\nI do not think this approach\
    \ is as effective as other approaches when you have a large string and want to\
    \ find multiple occurences. I guess this approach is better if you're only looking\
    \ for a single occurence in a string.\n<|/ c |>\n<| c |>\nIt is a good point.\
    \ I think the algorithm could be improved to not use strlen but to just use a\
    \ constant and pass it along with the word length\n<|/ c |>\n<| c |>\nIf you would\
    \ have added your approach to the post, we could have taken the time to compare\
    \ it against our solutions and decide which one is better. I am not going to just\
    \ copy&paste your code and try to solve the questions. So why do you think my\
    \ approach is better than yours? Do you have any ideas for improving my code?\
    \ Maybe you can provide a link to some reading on your suggestion? Thank you!\n\
    <|/ c |>\n<| c |>\nThanks. I appreciate it. It makes sense. I'll have to look\
    \ into this and play with it some more. But it seems promising and I'm sure it'll\
    \ help me. I will report back if I find any issues. Thanks!\n<|/ c |>\n<| c |>\n\
    Ok, I implemented your solution in my code. And it seems promising. I ran it against\
    \ some of my other code and it seems promising too. I ran it against some sample\
    \ cases and it seems like it's finding the closest vowel as well. It's really\
    \ good! I thank you for all the help. I appreciate it.\n<|/ c |>\n<| a tags=string,c++\
    \ |>\nHere is a recursive approach:\n<code>\nstring getClosestVowel(string str,\
    \ string target) {\n    if (str.length() == 0) {\n        return target;\n   \
    \ }\n    if (str.substr(0, target.length()).find(target) == 0) {\n        return\
    \ getClosestVowel(str.substr(target.length()), target);\n    }\n    return getClosestVowel(str.substr(1,\
    \ str.size() - 2), target);\n}\n</code>\nThe ", "{\n    int vowel_index = find_vowel_index(\"\
    a\", word);\n    \n    if(vowel_index == -1) \n    {\n        return \"\";\n \
    \   }\n    \n    int last_vowel_index = find_vowel_index(\"e\", word);\n    if(last_vowel_index\
    \ < 0) \n    {\n        last_vowel_index = (word.size() - 1);\n    }\n    \n \
    \   int index = vowel_index + 1;\n    \n    while (index != last_vowel_index &&\
    \ index != word.size()) \n    {\n        if(word.at( index ) == 'a' || word.at(\
    \ index ) == 'e' || word.at( index ) == 'i' || word.at( index ) == 'o' || word.at(\
    \ index ) == 'u') \n        {\n            index = index + 1;\n        }\n   \
    \     else\n        {\n            return word.at(index);\n        }\n    }\n\
    \    return \"\";\n}", "{\n    int size = word.length();\n    int minVowelIndex\
    \ = 0;\n    int maxVowelIndex = size;\n    \n    for(int i=size-1; i>=0; i--)\n\
    \    {\n        if(word[i] == std.character::tolower(word[i])) \n        {\n \
    \           if(i != minVowelIndex)\n            {\n                minVowelIndex\
    \ = i;\n            }\n            \n            if(i != maxVowelIndex)\n    \
    \        {\n                maxVowelIndex = i;\n            }\n        }\n   \
    \ }\n    \n    if(minVowelIndex <= maxVowelIndex)\n    {\n        for(int i =\
    \ minVowelIndex+1; i<=maxVowelIndex; i++)\n        {\n            if(word[i] ==\
    \ std.character::tolower(word[i])) \n            {\n                return std.character::toupper(word[i]);\n\
    \            }\n        }\n    }\n    return \"\";\n}", "{\n    int l=word.length(),\
    \ m=l-2, i=0, j=l-2;\n    while(j>=0 && word[j]!='e' && word[j]!='u')\n    {\n\
    \        if(word[j]=='e') i++;\n        if(word[j]=='u') i--;\n        if(word[j]=='a')\
    \ m--;\n        j--;\n    }\n    string temp=\"\";\n    if(i<=0)\n    {\n    \
    \    i=0;\n        if(j<=0)\n            i=0;\n        if(m<=0)\n            i=0;\n\
    \        while(j>=0 && word[j]!='e' && word[j]!='u')\n        {\n            if(word[j]=='e')\
    \ i++;\n            if(word[j]=='u') i--;\n            j--;\n        }\n     \
    \   temp=word.substr(i-3, 3);\n    }\n    else\n    {\n        j=l-1;\n      \
    \  while(j>=0 && word[j]!='e' && word[j]!='u')\n        {\n            if(word[j]=='e')\
    \ i++;\n            if(word[j]=='u') i--;\n            j--;\n        }\n     \
    \   temp=word.substr(i-1, 3);\n    }\n    return temp;\n}\n</code>\n<|/ a tags=string,c++\
    \ |>\n<| a tags=string,c++ |>\n<code>\nstring getClosestVowel(string word) {\n\
    \    int i=0;\n    string result=\"\";\n    while(i < word.length() && word[i]\
    \ != 'e' && word[i] != 'u') {\n        if(word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n            break;\n  \
    \      i++;\n    }\n    while(i < word.length() && word[i] != 'a' && word[i] !=\
    \ 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u') {\n        if(word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\
    \ {\n            break;\n        }\n        i++;\n    }\n    while(i < word.length()\
    \ && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i]\
    \ != 'u' && word[i] != 'y') {\n        if(word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'y') {\n  \
    \          break;\n        }\n        i++;\n    }\n    while(i < word.length()\
    \ && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i]\
    \ != 'u' && word[i] != 'y' && word[i] != 'u' && word", "{\n    if(word.length()\
    \ == 0) {\n        return \"\";\n    }\n    map<string, int> mapVowel;\n    for(int\
    \ i = 0; i < (int)word.length() - 1; i++) {\n        if(isupper(word[i]) && word[i\
    \ + 1] == toupper(word[i + 2])) {\n            mapVowel[word[i]]++;\n        }\n\
    \    }\n    map<string, int> mapConsonant;\n    for(int i = 0; i < (int)word.length()\
    \ - 1; i++) {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' ||\
    \ word[i] == 'o' || word[i] == 'u' || word[i] == 'y') {\n            mapConsonant[word[i]]++;\n\
    \        }\n    }\n    map<string, int> mapResult;\n    mapVowel.insert(pair<string,\
    \ int>(\"a\", 2));\n    mapVowel.insert(pair<string, int>(\"e\", 2));\n    mapVowel.insert(pair<string,\
    \ int>(\"i\", 2));\n    mapVowel.insert(pair<string, int>(\"o\", 2));\n    mapVowel.insert(pair<string,\
    \ int>(\"u\", 2));\n    mapConsonant.insert(pair<string, int>(\"a\", 1));\n  \
    \  mapConsonant.insert(pair<string, int>(\"e\", 1));\n    mapConsonant.insert(pair<string,\
    \ int>(\"i\", 1));\n    mapConsonant.insert(pair<string, int>(\"o\", 1));\n  \
    \  mapConsonant.insert(pair<string, int>(\"u\", 1));\n    mapResult.insert(pair<string,\
    \ int>(\"a\", 0));\n    mapResult.insert(pair<string, int>(\"e\", 0));\n    mapResult.insert(pair<string,\
    \ int>(\"i\", 0));\n    mapResult.insert(pair<string, int>(\"o\", 0));\n    mapResult.insert(pair<string,\
    \ int>(\"u\", 0));\n    string res = \"\";\n    map<string, int>::iterator iter;\n\
    \    iter = mapVowel.begin();\n    if(iter != mapVowel.end()) {\n        res =\
    \ iter->first;\n        iter = mapConsonant.find(res);\n        if(iter != mapConsonant.end())\
    \ {\n            int tmp1 = iter->second;\n            iter = mapResult.find(res);\n\
    \            if(iter != mapResult.end()) {\n                int tmp2 = iter->second;\n\
    \                tmp1 = (tmp2 * 2) + tmp1;\n                res = tmp1 < tmp2\
    \ ? tmp2 : tmp1;\n            }\n            else {\n                res = tmp1;\n\
    \            }\n        }\n    }\n    return res;\n}\n</code>\n<|/ a tags=c++,algorithm,string\
    \ d", "{\n    int i = word.length() - 1;\n    int consonantsCount = 0;\n    while(i\
    \ >= 0)\n    {\n        if(word[i] == \"a\" || word[i] == \"e\" || word[i] ==\
    \ \"i\" || word[i] == \"o\" || word[i] == \"u\")\n        {\n            return\
    \ word[i];\n        }\n        consonantsCount++;\n        i--;\n    }\n    int\
    \ j = 0;\n    while(j < consonantsCount)\n    {\n        int vowelsCount = 0;\n\
    \        int i = 0;\n        int countIndex = 0;\n        while(i < j)\n     \
    \   {\n            char a = word[i++];\n            vowelsCount++;\n         \
    \   if(vowelsCount == 2 && a == \"u\")\n            {\n                countIndex\
    \ = i;\n            }\n        }\n        j = countIndex - 1;\n    }\n    return\
    \ word[0];\n}", "{\n    string vowels = \"AEIOUaeiou\";\n    int len = word.length();\n\
    \    int i = len - 1;\n    int j = 0;\n    int vowelIndex = -1;\n    bool vowelFound\
    \ = false;", "{\n    if (is_empty(word))\n        return \"\";", "{\n  int left_consonant\
    \ = word.length() - 1;\n  int right_consonant = 0;\n  int vowel_count = 0;\n \
    \ int vowel_position = 0;\n  string closest_vowel = \"\";\n  \n  while(vowel_position\
    \ != word.length() - 1) {\n    \n    int left_consonant_value = std.typecons.char.cast(word[left_consonant])\
    \ - 'a';\n    \n    if(left_consonant_value == 13) {\n      break;\n    }\n  \
    \  \n    left_consonant--;\n    \n    int right_consonant_value = std.typecons.char.cast(word[right_consonant])\
    \ - 'a';\n    \n    if(right_consonant_value == 13) {\n      break;\n    }\n \
    \   \n    right_consonant++;\n    \n    if(left_consonant_value == right_consonant_value)\
    \ {\n      vowel_count++;\n    }\n    \n    if(vowel_count == 3) {\n      if(std.math.abs(left_consonant_value)\
    \ == 1) {\n        vowel_position++;\n        closest_vowel += word[vowel_position];\n\
    \      }\n      else if(std.math.abs(right_consonant_value) == 1) {\n        vowel_position++;\n\
    \        closest_vowel += word[vowel_position];\n      }\n    }\n  }\n  return\
    \ closest_vowel;\n}\n</code>\nThe time complexity for this solution is O(N). Here,\
    \ we have O(1) space complexity.\n<|/ a tags=string,algorithm,language-agnostic,dynamic-programming\
    \ dscore=1 |>\n<| c |>\nIf there is only 3 vowels, and 2 of them are together,\
    \ and we get the left most consonant from right to left, why would we count them?\
    \ Isn't that redundant?\n<|/ c |>\n<| c |>\nIf there are only 3 vowels, we count\
    \ the three vowels, because we only need to check three of them in the word to\
    \ find the vowel position.\n<|/ c |>\n<| c |>\nI see. So the only vowel that can\
    \ occur before the first consonant is \"z\"\n<|/ c |>\n<| a dscore=1 |>\nI ran\
    \ into a similar problem. Here's my solution in c++:\n<code>\nstd::string vowelsStr(std::string\
    \ word)\n{\n    int vowelCount = 0;\n    int firstVowel = 0;\n    int maxVowel\
    \ = word.size() - 1;\n    while(vowelCount != 3)\n    {\n        if(word[firstVowel]\
    \ >= 'a' && word[firstVowel] <= 'z')\n        {\n            ", "{\n    auto begin\
    \ = find(word.begin(), word.end(), vowel);\n    if(begin != word.end())\n    {\n\
    \        auto end = find(word.begin(), word.end(), consonants.end());\n      \
    \  auto middle = begin + distance(begin, end) / 2;\n        if(middle == word.end())\n\
    \            middle++;\n        string vowels = word.substr(middle, distance(begin,\
    \ end) - middle);\n        size_t size = vowels.size();\n        if(size >= 2)\n\
    \        {\n            auto first = vowels[0];\n            auto last = vowels.back();\n\
    \            for(size_t i = 0; i < size; i++)\n            {\n               \
    \ if(vowels[i] != first)\n                    if(vowels[i] != last)\n        \
    \                return first;\n            }\n        }\n    }\n    return \"\
    \";\n}\n</code>\n<|/ a dscore=0 tags=c++,string,arrays |>\n<| a dscore=0 |>\n\
    Here's a solution without using any STL functions:\n<code>\n#include <iostream>\n\
    #include <string>", "{\n    \n    for(int i=word.length-1; i>=0; i--) \n    {\n\
    \        for(int j=word.length-1; j>=0; j--) \n        {\n            if(word[i]\
    \ != word[j]) \n            {\n                if(toupper(word[i]) == 'A' && toupper(word[j])\
    \ != 'A') \n                {\n                    return toupper(word[i]);\n\
    \                }\n                else if(toupper(word[i]) != 'A' && toupper(word[j])\
    \ == 'A') \n                {\n                    return toupper(word[j]);\n\
    \                }\n            }\n        }\n    }\n    return \"\";\n}\n</code>\n\
    <|/ a tags=string,c++ |>\n<| a |>\n<code>\n#include <bits/stdc++.h>\nusing namespace\
    \ std;", "{\n\tint consonantCount = 0;\n\tint vowelCount = 0;\n\tstring vowel\
    \ = \"u\";\n\tfor (int i=word.length()-1; i>=0; --i)\n\t{\n\t\tif (word[i] ==\
    \ 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n\
    \t\t{\n\t\t\tvowelCount += 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconsonantCount +=\
    \ 1;\n\t\t}\n\t}\n\tif (vowelCount > consonantCount)\n\t{\n\t\treturn vowel;\n\
    \t}\n\telse\n\t{\n\t\treturn \"\";\n\t}\n}", "{\n    auto leftMostConsonant =\
    \ word.find_first_of('Z') < word.find_first_of('a') ? word.find_first_of('Z')\
    \ : word.find_first_of('a');\n    auto rightMostConsonant = word.find_last_of('Z')\
    \ < word.find_last_of('a') ? word.find_last_of('Z') : word.find_last_of('a');",
  "{\n    \n    int start = word.size()-2;\n    int end = word.size();\n    \n   \
    \ while(start >= 0 && end > start )\n    {\n       int left_cond = word[start];\n\
    \       int right_cond = word[end];", "{\n    if(word.length()<3) \n        return\
    \ \"\";\n        \n    stack<pair<string, int>> vowels;\n    \n    for(int i=0;i<word.length()-2;i++)\
    \ {\n        string c = word.substr(i+1, 1);\n        if(c.to_upper() == 'A' ||\
    \ c.to_upper() == 'E' || c.to_upper() == 'I' || c.to_upper() == 'O' || c.to_upper()\
    \ == 'U' || c.to_upper() == 'Y') {\n            vowels.push({c, i});\n       \
    \ }\n    }\n    \n    while(!vowels.empty()) {\n        pair<string, int> curr\
    \ = vowels.top();\n        vowels.pop();\n        string vowel = curr.first;\n\
    \        int index = curr.second;\n        if(word.length() > index + 2 && word[index]\
    \ == vowel && word[index+1] == vowel && word[index+2] == vowel) \n           \
    \ return vowel;\n    }\n    return \"\";\n}", "{\n    for(int i=word.length()-1;i>=0;i--)\n\
    \    {\n        if(word.at(i)==\"a\"||word.at(i)==\"e\"||word.at(i)==\"i\"||word.at(i)==\"\
    o\"||word.at(i)==\"u\")\n        {\n            int first=i;\n            for(int\
    \ j=first;j<word.length();j++)\n            {\n                if(word.at(j)==\"\
    a\"||word.at(j)==\"e\"||word.at(j)==\"i\"||word.at(j)==\"o\"||word.at(j)==\"u\"\
    )\n                {\n                    int second=j;\n                    string\
    \ res=\"\";\n                    string vowel=\"aueiou\";\n                  \
    \  for(int k=0;k<vowel.size();k++)\n                    {\n                  \
    \      if(first.at(k)==vowel.at(k))\n                        {\n             \
    \               res=res.concat(word.at(second));\n                        }\n\
    \                    }\n                    if(res.length()>0)\n             \
    \       {\n                        return res;\n                    }\n      \
    \          }\n            }\n        }\n    }\n    return \"\";\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks a lot Mr. Maniac\n<|/ c |>\n<| c |>\nHi, I\
    \ have added a solution that I hope is faster than the one you have posted here.\
    \ Please take a look.\n<|/ c |>\n<| c |>\nyeah thats a lot better\n<|/ c |>\n\
    <| a dscore=1 |>\nHere is a recursive method with a dynamic programming.\n<code>\n\
    public static String getVowelsOnTheRight(String word) {\n    if (word.length()\
    \ == 0) {\n        return \"\";\n    }\n    List<String> vowels = new ArrayList<>();\n\
    \    vowels.add(\"a\");\n    vowels.add(\"e\");\n    vowels.add(\"i\");\n    vowels.add(\"\
    o\");\n    vowels.add(\"u\");\n    vowels.add(\"y\");\n    vowels.add(\"\");\n\
    \    boolean found = false;\n    if (vowels.contains(word.charAt(0))) {\n    \
    \    found = true;\n    }\n    if (vowels.contains(word.charAt(word.length() -\
    \ 1))) {\n        found = true;\n    }\n    if (!found) {\n        vowels.add(\"\
    y\");\n        vowels.add(\"\");\n    }", "{\n    auto first_vowel = word[word.find_first_not_of(\"\
    AEIOUaeiou\")];\n    auto last_vowel = word[word.find_last_not_of(\"AEIOUaeiou\"\
    )];\n    \n    auto start = word.rfind(first_vowel);\n    auto end = word.rfind(last_vowel);\n\
    \    \n    return word.rbegin() + ((start >= 0) ? start : word.rfind(last_vowel))\n\
    }", "{\n\tint i;\n\tint j;\n\tstring vowels = \"AEIOUaeiou\";\n\tstd.string vowel_consonants\
    \ = \"BCDFGHJKLMNPQRSTVWXYZ\";\n\tstring consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;", "{\n\tint pos = 0;\n\tint rightSidePos = length(word) - 1;\n\tbool found =\
    \ false;\n\tfor(int i = 0; i < length(word); i++)\n\t{\n\t\tif(word[i] == toLowercase(rightSidePos))\n\
    \t\t{\n\t\t\trightSidePos--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos = i;\n\t\t\tfound\
    \ = true;\n\t\t}\n\t}\n\tif(!found)\n\t{\n\t\treturn \"\";\n\t}\n\tbool start\
    \ = false;\n\tbool end = false;\n\tfor(int i = pos + 1; i < length(word); i++)\n\
    \t{\n\t\tif(word[i] == toLowercase(rightSidePos))\n\t\t{\n\t\t\trightSidePos--;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tif(!start)\n\t\t\t{\n\t\t\t\tstart = i;\n\t\t\t\
    }\n\t\t\telse\n\t\t\t{\n\t\t\t\tend = i;\n\t\t\t}\n\t\t}\n\t}\n\tif(!start)\n\t\
    {\n\t\treturn \"\";\n\t}\n\tint leftSidePos = left(word, start);\n\tint rightSidePos\
    \ = right(word, end);\n\tstring vowel = \"\";\n\tbool leftFound = false;\n\tbool\
    \ rightFound = false;\n\tfor(int i = leftSidePos; i >= 0; i--)\n\t{\n\t\tif(word[i]\
    \ == toLowercase(rightSidePos))\n\t\t{\n\t\t\trightSidePos--;\n\t\t}\n\t\telse\n\
    \t\t{\n\t\t\tif(!leftFound)\n\t\t\t{\n\t\t\t\tleftFound = true;\n\t\t\t\tvowel\
    \ = word[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trightFound = true;\n\t\t\t\
    }\n\t\t}\n\t}\n\tif(!rightFound)\n\t{\n\t\tfor(int i = rightSidePos; i < length(word);\
    \ i++)\n\t\t{\n\t\t\tif(word[i] == toLowercase(leftSidePos))\n\t\t\t{\n\t\t\t\t\
    leftSidePos++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvowel += word[i];\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn vowel;\n}\n\"\"\"", "{\n    int i = word.length() - 1;\n\
    \    string vowels = \"aeiouy\";\n    int consonants = 0;\n    string result =\
    \ \"~\";\n    while((i >= 0) && (vowels.find(word.at(i)) != -1))\n    {\n    \
    \    if(word.at(i) == word.at(i+1))\n        {\n            consonants++;\n  \
    \          i -= 1;\n        }\n        else\n        {\n            consonants\
    \ = 0;\n            i -= 1;\n        }\n    }\n    while(i >= 0)\n    {\n    \
    \    if(consonants == 1)\n        {\n            if(vowels.find(word.at(i)) ==\
    \ -1)\n            {\n                result = word.at(i);\n                break;\n\
    \            }\n        }\n        consonants = 0;\n        i -= 1;\n    }\n \
    \   return result;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| c |>\n\
    Please don't post code only answers. Try to add some explanation what the code\
    \ does and why it solves the problem.\n<|/ c |>\n<| c |>\n`string vowels = \"\
    aeiouy\"` should be `const string vowels = \"aeiouy\"`. `vowels.find(word.at(i))`\
    \ should be `vowels.find(word.at(i))`.\n<|/ c |>\n<| a dscore=0 tags=string,c++,algorithm\
    \ |>\nOne more variation of David's answer. Here we find all occurences of vowels\
    \ in string and store them into array, then we iterate through array and find\
    \ index of closest occurence of character in string. \n<code>\n#include <iostream>\n\
    #include <cstring>\nusing namespace std;", "{\n\t\n\treturn \"\";\n\t\n}\n'''\n\
    problem_5 = '''\n/*\nYou are given two strings A and B. You need to find minimum\
    \ number of insertions \nand deletions required to make string B equals to string\
    \ A. Both strings are \nlowercase letters only.", "{\n    map<string,string> vowel_map;\n\
    \    for(char ch : word) vowel_map[ch] = \"\";\n    for(char ch : word) \n   \
    \ {\n        if(ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u')\n\
    \            vowel_map[ch] += \"a\";\n        else if(ch == 'b')\n           \
    \ vowel_map[ch] += \"b\";\n        else if(ch == 'c' || ch == 'g' || ch == 'j'\
    \ || ch == 'm' || ch == 'p' || ch == 's')\n            vowel_map[ch] += \"c\"\
    ;\n        else if(ch == 'd' || ch == 'f' || ch == 'k' || ch == 't' || ch == 'v'\
    \ || ch == 'w')\n            vowel_map[ch] += \"d\";\n        else if(ch == 'z')\n\
    \            vowel_map[ch] += \"z\";\n    }\n    map<string,string>::iterator\
    \ it;\n    for(it = vowel_map.begin(); it != vowel_map.end(); ++it) \n    {\n\
    \        string vowel = it.first;\n        string prefix = it.second;\n      \
    \  string suffix = \"\";\n        if(prefix.size() >= 2) \n        {\n       \
    \     prefix = prefix.substr(0,1);\n            suffix = prefix.substr(0,1) +\
    \ \"u\" + prefix.substr(1);\n        }\n        else if(prefix.size() == 1)\n\
    \        {\n            prefix = prefix.substr(0,1);\n            suffix = \"\
    u\" + prefix.substr(1);\n        }\n        if(word.find(vowel) != string::npos)\n\
    \        {\n            if(word.find(vowel,0,string::npos) == string::npos)\n\
    \                return \"\";\n            if(word.find(vowel,string::npos,word.length())\
    \ != string::npos)\n                return \"\";\n            string ans = word.substr(0,word.find(vowel,0,string::npos));\n\
    \            if(ans.size() == 0) \n                return \"\";\n            ans\
    \ += suffix;\n            return ans;\n        }\n    }\n    return \"\";\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis is not the exact solution to the problem.\
    \ Because it will return vowel if it's between two consonants only.\n<|/ c |>\n\
    <| c |>\nYes, you are correct. I edited my answer to fix that\n<|/ c |>\n<| c\
    \ |>\nI still see that `a` being return as vowel.\n<|/ c |>\n<| c |>\nYes, I see\
    \ that now. My bad. Thanks for pointing that out.\n<|/ c |>\n<| c |>\nSorry to\
    \ say, but this does not work in all cases. ", "{\n    int len = word.length();\n\
    \    char ch;\n    int mid;\n    string vowel;\n    for(int i=len-1;i>=0;i--)\n\
    \    {\n        ch = word[i];\n        mid = i;\n        while( (isupper(ch)||islower(ch))\
    \ && mid > 0 )\n        {\n            ch = tolower(ch);\n            if( (isupper(ch)&&islower(word[mid-1]))||(islower(ch)&&isupper(word[mid-1]))\
    \ )\n            {\n                vowel = ch;\n                mid = mid-1;\n\
    \                i = mid;\n            }\n            else\n            {\n  \
    \              ch = toupper(ch);\n                if( (isupper(ch)&&islower(word[mid-1]))||(islower(ch)&&isupper(word[mid-1]))\
    \ )\n                {\n                    vowel = ch;\n                    mid\
    \ = mid-1;\n                    i = mid;\n                }\n            }\n \
    \       }\n    }\n    return vowel;\n}", "{\n    int len=word.lenght;\n    int\
    \ i,j;\n    string vowel=\"\";\n    for(i=len-1;i>=0;--i)\n    {\n        if(isVowel(word[i]))\n\
    \        {\n            for(j=i-1;j>=0;--j)\n            {\n                if(isVowel(word[j]))\n\
    \                {\n                    if(word[j]==toupper(word[i]))\n      \
    \              {\n                        word[j]='\\0';\n                   \
    \ }\n                }\n            }\n        }\n        if(word[i]!=toupper(word[i]))\n\
    \        {\n            word[i]='\\0';\n            break;\n        }\n    }\n\
    \    return vowel;\n}", "{\n\tauto first = cbegin(word);\n    auto last  = cend(word);",
  "{\n   if(word == null || word.isEmpty()){\n       return \"\";\n   }", "{\n   \
    \ int start = 0;\n    int end = word.length() - 1;\n    int vowelCount = 0;\n\
    \    int curr = word[end];\n    while (vowelCount < 2 && start < end && isVowel(curr))\n\
    \    {\n        if (word[start] == curr)\n        {\n            start++;\n  \
    \          vowelCount++;\n        }\n        else if (word[end] == curr)\n   \
    \     {\n            end--;\n            vowelCount++;\n        }\n        else\n\
    \        {\n            if (word[start] < curr)\n                end--;\n    \
    \        else if (word[end] > curr)\n                start++;\n            else\n\
    \            {\n                if (word[end] == curr && start < end)\n      \
    \          {\n                    vowelCount++;\n                }\n         \
    \       else if (word[start] == curr && end > start)\n                {\n    \
    \                vowelCount++;\n                }\n                else\n    \
    \                return \"\";\n            }\n        }\n        curr = word[end];\n\
    \    }\n    return curr < 'a' ? curr : \"\";\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=string,c++ |>\nIf your string has length more than 4 characters, there\
    \ will be some empty strings left in your string. For such strings, you can either\
    \ remove them completely or return an empty string instead.\nYou can remove empty\
    \ strings from your string using std::remove_if function.\nHere is an example:\n\
    <code>\n#include <algorithm>", "{\n    int left = word.find_last_of('a') - 1;\n\
    \    int right = word.find_last_of('a') + 1;\n    \n    int left_cons = word.find_last_of('c')\
    \ - 1;\n    int right_cons = word.find_last_of('c') + 1;\n    \n    int left_num\
    \ = word.find_last_of('e') - 1;\n    int right_num = word.find_last_of('e') +\
    \ 1;\n    \n    int left_hr = word.find_last_of('i') - 1;\n    int right_hr =\
    \ word.find_last_of('i') + 1;\n    \n    if(left == -1 || right == -1)\n    {\n\
    \        if(left == -1 && right == -1)\n            return \"\";\n        else\n\
    \            return word.substr(0,word.length()-1);\n    }\n    int min = 0;\n\
    \    if(left_cons == -1)\n        min = left_num;\n    else if(left_num == -1)\n\
    \        min = left_hr;\n    else if(left_hr == -1)\n        min = left_cons;\n\
    \    else\n        min = left_cons;\n    \n    if(right_cons == -1)\n        max\
    \ = right_num;\n    else if(right_num == -1)\n        max = right_hr;\n    else\
    \ if(right_hr == -1)\n        max = right_cons;\n    else\n        max = right_cons;\n\
    \    \n    if(min > max)\n    {\n        if(min == right_cons && max == right_num)\n\
    \        {\n            if(word[min] == 'u')\n                return \"U\";\n\
    \            else if(word[min] == 'i')\n                return \"I\";\n      \
    \  }\n        else\n            return word.substr(0,min);\n    }\n    \n    if(min\
    \ < max)\n    {\n        if(min == left_cons && max == left_num)\n        {\n\
    \            if(word[max] == 'u')\n                return \"U\";\n           \
    \ else if(word[max] == 'i')\n                return \"I\";\n        }\n      \
    \  else\n            return word.substr(max,word.length());\n    }\n    \n   \
    \ return \"\";\n}", "{\n    map<int,char> vowels = {{1,'a'}, {2,'e'}, {3,'i'},\
    \ {4,'o'}, {5,'u'}};\n    map<int,char> consonants = {{1,'b'}, {2,'c'}, {3,'d'},\
    \ {4,'f'}, {5,'g'}, {6,'h'}, {7,'j'}, {8,'k'}, {9,'l'}, {10,'m'}, {11,'n'}, {12,'p'},\
    \ {13,'q'}, {14,'r'}, {15,'s'}, {16,'t'}, {17,'v'}, {18,'w'}, {19,'x'}, {20,'y'},\
    \ {21,'z'}};\n    map<int,char> noVowels = {{1,'A'}, {2,'B'}, {3,'C'}, {4,'D'},\
    \ {5,'E'}, {6,'F'}, {7,'G'}, {8,'H'}, {9,'I'}, {10,'J'}, {11,'K'}, {12,'L'}, {13,'M'},\
    \ {14,'N'}, {15,'O'}, {16,'P'}, {17,'Q'}, {18,'R'}, {19,'S'}, {20,'T'}, {21,'U'},\
    \ {22,'V'}, {23,'W'}, {24,'X'}, {25,'Y'}, {26,'Z'}};\n    \n    for(int i = 0;\
    \ i < word.length(); i++)\n    {\n        if(isalpha(word[i]))\n        {\n  \
    \          int index = findindex(consonants, word[i]);\n            if(index <=\
    \ 6)\n            {\n                if(index != 0)\n                    string\
    \ temp = word.substr(0,index);\n                    if(isalpha(temp))\n      \
    \                  return temp;\n            }\n            else\n           \
    \ {\n                string temp = word.substr(0,6);\n                if(isalpha(temp))\n\
    \                    return temp;\n            }\n        }\n    }\n    \n   \
    \ return \"\";\n}\n</code>\n<|/ a |>\n<| c |>\n`for(int i = 0; i < word.length();\
    \ i++)` - `word.length()` should be `word.length()-1` otherwise you'll have a\
    \ `segmentation fault`. Your code will work but it's also possible to do it without\
    \ `for` loop.\n<|/ c |>\n<| a tags=string,algorithm,c++ dscore=0 |>\n<code>\n\
    import java.util.*;\nclass vowel{\n    public static void main(String args[]){\n\
    \        Scanner sc=new Scanner(System.in);\n        System.out.println(\"enter\
    \ a word\");\n        String str=sc.nextLine();\n        char[] ch=str.toCharArray();\n\
    \        String res", "{\n    map<char,int> vowels;\n    foreach(char c in word)\n\
    \        vowels[toupper(c)]++;\n    int min=0, max=0;\n    foreach(char c in word)\n\
    \    {\n        foreach(char c2 in word)\n        {\n            if(toupper(c)!=toupper(c2))\n\
    \                continue;\n            if(isalpha(c))\n            {\n      \
    \          int count = vowels[toupper(c2)];\n                if(count<min)\n \
    \                   min=count;\n                if(count>max)\n              \
    \      max=count;\n            }\n        }\n    }\n    for(int i=min;i<max;i++)\n\
    \    {\n        int count = 0;\n        foreach(char c in word)\n        {\n \
    \           if(toupper(c)==toupper(word[i]))\n                count++;\n     \
    \   }\n        if(count==0)\n            return toupper(word[i]);\n    }\n   \
    \ return \"\";\n}\n</code>\n<|/ a |>\n<| a tags=c++ |>\n<code>\nstring getClosestVowel(string\
    \ word) {\n    int i, j, k, l;\n    for(i = word.size(); --i >= 0;)\n    {\n \
    \       for(j = word.size(); --j >= 0;)\n        {\n            for(k = word.size();\
    \ --k >= 0;)\n            {\n                for(l = word.size(); --l >= 0;)\n\
    \                {\n                    if(word[i] == word[j])\n             \
    \           break;\n                    if(word[i] == word[k])\n             \
    \           break;\n                    if(word[i] == word[l])\n             \
    \           break;\n                }\n            }\n        }\n    }\n    return\
    \ word[i];\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n// C++ Program to\
    \ find nearest vowel.\n// Author : Nitish Kumar", "{\n    int right_side = word.find_last_of(\"\
    aeiouAEIOU\", word.length()-1);\n    if (right_side == -1) \n        return \"\
    \";\n    int left_side = word.find_last_of(\"aeiouAEIOU\", right_side);\n    if\
    \ (left_side == -1) \n        return \"\";\n    int left_side_lower = word.length()\
    \ - 1 - left_side;\n    int right_side_lower = word.length() - 1 - right_side;\n\
    \    string found_vowel = word[left_side_lower];\n    if (found_vowel == \"a\"\
    \ || found_vowel == \"A\" || found_vowel == \"e\" || found_vowel == \"E\" || found_vowel\
    \ == \"i\" || found_vowel == \"I\" || found_vowel == \"o\" || found_vowel == \"\
    O\" || found_vowel == \"u\" || found_vowel == \"U\")\n        return found_vowel;\n\
    \    if (found_vowel == \"o\" || found_vowel == \"O\" || found_vowel == \"i\"\
    \ || found_vowel == \"I\")\n        return found_vowel;\n    if (found_vowel ==\
    \ \"u\" || found_vowel == \"U\")\n        return found_vowel;\n    if (left_side\
    \ < right_side)\n        return get_closest_vowel(word.substr(0, left_side_lower\
    \ + 1));\n    if (right_side < left_side)\n        return get_closest_vowel(word.substr(left_side_lower\
    \ + 1, right_side_lower + 1));\n    if (left_side == right_side)\n        return\
    \ get_closest_vowel(word.substr(0, left_side_lower + 1));\n    return get_closest_vowel(word.substr(left_side_lower\
    \ + 1, right_side_lower + 1));\n}", "{\n    string vowel = \"\";\n    for (int\
    \ i=word.length-1; i>0; i--) \n    {\n        bool isVowel = \n            word.at(i)\
    \ >= 'A' && word.at(i) <= 'Z' ||\n            word.at(i) >= 'a' && word.at(i)\
    \ <= 'z' ||\n            word.at(i) >= '0' && word.at(i) <= '9';\n        if (word[i]\
    \ == word.at(i) && isVowel) \n        {\n            vowel = word.at(i);\n   \
    \         break;\n        }\n    }\n    return vowel;\n}\n</code>\n<|/ a tags=c++,string\
    \ |>\n<| c |>\nI suggest you add some comments about what you did and why you\
    \ did it. Not everyone will know you wrote this code and will think you wrote\
    \ it so someone can improve it.\n<|/ c |>\n<| c |>\nI am going to post some comments\
    \ right now. Thank you.\n<|/ c |>\n<| c |>\nYou don't have to post comments. Just\
    \ add your answer. If it is correct, then mark it as such. That's how Stack Overflow\
    \ works.\n<|/ c |>\n<| c |>\nIt would have been better to point out to OP that\
    \ his own code does not compile\n<|/ c |>\n<| c |>\nI added some comments now.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nstring getClosestVowel(string word)\n{\n \
    \   string vowel = \"\";", "{\n    int i=word.length()-1;\n    string vowel=\"\
    \";\n    while(i>0)\n    {\n        int j=i-1;\n        int consonant=0;\n   \
    \     while(j>0)\n        {\n            if(word.charAt(j)==\"a\"||word.charAt(j)==\"\
    e\"||word.charAt(j)==\"i\"||word.charAt(j)==\"o\"||word.charAt(j)==\"u\")\n  \
    \          {\n                consonant++;\n            }\n            j--;\n\
    \        }\n        double distance;\n        double distance1=distance(word.c_str()[i],word.c_str()[j]);\n\
    \        distance1=distance1/consonant;\n        if(distance1>=0.9&&distance1<=1)\n\
    \        {\n            if(word.charAt(j)==\"a\"||word.charAt(j)==\"e\"||word.charAt(j)==\"\
    i\"||word.charAt(j)==\"o\"||word.charAt(j)==\"u\")\n            {\n          \
    \      vowel+=word.charAt(j);\n            }\n        }\n        i--;\n    }\n\
    \    if(vowel.empty())\n    {\n        vowel=\"\";\n    }\n    return vowel;\n\
    }", "{\n    vector<char> vs;\n    for(int i = word.length()-1; i>0; i--){\n  \
    \      if(word[i]=='a'||word[i]=='e'||word[i]=='i'||word[i]=='o'||word[i]=='u'){\n\
    \            vs.push_back(word[i]);\n        }\n    }", "{\n  int left = 0;\n\
    \  int right = word.length() - 1;\n  string result = \"\";\n  while(left < right)\n\
    \  {\n    string a = word.substr(left, 2);\n    string b = word.substr(right,\
    \ 2);\n    bool isA = is_vow(a);\n    bool isB = is_vow(b);\n    bool isBoth =\
    \ isA && isB;\n    if (isBoth)\n    {\n      if (compare(a, b) == -1)\n      {\n\
    \        left++;\n      }\n      else\n      {\n        right--;\n      }\n  \
    \  }\n    else\n    {\n      left++;\n      right--;\n    }\n  }\n  return result;\n\
    }", "{\n    map<string, int> vowelCount;\n    for(uint i=0; i<word.length(); i++)\n\
    \    {\n        char letter = word[i];\n        if(vowelCount.find(letter) ==\
    \ vowelCount.end())\n            vowelCount[letter] = 0;\n        vowelCount[letter]\
    \ += 1;\n    }\n    map<string, int>::iterator it = vowelCount.begin();\n    while(it!=vowelCount.end())\n\
    \    {\n        if(it->second>2)\n            return it->first;\n        it++;\n\
    \    }\n    return \"\";\n}", "{\n    string cons = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    string vowels = \"aeiou\";\n    int i,j,k;\n    i = word.size();\n    while(i--\
    \ > 0)\n    {\n        //for j=i+1;j<word.size(); j++ is unnecessary, it goes\
    \ out of bound\n        //j = word.size();\n        k = word[i];\n        if(!std.arrayContains(cons,\
    \ k))\n        {\n            word[i] = k;\n            continue;\n        }\n\
    \        j = i;\n        while(j-- > 0)\n        {\n            if(j==word.size())\
    \ break;\n            if(std.arrayContains(vowels, word[j]))\n            {\n\
    \                return word[j];\n            }\n        }\n    }\n    return\
    \ \"\";\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\ndef closest_vowel(word):\n\
    \    vowels = list(\"AEIOU\")\n    vowels_len = len(vowels)", "{\n    if (word.empty())\
    \ return \"\";\n    stack<char> chars;\n    chars.push('\\0');\n    for (auto\
    \ c : word) \n    {\n        if (isalpha(c)) chars.push(c);\n    }\n    char first\
    \ = chars.top();\n    chars.pop();\n    char last = get_last_char(word);\n   \
    \ \n    for (auto c : chars)\n    {\n        if (c == last)\n        {\n     \
    \       char c = get_next_char(c);\n            if (isalpha(c))\n            {\n\
    \                chars.push(c);\n                char v = toupper(c);\n      \
    \          if (v == 'A' || v == 'E' || v == 'I' || v == 'O' || v == 'U')\n   \
    \             {\n                    char before = get_previous_char(v);\n   \
    \                 if (chars.top() != before)\n                    {\n        \
    \                chars.push(before);\n                        char after = get_next_char(v);\n\
    \                        if (after != '\\0') chars.push(after);\n            \
    \        }\n                }\n            }\n        }\n    }\n    return chars.top();\n\
    }", "{\n    int i=word.size()-1;\n    int j=word.size()-1;\n    int m=word[0]==word[m];\n\
    \    int n=word[i]==word[n];\n    while (i>=0 && i<j){\n        if(m==word[j]==word[i]&&n==word[i-1]==word[i+1]){\n\
    \            return word[i];\n        }\n        else{\n            j--;\n   \
    \     }\n    }\n    return word[0]==word[m]==word[i]==word[n]? word[0] : \"\"\
    ;\n}\n/*\nYou are given a string. Your task is to split it into the substrings\
    \ \n    that each contain exactly two consonants followed by the first vowel \n\
    \    found in the original string.", "{\n    int i,j,k,l,m,n;\n    string res\
    \ = \"\";\n    for(i = 0; i < word.length(); i += 1){\n        if(word[i] == 'a'){\n\
    \            for(j = 0; j < word.length(); j += 1){\n                k = j + 1;\n\
    \                if(word[j] == 'u' || word[k] == 'u'){\n                    m\
    \ = j + 2;\n                    while(word[m] != 'e' && word[m] != 'i'){\n   \
    \                     m += 1;\n                    }\n                    n =\
    \ m + 1;\n                    while(n<word.length() && word[n] != 'e' && word[n]\
    \ != 'i'){\n                        n += 1;\n                    }\n         \
    \           if(word[m] == 'e' || word[m] == 'i'){\n                        if(word[n]\
    \ == 'e' || word[n] == 'i'){\n                            res = word[m];\n   \
    \                         break;\n                        }\n                \
    \    }\n                }\n            }\n        }\n    }\n    return res;\n\
    }\n</code>\n<|/ a tags=string,algorithm |>\n<| c |>\nWhy do you need j in the\
    \ second loop? Why not just m?\n<|/ c |>\n<| c |>\nThanks for your comment and\
    \ question. I updated my answer.\n<|/ c |>\n<| c |>\nHow is this supposed to work?\
    \ For example in the string \"abd\" it will output \"a\". Can you explain?\n<|/\
    \ c |>\n<| c |>\nThe second loop is used to check whether the first vowel exists\
    \ between two consecutive consonants, and the if statement is used for checking\
    \ if the first vowel exists between two consecutive consonants.\n<|/ c |>\n<|\
    \ c |>\nBut it won't work if there is just one vowel at the end of the string.\
    \ Try it for \"ab\" :)\n<|/ c |>\n<| a |>\nIf you're dealing with just letters,\
    \ you can use this simple code:\n<code>\ndef closestVowel(word):\n    vowel =\
    \ \"aeiou\"\n    letter = word.lower()\n    letterIndex = 0\n    for index, letter\
    \ in enumerate(word):\n        if letter in vowel:\n            letterIndex =\
    \ index\n            break\n    letterIndex += len(vowel) - len(letter)\n    letterIndex\
    \ += len(vowel) + letterIndex\n    return word[letterIndex:]\n</code>\n<|/ a dscore=3\
    \ tags=string,algorithm |>\n<| c |>\nThis is not correct. Consider `word = \"\
    apple\"`. The function returns `elppa` instead of `e`.\n<|/ c |>\n<| c |>\nI know,\
    \ I changed it back. Maybe the problem is the original code was trying to do more\
    \ than just ", "{\n    vector<char> vowels;\n    vowels.push_back('a', 'e', 'i',\
    \ 'o', 'u');\n    for(int i=0;i<word.length()-1;i++)\n    {\n        char letter\
    \ = word[i];\n        for(int j=i+1;j<word.length();j++)\n        {\n        \
    \    char letter2 = word[j];\n            if(vowels.contains(letter) && vowels.contains(letter2))\n\
    \            {\n                string vowel = to_string(letter);\n          \
    \      string vowel2 = to_string(letter2);\n                if(vowel2.size() <\
    \ vowel.size())\n                {\n                    return vowel;\n      \
    \          }\n                else if(vowel2.size() > vowel.size())\n        \
    \        {\n                    return vowel2;\n                }\n          \
    \  }\n        }\n    }\n    return \"\";\n}\n</code>\n<|/ a |>\n<| c |>\nHi Mohammad,\
    \ thank you for your help. I try the function and i got this error `/home/user/cpp/main.cpp:\
    \ In function \u2018int main()\u2019:\n/home/user/cpp/main.cpp:13:1: error: \u2018\
    __gnu_cxx::__normal_iterator<char*, std::basic_string<char> > __gnu_cxx::__normal_iterator<char*,\
    \ std::basic_string<char> >\u2019 has no member named \u2018size\u2019\n/home/user/cpp/main.cpp:13:1:\
    \ error: \u2018__gnu_cxx::__normal_iterator<char*, std::basic_string<char> > __gnu_cxx::__normal_iterator<char*,\
    \ std::basic_string<char> >\u2019 has no member named \u2018size\u2019\n/home/user/cpp/main.cpp:13:1:\
    \ error: \u2018__gnu_cxx::__normal_iterator<char*, std::basic_string<char> > __gnu_cxx::__normal_iterator<char*,\
    \ std::basic_string<char> >\u2019 has no member named \u2018size\u2019\n/home/user/cpp/main.cpp:13:1:\
    \ error: expected \u2018;\u2019 before \u2018]\u2019 token\n/home/user/cpp/main.cpp:13:1:\
    \ error: expected \u2018;\u2019 before \u2018]\u2019 token\n/home/user/cpp/main.cpp:13:1:\
    \ error: expected \u2018;\u2019 before \u2018]\u2019 token\n/home/user/cpp/main.cpp:13:1:\
    \ error: expected \u2018;\u2019 before \u2018]\u2019 token\n/home/user/cpp/main.cpp:13:1:\
    \ error: expected \u2018;\u2019 before \u2018]\u2019 token\n/home/user/cpp/main.cpp:13:1:\
    \ error: expected \u2018;\u2019 before \u2018]\u2019 token\n/home/user/cpp/main.cpp:13:1:\
    \ error: expected \u2018;\u2019 before \u2018]\u2019", "{\n    for(int i = 0;\
    \ i<word.length(); i++)\n    {\n        if(word[i] == 'a' || word[i] == 'e' ||\
    \ word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n        {\n           \
    \ int j = i - 1;\n            int k = i + 1;\n            while(word[j] == 'a'\
    \ || word[j] == 'e' || word[j] == 'i' || word[j] == 'o' || word[j] == 'u')\n \
    \           {\n                if(j == 0)\n                    return \"\";\n\
    \                j--;\n                k++;\n            }\n            while(word[k]\
    \ == 'a' || word[k] == 'e' || word[k] == 'i' || word[k] == 'o' || word[k] == 'u')\n\
    \            {\n                k++;\n            }\n            if(abs(word[i]\
    \ - word[j]) <= abs(word[i] - word[k]))\n            {\n                if(word[i]\
    \ <= word[j])\n                    return word[i];\n                else\n   \
    \                 return word[j];\n            }\n        }\n    }\n    return\
    \ \"\";\n}", "{\n    int minLen = abs(word.length() - 2);\n    int maxLen = abs(word.length()\
    \ - 1);\n    \n    bool isFirst = true;\n    for(int i=0;i<word.length()-1;i++)\n\
    \    {\n        if(isFirst)\n        {\n            if(std.string.toLower(word.at(i))==\"\
    a\" || std.string.toLower(word.at(i))==\"e\" || std.string.toLower(word.at(i))==\"\
    i\" || std.string.toLower(word.at(i))==\"o\" || std.string.toLower(word.at(i))==\"\
    u\" || std.string.toLower(word.at(i))==\"y\" || std.string.toLower(word.at(i))==\"\
    \xE4\" || std.string.toLower(word.at(i))==\"\xF6\" || std.string.toLower(word.at(i))==\"\
    \xFC\")\n            {\n                minLen = i;\n                isFirst =\
    \ false;\n            }\n        }\n        else\n        {\n            if(std.string.toLower(word.at(i))==\"\
    a\" || std.string.toLower(word.at(i))==\"e\" || std.string.toLower(word.at(i))==\"\
    i\" || std.string.toLower(word.at(i))==\"o\" || std.string.toLower(word.at(i))==\"\
    u\" || std.string.toLower(word.at(i))==\"y\" || std.string.toLower(word.at(i))==\"\
    \xE4\" || std.string.toLower(word.at(i))==\"\xF6\" || std.string.toLower(word.at(i))==\"\
    \xFC\")\n            {\n                maxLen = i;\n            }\n        }\n\
    \    }\n    if(minLen > maxLen) return \"\";\n    return word.at(minLen);\n}",
  "{\n    int cons = 0;\n    int vowel = 0;\n    int vowel_cons = 0;\n    int vowel_word\
    \ = 0;\n    int cons_word = 0;\n    int word_len = word.length();\n    for (int\
    \ i = word_len - 1; i >= 0; i--)\n    {\n        if (isalpha(word[i]))\n     \
    \   {\n            if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u')\n            {\n                cons_word++;\n   \
    \             cons += 1;\n            }\n            else\n            {\n   \
    \             if (cons_word == 0)\n                {\n                    cons_word\
    \ = i;\n                }\n                else if (cons_word == word_len - 1\
    \ && i != 0)\n                {\n                    cons_word = i;\n        \
    \        }\n                else if (cons_word > word_len - 1 && i == 0)\n   \
    \             {\n                    cons_word = i;\n                }\n     \
    \           else\n                {\n                    if (cons_word < i)\n\
    \                    {\n                        cons_word = i;\n             \
    \       }\n                }\n            }\n        }\n        else\n       \
    \ {\n            if (cons_word == 0)\n            {\n                cons_word\
    \ = i;\n            }\n            else if (cons_word == word_len - 1 && i !=\
    \ 0)\n            {\n                cons_word = i;\n            }\n         \
    \   else if (cons_word > word_len - 1 && i == 0)\n            {\n            \
    \    cons_word = i;\n            }\n            else\n            {\n        \
    \        if (cons_word < i)\n                {\n                    cons_word\
    \ = i;\n                }\n            }\n        }\n    }\n    for (int i = 0;\
    \ i < word_len; i++)\n    {\n        if (isalpha(word[i]))\n        {\n      \
    \      if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u')\n            {\n                vowel_cons++;\n         \
    \       vowel_word += 1;\n            }\n            else\n            {\n   \
    \             if (vowel_cons == 0)\n                {\n                    vowel_cons\
    \ = i;\n                }\n                else if (vowel_cons == word_len - 1\
    \ && i != 0)\n                {\n                    vowel_cons = i;\n       \
    \         }\n                else if (vowel_cons > word_len - 1 && i == 0)\n \
    \               {\n                    vowel_cons = i;\n                }\n  \
    \              else\n                {\n                    if (vowel_cons < i)\n\
    \                    {\n                        vowel_cons = i;\n            \
    \        }\n                }\n            }\n        }\n        else\n      \
    \  {\n            if (vowel_cons == 0)\n            {\n                vowel_cons\
    \ = i;\n            }\n            else if (vowel_cons == word_len - 1 && i !=\
    \ 0)\n            {\n                vowel_cons = i;\n            }\n        \
    \    else if (vowel_cons > word_len - 1 && i == 0)\n            {\n          \
    \      vowel_cons = i;\n            }\n", "{\n    map<string, int> m; \n    for\
    \ (int i = word.length() - 1; i >= 0; --i) \n    {\n        if (m.find(word[i])\
    \ == m.end())\n        {\n            m[word[i]] = 1;\n        }\n        else\n\
    \        {\n            m[word[i]]++;\n        }\n    }\n    \n    int max = -999999999;\n\
    \    for (auto p : m)\n    {\n        if (p.second > max)\n        {\n       \
    \     max = p.second;\n        }\n    }\n    \n    return m[word.back()] > max\
    \ ? \"a\" : \"\";\n}", "{\n    if(word.length < 2)\n    {\n        return \"\"\
    ;\n    }", "{\n  int i = 0;\n  while (i+1 < word.length()) \n  {\n    int j;\n\
    \    if (word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O'\
    \ || word[i] == 'U')\n    {\n      for (j = i+1; j < word.length(); j++)\n   \
    \   {\n        if (word[j] != 'a' && word[j] != 'e' && word[j] != 'i' && word[j]\
    \ != 'o' && word[j] != 'u')\n        {\n          break;\n        }\n      }\n\
    \      if (j == word.length())\n      {\n        return word[i];\n      }\n  \
    \    else\n      {\n        i++;\n      }\n    }\n    else if (word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u')\n \
    \   {\n      for (j = i-1; j >= 0 ; j--)\n      {\n        if (word[j] != 'a'\
    \ && word[j] != 'e' && word[j] != 'i' && word[j] != 'o' && word[j] != 'u')\n \
    \       {\n          break;\n        }\n      }\n      if (j == -1)\n      {\n\
    \        return word[i];\n      }\n      else\n      {\n        i++;\n      }\n\
    \    }\n    else\n    {\n      return \"\";\n    }\n  }\n  return \"\";\n}\n</code>\n\
    <|/ a dscore=0 tags=c++,function,for-loop,string |>\n<| c |>\nThis is a code dump\
    \ with no explanation.  You should consider explaining your answer!\n<|/ c |>\n\
    <| a tags=c++,function,for-loop,string |>\n<code>\n#include <string>\n#include\
    \ <vector>\n#include <algorithm>\n#include <cstdlib>", "{\n    map<int, char>\
    \ vowelsDict = {{'a','e','i','o','u', 0}};\n    int pos = 0;\n    int minPos =\
    \ 999;\n    for(int i = word.length()-1; i >= 0; i--) {\n        if(vowelsDict.count(word[i])\
    \ > 0)\n        {\n            if(word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u')\n            {\n               \
    \ if(minPos < word.length()-i) {\n                    minPos = word.length()-i;\n\
    \                    pos = i;\n                }\n            }\n        }\n \
    \   }\n    return word[pos];\n}\n</code>\n<|/ a tags=c++,string,algorithm dscore=3\
    \ |>\n<| a dscore=2 |>\nHere are some thoughts that might help.  Perhaps you can\
    \ get some inspiration from them and implement some of your own.\nTo determine\
    \ if a character is a vowel, you could use the ASCII table, which will give you\
    \ all of the characters and their ASCII codes.  You can see what a vowel looks\
    \ like here, but note that the vowels have slightly different shapes.  Here's\
    \ an example of how you might implement that.\nTo find the closest vowel, you\
    \ can probably get some inspiration from String.IndexOf().  Here's another question\
    \ that might help you.\nFinally, if you have problems writing code that uses these\
    \ methods, I suggest you start by writing a method that is just to see if you\
    \ can find the index of the first vowel in some string.\n<|/ a tags=c++,string,algorithm\
    \ |>\n<| a |>\n<code>\npublic class ClosestVowel {", "{\n    for(int i=word.length()-1;i>=0;i--)\n\
    \    {\n        if(word[i]==\"A\" || word[i]==\"E\" || word[i]==\"I\" || word[i]==\"\
    O\" || word[i]==\"U\" || word[i]==\"a\" || word[i]==\"e\" || word[i]==\"i\" ||\
    \ word[i]==\"o\" || word[i]==\"u\")\n        {\n            return word[i];\n\
    \        }\n    }\n    return \"\";\n}", "{\n    auto first = word[0];\n    auto\
    \ last  = word[word.length()-1];", "{\n    auto vowel_iter = word.rbegin();\n\
    \    auto vowel_end = word.rend();\n    vowel_iter = std::find_if(vowel_iter,\
    \ vowel_end, \n                [&](char c) {\n                    return ((c >=\
    \ 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n                });\n    vowel_iter\
    \ = std::find_if(vowel_iter, vowel_end, \n                [&](char c) {\n    \
    \                return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n\
    \                });", "{\n    stack<pair<int, int>> vowels;\n    for(int i =\
    \ 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n        {\n\
    \            vowels.push(pair<int, int>(i + 1, i));\n        }\n    }", "{\n \
    \   string result = \"\";\n    typedef map<string, int> VowelMap;\n    VowelMap\
    \ vowels;", "{\n    int len = word.length();\n    int left = 0;\n    int right\
    \ = 0;\n    int mid = 0;\n    int vcount = word.find_first_not_of(\"aeiou\");\n\
    \    string vowel;\n    \n    if (vcount == -1)\n    {\n        return \"\";\n\
    \    }\n    \n    for (int i = 0; i <= len - 2; i++)\n    {\n        mid = len\
    \ - i - 1;\n        right = len - 1;\n        left = len - 1;\n        \n    \
    \    while (mid > 0 && word[mid-1] == word[mid])\n        {\n            right--;\n\
    \            mid--;\n        }\n        \n        while (mid < len && word[mid]\
    \ == word[mid+1])\n        {\n            left++;\n            mid++;\n      \
    \  }\n        \n        string rightstr = word.substr(right+1, len-right - 1);\n\
    \        string leftstr = word.substr(left+1, len-left-1);\n        \n       \
    \ bool isvowel = false;\n        bool isvowelleft = false;\n        bool isvowelright\
    \ = false;\n        \n        for (int j = 0; j <= len - 1; j++)\n        {\n\
    \            if (word[j] == word[mid])\n            {\n                if (word[left]\
    \ == word[mid+1])\n                {\n                    isvowelleft = true;\n\
    \                }\n                if (word[right] == word[mid+1])\n        \
    \        {\n                    isvowelright = true;\n                }\n    \
    \            if (word[j] == vowel)\n                {\n                    isvowel\
    \ = true;\n                }\n            }\n        }\n        \n        if (isvowel)\n\
    \        {\n            if (isvowelleft)\n            {\n                if (isvowelright)\n\
    \                {\n                    if (left == right)\n                 \
    \   {\n                        if (len == right + vcount && right - vcount <=\
    \ len && right - vcount >= 1)\n                        {\n                   \
    \         vowel = word.substr(left+1, len-left-1);\n                        }\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return vowel;\n}\n</code>\n<|/ a tags=string,c++,algorithm |>\n<| a tags=string,c++,algorithm\
    \ |>\n<code>\n#include <iostream>\n#include <algorithm>", "{\n    if (word.length()\
    \ == 0 || word == \"a\" || word == \"e\" || word == \"i\" || word == \"o\" ||\
    \ word == \"u\")\n        return word;", "{\n\tint vowels[26];\n\tfor(int i =\
    \ 0; i < 26; i++)\n\t\tvowels[i] = 0;\n\tfor (int i = word.length() - 1; i >=\
    \ 0; i--)\n\t{\n\t\tif(is_vowel(word[i]))\n\t\t\tvowels[tolower(word[i]) - 'a']++;\n\
    \t}\n\tstring result = \"\";\n\tfor (int i = vowels.length - 1; i >= 0; i--)\n\
    \t{\n\t\tif (vowels[i] > 0 && vowels[i] + 1 < 26)\n\t\t\tbreak;\n\t\telse \n\t\
    \t\tvowels[i]--;\n\t}\n\tif (vowels[0] == 0)\n\t\treturn \"\";\n\tresult += (char)(tolower((int)'a')\
    \ + vowels[0] - 1);\n\treturn result;\n}", "{\n    string vowels = \"aeiouy\"\
    ;\n    string::iterator it;\n    int start = distance(word.rbegin(), word.rend(),\
    \ vowels.rbegin());\n    it = (word.rbegin() + start).base();\n    while(!isalpha(*it))\n\
    \    {\n        it++;\n    }\n    int stop = distance(word.rbegin(), word.rend(),\
    \ vowels.rend());\n    it = (word.rend()).base();\n    while(!isalpha(*it))\n\
    \    {\n        it--;\n    }\n    int diff = abs(it - word.end());\n    if(diff\
    \ > 2 && diff < 4)\n    {\n        string first = word.substr(0, stop);\n    \
    \    string second = word.substr(start, stop);\n        if(second == first)\n\
    \            return second;\n    }\n    return \"\";\n}\n</code>\n<|/ a |>\n<|\
    \ a tags=c++,string |>\nI think the easiest and most readable way of doing this\
    \ is probably to convert your string into a vector of characters and then use\
    \ upper_bound or lower_bound to find the nearest vowel.\n<code>\n#include <iostream>\n\
    #include <vector>\n#include <algorithm>\n#include <string>", "{\n    \n    int\
    \ left  = word.find_last_of(\"aeiou\");\n    int right = word.find_last_of(\"\
    AEIOU\");", "{\n    for(auto i : word)\n    {\n        if(isvowel(i)) \n     \
    \   {\n            auto v = std.string(i);\n            auto pos = v.length()\
    \ - 1;\n            while(pos >= 0)\n            {\n                auto c = v.at(pos);\n\
    \                if(isvowel(c))\n                {\n                    string\
    \ vowel = v;\n                    auto vowel_pos = pos + 1;\n                \
    \    while(vowel_pos < v.length() && isvowel(v.at(vowel_pos)))\n             \
    \       {\n                        vowel = v.substr(0, vowel_pos) + v.substr(vowel_pos+1);\n\
    \                        vowel_pos--;\n                    }\n               \
    \     if(vowel == v)\n                    {\n                        return c;\n\
    \                    }\n                }\n                pos--;\n          \
    \  }\n        }\n    }\n    return \"\";\n}\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nThis code works in most cases. In other cases it produces an infinite\
    \ loop. I'm looking for some insight on why that is.\n<|/ c |>\n<| c |>\nI think\
    \ I figured out the problem. Not sure if this is the fastest solution, but it\
    \ works for most cases. I will edit my question to provide some test cases for\
    \ you to test against. Thank you for taking time to provide feedback.\n<|/ c |>\n\
    <| c |>\nHi, can you share the test case which produces infinite loop?\n<|/ c\
    \ |>\n<| c |>\nYes, I'll update my question with that. Sorry for the delay.\n\
    <|/ c |>\n<| c |>\nI've updated my question with a solution that works better\
    \ for me. Thank you for your help!\n<|/ c |>\n<| a dscore=1 |>\nHere's a brute-force\
    \ solution:\n<code>\nstd::string get_closest_vowel(std::string word)\n{\n    for\
    \ (auto &c : word)\n        if (isvowel(c))\n        {\n            auto vowel_pos\
    \ = word.find_last_of(c);\n            while (vowel_pos >= 0)\n            {\n\
    \                if (isvowel(word.substr(0, vowel_pos)))\n                   \
    \ return c;\n                vowel_pos--;\n            }\n        }\n    return\
    \ \"\";\n}\n</code>\n<|/ a tags=string,algorithm,c++ |>\n<| a tags=string,algorithm,c++\
    \ |>\nThis doesn't directly answer your question, but is more of an observation\
    \ as to why your code doesn't work.\nYou don't say why your code doesn't work.\
    \ My guess is that you're getting an infinite loop. One way to test whether this\
    \ is the case is to print out the string that you're searching through at each\
    \ stage of the loop. You can see that once you reach the end of the ", "{\n  \
    \  int start = 1;\n    int end = word.length() - 1;\n    int middle = word.length()\
    \ / 2;\n    while(start < end || start > middle || end > middle)\n    {\n    \
    \    int left = word.find_first_not_of('ZA', start);\n        int right = word.find_first_not_of('ZA',\
    \ end);\n        if(left == -1)\n        {\n            end = word.find_last_not_of('ZA',\
    \ end);\n        }\n        else if(right == -1)\n        {\n            start\
    \ = word.find_last_not_of('ZA', start);\n        }\n        else\n        {\n\
    \            if(left != right)\n            {\n                string leftVowel\
    \ = get_vowel(word.substr(left, 1));\n                string rightVowel = get_vowel(word.substr(right,\
    \ 1));\n                if(leftVowel != rightVowel)\n                {\n     \
    \               int pos = distance(leftVowel, rightVowel);\n                 \
    \   if(pos < middle)\n                    {\n                        middle =\
    \ pos;\n                    }\n                }\n            }\n            else\n\
    \            {\n                middle = middle;\n            }\n        }\n \
    \   }\n    if(start < middle && end > middle)\n    {\n        string leftVowel\
    \ = get_vowel(word.substr(start, 1));\n        string rightVowel = get_vowel(word.substr(middle,\
    \ 1));\n        string leftVowel2 = get_vowel(word.substr(start, 1));\n      \
    \  string rightVowel2 = get_vowel(word.substr(middle, 1));\n        int pos =\
    \ distance(leftVowel, rightVowel);\n        int pos2 = distance(leftVowel2, rightVowel2);\n\
    \        if(pos < middle && pos2 < middle)\n        {\n            if(pos < pos2)\n\
    \            {\n                return leftVowel;\n            }\n           \
    \ else\n            {\n                return rightVowel;\n            }\n   \
    \     }\n        else\n        {\n            return \"\";\n        }\n    }\n\
    \    else\n    {\n        return \"\";\n    }\n}", "{\n    return \"\";\n}", "{\n\
    \    if(!std.string.find(word, \"a\") && !std.string.find(word, \"e\") && !std.string.find(word,\
    \ \"i\") && !std.string.find(word, \"o\") && !std.string.find(word, \"u\") &&\
    \ !std.string.find(word, \"y\")) return \"\";\n    \n    int i=word.size()-1;\n\
    \    string vowel;\n    while(i>=0)\n    {\n        if(std.string.find(word.substr(0,i),\
    \ \"a\") || std.string.find(word.substr(0,i), \"e\") || std.string.find(word.substr(0,i),\
    \ \"i\") || std.string.find(word.substr(0,i), \"o\") || std.string.find(word.substr(0,i),\
    \ \"u\") || std.string.find(word.substr(0,i), \"y\")) \n            vowel = word.substr(0,i);\n\
    \        i = i-1;\n    }\n    return vowel;\n}", "{\n    int low = word.length()\
    \ - 1;\n    int high = 0;\n    while(low >= 0 && high < word.length())\n    {\n\
    \        if(!isVowel(word[low]) && !isVowel(word[high]))\n        {\n        \
    \    low--;\n            high++;\n        }\n        else\n        {\n       \
    \     low--;\n            high++;\n            while(low >= 0 && high < word.length()\
    \ && word[low] == word[high])\n            {\n                low--;\n       \
    \         high++;\n            }\n            if(low < 0 || high == word.length())\n\
    \            {\n                if(low < 0)\n                {\n             \
    \       low = 0;\n                }\n                else if(word[low] == 'z')\n\
    \                {\n                    low = word.length() - 1;\n           \
    \     }\n                else\n                {\n                    low = word.length()\
    \ - 1;\n                    while(low >= 0 && word[low] == 'z')\n            \
    \        {\n                        low--;\n                    }\n          \
    \      }\n                return word[low];\n            }\n        }\n    }\n\
    \    return \"\";\n}", "{\n\tmap<char,int> m;\n\tfor (int i = 0; i < word.length();\
    \ i++)\n\t{\n\t\tchar c = word[i];\n\t\tif (m.containsKey(c))\n\t\t\tm[c]++;\n\
    \t\telse\n\t\t\tm[c] = 1;\n\t}\n\tmap<char,int>::iterator it;\n\tstring vowel\
    \ = \"\";\n\tfor (it=m.begin();it!=m.end();it++)\n\t{\n\t\tint count = it->second;\n\
    \t\tint min = it->first;\n\t\tif (count % 2 == 0 && count == word.size()-1)\n\t\
    \t\treturn vowel;\n\t\tif (count == word.size()-1)\n\t\t\treturn it->first;\n\t\
    \tif (count % 2 == 0)\n\t\t{\n\t\t\tif (word[min]=='a' || word[min]=='e' || word[min]=='i'\
    \ || word[min]=='o' || word[min]=='u')\n\t\t\t\tvowel += it->first;\n\t\t\telse\n\
    \t\t\t\treturn vowel;\n\t\t}\n\t}\n\treturn vowel;\n}", "{\n    // Write your\
    \ code here\n    sort(word.begin(),word.end());\n    int first=find(word.rbegin(),word.rend(),'u');\n\
    \    int second=find(word.rbegin(),word.rend(),'U');\n    int firstlen=length(word)-first-1;\n\
    \    int secondlen=length(word)-second-1;\n    if(firstlen>secondlen)\n      \
    \  return \"\";\n    else\n        return word[secondlen+2];\n}\n</code>\n<|/\
    \ a tags=string,c++,algorithm |>\n<| a dscore=0 tags=string,c++,algorithm |>\n\
    I wrote this code for solving that problem but I don't know how to deal with that\
    \ case when the string is \"ab\" and my code return \"i\"\n<code>\n#include <iostream>\n\
    #include <algorithm>\n#include <string>\nusing namespace std;", "{\n    int vowel_count\
    \ =0;\n    for(int i=word.length()-1;i>=0;i--){\n        if(isupper(word[i])){\n\
    \            vowel_count++;\n        }\n    }\n    int index_of_first_vowel_found\
    \ = 0;\n    for(int i=word.length()-1;i>=0;i--){\n        if(isupper(word[i])){\n\
    \            if(vowel_count <=2){\n                index_of_first_vowel_found\
    \ = i;\n                vowel_count++;\n                break;\n            }\n\
    \            else{\n                if(vowel_count > 2){\n                   \
    \ index_of_first_vowel_found = i;\n                    vowel_count--;\n      \
    \              break;\n                }\n                else {\n           \
    \         index_of_first_vowel_found = i;\n                }\n            }\n\
    \        }\n    }\n    string result=\"\";\n    for(int i=index_of_first_vowel_found;i<word.length();i++){\n\
    \        if(isupper(word[i])){\n            break;\n        }\n        else {\n\
    \            result +=word[i];\n        }\n    }\n    return result;\n}", "{\n\
    \    typedef map<int,bool> VowelsMap;\n    VowelsMap vowels;\n    string vowel\
    \ = \"\";\n    int minVowel = INT_MAX;\n    int maxVowel = 0;\n    for(int i=0;\
    \ i<word.length(); ++i) {\n        if(word[i]=='a'||word[i]=='e'||word[i]=='i'||word[i]=='o'||word[i]=='u')\
    \ {\n            vowels[word[i]] = true;\n        }\n    }\n    for(int i=0; i<word.length();\
    \ ++i) {\n        if(vowels[word[i]]) {\n            if(minVowel==INT_MAX) {\n\
    \                minVowel = i;\n            }\n            else if(maxVowel==0)\
    \ {\n                maxVowel = i;\n            }\n            else if(word[i]<minVowel)\
    \ {\n                minVowel = i;\n            }\n            else if(word[i]>maxVowel)\
    \ {\n                maxVowel = i;\n            }\n        }\n    }\n    if(minVowel<maxVowel)\
    \ {\n        while(vowels[word[minVowel]]) {\n            minVowel++;\n      \
    \  }\n        while(vowels[word[maxVowel]]) {\n            maxVowel--;\n     \
    \   }\n        vowel = word[minVowel]+word[maxVowel];\n    }\n    else \n    \
    \    vowel = word[0];\n    return vowel;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,string\
    \ |>\n<| a tags=algorithm,string |>\nMy solution in Java using regex:\n<code>\n\
    public String getClosestVowel(String word) {\n    String vowels = \"aeiou\";\n\
    \    return word.substring(0, word.lastIndexOf(vowels, word.lastIndexOf(vowels.substring(1))))\n\
    \            + word.substring(word.lastIndexOf(vowels.substring(1)));\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nOh, I see you've posted a solution in C++. But this\
    \ one won't work for you, because it will only work with the first vowel in the\
    \ string. I'll post an answer in a sec.\n<|/ c |>\n<| a |>\nHere is a Python version.\
    \ \n<code>\ndef get_closest_vowel(word):\n  vowels = 'aeiouAEIOU'\n  vowel_pos\
    \ = -1\n  for i in range(1, len(word)):\n    if word[i-1] in vowels and word[i]\
    \ in vowels:\n      vowel_pos = i\n      break\n  result = word[:vowel_pos] +\
    \ word[vowel_pos:]\n  return result\n</code>\n<|/ a dscore=", "{\n    auto start\
    \ = word.size() - 1;\n    auto end = word.size();", "{\n  int start = word.length()\
    \ - 1;\n  int end = -1;\n  while (end == -1)\n  {\n    end = (start - 1);\n  \
    \  if (word[end] == 'a' || word[end] == 'e' || word[end] == 'i' || word[end] ==\
    \ 'o' || word[end] == 'u')\n    {\n      end -= 1;\n    }\n    else\n    {\n \
    \     start -= 1;\n    }\n  }\n  return word.substr(start, (end - start) + 1);\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nHere's a solution using recursion.\n\
    <code>\nstring vowel = \"\",\n        vowels = \"aeiou\";", "{\n    auto it =\
    \ find(word.rbegin(), word.rend(), 'a');\n    \n    auto left_it = it;\n    \n\
    \    for(auto i = it; it != word.rend(); ++it)\n    {\n        if(*it == 'a' ||\
    \ *it == 'e' || *it == 'i' || *it == 'o' || *it == 'u') break;\n    }", "{\n \
    \   int i = 0;\n    int j = 0;\n    string vowel = \" \";\n    while(i<word.length())\n\
    \    {\n        if(word[i]==word[i+1])\n        {\n            j = i;\n      \
    \      while(j<word.length())\n            {\n                if(word[j]==word[j+1])\n\
    \                {\n                    j++;\n                }\n            \
    \    else if(word[j]==word[j+2])\n                {\n                    vowel\
    \ += word[j];\n                    j+=3;\n                    break;\n       \
    \         }\n                else if(word[j]==word[j+3])\n                {\n\
    \                    vowel += word[j];\n                    j+=4;\n          \
    \          break;\n                }\n                else if(word[j]==word[j+4])\n\
    \                {\n                    vowel += word[j];\n                  \
    \  j+=5;\n                    break;\n                }\n                else\
    \ if(word[j]==word[j+5])\n                {\n                    vowel += word[j];\n\
    \                    j+=6;\n                    break;\n                }\n  \
    \              else if(word[j]==word[j+6])\n                {\n              \
    \      vowel += word[j];\n                    j+=7;\n                    break;\n\
    \                }\n                else if(word[j]==word[j+7])\n            \
    \    {\n                    vowel += word[j];\n                    j+=8;\n   \
    \                 break;\n                }\n                else if(word[j]==word[j+8])\n\
    \                {\n                    vowel += word[j];\n                  \
    \  j+=9;\n                    break;\n                }\n                else\
    \ if(word[j]==word[j+9])\n                {\n                    vowel += word[j];\n\
    \                    j+=10;\n                    break;\n                }\n \
    \               else if(word[j]==word[j+10])\n                {\n            \
    \        vowel += word[j];\n                    j+=11;\n                    break;\n\
    \                }\n                else if(word[j]==word[j+11])\n           \
    \     {\n                    vowel += word[j];\n                    j+=12;\n \
    \                   break;\n                }\n                else if(word[j]==word[j+12])\n\
    \                {\n                    vowel += word[j];\n                  \
    \  j+=13;\n                    break;\n                }\n                else\
    \ if(word[j]==word[j+13])\n                {\n                    vowel += word[j];\n\
    \                    j+=14;\n                    break;\n                }\n \
    \               else if(word[j]==word[j+14])\n                {\n            \
    \        vowel += word[j];\n                    j+=15;\n                    break;\n\
    \                }\n                else if(word[j]==word[j+15])\n           \
    \     {\n                    vowel += word[j];\n                    j+=16;\n \
    \                   break;\n                }\n                else if(word[j]==word[j+16])\n\
    \                {\n                    vowel += word[j];\n                  \
    \  j+=17;\n                    break;\n                }\n                else\
    \ if(word[j]==word[j+17])\n                {\n                    vowel += word",
  "{\n\tint i=word.length()-1;\n\twhile(i > 0) {\n\t\tif(word[i] == 'a') {\n\t\t\t\
    if(word[i-1] == 'u' || word[i-1] == 'e' || word[i-1] == 'i' || word[i-1] == 'o'\
    \ || word[i-1] == 'A') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if(word[i]\
    \ == 'e') {\n\t\t\tif(word[i-1] == 'u' || word[i-1] == 'e' || word[i-1] == 'i'\
    \ || word[i-1] == 'o' || word[i-1] == 'A') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\
    \t\telse if(word[i] == 'i') {\n\t\t\tif(word[i-1] == 'u' || word[i-1] == 'e' ||\
    \ word[i-1] == 'i' || word[i-1] == 'o' || word[i-1] == 'A') {\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t\telse if(word[i] == 'o') {\n\t\t\tif(word[i-1] == 'u' || word[i-1]\
    \ == 'e' || word[i-1] == 'i' || word[i-1] == 'o' || word[i-1] == 'A') {\n\t\t\t\
    \tbreak;\n\t\t\t}\n\t\t}\n\t\telse if(word[i] == 'u') {\n\t\t\tif(word[i-1] ==\
    \ 'u' || word[i-1] == 'e' || word[i-1] == 'i' || word[i-1] == 'o' || word[i-1]\
    \ == 'A') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if(word[i] == 'A') {\n\t\
    \t\tif(word[i-1] == 'u' || word[i-1] == 'e' || word[i-1] == 'i' || word[i-1] ==\
    \ 'o' || word[i-1] == 'A') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if(i ==\
    \ 0) {\n\t\t\tbreak;\n\t\t}\n\t\ti--;\n\t}\n\tif(i == word.length()-1) {\n\t\t\
    return \"\";\n\t}\n\treturn word[i];\n}\n</code>\n<|/ a |>\n<| c |>\nThank you\
    \ so much! Can you explain the for loop here?\n<|/ c |>\n<| c |>\nIt's a tricky\
    \ one. Basically the for loop goes from right to left. The first condition is\
    \ `i<word.length()-1` and the second is `i--`. Basically the loop runs while `i`\
    \ has not reached `0` so it will terminate when it reaches `-1`. Now to understand\
    \ the `break` condition, the condition here `if(word[i] == 'a') {\n\t\t\tif(word[i-1]\
    \ == 'u' || word[i-1] == 'e' || word[i-1] == 'i' || word[i-1] == 'o' || word[i-1]\
    \ == 'A') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}` means that if the letter at `i` is\
    \ `a` and it is next to a vowel it will terminate the loop and return the letter\
    \ `a` which is the closest vowel to the right end of the word.\n<|/ c |>\n<| a\
    \ dscore=2 |>\n<code>\nstring get_closest_vowel(string word) \n{\n    string vowel",
  "{\n    string vowels[] = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n    string leftSide\
    \ = word[word.len()-1];\n    string rightSide = word[word.len()-1];\n    string\
    \ firstVowel = vowels[leftSide.find_last_of(\"aeiou\")];\n    string lastVowel\
    \ = vowels[rightSide.find_first_of(\"aeiou\")];\n    string result = \"\";\n \
    \   \n    if(leftSide.find_last_of(\"aeiou\") > rightSide.find_first_of(\"aeiou\"\
    )){\n        return \"\";\n    }\n    \n    if(firstVowel == \"\" && lastVowel\
    \ == \"\"){\n        return \"\";\n    }", "{\n\tstring vowels = \"AEIOU\";\n\t\
    auto vowel = vowels.find(word[word.size()-1]);\n\tauto cons = word.rfind(word[word.size()-2],vowel);\n\
    \tif((cons == string::npos) || (cons < 0))\n\t\treturn word;\n\treturn word[cons];\n\
    }", "{\n    auto result = word;\n    auto vowel_end = result.rfind('u');\n   \
    \ if(vowel_end != string::npos)\n    {\n        auto current_vowel = result.rfind(result,0,vowel_end+1);\n\
    \        if(current_vowel != string::npos)\n        {\n            string temp=result.substr(current_vowel);\n\
    \            return temp.substr(temp.find_last_of(\"u\"));\n        }\n    }\n\
    \    return \"\";\n}\n</code>\n<|/ a |>\n<| c |>\nNice solution. I didn't think\
    \ about this. However, I wonder about the efficiency of this solution compared\
    \ to other solutions proposed so far.\n<|/ c |>\n<| c |>\nThis is an easy problem\
    \ to solve. It has complexity of O(n) where n is length of the word. The complexity\
    \ of the solution proposed in the question seems to be O(n*m). So it is better\
    \ to use the proposed solution in that case.\n<|/ c |>\n<| c |>\nThank you. Although\
    \ my solution seems a bit longer, it works perfectly for this problem. Thank you\
    \ for taking the time to answer my question.\n<|/ c |>\n<| a |>\nHere's a solution\
    \ using a different approach:\n<code>\n// Return closest vowel that is between\
    \ vowel start and vowel end\nstring closestVowel(string word) {\n    if(word.length()\
    \ == 0) return \"\";\n    auto pos = word.rfind('u');\n    if(pos == string::npos)\
    \ return \"\";\n    pos += 2;\n    string vowel = word.substr(pos).substr(0, pos);\n\
    \    string vowel1 = word.substr(pos).substr(pos);\n    auto vowelPos = word.find(vowel,\
    \ pos);\n    while(vowelPos == word.end()) vowelPos = word.find(vowel1, pos +\
    \ 1);\n    if(vowelPos == word.end()) return \"\";\n    string prefix = word.substr(0,\
    \ pos);\n    string suffix = word.substr(pos + vowelPos + 1);\n    auto suffix\
    \ = suffix.find_last_of(\"u\");\n    return prefix.substr(0, prefix.find_last_of(\"\
    u\")) + suffix;\n}\n</code>\n<|/ a dscore=0 tags=algorithm,c++,string |>\n<| a\
    \ tags=algorithm,c++,string dscore=0 |>\nI came up with a more efficient approach\
    \ which does not require to find multiple vowels but rather just a single one\
    \ and then remove this vowel from the string. Here is how I do it:\n<code>\nstring\
    \ get_closest_vowel(string word){\n  string vowels = \"uaoui\";\n  int index =\
    \ word.rfind(\"u\");\n  if(index == string::npos){\n      return ", "{\n    if(word.empty())\
    \ return \"\";\n    \n    unordered_set<char> vowels = { 'a', 'e', 'i', 'o', 'u'\
    \ };\n    \n    for(int i = word.size()-1;i>=1;i--)\n    {\n        if(vowels.count(word[i])\
    \ == 0) continue;\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u') break;\n    }", "{\n    string vowels =\
    \ \"aeiouAEIOU\";\n    int start = 0;\n    int end = word.length() - 1;\n    while\
    \ (start <= end) {\n        string leftString = word.substr(0, start);\n     \
    \   string rightString = word.substr(end, end + 1);\n        int posVowel = vowels.find(leftString);\n\
    \        int posNonVowel = vowels.find(rightString);\n        if (posVowel >=\
    \ 0) {\n            if (posNonVowel >= 0)\n                return word.substr(start,\
    \ end + 1);\n            else \n                return word.substr(start, posVowel);\n\
    \        }\n        else if (posNonVowel >= 0)\n            start = end + 1;\n\
    \        else if (posVowel < 0)\n            end = start - 1;\n    }\n    return\
    \ \"\";\n}", "{\n    int vowel_count = 0;\n    int vowel_start_index;\n    int\
    \ vowel_end_index;\n    int letter_start_index;\n    int letter_end_index;", "{\n\
    \tint left = 0;\n\tint right = (word.length() - 1);\n\tint left_count = 1;\n\t\
    int right_count = 1;\n\twhile(left < right && left_count < right_count) \n\t{\n\
    \t\tint middle = left + (right - left) / 2;\n\t\tif(word.startsWith(vowels[middle])\
    \ && word.endsWith(vowels[middle])) {\n\t\t\treturn vowels[middle];\n\t\t}\n\t\
    \tif(word.endsWith(vowels[middle]) && word.startsWith(vowels[middle - 1])) {\n\
    \t\t\tright = middle - 1;\n\t\t\tright_count++;\n\t\t}\n\t\telse if(word.startsWith(vowels[middle\
    \ - 1]) && word.endsWith(vowels[middle])) {\n\t\t\tleft = middle;\n\t\t\tleft_count++;\n\
    \t\t}\n\t}\n\tif(left == right) {\n\t\tif(left_count == right_count) {\n\t\t\t\
    return word[left];\n\t\t}\n\t\telse {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\telse\
    \ {\n\t\treturn \"\";\n\t}\n}", "{\n\tint leftVowelIndex = findVowelIndex(word);\n\
    \tint rightVowelIndex = findVowelIndex(word, right(word));\n\treturn leftVowelIndex\
    \ < rightVowelIndex ? word[leftVowelIndex] : \"\";\n}\n/*\nYou are given two strings\
    \ and are asked to find the longest common prefix.", "{\n    int vowels[] = {\
    \ 'a', 'e', 'i', 'o', 'u' };\n    int len = word.size();\n    int count = 0;\n\
    \    for(int i=0; i<len; i++)\n    {\n        if(islower(word[i]))\n        {\n\
    \            int j;\n            for(j=0; j<len; j++)\n            {\n       \
    \         if(islower(word[j]) && word[j]!=word[i] && word[j] != 'z')\n       \
    \         {\n                    if(word[j-1]==vowels[count] && word[j+1]==vowels[count])\n\
    \                    {\n                        count++;\n                   \
    \ }\n                    break;\n                }\n            }\n        }\n\
    \    }\n    if(count>=3)\n    {\n        return word[count-1];\n    }\n    return\
    \ \"\";\n}\n</code>\n<|/ a |>\n<| c |>\nWhy not `int vowels[] = { 'a', 'e', 'i',\
    \ 'o', 'u' };`?\n<|/ c |>\n<| c |>\nI thought of it but had a very little idea\
    \ on how to do that.\n<|/ c |>\n<| c |>\n, that should be `if (islower(word[j]))`\
    \ since the first `word[j]` is the `i` in the first conditional.\n<|/ c |>\n<|\
    \ c |>\nOops, yes that is what I meant to say... Thanks for pointing that out.\n\
    <|/ c |>\n<| c |>\nNo need for an inner loop, just one `for` loop with an `if`\
    \ statement is all that's needed.\n<|/ c |>\n<| a tags=c++ dscore=0 |>\nHere is\
    \ another solution in Python.\n<code>\ndef find_closest_vowel(word):\n    vowels\
    \ = 'aeiouAEIOU'\n    for s in range(len(word)):\n        if word[s] in vowels:\n\
    \            start = s\n            break\n    start = max(0, start - 1)\n   \
    \ for s in range(len(word)):\n        if word[s] in vowels:\n            end =\
    \ s\n            break\n    end = min(len(word), end)\n    if start < end:\n \
    \       return word[start:end]\n    return \"\"\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nC++ - Recursive Method\n<code>\n#include <bits/stdc++.h>\nusing namespace\
    \ std;", "{\n    int index = 0;\n    int lastIndex = word.size() - 1;\n    bool\
    \ isVowel = false;\n    int leftIndex = 1;\n    int rightIndex = word.size() -\
    \ 1;", "{\n    \n    \n    \n    map<int,char> m; //create a map to count the\
    \ number of consonant in the word", "{\n\tint len = word.length();\n\tchar prev\
    \ = '\\0';\n\tchar curr = word[len - 2];\n\tint cnt = 0;\n\tbool end = false;\n\
    \tfor(int i = len - 1; i >= 0; --i)\n\t{\n\t\tif(curr == 'a'||curr == 'e'||curr\
    \ == 'i'||curr == 'o'||curr == 'u')\n\t\t{\n\t\t\tend = true;\n\t\t\tbreak;\n\t\
    \t}\n\t\telse\n\t\t{\n\t\t\tprev = curr;\n\t\t\tcurr = word[i];\n\t\t}\n\t\tcnt++;\n\
    \t}\n\tif(!end)\n\t\treturn \"\";\n\tif(prev == 'u')\n\t\treturn \"u\";\n\tif(prev\
    \ == 'o')\n\t\treturn \"o\";\n\tstring ans = \"\";\n\tfor(int i = 0; i < len;\
    \ ++i)\n\t{\n\t\tif(curr == 'a'||curr == 'e'||curr == 'i'||curr == 'o'||curr ==\
    \ 'u')\n\t\t{\n\t\t\tans = ans + curr;\n\t\t}\n\t\telse if(curr == 'k')\n\t\t\
    {\n\t\t\tans = ans + \".\";\n\t\t\tbreak;\n\t\t}\n\t\telse if(curr == 'd')\n\t\
    \t{\n\t\t\tif(i < len-1)\n\t\t\t{\n\t\t\t\tans = ans + word[i+1];\n\t\t\t}\n\t\
    \t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if(curr == 'z')\n\t\
    \t{\n\t\t\tans = ans + word[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tans = ans + \"u\"\
    ;\n\treturn ans;\n}", "{\n    map<string,int> vowel_count;\n    for(int i = 0;\
    \ i < (int) word.size(); i++)\n    {\n        for(int k = word.size() - 1; i >\
    \ k; i--)\n        {\n            if(isalpha(word[i]))\n            {\n      \
    \          if(word[i] == word[i + 1])\n                {\n                   \
    \ if(vowel_count.find(word[i]) != vowel_count.end())\n                    {\n\
    \                        vowel_count[word[i]] += 1;\n                        break;\n\
    \                    }\n                    else\n                    {\n    \
    \                    vowel_count[word[i]] = 1;\n                    }\n      \
    \          }\n            }\n        }\n    }\n    \n    map<string,int>::iterator\
    \ it;\n    string closest_vowel = \"\";\n    for(it = vowel_count.begin(); it\
    \ != vowel_count.end(); it++)\n    {\n        if(closest_vowel == \"\")\n    \
    \    {\n            if(it->second > 0)\n            {\n                closest_vowel\
    \ = it->first;\n            }\n        }\n        else if((it->second >= 2) ||\
    \ (it->second == 0) || (it->second == -1))\n        {\n            break;\n  \
    \      }\n    }\n    return closest_vowel;\n}", "{\n    int i,j;\n    int start\
    \ = 0;\n    int end = word.size();\n    string vowel = \"\";\n    for(i = word.size()-1;i\
    \ >=0;i--)\n    {\n        if(word[i] == 'a')\n        {\n            start++;\n\
    \        }\n        if(word[i] == 'e')\n        {\n            start++;\n    \
    \        end--;\n        }\n        if(word[i] == 'i')\n        {\n          \
    \  start++;\n            end--;\n        }\n        if(word[i] == 'o')\n     \
    \   {\n            start++;\n            end--;\n        }\n        if(word[i]\
    \ == 'u')\n        {\n            start++;\n            end--;\n        }\n  \
    \      if(word[i] == 'A')\n        {\n            start++;\n            end--;\n\
    \        }\n        if(word[i] == 'E')\n        {\n            start++;\n    \
    \        end--;\n        }\n        if(word[i] == 'I')\n        {\n          \
    \  start++;\n            end--;\n        }\n        if(word[i] == 'O')\n     \
    \   {\n            start++;\n            end--;\n        }\n        if(word[i]\
    \ == 'U')\n        {\n            start++;\n            end--;\n        }\n  \
    \      if(word[i] == ' ')\n        {\n            break;\n        }\n    }\n \
    \   for(int k = end;k>=0;k--)\n    {\n        if(word[k] == 'a')\n        {\n\
    \            end++;\n        }\n        if(word[k] == 'e')\n        {\n      \
    \      end++;\n            start--;\n        }\n        if(word[k] == 'i')\n \
    \       {\n            end++;\n            start--;\n        }\n        if(word[k]\
    \ == 'o')\n        {\n            end++;\n            start--;\n        }\n  \
    \      if(word[k] == 'u')\n        {\n            end++;\n            start--;\n\
    \        }\n        if(word[k] == 'A')\n        {\n            end++;\n      \
    \      start--;\n        }\n        if(word[k] == 'E')\n        {\n          \
    \  end++;\n            start--;\n        }\n        if(word[k] == 'I')\n     \
    \   {\n            end++;\n            start--;\n        }\n        if(word[k]\
    \ == 'O')\n        {\n            end++;\n            start--;\n        }\n  \
    \      if(word[k] == 'U')\n        {\n            end++;\n            start--;\n\
    \        }\n        if(word[k] == ' ')\n        {\n            break;\n      \
    \  }\n    }\n    for(i = start;i <end;i++)\n    {\n        if(word[i] == 'a')\n\
    \        {\n            vowel += \"a\";\n        }\n        if(word[i] == 'e')\n\
    \        {\n            vowel += \"e\";\n        }\n        if(word[i] == 'i')\n\
    \        {\n            vowel += \"i\";\n        }\n        if(word[i] == 'o')\n\
    \        {\n            vowel += \"o\";\n        }\n        if(word[i] == '",
  "{\n    return \"\";\n}", "{\n    int left = 1;\n    int right = word.Length - 1;\n\
    \    \n    while(true)\n    {\n        int mid = left + right / 2;\n        char\
    \ left = word[mid];\n        char right = word[mid+1];\n        \n        if(left\
    \ == right) // found a vowel\n        {\n            return left; \n        }\n\
    \        else if(left == 'a' || left == 'e' || left == 'i' || left == 'o' || left\
    \ == 'u')\n        {\n            if(right - left < 3)\n            {\n      \
    \          right--;\n            }\n            else\n            {\n        \
    \        if(word.IndexOf(right, mid) == word.Length - 1)\n                {\n\
    \                    return left;\n                }\n                else if(word.IndexOf(right,\
    \ mid) == 0)\n                {\n                    right = mid;\n          \
    \          left = word[mid];\n                    break;\n                }\n\
    \                else\n                {\n                    left = word[mid];\n\
    \                    right = word[mid+1];\n                }\n            }\n\
    \        }\n        else\n        {\n            if(word.IndexOf(left, mid) ==\
    \ word.Length - 1)\n            {\n                left++;\n                break;\n\
    \            }\n            else if(word.IndexOf(left, mid) == 0)\n          \
    \  {\n                left++;\n                right = mid;\n            }\n \
    \           else\n            {\n                right = mid;\n              \
    \  left = word[mid];\n            }\n        }\n    }\n    return \"\";\n}\n</code>\n\
    <|/ a tags=c#,string |>\n<| a dscore=0 |>\nI implemented the solution by using\
    \ a dictionary to store the vowel count.\n<code>\nvar vowelCount = new Dictionary<char,\
    \ int>();\nstring vowel = \"aeiou\";\nfor (int i = 0; i < word2.Length; i++)\n\
    {\n    if (vowel.Contains(word2[i]))\n    {\n        int count = vowelCount[word2[i]];\n\
    \        vowelCount[word2[i]] = count + 1;\n    }\n}\n</code>\nAnd then I used\
    \ this to find the vowel closest to the right position in the string:\n<code>\n\
    string closestVowel = \"\";", "{\n    if (is_empty(word)) return \"\";\n    int\
    \ vowelStart = 0;\n    int vowelEnd = 0;\n    int vowels = 0;\n    for (int i\
    \ = 0; i <= word.size(); i++)\n    {\n        if (isVowel(word[i]))\n        {\n\
    \            vowels++;\n            if (vowels == 1) vowelStart = i;\n       \
    \     else if (vowels == 2) vowelEnd = i;\n        }\n    }\n    int vowelMiddle\
    \ = (vowelStart + vowelEnd) / 2;\n    if (vowels == 0) return \"\";\n    return\
    \ word[vowelMiddle];\n}", "{\n  if(word == \"\")\n  {\n    return \"\";\n  }\n\
    \  \n  if(isupper(word[0]))\n  {\n    return \"\";\n  }\n  \n  int start = 0;\n\
    \  int end = 0;\n  int closest_vowel_index = 0;\n  int vowel_start_index = 0;\n\
    \  int vowel_end_index = 0;\n  int vowel_distance = 0;\n  \n  int lower_letter_count\
    \ = 0;\n  int upper_letter_count = 0;\n  \n  int consonant_start_index = -1;\n\
    \  int consonant_end_index = -1;\n  int consonant_distance = -1;\n  \n  bool vowel_found\
    \ = false;\n  bool is_vowel_end_found = false;\n  bool is_vowel_start_found =\
    \ false;\n  \n  for(int i = 1; i < word.length(); i++)\n  {\n    if(word[i] ==\
    \ 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U'\
    \ || word[i] == 'Y' || word[i] == 'a')\n    {\n      is_vowel_end_found = true;\n\
    \      is_vowel_start_found = true;\n    }\n    \n    if(word[i] == 'B' || word[i]\
    \ == 'F' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' || word[i] == 'Y'\
    \ || word[i] == 'b')\n    {\n      is_vowel_end_found = true;\n      is_vowel_start_found\
    \ = true;\n    }\n    \n    if(word[i] == 'C' || word[i] == 'G' || word[i] ==\
    \ 'J' || word[i] == 'O' || word[i] == 'U' || word[i] == 'Y' || word[i] == 'c')\n\
    \    {\n      is_vowel_end_found = true;\n      is_vowel_start_found = true;\n\
    \    }\n    \n    if(word[i] == 'D' || word[i] == 'H' || word[i] == 'K' || word[i]\
    \ == 'O' || word[i] == 'U' || word[i] == 'Y' || word[i] == 'd')\n    {\n     \
    \ is_vowel_end_found = true;\n      is_vowel_start_found = true;\n    }\n    \n\
    \    if(word[i] == 'E' || word[i] == 'J' || word[i] == 'N' || word[i] == 'R' ||\
    \ word[i] == 'T' || word[i] == 'y' || word[i] == 'e')\n    {\n      is_vowel_end_found\
    \ = true;\n      is_vowel_start_found = true;\n    }\n    \n    if(word[i] ==\
    \ 'F' || word[i] == 'M' || word[i] == 'O' || word[i] == 'U' || word[i] == 'Y'\
    \ || word[i] == 'f')\n    {\n      is_vowel_end_found = true;\n      is_vowel_start_found\
    \ = true;\n    }\n    \n    if(word[i] == 'G' || word[i] == 'P' || word[i] ==\
    \ 'R' || word[i] == 'T' || word[i] == 'y", "{\n    if (word.empty())\n       \
    \ return \"\";\n    \n    auto first = word[0];\n    auto last = word[word.size()\
    \ - 1];", "{\n    int c=0;\n    int d=0;\n    int temp=0;\n    for (int i=word.length()-1;i>=0;i--)\n\
    \    {\n        c = word[i];\n        if (c=='a' || c=='e' || c=='i' || c=='o'\
    \ || c=='u' || c=='A' || c=='E' || c=='I' || c=='O' || c=='U')\n        {\n  \
    \          d++;\n        }\n    }\n    for (int i=word.length()-1;i>=0;i--)\n\
    \    {\n        temp = d;\n        d = c;\n        c = temp;\n    }\n    string\
    \ word2 = \"\";\n    if (d==0 || c==0)\n    {\n        return word2;\n    }\n\
    \    else\n    {\n        return word;\n    }\n}\n</code>\n<|/ a dscore=2 tags=string,python\
    \ |>\n<| c |>\nWelcome to Stack Overflow! While this code may solve the question,\
    \ [including an explanation](//meta.stackexchange.com/q/114762) of how and why\
    \ this solves the problem would really help to improve the quality of your post,\
    \ and probably result in more up-votes. Remember that you are answering the question\
    \ for readers in the future, not just the person asking now. Please [edit] your\
    \ answer to add explanations and give an indication of what limitations and assumptions\
    \ apply.\n<|/ c |>\n<| c |>\nHow about vowels inside the word?\n<|/ c |>\n<| c\
    \ |>\nthanks for the suggestion. now I added an explanation.\n<|/ c |>\n<| a tags=string,python\
    \ |>\nHere is my solution\n<code>\ndef get_closest_vowel(s):\n    vowels = 'aeiouAEIOU'\n\
    \    \n    if s[0] in vowels and s[-1] in vowels:\n        return ''\n    else:\n\
    \        for i in range(len(s)):\n            if s[i] in vowels:\n           \
    \     j = i\n                j += len(vowels)\n                while j != 0 and\
    \ s[j-1] not in vowels:\n                    j -= 1\n                if j != 0:\n\
    \                    return s[i:j].lower()\n    return ''\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=0 |>\nThis solution returns True if there is any vowel in the\
    \ string and False otherwise:\n<code>\ndef has_vowels(word):\n    for letter in\
    \ word:\n        if letter in 'aeiouAEIOU':\n            return True\n    return\
    \ False\n</code>\n<|/ a tags=string,python |>\n<| c |>\nWhile this code may solve\
    \ the question, [including an explanation](//meta.stackexchange.com/q/114762)\
    \ of how and why this solves the problem would really help to improve the quality\
    \ of your post, and probably ", "{\n    int vowelIndex = 0;\n    int conIndex\
    \ = 0;", "{\n\tint  index1 = word.length() - 1;\n\tint  index2 = 0;\n\t\n\twhile\
    \ ((index1 < 0) || (index2 < 0)) \n\t{\n\t\tif (index1 > index2)\n\t\t{\n\t\t\t\
    index1 = word.length();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tindex2 = 0;\n\t\t}\n\t\
    }\n\t\n\tstring letter1 = word.substr(index1, 1);\n\tstring letter2 = word.substr(index2,\
    \ 1);\n\t\n\tchar  letter1Char = std.toupper(letter1);\n\tchar  letter2Char =\
    \ std.toupper(letter2);\n\t\n\tchar  vowel1 = std.toupper(\"a\");\n\tchar  vowel2\
    \ = std.toupper(\"e\");\n\tchar  vowel3 = std.toupper(\"i\");\n\tchar  vowel4\
    \ = std.toupper(\"o\");\n\tchar  vowel5 = std.toupper(\"u\");\n\t\n\tbool isVowel1\
    \ = ((letter1Char >= 'A') && (letter1Char <= 'E'));\n\tbool isVowel2 = ((letter2Char\
    \ >= 'A') && (letter2Char <= 'E'));\n\tbool isVowel3 = ((letter1Char >= 'A') &&\
    \ (letter1Char <= 'I'));\n\tbool isVowel4 = ((letter2Char >= 'A') && (letter2Char\
    \ <= 'I'));\n\tbool isVowel5 = ((letter1Char >= 'A') && (letter1Char <= 'O'));\n\
    \tbool isVowel6 = ((letter2Char >= 'A') && (letter2Char <= 'O'));\n\tbool isVowel7\
    \ = ((letter1Char >= 'A') && (letter1Char <= 'U'));\n\tbool isVowel8 = ((letter2Char\
    \ >= 'A') && (letter2Char <= 'U'));\n\t\n\tif (isVowel1)\n\t{\n\t\tif (isVowel2)\n\
    \t\t{\n\t\t\tif (isVowel3)\n\t\t\t{\n\t\t\t\tif (isVowel4)\n\t\t\t\t{\n\t\t\t\t\
    \tif (isVowel5)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isVowel6)\n\t\t\t\t\t\t{\n\t\t\t\
    \t\t\t\tif (isVowel7)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (isVowel8)\n\t\t\t\t\
    \t\t\t\t{\n\t\t\t\t\t\t\t\t\tindex1 -= 1;\n\t\t\t\t\t\t\t\t\tindex2 -= 1;\n\t\t\
    \t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\
    {\n\t\t\t\t\t\t\t\t\tindex1 -= 1;\n\t\t\t\t\t\t\t\t\tindex2 -= 1;\n\t\t\t\t\t\t\
    \t\t\tindex2 ", "{\n    int len = word.length();\n    if (len<2) return \"\";\n\
    \    string result = \"\";\n    int last_vowel = -1;\n    bool is_vowel = false;\n\
    \    for (int i=0; i<len; i++) {\n        char ch = word.at(i);\n        bool\
    \ is_prev_vowel = i!=0;\n        bool is_last_vowel = i==len - 1;\n        bool\
    \ is_prev_prev_vowel = false;\n        bool is_last_prev_vowel = false;\n    \
    \    if (i==0) {\n            is_vowel = is_consonant(ch);\n        }\n      \
    \  else if (is_vowel) {\n            if (is_consonant(ch) && ch!=word.at(i - 1))\
    \ {\n                int last_ch = word.at(i - 1);\n                if (is_vowel(last_ch))\
    \ {\n                    is_prev_prev_vowel = true;\n                }\n     \
    \           else if (is_vowel(ch)) {\n                    is_last_prev_vowel =\
    \ true;\n                }\n            }\n        }\n        if (is_vowel) {\n\
    \            if (is_last_vowel) {\n                if (last_vowel==-1) {\n   \
    \                 last_vowel = i;\n                }\n                else {\n\
    \                    int last_last_vowel = word.at(i - 2);\n                 \
    \   if (is_vowel(last_last_vowel)) {\n                        is_last_prev_vowel\
    \ = true;\n                    }\n                    else if (is_vowel(last_ch))\
    \ {\n                        is_last_prev_vowel = true;\n                    }\n\
    \                }\n            }\n        }\n        if (is_last_vowel && last_vowel!=-1)\
    \ {\n            if (is_last_prev_vowel) {\n                if (is_vowel(word.at(last_vowel-1)))\
    \ {\n                    is_prev_vowel = true;\n                }\n          \
    \      else if (is_vowel(word.at(last_vowel))) {\n                    is_prev_vowel\
    \ = true;\n                }\n                else if (is_vowel(word.at(last_vowel+1)))\
    \ {\n                    is_prev_vowel = true;\n                }\n          \
    \  }\n            if (is_prev_vowel) {\n                if (is_vowel(word.at(last_vowel-1)))\
    \ {\n                    is_last_vowel = true;\n                }\n          \
    \      else if (is_vowel(word.at(last_vowel))) {\n                    is_last_vowel\
    \ = true;\n                }\n                else if (is_vowel(word.at(last_vowel+1)))\
    \ {\n                    is_last_vowel = true;\n                }\n          \
    \  }\n        }\n    }\n    \n    if (is_vowel && last_vowel!=-1) {\n        if\
    \ (last_vowel+2<len && is_vowel(word.at(last_vowel+2))) {\n            result\
    \ = word.at(last_vowel+1);\n        }\n    }\n    \n    return result;\n}", "{\n\
    \    int vowel_count = 0;\n    bool found_vowel = false;", "{\n    int index =\
    \ get_index(word);\n    string vowels = \"aeiouAEIOU\";\n    if(index == -1) return\
    \ \"\";\n    string result = vowels[(index % vowels.length)];\n    if(result ==\
    \ \"a\" || result == \"e\" || result == \"i\" || result == \"o\" || result ==\
    \ \"u\") return result;\n    int count = word.length();\n    while(count > index){\n\
    \        count -= 2;\n        index -= 2;\n    }\n    if(count == 0){\n      \
    \  int count = 0;\n        while(word[count] != word.front()){\n            ++count;\n\
    \        }\n        string vowel1 = get_closest_vowel(word.substr(count));\n \
    \       string vowel2 = get_closest_vowel(word.substr(count+1));\n        if(vowel1\
    \ != \"\" && vowel2 != \"\") return get_vowels(vowel1, vowel2);\n    }\n    return\
    \ \"\";\n}", "{\n\tint i;\n\tint cons_start = word.length() - 1;\n\tint cons_end\
    \ = word.length();\n\tbool flag = false;\n\tstring result = \"\";\n\t\n\tfor (int\
    \ i = 0; i <= cons_end; i++)\n\t{\n\t\tif (isupper(word.at(i)))\n\t\t{\n\t\t\t\
    if (flag)\n\t\t\t{\n\t\t\t\tif (islower(word.at(i)))\n\t\t\t\t{\n\t\t\t\t\tcons_end\
    \ = i;\n\t\t\t\t\tcons_start = cons_end - 1;\n\t\t\t\t\tflag = false;\n\t\t\t\t\
    \tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (islower(word.at(i)))\n\
    \t\t\t\t{\n\t\t\t\t\tcons_end = i;\n\t\t\t\t\tcons_start = cons_end - 1;\n\t\t\
    \t\t\tflag = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\
    \t\t{\n\t\t\tif (islower(word.at(i)))\n\t\t\t{\n\t\t\t\tcons_end = i;\n\t\t\t\t\
    cons_start = cons_end - 1;\n\t\t\t\tflag = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\
    \t\t}\n\t\tbreak;\n\t}\n\t\n\tif (cons_start >= 0 && cons_end <= cons_start)\n\
    \t{\n\t\tfor (i = cons_start; i <= cons_end; i++)\n\t\t{\n\t\t\tif (islower(word.at(i)))\n\
    \t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (isupper(word.at(i)))\n\
    \t\t\t\t{\n\t\t\t\t\tresult = toupper(word.at(i));\n\t\t\t\t\tbreak;\n\t\t\t\t\
    }\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}\n/*\nYou are given a string and\
    \ a number. The task is to rearrange the characters of the \n    string to the\
    \ given number. The characters of the string must be separated by \n    spaces.\
    \ \n    \n    Return the string with all spaces replaced by specified character.\n\
    \    \n    You cannot use any built-in functions. You can only use the library\
    \ functions \n    like std.string.printf, std.string.len and std.string.at. ",
  "{\n\tif (word.empty())\n\t\treturn \"\";\n\tint first = std.find(word, \"\"); //\
    \ first consonant index\n\tint last = std.find(word, word[std.size(word)-1]);\
    \ // last consonant index\n\tif (first < 0 || last < 0 || first > last)\n\t\t\
    return \"\";\n\tint middle = first;\n\tint count = 0;\n\twhile(middle != last)\
    \ {\n\t\tmiddle++;\n\t\tstring letter = std.substr(word, 0, middle);\n\t\tstring\
    \ vowels = std.lower(\"aeiou\");\n\t\tif (vowels.find(letter) != string::npos)\n\
    \t\t\tcount++;\n\t\tif (count > 1)\n\t\t\tbreak;\n\t}\n\tif (count == 0)\n\t\t\
    return \"\";\n\tstring consonants = std.lower(\"bcdfghjklmnpqrstvwxyz\");\n\t\
    bool vowel = false;\n\twhile(middle != last) {\n\t\tmiddle++;\n\t\tstring letter\
    \ = std.substr(word, 0, middle);\n\t\tif (consonants.find(letter) != string::npos)\
    \ {\n\t\t\tvowel = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (vowel)\n\t\treturn \"\
    u\";\n\treturn \"\";\n}\n/*\nYou are given a string containing only digits. Return\
    \ it if it is valid \n    number representation of integer number system (from\
    \ 1 to 2147483647)\n    otherwise return an empty string. \n    \n    You may\
    \ assume that the given string contains only digits (0-9).", "{\n\tint  i=0;\n\
    \tint  j=0;\n\tint  k=0;\n\tint  l=0;\n\tint  count=0;\n\tint  consonant_count=0;\n\
    \tchar vowels[32];\n\tchar consonants[32];\n\tstring vowel_string;\n\tstring consonant_string;\n\
    \t\n\tfor(int x=0;x<word.length();x++)\n\t{\n\t\tconsonant_count=0;\n\t\twhile(word[x]\
    \ == consonants[consonant_count])\n\t\t{\n\t\t\tconsonant_count++;\n\t\t}\n\t\t\
    consonant_count--;\n\t\tconsonant_string.push_back(word[x]);\n\t\t\n\t\tfor(int\
    \ y=consonant_count+1;y<consonants.length;y++)\n\t\t{\n\t\t\tcount=0;\n\t\t\t\
    while(word[x] == consonants[y])\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\ty--;\n\t\t\
    \t}\n\t\t\tcount--;\n\t\t\tvowels[vowel_count]=word[x];\n\t\t\tvowel_count++;\n\
    \t\t\tvowel_string.push_back(vowels[count]);\n\t\t\ti++;\n\t\t}\n\t\tj++;\n\t\
    }\n\tk=0;\n\twhile(j<word.length())\n\t{\n\t\tk=0;\n\t\twhile(j<word.length()\
    \ && k<word.length()-1 && word[k]==word[k+1] && consonant_count>0)\n\t\t{\n\t\t\
    \tk++;\n\t\t\tconsonant_count--;\n\t\t}\n\t\tj++;\n\t\tcount++;\n\t\twhile(j<word.length()\
    \ && word[k]==consonants[count])\n\t\t{\n\t\t\tcount++;\n\t\t\tk++;\n\t\t}\n\t\
    \tconsonant_string.push_back(word[k]);\n\t\tconsonant_string.push_back(vowels[count]);\n\
    \t\tk++;\n\t\tvowel_count++;\n\t\ti++;\n\t}\n\tif(j==word.length())\n\t\treturn\
    \ \"\";\n\treturn string(vowel_string);\n}", "{\n    if(word.length() <= 1) return\
    \ \"\";\n    int endIndex = word.length() - 1;\n    for(int i = 0; i < endIndex;\
    \ i++){\n        char c = word[i];\n        if(is_vowel(c)){\n            int\
    \ startIndex = i;\n            int prevVowelIndex = i - 1;\n            bool found\
    \ = false;\n            for(int j = i; j > 0; j--){\n                char prevChar\
    \ = word[j-1];\n                if(prevChar == c){\n                    if(found){\n\
    \                        int maxIndex = j;\n                        break;\n \
    \                   }\n                    found = true;\n                   \
    \ prevVowelIndex = j;\n                }\n            }\n            if(found){\n\
    \                string prevWord = word.substr(prevVowelIndex+1, word.length());\n\
    \                string nextWord = word.substr(startIndex+1, word.length());\n\
    \                string nextPrevWord = word.substr(prevVowelIndex+1, word.length());\n\
    \                if(is_vowel(nextPrevWord.back())){\n                    string\
    \ finalString = prevWord.substr(0, prevWord.size()-1);\n                    return\
    \ finalString;\n                } else if(is_vowel(nextWord.back())){\n      \
    \              string finalString = prevWord.substr(0, prevWord.size()-1);\n \
    \                   return finalString;\n                }\n            }\n  \
    \      }\n    }\n    return \"\";\n}\n</code>\n<|/ a tags=c++,string,substring\
    \ |>\n<| a dscore=0 |>\nThis is my solution to find the closest vowel in the right\
    \ side\n<code>\nstring getClosestVowel(string word){\n    int index = 0, size\
    \ = word.length(), lastVowelIndex = 0, lastVowel = '\\0';\n    for(int i = 0;\
    \ i < size; i++){\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i]\
    \ == 'I' || word[i] == 'O' || word[i] == 'U'){\n            if(lastVowel == '\\\
    0') lastVowel = word[i];\n        }\n        else if (word[i] == 'A' || word[i]\
    \ == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U'){\n           \
    \ lastVowel = word[i];\n            lastVowelIndex = i;\n        }\n    }\n  \
    \  if (lastVowel == '\\0') return \"\";\n    for(int i = lastVowelIndex + 1; i\
    \ < size; i++){\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i]\
    \ == 'I' || word[i]", "{\n  int index = word.length() - 1;\n  string res;\n  char\
    \ c = word[index];\n  while(index >= 0) {\n    c = word[index];\n    \n    if(c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n      return res;\n\
    \    index--;\n  }\n  return res;\n}", "{\n    string vowel = \"AEIOUaeiou\";\n\
    \    int start = 0;\n    int end = 0;\n    int length = 0;\n    for (int i = 0;\
    \ i < word.length(); i++) {\n        if (vowel.find(word.at(i)) == 0) start =\
    \ i;\n        else if (vowel.find(word.at(i)) == 0) end = i;\n    }\n    for (int\
    \ i = word.size(); i >= 0; i--) {\n        if (vowel.find(word.at(i)) == 0) length\
    \ = i;\n    }\n    if (end == start) return word.at(end);\n    int d = (end -\
    \ start) % length + 1;\n    return word.at(d - 1);\n}", "{\n    map<string,string>\
    \ vMap;\n    map<string,string> cMap;\n    map<string,string> vCMap;", "{\n  \
    \  int len = word.length();\n    int i = 0;\n    int j = 0;\n    string vowels[]\
    \ = {\"A\",\"E\",\"I\",\"O\",\"U\"};\n    \n    while(i < len && j<vowels.length){\n\
    \        if(word.charAt(i) == vowels[j]){\n            j++;\n        }\n     \
    \   if(j == vowels.length){\n            return word.charAt(i);\n        }\n \
    \       i++;\n    }\n    return \"\";\n}\n/*\nYou are given a word. Your task\
    \ is to find the closest vowel that stands between \n    two consonants from the\
    \ left side of the word (case sensitive).\n    \n    Vowels in the beginning and\
    \ ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. ", "{\n    auto length = word.length();\n    int start\
    \ = 0;\n    int end = length - 1;", "{\n    map<string, pair<int, int>> mymap;\n\
    \    for(int i=word.length()-2; i>=0; --i)\n    {\n        for(int j=i+1; j<word.length()-1;\
    \ ++j)\n        {\n            string sub=word.substr(i, j);\n            if(!isVowel(sub[0])\
    \ && !isVowel(sub[sub.length()-1]))\n                mymap.insert(sub, make_pair(distance(sub),\
    \ i));\n        }\n    }\n    map<string, pair<int, int>>::iterator itr=mymap.begin();\n\
    \    if(!itr->first.empty())\n        return itr->first.front();\n    return \"\
    \";\n}\n</code>\n<|/ a dscore=2 tags=c++,algorithm |>\n<| c |>\nThe code doesn't\
    \ work if the string has consecutive vowels, e.g. \"apple\"\n<|/ c |>\n<| c |>\n\
    , I wrote a python version, you can take a look at it.\n<|/ c |>\n<| a dscore=1\
    \ tags=c++,algorithm |>\nThis can be done in O(n) time using dynamic programming.\
    \ \nThe pseudo-code would be:", "{\n    int i, j, len = word.length();\n    char\
    \ first, last;\n    string vowels = \"AEIOUaeiou\";\n    string vowels_set = to_set(vowels);\n\
    \    string result = \"\";\n    \n    for(i = len-1; i >= 0; --i)\n    {\n   \
    \     first = word[i];\n        last  = word[i-1];\n        if(vowels_set.find(first)\
    \ == vowels_set.find(last))\n        {\n            result = first;\n        \
    \    break;\n        }\n    }\n    return result;\n}", "{\n    char a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z;\n\
    \    for(int i = 0; i < word.length(); i++)\n    {\n        a = word[i];\n   \
    \     if(isupper(a))\n            A = a;\n        if(islower(a))\n           \
    \ A = a;\n    }\n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n    \
    \    b = word[i];\n        if(isupper(b))\n            B = b;\n        if(islower(b))\n\
    \            B = b;\n    }\n    for(int i = word.length() - 1; i >= 0; i--)\n\
    \    {\n        c = word[i];\n        if(isupper(c))\n            C = c; \n  \
    \      if(islower(c))\n            C = c; \n    }\n    for(int i = word.length()\
    \ - 1; i >= 0; i--)\n    {\n        d = word[i];\n        if(isupper(d))\n   \
    \         D = d; \n        if(islower(d))\n            D = d; \n    }\n    for(int\
    \ i = word.length() - 1; i >= 0; i--)\n    {\n        e = word[i];\n        if(isupper(e))\n\
    \            E = d; \n        if(islower(e))\n            E = d; \n    }\n   \
    \ for(int i = word.length() - 1; i >= 0; i--)\n    {\n        f = word[i];\n \
    \       if(isupper(f))\n            F = d; \n        if(islower(f))\n        \
    \    F = d; \n    }\n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n\
    \        g = word[i];\n        if(isupper(g))\n            G = d; \n        if(islower(g))\n\
    \            G = d; \n    }\n    for(int i = word.length() - 1; i >= 0; i--)\n\
    \    {\n        h = word[i];\n        if(isupper(h))\n            H = d; \n  \
    \      if(islower(h))\n            H = d; \n    }\n    for(int i = word.length()\
    \ - 1; i >= 0; i--)\n    {\n        i = word[i];\n        if(isupper(i))\n   \
    \         I = d; \n        if(islower(i))\n            I = d; \n    }\n    for(int\
    \ i = word.length() - 1; i >= 0; i--)\n    {\n        j = word[i];\n        if(isupper(j))\n\
    \            J = d; \n        if(islower(j))\n            J = d; \n    }\n   \
    \ for(int i = word.length() - 1; i >= 0; ", "{\n    stack<pair<int, char>> vowels;\n\
    \    for(auto c: word)\n    {\n        if(std.string::isLetter(c))\n        {\n\
    \            vowels.push(make_pair(std.math::abs(c-'a'), c));\n        }\n   \
    \ }\n    auto current = vowels.top();\n    vowels.pop();\n    for(auto c: word)\n\
    \    {\n        if(std.string::isLetter(c))\n        {\n            if(current\
    \ > make_pair(std.math::abs(c-'a'), c))\n            {\n                vowels.push(make_pair(std.math::abs(c-'a'),\
    \ c));\n            }\n        }\n    }\n    return vowels.top().second;\n}",
  "{\n   for (int i=word.length()-1; i>0; i--) \n   { \n      for (int j=0; j<26;\
    \ j++) \n      { \n         if ( word[i]=='a' || word[i]=='e' || word[i]=='i'\
    \ || word[i]=='o' || word[i]=='u' ) \n         { \n            string vowel=char(j+'a');\
    \ \n            int index=vowel.find_last_of(\"AEIOUaeiou\");\n            return\
    \ word.substr(index+1,1);\n         } \n      } \n   } \n   string vowel=char(97+'a');\
    \ \n   int index=vowel.find_last_of(\"AEIOUaeiou\");\n   return word.substr(index+1,1);\
    \ \n}\n</code>\n<|/ a dscore=0 tags=string,c++ |>\n<| a tags=string,c++ |>\nTry\
    \ this one:\n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\
    #include <cctype>\nusing namespace std;", "{\n    if (word.length() <= 1) \n \
    \       return \"\";\n    auto it = word.rbegin();\n    bool is_vowel = false;\n\
    \    while(!is_vowel && it != word.rend()){\n        is_vowel = is_vowel\n   \
    \                || (it->islower()\n                       && to_lower(*it) ==\
    \ to_lower(*it.rbegin()));\n        it++;\n    }\n    if (is_vowel)\n        return\
    \ to_lower(*it);\n    else\n        return \"\";\n}", "{\n    int length = word.length();\n\
    \    int firstConsonantPosition = length - 1;\n    int firstVowelPosition = length\
    \ - 1;\n    int lastVowelPosition = length - 1;\n    int secondConsonantPosition\
    \ = length - 1;\n    int secondVowelPosition = length - 1;", "{\n    int firstConsonant\
    \ = word.find_first_not_of(\"aeiou\");\n    int lastConsonant = word.find_last_not_of(\"\
    aeiou\");\n    int min = 0;\n    int max = word.length() - 1;\n    int middleConsonant;\n\
    \    bool foundVowel = false;", "{\n    if( !isalpha(word) )\n        return \"\
    \";\n    char lastChar = word[word.size()-1];\n    \n    vector<char> vowels;\n\
    \    \n    for( int i = word.size()-2; i>=0; i-- ) {\n        if(isalpha(word[i])\
    \ && isalpha(word[i+1])) {\n            vowels.push_back(word[i]);\n        }\n\
    \    }\n    \n    vector<char>::iterator it = find(vowels.begin(), vowels.end(),\
    \ lastChar);\n    \n    if( it == vowels.end() )\n        return \"\";\n    \n\
    \    char currChar = word[word.size()-1];\n    \n    if( !isalpha(currChar) )\n\
    \        return \"\";\n    \n    for( ; it!=vowels.end(); ++it )\n    {\n    \
    \    if( currChar == *it )\n            break;\n    }\n    \n    if( it==vowels.end()\
    \ )\n        return \"\";\n    \n    string vowel = *it;\n    \n    return vowel;\n\
    }", "{\n    return \"\";\n}", "{\n    string vowels = \"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\"\
    ;\n    int i;\n    int j;\n    int counter;\n    int result;\n    \n    for(i\
    \ =0, j= word.length() - 1; i < word.length(); i++, j--)\n    {\n        if(word[i]\
    \ != word[j])\n        {\n            counter = 0;\n            \n           \
    \ if(word[i] == 'a' || word[i] == 'A')\n            {\n                counter++;\n\
    \            }\n            if(word[j] == 'a' || word[j] == 'A')\n           \
    \ {\n                counter++;\n            }\n            \n            if(counter\
    \ == 0)\n            {\n                result = word[i];\n            }\n   \
    \     }\n    }\n    \n    return result == \"\" ? \"\" : result;\n}", "{\n   \
    \ for(int i=word.length-1; i>=0; i--)\n    {\n        bool found = false;\n  \
    \      string firstConsonant = \"\";\n        string secondConsonant = \"\";\n\
    \        for(int j=i; j<word.length; j++)\n        {\n            if(word[j] ==\
    \ 'a')\n            {\n                firstConsonant = word[j];\n           \
    \     break;\n            }\n            if(word[j] == 'e')\n            {\n \
    \               firstConsonant = word[j];\n                break;\n          \
    \  }\n            if(word[j] == 'i')\n            {\n                firstConsonant\
    \ = word[j];\n                break;\n            }\n            if(word[j] ==\
    \ 'o')\n            {\n                firstConsonant = word[j];\n           \
    \     break;\n            }\n            if(word[j] == 'u')\n            {\n \
    \               firstConsonant = word[j];\n                break;\n          \
    \  }\n            if(word[j] == 'A')\n            {\n                firstConsonant\
    \ = word[j];\n                break;\n            }\n            if(word[j] ==\
    \ 'E')\n            {\n                firstConsonant = word[j];\n           \
    \     break;\n            }\n            if(word[j] == 'I')\n            {\n \
    \               firstConsonant = word[j];\n                break;\n          \
    \  }\n            if(word[j] == 'O')\n            {\n                firstConsonant\
    \ = word[j];\n                break;\n            }\n            if(word[j] ==\
    \ 'U')\n            {\n                firstConsonant = word[j];\n           \
    \     break;\n            }\n        }\n        for(int k=i; k<word.length-1;\
    \ k++)\n        {\n            if(word[k] == 'a')\n            {\n           \
    \     secondConsonant = word[k];\n                break;\n            }\n    \
    \        if(word[k] == 'e')\n            {\n                secondConsonant =\
    \ word[k];\n                break;\n            }\n            if(word[k] == 'i')\n\
    \            {\n                secondConsonant = word[k];\n                break;\n\
    \            }\n            if(word[k] == 'o')\n            {\n              \
    \  secondConsonant = word[k];\n                break;\n            }\n       \
    \     if(word[k] == 'u')\n            {\n                secondConsonant = word[k];\n\
    \                break;\n            }\n            if(word[k] == 'A')\n     \
    \       {\n                secondConsonant = word[k];\n                break;\n\
    \            }\n            if(word[k] == 'E')\n            {\n              \
    \  secondConsonant = word[k];\n                break;\n            }\n       \
    \     if(word[k] == 'I')\n            {\n                secondConsonant = word[k];\n\
    \                break;\n            }\n            if(word[k] == 'O')\n     \
    \       {\n                secondConsonant = word[k];\n                break;\n\
    \            }\n            if(word[k]", "{\n    auto itr = word.rbegin();\n \
    \   auto end_itr = word.rend();\n    while(end_itr != word.rbegin() && itr !=\
    \ word.rend()) \n    {\n        // if the current char is not a consonant\n  \
    \      if(!is_consonant(*itr)) return \"\";\n        // if the current char is\
    \ a vowel and we are not at the last char of the word \n        if(is_vowel(*itr)\
    \ && !itr == word.rend() )\n        {\n            // get the current vowel char\
    \ and compare with next char \n            auto vowel = *itr;\n            itr++;\n\
    \            if(itr == word.rend()) return vowel;\n            if(itr != word.rend()\
    \ && !is_vowel(*itr)) \n            {\n                // if next char is a vowel\
    \ then return current vowel\n                return vowel;\n            }\n  \
    \      }\n        itr++;\n    }\n    return \"\";\n}", "{\n    return \"\";\n\
    \    \n}", "{\n    if (word.length() <= 1) return \"\";", "{\n    vector<char>\
    \ vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"a\", \"e\", \"i\", \"\
    o\", \"u\", \"y\"};\n    \n    int i = 0;\n    int j = 0;\n    string result =\
    \ \"\";\n    \n    for(i = word.size()-1; i>=0; i--)\n    {\n        if(vowels.find(word[i])\
    \ != end(vowels))\n        {\n            int j = 0;\n            int pos = 0;\n\
    \            while((pos != word.size()-1) && (word[pos] != word[i]))\n       \
    \     {\n                j++;\n                pos++;\n            }\n       \
    \     if(j == 2)\n            {\n                result = word[i];\n         \
    \   }\n        }\n    }\n    \n    return result;\n}", "{\n    map<string, int>\
    \ vowelCount;\n    for(int i = 0; i < word.length(); i++)\n    {\n        if(isVowel(word[i]))\n\
    \        {\n            string vowel = word[i];\n            vowelCount[vowel]\
    \ += 1;\n        }\n    }", "{\n    for(int i=word.length()-1;i>=0;i--)\n    {\n\
    \        auto ch = word[i];\n        if(islower(ch)) \n        {\n           \
    \ if(ch=='a'||ch=='e'||ch=='i'||ch=='o'||ch=='u')\n            {\n           \
    \     if(word[i-1]==ch||word[i-1]=='A'||word[i-1]=='E'||word[i-1]=='I'||word[i-1]=='O'||word[i-1]=='U')\n\
    \                    return ch;\n            }\n        }\n    }\n    return \"\
    \";\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,algorithm dscore=0 |>\nHere\
    \ is a java implementation:\n<code>\npublic static void main(String[] args) {\n\
    \    String word = \"quick\";\n    System.out.println(findClosestVowel(word));\n\
    }", "{\n    if(word.length < 2)\n    {\n        return \"\";\n    }\n    for(auto\
    \ c : word)\n    {\n        auto c1 = consonants[tolower(c)];\n        auto c2\
    \ = consonants[tolower(c1)];\n        if(c2 > c1)\n        {\n            auto\
    \ c3 = consonants[tolower(c2)];\n            if(c3 > c2)\n            {\n    \
    \            return c;\n            }\n            else\n            {\n     \
    \           return c3;\n            }\n        }\n        else\n        {\n  \
    \          return c1;\n        }\n    }\n    return \"\";\n}\n</code>\n<|/ a dscore=0\
    \ tags=c++,string,algorithm |>\n<| c |>\nThanks for the answer. I did a quick\
    \ test and it seems to work only if the first and last letters of the given string\
    \ are vowels (the loop never ends). If the first and last letters are consonants,\
    \ it seems like your code does not work, because the algorithm does not find the\
    \ closest consonant. For example: \"a\" does not return anything since it can't\
    \ have a vowel on the left or right side of the string.\n<|/ c |>\n<| c |>\nMy\
    \ answer solves the problem you specified in your question _\"find the closest\
    \ vowel that stands between two consonants from the right side of the word\"_\
    \ . The code checks whether there is any vowel on the left and right side of the\
    \ string. If there is none, `get_closest_vowel` returns an empty string. Check\
    \ my updated answer, please.\n<|/ c |>\n<| c |>\nThank you. I've updated the original\
    \ question with your code.\n<|/ c |>\n<| a tags=c++,string,algorithm dscore=0\
    \ |>\nTry this.\n<code>\n#include <iostream>\nusing namespace std;", "{\n    \
    \ auto c = word.back();\n     auto n = word.size() - 1;\n     while (n >= 0)\n\
    \     {\n         if (std.string(\"aeiouAEIOU\").contains(word.sub(n, 1)))\n \
    \        {\n             break;\n         }\n         n--;\n     }\n     auto\
    \ i = n;\n     while (i >= 0)\n     {\n         if (std.string(\"aeiouAEIOU\"\
    ).contains(word.sub(i, 1)))\n         {\n             break;\n         }\n   \
    \      i--;\n     }\n     if (i > n)\n     {\n         return \"\";\n     }\n\
    \     string res = \"\";\n     while (n >= 0)\n     {\n         auto j = i;\n\
    \         auto k = n;\n         while (j >= 0 && k >= 0)\n         {\n       \
    \      if (word[j] == word[k])\n             {\n                 if (std.string(\"\
    aeiouAEIOU\").contains(word.sub(n, 1)))\n                 {\n                \
    \     res += word[j];\n                     break;\n                 }\n     \
    \            else\n                 {\n                     res += word[j];\n\
    \                     n -= 1;\n                     break;\n                 }\n\
    \             }\n             else\n             {\n                 j--;\n  \
    \               k--;\n             }\n         }\n         if (j >= 0)\n     \
    \    {\n             n--;\n             break;\n         }\n         if (k >=\
    \ 0)\n         {\n             i--;\n             break;\n         }\n     }\n\
    \     return res;\n}", "{\n    int start = 0;\n    int end = 0;", "{\n    unordered_set<char>\
    \ vowels;\n    vowels.add('a');\n    vowels.add('e');\n    vowels.add('i');\n\
    \    vowels.add('o');\n    vowels.add('u');\n    vowels.add('y');\n    vowels.add('\xE6\
    ');\n    vowels.add('\xF8');\n    \n    auto cbegin = word.find_last_of(',');\n\
    \    auto cend = word.find_first_of('.');\n    \n    if(cbegin == string::npos\
    \ || cend == string::npos)\n    {\n        return \"\";\n    }\n    \n    string\
    \ consonants = word.cbegin() + (cend - cbegin);\n    \n    for(auto i = consonants.cend()-1;\
    \ i >= consonants.cbegin(); i--)\n    {\n        auto c = *i;\n        if(vowels.find(c)\
    \ == vowels.cbegin())\n        {\n            return c;\n        }\n    }\n  \
    \  \n    return \"\";\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for the\
    \ case of the word \"yogurt\", which should return \"u\"\n<|/ c |>\n<| c |>\n\
    I actually just updated it. This should work now.\n<|/ c |>\n<| c |>\nI see you\
    \ added the update to your answer, but it is still incorrect, because \"yogurt\"\
    \ should be returning \"u\" not \"y\". I was able to fix this after adding a break\
    \ in the if statement that checks if cbegin and cend are both equal to string::npos.\
    \ Thanks for the help though\n<|/ c |>\n<| c |>\nYeah I didn't test it for that\
    \ case, I will do that next time\n<|/ c |>\n<| a dscore=0 |>\nYou can easily do\
    \ this using Regex. Here is an example where I print the first match and the second\
    \ match on the console:\n<code>\nstring word = \"yogurt\";\nstring pattern = \"\
    ^[aeiouy]+[aeiouy]*[aeiouy]+$\";\nstd::regex regex(pattern);\nauto match = std::sregex_iterator(word.begin(),\
    \ word.end(), regex);\nauto end = std::sregex_iterator();\nstd::cout << std::distance(word.begin(),\
    \ match) << \" matches of \" << pattern << std::endl;\nstd::cout << *match <<\
    \ \" match in position \" << match.offset() << \" of \" << word << std::endl;\n\
    std::cout << std::distance(word.begin(), end) << \" matches of \" << pattern <<\
    \ std::endl;\nstd::cout << *end << \" match in position \" << end.offset() <<\
    \ \" of \" << word << std::endl;\n</code>", "{\n    int left=0,right=0;\n    map<char,int>\
    \ vowels;\n    map<char,int> consonants={};\n    for(int i=0;i<word.length();i++){\n\
    \        if(word[i]!='U')\n            consonants[tolower(word[i])]++;\n    }\n\
    \    for(auto it=consonants.begin();it!=consonants.end();it++){\n        left=it->first;\n\
    \        right=it->second;\n        if(left<right)\n            break;\n    }\n\
    \    \n    while(word[right]!='U')\n        right++;\n    right--;\n    \n   \
    \ while(left<right){\n        if(isalpha(word[left]))\n            vowels[tolower(word[left])]++;\n\
    \        left++;\n    }\n    \n    left--;\n    \n    while(left<right){\n   \
    \     if(isalpha(word[right]))\n            vowels[tolower(word[right])]++;\n\
    \        right--;\n    }\n    \n    left--;\n    right++;\n    \n    for(auto\
    \ it=vowels.begin();it!=vowels.end();it++)\n        if(it->second<2)\n       \
    \     return it->first;\n    return \"\";\n}\n</code>\n<|/ a |>\n<| c |>\nHi,\
    \ thanks for your solution. I think it is very clever and elegant. How would it\
    \ be if one wanted to return the `consonants` in the same order? For example,\
    \ if I used `get_closest_vowel(\"ab\")`, it would return `[d, g]`.\n<|/ c |>\n\
    <| c |>\nThanks for the hint. I edited the answer\n<|/ c |>\n<| a tags=algorithm,c++\
    \ |>\n<code>\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing\
    \ namespace std;\nstring getClosestVowel(string word) {\n    int left,right,count=0,flag=0;\n\
    \    int len=word.length();\n    vector<int> cons(len);\n    for(char a:word){\n\
    \        if(isalpha(a)){\n            cons[count]=a;\n            count++;\n \
    \       }\n    }\n    left=right=0;\n    for(int i=0;i<word.length();i++){\n \
    \       if(isalpha(word[i])){\n            if(left<right)\n                flag=1;\n\
    \            left++;\n        }\n        else if(isalpha(word[word.length()-1])){\n\
    \            right--;\n        }\n    }\n    if(left<right){\n        int j=0;\n\
    \        for(int i=left;", "{\n    string vowels = \"aeiou\";\n    string result\
    \ = \"\";\n    int startPos = 0;\n    int endPos = word.length() - 1;\n    while\
    \ (startPos < endPos)\n    {\n        int curPos = startPos;\n        while ((curPos\
    \ > -1) && (curPos < endPos))\n        {\n            if (word[curPos] in vowels)\n\
    \            {\n                if (curPos != startPos)\n                {\n \
    \                   int nextVowPos = curPos - 1;\n                    while (nextVowPos\
    \ < 0)\n                    {\n                        if (word[nextVowPos] in\
    \ vowels)\n                        {\n                            break;\n   \
    \                     }\n                        nextVowPos++;\n             \
    \       }\n                    if (nextVowPos < 0)\n                    {\n  \
    \                      nextVowPos = 0;\n                    }\n              \
    \      int nextVowPos2 = curPos + 1;\n                    while (nextVowPos2 <\
    \ endPos)\n                    {\n                        if (word[nextVowPos2]\
    \ in vowels)\n                        {\n                            break;\n\
    \                        }\n                        nextVowPos2++;\n         \
    \           }\n                    if (nextVowPos2 < endPos)\n               \
    \     {\n                        nextVowPos2 = endPos;\n                    }\n\
    \                    if (nextVowPos < nextVowPos2)\n                    {\n  \
    \                      int vowelIndex = nextVowPos;\n                        while\
    \ (vowelIndex < nextVowPos2)\n                        {\n                    \
    \        if (word[vowelIndex] != \"i\")\n                            {\n     \
    \                           break;\n                            }\n          \
    \                  vowelIndex++;\n                        }\n                \
    \        if (vowelIndex < nextVowPos2)\n                        {\n          \
    \                  vowelIndex = nextVowPos2;\n                        }\n    \
    \                    if (vowelIndex == nextVowPos)\n                        {\n\
    \                            vowelIndex--;\n                        }\n      \
    \                  if (vowelIndex == 0)\n                        {\n         \
    \                   vowelIndex++;\n                        }\n               \
    \         result = word[vowelIndex];\n                        break;\n       \
    \             }\n                }\n                else if (curPos == startPos)\n\
    \                {\n                    int vowelIndex = curPos - 1;\n       \
    \             while (vowelIndex < curPos)\n                    {\n           \
    \             if (word[vowelIndex] != \"i\")\n                        {\n    \
    \                        break;\n                        }\n                 \
    \       vowelIndex++;\n                    }\n                    if (vowelIndex\
    \ < curPos)\n                    {\n                        vowelIndex = curPos;\n\
    \                    }\n                    if (vowelIndex == curPos)\n      \
    \              {\n                        vowelIndex++;\n                    }\n\
    \                    result = word[vowelIndex];\n                    break;\n\
    \                }\n            }\n            curPos--;\n        }\n        startPos++;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=2 tags=c++,string |>\n<|\
    \ a dscore=1 |>\nA solution using two ", "{\n    int i, j, k, l, n, m, t;\n  \
    \  int nn = word.length();\n    int v = 0;\n    for (i = nn-1; i >= 0; i--)\n\
    \    {\n        for (j=i; j<nn; j++)\n        {\n            if (islower(word[j]))\n\
    \            {\n                break;\n            }\n        }\n        if (j\
    \ > i)\n        {\n            if (word.substr(i, j) == \"a\" || word.substr(i,\
    \ j) == \"e\" || word.substr(i, j) == \"i\" || word.substr(i, j) == \"o\" || word.substr(i,\
    \ j) == \"u\" || word.substr(i, j) == \"y\" || word.substr(i, j) == \"o\" || word.substr(i,\
    \ j) == \"i\" || word.substr(i, j) == \"u\")\n            {\n                v\
    \ = j;\n                break;\n            }\n        }\n    }\n    if (v ==\
    \ 0)\n    {\n        return \"\";\n    }\n    else \n    {\n        int c = 0;\n\
    \        for (n=v; n<nn; n++)\n        {\n            for (m=v; m<nn; m++)\n \
    \           {\n                if (islower(word[n]) && islower(word[m]))\n   \
    \             {\n                    if (c == 0)\n                    {\n    \
    \                    break;\n                    }\n                    else\n\
    \                    {\n                        c++;\n                    }\n\
    \                }\n            }\n        }\n        if (n > v)\n        {\n\
    \            t = n - 1;\n        }\n        else if (n < v)\n        {\n     \
    \       t = n + 1;\n        }\n        else\n        {\n            t = 0;\n \
    \       }\n        int a = word[v];\n        for (l=v; l<nn; l++)\n        {\n\
    \            if (islower(word[l]))\n            {\n                break;\n  \
    \          }\n        }\n        int b = word[t];\n        if (a == 'A')\n   \
    \     {\n            if (b == 'Z')\n            {\n                return \"A\"\
    ;\n            }\n            else\n            {\n                return \"a\"\
    ;\n            }\n        }\n        else if (a == 'E')\n        {\n         \
    \   if (b == 'Z')\n            {\n                return \"e\";\n            }\n\
    \            else\n            {\n                return \"e\";\n            }\n\
    \        }\n        else if (a == 'I')\n        {\n            if (b == 'Z')\n\
    \            {\n                return \"i\";\n            }\n            else\n\
    \            {\n                return \"i\";\n            }\n        }\n    \
    \    else if (a == 'O')\n        {\n            if (b == 'Z')\n            {\n\
    \                return \"o\";\n            }\n            else\n            {\n\
    \                return \"o\";\n            }\n        }\n        else if (a ==\
    \ 'U')\n        {\n            if (b == 'Z')\n            {\n                return\
    \ \"u\";\n            }\n            else\n            {\n                return\
    \ \"u\";\n            }\n        }\n        else if (a == 'Y')\n        {\n  \
    \          if (b == 'Z')\n            {\n                return \"y\";", "{\n\
    \    int i, j;\n    int nVowels = 8;\n    int nVowels_start = 3;\n    int nVowels_end\
    \ = 6;\n    string vowels;\n    string ans;", "{\n    if(word.length() < 1)\n\
    \        return \"\";\n    map<string, string> vowels = {{\"a\",\"e\"},{\"i\"\
    ,\"o\"},{\"u\",\"i\"}};\n    for(int i = word.length()-1; i > 0; i--)\n    {\n\
    \        string temp = word.substr(i-1, 1);\n        if(vowels.count(temp) > 0)\n\
    \            return temp;\n    }\n    return \"\";\n}\n</code>\n<|/ a tags=c++,string,algorithm,char,data-structures\
    \ dscore=1 |>\n<| c |>\nThank you for the explanation. I understand the logic.\
    \ One question, why did you return the substring that has `i`? Why not `i-1`?\n\
    <|/ c |>\n<| c |>\nBecause if i at position 1 (\"yogurt\") then temp.substr(0,1)\
    \ will be \"y\", but in \"yogurt\" only \"y\" is present and not \"u\" as in the\
    \ input example.\n<|/ c |>\n<| a |>\nYou just need to search for the letter you're\
    \ looking for, subtract one, and use that as the index:\n<code>", "{\n\tif(word.length<=0)\n\
    \t\treturn \"\";\n\tauto result=word;\n\tfor(int i=word.length()-1;i>0;i--)\n\t\
    {\n\t\tif(isVowel(word[i]))\n\t\t{\n\t\t\tif(findClosestVowel(word,word[i],result,false)>0)\n\
    \t\t\t\tbreak;\n\t\t}\n\t}\n\tif(findClosestVowel(word,word[0],result,false)>=0)\n\
    \t\treturn result;\n\treturn \"\";\n}\n/*\nYou are given a word. Your task is\
    \ to find out all the vowels that exists in\n    the right side of the word. ",
  "{\n    if(word.length() <= 0)\n        return \"\";\n    if(word.length() >= 2)\n\
    \        return \"\";\n    \n    if(word.front()[0] != toupper(word.front()))\n\
    \        return \"\";\n    if(word.back()[0] != toupper(word.back()))\n      \
    \  return \"\";\n    \n    int vowelCount = 0;\n    int i = 0;\n    \n    for(;\
    \ i < word.length() - 1; ++i)\n    {\n        if(word.at(i) == word.at(i + 1))\n\
    \            ++vowelCount;\n    }\n    \n    if(vowelCount < 2)\n        return\
    \ \"\";\n    \n    vowelCount = 0;\n    \n    for(; i < word.length() - 1; ++i)\n\
    \    {\n        if(word.at(i) == word.at(i + 1))\n            ++vowelCount;\n\
    \    }\n    \n    if(vowelCount >= 2)\n        return \"\";\n    \n    vowelCount\
    \ = 0;\n    \n    for(int i = word.length() - 2; i >= 0; --i)\n    {\n       \
    \ if(word.at(i) == word.at(i + 1))\n            ++vowelCount;\n    }\n    \n \
    \   if(vowelCount >= 2)\n        return \"\";\n    \n    if(word.length() == 2)\n\
    \        return \"u\";\n    \n    string vowel;\n    \n    for(int i = word.length()\
    \ - 2; i >= 0; --i)\n    {\n        if(word.at(i) == word.at(i + 1))\n       \
    \ {\n            string currentVowel = word.substr(word.at(i), 2);\n         \
    \   \n            if(vowel.empty())\n                vowel = currentVowel;\n \
    \           else\n            {\n                if(vowel != currentVowel)\n \
    \                   return \"\";\n            }\n        }\n    }\n    \n    return\
    \ vowel;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhy are you posting your answers\
    \ in the answer box?\n<|/ c |>\n<| c |>\nThis is not an answer to the question.\n\
    <|/ c |>\n<| c |>\nThis is an answer to the question. You are posting a code without\
    \ even showing him where he is having problem.\n<|/ c |>\n<| c |>\nThis is what\
    \ I am posting as a comment. It is up to the OP to decide whether he should post\
    \ the code or put it in his question. I gave him a hint about where to look because\
    \ he did not know how he should look.\n<|/ c |>\n<| c |>\nI don't understand how\
    \ this helps anyone at all. There is no explanation of what was wrong with his\
    \ code (other than that he's not asking a question).\n<|/ c |>\n<| a |>\n<code>\n\
    #include <iostream>\n#include <string>", "{\n    unordered_set<char> vowels;\n\
    \    \n    for (auto c: word) {\n        vowels.insert(c);\n    }\n    \n    auto\
    \ start = word.length();\n    auto end = word.length() - 1;\n    \n    auto result\
    \ = \"\";\n    \n    while (start >= 0 && end < word.length() && vowels.count(word[start])\
    \ > 0 && vowels.count(word[end]) > 0) {\n        if (word[start] == 'a' || word[start]\
    \ == 'e' || word[start] == 'i' || word[start] == 'o' || word[start] == 'u') {\n\
    \            if (word[end] == 'a' || word[end] == 'e' || word[end] == 'i' || word[end]\
    \ == 'o' || word[end] == 'u') {\n                result = word[start];\n     \
    \       }\n            else {\n                result = \"\";\n            }\n\
    \        }\n        start --;\n        end ++;\n    }\n    \n    return result\
    \ + \"V\";\n}", "{\n  int left = 0;\n  int right = word.length() - 1;\n  int mid\
    \ = (left + right)/2;", "{\n    string vowels = \"a\xE1\xE0\xE3\xE2\xE4\xE9\xE8\
    \xEA\xEB\xED\xEC\xEE\xEF\xF3\xF2\xF5\xF4\xF6\xFA\xF9\xFB\xFC\xFD\xFF\xC1\xC0\xC3\
    \xC2\xC4\xC9\xC8\xCA\xCB\xCD\xCC\xCE\xCF\xD3\xD2\xD5\xD6\xD4\xD9\xDA\xDB\xDC\xDD\
    \".toLower();\n    int length = word.length();\n    int start = 0, end = length;\n\
    \    \n    while(start < end) {\n        if(word[start] in vowels) {\n       \
    \     if(start >= 0) {\n                if(word[start-1] in vowels) {\n      \
    \              end = start;\n                } else if(word[start+1] in vowels)\
    \ {\n                    start = start+1;\n                } else {\n        \
    \            end = start+1;\n                    start++;\n                }\n\
    \            } else {\n                if(word[start+1] in vowels) {\n       \
    \             end = start;\n                    start++;\n                } else\
    \ {\n                    end = start+1;\n                    start++;\n      \
    \          }\n            }\n        } else {\n            if(word[end-1] in vowels)\
    \ {\n                if(end <= length-1) {\n                    if(word[end] in\
    \ vowels) {\n                        start = end;\n                    } else\
    \ if(word[end+1] in vowels) {\n                        end = end+1;\n        \
    \            } else {\n                        start = end+1;\n              \
    \          end++;\n                    }\n                } else {\n         \
    \           start = end+1;\n                    end++;\n                }\n  \
    \          } else {\n                if(word[end] in vowels) {\n             \
    \       if(end <= length-1) {\n                        if(word[end] in vowels)\
    \ {\n                            end = length;\n                        } else\
    \ if(word[end+1] in vowels) {\n                            end = end+1;\n    \
    \                    } else {\n                            end = length;\n   \
    \                         end++;\n                        }\n                \
    \    } else {\n                        end = length;\n                       \
    \ end++;\n                    }\n                } else {\n                  \
    \  if(word[start-1] in vowels) {\n                        start = start-1;\n \
    \                   } else if(word[start+1] in vowels) {\n                   \
    \     start = start+1;\n                    } else {\n                       \
    \ start = start+1;\n                        start++;\n                    }\n\
    \                    end++;\n                }\n            }\n        }\n   \
    \ }\n    if(word[start-1] in vowels) {\n        if(start >= 0) {\n           \
    \ if(word[start-1] in vowels) {\n                end = start;\n            } else\
    \ if(word[start+1] in vowels) {\n                start = start+1;\n          \
    \  } else {\n                end = start+1;\n                start++;\n      \
    \      }\n        } else {\n            if(word[start+1] in vowels) {\n      \
    \          end = start;\n                start++;\n            } else {\n    \
    \            end = start+1;\n                start++;\n            }\n       \
    \ }\n    } else {\n        if(word[end-1] in vowels) {\n            if(", "{\n\
    \    // Write your code here\n    map<char, pair<int, int>> mapChar;\n    for(int\
    \ i=word.length()-1; i>=0; i--) {\n        char c = word[i];\n        if(isupper(c))\
    \ {\n            mapChar[c] = make_pair(0,0);\n        } else if (islower(c))\
    \ {\n            mapChar[c] = make_pair(0,1);\n        } else {\n            pair<int,\
    \ int> pos = mapChar[toupper(c)];\n            if(pos.second >= 0 && pos.second\
    \ < word.size()) {\n                int pos2 = mapChar[toupper(word[pos.second])].second;\n\
    \                if(pos2 >= 0 && pos2 < word.size()) {\n                    return\
    \ word[pos.second-1];\n                }\n            }\n        }\n    }\n  \
    \  return \"\";\n}\n</code>\n<|/ a tags=c++,string,algorithm |>\n<| a dscore=1\
    \ |>\n<code>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include\
    \ <cctype>\nusing namespace std;", "{\n    int left=0,right=0;\n    int index=0;\n\
    \    string vowels=\"aeiou\";\n    int size=word.length();\n    while(left<size)\n\
    \    {\n        right=left+1;\n        while(right<size && word.at(right)!=word.at(left))\
    \ \n            right++;\n        if(word.at(right)==word.at(left))\n        {\n\
    \            for(index=0; index<5; index++)\n                if(vowels[index]==word.at(right))\n\
    \                    return word.at(left);\n        }\n        else\n        \
    \    left=right;\n    }\n    return \"\";\n}\n</code>\n<|/ a tags=c++,string,stdstring\
    \ dscore=1 |>\n<| c |>\nPlease note that this only works with letters in `abcdefghijklmnopqrstuvwxyz`\n\
    <|/ c |>\n<| a tags=c++,string,stdstring |>\n<code>\n#include <iostream>\n#include\
    \ <string>\nusing namespace std;", "{\n    int c = 0;\n    int v = std.string.count(\"\
    a\",\"e\",\"i\",\"o\",\"u\");\n    int b = std.string.count(word);\n    for(int\
    \ i = b-1; i >= v; i--) {\n        if(word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u') {\n            c++;\n          \
    \  if(c == 2) {\n                return word[i];\n            }\n        }\n \
    \   }\n    return \"\";\n}", "{\n    string s = \"\";\n    int pos = 0;\n    int\
    \ vowelCount = 0;\n    \n    while(pos < word.length)\n    {\n        if(isVowel(word[pos]))\
    \ \n        {\n            vowelCount++;\n        }\n        if(vowelCount > 1)\n\
    \        {\n            if(word[pos+1] == word[pos])\n            {\n        \
    \        pos = word.length-1;\n                s = word[pos];\n            }\n\
    \            break;\n        }\n        pos++;\n    }\n    return s;\n}\n/*\n\
    You are given two strings, s1 and s2, both are of length N. \n    Find a substring\
    \ s3 of s2 that is a palindrome, \n    such that all characters in s3 are in s1\
    \ and in \n    the middle of the given substring, no other characters are in s1.\
    \ \n    \n    You can assume both strings consist of only English letters.\n \
    \   \n    Example: \n    >>> s1 = \"hello\"\n    >>> s2 = \"olll\"\n    >>> s3\
    \ = \"hello\"\n    >>> palindrome(s1, s2)\n    >>> palindrome(s1, s3)\n    \n\
    \    \n    \n    Note: \n    >>> palindrome(\"ab\", \"a\")\n    True\n    >>>\
    \ palindrome(\"ab\", \"b\")\n    False\n    >>> palindrome(\"ab\", \"ab\")\n \
    \   True\n    >>> palindrome(\"abc\", \"bca\")\n    False\n    \n*/", "{\n   \
    \ // your code goes here\n    string result=\"\";\n    for(int i=word.length-1;i>=1;i--)\n\
    \    {\n        if(word[i]==\"a\"||word[i]==\"e\"||word[i]==\"i\"||word[i]==\"\
    o\"||word[i]==\"u\")\n        {\n            if(word[i-1]==\"o\"||word[i-1]==\"\
    u\"||word[i-1]==\"A\"||word[i-1]==\"E\"||word[i-1]==\"I\"||word[i-1]==\"O\"||word[i-1]==\"\
    U\")\n            {\n                if(word[i+1]==\"o\"||word[i+1]==\"u\"||word[i+1]==\"\
    A\"||word[i+1]==\"E\"||word[i+1]==\"I\"||word[i+1]==\"O\"||word[i+1]==\"U\")\n\
    \                {\n                    result=word[i];\n                    break;\n\
    \                }\n            }\n        }\n    }\n    \n    if(result.length()==0)\n\
    \    {\n        result=\"\";\n    }\n    \n    return result;\n}\n</code>\n<|/\
    \ a dscore=0 tags=string,c++ |>\n<| c |>\nI see you used the code from here [link](http://www.cplusplus.com/forum/beginner/62485/)\
    \ but I don't understand how it works with the `word[i+1]` part. Could you please\
    \ explain that? If it goes till `word[i]` then how will it know to stop when it\
    \ gets to the first letter of `word[i+1]`?\n<|/ c |>\n<| a tags=string,c++ |>\n\
    You can use recursion :\n<code>\n#include <string>\n#include <iostream>\nusing\
    \ namespace std;", "{\n\tif (word.length <= 1) \n\t{\n\t\treturn \"\";\n\t}",
  "{\n    int len = word.size;\n    string vowels = \"aeiou\";\n    int min_len =\
    \ 1;\n    int i;\n    for(i = 1; i < len; i++)\n    {\n        int j = len - i;\n\
    \        if(word[j] == 'u' || word[j] == 'E' || word[j] == 'I' || word[j] == 'O')\n\
    \        {\n            int cons_cnt = 0;\n            int cnt = 0;\n        \
    \    int curr_cons = word[j];\n            int cons_idx = j;\n            while(j\
    \ > 0)\n            {\n                cons_cnt++;\n                if(word[j\
    \ - 1] == curr_cons)\n                {\n                    cnt++;\n        \
    \        }\n                j--;\n            }\n            if(cnt < cons_cnt)\n\
    \            {\n                min_len = cons_cnt - cnt;\n                cons_idx\
    \ = cons_cnt - 1;\n                curr_cons = word[cons_idx];\n            }\n\
    \        }\n    }\n    return cons(word, min_len, 'a').s;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ dscore=0 |>\n<| c |>\nSorry, I meant to say you need a method to find the vowel\
    \ between two consonants.\n<|/ c |>\n<| c |>\nIt finds the closest vowel, but\
    \ there is some problem. If the word is \"full\", it returns \"u\", not \"u\"\
    . Because it returns the closest vowel that is right between \"f\" and \"a\".\n\
    <|/ c |>\n<| c |>\nAh I see. Edited my answer, please check\n<|/ c |>\n<| c |>\n\
    Thank you! It works fine! But i have a problem. When the input is \"ab\", it returns\
    \ \"\"(empty string). But it suppose to return \"\" as well. How can i fix this?\n\
    <|/ c |>\n<| c |>\nIn that case, you should change `if(min_len > cons_cnt)` to\
    \ `if(min_len < cons_cnt)`. See my edited answer.\n<|/ c |>\n<| a |>\nThis code\
    \ will find the first vowel starting from index 0 to length -1\n<code>\nstd::string\
    \ get_vowel(std::string word)\n{\n    std::string vowels = \"aeiou\";\n    std::string\
    \ firstVowel = \"\";\n    for(int i=0;i<word.length();i++)\n    {\n        if(vowels.find(word[i])!=std::string::npos)\n\
    \        {\n            firstVowel = word[i];\n            break;\n        }\n\
    \    }\n    return firstVowel;\n}\n</code>\n<|/ a tags=string,c++,algorithm dscore=0 ",
  "{\n    int[] indices = {0, 1, 2, 3, 5};\n    for(int i=0; i<=word.size()-1; i++)\n\
    \    {\n        int n = word[i];\n        for(int j=0; j<indices.length; j++)\n\
    \        {\n            if(word.compare(i, indices[j], 1, indices[j+1]) == 0)\n\
    \            {\n                break;\n            }\n        }\n        if(j\
    \ == indices.length)\n        {\n            indices.push_back(i+1);\n       \
    \ }\n    }\n    indices.reverse();\n    for(int i=0; i<indices.length; i++)\n\
    \    {\n        if(word.compare(indices[i], indices[indices.length-1], 1, indices[indices.length-1])\
    \ == 0)\n        {\n            return word[i];\n        }\n    }\n    return\
    \ \"\";\n}\n</code>\n<|/ a tags=string,c,c++ |>\n<| c |>\nthis should be the accepted\
    \ answer, as it is the most elegant and performant solution\n<|/ c |>\n<| a |>\n\
    I came up with the following in C (sorry my answer is not as efficient as it could\
    \ be):\n<code>\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>", "{\n\
    \     string vowels = \"aeiouAEIOU\";\n     int left = 0;\n     int right = word.lenght-1;\n\
    \     int leftRight = word.length-1;\n     while(left < right){\n         if(word[left].isalpha()\
    \ && word[leftRight].isalpha()){\n         if(vowels.find(word[left]) != string::npos\
    \ && vowels.find(word[leftRight]) != string::npos){\n             return word[left];\n\
    \         }\n         }\n         left++;\n         right--;\n         leftRight--;\n\
    \     }\n     return \"\";\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is O(n^2),\
    \ and not O(n) in the best case. An example is \"pita\" - it returns \"i\" instead\
    \ of \"u\"\n<|/ c |>\n<| c |>\nYou forgot to mention the case that there is no\
    \ vowel in the word. Return empty string.\n<|/ c |>\n<| c |>\n`get_closest_vowel(\"\
    pita\");` returns `\"i\"` which is correct, right?\n<|/ c |>\n<| c |>\nIt returns\
    \ an empty string because you did not mention that case. I do not think your answer\
    \ is O(n) at all.\n<|/ c |>\n<| a |>\nI thought that my answer is O(N) but actually\
    \ its O(N^2), so I made this O(N).\nIt uses two pointers instead of one, also\
    \ it checks the last letter before the first letter to determine whether it should\
    \ be treated as consonant. \n<code>\n string get_closest_vowel(string word)\n\
    {\n    string vowels = \"aeiouAEIOU\";\n    string tmp;\n    bool lastLetterConsonant=false;\n\
    \    int firstLetterConsonant=false;\n    int i=0;\n    while(i<word.length())\n\
    \    {\n        if(vowels.find(word[i])==string::npos)\n        {\n          \
    \  if(!firstLetterConsonant)\n            {\n                firstLetterConsonant=i;\n\
    \            }\n            tmp=word[i];\n            word[i]=\"\";\n        \
    \    word[firstLetterConsonant]=tmp;\n        }\n        else if(!lastLetterConsonant)\n\
    \        {\n            lastLetterConsonant=i;\n        }\n        else\n    \
    \    {\n            if(word[i]==word[firstLetterConsonant])\n            {\n \
    \               word[i]=\"\";\n                word[lastLetterConsonant]=word[lastLetterConsonant+1];\n\
    \            }\n            ", "{\n    char vowels[] = {'A','E','I','O','U'};\n\
    \    for(auto it = std::find(word.begin(), word.end(), 'e'); it != word.end();\
    \ ++it)\n    {\n        if (std::find(vowels, vowels + sizeof(vowels), 'e') !=\
    \ vowels + sizeof(vowels))\n        {\n            return *it;\n        }\n  \
    \  }\n    for(auto it = std::find(word.begin(), word.end(), 'i'); it != word.end();\
    \ ++it)\n    {\n        if (std::find(vowels, vowels + sizeof(vowels), 'i') !=\
    \ vowels + sizeof(vowels))\n        {\n            return *it;\n        }\n  \
    \  }\n    for(auto it = std::find(word.begin(), word.end(), 'o'); it != word.end();\
    \ ++it)\n    {\n        if (std::find(vowels, vowels + sizeof(vowels), 'o') !=\
    \ vowels + sizeof(vowels))\n        {\n            return *it;\n        }\n  \
    \  }\n    for(auto it = std::find(word.begin(), word.end(), 'u'); it != word.end();\
    \ ++it)\n    {\n        if (std::find(vowels, vowels + sizeof(vowels), 'u') !=\
    \ vowels + sizeof(vowels))\n        {\n            return *it;\n        }\n  \
    \  }\n    return \"\"s;\n}", "{\n\tstack<string> vowels;\n\tfor (int i = 0; i\
    \ < (int)word.size(); i++)\n\t{\n\t\tif (is_vowel(word[i]))\n\t\t{\n\t\t\tvowels.push(word[i]);\n\
    \t\t}\n\t}", "{\n    auto vowels = new[] {'a', 'e', 'i', 'o', 'u'};\n    auto\
    \ vowels_size = vowels.GetLength();\n    auto iter = word.size() - vowels_size;\n\
    \    \n    for (auto &i : vowels)\n    {\n        if (iter < 0)\n        {\n \
    \           return \"\";\n        }\n        \n        if (word[iter] == i)\n\
    \        {\n            iter--;\n            break;\n        }\n        \n   \
    \     iter--;\n    }\n    \n    return word.substr(iter);\n}", "{\n    if(!is_english(word))\
    \ \n        return \"\";\n    for(int i = word.length()-2; i>0; i--) \n    {\n\
    \        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' || word[i] == 'y') \n        {\n            string tmp = word;\n\
    \            tmp.pop_back();\n            return tmp;\n        }\n        if(word[i]\
    \ == 'y' && word[i-1] == 'a' && word[i+1] == 'a') \n        {\n            string\
    \ tmp = word;\n            tmp.pop_back();\n            tmp.pop_back();\n    \
    \        return tmp;\n        }\n    }\n    for(int i = 0; i<word.length(); i++)\n\
    \    {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' || word[i] == 'y')\n        {\n            string tmp\
    \ = word;\n            tmp.pop_back();\n            return tmp;\n        }\n \
    \       if(word[i] == 'y' && word[i-1] == 'a' && word[i+1] == 'a')\n        {\n\
    \            string tmp = word;\n            tmp.pop_back();\n            tmp.pop_back();\n\
    \            return tmp;\n        }\n    }\n    return \"\";\n}", "{\n    map<char,\
    \ int> vowel_map;\n    \n    for(auto v : {'a', 'e', 'i', 'o', 'u'})\n       \
    \ vowel_map[v] = 0;\n    \n    for(auto c : word)\n    {\n        if(!isalpha(c))\n\
    \            continue;\n        \n        vowel_map['a'] += vowel_map['A'] + 1;\n\
    \        vowel_map['e'] += vowel_map['E'] + 1;\n        vowel_map['i'] += vowel_map['I']\
    \ + 1;\n        vowel_map['o'] += vowel_map['O'] + 1;\n        vowel_map['u']\
    \ += vowel_map['U'] + 1;\n    }\n    \n    auto max = [&vowel_map] (auto left,\
    \ auto right) -> int \n    { \n        return std::max(left.second, right.second);\
    \ \n    };\n    auto min = [&vowel_map] (auto left, auto right) -> int \n    {\
    \ \n        return std::min(left.second, right.second); \n    };\n    \n    auto\
    \ consonants_count = count(word.begin(), word.end(), 'k') + 1;\n    auto vowels_count\
    \ = vowel_map.size();\n    \n    if(vowels_count < 2)\n    {\n        return \"\
    \";\n    }\n    \n    auto min = vowel_map.begin();\n    auto max = vowel_map.end();\n\
    \    \n    return find(max, min, max)->first;\n}", "{\n    int start = 0;\n  \
    \  int end = word.length()-1;\n    char firstLetter = word[0];\n    char secondLetter\
    \ = word[end];\n    while(end > start)\n    {\n        if(firstLetter == secondLetter)\n\
    \        {\n            if (start==0 && end==word.length()-1)\n            {\n\
    \                cout << \"No vowel in the begining and ending\" << endl;\n  \
    \              return \"\"; \n            }\n            else if (start == 0 &&\
    \ end == word.length()-1)\n            {\n                return firstLetter;\n\
    \            }\n            else\n            {\n                return secondLetter;\n\
    \            }\n        }\n        else if (firstLetter == secondLetter && firstLetter\
    \ != word[end])\n        {\n            end = end - 1;\n            secondLetter\
    \ = word[end];\n        }\n        else if (firstLetter == secondLetter && firstLetter\
    \ == word[end])\n        {\n            start = start + 1;\n            secondLetter\
    \ = word[end];\n        }\n        else\n        {\n            end--;\n     \
    \   }\n    }\n    return \"\";\n}", "{\n    return word[1 + word.rfind(_consonants,\
    \ 0, word.size()) - 1] + _vowels[word.rfind(_consonants, 0, word.size()) - 1];\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThanks for your response. Your program looks good,\
    \ but what about the time complexity? Does it have O(N) complexity?\n<|/ c |>\n\
    <| c |>\nI haven't analysed the time complexity of string processing, but i think\
    \ it is O(N). Because string processing is linear operation in time complexity.\
    \ Also note that i am using string as array (character array) in C++, so it also\
    \ has linear operations. Hence O(N).\n<|/ c |>\n<| c |>\n`std::find_if` is also\
    \ linear complexity (http://en.cppreference.com/w/cpp/algorithm/find). `std::find`\
    \ can be implemented using [linear search](http://en.wikipedia.org/wiki/Linear_search).\
    \ Thus O(N).\n<|/ c |>\n<| c |>\nThanks Jay! I'll check the time complexity\n\
    <|/ c |>\n<| a tags=string,algorithm,c++,c,python |>\nHere's a non-recursive solution\
    \ in C++:\n<code>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n\
    #include <string>\nusing namespace std;", "{\n\tif(word.length<2)\n\t\treturn\
    \ \"\";\n\t\n\tint left=0,right=word.length()-1,found=0,cnt=0,res=\"\";\n\tstring\
    \ vowels=\"aeiouAEIOU\";\n\t\n\twhile(left<right)\n\t{\n\t\tint mid=int(left+right)/2;\n\
    \t\tstring substr=word.substr(mid,1);\n\t\t\n\t\tif(vowels.find(substr))\n\t\t\
    {\n\t\t\tif(substr==word[mid])\n\t\t\t{\n\t\t\t\tfound=1;\n\t\t\t\tbreak;\n\t\t\
    \t}\n\t\t}\n\t\t\n\t\t\n\t\tif(substr==\"a\")\n\t\t{\n\t\t\tif(found==1)\n\t\t\
    \t\tbreak;\n\t\t\tleft+=1;\n\t\t}\n\t\telse if(substr==\"e\")\n\t\t{\n\t\t\tif(found==1)\n\
    \t\t\t\tbreak;\n\t\t\tleft+=1;\n\t\t}\n\t\telse if(substr==\"i\")\n\t\t{\n\t\t\
    \tif(found==1)\n\t\t\t\tbreak;\n\t\t\tleft+=1;\n\t\t}\n\t\telse if(substr==\"\
    o\")\n\t\t{\n\t\t\tif(found==1)\n\t\t\t\tbreak;\n\t\t\tleft+=1;\n\t\t}\n\t\telse\
    \ if(substr==\"u\")\n\t\t{\n\t\t\tif(found==1)\n\t\t\t\tbreak;\n\t\t\tleft+=1;\n\
    \t\t}\n\t\t\n\t\telse if(substr==\"A\")\n\t\t{\n\t\t\tif(found==1)\n\t\t\t\tbreak;\n\
    \t\t\tright--;\n\t\t}\n\t\telse if(substr==\"E\")\n\t\t{\n\t\t\tif(found==1)\n\
    \t\t\t\tbreak;\n\t\t\tright--;\n\t\t}\n\t\telse if(substr==\"I\")\n\t\t{\n\t\t\
    \tif(found==1)\n\t\t\t\tbreak;\n\t\t\tright--;\n\t\t}\n\t\telse if(substr==\"\
    O\")\n\t\t{\n\t\t\tif(found==1)\n\t\t\t\tbreak;\n\t\t\tright--;\n\t\t}\n\t\telse\
    \ if(substr==\"U\")\n\t\t{\n\t\t\tif(found==1)\n\t\t\t\tbreak;\n\t\t\tright--;\n\
    \t\t}\n\t\t\n\t\t\n\t\tcnt++;\n\t}\n\t\n\tif(cnt>1)\n\t\treturn res;\n\t\n\tif(cnt==1)\n\
    \t{\n\t\tif(vowels.find(word[mid])!=0)\n\t\t\tres=word[mid];\n\t}\n\treturn res;\n\
    }", "{\n    map<string, string> vowels;\n    map<string, string> vowelsWithCase;\n\
    \    map<string, string> vowelsWithCaseWithCaps;\n    map<string, string> vowelsWithCaseWithCapsWithCase;\n\
    \    map<string, string> vowelsWithCaseWithCapsWithCaseAndLowerCase;", "{\n  \
    \  int n = 0;\n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n      \
    \  if(word[i] == 'u' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i]\
    \ == 'a')\n        {\n            n++;\n        }\n    }\n    \n    string ret\
    \ = \"\";\n    for(int i = word.length() - 1; i >= 0; i--)\n    {\n        if(word[i]\
    \ == 'u' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'a'\
    \ || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'a')\n \
    \       {\n            if(n > 0)\n            {\n                ret = \"\";\n\
    \                n = -1;\n            }\n            else\n            {\n   \
    \             ret = \"u\";\n                break;\n            }\n        }\n\
    \    }\n    \n    return ret;\n}", "{\n\tstring vowels = \"AEIOUaeiou\";\n\tint\
    \ start = 0;\n\tint end = word.size()-1;\n\tstring result = \"\";", "{\n    int\
    \ lower = std.algorithm.toLower(word);\n    int upper = std.algorithm.toUpper(word);\n\
    \    bool is_vowel = std.string.isLetter(lower) || std.string.isLetter(upper);",
  "{\n    int i = 0, end = word.length();\n    while (i < end && isVowel(word[i]))\n\
    \    {\n        i++;\n    }\n    int j = i - 1, k = 0;\n    while (j < end &&\
    \ isVowel(word[j]))\n    {\n        j--;\n    }\n    if (i < j)\n    {\n     \
    \   if (j != 0)\n        {\n            if (word[i] == word[j])\n            {\n\
    \                return word[i];\n            }\n        }\n        if (k == j)\n\
    \        {\n            return \"\";\n        }\n        else if (word[k] == word[j])\n\
    \        {\n            return word[k];\n        }\n    }\n    return \"\";\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis one worked for me. But how did you\
    \ write `isVowel`?\n<|/ c |>\n<| c |>\n: I didn't write it I only wrote the comments.\n\
    <|/ c |>\n<| c |>\nOkay, I got it, but what if I have to find all the vowels?\
    \ what changes should I make in the code?\n<|/ c |>\n<| c |>\n: Do you want the\
    \ whole vowel including preceding and following consonants or just the vowel itself?\n\
    <|/ c |>\n<| c |>\nI'm sorry for taking your time. I have to find the whole vowel\
    \ including preceding and following consonants.\n<|/ c |>\n<| a dscore=3 tags=algorithm,language-agnostic,string\
    \ |>\nThe naive approach would be to just go through all the characters looking\
    \ for consonants and then go through the string again, looking for vowels. Each\
    \ time you come across a consonant, you look for the next consonant from the end.\
    \ If that consonant is also a vowel, you add it to the output. \n<code>\ndef findVowel(str):\n\
    \    for i in range(len(str)):\n        if str[i] in consonants:\n           \
    \ for ii in range(i+1, len(str)):\n                if str[ii] in vowels:\n   \
    \                 return str[i] + str[ii]\n    return \"\"\n</code>\nThis isn't\
    \ very efficient though, and you would be better off using something like a bloom\
    \ filter, which would let you speed up the search by a factor of about 2x if you\
    \ were searching for multiple consonants and vowels at the same time.\n<|/ a |>\n\
    <| c |>\nAwesome. This was also my first thought but I was thinking there might\
    \ be a faster solution.\n<|/ c |>\n<| c |>\nYeah, a bloom filter is probably going\
    \ to be your best bet.\n<|/ c |>\n<| a dscore=", "{\n    // Write your code here.\n\
    \    for(int i=0; i<word.size()-1; i++){\n        if (std.cond(i) == 'c'){\n \
    \           int right_index = std.strlen(word);\n            for(int j=i+1; j<word.size();\
    \ j++){\n                if (std.cond(j) == 'c'){\n                    right_index\
    \ = j;\n                    break;\n                }\n            }\n       \
    \     int dist = std.strlen(std.substr(word, 0, i)) + std.strlen(std.substr(word,\
    \ right_index));\n            if(dist<0){\n                dist = -1;\n      \
    \      }\n            char vowel = std.substr(word, 0, i);\n            if (std.cond(vowel)\
    \ == 'a' || std.cond(vowel) == 'e' || std.cond(vowel) == 'i' || std.cond(vowel)\
    \ == 'o' || std.cond(vowel) == 'u'){\n                return std.cond(vowel);\n\
    \            }\n        }\n    }\n    return \"\";\n}", "{\n    typedef std.pair<int,\
    \ string> pair;\n    auto first = map ([](char c){ return std.make_pair(c,\"\"\
    ); }, word);\n    auto second = map ([](char c){ return std.make_pair(c,\"\");\
    \ }, word);\n    auto third_consonant = map ([](char c){ return std.make_pair(c,\"\
    \"); }, word);\n    auto fourth_consonant = map ([](char c){ return std.make_pair(c,\"\
    \"); }, word);\n    auto fifth_consonant = map ([](char c){ return std.make_pair(c,\"\
    \"); }, word);\n    auto sixth_consonant = map ([](char c){ return std.make_pair(c,\"\
    \"); }, word);", "{\n  int i,j;\n  int count1=0;\n  int count2=0;\n  int count3=0;\n\
    \  int count4=0;\n  int count5=0;\n  int count6=0;\n  string vowels[] = {\"a\"\
    ,\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"};\n  for(i=word.length()-1;i>=0;i--)\n\
    \  {\n    if(word[i]!=vowels[i])\n    {\n      count1=0;\n      count2=0;\n  \
    \    count3=0;\n      count4=0;\n      count5=0;\n      count6=0;\n      for(j=0;j<word.length();j++)\n\
    \      {\n        if(word[j]==vowels[i])\n        {\n          count1+=1;\n  \
    \      }\n        else if(word[j]==vowels[(j+1)%7])\n        {\n          count2+=1;\n\
    \        }\n        else if(word[j]==vowels[(j+2)%7])\n        {\n          count3+=1;\n\
    \        }\n        else if(word[j]==vowels[(j+3)%7])\n        {\n          count4+=1;\n\
    \        }\n        else if(word[j]==vowels[(j+4)%7])\n        {\n          count5+=1;\n\
    \        }\n        else if(word[j]==vowels[(j+5)%7])\n        {\n          count6+=1;\n\
    \        }\n      }\n      if(count1>=count2)\n      {\n        if(count1>=count3)\n\
    \        {\n          if(count1>=count4)\n          {\n            if(count1>=count5)\n\
    \            {\n              if(count1>=count6)\n              {\n          \
    \      return vowels[i];\n              }\n              else if(count5>count6)\n\
    \              {\n                return vowels[(j+4)%7];\n              }\n \
    \             else if(count4>count6)\n              {\n                return\
    \ vowels[(j+3)%7];\n              }\n              else if(count3>count6)\n  \
    \            {\n                return vowels[(j+2)%7];\n              }\n   \
    \           else if(count2>count6)\n              {\n                return vowels[(j+1)%7];\n\
    \              }\n              else if(count1>count6)\n              {\n    \
    \            return vowels[i];\n              }\n            }\n            else\
    \ if(count5>count6)\n            {\n              return vowels[(j+5)%7];\n  \
    \          }\n            else if(count4>count6)\n            {\n            \
    \  return vowels[(j+4)%7];\n            }\n            else if(count3>count6)\n\
    \            {\n              return vowels[(j+3)%7];\n            }\n       \
    \     else if(count2>count6)", "{\n  if(word == \"\" || word.length <= 1)\n  \
    \  return \"\";", "{\n\tfor (int i = word.length() - 1; i >= 0; --i) \n\t{\n\t\
    \tbool isVowel = true;", "{\n    int consonant=0;\n    int vowel=0;\n    int right_consonant=0;\n\
    \    \n    for (int i = 0; i < word.length(); i++)\n    {\n        consonant =\
    \ word[i]-'a';\n        vowel = consonant-1;\n        right_consonant = word[i+1]-'a';\n\
    \        \n        if (right_consonant<=consonant)\n        {\n            if\
    \ (vowel<0)\n            {\n                return \"\";\n            }\n    \
    \        else\n            {\n                return word[i] + 'a';\n        \
    \    }\n        }\n        else if (right_consonant>=consonant)\n        {\n \
    \           if (vowel>0)\n            {\n                return word[i] + 'a';\n\
    \            }\n        }\n    }\n    return \"\";\n}\n</code>\n<|/ a |>\n<| a\
    \ |>\nMy first answer was wrong. Here is a new one:\n<code>\nstring get_closest_vowel(string\
    \ word) \n{\n    int consonant=0;\n    int vowel=0;\n    int right_consonant=0;\n\
    \    \n    for (int i = 0; i < word.length(); i++)\n    {\n        consonant =\
    \ word[i]-'a';\n        vowel = consonant-1;\n        right_consonant = word[i+1]-'a';\n\
    \        \n        if (right_consonant<=consonant)\n        {\n            if\
    \ (vowel<0)\n            {\n                return \"\";\n            }\n    \
    \        else\n            {\n                return word[i] + 'a';\n        \
    \    }\n        }\n        else if (right_consonant>=consonant)\n        {\n \
    \           if (vowel>0)\n            {\n                return word[i] + 'a';\n\
    \            }\n        }\n    }\n    return \"\";\n}\n</code>\nI changed a couple\
    \ of things:", "{\n    string vowels[] = {'a', 'e', 'i', 'o', 'u'};\n    int length\
    \ = word.length();\n    \n    if(length<2)\n    {\n        return \"\";\n    }\n\
    \    int rightIndex = word.length()-1;\n    int leftIndex = word.length()-2;\n\
    \    \n    int index = word.length()-1;\n    \n    while(rightIndex>0)\n    {\n\
    \        if(word[index]=='z')\n        {\n            break;\n        }\n    \
    \    index--;\n    }\n    \n    while(leftIndex<word.length()-1)\n    {\n    \
    \    if(word[index]=='z')\n        {\n            break;\n        }\n        index++;\n\
    \    }\n    \n    char firstLetter = word[leftIndex];\n    char secondLetter =\
    \ word[rightIndex];\n    \n    int firstLetterIndex = find(vowels, firstLetter);\n\
    \    int secondLetterIndex = find(vowels, secondLetter);\n    \n    while(index>0)\n\
    \    {\n        if(word[index]==firstLetter)\n        {\n            int index\
    \ = word.length()-1;\n            while(index>0)\n            {\n            \
    \    if(word[index]==secondLetter)\n                {\n                    int\
    \ result = rightIndex-index;\n                    if(result>0)\n             \
    \       {\n                        break;\n                    }\n           \
    \         else\n                    {\n                        return word;\n\
    \                    }\n                }\n                index--;\n        \
    \    }\n            break;\n        }\n        index--;\n    }\n    return word;\n\
    }\n</code>\n<|/ a dscore=1 tags=c++,c |>\n<| a dscore=0 tags=c++,c |>\n<code>\n\
    #include <stdio.h>\n#include <string.h>\n#include <ctype.h>"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
