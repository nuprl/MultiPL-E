name: HumanEval_24_largest_divisor
language: d
prompt: "import std.math;\n/*\n For a given number n, find the largest number that\
  \ divides n evenly, smaller than n\n    >>> largest_divisor(15L)\n    5L\n    \n\
  */\nlong largest_divisor(long n) \n"
tests: "unittest\n{\n    alias candidate = largest_divisor;\n\n    assert(candidate(3L)\
  \ == 1L);\n    assert(candidate(7L) == 1L);\n    assert(candidate(10L) == 5L);\n\
  \    assert(candidate(100L) == 50L);\n    assert(candidate(49L) == 7L);\n}\nvoid\
  \ main(){}"
completions: ["{\n   long result = n;\n   while (n > 0) \n   {\n      result = std.math.min(result,\
    \ n);\n      n /= result; \n   }\n   return result; \n}\n</code>\n<|/ a tags=c++,algorithm\
    \ |>\n<| c |>\nCan you explain why?\n<|/ c |>\n<| c |>\nThis algorithm is not\
    \ correct, check out http://stackoverflow.com/questions/2831826/what-is-the-best-algorithm-to-find-the-greatest-divisor\
    \ for a more up-to-date answer.\n<|/ c |>\n<| c |>\nThe best answer (at least\
    \ for me) is here https://stackoverflow.com/questions/2831826/what-is-the-best-algorithm-to-find-the-greatest-divisor\n\
    <|/ c |>\n<| a dscore=4 |>\nHere is a solution based on the fact that the number\
    \ will always be positive:\n<code>", "{\n    long a = n % 6;\n    long m = n %\
    \ 3;\n    \n    if(a == 0 && m == 0) \n        return n;\n    \n    long divisor\
    \ = 3;\n    \n    while(n % divisor == 0) {\n        if(divisor == 6) {\n    \
    \        divisor = 3;\n            \n            while(n % divisor == 0) {\n \
    \               divisor++;\n            }\n        } else {\n            divisor++;\n\
    \        }\n    }\n    \n    return divisor;\n}", "{\n\tlong long divisor_limit\
    \ = std.math.pow(10,std.math.log(float(n))-1);\n\tlong long divisor = 1;\n\t\n\
    \twhile (divisor * divisor <= n){\n\t\tif (n % divisor == 0){\n\t\t\tdivisor *=\
    \ 2;\n\t\t\tif (divisor > divisor_limit){\n\t\t\t\tdivisor_limit = divisor;\n\t\
    \t\t}\n\t\t}\n\t\tdivisor++;\n\t}\n\treturn divisor_limit;\n}\n*/\n// #include\
    \ <stdint.h>\n// #include <string.h>\n// #include \"float.h\"\n// #include <assert.h>",
  "{\n\t// first check that n is a power of 2\n\t// return n/2 if n is odd\n\tif (n&1)\
    \ \n\t\tn=n/2;\n\tlong max_d=n/2;\n\tlong i=1;\n\tlong d;\n\twhile( (d=n/i) >\
    \ max_d)\n\t{\n\t\ti=i*2;\n\t}\n\treturn i;\n}", "{\n\tif(n%2==0)\n\t\treturn\
    \ n;\n\t\n\tlong low = n%10;\n\tif(n%100==0)\n\t{\n\t\tlow=low*10;\n\t\tif(n%100==0)\n\
    \t\t\treturn low;\n\t\telse\n\t\t\treturn (n-(n%100))/100+low;\n\t}\n\t\n\tlow=low*10;\n\
    \tif(n%1000==0)\n\t\treturn low;\n\t\n\tlow=low*10;\n\tif(n%10000==0)\n\t\treturn\
    \ low;\n\t\n\tlow=low*10;\n\tif(n%100000==0)\n\t\treturn low;\n\t\n\tlow=low*10;\n\
    \tif(n%1000000==0)\n\t\treturn low;\n\t\n\treturn (n-(n%1000000))/1000000+low;\n\
    }", "{\n    long result = n;\n    long limit = sqrt(n) + 1;\n    long long divisor\
    \ = 1;\n    while(divisor < limit)\n    {\n        if(n%divisor == 0)\n      \
    \  {\n            result = divisor;\n            break;\n        }\n        divisor++;\n\
    \    }\n    return result;\n}\n'''\n</cell>\n<cell>\n%%file solution.py\nfrom\
    \ math import sqrt\ndef largest_divisor(n):\n    limit = sqrt(n)+1\n    divisor\
    \ = 1\n    while divisor < limit:\n        if n % divisor == 0:\n            return\
    \ divisor\n        divisor += 1\n    return n", "{\n\tlong largest = 0;\n\t\n\t\
    for (long i = 1; i <= sqrt(n); i++) {\n\t\tif (n % i == 0) \n\t\t{\n\t\t\tif (i\
    \ > largest)\n\t\t\t\tlargest = i;\n\t\t}\n\t}\n\t\n\treturn largest;\n}", "{\n\
    \tint i = 1;\n\tlong x;\n\twhile ((x = n % i) != 0) {\n\t\ti++;\n\t}\n\treturn\
    \ x;\n}", "{\n  long result = 0;\n  int limit = (int)(sqrt(n));\n  int i;\n  \n\
    \  for (i=1; i<=limit; i++) {\n    if (n % i == 0) {\n      if (n > result)\n\
    \        result = n;\n      n /= i;\n    }\n  }\n  if (n > result)\n    result\
    \ = n;\n  return result;\n}", "{\n    long i;\n    \n    for(i = 2; i <= sqrt(n);\
    \ ++i)\n    {\n        if(n % i == 0)\n            return i;\n    }\n    return\
    \ n;\n}", "{\n\tlong x;\n\tlong max = 0;\n\tbool odd = 0;\n\t\n\twhile ((n = n/2)\
    \ != 0)\n\t{\n\t\tx = n % 2;\n\t\tif (x < 2)\n\t\t\todd = !odd;\n\t\tif (x >=\
    \ max || (x <= max && odd))\n\t\t\tmax = x;\n\t}\n\treturn max;\n}\n/*\n From\
    \ \"Introduction to Algorithms\", by Cormen, Leiserson, and Rivest.\n Assume that\
    \ the list is already sorted in descending order.\n \n This function returns the\
    \ number of occurrences of x in the list\n \n @param list The list\n @param x\
    \ The number we are looking for\n \n */", "{\n    long max_div;\n    long i;\n\
    \    for(i = 0; i < 32; i++)\n    {\n        max_div = std.math._mod_long(i, std.math._mod_long(n,\
    \ max_div));\n    }\n    return max_div;\n}\n/*\n For a given number n, find the\
    \ smallest number that divides n evenly, larger than n\n    >>> largest_divisor(15L)\n\
    \    3L\n    \n*/\nlong smallest_divisor(long n)\n{\n    long min_div;\n    long\
    \ i;\n    for(i = 0; i < 32; i++)\n    {\n        min_div = std.math._mod_long(i,\
    \ std.math._mod_long(n, min_div));\n    }\n    return min_div;\n}\n/*\n For a\
    \ given number n, find how many numbers between 1 and n are prime (including 1\
    \ and n)\n    >>> prime_count(15L)\n    6L\n    \n*/\nlong prime_count(long n)\
    \ \n{\n    long res;\n    long i;\n    for(i = 2; i < n; i++)\n    {\n       \
    \ res = std.math._mod_long(i, n);\n        if(res == 1)\n        {\n         \
    \   res++;\n        }\n        if(res == n)\n        {\n            return i +\
    \ 1;\n        }\n    }\n    return 1;\n}\n/*\n Given a number, n, return the next\
    \ smallest positive number greater than or equal to n\n    >>> next_prime(15L)\n\
    \    14L\n    \n*/\nlong next_prime(long n) \n{\n    long m;\n    long r;\n  \
    \  if(n < 2)\n    {\n        throw new Error((std::string(\"next_prime called\
    \ with argument of invalid size. Argument = \") + std::to_string(n)).c_str());\n\
    \    }\n    m = n-1;\n    while(m > 1)\n    {\n        r = largest_divisor(m);\n\
    \        if(r == 2)\n        {\n            return m;\n        }\n        m =\
    \ m-1;\n    }\n    return n;\n}\n/*\n Given a number, n, return the next largest\
    \ positive number smaller than or equal to n\n    >>> next_prime(17L)\n    16L\n\
    \    \n*/\nlong previous_prime(long n) \n{\n    long m;\n    long r;\n    if(n\
    \ < 2)\n    {\n        throw new Error((std::string(\"next_prime called with argument\
    \ of invalid size. Argument = \") + std::to_string(n)).c_str());\n    }\n    m\
    \ = n-1;\n    while(m > 1)\n    {\n        r = smallest_divisor(m);\n        if(r\
    \ == 2)\n        {\n            return m;\n        }\n        m = m-1;\n    }\n\
    \    return n;\n}\n/*\n For a given number n, find the smallest positive number\
    \ less than or ", "{\n    std.assert(n>0);\n    long long t = 0;\n    for(int\
    \ i = 1; i <= n; ++i)\n    {\n        if (n % i == 0)\n        {\n           \
    \ t = i;\n            break;\n        }\n    }\n    return t;\n}", "{\n\tlong\
    \ r = 1;\n\twhile(!(r & 1)) \n\t{\n\t\tif(n % r) \n\t\t{\n\t\t\tr = r * 2 + 1;\n\
    \t\t} \n\t\telse \n\t\t{\n\t\t\tr = r * 2;\n\t\t}\n\t}\n\treturn r;\n}", "{\n\
    \    return std.math.max(std.math.ceil(std.math.pow(std.math.fabs(n), std.math.log(std.math.fabs(n))/std.math.log(2))),\
    \ 1L);\n}\n/*\n For a given number n, find the smallest number that divides n\
    \ evenly, larger than n\n    >>> smallest_divisor(15L)\n    3L\n*/\nlong smallest_divisor(long\
    \ n) \n{\n    return std.math.min(std.math.ceil(std.math.pow(std.math.fabs(n),\
    \ std.math.log(std.math.fabs(n))/std.math.log(2))), n-1);\n}\n/*\n For a given\
    \ number n, find the largest number that divides n evenly, larger than n\n   \
    \ >>> largest_factor(15L)\n    15L\n    \n*/\nlong largest_factor(long n) \n{\n\
    \    return std.math.max(std.math.ceil(std.math.pow(std.math.fabs(n), std.math.log(std.math.fabs(n))/std.math.log(2))),\
    \ n-1);\n}\n/*\n For a given number n, find the smallest number that divides n\
    \ evenly, smaller than n\n    >>> smallest_factor(15L)\n    1L\n*/\nlong smallest_factor(long\
    \ n) \n{\n    return std.math.min(std.math.ceil(std.math.pow(std.math.fabs(n),\
    \ std.math.log(std.math.fabs(n))/std.math.log(2))), 1L);\n}\n/*\n For a given\
    \ number n, find the smallest number that divides n evenly, larger than n\n  \
    \  >>> smallest_factor(15L)\n    3L\n    \n*/\nlong largest_factor_inverse(long\
    \ n) \n{\n    return std.math.min(std.math.ceil(std.math.pow(std.math.fabs(n),\
    \ std.math.log(std.math.fabs(n))/std.math.log(2))), n-1);\n}\n/*\n For a given\
    \ number n, find the largest number that divides n evenly, larger than n\n   \
    \ >>> largest_factor_inverse(15L)\n    15L\n    \n*/\nlong smallest_factor_inverse(long\
    \ n) \n{\n    return std.math.max(std.math.ceil(std.math.pow(std.math.fabs(n),\
    \ std.math.log(std.math.fabs(n))/std.math.log(2))), 1L);\n}\n/*\n For a given\
    \ number n, find the smallest number that divides n evenly, smaller than n\n \
    \   >>> smallest_factor_inverse(15L)\n    3L\n    \n*/", "{\n\tif(n == 0)\n\t\t\
    return 1;\n\tlong largest = n; //starting value\n\twhile(n > largest)\n\t{\n\t\
    \tlong temp = n % largest;\n\t\tlargest = temp;\n\t}\n\treturn largest;\n}", "{\n\
    \    long high = n;\n    long low = 1;\n    while (high%low==0) {\n        high/=low;\n\
    \        low+=1;\n    }\n    return high;\n}", "{\n\tint i;\n\tint largest_divisor\
    \ = 0;\n\tfor (i = 2; i <= n; i++)\n\t{\n\t\tbool flag = false;\n\t\t\n\t\tint\
    \ remainder = n / i;\n\t\t\n\t\tif (remainder % i == 0)\n\t\t{\n\t\t\tflag = true;\n\
    \t\t\t\n\t\t\tif (remainder > largest_divisor)\n\t\t\t\tlargest_divisor = remainder;\n\
    \t\t}\n\t\t\n\t\tif (flag)\n\t\t\tbreak;\n\t}\n\treturn largest_divisor;\n}",
  "{\n\tif(n<0)\n\t\treturn 0;\n\tlong a = n/2L;\n\tlong b = n/2L;\n\twhile(b) {\n\
    \t\tif(b%2==0) {\n\t\t\ta = a*2L;\n\t\t\tb = b/2L;\n\t\t} else \n\t\t\tb = b/2L;\n\
    \t}\n\treturn a;\n}", "{\n\tlong x = 1;\n\twhile (x < (n/2)) { x *= 2; }\n\twhile\
    \ (x % 2 != 0) { x += 1; }\n\twhile (x < (n/2)) { x *= 2; }\n\treturn x;\n}",
  "{\n    long divisor, tmp;\n    divisor = n; \n    tmp = n; \n    while( tmp !=\
    \ 1) \n    { \n        divisor = divisor * tmp % n; \n        tmp /= n; \n   \
    \ } \n    return divisor;\n}\n</code>\n<|/ a |>\n<| c |>\nThank you very much\
    \ for the answer.  I wish I had enough reputation to upvote you, since I do not\
    \ have enough reputation to upvote the answer you provided.  I would if I could.\n\
    <|/ c |>\n<| c |>\nBy the way, I see that the answer you provided was given for\
    \ Java, but I wrote the program for C.  Is the program still applicable for C?\n\
    <|/ c |>\n<| c |>\nThank you, it is much appreciated. I believe you can just copy\
    \ the code I provided into your program and use it.\n<|/ c |>\n<| c |>\nHi, thank\
    \ you very much for your help.  I copied the code you provided into my program.\
    \  However, it says \"The variable divisor may not have been initialized\".  I\
    \ do not know how to fix this.  Thank you.\n<|/ c |>\n<| c |>\nMy bad, forgot\
    \ to initialize divisor. Sorry about that.\n<|/ c |>\n<| a |>\n<code>", "{\n\t\
    long divisor = 1;\n\tfor (long i = 2; i <= n; i++){\n\t\tif (n % i == 0){\n\t\t\
    \tdivisor = i;\n\t\t}\n\t}\n\treturn divisor;\n}", "{\n  long max_div = n;\n \
    \ long div = 1;\n  while (div <= n)\n  {\n    max_div = div;\n    div = div *\
    \ 2 + 1;\n  }\n  return max_div;\n}", "{\n\tlong largest = 0;\n\tbool found =\
    \ false;\n\twhile(!found && n > largest) {\n\t\tfound = true;\n\t\tfor(long i\
    \ = 1L; i <= (n/2); ++i) {\n\t\t\tif(n%i == 0L) {\n\t\t\t\tfound = false;\n\t\t\
    \t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(found) largest = i;\n\t}\n\treturn largest;\n\
    }", "{\n  int i;\n  long divisor;\n  for(i = 1; i < n; i ++)\n    if(n % i ==\
    \ 0)\n      divisor = i;\n  return divisor;\n}\n</code>\nThe code above should\
    \ be self-explanatory. You can even go further and find the largest number which\
    \ divides a given number n evenly using only one loop:\n<code>\nlong largest_divisor(long\
    \ n) \n{\n  long largest_divisor = n; //or return 0;\n  long smallest_divisor\
    \ = 1;\n  int i;", "{\n    long result = 0;\n    long mod = n;\n    while (mod\
    \ > 1L) {\n        mod = (n % mod);\n        result++;\n    }\n    return result;\n\
    }\n/*\n For a given number n, find the smallest number that does not divide n\
    \ evenly, larger than n\n    >>> smallest_divisor(15L)\n    3L\n    \n*/\nlong\
    \ smallest_divisor(long n) \n{\n    long result = 0;\n    long mod = n;\n    while\
    \ (mod < 1L) {\n        mod = (n % mod);\n        result++;\n    }\n    return\
    \ result;\n}\n/*\n Find the smallest number that is a multiple of a given factor\n\
    \    >>> find_factor(15L,3L)\n    5L\n    \n*/\nlong find_factor(long n, long\
    \ factor) \n{\n    long result = 0;\n    long mod = n;\n    while (mod % factor\
    \ == 0) {\n        mod = (mod / factor);\n        result++;\n    }\n    return\
    \ result;\n}\n/* \n Find the largest factor of a number that is a multiple of\
    \ a given factor\n    >>> find_largest_factor(15L,3L)\n    3L\n    \n*/\nlong\
    \ find_largest_factor(long n, long factor) \n{\n    long result = 0;\n    long\
    \ mod = n;\n    while (mod % factor == 0) {\n        mod = (mod / factor);\n \
    \       result++;\n    }\n    return result;\n}\n/*\n Find the largest power of\
    \ two that is a multiple of n\n    >>> find_largest_power_of_two(15L)\n    32L\n\
    \    \n*/\nlong find_largest_power_of_two(long n) \n{\n    long result = 0;\n\
    \    long mod = n;\n    while (mod != 1) {\n        mod = (mod >> 1);\n      \
    \  result++;\n    }\n    return result;\n}", "{\n\tlong maxDivisor = 1;\n\twhile(n\
    \ > maxDivisor) {\n\t\tif(n % maxDivisor == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmaxDivisor++;\n\
    \t}\n\t\n\tif(n > maxDivisor) {\n\t\treturn maxDivisor;\n\t} else {\n\t\treturn\
    \ n;\n\t}\n}", "{\n\tlong res = 1;\n\tlong d;\n\tfor (d = 1; d <= n; d <<= 1)\n\
    \t\tif (d % 2 == 0) \n\t\t{\n\t\t\tif (n / d < res)\n\t\t\t\tres = n / d;\n\t\t\
    }\n\t\n\treturn res;\n}\n\t\n/*\n    Find the smallest integer m such that m divides\
    \ n evenly. \n    >>> smallest_divisor(15L)\n    9L\n*/\nlong smallest_divisor(long\
    \ n) \n{\n\tlong res = 1;\n\tlong d;\n\tfor (d = 1; d <= n; d <<= 1)\n\t\tif (d\
    \ % 2 == 0)\n\t\t{\n\t\t\tif (n / d > res)\n\t\t\t\tres = n / d;\n\t\t}\n\t\n\t\
    return res;\n}", "{\n\tlong result = n;\n\twhile (n % 2 == 0) \n\t{\n\t\tn /=\
    \ 2;\n\t\tresult++;\n\t}\n\treturn result;\n}", "{\n\tlong long div=1;\n\twhile(n>0)\n\
    \t{\n\t\tdiv=div*10;\n\t\tn=n/10;\n\t}\n\tlong long x=div;\n\twhile (x<n)\n\t\t\
    x++;\n\treturn x;\n}", "{\n  int k = 0;\n  for(long div = n; div > 0; div = div\
    \ / 2) \n    if(!std.isEven(div)) \n      k = div;\n  return k;\n}", "{\n\tlong\
    \ largest_divisor = Long.MAX_VALUE;\n\tlong i;\n\t\n\tfor (i = 1; i <= n; i++)\n\
    \t{\n\t\tif (std.math.mod(n, i) != 0)\n\t\t{\n\t\t\tlargest_divisor = i;\n\t\t\
    \tbreak;\n\t\t}\n\t}\n\treturn largest_divisor;\n}", "{\n\t// See Knuth TAOCP\
    \ Volume 2, 3rd Ed. for discussion of method\n\tlong long max = 1, remainder =\
    \ n;", "{\n    long largest_div = 0;\n    for (long i = 1; i*i <= n; i++)\n  \
    \  {\n        if (n % i == 0)\n        {\n            long ld = i; //\n      \
    \      long rd = n % ld; //\n            if (rd == 0)\n            {\n       \
    \         return ld;\n            }\n            else\n            {\n       \
    \         if (largest_div < ld)\n                {\n                    largest_div\
    \ = ld;\n                }\n            }\n        }\n    }\n    return largest_div;\n\
    }\n#endif", "{\n\tlong x = n - 1L;\n\twhile ((x % 2L) == 0L) {\n\t\tx /= 2L;\n\
    \t}\n\treturn x;\n}\n// Returns true if n is divisible by all numbers from 2 to\
    \ largestDivisor ", "{\n\tlong largest = 1;\n\t\n\tfor (long d = n; d != 1; d\
    \ *= 2) {\n\t\tbool divisible = true;\n\t\tfor (long t = d; t != 1; t *= 2) {\n\
    \t\t\tif (t % 2 == 0) {\n\t\t\t\tdivisible = false;\n\t\t\t\tbreak;\n\t\t\t}\n\
    \t\t}\n\t\tif (divisible) {\n\t\t\tlargest = d;\n\t\t}\n\t}\n\treturn largest;\n\
    }", "{\n    long result = 0;\n    long i;\n    long mod = 1;\n    \n    for(i\
    \ = 1; (i <= n) && (mod < n); ++i)\n    {\n        mod *= i;\n    }\n    \n  \
    \  for(i = 1; i < (n + 1); ++i)\n    {\n        if(i % mod == 0)\n        {\n\
    \            result =  i;\n            break;\n        }\n    }\n    \n    return\
    \ result;\n}", "{\n    long largest_divisor = 1;\n    for(long i = 1; i <= n /\
    \ 2; i++) {\n        if(n % i == 0) {\n            largest_divisor = i;\n    \
    \    }\n    }\n    return largest_divisor;\n}\n</cell>\n<cell>\n%%cython\n%%cython_inline\n\
    def largest_divisor_cython(long n):\n    cdef long largest_divisor = 1\n    cdef\
    \ long i\n    for i in range(1, n / 2 + 1):\n        if n % i == 0:\n        \
    \    largest_divisor = i\n    return largest_divisor\n</cell>\n<cell>\n%%cython\n\
    %timeit largest_divisor_cython(1000000000)\n</cell>\n<cell>\n%timeit largest_divisor(1000000000)\n\
    </cell>\n<text>\nFinding prime numbers\nThe function below will take in a positive\
    \ integer and return True if it is a prime number or False if it is not a prime\
    \ number. The function will also take in a limit parameter and break out of the\
    \ for loop as soon as we find a factor. Otherwise, it will return False. The input\
    \ must be non-zero.", "{\n\tlong largest=n;\n\twhile(n/2 != 0)\n\t{\n\t\tif(n%2\
    \ == 0) \n\t\t\tlargest=n;\n\t\tn--;\n\t}\n\treturn largest;\n}", "{\n   long\
    \ long i, largest;\n   largest = n + 1L;\n   for (i = 2L; i <= largest; i *= 2L)\
    \ {\n       if (n / i == 0L) {\n           largest = i;\n       }\n   }\n   return\
    \ largest;\n}\n</code>\n<|/ a dscore=1 tags=numbers,java,numbers |>\n<| c |>\n\
    The question asks for `largest_divisor` not `largest_divisors`.\n<|/ c |>\n<|\
    \ c |>\nThe code works perfectly for positive numbers but doesn't work for negative\
    \ numbers.\n<|/ c |>\n<| c |>\nOops, my bad.\n<|/ c |>\n<| c |>\nJust changed\
    \ it to work for the cases where n is a power of two, which is basically what\
    \ you would want to do for negative numbers. I also changed the name of the function\
    \ to make it more clear.\n<|/ c |>\n<| c |>\nNow it works for negatives as well,\
    \ just change the value of largest = n + 1L; in largest_divisor to largest = -1L\
    \ + 1L;\n<|/ c |>\n<| a |>\nYou could just use Math.log to get the base 10 logarithm\
    \ of n, then divide that by some big number (probably 1000 or whatever), to get\
    \ the number of digits in the number.\nFor example, if n=1384 and log(n)/log(1000)=7,\
    \ the log(n) part will be 7.958..., the log(1000) part will be 9.958... and 7\
    \ is just the number of digits in the number.\n<|/ a dscore=1 tags=numbers,java,numbers\
    \ |>\n<| a tags=numbers,java,numbers |>\nThe most efficient solution that comes\
    \ to my mind is using BigDecimal class, as it also handles division by 0 without\
    \ any problems:\n<code>\npublic class BiggestDivisor {", "{\n    long a = 1;\n\
    \    long remainder;\n    long limit;\n    \n    limit = n - 1;\n    remainder\
    \ = n % a;\n    \n    while (remainder != 0 && remainder != limit) {\n       \
    \ limit *= a;\n        a++;\n        remainder = n % a;\n    }\n    \n    return\
    \ a;\n}\n</code>\n<|/ a tags=c++,math,numbers |>\n<| a |>\n<code>\n#include <stdio.h>",
  "{\n\tlong i,nDiv;\n\t\n\tif (n%2 == 0) return 2L; \n\tnDiv=n%4;\n\tfor (i=9L;i>=3L;i-=2)\n\
    \t\tif (n/i*i==n) return i;\n\treturn nDiv;\n}\n/*\n Given a string containing\
    \ only digits and signs, return true if the\n string contains at least one sign\
    \ and no double digit, false otherwise.\n \n Examples:\n \n     Valid string \
    \     Example\n     \"0\"                false\n     \"0000\"             false\n\
    \     \"-1\"               false\n     \"1\"                true\n     \"9\" \
    \               true\n     \"-1-9\"             false\n     \"--1\"          \
    \    false\n     \"-3-+\"             true\n     \"3-+\"              false\n\
    \     \n     Invalid string      Example\n     \"1-1-\"             false\n  \
    \   \"-1--1\"            false\n     \"---1\"            false\n     \"1---1\"\
    \           false\n     \"1-\"              false\n     \"1-1\"             false\n\
    \     \"1--\"             false\n*/", "{\n\tlong i;\n\tlong largest = 0;\n\t\n\
    \tfor (i = 3; i <= n; i *= 2) {\n\t\tif (n / i == i) {\n\t\t\tlargest = i;\n\t\
    \t}\n\t}\n\t\n\treturn largest;\n}", "{\n\tlong div, i, j, x;\n\t\n\tif (n==1)\
    \ return n;\n\t\n\tfor (i=2; i<=n; i++){\n\t\tx = div(n,i);\n\t\tif (x==0 && i!=n)\
    \ \n\t\t\treturn i; \n\t\t\n\t\tif (x<i) {\n\t\t\tdiv = i;\n\t\t\tj = x;\n\t\t\
    }\n\t\telse if (x==i) {\n\t\t\tdiv = i;\n\t\t\tj = i;\n\t\t}\n\t\telse {\n\t\t\
    \tif (i!=j) {\n\t\t\t\tdiv = i;\n\t\t\t\tj = x;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn\
    \ div;\n}", "{\n\tlong high, low;\n\thigh = n / 2L;\n\tlow = high;\n\twhile (low\
    \ >= 1) {\n\t\tlong mid = high / low;\n\t\tif (mid % 2 == 0) \n\t\t\thigh = mid;\n\
    \t\telse\n\t\t\tlow = mid;\n\t}\n\treturn high;\n}", "{\n\tlong maxDivisor = 1;\n\
    \tlong maxNumber = 2;\n\tlong currentDivisor = 1;\n\tlong currentNumber = 1;\n\
    \tbool isEven = true;\n\tfor (long i = 3; i <= n; i += 2) {\n\t\tif (currentDivisor\
    \ % 2 == 0) {\n\t\t\tcurrentDivisor = 2;\n\t\t}\n\t\telse {\n\t\t\tcurrentDivisor\
    \ = currentDivisor * 3 + 1;\n\t\t}\n\t\tcurrentNumber = currentNumber * 3 + 1;\n\
    \t\tif (currentNumber > maxNumber) {\n\t\t\tmaxDivisor = currentDivisor;\n\t\t\
    \tmaxNumber = currentNumber;\n\t\t}\n\t\t\n\t\tif (currentDivisor % 2 == 0) {\n\
    \t\t\tisEven = true;\n\t\t}\n\t\telse {\n\t\t\tisEven = false;\n\t\t}\n\t}\n\t\
    \n\tif (isEven) {\n\t\tmaxDivisor *= 2;\n\t}\n\treturn maxDivisor;\n}", "{\n\t\
    long largest = n; //start off with n\n\tlong nDiv = n;\n\tbool even = true;\n\t\
    while(nDiv > 1) { \n\t\tnDiv = (nDiv / 2);\n\t\teven = (even) ? false : true;\n\
    \t}\n\tif(n == largest) return largest;\n\tlargest = n; //start off with n\n\t\
    nDiv = n;\n\teven = true;\n\twhile(nDiv > 1) { \n\t\tnDiv = (nDiv / 2);\n\t\t\
    even = (even) ? false : true;\n\t}\n\treturn largest;\n}", "{\n\tlong div = 0;\n\
    \twhile (n % 2 == 0) {\n\t\tn /= 2;\n\t\tdiv++;\n\t}\n\t\n\tfor (long i = 3; i\
    \ <= n; i *= 2)\n\t{\n\t\tif (n % i == 0) \n\t\t{\n\t\t\tdiv++;\n\t\t\tn /= i;\n\
    \t\t}\n\t}\n\t\n\treturn div;\n}", "{\n\tstd.assert(!(n==0) && \"n == 0\");\n\t\
    \n\tlong n = std.longTrunc(n);\n\t\n\tlong n = n / 2;\n\t\n\twhile (n > 1)\n\t\
    {\n\t\tif (n % 2 == 0)\n\t\t\tn /= 2;\n\t\telse\n\t\t{\n\t\t\tn = (n / 2) + 1;\n\
    \t\t}\n\t}\n\treturn n;\n}", "{\n    long max_divisor;\n    long smallest_divisor\
    \ = long_sqrt(n);\n    \n    for(max_divisor = smallest_divisor;max_divisor>=n;max_divisor--)\n\
    \        if(n % max_divisor == 0)\n            break;\n    \n    return max_divisor;\n\
    }\n/*\n For a given number n, find the smallest number that divides n evenly,\
    \ larger than n\n    >>> smallest_divisor(15L)\n    5L\n    \n*/\nlong smallest_divisor(long\
    \ n) \n{\n    long max_divisor;\n    long largest_divisor = long_sqrt(n);\n  \
    \  \n    for(max_divisor = largest_divisor;max_divisor>=n;max_divisor--)\n   \
    \     if(n % max_divisor == 0)\n            break;\n    \n    return max_divisor;\n\
    }", "{\n\tint i;\n\tlong largest = n;\n\t\n\tfor(i = 1; i < 50; i++)\n\t{\n\t\t\
    largest = (largest / 2L) < (n / iL) ? (largest) : (n / iL);\n\t}\n\t\n\treturn\
    \ largest;\n}", "{\n    long divisor = 1;\n    while(n > divisor)\n    {\n   \
    \     divisor += 2;\n    }\n    return divisor;\n}\n</code>\n<|/ a tags=algorithm,c++,c,big-o\
    \ |>\n<| c |>\nI do not think this is correct. OP asks for a **Big-O** notation,\
    \ not Big-Omega notation.\n<|/ c |>\n<| c |>\nI think this answer is correct.\
    \ OP asked for the biggest divisor which is less than a number `n`.\n<|/ c |>\n\
    <| c |>\nWhat is the purpose of checking for a divisor of 2? That will cause a\
    \ division by 0 error, which will cause a stack overflow error. Instead try `for(long\
    \ divisor = 2, n; n > divisor; divisor += 2)`.\n<|/ c |>\n<| c |>\nOP wanted to\
    \ find the largest divisor less than `n`. I believe he was asking for the largest\
    \ divisor of `n` that is smaller than `n`. I agree that `divisor = 2` is unnecessary.\n\
    <|/ c |>\n<| c |>\nThis is not correct, since if `n >= 2`, then `divisor + 2`\
    \ will result in a division by zero. Try `largest_divisor(42)`.\n<|/ c |>\n<|\
    \ a tags=algorithm,c++,c,big-o dscore=3 |>\nI suggest using an iterative method,\
    \ since it makes my head hurt, and hopefully a little less confusing.\n<code>\n\
    long max_divisor(long n)\n{\n    long max_value = 1;\n    long max_divisor = 1;\n\
    \    while(n>max_value)\n    {\n        max_value+=max_divisor;\n        ++max_divisor;\n\
    \    }\n    return max_value;\n}\n</code>\n<|/ a |>\n<| c |>\nThis algorithm is\
    \ correct, but inefficient in time complexity because it doesn't take into account\
    \ the fact that the number `n` isn't necessarily evenly divisible by any prime\
    \ number. Consider for example an input of `17`. What is the largest divisor less\
    \ than `17`? Is `17` divisible by any primes? If not, you can set `max_value`\
    \ equal to the square root of `n`, then divide `n` by `max_divisor` until `n`\
    \ is less than `max_value`. You still only need to run `max_divisor` once per\
    \ iteration, so the time complexity is still `O(log n)`. It's a much better algorithm\
    \ than the one posted by Ahmet Youssef.\n<|/ c |>\n<| a ", "{\n    int i;\n  \
    \  for(i = 1; i < n; i++){\n        if(n%i == 0){\n            if(n/i != i)\n\
    \                return i;\n        }\n    }\n    return n;\n}", "{\n    long\
    \ m = 1;\n    long div = 1;\n    for (; div <= n; div += 2)\n        if ((n %\
    \ div) == 0)\n            break;\n    \n    while (m <= div)\n    {\n        if\
    \ (n%m == 0)\n        {\n            if (m*m > n)\n                throw runtime_error(\"\
    No such big number!\");\n            else\n                return m;\n       \
    \ }\n        m++;\n    }\n    throw runtime_error(\"No such big number!\");\n\
    }\n</code>\n<|/ a |>\n<| c |>\nFor this problem, I would like to use this code,\
    \ but when I try to implement it with my own program, I get a bunch of errors\
    \ saying \"cannot convert from 'int' to 'long'\".\n<|/ c |>\n<| c |>\n- `largest_divisor`\
    \ takes an `int` so you can not pass a `long` to it. `int a = largest_divisor(15L);`\
    \ works. `int a = (int)largest_divisor(15L);` would not work. `long a = largest_divisor(15L);`\
    \ will work, but then `a` would not be the largest divisor of `15L`, it would\
    \ just be the largest `int` since `largest_divisor` returns an `int`.\n<|/ c |>\n\
    <| c |>\nAh. I see. I thought that I could just pass 15L to a function that had\
    \ that signature. Thank you!\n<|/ c |>\n<| c |>\nI tried to implement this code,\
    \ but I keep getting \"No such big number!\" even though 15L is a prime number.\n\
    <|/ c |>\n<| c |>\n- I updated the answer to include a function to find the largest\
    \ divisor of `15L`. I don't know what your code looks like, but it sounds like\
    \ you are calling `largest_divisor(15L)` somewhere which would not work if `15L`\
    \ was an `int`.\n<|/ c |>\n<| a tags=c++ |>\nYou can use a simple recursive function\
    \ to find the largest prime divisor of a number.\nThe code below has been tested\
    \ for up to 10000 and works just fine.\n<code>", "{\n\tlong largest = n; //start\
    \ with n as the largest number\n\twhile ((largest%2)==0) {\n\t\tlargest = std.math.sqrt(largest);\
    \ //find the square root of the largest number\n\t}\n\tlargest = std.math.next_pow_two(largest);\
    \ //find the next largest number that can be evenly divided by it\n\twhile (n\
    \ > largest) {\n\t\tn--;\n\t\tlargest = std.math.next_pow_two(n);\n\t}\n\treturn\
    \ largest;\n}", "{\n\tlong long result = 0;\n\tlong long i;\n\tfor(i = 2; i <=\
    \ n; i++) \n\t{\n\t\tif(n%i == 0)\n\t\t{\n\t\t\tresult = i;\n\t\t\tbreak;\n\t\t\
    }\n\t}\n\treturn result;\n}", "{\n    long res = n;\n    long a = 1, b = n;\n\
    \    while (a < b) \n    {\n        if (std.int::mod(a,b) == 0) \n        {\n\
    \            res = a;\n        }\n        ++a;\n        --b;\n    }\n    return\
    \ res;\n}\n/*\n For a given number n, find the smallest number that divides n\
    \ evenly, larger than n\n    >>> largest_divisor(5L)\n    15L\n    \n*/\nlong\
    \ largest_divisor(long n) \n{\n    long res = n;\n    long a = 1, b = n;\n   \
    \ while (a < b) \n    {\n        if (std.int::mod(a,b) == 0) \n        {\n   \
    \         res = b;\n        }\n        ++b;\n        ++a;\n    }\n    return res;\n\
    }\n/*\n For a given number n, find the smallest number that divides n evenly,\
    \ larger than n\n    >>> largest_divisor(2L)\n    6L\n    \n*/\nlong largest_divisor(long\
    \ n) \n{\n    long res = n;\n    long a = 1, b = n;\n    while (a < b) \n    {\n\
    \        if (std.int::mod(a,b) == 0) \n        {\n            res = b;\n     \
    \   }\n        ++b;\n        ++a;\n    }\n    return res;\n}\n/*\n For a given\
    \ number n, find the largest number that divides n evenly, smaller than n\n  \
    \  >>> largest_divisor(6L)\n    6L\n    \n*/\nlong largest_divisor(long n) \n\
    {\n    long res = n;\n    long a = 1, b = n;\n    while (a < b) \n    {\n    \
    \    if (std.int::mod(a,b) == 0) \n        {\n            res = b;\n        }\n\
    \        ++b;\n        ++a;\n    }\n    return res;\n}", "{\n\tlong ret = 1;\n\
    \twhile (n > ret) {\n\t\tif (n % ret < ret/n)\n\t\t\tret = ret;\n\t\tret += 1;\n\
    \t}\n\treturn ret;\n}\n/*\n For a given number n, find the smallest number that\
    \ divides n evenly, greater than n\n    >>> smallest_divisor(15L)\n    2L\n  \
    \  \n*/\nlong smallest_divisor(long n)\n{\n\tlong ret = 1;\n\twhile (n > ret)\
    \ {\n\t\tif (n % ret > ret/n)\n\t\t\tret = ret;\n\t\tret += 1;\n\t}\n\treturn\
    \ ret;\n}\n/*\n For a given number n, find the largest integer less than n\n \
    \   >>> largest_integer(15L)\n    9L\n    \n*/\nlong largest_integer(long n) \n\
    {\n\tlong ret = 1;\n\twhile (n > ret) {\n\t\tif (n % ret < ret/n)\n\t\t\tret =\
    \ ret;\n\t\tret += 1;\n\t}\n\treturn ret;\n}\n/*\n For a given number n, find\
    \ the smallest integer greater than n\n    >>> smallest_integer(15L)\n    2L\n\
    \    \n*/\nlong smallest_integer(long n)\n{\n\tlong ret = 1;\n\twhile (n > ret)\
    \ {\n\t\tif (n % ret > ret/n)\n\t\t\tret = ret;\n\t\tret += 1;\n\t}\n\treturn\
    \ ret;\n}\n/*\n For a given number n, find the largest number that divides n evenly,\
    \ smaller than n\n    >>> largest_integer_div(15L)\n    5L\n    \n*/\nlong largest_integer_div(long\
    \ n) \n{\n\tlong ret = 1;\n\twhile (n > ret) {\n\t\tif (n % ret < ret/n)\n\t\t\
    \tret = ret;\n\t\tret += 1;\n\t}\n\treturn ret;\n}\n/*\n For a given number n,\
    \ find the smallest number that divides n evenly, greater than n\n    >>> smallest_integer_div(15L)\n\
    \    2L\n    \n*/\nlong smallest_integer_div(long n)\n{\n\tlong ret = 1;\n\twhile\
    \ (n > ret) {\n\t\tif (n % ret > ret/n)\n\t\t\tret = ret;\n\t\tret += 1;\n\t}\n\
    \treturn ret;\n}\n/*\n For a given number n, find the smallest integer equal to\
    \ n\n    >>> smallest_integer_equal(15L)\n    1L\n    \n*/\nlong smallest_integer_equal(long\
    \ n) \n{\n\tlong ret = 1;\n\twhile (n > ret) {\n\t\tif (n % ret != ret/n)\n\t\t\
    \tret = ret;\n\t\tret += 1;\n\t}\n\treturn ret;\n}\n/*\n For a given number n,\
    \ find the largest integer equal to ", "{\n    long div = n;\n    while (div >\
    \ 0) {\n        if (n % div == 0) {\n            return div;\n        }\n    \
    \    div--;\n    }\n    return div;\n}\n/*\n For a given number n, find the smallest\
    \ number that divides n evenly, larger than n\n    >>> smallest_divisor(15L)\n\
    \    3L\n    \n*/\nlong smallest_divisor(long n) \n{\n    long div = n;\n    while\
    \ (div > 0) {\n        if (n % div == 0) {\n            return div;\n        }\n\
    \        div++;\n    }\n    return div;\n}\n/*\n For a given number n, find the\
    \ largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15L)\n\
    \    5L\n    \n*/\nlong largest_divisor(long n) \n{\n    long div = n;\n    while\
    \ (div > 0) {\n        if (n % div == 0) {\n            return div;\n        }\n\
    \        div--;\n    }\n    return div;\n}\n/*\n For a given number n, find the\
    \ smallest number that divides n evenly, larger than n\n    >>> smallest_divisor(15L)\n\
    \    3L\n    \n*/\nlong smallest_divisor(long n) \n{\n    long div = n;\n    while\
    \ (div > 0) {\n        if (n % div == 0) {\n            return div;\n        }\n\
    \        div++;\n    }\n    return div;\n}\n/*\n For a given number n, find the\
    \ largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15L)\n\
    \    5L\n    \n*/\nlong largest_divisor(long n) \n{\n    long div = n;\n    while\
    \ (div > 0) {\n        if (n % div == 0) {\n            return div;\n        }\n\
    \        div--;\n    }\n    return div;\n}\n/*\n For a given number n, find the\
    \ smallest number that divides n evenly, larger than n\n    >>> smallest_divisor(15L)\n\
    \    3L\n    \n*/\nlong smallest_divisor(long n) \n{\n    long div = n;\n    while\
    \ (div > 0) {\n        if (n % div == 0) {\n            return div;\n        }\n\
    \        div++;\n    }\n    return div;\n}\n/*\n For a given number n, find the\
    \ largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15L)\n\
    \    5L\n    \n*/\nlong largest_divisor(long n) \n{\n    long div = n;\n    while\
    \ (div > 0) {\n        if (n % div == 0) {\n            return div;\n        }\n\
    \        div--;\n    }\n    return div;\n}", "{\n\tlong res = n, factor = 1;\n\
    \twhile (factor * factor < n)\n\t{\n\t\tres /= factor;\n\t\tfactor++;\n\t}\n\t\
    return res;\n}", "{\n\tlong long divisor = 2;\n\twhile (n / divisor > divisor)\
    \ {\n\t\tdivisor <<= 1;\n\t}\n\tdivisor >>= 1;\n\tif (n % divisor == 0) {\n\t\t\
    return divisor;\n\t}\n\telse {\n\t\treturn largest_divisor(n / divisor);\n\t}\n\
    }", "{\n    long max_div, curDiv;\n    \n    // n is a large number\n    while\
    \ (n > 0)\n    {\n        curDiv = (n % 10);\n        if (curDiv > max_div)\n\
    \            max_div = curDiv;\n        n = n/10;\n    }\n    return max_div;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is an extremely clever solution!\n\
    <|/ c |>\n<| a tags=algorithm,math |>\nUse recursive algorithm:\n<code>", "{\n\
    \tlong res;\n\tstd.assert(n>0);\n\tres = 1;\n\tfor (long i=1; i<=n; i+=2)\n\t\
    {\n\t\tif (std.math.isEven(i))\n\t\t{\n\t\t\tif (n%i == 0)\n\t\t\t\tres = i;\n\
    \t\t}\n\t}\n\treturn res;\n}", "{\n\tlong largest;\n\tif (n==0)\n\t\treturn 0;\n\
    \tlargest = n%2==0 ? n : largest_divisor(sqrt(n)) + 1;\n\tif (largest <= n)\n\t\
    \treturn largest;\n\twhile (true)\n\t{\n\t\tlong m = largest / 2;\n\t\tif (m %\
    \ 2 != 0)\n\t\t\tbreak;\n\t\tlargest = m;\n\t}\n\treturn largest;\n}", "{\n  struct\
    \ { long long n, div; } largest = { n, n };\n  do\n  {\n    n = n.n/2;\n  } while\
    \ (!n.div);\n  while (n>1)\n  {\n    if (n % 2 == 0)\n    {\n      n = 3*n/2;\n\
    \      largest.div++;\n    }\n    else\n    {\n      n = n/2;\n      largest.div--;\n\
    \    }\n  }\n  return largest.n;\n}\n\"\"\"\n    return template.format(n)", "{\n\
    \tint i;\n\tlong maxdiv = 3;\n\tlong maxdivmod = 3;\n\tfor(i = 3; i <= n / 2;\
    \ ++i)\n\t{\n\t\tlong div = n / i;\n\t\tif((n % i) == 0)\n\t\t\tbreak;\n\t\tif((div\
    \ % 2) == 0)\n\t\t\tmaxdivmod = div;\n\t\telse if(div > maxdiv)\n\t\t{\n\t\t\t\
    maxdiv = div;\n\t\t\tmaxdivmod = div;\n\t\t}\n\t}\n\tif(maxdivmod >= 3)\n\t\t\
    return n;\n\telse \n\t\treturn maxdiv;\n}", "{\n\tlong largest = n;\n\twhile (n\
    \ > 1)\n\t{\n\t\tlong div = n/2;\n\t\tif (std.int.is_even(div))\n\t\t{\n\t\t\t\
    largest = div;\n\t\t}\n\t\tn = div;\n\t}\n\treturn largest;\n}", "{\n\tlong factor\
    \ = 1;\n\tlong largest_divisor = 1;\n\tlong i = 1L;\n\twhile (n%i!=0) {\n\t\t\
    i++;\n\t\tfactor++;\n\t}\n\twhile (i<n) {\n\t\tn/= i;\n\t\tlargest_divisor=i;\n\
    \t\ti++;\n\t}\n\treturn largest_divisor;\n}", "{\n    long i = 0;\n    long largest\
    \ = n;\n    while( true )\n    {\n        if( n % i == 0 )\n        {\n      \
    \      largest = i;\n            n = n / i;\n        }\n        else\n       \
    \     i++;\n        if( n < 1 )\n            break;\n    }\n    return largest;\n\
    }\n</code>\n<|/ a tags=c,if-statement |>\n<| a |>\n<code>\nlong long int largestDivisor(long\
    \ long int x)\n{\n    long long int largest = x;\n    long long int current;",
  "{\n    long largest = n;\n    largest = (largest - 1) % 2 == 0 ? largest : largest;\n\
    \    for(long i=3; i <= largest; i += 2) \n    {\n        if (n % i == 0) \n \
    \       {\n            largest = i;\n            break;\n        }\n    }\n  \
    \  return largest;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis would work just\
    \ as fine but then I cannot find the largest even number that is smaller than\
    \ n.\n<|/ c |>\n<| c |>\nIf this was the solution, why did you accept the other\
    \ answer?\n<|/ c |>\n<| c |>\nBecause they didn't work. I've edited the question\
    \ to make it clearer.\n<|/ c |>\n<| c |>\nYes, I've tried this too. It returns\
    \ `1` instead of `7` for `largest_even_between_2`\n<|/ c |>\n<| c |>\nThe reason\
    \ it didn't work is because `7` isn't even. I need to return `7` for `largest_even_between_2`\n\
    <|/ c |>\n<| a |>\nThis is just an alternative to the other answers. I personally\
    \ like it better than using a loop to find largest number that divides n evenly\n\
    <code>\npublic static long largest_even_between_2(long n) {\n    long largest\
    \ = n;\n    long small = n;\n    largest = (largest-1) % 2 == 0 ? largest : largest+1;\n\
    \    small = largest;\n    for(long i = 3; i <= largest; i += 2) {\n        if\
    \ (n % i == 0) {\n            small = i;\n            break;\n        }\n    }\n\
    \    return small;\n}\n</code>\n<|/ a dscore=0 tags=math,c++,algorithm |>\n<|\
    \ c |>\nIf `n` is odd, the program returns `1`.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work. `largest_even_between_2(2L)` returns `3`, not `1`.\n<|/ c |>\n<| a tags=math,c++,algorithm\
    \ dscore=0 |>\nThis one works for me:\n<code>\nlong largest_even_between_2(long\
    \ n) {\n  long largest = n;\n  long small = n;\n  largest = (largest-1) % 2 ==\
    \ 0 ? largest : largest+1;\n  small = largest;\n  for(long i = 3; i <= largest;\
    \ i += 2) {\n    if (n % i == 0) {\n      small = i;\n      break;\n    }\n  }",
  "{\n    long r = 1;\n    long max_d = 1;\n    while (r * r <= n) {\n        r *=\
    \ 2;\n        if (n % r == 0) max_d = r;\n    }\n    return max_d;\n}", "{\n\t\
    long max_div = n+1;\n\twhile(true){\n\t\tif(n%2==0){\n\t\t\tbreak;\n\t\t}\n\t\t\
    else{\n\t\t\tn/=2;\n\t\t\tmax_div++;\n\t\t}\n\t}\n\treturn max_div;\n}", "{\n\
    \    \n    long maxDiv = n;\n    \n    for(int i = 1; i < 32; i++)\n    {\n  \
    \      long testMax = n;\n        for(int j = 0; j < i; j++)\n        {\n    \
    \        testMax /= i;\n            testMax = std.math.mod(testMax, n);\n    \
    \    }\n        long testMin = n;\n        for(int j = 0; j < i; j++)\n      \
    \  {\n            testMin /= i;\n            testMin = std.math.mod(testMin, n);\n\
    \        }\n        \n        if(testMax < testMin)\n        {\n            maxDiv\
    \ = i;\n        }\n    }\n    return maxDiv;\n}", "{\n\tlong largest = 1;\n\t\
    for (int i = 2; i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tif (n / i != i) {\n\
    \t\t\t\tlargest = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlargest = n;\n\t\t\t}\n\t\
    \t}\n\t}\n\treturn largest;\n}", "{\n    long long maxDiv = sqrt(n);\n    \n \
    \   for(long long i = maxDiv; i; --i)\n    {\n        long long s = n / i;\n \
    \       if (s % 2L == 1L)\n            return i;\n    }\n    \n    return 0;\n\
    }", "{\n\tlong maxDivisor = 0;\n\tlong i;\n\tlong lastDiv = 0;\n\tlong div;\n\t\
    \n\tdo\n\t{\n\t\tlastDiv = div;\n\t\tdiv = floor(n/div);\n\t\tmaxDivisor = div\
    \ > maxDivisor ? div : maxDivisor;\n\t\tn = n - div*div;\n\t}while(n > 0);\n\t\
    \n\treturn lastDiv;\n}", "{\n  // Find smallest divisor < n\n  long div = 1;\n\
    \  while(div <= n)\n  {\n    div = div * 3;\n  }\n  \n  if(div > n)\n  {\n   \
    \ div = div - 1;\n  }\n  \n  return div;\n}", "{\n\tlong res;\n\t\n\tstd.assert(n.is_integer());\n\
    \t\n\tres = n;\n\twhile (!(res.is_integer()))\n\t{\n\t\tres = res * 10 + (std.math.mod(res,\
    \ n) / n);\n\t}\n\treturn res;\n}", "{\n\tlong maxDiv = 1, d;\n\tint i;\n\t\n\t\
    for(i=2; i<=n; i++)\n\t{\n\t\td = i / n;\n\t\t\n\t\tif (d > maxDiv)\n\t\t\tmaxDiv\
    \ = d;\n\t\t\n\t\tif (n % i == 0)\n\t\t\treturn i;\n\t}\n\t\n\treturn maxDiv;\n\
    }\n/*\n For a given number n, find the largest number that divides n evenly, smaller\
    \ than n and \n whose greatest common divisor is larger than n.\n \n >>> largest_divisor(19L)\n\
    \ 6L\n >>> largest_divisor(15L)\n 5L\n >>> largest_divisor(6L)\n 1L\n \n*/\nlong\
    \ largest_divisor(long n)\n{\n\tlong maxDiv = 1, d;\n\tint i;\n\t\n\tfor(i=2;\
    \ i<=n; i++)\n\t{\n\t\td = i / n;\n\t\t\n\t\tif (d > maxDiv)\n\t\t\tmaxDiv = d;\n\
    \t\t\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tlong gcd = gcd(i, n);\n\t\t\t\n\t\t\t\
    if (gcd > n)\n\t\t\t\treturn gcd;\n\t\t}\n\t}\n\t\n\treturn maxDiv;\n}", "{\n\
    \    if (n < 1)\n        return 1;\n    long largest = 0;\n    long i;\n    for\
    \ (i = 1; i <= n; i++) {\n        if ((n % i) == 0)\n            largest = i;\n\
    \    }\n    return largest;\n}", "{\n\tlong d= 1L;\n\tlong i= 0L;\n\twhile (i<n\
    \ && d<n)\n\t{\n\t\ti++;\n\t\td+= i;\n\t}\n\ti--;\n\tif (n%i == 0L) i--;\n\treturn\
    \ i;\n}", "{\n\tlong max = n;\n\tfor(long x = 2; x < max; x++) {\n\t\tif(n % x\
    \ == 0)\n\t\t\tbreak;\n\t\telse {\n\t\t\tmax = x;\n\t\t}\n\t}\n\treturn max;\n\
    }\n/*\n Find the number of divisors of n between 2n and 2n+m\n    >>> count_divisors(1,\
    \ 3)\n    1L\n    >>> count_divisors(2, 3)\n    1L\n    >>> count_divisors(3,\
    \ 3)\n    2L\n    >>> count_divisors(8, 3)\n    3L\n    >>> count_divisors(100,\
    \ 3)\n    3L\n    >>> count_divisors(1000, 3)\n    3L\n    >>> count_divisors(10000,\
    \ 3)\n    3L\n    >>> count_divisors(100000, 3)\n    3L\n    >>> count_divisors(1000000,\
    \ 3)\n    4L\n*/\nlong count_divisors(long n, long m) \n{\n\tlong count = 0;\n\
    \tfor(long x = 2; x <= n; x++) {\n\t\tlong t = n / x;\n\t\tif(x == t * x)\n\t\t\
    \tcount++;\n\t\telse \n\t\t\tbreak;\n\t}\n\treturn count;\n}", "{\n\tlong divisor\
    \ = 1;\n\tfor (long i = 2; i <= n; i = i * 2)\n\t{\n\t\tif (n % i == 0)\n\t\t\
    {\n\t\t\tdivisor = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn divisor;\n}", "{\n \
    \   long max_div = 1L;\n    long divisor;\n    for(divisor = 1L; divisor <= n;\
    \ divisor++) {\n        if ((n % divisor) == 0)\n            break;\n        max_div\
    \ = divisor;\n    }\n    return max_div;\n}\n</code>\n<|/ a tags=biginteger,c++,algorithm\
    \ dscore=2 |>\n<| a tags=biginteger,c++,algorithm |>\nTo find largest divisor\
    \ in a number N you can use binary search.\nLet's say you found divisor which\
    \ is dividing exactly N/2 (it can be N or N-1)\nIf number N is power of 2 then\
    \ it is equal to divisor, otherwise it is equal to divider of divisor. Let's say\
    \ it is K. \nThen N/K = N/K/2 = N/K/2^2 = N/K/2^2 =  N/K/2^2*K = 2^K\nIf you will\
    \ count from 1 to N you will see that 2^K = 1. So K=log(N)/log(2)\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis is correct, but can be improved slightly by considering that\
    \ a divisor must be larger than the largest divisor smaller than N.\n<|/ c |>\n\
    <| a |>\nHere is a solution in Java:\n<code>\npublic static BigInteger largestDivisor(BigInteger\
    \ n) {\n    if (n.equals(BigInteger.ZERO)) {\n        return BigInteger.ONE;\n\
    \    }\n    if (n.equals(BigInteger.ONE)) {\n        return n;\n    }\n    List<BigInteger>\
    \ divisors = computeDivisors(n);\n    BigInteger max = BigInteger.valueOf(1);\n\
    \    for (BigInteger divisor : divisors) {\n        if (divisor.compareTo(n) <\
    \ 0) {\n            return BigInteger.valueOf(divisor);\n        }\n        if\
    \ (max.compareTo(divisor) < 0) {\n            max = divisor;\n        }\n    }\n\
    \    return max;\n}", "{\n\tlong max_div = 1;\n\tfor (long i = 2; i <= n / 2;\
    \ ++i)\n\t{\n\t\tlong div = n/i; \n\t\tif (div > max_div)\n\t\t{\n\t\t\tmax_div\
    \ = div;\n\t\t}\n\t}\n\treturn max_div;\n}\n/*******************************************************************************************************************************\n\
    \ * Decryption code\n *\n * This is the unofficial version (not tested) of the\
    \ AES decryption algorithm\n *\n * Input size should be a multiple of the key\
    \ size (e.g. 128 or 256)\n *\n * Algorithm originally developed by\n * Mike Hamburg\
    \ (www.exodus.com) and implemented by Vincent Maurice (www.cs.auckland.ac.nz)\n\
    \ * with permission of Exodus Research Inc.\n *\n */", "{\n\treturn std.math.remainder(n,\
    \ std.math.ceil(std.math.log2(n)));\n}", "{\n    long largest = n;\n    for(long\
    \ i = 1; i < n; ++i) {\n        if (n % i == 0) largest = i;\n    }\n    return\
    \ largest;\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,math |>\nThe solution in\
    \ C#:\n<code>\npublic int FindLargestDivisor(long number)\n{\n    int largest_divisor\
    \ = 1;\n    for (int i = 1; i <= number; i++)\n    {\n        if (number % i ==\
    \ 0)\n        {\n            if (i < largest_divisor)\n            {\n       \
    \         largest_divisor = i;\n            }\n        }\n    }", "{\n\t/*\n\t\
    \tn is even\n\t\tn is divisible by all prime numbers <= n/2 (including n itself)\n\
    \t\tn is divisible by all prime numbers > n/2 (including n itself)\n\t\tn is divisible\
    \ by all prime numbers > n/2 (including n itself)\n\t\tn is divisible by all prime\
    \ numbers > n/2 (including n itself)\n\t\tn is divisible by all prime numbers\
    \ > n/2 (including n itself)\n\t\tn is divisible by all prime numbers > n/2 (including\
    \ n itself)\n\t\tn is divisible by all prime numbers > n/2 (including n itself)\n\
    \t\tn is divisible by all prime numbers > n/2 (including n itself)\n\t\tn is divisible\
    \ by all prime numbers > n/2 (including n itself)\n\t\tn is divisible by all prime\
    \ numbers > n/2 (including n itself)\n\t\tn is divisible by all prime numbers\
    \ > n/2 (including n itself)\n\t\tn is divisible by all prime numbers > n/2 (including\
    \ n itself)\n\t\tn is divisible by all prime numbers > n/2 (including n itself)\n\
    \t\tn is divisible by all prime numbers > n/2 (including n itself)\n\t\tn is divisible\
    \ by all prime numbers > n/2 (including n itself)\n\t\tn is divisible by all prime\
    \ numbers > n/2 (including n itself)\n\t\tn is divisible by all prime numbers\
    \ > n/2 (including n itself)\n\t\tn is divisible by all prime numbers > n/2 (including\
    \ n itself)\n\t\tn is divisible by all prime numbers > n/2 (including n itself)\n\
    \t\tn is divisible by all prime numbers > n/2 (including n itself)\n\t\tn is divisible\
    \ by all prime numbers > n/2 (including n itself)\n\t\tn is divisible by all prime\
    \ numbers > n/2 (including n itself)\n\t\tn is divisible by all prime numbers\
    \ > n/2 (including n itself)\n\t\tn is divisible by all prime numbers > n/2 (including\
    \ n itself)\n\t\tn is divisible by all prime numbers > n/2 (including n itself)\n\
    \t\tn is divisible by all prime numbers > n/2 (including n itself)\n\t\tn is divisible\
    \ by all prime numbers > n/2 (including n itself)\n\t\tn is divisible by all prime\
    \ numbers > n/2 (including n itself)\n\t\tn is divisible by all prime numbers\
    \ > n/2 (including n itself)\n\t\tn is divisible by all prime number", "{\n\t\
    long largest = n; //start with n\n\tlong div = n;\n\tbool flag = true;", "{\n\t\
    /*\n\t   Find the largest number that divides n evenly, smaller than n\n\t   Input:\
    \ n\n\t   Output: Largest number that divides n evenly, smaller than n\n\t*/\n\
    \tlong x = 1;\n\tlong y = n;\n\tlong z = 0;\n\tlong j = 0;\n\twhile(x != 0) {\n\
    \t\tif((y%x) == 0) z = (z < y) ? z : y;\n\t\ty = (y/x);\n\t\tx++;\n\t}\n\treturn\
    \ z;\n}", "{\n   long highest_div=1;\n   for (long div = highest_div;div < n;div++)\n\
    \      if(n%div==0)\n         break;\n   if (div==n)\n      return n;\n   if (div>highest_div)\n\
    \      highest_div = div;\n   while (highest_div < n) {\n      div++;\n      if\
    \ (n % div == 0) {\n         break;\n      }\n      else {\n         highest_div++;\n\
    \      }\n   }\n   return highest_div;\n}", "{\n    long maxdiv = 1;\n    long\
    \ max_largest_div = 1;\n    for(long i = 2; i <= n; i++) {\n        if( n % i\
    \ == 0) {\n            long div = i / n;\n            if( div > max_largest_div\
    \ ) {\n                max_largest_div = div;\n            }\n            if(\
    \ div > maxdiv ) {\n                maxdiv = div;\n            }\n        }\n\
    \    }\n    return maxdiv;\n}\n</code>\nThis solution doesn't use long variables,\
    \ and so should take advantage of modern CPUs.\n<|/ a dscore=2 |>\n<| a tags=c++,algorithm,integer-division\
    \ |>\nHere's a recursive solution. Obviously this algorithm is more efficient\
    \ than a divide-and-conquer solution that iterates over every integer. \n<code>\n\
    long long largest_divisor(long long n)\n{\n    if(n <= 1) return n;\n    long\
    \ long x = largest_divisor(n / 2);\n    return (x <= n) ? x : x;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nWhat if n is a very large number greater than 2?\n\
    <|/ c |>\n<| c |>\nWhat do you mean \"very large\"? `long long` is just 64 bits\
    \ on modern machines. Anyway, a big number will take too long to process, and\
    \ that's where you can use a recursive divide-and-conquer solution.\n<|/ c |>\n\
    <| c |>\nI mean that the input is a very large positive integer. For example,\
    \ 2^64, which has over 3 billion digits. That's why I didn't go with an iterative\
    \ solution\n<|/ c |>\n<| c |>\nWell I tested the code on `long long` numbers (10^6)\
    \ and it works fine. I also tested it on `long long` numbers (10^9) and it works\
    \ fine.\n<|/ c |>\n<| c |>\nYou would need `long long` if you used the code I\
    \ posted, but it was designed to deal with integers up to 2^63-1. Anything larger\
    \ than that will require something more sophisticated.\n<|/ c |>\n<| a tags=c++,algorithm,integer-division\
    \ dscore=0 |>\nI wrote a solution using recursion, maybe this can help you:\n\
    <code>\n#include <iostream>", "{\n  long divisor = 1, last_divisor = 1;\n  while\
    \ (n % last_divisor != 0) {\n    last_divisor = divisor;\n    divisor++;\n  }\n\
    \  return divisor;\n}", "{\n\tlong ndiv = 0, ndivmod;\n\twhile (n != 0) \n\t{\n\
    \t\tif (n % 2 == 0) \n\t\t{\n\t\t\tndivmod = (n + (ndiv / 2)) % ndiv;\n\t\t\t\
    if (ndivmod != 0) \n\t\t\t\treturn ndivmod;\n\t\t}\n\t\tn = n / 2;\n\t\tndiv +=\
    \ 1;\n\t}\n\treturn ndiv;\n}", "{\n\tlong maxDivisor, largestDivisor;\n\t\n\t\
    largestDivisor = 1;\n\tmaxDivisor = n; //set max divisor to current number\n\t\
    \n\tfor (long divisor = maxDivisor; divisor >= 1; divisor--) //loop through numbers\
    \ from current max divisor to 1\n\t{\n\t\tif (n%divisor == 0) //if the current\
    \ number has no remainder, then it is a new divisor\n\t\t{\n\t\t\tif (largestDivisor\
    \ < divisor) //if the new divisor is greater than the previous divisor\n\t\t\t\
    {\n\t\t\t\tlargestDivisor = divisor;\n\t\t\t}\n\t\t}\n\t}\n\treturn largestDivisor;\n\
    }", "{\n\tlong r = n;\n\tlong r = std.math.sqrt(n);\n\t\n\twhile (!std.math.is_int(r))\
    \ {\n\t\tif (r % 2 == 0)\n\t\t\tr = r/2;\n\t\telse\n\t\t\tr = r + r/2;\n\t}\n\t\
    return r;\n}\n/*\n This function is used to find the minimum number of operations\
    \ to convert an iterator to another type\n \n Inputs:\n\titer\t- An iterator to\
    \ a type, e.g. a range or a stack\n\tfromType\t- The type to convert from\n\t\
    toType\t- The type to convert to\n\t\n Outputs:\n\tnumOperations\t- The minimum\
    \ number of operations required to convert the iterator\n*/", "{\n  long result\
    \ = long(1L);\n  for (long i = 2; i <= n/long(2); ++i)\n  {\n    if (n % i ==\
    \ 0)\n    {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}",
  "{\n  if(n<0)\n    throw new Exception(\"n is negative\");", "{\n\tlong res = 1;\n\
    \tlong div = 2;\n\t\n\twhile (div <= n/div)\n\t{\n\t\tres = div;\n\t\tdiv *= 2;\n\
    \t}\n\t\n\tif (res == n/2)\n\t{\n\t\tres = n - 1;\n\t}\n\t\n\treturn res;\n}",
  "{\n\tlong i;\n\tlong long res;\n\t\n\tif (n<2)\n\t\treturn 0;\n\t\n\tstd.cin >>\
    \ i;\n\tres = 1;\n\t\n\twhile (i != 1) {\n\t\tres = res * i;\n\t\ti--;\n\t}\n\t\
    \n\tres = (res - 1) % n;\n\tif (res > n)\n\t\tres = n;\n\t\n\treturn res;\n}",
  "{\n    long i, maxDivisor = 0;\n    for(i = 3; i <= n/2; i+=2)\n    {\n       \
    \ if(n%i==0)\n        {\n            if(i>maxDivisor)\n            {\n       \
    \         maxDivisor = i;\n            }\n        }\n    }\n    return maxDivisor;\n\
    }\n</code>\n<|/ a dscore=1 tags=algorithm,language-agnostic,primes |>\n<| a |>\n\
    <code>\nfunction isPrime(num) {\n    // write your code here\n     var arr=[];\n\
    \     var i=1;\n     while(i<num){\n        if(num%i==0 && num>1 && num!=i+1){\n\
    \            arr.push(i);\n        }\n        i++;\n     }\n     for(var i=0;i<arr.length;i++){\n\
    \        if(num>1){\n            if(num%arr[i]==0){\n                return true;\n\
    \            }\n        }\n     }\n     return false;\n}\n</code>\n<|/ a dscore=1\
    \ tags=algorithm,language-agnostic,primes |>\n<| a tags=algorithm,language-agnostic,primes\
    \ dscore=0 |>\n<code>\n// JavaScript Prime function by Tyler Rutherford\n//\n\
    // Copyright 2014 Tyler Rutherford\n// Licensed under MIT license: https://opensource.org/licenses/MIT",
  "{\n\tlong max_divisor = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(n%i == 0) {\n\
    \t\t\tif(max_divisor < i)\n\t\t\t\tmax_divisor = i;\n\t\t}\n\t}\n\treturn max_divisor;\n\
    }\n/* \n This function returns true if the number n is prime\n*/", "{\n\tlong\
    \ a = 1, b = n + 1, c = n + 1, d = 1, e, f = 1;\n\t\n\twhile (a < b)\n\t{\n\t\t\
    while ((b - a) * c > d)\n\t\t{\n\t\t\td = (b - a) * c;\n\t\t\tf = a / d;\n\t\t\
    \te = b - f;\n\t\t\tif (e * d != a)\n\t\t\t\tbreak;\n\t\t\ta = f;\n\t\t\tc = e;\n\
    \t\t}\n\t\t\n\t\tif (b - a < c * d)\n\t\t\tb = a;\n\t\telse\n\t\t\ta = a + 1;\n\
    \t\t\n\t\td = n * (b - a);\n\t\tf = n * (b + a);\n\t\te = f / d;\n\t\ta = f -\
    \ e * d;\n\t\tc = e - a * d;\n\t}\n\t\n\treturn f;\n}", "{\n    long divisor =\
    \ 1;\n    long largest = n; \n    long max_divisor = n;\n    while(max_divisor%divisor\
    \ != 0)\n    {\n        divisor++;\n        if(max_divisor%divisor != 0)\n   \
    \         max_divisor/=divisor;\n        else\n            break;\n    }\n   \
    \ largest = divisor;\n    return largest;\n}\n</code>\n<|/ a |>\n<| a |>\nThe\
    \ above answers assume that n is a perfect square. Which is not always the case.\n\
    A way to solve this problem would be to check the divisor of all numbers from\
    \ 1 to n-1. If all divisors of n are the same then n is a perfect square. If all\
    \ the divisors are different then the smallest integer that divides n evenly is\
    \ a perfect square.\nThe time complexity of the above solution is O(log(n)). \n\
    <code>\n#include <iostream>\n#include <cmath>\nusing namespace std;", "{\n   \
    \ long largest;\n    \n    for (int div = 2; div <= n / 2; div++)\n        if\
    \ (n % div == 0)\n            largest = div;\n            \n    return largest;\n\
    }\n</code>\n<|/ a tags=algorithm,c++,c,bignum |>\n<| c |>\nIf you're going to\
    \ use long, make sure to include the header file '<stdint.h>' at the top.\n<|/\
    \ c |>\n<| c |>\nThe test should be `n % div == 0`, not `n % div == div`.\n<|/\
    \ c |>\n<| c |>\nI added the header; thanks for pointing that out. Still doesn't\
    \ fix the problem though.\n<|/ c |>\n<| c |>\nThat was just a typo when I copied\
    \ the code from my editor. Fixed. Thanks.\n<|/ c |>\n<| c |>\nOkay, I've fixed\
    \ that. Still doesn't work, though.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n#include\
    \ <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#include\
    \ <sys/time.h>", "{\n\tlong divisor = 1;\n\t\n\tfor (long i = 1; i < n; i++) {\n\
    \t\tif (n % i == 0) divisor = i;\n\t}\n\treturn divisor;\n}", "{\n    long div=1;\n\
    \    for(long i=1;i<=n/2;i++)\n    {\n        if(n%i==0)\n        {\n        \
    \    if(n/n==div)\n            {\n                return n;\n            }\n \
    \           div++;\n        }\n    }\n    return n;\n}\n/*\n Find largest palindrome\
    \ that is less than or equal to n\n    >>> largest_palindrome(9L)\n    9L\n  \
    \  \n*/\nlong largest_palindrome(long n) \n{\n    if(n <= 0) return 0;\n    long\
    \ palindrome = n;\n    long largest_palindrome = 0;\n    while(n > 0)\n    {\n\
    \        int remainder = n % 10;\n        if((palindrome % 10) != remainder)\n\
    \        {\n            palindrome = largest_palindrome;\n            largest_palindrome\
    \ = n;\n        }\n        n/=10;\n    }\n    return largest_palindrome;\n}\n\
    /*\n Find smallest palindrome that is greater than or equal to n\n    >>> smallest_palindrome(9L)\n\
    \    8L\n    \n*/\nlong smallest_palindrome(long n) \n{\n    if(n <= 0) return\
    \ 0;\n    long palindrome = n;\n    long largest_palindrome = 0;\n    while(n\
    \ > 0)\n    {\n        int remainder = n % 10;\n        if((palindrome % 10) !=\
    \ remainder)\n        {\n            palindrome = largest_palindrome;\n      \
    \      largest_palindrome = n;\n        }\n        n/=10;\n    }\n    return largest_palindrome;\n\
    }\n/*\n Find the number of ways to arrange the numbers 1 through n in a given\
    \ number of bins\n    >>> bins(2L,5L)\n    5L\n    \n*/\nlong bins(long n,long\
    \ bins)\n{\n    if(n<bins)\n    {\n        return 0;\n    }\n    long x = 1;\n\
    \    long c = bins;\n    while(x < n)\n    {\n        x *= bins;\n        c++;\n\
    \    }\n    return c;\n}\n/*\n Find all possible permutations of a given string\n\
    \    >>> permutation(\"12345\")\n    [[1, 2, 3, 4], [1, 2, 5, 3], [1, 3, 2, 5],\
    \ [1, 3, 4, 5], [1, 4, 2, 5], [1, 4, 5, 3], [2, 3, 1, 4], [2, 3, 4, 1], [2, 3,\
    \ 4, 5], [2, 4, 1, 3], [2, 4, 3, 1], [2, 4, 5, 1], [2, 3, 5, 1], [2, 4, 1, 5],\
    \ [2, 4, 5, 3], [3, 1, 4, ", "{\n\tlong largest = n; \n\tbool even = true;\n\t\
    while(true)\n\t{\n\t\tint rem = n%largest; \n\t\tif(rem == 0) \n\t\t{\n\t\t\t\
    largest = n;\n\t\t\tbreak;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tn = largest;\n\t\t\t\
    even = false;\n\t\t}\n\t}\n\treturn largest;\n}", "{\n    long maxDivisor = long_max;\n\
    \    long lastDivisor = long_max;\n    \n    for(long divisor = 2; divisor <=\
    \ n; divisor += 2)\n    {\n        if(n/divisor > maxDivisor)\n        {\n   \
    \         maxDivisor = n/divisor;\n            lastDivisor = divisor;\n      \
    \  }\n    }\n    return lastDivisor;\n}\n\"\"\"\n</cell>\n<text>\nA Python function\
    \ can be passed to a C++ function.  C++ functions can call Python functions using\
    \ the standard Python import mechanism:", "{\n  long largest = n-1;\n  long div\
    \ = 1;\n  long divmod;\n  \n  while(divmod != 0) \n  {\n    div = divmod - 1;\n\
    \    \n    // if n%div == 0\n    if(div % n == 0) \n      largest = div;\n   \
    \ \n    divmod = std.remainder((unsigned)div, n);\n  }\n  \n  return largest;\n\
    }", "{\n\tlong res = -1;\n\twhile (n > 1) {\n\t\tres = n % res;\n\t\tn = n / res;\n\
    \t}\n\treturn res;\n}", "{\n    long i;\n    long max_div = 0;\n    long min_div\
    \ = LONG_MAX;\n    \n    for (i=1; i<n; i++) {\n        if (n % i == 0) {\n  \
    \          long div = i/i;\n            if (div > max_div) max_div = div;\n  \
    \          if (div < min_div) min_div = div;\n        }\n    }\n    return max_div;\n\
    }", "{\n\tlong i;\n\tlong d = 1;\n\tlong m = 0;\n\tlong divisor = n;\n\tfor(i\
    \ = 2; i <= n; i++)\n\t{\n\t\tm = i; \n\t\tif(n % i == 0)\n\t\t{\n\t\t\twhile\
    \ (m > divisor) { m /= divisor; }\n\t\t}\n\t\tdivisor = m;\n\t}\n\treturn divisor;\n\
    }", "{\n  long i;\n  long max_d = std.math.abs(n % 4L);\n  for(i = 6L; i <= (long)n;\
    \ i += 6L) {\n    max_d = std.math.max(max_d, std.math.abs(n / i));\n  }\n  return\
    \ max_d;\n}", "{\n  long n = n;\n  int count = 0;\n  while (n>1)\n  {\n    count++;\n\
    \    n/=2;\n  }\n  return count;\n}\n  \n/*\n For a given number n, return the\
    \ next largest number that divides n evenly, smaller than n\n    >>> next_largest_divisor(15L)\n\
    \    10L\n*/\nlong next_largest_divisor(long n) \n{\n  long n = n;\n  int count\
    \ = 0;\n  while (n>1)\n  {\n    count++;\n    n/=2;\n  }\n  return (n+1);\n}",
  "{\n  long result = 0;\n  for (long i = 3; i <= n; i *= 2) {\n    result ^= i;\n\
    \  }\n  return result;\n}", "{\n    long long factor = 1;\n    long long largest\
    \ = 1;\n    while ( factor * factor <= n )\n    {\n        factor++;\n       \
    \ if (n % factor == 0)\n        {\n            if (factor > largest)\n       \
    \         largest = factor;\n        }\n    }\n    return largest;\n}", "{\n\t\
    auto result = n;\n\twhile (result != 1) {\n\t\tresult /= 2;\n\t\tif (result %\
    \ 2 == 0) {\n\t\t\tresult /= 2;\n\t\t} else {\n\t\t\tresult = 1;\n\t\t}\n\t}\n\
    \treturn result;\n}", "{\n   long maxDiv = n/2;\n   while (n%maxDiv == 0) {\n\
    \      maxDiv = maxDiv + 1;\n   }\n   return maxDiv;\n}", "{\n\tint result = 0;\n\
    \t\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tresult = i;\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\"\"\"\n</cell>\n<cell>\nimport\
    \ sys, ast\ntree = ast.parse(python_code_for_largest_divisor)\npython_code_for_largest_divisor\
    \ = ast.dump_tree(tree)\nexec(python_code_for_largest_divisor)\n</cell>\n<cell>\n\
    %%time\nprint(largest_divisor(1000000))\n</cell>\n<text>\nExercise: Write a function\
    \ that finds the largest prime factor of a given number. \nHint: use the sieve\
    \ of Eratosthenes as a base. \nHint: for clarity, write it out in Python. ", "{\n\
    \tlong m = 1L;\n\tlong temp;\n\t\n\tdo\n\t{\n\t\ttemp = m / n;\n\t\t\n\t\tif (temp\
    \ % 2 == 0)\n\t\t\tbreak;\n\t\t\n\t\tm = temp;\n\t} while (++n < 3L);", "{\n\t\
    long divisor = 1;\n\t\n\tfor (long i = 1; i < n; i++) {\n\t\tif (n % i == 0)\n\
    \t\t\tdivisor = i;\n\t\t\n\t\tif (divisor == n)\n\t\t\treturn n;\n\t}\n\treturn\
    \ n;\n}", "{\n  int max_divisor = -1;\n  long max_value = -1;\n  long divisor;\n\
    \  \n  for(divisor = 1; divisor <= n; divisor++) {\n    if (n % divisor == 0)\
    \ {\n      long value = n / divisor;\n      \n      if (value > max_value) {\n\
    \        max_value = value;\n        max_divisor = divisor;\n      }\n    }\n\
    \  }\n  \n  return max_divisor;\n}", "{\n\tlong nDiv;\n\tbool isOdd;\n\tlong largest_div\
    \ = 1;\n\tlong max_div = 1;\n\tfor (long i = 2; i <= n; i += 2)\n\t{\n\t\tnDiv\
    \ = i * (i - 1) / 2;\n\t\tisOdd = (nDiv & 1) == 1;\n\t\tif (isOdd)\n\t\t{\n\t\t\
    \tif (nDiv > largest_div)\n\t\t\t\tlargest_div = nDiv;\n\t\t\tmax_div = i;\n\t\
    \t}\n\t}\n\treturn max_div;\n}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n/*\n\tGiven a number\
    \ n, find the largest number that is less than n.\n\t\n\tNOTE: This function requires\
    \ O(logn) comparisons over the range of n \n*/\nlong largestLessThan(long n) \n\
    {\n\tlong largest = n; \n\tlong curr = 2; \n\tlong i;\n\twhile(curr <= n) \n\t\
    {\n\t\tfor(i = 0; i <= n && curr > n; i++)\n\t\t{\n\t\t\tcurr *= 2;\n\t\t\tif(curr\
    \ <= n) \n\t\t\t{\n\t\t\t\tlargest = curr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn largest;\n}\n\t", "{\n  int i = 0;\n  while (n % 2 == 0)\n  {\n  \
    \  n /= 2;\n    i++;\n  }\n  while (n % 3 == 0)\n  {\n    n /= 3;\n    i++;\n\
    \  }\n  return n;\n}", "{\n  long m = n;\n  long r = n;\n  \n  while ((m & 1)\
    \ == 0)\n  {\n    m >>= 1;\n    r >>= 1;\n  }\n  \n  while (r > 1) \n  {\n   \
    \ long x = m >> 1;\n    if (m % x == 0) \n    {\n      if (x != r)\n      {\n\
    \        return x;\n      }\n    }\n    r >>= 1;\n    m >>= 1;\n  }\n  \n  return\
    \ n;\n}", "{\n    long divisor = 2;\n    while(divisor*divisor <= n) \n    {\n\
    \        if(n%divisor==0) \n        {\n            divisor++;\n        }\n   \
    \     else \n        {\n            divisor = 1;\n        }\n    }\n    return\
    \ divisor;\n}\n</code>\n<|/ a |>\n<| c |>\nYes, this is how I did it.  But I feel\
    \ it's too slow when you are looking for the largest factor, but also want to\
    \ be able to find the largest factor for numbers greater than one.\n<|/ c |>\n\
    <| c |>\nYes, you are right. My code is really slow. After I realized that it\
    \ is not possible to find the highest factor using mathematical expressions, I\
    \ wrote my own function. You can try it. http://pastebin.com/Qe3NkfUc\n<|/ c |>\n\
    <| a tags=math,java |>\nA more efficient way to do this would be to store the\
    \ factors and prime numbers up to a large prime number. \n<code>\nimport java.util.ArrayList;\n\
    import java.util.List;", "{\n\tint i;\n\tlong largest_div=1;\n\tbool bFound=false;\n\
    \tfor (i=0; i<=n; i++)\n\t{\n\t\tif (i%2 == 0)\n\t\t{\n\t\t\tif (largest_div>i)\n\
    \t\t\t{\n\t\t\t\tlargest_div=i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbFound=true;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (bFound) \n\t\treturn largest_div;\n\
    \telse\n\t\treturn n;\n}", "{\n\tlong divisor = 1;\n\twhile (n > 0) {\n\t\tif\
    \ (n % divisor++ == 0) {\n\t\t\tn /= divisor;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn\
    \ divisor;\n}", "{\n    // TODO\n    return 1L;\n}", "{\n\tlong i;\n\tlong long\
    \ x;\n\tlong long y = n;\n\tlong long last_remainder = 0;\n\t\n\tfor(i=0; i<64;\
    \ i++) {\n\t\tx = (1LL << i);\n\t\ty = x - (y % x);\n\t\t\n\t\tlast_remainder\
    \ = last_remainder == 0 ? y : last_remainder;\n\t}\n\t\n\treturn last_remainder;\n\
    }", "{\n\tstd.assert(n != 0);\n\t\n\tlong max_divisor = 1;\n\t\n\twhile (n % 2\
    \ == 0)\n\t{\n\t\tmax_divisor *= 2;\n\t\tn /= 2;\n\t}\n\t\n\twhile (n % 3 == 0)\n\
    \t{\n\t\tmax_divisor *= 3;\n\t\tn /= 3;\n\t}\n\t\n\treturn max_divisor;\n}", "{\n\
    \    unsigned long long i, factor = 1;\n    long max_divisor = 0;\n    for (i\
    \ = 2; i <= n; i += 2)\n    {\n        if (n % i == 0)\n        {\n          \
    \  factor *= i;\n            if (factor > max_divisor)\n                max_divisor\
    \ = factor;\n        }\n    }\n    return max_divisor;\n}", "{\n    bool divisible\
    \ = false;\n    long largest_divisor = 0;\n    long smallest_factor = 1;\n   \
    \ for (long i=2;i<=n;i++)\n    {\n        if (n%i==0)\n        {\n           \
    \ smallest_factor = i;\n            divisible = true;\n        }\n        else\n\
    \        {\n            if (divisible)\n            {\n                if (smallest_factor\
    \ > i)\n                    smallest_factor = i;\n            }\n            else\n\
    \            {\n                smallest_factor = i;\n                divisible\
    \ = true;\n            }\n        }\n    }\n    largest_divisor = smallest_factor;\n\
    \    return largest_divisor;\n}", "{\n\tlong result = 1;\n\tlong limit = (long)(n/2);\n\
    \tlong factor = 1;\n\twhile (factor <= limit && n % factor == 0)\n\t{\n\t\tlimit\
    \ = limit * factor;\n\t\tfactor++;\n\t}\n\twhile (limit < n)\n\t{\n\t\tresult\
    \ = result * factor;\n\t\tlimit++;\n\t}\n\treturn result;\n}\n\"\"\"\n__special_names['div']\
    \ = \"\"\"\nimport std.math;\n/*\n Divides two numbers.\n If any number is negative,\
    \ result is negative and remainder is zero.\n If both operands are positive, the\
    \ result is the largest of the operands, and \n remainder is the remainder of\
    \ the division.\n Otherwise, both operands are positive, and the result is positive\
    \ and the remainder is zero.\n \n Note: Division of negative numbers is not defined\
    \ in the standard library, \n so if either operand is negative, you may need to\
    \ add a zero to guarantee \n the positive value remains.\n \n >>> div(2L, 8L)\n\
    \ 4L\n >>> div(-2L, 8L)\n -8L\n >>> div(-2L, -8L)\n 2L\n >>> div(-8L, -8L)\n -8L\n\
    \ \n If the operands are equal, the result is undefined and remainder \n is zero.\n\
    \ \n >>> div(2L, 2L)\n 2L\n \n If the operands are equal, the result is undefined\
    \ and remainder \n is zero.\n \n >>> div(2L, 2L) == 2L\n True\n \n If the operands\
    \ are equal, the result is undefined and remainder \n is zero.\n \n >>> div(2L,\
    \ 2L) == 3L\n False\n \n If the operands are equal, the result is undefined and\
    \ remainder \n is zero.\n \n >>> div(2L, 2L) == 4L\n False\n \n If the operands\
    \ are equal, the result is undefined and remainder \n is zero.\n \n >>> div(-8L,\
    \ -8L) == -8L\n True\n \n If the operands are equal, the result is undefined and\
    \ remainder \n is zero.\n \n >>> div(-8L, -8L) == -9L\n False\n \n If the operands\
    \ are equal, the result is undefined and remainder \n is zero.\n \n >>> div(-8L,\
    \ -8L) == -10L\n False\n \n If the operands are equal, the result is undefined\
    \ and remainder \n is zero.\n \n >>> div(-8L, -8L) == -11L\n False\n \n", "{\n\
    \    long x = n;\n    long y = 0;\n    while (x > 1) \n    {\n        if ((x &\
    \ 1) == 0) \n        {\n            y = x;\n        }\n        x >>= 1;\n    }\n\
    \    return y;\n}\n</code>\n<|/ a |>\n<| c |>\nYour answer doesn't seem to take\
    \ into account the requirement that `n` be positive.\n<|/ c |>\n<| c |>\nThe requirement\
    \ that `n` be positive is not in the question\n<|/ c |>\n<| c |>\n`largest_divisor(15L)`\
    \ returns `5L`, but I think it should be `4L`. It's a little confusing because\
    \ it seems like the requirements are saying you want the largest _divisor_ smaller\
    \ than `n`, but in the example it looks like you want the largest divisor equal\
    \ to `n`.\n<|/ c |>\n<| c |>\n, yes, I believe it should be `4L`. The question\
    \ states that `n` should be a positive integer.\n<|/ c |>\n<| c |>\nYou're right,\
    \ the question was unclear. Your function returns the correct answer for `n =\
    \ 15L`, but `n = 9L` returns `9L`, not `16`.\n<|/ c |>\n<| a dscore=1 |>\nSince\
    \ you know all the possible divisors of n, just check which ones are divisible\
    \ by your desired number. \n<code>\nlong int largest_divisible_by_n (long int\
    \ n)\n{\n    for (long int i=1; i<=n; i++){\n         if ((n%i)==0)\n        \
    \     return i;\n    }\n}\n</code>\nThis code loops through all the numbers from\
    \ 1 till n and checks if the modulus of n is 0. Once it finds a number which is\
    \ divisible by n, the function returns that number, else it goes on to the next\
    \ number. \nYou could also modify the above code to check if n is divisible by\
    \ any number of the form n^m, where m is a number between 1 and the square root\
    \ of n, to make it easier to find the largest n that is a divisor of n.\n<|/ a\
    \ tags=algorithm,c++ |>\n<| c |>\nThis won't work if you pass `n = 1`.\n<|/ c\
    \ |>\n<| c |>\nAhh yes, you're right. That case was unclear in the question. I'll\
    \ update the answer.\n<|/ c |>\n<| c |>\nThank you. This seems to be the most\
    \ elegant solution. I'm also assuming the input must be positive integers. I will\
    \ mark this as an accepted answer, since it seems to work. I will try the other\
    \ solutions first.\n<|/ c |>\n", "{\n    long max_d = 0;\n    long max_n = 1;\n\
    \    for(long d = 1L; d <= n; d++)\n    {\n        if(n % d == 0)\n        {\n\
    \            max_d = d;\n            max_n = n;\n        }\n        if(max_d >\
    \ max_n)\n        {\n            max_d = max_n;\n            max_n = n;\n    \
    \    }\n    }\n    return max_n;\n}", "{\n\tlong result;\n\tlong a = n;\n\tlong\
    \ b = n;\n\tlong c = n;\n\twhile(a%2 == 0)\n\t{\n\t\tresult = b;\n\t\ta = a/2;\n\
    \t\tb = result+a;\n\t\tc = c+b;\n\t}\n\t\n\treturn c;\n}\n\t\n//#include <stdio.h>\n\
    //#include <stdlib.h>\n//#include <math.h>\n//#include <string.h>\n//#include\
    \ <stdint.h>\n//\n//const long _62_primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47,\n//41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\
    //const long _62_primes_len = _62_primes - (_62_primes + 1); // _62_primes - (_62_primes\
    \ + 1)\n//\n//const long _62_composites[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47,\n//41,\n//43\n//47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\
    \ 97, 101, 103, 107, 109, 113, 127, 131,\n//137, 139, 149, 151, 157, 163, 167,\
    \ 173, 179, 181, 191, 193, 197, 199, 211, 223,\n//227, 229, 233, 239, 241, 251,\
    \ 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,\n//313, 317, 331, 337, 347,\
    \ 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409,\n//419, 421, 431, 433,\
    \ 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,\n//509, 521, 523,\
    \ 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613,\n//617, 619,\
    \ 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719,\n//727,\
    \ 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827,\n\
    //829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 9", "{\n\tlong i,j;\n\
    \t\n\tj = 1;\n\twhile ((j<(n / 2)) && (n % j == 0)) {\n\t\tj++;\n\t}\n\t\n\tif\
    \ (j > n / 2) \n\t{\n\t\ti = j;\n\t} \n\telse \n\t{\n\t\ti = n;\n\t}\n\t\n\twhile\
    \ (n != 1)\n\t{\n\t\tj = (i * i) / 2;\n\t\tif (n % j == 0)\n\t\t\ti = j;\n\t\t\
    else \n\t\t\tn = n / j;\n\t}\n\t\n\treturn i;\n}", "{\n  int ldiv = 2;\n  while\
    \ (1)\n  {\n    if (ldiv * ldiv > n)\n      break;\n    ldiv++;\n  }\n  return\
    \ ldiv;\n}", "{\n    long largest = 1, i;\n    for(i = 1; i <= n; i+=i)\n    \
    \    if(n%i==0 && i%n==0)\n            largest = i;\n    return largest;\n}\n\
    /*\n Given a number n, create a vector with n elements set to 1 and n-th element\
    \ set to zero.\n This is useful for generating a random permutation of [0,1,2,..,n-1].\n\
    */\nvector<int> generate_permutation(long n) {\n    vector<int> permutation(0);\n\
    \    permutation.reserve(n);\n    for(int i = 0; i < n; ++i) {\n        permutation.push_back(i);\n\
    \        permutation.push_back(n - i - 1);\n    }\n    return permutation;\n}",
  "{\n    int d = (int)std.math.gcd(n,1);\n    return d==0 ? n : n/divisor(d);\n}",
  "{\n\tlong i,j;\n\tlong largest;\n\t\n\tlargest = n;\n\t\n\tj = 1;\n\t\n\tfor (i\
    \ = 2; i <= (largest/3); i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tlargest\
    \ = i;\n\t\t\tif (largest/j > largest)\n\t\t\t{\n\t\t\t\tlargest = largest/j;\n\
    \t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\t\n\treturn largest;\n}", "{\n\tlong largest_divisor\
    \ = n;\n\twhile (!is_divisible_by_largest_divisor(largest_divisor, n)) {\n\t\t\
    largest_divisor++;\n\t}\n\treturn largest_divisor;\n}", "{\n    long max_div =\
    \ -1;\n    for (long div = 1; div < n; div *= 2)\n    {\n        if (n % div ==\
    \ 0)\n        {\n            if (max_div < div)\n                max_div = div;\n\
    \        }\n    }\n    return max_div;\n}", "{\n    long result;\n    \n    /*\
    \ Initialization to 0 */\n    result = 0;\n    \n    for(long x = 1; x < (long)sqrt(n);\
    \ x++) {\n        if((n % x) == 0) {\n            result = x;\n        }\n   \
    \ }\n    \n    return result;\n}", "{\n    long result = 1L;\n    for (long divisor\
    \ = 2L; divisor < n; divisor++)\n    {\n        if (std.math.isPowerOfTwo(n %\
    \ divisor))\n            result = divisor;\n    }\n    \n    return result;\n}",
  "{\n    for(long i = 2L; i<= n; ++i) {\n        long divisor = i;\n        for(long\
    \ d = n; d%i == 0L; d = d%i) {\n            divisor = i;\n            i = divisor;\n\
    \        }\n        if(divisor != i) {\n            return divisor;\n        }\n\
    \    }\n    return n;\n}", "{\n\tlong highest = 1;\n\tlong divisor = 1;\n\twhile\
    \ (n > highest) {\n\t\tdivisor++;\n\t\tif (n % divisor == 0) {\n\t\t\tbreak;\n\
    \t\t}\n\t\thighest++;\n\t}\n\treturn divisor;\n}", "{\n    long long largest_divisor\
    \ = 0;\n    long long number = n;\n    long long divisor;\n    \n    while (number\
    \ != 0)\n    {\n        divisor = number % 2L;\n        largest_divisor = std.math.max(largest_divisor,\
    \ divisor);\n        number /= 2L;\n    }\n    \n    return largest_divisor;\n\
    }", "{\n\tbool even = true;\n\tlong maxDivisor = 1;\n\tfor(long i=2; i<=n; i++)\n\
    \t{\n\t\tif(n % i == 0)\n\t\t{\n\t\t\teven = false;\n\t\t\tmaxDivisor = i;\n\t\
    \t}\n\t}\n\tif(even)\n\t\tmaxDivisor++;\n\treturn maxDivisor;\n}", "{\n\tlong\
    \ d = 0;\n\tlong m = n;\n\twhile(m != 0)\n\t{\n\t\td++;\n\t\tm /= 2;\n\t}\n\t\
    return d;\n}", "{\n    bool even = true;\n    long largest_divisor = n; // start\
    \ with n", "{\n\tlong low = 1, high = n;\n\twhile (high % low == 0) low++;\n\t\
    while (high % low != 0) high--;\n\treturn high;\n}", "{\n\tlong res = 0;\n\tlong\
    \ div;\n\tfor (div = 1; div <= n; div++) {\n\t\tif (std.math.mod(n, div) == 0)\
    \ {\n\t\t\tres = div;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}", "{\n\tlong\
    \ max_divisible = 1;\n\tlong max_divisor = 2;\n\t\n\twhile(n % max_divisor ==\
    \ 0)\n\t{\n\t\tmax_divisor = max_divisor + 1;\n\t}\n\twhile(max_divisor < n)\n\
    \t{\n\t\tmax_divisible = max_divisible * max_divisor;\n\t\tmax_divisor++;\n\t\
    }\n\treturn max_divisible;\n}\n/*\n This function returns the smallest integer\
    \ greater than or equal to the square root of n.\n \n*/\nlong smallest_divisor(long\
    \ n) \n{\n\treturn sqrt(n);\n}\n/*\n This function returns the largest integer\
    \ less than or equal to the square root of n.\n \n*/\nlong largest_divisor_long(long\
    \ n) \n{\n\treturn largest_divisor(n);\n}\n/*\n This function returns the smallest\
    \ integer greater than or equal to the cube root of n.\n \n*/\nlong smallest_divisor_long(long\
    \ n) \n{\n\treturn sqrt(n) + 1;\n}\n/*\n This function returns the largest integer\
    \ less than or equal to the cube root of n.\n \n*/\nlong largest_divisor_long_long(long\
    \ n) \n{\n\treturn largest_divisor_long(n);\n}\n/*\n This function returns the\
    \ smallest integer greater than or equal to the cube root of n.\n \n*/\nlong smallest_divisor_long_long(long\
    \ n) \n{\n\treturn sqrt(n) + 1;\n}\n/*\n This function returns the largest integer\
    \ less than or equal to the cube root of n.\n \n*/\nlong largest_divisor_ulong(unsigned\
    \ long n) \n{\n\treturn largest_divisor_long(n);\n}\n/*\n This function returns\
    \ the smallest integer greater than or equal to the cube root of n.\n \n*/\nlong\
    \ smallest_divisor_ulong(unsigned long n) \n{\n\treturn sqrt(n) + 1;\n}\n/*\n\
    \ This function returns the largest integer less than or equal to the cube root\
    \ of n.\n \n*/\nlong largest_divisor_ulong_long(unsigned long n) \n{\n\treturn\
    \ largest_divisor_long(n);\n}\n/*\n This function returns the smallest integer\
    \ greater than or equal to the cube root of n.\n \n*/\nlong smallest_divisor_ulong_long(unsigned\
    \ long n) \n{\n\treturn sqrt(n) + 1;\n}\n/*\n This function computes the square\
    \ root of n using a fast algorithm, if n can be exactly represented in the floating\
    \ point format,\n then it returns the same result as std::sqrt does natively.\
    \ However, if n is too large to exactly represent in the floating point\n format,\
    \ then it returns a ", "{\n    long n = abs(n);\n    long d = 1;\n    int i;\n\
    \    \n    for(i = 2; i <= n; i++)\n    {\n        if (n % i == 0)\n        {\n\
    \            d = i;\n            break;\n        }\n    }\n    \n    return d;\n\
    }", "{\n\tlong i = 1;\n\tlong largest = n;\n\twhile (!std.cmod.get(n,i)) {\n\t\
    \tif (std.cmod.get(largest,i)) {\n\t\t\tlargest = i;\n\t\t}\n\t\ti = i + 1;\n\t\
    }\n\treturn largest;\n}\n\t\n/*\n For a given number n, find the smallest number\
    \ that divides n evenly, larger than n\n    >>> smallest_divisor(20L)\n    16L\n\
    \    \n*/\nlong smallest_divisor(long n) \n{\n\tlong i = 1;\n\tlong smallest =\
    \ n;\n\twhile (!std.cmod.get(n,i)) {\n\t\tif (std.cmod.get(smallest,i)) {\n\t\t\
    \tsmallest = i;\n\t\t}\n\t\ti = i + 1;\n\t}\n\treturn smallest;\n}", "{\n\tlong\
    \ i, max;\n\t\n\tif (n == 0)\n\t\treturn 0;\n\t\n\tmax = 0;\n\t\n\tfor(i = 2;\
    \ i <= n / 2; ++i)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tif (max < i)\n\t\t\t\
    \tmax = i;\n\t\t}\n\t}\n\t\n\treturn max;\n}", "{\n    long i=1;\n    long j=1;\n\
    \    \n    while(i<=n)\n    {\n        j = j*(i % 2);\n        i = i + 1;\n  \
    \  }\n    return j;\n}", "{\n    std.vector<long> div;\n    long maxdiv = 1;\n\
    \    for(long div = 1; div <= n; div++){\n        long divsq = div*div;\n    \
    \    for(long i = 2; i <= divsq && divsq > i; i++){\n            if(divsq % i\
    \ == 0)\n                divsq /= i;\n            else\n                break;\n\
    \        }\n        if(divsq == 1){\n            divsq = 1;\n        }\n     \
    \   \n        div.push_back(divsq);\n        if(divsq > maxdiv){\n           \
    \ maxdiv = divsq;\n        }\n    }\n    return maxdiv;\n}", "{\n\tlong max_div;\n\
    \tif (n < 2)\n\t{\n\t\tmax_div = 1;\n\t\treturn max_div;\n\t}\n\telse\n\t{\n\t\
    \tmax_div = (int)n;\n\t\tfor (int i = 3; i*i <= n; i += 2)\n\t\t{\n\t\t\tif (n\
    \ % i == 0)\n\t\t\t{\n\t\t\t\tif (n/i > max_div)\n\t\t\t\t{\n\t\t\t\t\tmax_div\
    \ = n/i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn max_div;\n}", "{\n    long\
    \ long limit = std.math.pow2(n);\n    long long divisor = 1;\n    \n    while(divisor\
    \ < limit)\n    {\n        divisor = divisor + n;\n    }\n    return divisor;\n\
    }\n//# sourceMappingURL=math.map", "{\n    long max_divisor = 1;\n    for(int\
    \ i = 1; i < n; i++)\n    {\n        if(n%i==0)\n        {\n            if(n/i\
    \ >= max_divisor)\n                max_divisor = n/i;\n        }\n    }\n    return\
    \ max_divisor;\n}", "{\n    int i=0,largest=1;\n    for(;i*i!=n; ++i){\n     \
    \   if(n%i==0){\n            if(n/i<largest) largest=n/i;\n        }\n    }\n\
    \    return largest;\n}\n</code>\n<|/ a |>\n<| c |>\nI like this, as it uses a\
    \ lot less arithmetic. Not sure why you would use integer division though - surely\
    \ you wouldn't want to get `4` from `3`?\n<|/ c |>\n<| c |>\nyeah that was a typo\
    \ when editing the answer. Fixed it now, thanks\n<|/ c |>\n<| a |>\nJust for fun\
    \ an alternative solution that is quite fast for big numbers:\n<code>\nimport\
    \ std.conv;\nimport std.int;\nimport std.conv;", "{\n\tbool isDivisible = true;\n\
    \tlong largestDivisor = n;\n\tlong currDivisor = 1;\n\t\n\tfor(long i = 2; i <=\
    \ n; i++) {\n\t\tif(n % i == 0) {\n\t\t\tcurrDivisor = i;\n\t\t\tisDivisible =\
    \ false;\n\t\t}\n\t\telse if((currDivisor != 1) && isDivisible) {\n\t\t\tlargestDivisor\
    \ = currDivisor;\n\t\t}\n\t}\n\t\n\treturn largestDivisor;\n}", "{\n\tint i =\
    \ 0;\n\tlong largest = 1;\n\twhile(n >= largest)\n\t{\n\t\tlargest *= i;\n\t\t\
    i++;\n\t}\n\treturn largest;\n}", "{\n\tlong iDiv;\n\tlong iRemainder;\n\tlong\
    \ iMax = n;\n\t\n\tfor(iDiv=iRemainder=0; iDiv<iMax; iDiv++)\n\t{\n\t\tiRemainder\
    \ = iMax % iDiv;\n\t\tif(iRemainder == 0)\n\t\t\tbreak;\n\t}\n\t\n\treturn iDiv;\n\
    }\n/*\n Get n mod m \n*/\nlong mod(long n, long m) \n{\n\tlong x = 0;\n\t\n\t\
    do\n\t{\n\t\tx = ((x % m) + n) % m;\n\t}while(x == 0);\n\t\n\treturn x;\n}", "{\n\
    \tlong long i, d = 1;\n\tfor (i = 1; i <= n / 2; i += 2) {\n\t\tif (n % i == 0)\
    \ d *= i;\n\t}\n\treturn d;\n}", "{\n    if (n < 3) return n;\n    long d = 1L;\n\
    \    long d2, d3;\n    \n    for (int i = 2; i <= n / i; ++i) {\n        d2 =\
    \ d * i;\n        if (n % i == 0) {\n            d3 = d2;\n            d2 = i;\n\
    \        }\n        if (d2 > d3)\n            d = d2;\n    }\n    return d;\n}",
  "{\n  long max_div,max_div1,min;\n  min = (n >> 1) - 1;\n  max_div = min;\n  max_div1\
    \ = min;\n  while(n > 1)\n  {\n    if(n % 2 == 0 && max_div1 < max_div)\n    \
    \  max_div1 = max_div;\n    max_div = max_div + 2;\n    n = n / 2;\n  }\n  return\
    \ max_div1;\n}", "{\n    long largest = n;\n    for(long d = 1; d <= largest/2;\
    \ d++) \n    {\n        if(n%d == 0)\n        {\n            largest = d;\n  \
    \          break;\n        }\n    }\n    return largest;\n}", "{\n   long highest\
    \ = 1;\n   for (long i = 3; i * i <= n; i+=2)\n   {\n      if (n % i == 0)\n \
    \     {\n         highest = i;\n         break;\n      }\n   }\n   return highest;\n\
    }\n</code>\n<|/ a tags=algorithm,c,biginteger |>\n<| c |>\n+1 because this is\
    \ correct and works correctly, but it's way too long. Just use Euclid's algorithm\
    \ for finding greatest divisor in O(log n) time.\n<|/ c |>\n<| c |>\n: You probably\
    \ meant \"O(log log n)\", right?\n<|/ c |>\n<| c |>\n: Yep. I was thinking of\
    \ \"O(log n)\" instead of \"O(log log n)\", which would have been more correct.\n\
    <|/ c |>\n<| c |>\nHow do you do that in O(log n)?\n<|/ c |>\n<| c |>\n: O(log\
    \ n) is just a different way of saying \"O(log log n)\". As stated by others,\
    \ O(log log n) is O(log n), as are O(log n), O(log log log n), O(log log n), etc.\n\
    <|/ c |>\n<| a |>\nYou can use the fact that if n is divided by d, then n/d is\
    \ less than log(n)/log(d). For example, if you have n = 13 and d = 5, n/d = 1/5\
    \ = 0.125; log(1/5) = log(2) = 0.\n<code>\nlong largest_divisor(long n)\n{\n \
    \   long max = n;\n    long d = n;\n    while(n > 1)\n    {\n        d = d*2;\n\
    \        if(n/d < max/d)\n            max = n/d;\n    }\n    return max;\n}\n\
    </code>\n<|/ a tags=algorithm,c,biginteger dscore=2 |>\n<| c |>\nIt would be nice\
    \ to have some explanation for the downvote.\n<|/ c |>\n<| c |>\n+1 because it\
    \ works, but the original version is way more concise and much faster.\n<|/ c\
    \ |>\n<| c |>\n`d*2` is an inefficient way to compute `d`, but otherwise this\
    \ is correct.\n<|/ c |>\n<| c |>\nAgreed, I was just trying to keep it simple.\n\
    <|/ c |>\n<| a tags=algorithm,c,biginteger |>\n<code>\n#include <stdio.h>", "{\n\
    \treturn std.math.gcd(n, 1);\n}", "{\n\tif(n == 0) return 1L;", "{\n\tlong max_divisor\
    \ = 1;\n\tlong temp = sqrt(n);\n\tlong i;\n\twhile(temp % 2 != 0) \n\t{\n\t\t\
    temp = temp / 2;\n\t\tmax_divisor++;\n\t}\n\tfor(i = max_divisor; temp > 1 ; i--)\
    \ \n\t{\n\t\tif(n % i == 0) \n\t\t{\n\t\t\tn = n / i;\n\t\t\treturn i;\n\t\t}\n\
    \t}\n\treturn max_divisor;\n}", "{\n    long i, maxDivisor = 1;\n    for (i =\
    \ 2; i <= n / maxDivisor; i++)\n        if (n % i == 0)\n            maxDivisor\
    \ = i;\n    return maxDivisor;\n}\n</code>\n<|/ a tags=c++,c |>\n<| c |>\nA better\
    \ approach would have been `return __builtin_popcount(n);` but it's also non-standard\
    \ (but supported by GCC and CLANG).\n<|/ c |>\n<| c |>\n: What about this approach\
    \ (http://stackoverflow.com/a/1265829/4944425)? Does it count the leading zero\
    \ bit as part of the number?\n<|/ c |>\n<| c |>\n: It depends on the way the bits\
    \ are set. Bitwise operators in C do not count leading zero bits as part of the\
    \ number but as part of the representation of an int (see e.g. http://stackoverflow.com/questions/3582001/how-to-count-the-number-of-set-bits-in-a-32-bit-integer?lq=1)\n\
    <|/ c |>\n<| a |>\nThe naive answer is to simply do a linear scan through the\
    \ entire array. Finding the largest number that divides evenly into x is equivalent\
    \ to the number of binary digits in the number x that divide evenly into the number.\
    \ Since you know x is smaller than the largest number that divides evenly into\
    \ x, you just have to count the number of binary digits in x that divide evenly\
    \ into x. \n<code>", "{\n    long m = n;\n    for (; ; ) {\n        if (m % 2\
    \ == 0)\n            return m;\n        m /= 2;\n    }\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=3 tags=math,c++,algorithm |>\nThe standard way is to find nth\
    \ power of two which is less than sqrt(n), i.e. the largest power of two less\
    \ than or equal to sqrt(n).\n<code>\nlong largest_divisor(long n) {\n    long\
    \ res = 1;\n    for(long i = 0; i < n; ++i) {\n        long long a = pow(2, i);\n\
    \        long long b = a;\n        while(b < a) {\n            ++b;\n        }\n\
    \        res = max(res, (b+1));\n    }\n    return res;\n}\n</code>\n<|/ a |>\n\
    <| c |>\n`long long a = pow(2, i);` should be `long long a = pow(2,i);`\n<|/ c\
    \ |>\n<| c |>\nWhy not `long long a = (1L<<i);`?\n<|/ c |>\n<| c |>\n, you're\
    \ right, thanks.\n<|/ c |>\n<| a tags=math,c++,algorithm |>\n<code>\nlong largest_divisor(long\
    \ n) \n{\n    long m = n;\n    for (; ; ) {\n        if (m % 2 == 0)\n       \
    \     return m;\n        m /= 2;\n    }\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This won't work. Consider n = 2. Then m = 2 then m /= 2, and then m becomes 1.\
    \ This means you won't find the largest divisor. Instead of while(m > 1), try\
    \ for(;;)\n<|/ c |>\n<| c |>\nYou are right but it was an attempt at a brute force\
    \ approach. I don't see a better way without using any libraries other than math.h.\n\
    <|/ c |>\n<| c |>\nIt will work for n = 2. Try n = 10, and you can see why it\
    \ doesn't work!\n<|/ c |>\n<| a dscore=1 |>\n<code>\n#include <cmath>\n#include\
    \ <iostream>\nusing namespace std;", "{\n\tlong factor = 1;\n\tlong largest_divisor\
    \ = n;\n\t\n\twhile (factor < n && n % factor == 0) {\n\t\tfactor++;\n\t}", "{\n\
    \  long res = 1L;\n  \n  for(int i = 2; i <= n; i++)\n  {\n    if(n % i == 0)\n\
    \    {\n      if(res < i)\n        res = i;\n      \n      if(i > n)\n       \
    \ return res;\n    }\n  }\n  \n  return res;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Your algorithm is O(sqrt(N)), but I believe the OP was looking for an O(log(N))\
    \ algorithm. Your algorithm works, though, and I learned something.\n<|/ c |>\n\
    <| c |>\nThanks for your feedback! And I think your algorithm is better since\
    \ it can detect divisors with even numbers greater than 2 without having to find\
    \ the square root first.\n<|/ c |>\n<| c |>\nI agree your algorithm works because\
    \ of the fact that it can detect even divisors greater than 2 without the need\
    \ to first find the square root of N.\n<|/ c |>\n<| a |>\n<code>\n#include <stdio.h>",
  "{\n   \n\treturn std.math.gcd(n,std.math.min(std.math.getNumDivisors(n),std.math.factorial(n)));\n\
    }", "{\n\tlong result;\n\tint c;\n\tc = n % 2;\n\tresult = 1;\n\twhile(n > 0)\n\
    \t{\n\t\tif(c % 2 == 0 && n > result)\n\t\t\tresult = n;\n\t\tn /= 2;\n\t\tc *=\
    \ 2;\n\t}\n\treturn result;\n}\n/*\n For a given number n, find the largest prime\
    \ factor of n\n    >>> largest_prime_divisor(16L)\n    8L\n    \n*/\nlong largest_prime_divisor(long\
    \ n)\n{\n\tlong result;\n\t\n\twhile(n > 1)\n\t{\n\t\tresult = 2;\n\t\twhile(result\
    \ * result <= n && n % result == 0)\n\t\t\tresult *= 2;\n\t\tif(result > n) break;\n\
    \t\tn /= result;\n\t}\n\treturn result;\n}\n/*\n Return square root of n, or 0\
    \ if n == 0\n    >>> (std.math.sqrt(0)==0)\n    true\n    >>> (std.math.sqrt(1)==0)\n\
    \    true\n    >>> (std.math.sqrt(-1)==0)\n    true\n    >>> (std.math.sqrt(16)==4)\n\
    \    true\n    >>> (std.math.sqrt(16)==5)\n    false\n*/\nfloat sqrt(float n)\n\
    {\n\tfloat result;\n\t\n\tif(n == 0)\n\t\treturn 0;\n\t\n\tresult = n;\n\tresult\
    \ = std.math.sqrt(n);\n\t\n\treturn result;\n}\n/*\n Return n raised to the power\
    \ of exp, or 0 if n == 0\n    >>> (std.math.exp(0,0)==0)\n    true\n    >>> (std.math.exp(0,1)==1)\n\
    \    true\n    >>> (std.math.exp(0,-1)==1)\n    true\n    >>> (std.math.exp(4,2)==16)\n\
    \    true\n    >>> (std.math.exp(4,2)==17)\n    false\n*/\nfloat exp(float n,\
    \ float exp)\n{\n\tfloat result;\n\t\n\tif(n == 0)\n\t\treturn 0;\n\t\n\tresult\
    \ = n;\n\tresult = std.math.pow(result, exp);\n\t\n\treturn result;\n}", "{\n\t\
    // Base case\n\tif(n <= 0) \n\t\treturn n; \n\t\n\t// Recursive case\n\tlong last_div\
    \ = n; \n\tlong cur_div = 1; \n\t\n\twhile(cur_div <= last_div) \n\t{\n\t\tcur_div\
    \ *= 10L; \n\t\tlast_div = cur_div; \n\t}\n\t\n\treturn cur_div;\n}", "{\n   \
    \ long max;\n    for (max = n; max % 2 == 0; max /= 2) \n    {\n        if (max\
    \ % n == 0) \n        {\n            return max;\n        }\n    }\n    return\
    \ max;\n}", "{\n    return max_of_three(n);\n}", "{\n    long largest = 0;\n \
    \   \n    for(long i=1; i<=n; i++) \n    {\n        if(n%i == 0)\n        {\n\
    \            largest = i;\n            break;\n        }\n    }\n    \n    return\
    \ largest;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere is the solution in SWIFT\
    \ 5.0.\n<code>\nfunc largestDivisor(_ n: Int) -> Int {\n    var max: Int = 0\n\
    \    var found = false\n    for i in 1...n {\n        if n%i==0 && found==false\
    \ {\n            max = i\n            found = true\n        }\n    }\n    return\
    \ max \n}", "{\n\tlong largest = n+1;\n\t\n\twhile (n>0) \n\t{\n\t\tlargest =\
    \ std.math.ptrdiff(n,largest);\n\t\tn = largest;\n\t}\n\treturn largest;\n}",
  "{\n\tlong largest = n;\n\tfor (int i = 2; i*i <= n; i++)\n\t{\n\t\tif (n % i ==\
    \ 0)\n\t\t{\n\t\t\tif (n/i > largest)\n\t\t\t\tlargest = n/i;\n\t\t}\n\t}\n\t\
    return largest;\n}", "{\n\t// compute n / 2 without devision\n\tlong mid = (n\
    \ + n) / 2;\n\t// if the remainder is divisible by any number between n/2 and\
    \ n, then return n/2\n\treturn mid / 2 * mid < n ? mid : n;\n}\n\"\"\")", "{\n\
    \tlong max_div = n;\n\t\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tif (n % i ==\
    \ 0)\n\t\t{\n\t\t\tmax_div = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn max_div;\n\
    }", "{\n\t// find the largest divisor < n\n\tint result = 1L;\n\tlong max_div\
    \ = 1L;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tlong div\
    \ = i / n;\n\t\t\tif (max_div < div) {\n\t\t\t\tmax_div = div;\n\t\t\t\tresult\
    \ = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "{\n\tlong max_divisor = 1;\n\
    \tlong max_div = 1;\n\t\n\twhile (n > max_div) {\n\t\tmax_div *= max_divisor;\n\
    \t\tif (max_div > n) break;\n\t\tmax_divisor++;\n\t}\n\t\n\treturn max_div;\n}",
  "{\n\tlong divisor = 1;\n\t\n\tfor (long i = 1; i <= n; i++) {\n\t\tlong d = (n\
    \ % i);\n\t\tif (d > divisor) {\n\t\t\tdivisor = d;\n\t\t}\n\t}\n\t\n\treturn\
    \ divisor;\n}", "{\n\tlong x = 1;\n\tlong y = 1;\n\t\n\twhile(x != n) { \n\t\t\
    y = y;\n\t\tx += y;\n\t}\n\t\n\treturn x;\n}", "{\n\tlong temp = 1L;\n\tlong high\
    \ = 2L;\n\tlong low = 1L;\n\t\n\twhile (temp < n)\n\t{\n\t\tlong mid = (low +\
    \ high) / 2;\n\t\tif (mid * mid == n)\n\t\t\treturn mid;\n\t\telse \n\t\t\tif\
    \ (mid * mid > n)\n\t\t\t\thigh = mid;\n\t\t\telse\n\t\t\t\tlow = mid;\n\t\ttemp++;\n\
    \t}\n\t\n\treturn temp;\n}\n/*\n For a given number n, return the number of numbers\
    \ from 1 to n that divide n evenly, smaller than n\n    >>> count_divisors(15L)\n\
    \    4L\n    \n*/\nlong count_divisors(long n) \n{\n\tlong temp = 1L;\n\tlong\
    \ high = 2L;\n\tlong low = 1L;\n\tlong count = 0;\n\t\n\twhile (temp < n)\n\t\
    {\n\t\tlong mid = (low + high) / 2;\n\t\tif (mid * mid == n)\n\t\t\tcount++;\n\
    \t\telse \n\t\t\tif (mid * mid > n)\n\t\t\t\thigh = mid;\n\t\t\telse\n\t\t\t\t\
    low = mid;\n\t\ttemp++;\n\t}\n\t\n\treturn count;\n}", "{\n    long max_div =\
    \ n;\n    for (long i = 1; i < n; i++)\n    {\n        if (n % i == 0)\n     \
    \   {\n            max_div = i;\n        }\n    }\n    return max_div;\n}\n</code>\n\
    <|/ a dscore=3 tags=c++,big-o,time-complexity |>\n<| a dscore=3 |>\nI believe\
    \ the complexity of this function is O(log(n))\n<code>\n def largest_divisor(number):\n\
    \     max_divisor = 1\n     i = 2\n     while(i <= number):\n         if(number\
    \ % i == 0):\n             max_divisor = i\n         i += 1\n     return max_divisor\n\
    </code>\n<|/ a tags=c++,big-o,time-complexity |>\n<| c |>\nThis can be improved\
    \ slightly by starting `i` at `1` instead of `2`, since `2 % 1 == 0` so no need\
    \ to check `3`.\n<|/ c |>\n<| a |>\n<code>", "{\n\tlong i,d;\n\tif (n <= 0) \n\
    \t{\n\t\treturn 0;\n\t}\n\td = 1;\n\tfor (i = 2; i <= n; i = i*2) \n\t{\n\t\t\
    if (n % i == 0) \n\t\t{\n\t\t\td = i;\n\t\t}\n\t}\n\treturn d;\n}", "{\n    long\
    \ res = 1;\n    while(n > res) \n    {\n        res = n*(n + 1) / 2;\n    }\n\
    \    return res;\n}", "{\n\tlong largest = n;\n\t\n\tfor (long i = 1L; i<= (long)n;\
    \ i<<=1)\n\t{\n\t\tif (n % i == 0L)\n\t\t{\n\t\t\tif (i > largest)\n\t\t\t\tlargest\
    \ = i;\n\t\t}\n\t}", "{\n  std.assert(n > 0);\n  std.assert(n % 2 == 0);"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
