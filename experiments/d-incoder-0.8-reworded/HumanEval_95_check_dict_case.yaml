name: HumanEval_95_check_dict_case
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given an associative array,\
  \ return true if all keys are strings in lower \n    case or all keys are strings\
  \ in upper case, else return false.\n    The function should return false is the\
  \ given associative array is empty.\n    Examples:\n    >>> check_dict_case([\"\
  a\": \"apple\", \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
  a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    false\n   \
  \ >>> check_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n\
  \    false\n    >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\"\
  : \"Houston\"].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\"\
  , \"ZIP\": \"12345\"].nullable)\n    true\n    \n*/\nbool check_dict_case(Nullable!(string[string])\
  \ dict) \n"
tests: "unittest\n{\n    alias candidate = check_dict_case;\n\n    assert(candidate([\"\
  p\": \"pineapple\", \"b\": \"banana\"].nullable) == true);\n    assert(candidate([\"\
  p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"].nullable) == false);\n\
  \    assert(candidate([\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"\
  ].nullable) == false);\n    assert(candidate([\"Name\": \"John\", \"Age\": \"36\"\
  , \"City\": \"Houston\"].nullable) == false);\n    assert(candidate([\"STATE\":\
  \ \"NC\", \"ZIP\": \"12345\"].nullable) == true);\n    assert(candidate([\"fruit\"\
  : \"Orange\", \"taste\": \"Sweet\"].nullable) == true);\n    assert(candidate(Nullable!(string[string]).init)\
  \ == false);\n}\nvoid main(){}"
completions: ["{\n    foreach (key key, value dict) \n    {\n        bool is_string\
    \ = (value ?? \"\").length == 0;\n        if (!is_string)\n        {\n       \
    \     auto lower_string = value.toCString();\n            auto upper_string =\
    \ lower_string.upcase();\n            if (key != upper_string)\n            {\n\
    \                return false;\n            }\n        }\n    }\n    return true;\n\
    }", "{\n    var n = 0;\n    var first = true;\n    for (var v in dict)\n    {\n\
    \        if (v is int)\n        {\n            if (first)\n            {\n   \
    \             first = false;\n                continue;\n            }\n     \
    \       n++;\n        }\n        else if (v is string)\n        {\n          \
    \  if (first)\n            {\n                first = false;\n               \
    \ continue;\n            }\n            n++;\n        }\n        else\n      \
    \  {\n            return false;\n        }\n    }\n    if (n == 0)\n    {\n  \
    \      return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\
    \"\"\"\n</cell>\n<text>\nis_valid_int", "{\n    foreach(k, v) in dict \n    {\n\
    \        bool strcase = is(lower(k), lower(v));\n        bool strupper = is(upper(k),\
    \ upper(v));\n        if(!strcase && !strupper) return false; // return false\
    \ is empty \n    }\n    return true;\n}", "{\n    if (dict.isNull)\n    {\n  \
    \      throw new Exception(\"invalid empty dict\");\n    }\n    KeyValuePair!(string,\
    \ string) kv;\n    for (KeyValuePair!(const string& key, const string& val) in\
    \ dict)\n    {\n        if (!isLower(key))\n        {\n            return false;\n\
    \        }\n        if (!isUpper(key))\n        {\n            return false;\n\
    \        }\n    }\n    return true;\n}", "{\n    return !(dict.len() == 0);\n}",
  "{\n    foreach(k, v: dict)\n    {\n        if(v.isNull)\n        {\n          \
    \  return false;\n        }\n        if(!v.asString().isLower())\n        {\n\
    \            return false;\n        }\n    }\n    \n    return true;\n}", "{\n\
    \    return !dict.isNull;\n}", "{\n    if(dict.length == 0) \n        return true;\n\
    \    \n    auto it = dict.begin();\n    auto itEnd = dict.end();\n    \n    for(;\
    \ it != itEnd; ++it)\n    {\n        if(it.key.islower() != it.value.islower())\n\
    \            return false;\n    }\n    \n    for(; it != itEnd; ++it)\n    {\n\
    \        if(it.key.isupper() != it.value.isupper())\n            return false;\n\
    \    }\n    \n    return true;\n}\n\"\"\"", "{\n    int i = 0;\n    while (!is_null(dict[i]))\n\
    \    {\n        if (!is_null(dict[i]))\n        {\n            if (dict[i].islower())\n\
    \                return false;\n            else if (dict[i].isupper())\n    \
    \            return false;\n        }\n        ++i;\n    }\n    return true;\n\
    }", "{\n  int count = 0;\n  for (auto it : dict) {\n    string key = it.first.as_string();\n\
    \    string val = it.second.as_string();\n    if (key == \"State\" || key == \"\
    Zip\")\n      count++;\n    else if (key == \"Name\" || key == \"Age\")\n    \
    \  count++;\n  }\n  if (count == 0) {\n    return true;\n  } else {\n    return\
    \ false;\n  }\n}", "{\n    foreach(key in dict) {\n        if(!key.key.hasCaseInsensitive())\
    \ {\n            return false;\n        }\n        if(!key.value.hasCaseInsensitive())\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    This has the additional advantage that you can easily test if the given value\
    \ is nullable or not.\n<code>", "{\n    return is(dict.keys);\n}", "{\n    if\
    \ (dict.isNull)\n    {\n        return false;\n    }\n    var keys = dict.getKeys();\n\
    \    for (var i = 0, len = keys.size(); i < len; ++i)\n    {\n        string key\
    \ = keys[i];\n        if (key.isLower())\n        {\n            return true;\n\
    \        }\n        if (key.isUpper())\n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}", "{\n    if (dict == null) {\n      \
    \  return false;\n    }", "{\n    // TODO: implement\n    return true;\n}", "{\n\
    \    for (auto key : dict)\n    {\n        auto key_case = key.key();\n      \
    \  if (key_case != key_case.toLower())\n            return false;\n    }\n   \
    \ return true;\n}\n</code>\n<|/ a tags=d,static-methods,associative-array,dictionary\
    \ |>\n<| a dscore=2 tags=d,static-methods,associative-array,dictionary |>\nWith\
    \ DMD and std.algorithm.search, it's very simple:\n<code>\nimport std.algorithm;",
  "{\n    return !is_null(dict);\n}", "{\n    var _case = dict[\"A\"] == null && dict[\"\
    B\"] == null && dict[\"C\"] == null;\n    return _case;\n}", "{\n    forall key\
    \ in dict[string]\n        if\n            not(isLower(key) || isUpper(key))\n\
    \        then \n            false\n        else \n            true\n}\n\"\"\"\
    )\n    return CheckDict({\n        \"nullable\": Nullable(lambda key: len(key)\
    \ == 0)\n    })", "{\n    for(auto kv : dict)\n    {\n        if(kv.first().length\
    \ != kv.second().length())\n        {\n            return false;\n        }\n\
    \    }\n    return true;\n}\n</cell>\n<cell>\n// Test", "{\n    foreach (key,\
    \ val) in dict do\n    {\n        bool result = toLower(key) == toLower(val);\n\
    \        if (!result)\n            return false;\n    }", "{\n    foreach(k in\
    \ dict) \n    {\n        bool is_upper = k.getString().getChar(0) >= 'A' && k.getString().getChar(0)\
    \ <= 'Z';\n        if(!is_upper) \n        {\n            return false;\n    \
    \    }\n    }\n    return true;\n}", "{\n    foreach(k, v) \n    {\n        bool\
    \ flag = false;\n        if(!dict?[k]) \n        {\n            flag = true;\n\
    \        }\n        else if(!dict?[k].isUppercase) \n        {\n            flag\
    \ = true;\n        }\n        if(flag)\n        {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nTo make it more clear to understand I created the following function, which\
    \ takes array of associative array and checks if all the keys are lowercase\n\
    <code>\nimport std.algorithm; \nimport std.array;\nimport std.conv;\nimport std.conv;\n\
    import std.string;", "{\n    for(Keys key: dict)\n    {\n        if(!(isInfix(key)\
    \ && isCaseInsensitive(key)))\n        {\n            return false;\n        }\n\
    \    }\n    return true;\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nYou\
    \ can write a simple function to check the existence of any key in a dictionary:\n\
    <code>\ndef exist(dict, key)\n    dict.has_key?(key)\nend\n</code>\n<|/ a tags=null,ruby,hash\
    \ |>\n<| a dscore=2 tags=null,ruby,hash |>\nUsing Ruby 2.5.x, you can use the\
    \ Hash#key? method.\n<code>\nd = { \"a\" => 1, 2 => 3 }", "{\n    if (dict.isNull)\
    \ return true;\n    auto dict_of_strings = dict.asMap();\n    for (auto pair :\
    \ dict_of_strings) {\n        if (!pair.second.isString) \n            return\
    \ false;\n        if (pair.second.asString().length() != 1) \n            return\
    \ false;\n    }\n    return true;\n}", "{\n    return !dict.isEmpty && dict.keys.all(key\
    \ => \n        {\n            if (toLower(key).equals(toLower(toUpper(key))))\n\
    \                return true;\n            else\n                return false;\n\
    \        });\n}\n</code>\n<|/ a tags=swift dscore=3 |>\n<| a dscore=3 tags=swift\
    \ |>\nUsing Swift 4.2\n<code>\nfunc isNullable<Value: Hashable, HashableKey>(fromDictionary\
    \ dictionary: [HashableKey: Value?]) -> (Bool, Dictionary<HashableKey, Value>?)\
    \ {\n    guard let keys = dictionary.keys,\n        keys.contains(where: { $0.hashValue\
    \ == HashableKey.hashValue }),\n        let lastKey = keys.last,\n        let\
    \ lastValue: Value = dictionary[keys.last!] else {\n            return (true,\
    \ nil)\n    }\n    guard let firstValue = dictionary[keys.first!] else {\n   \
    \     return (true, Dictionary<HashableKey, Value>(nil))\n    }\n    return (true,\
    \ Dictionary<HashableKey, Value>([lastKey : lastValue, firstKey : firstValue]))\n\
    }\n</code>\n<|/ a |>\n<| a dscore=2 |>\nHere is a simple solution based on Antonio's\
    \ answer. It avoids using a dictionary at all as it is just a key-value pair array.\n\
    <code>\nfunc isNullable<Value: Hashable, HashableKey>(fromDictionary dictionary:\
    \ [HashableKey: Value?]) -> (Bool, Dictionary<HashableKey, Value>?) {\n    guard\
    \ let keys = dictionary.keys,\n        keys.contains(where: { $0.hashValue ==\
    \ HashableKey.hashValue }),\n        let lastKey = keys.last,\n        let lastValue:\
    \ Value = dictionary[keys.last!] else {\n            return (true, nil)\n    }\n\
    \    guard let firstValue = dictionary[keys.first!] else {\n        return (true,\
    \ Dictionary<HashableKey, Value>(nil))\n    }\n    return (true, Dictionary<HashableKey,\
    \ Value>([lastKey : lastValue, firstKey : firstValue]))\n}\n</code>\n<|/ a tags=swift\
    \ |>\n<| a dscore=1 tags=swift |>\n<code>\nfunc isNullable<Value: Hashable>(fromDictionary\
    \ dictionary: [Value : Value?]) -> (Bool, Dictionary<Value, Value>?) {\n    let\
    \ values = dictionary.values.filter({ $0 == nil })\n    return (values.isEmpty,\
    \ values != nil && Dictionary <Value, Value>(dictionary: dictionary.map {\n  \
    \      (_, value) -> Value in (value: $0, value: value)\n    }))\n", "{\n    if(\
    \ !dict.isNotNull() )\n    {\n        return false;\n    }\n    \n    // If dict\
    \ is empty all keys must be in lower case.\n    // If dict is empty all keys must\
    \ be in upper case.\n    foreach( k : dict.keys() )\n    {\n        if( !string_compare(k.as_string(),\
    \ k.as_string().to_lowercase()) )\n        {\n            return false;\n    \
    \    }\n        if( !string_compare(k.as_string(), k.as_string().to_uppercase())\
    \ )\n        {\n            return false;\n        }\n    }\n    \n    return\
    \ true;\n}\n\"\"\"\n}", "{\n    foreach (key, val) in dict {\n        if (!(is_string(key)\
    \ && is_string(val))) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n'''\n)", "{\n    foreach(string k in dict.keys) {\n        auto case1\
    \ = toupper(k);\n        auto case2 = k.toUpper();\n        if (case1 != case2\
    \ || dict[k] == null) \n            return false;\n    }\n    return true;\n}",
  "{\n    foreach(k in dict) {\n        if (!is_string(k)) return false; // all keys\
    \ not strings\n    }\n    return !dict.isNull;\n}\n\"\"\")\n    \ndef gen_stl_map(template):\n\
    \    stl_map_t = template.add_type('stl_map_t', \"\"\"\ntypedef map<string, int>\
    \ stl_map_t;\n\"\"\")", "{\n    assert(!dict.isNull());\n    int count = 0;\n\
    \    foreach(string key, dict) \n    {\n        if (count(key.c_str()) == 0)\n\
    \        {\n            count = count + 1;\n        }\n    }\n    return count\
    \ == 0;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nBased on your requirement, it\
    \ looks like you just want to check for existence of keys, and you are not interested\
    \ in checking their values (i.e. nullability of a key)\nSo you just need to check\
    \ for existence of keys in your associative array and you are done\n<code>", "{\n\
    \    return !dict.isEmpty && dict[\"a\"] == \"apple\" && dict[\"A\"] == \"banana\"\
    ;\n}\n</code>\n<|/ a tags=d,struct,associative-array,arrays,std |>\n<| c |>\n\
    The last example in the question is a good one. This should be made more explicit.\
    \ `const` may have some side effects.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ your dictionary keys may have numeric suffixes like `1`, `2`, `3`.  Also, I\
    \ don't think this solution correctly handles duplicate keys.\n<|/ c |>\n<| c\
    \ |>\nI fixed my solution. It also handles duplicate keys.\n<|/ c |>\n<| c |>\n\
    `!dict.isEmpty` looks unnecessary in the loop condition, since `dict[]` returns\
    \ `null` if the key doesn't exist.\n<|/ c |>\n<| a dscore=2 |>\nIf your array\
    \ is not too big, you can simply loop through it and check the keys for case-sensitive\
    \ matches:\n<code>", "{\n    bool valid = true;\n    for (int i=0; i<len(dict);\
    \ ++i)\n    {\n        string key = dict[i].first;\n        string value = (string)dict[i].second;\n\
    \        \n        if (key.equals(\"state\") || key.equals(\"postalcode\"))\n\
    \            continue;\n        \n        if (!value.isEmpty())\n            valid\
    \ = false;\n    }\n    return valid;\n}", "{\n\tforeach(string str in dict){\n\
    \t\tint len = length(dict[str]);\n\t\tif (len != 1){\n\t\t\terror(\"Invalid dictionary\
    \ for check_dict_case\");\n\t\t}\n\t\tif (isupper(str) || islower(str)){\n\t\t\
    \treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "{\n    foreach (key, value)\
    \ in dict do\n    {\n        if (std.typecons.isLower(key) || std.typecons.isUpper(key))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    \"\"\"\n</cell>\n<cell>\n!./bin/bash ../Helper/BiomarkerGuy/Helper/Scripts/check_dict_case.sh\n\
    </cell>\n<text>\ncheck_dict_case({\"a\": \"apple\", \"b\": \"banana\"})", "{\n\
    \    return !dict.hasKey(null);\n}\n\"\"\"", "{\n    \n    for(auto &v: dict)\n\
    \        if(!is_str(v) && is_str(v.value) || !is_str(v) && !is_str(v.value))\n\
    \            return false;\n    return true;\n}", "{\n    if(!dict.isNull)\n \
    \   {\n        bool result = true;\n        for(auto v: dict)\n        {\n   \
    \         if(!v.key.isUpperCase && v.key.isLowercase)\n            {\n       \
    \         result = false;\n                break;\n            }\n           \
    \ else if(v.key.isUpperCase && !v.key.isLowercase)\n            {\n          \
    \      result = false;\n                break;\n            }\n        }\n   \
    \     return result;\n    }\n    else\n    {\n        return false;\n    }\n}",
  "{\n\tauto iter = dict.begin();\n\tauto end= dict.end();\n\tfor (; iter != end;\
    \ ++iter) {\n\t\tif (!(iter.key().toLower() == iter.key().toUpper())) return false;\n\
    \t}\n\treturn true;\n}", "{\n    foreach(key in dict, value){\n        if (!strcasecmp(key.get(),\
    \ key.get().c_str()))\n            return false;\n        if (typeof(dict[key])\
    \ <> typeof(Nullable!(string[string]))) return false;\n    }\n    return true;\n\
    }\n</code>\nIt uses the fact that Nullable is a value type that can be null. \n\
    It also uses the fact that an std::map has a type that is an std::pair and that\
    \ std::pair has a type that is std::pair and that is also Nullable!(string[string]).\n\
    <|/ a tags=dictionary,python,c++,boost |>\n<| c |>\nHow would the code look if\
    \ we wanted to add `if (key.get().empty()) return false; else return true;`?\n\
    <|/ c |>\n<| c |>\n, I added a second version. It should now be clear.\n<|/ c\
    \ |>\n<| a dscore=2 |>\nI modified ChristopheD's solution slightly to handle key\
    \ collisions:\n<code>", "{\n    if(!dict)\n    {\n        throw new ArgumentError.value(dict,\
    \ \"dict\", \"Dictionary cannot be empty\");\n    }\n    for (key in dict)\n \
    \   {\n        if (std.isLower(key))\n        {\n            return true;\n  \
    \      }\n        if (std.isUpper(key))\n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}", "{\n  // TODO: Complete this function\n\
    \  return true;\n}", "{\n    if (dict.empty()) return false;", "{\n\tforeach(k,\
    \ v) dict += k as string;\n\treturn dict[\"A\"] != dict[\"a\"] || dict[\"B\"]\
    \ != dict[\"b\"];\n}", "{\n    foreach(k, v) \n    {\n        if (k as string\
    \ in Lower(k)) \n        {\n            if (k as string in Upper(k))\n       \
    \     {\n                return false;\n            }\n            else\n    \
    \        {\n                return true;\n            }\n        }\n        else\n\
    \        {\n            return true;\n        }\n    }\n    return false;\n}",
  "{\n    if(!dict.is_empty())\n    {\n        foreach(k, v |v in dict)\n        {\n\
    \            if(is_lower(k) || is_upper(k))\n                return true;\n  \
    \      }\n    }\n    return false;\n}", "{\n    if (dict == null) {\n        return\
    \ true;\n    }\n    auto keyList = dict.keys;\n    auto valueList = dict.values;\n\
    \    auto keyLength = (size_t)keyList.size();\n    auto valueLength = (size_t)valueList.size();\n\
    \    // If there are any non-string or non-number keys, return false\n    for\
    \ (size_t i = 0; i < keyLength; ++i) {\n        if (!is_string_or_number(keyList[i]))\
    \ {\n            return false;\n        }\n    }\n    for (size_t i = 0; i < valueLength;\
    \ ++i) {\n        if (!is_string_or_number(valueList[i])) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}", "{\n    return !std.typecons.is_nil(dict.key)\
    \ || !std.typecons.is_nil(dict.value.keys());\n}\n'''\nchecker_dict['check_dict_case']\
    \ = check_dict_case", "{\n    if (dict.IsEmpty) \n    { \n        return false;\
    \ \n    } \n    \n    for (auto& [key, value] : dict)\n    {\n        if (!(is_string(value)\
    \ || is_string(key)))\n        {\n            return false; \n        } \n   \
    \ }\n    return true; \n} \n/*", "{\n    if (dict.isNull) return true;\n    auto\
    \ lowercase = [](string s) { return s.lower(); };\n    auto uppercase = [](string\
    \ s) { return s.upper(); };\n    return std::all_of(dict.dict.begin(), dict.dict.end(),\
    \ [&](pair<string, string> p){\n        return p.first.isNull() && p.second.isNull()\
    \ ? true :\n            check(lowercase(p.first), p.second) ||\n            check(uppercase(p.first),\
    \ p.second);\n    });\n}\n</code>\n<|/ a tags=dictionary,c++,stl,stdmap |>\n<|\
    \ c |>\nThis is a much more idiomatic approach than the one I proposed.\n<|/ c\
    \ |>\n<| c |>\nIt actually uses less memory then my solution -- I used `std::set`\
    \ as I couldn't use my own hash function and I didn't want to use Boost hash_set\
    \ as it is unavailable in some environments\n<|/ c |>\n<| c |>\nI wrote a similar\
    \ solution a while back using C++03 constructs and I believe it can handle any\
    \ type with implicit conversion to `string`.  Though it's also more complicated\
    \ than it needs to be.  I'll add it back in if it doesn't work\n<|/ c |>\n<| c\
    \ |>\nI added a version that works with C++03 constructs, and also an example\
    \ showing that it works with non-`string` keys\n<|/ c |>\n<| a tags=dictionary,c++,stl,stdmap\
    \ |>\nI think it's best to use an unordered_map or unordered_set - no doubt you'll\
    \ get better performance.\n<|/ a dscore=1 |>\n<| c |>\nBut it uses more memory,\
    \ since each entry must be stored twice. Also, if you use custom hash functions\
    \ with unordered_set/unordered_map you may get incorrect results (see http://www.boost.org/doc/libs/1_45_0/doc/html/unordered/containers.html)\n\
    <|/ c |>\n<| c |>\n: Yes, but with C++0x unordered_map/unordered_set can take\
    \ an allocator as a template parameter.\n<|/ c |>\n<| c |>\n: I believe the memory\
    \ usage is pretty much the same, since a map or set has pointers pointing to its\
    \ elements.\n<|/ c |>\n<| c |>\n: Also, just realized that boost::unordered_map/unordered_set\
    \ can take an allocator as a template parameter.\n<|/ c |>\n<| a dscore=1 |>\n\
    I'd like to throw in something based on Brad's ideas that I've used before.  It's ",
  "{\n    auto keys = dict.keys();\n    for(auto itr = keys.begin(); itr != keys.end();\
    \ ++itr) {\n        auto ktype = key_type(*itr);\n        auto vtype = value_type(*itr);\n\
    \        if(ktype == std.typecons.std_string_t.type()) {\n            if(vtype\
    \ == std.typecons.std_string_t.type()) {\n                // all keys are in lower\
    \ case\n            } else {\n                // all keys are in upper case\n\
    \            }\n        } else {\n            if(vtype == std.typecons.std_string_t.type())\
    \ {\n                // all keys are in upper case\n            } else {\n   \
    \             // all keys are in lower case\n            }\n        }\n    }\n\
    \    return dict.has_elements();\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=swift,dictionary,associative-array,arrays\
    \ |>\n<code>\npublic static func isDictionary(_ object: Any?) -> Bool {\n    switch\
    \ object! {\n    case is Dictionary<String, Any?>:\n        return true\n    case\
    \ is Array:\n        return false\n    case is String:\n        return true\n\
    \    case is Int:\n        return false\n    case is Float:\n        return false\n\
    \    case is Dictionary:\n        return false\n    case is [AnyObject]:\n   \
    \     return false\n    case is AnyObject:\n        return false\n    default:\n\
    \        return false\n    }\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks.\
    \ I added this as another answer to this question: https://stackoverflow.com/a/63785627/1888901\n\
    <|/ c |>\n<| a dscore=2 |>\nSwift 5.1 added two new methods to Dictionary to check\
    \ whether it contains a key or value, and whether it contains an entry for the\
    \ key or value. These are all checked at compile time, rather than run time, so\
    \ it can be used for static type checking.\n<code>\nextension Dictionary {\n \
    \   func containsKey(_ key: Key) -> Bool\n    {\n        return contains(key)\
    \ || self[key].isEmpty == false\n    }", "{\n    if (dict.isEmpty()) return false;",
  "{\n    if (dict.isEmpty)\n        throw \"check_dict_case() called with empty associative\
    \ array!\";\n    for (KeyValuePair!(string,string) entry in dict)\n    {\n   \
    \     if (entry.key.equalsCaseInsensitive(\"lower\")) // convert key from upper\
    \ to lower\n            return true;\n        else if (entry.key.equalsCaseInsensitive(\"\
    upper\")) // convert key from lower to upper\n            return false;\n    \
    \    else \n            throw \"KeyValuePair!(string,string) dictionary does not\
    \ contain correct key name!\";\n    }\n    return true;\n}", "{\n    int: foreach\
    \ ( key, value ) in dict do \n    {\n        // ignore keys that aren't strings\n\
    \        if( key !is string ) then\n            return false;\n        // ignore\
    \ keys that aren't all lower case\n        if( value !is string[string] ) then\n\
    \            return false;\n        \n        if( value !islower ) then\n    \
    \        return false;\n        \n        if( value !isequal value.toUpper ) then\n\
    \            return false;\n        \n    } \n    return true;\n}", "{\n    foreach(k,\
    \ v) dict += Nullable!(string) k + Nullable!(string) v;\n    \n    int cnt = 0;\n\
    \    \n    foreach(k, v) if (k == toUpper(v)) cnt++;\n    foreach(k, v) if (k\
    \ == toLower(v)) cnt++;\n    \n    bool result = cnt > 0 && cnt == dict.count();\n\
    \    \n    return result;\n}", "{\n    Nullable!(string) first;\n    Nullable!(string)\
    \ second;\n    bool result = false;\n    if (dict.isNull())\n        return true;",
  "{\n   if(not dict)\n       return true;\n   foreach(e, dict)\n   {\n       if(!is_string(e))\n\
    \       {\n           return false;\n       }\n       if(!is_string(e))\n    \
    \   {\n           return false;\n       }\n   }\n   return true;\n}", "{\n   \
    \ // If dict is an empty dictionary return true\n    if(!dict || !dict.isEmpty)\
    \ return true;\n    \n    // Get all the keys and convert to lowercase\n    string[]\
    \ keys = (string[])dict.toList().toArray();\n    \n    // If the first key's value\
    \ is null or empty, return false\n    if(!keys[0].isEmpty()) return false;\n \
    \   \n    // If the keys are all upper case return true\n    foreach(i in keys.indices){\n\
    \        if(!keys[i].isUppercase()) return false;\n    }\n    \n    // If all\
    \ the keys are upper case return true\n    return true;\n}", "{\n    for (auto\
    \ it : dict)\n        if (it.key as string in \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )\n            if (it.key as string in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n     \
    \           return false;\n    return true;\n}\n</code>\nThis doesn't take into\
    \ account the case where you have a dictionary with a key of \"a\" and \"a\" and\
    \ the value \"a\" though.\n<|/ a tags=types,ocaml,functional-programming,dictionary,comparison\
    \ |>\n<| c |>\nThank you! The use of a `for` loop is something I should probably\
    \ get familiar with more closely.\n<|/ c |>\n<| a dscore=1 tags=types,ocaml,functional-programming,dictionary,comparison\
    \ |>\nHere is another method using pattern matching. This one doesn't rely on\
    \ nullable types. Although it also doesn't check if the dictionary is empty.\n\
    <code>\ntype 'a dict = {\n    mutable mutable dict : 'a -> 'a;\n    mutable mutable\
    \ count : int;\n}", "{\n    bool result = true;\n    foreach(k, v : {!dict}) {\n\
    \        bool isString = !is_null(v);\n        if (!isString || !k) {\n      \
    \      result = false;\n        } else {\n            string key = k;\n      \
    \      string lowerCase = key.lower;\n            string upperCase = key.upper;\n\
    \            if (isString) {\n                bool result = false;\n         \
    \       if (lowerCase != upperCase) {\n                    result = true;\n  \
    \              }\n                else {\n                    string lowerUpper\
    \ = key.lower + key.upper;\n                    bool result = false;\n       \
    \             if (lowerUpper != lowerCase) {\n                        result =\
    \ true;\n                    }\n                    else {\n                 \
    \       string upperLower = key.upper + key.lower;\n                        bool\
    \ result = false;\n                        if (lowerUpper != upperCase) {\n  \
    \                          result = true;\n                        }\n       \
    \                 else {\n                            string lowerUpperNoSpace\
    \ = key.lower.replace(\" \", \"\");\n                            bool result =\
    \ false;\n                            if (lowerUpper != lowerUpperNoSpace) {\n\
    \                                result = true;\n                            }\n\
    \                            else {\n                                string upperLowerNoSpace\
    \ = key.upper.replace(\" \", \"\");\n                                bool result\
    \ = false;\n                                if (upperLower != upperLowerNoSpace)\
    \ {\n                                    result = true;\n                    \
    \            }\n                                else {\n                     \
    \               string noSpace = key.replace(\" \", \"\");\n                 \
    \                   bool result = false;\n                                   \
    \ if (noSpace != lowerUpperNoSpace) {\n                                      \
    \  result = true;\n                                    }\n                   \
    \             }\n                            }\n                        }\n  \
    \                  }\n                }\n            }\n            else {\n \
    \               result = false;\n            }\n        }\n    }\n    return result;\n\
    }", "{\n    if (dict.length == 0) {\n        return true;\n    }\n    auto iter\
    \ = dict.begin();\n    string key = (*iter).first;\n    auto end = dict.end();\n\
    \    for(++iter; iter != end; ++iter) {\n        if (iter->first.lexeme != key)\
    \ {\n            return false;\n        }\n        if (iter->first.upper != key)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    And a little test:\n<code>", "{\n  if(dict.IsEmpty)\n  {\n    return false;\n\
    \  }\n  foreach(string key in dict.Keys)\n  {\n    bool result = is_lower_case(key)\
    \ || is_upper_case(key); \n    if(!result)\n    {\n      return false;\n    }\n\
    \  }\n  return true;\n}", "{\n    if (dict == Nullable!(string[string])) return\
    \ true;\n    \n    foreach(ref key, ref val; dict) {\n        if (!is_string(key))\
    \ return false;\n        if (!is_string(val)) return false;\n    }\n    \n   \
    \ return true;\n}", "{\n    if (dict.isNull) return false;\n    foreach (key,\
    \ value) in dict\n        if (value.isNull) return false;\n    foreach (key, value)\
    \ in dict\n        if (!value.isString) return false;\n    return true;\n}\n\"\
    \"\"", "{\n    foreach (kv in dict)\n    {\n        if (!is_string(kv))\n    \
    \    {\n            return false;\n        }\n    }\n    return true;\n}", "{\n\
    \    if (dict.isNull)\n    {\n        return false;\n    }\n    for (auto key\
    \ : string.keys(dict))\n    {\n        if (key.isLowercase())\n        {\n   \
    \         continue;\n        }\n        if (key.isUppercase())\n        {\n  \
    \          continue;\n        }\n        return false;\n    }\n    return true;\n\
    }", "{\n  require(dict != null);\n  for(auto it : dict)\n  {\n    require(it.key!=null);\n\
    \    require(it.key!=\"\");\n    require(it.key!='\\0');\n    require(it.key!=it);\n\
    \  }\n  return !dict.empty();\n}", "{\n    foreach (pair!(string[string], string)\
    \ entry in dict) \n    {\n        if (!(check_type(Nullable!(string[string]))))\n\
    \        {\n            return false;\n        }\n        if (!(check_type(string)))\n\
    \        {\n            return false;\n        }\n        if (!(check_strings(entry.key)))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}",
  "{\n    bool result = false;\n    if (dict.has_value())\n    {\n        for (auto\
    \ [key, value] : dict)\n        {\n            if (is_string(value))\n       \
    \     {\n                result = true;\n                break;\n            }\n\
    \        }\n    }\n    return result;\n}", "{\n    foreach(x, dict) \n    {\n\
    \        \n        if (!isa(x, String) || toLower(x) != x)\n        {\n      \
    \      return false;\n        }\n    }\n    return true;\n}", "{\n    foreach\
    \ (string k in dict) \n    {\n        if (!(k.toLower() == k.toUpper()))\n   \
    \     {\n            return false;\n        }\n    }\n    return true;\n}", "{\n\
    \    if (dict.isNull) return true;\n    foreach(string key in dict) \n    {\n\
    \        if (!(typeof(key) == string)) return false;\n        if (!isLowercase(key.c_str()))\
    \ return false;\n    }\n    \n    return true;\n}\n</code>\n<|/ a dscore=1 tags=c,c++,types,python\
    \ |>\n<| a |>\nI came up with this solution which works on C and C++:\n<code>",
  "{\n    intraref keys (dict);\n    bool b = false;\n    keys.foreach((Key!(string)\
    \ key){\n        if (key == key)\n            b = True;\n    });\n    return b;\n\
    }\n</code>\n<|/ a tags=c#,dictionary,string,.net,types dscore=0 |>\n<| a dscore=0\
    \ |>\nI wrote the following function:\n<code>", "{\n    for (auto key : dict)\n\
    \    {\n        bool isLowerCase = key.to<string>().toLower();\n        bool isUpperCase\
    \ = key.to<string>().toUpper();\n        \n        if (key.hasValue() && isLowerCase\
    \ == isUpperCase)\n            return true;\n    }\n    \n    return false;\n}",
  "{\n    if (dict.isNull) return false; \n    foreach (var key in dict.keys) {\n\
    \        if (!key.has_case_change()) return false;\n    }\n    return true;\n}",
  "{\n  int count = 0;\n  foreach(key,value) in dict {\n    count += 1;\n    if (key.upper)\
    \ {\n      return false;\n    }\n    if (key.lower) {\n      return false;\n \
    \   }\n  }\n  return count == 0;\n}", "{\n    foreach (kk, v) in dict \n    {\n\
    \        if (typeof(kk) != typeof(string)) \n        {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n''');\n}", "{\n\tforeach (string key in\
    \ dict)\n\t{\n\t\tif (!dict[key])\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\
    \tif (!string.IsNullOrWhiteSpace(dict[key]))\n\t\t{\n\t\t\tif (dict[key].ToLowerInvariant()\
    \ != key)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tstring temp\
    \ = dict[key].ToLowerInvariant();\n\t\t\t\n\t\t\tif (temp != key)\n\t\t\t{\n\t\
    \t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn true;\n}", "{\n    map<string,\
    \ string> toUpper = {\n        \"a\": \"A\", \"b\": \"B\", \"c\": \"C\", \"d\"\
    : \"D\", \"e\": \"E\", \"f\": \"F\", \"g\": \"G\", \"h\": \"H\", \"i\": \"I\"\
    , \"j\": \"J\", \"k\": \"K\", \"l\": \"L\", \"m\": \"M\", \"n\": \"N\", \"o\"\
    : \"O\", \"p\": \"P\", \"q\": \"Q\", \"r\": \"R\", \"s\": \"S\", \"t\": \"T\"\
    , \"u\": \"U\", \"v\": \"V\", \"w\": \"W\", \"x\": \"X\", \"y\": \"Y\", \"z\"\
    : \"Z\", \n    };\n    map<string, string> toLower = {\n        \"a\": \"a\",\
    \ \"b\": \"b\", \"c\": \"c\", \"d\": \"d\", \"e\": \"e\", \"f\": \"f\", \"g\"\
    : \"g\", \"h\": \"h\", \"i\": \"i\", \"j\": \"j\", \"k\": \"k\", \"l\": \"l\"\
    , \"m\": \"m\", \"n\": \"n\", \"o\": \"o\", \"p\": \"p\", \"q\": \"q\", \"r\"\
    : \"r\", \"s\": \"s\", \"t\": \"t\", \"u\": \"u\", \"v\": \"v\", \"w\": \"w\"\
    , \"x\": \"x\", \"y\": \"y\", \"z\": \"z\",\n    };\n    for (auto it: dict)\n\
    \    {\n        if (it.first.first != it.first.second)\n            return false;\n\
    \        if (toUpper[it.first.first] == it.first.second)\n            return false;\n\
    \        if (toLower[it.first.first] == it.first.second)\n            return false;\n\
    \    }\n    return true;\n}", "{\n    foreach (k, v) in dict \n    {\n       \
    \ if ( k.toLowerCase() in Nullable!(string[string].t) ) \n        {\n        \
    \    return false;\n        }\n    }\n    return true;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=dictionary,python |>\nThis solution uses dict.__contains__ to\
    \ check for existence of a key. \n<code>\ndef check_dict_case(d):\n    for k,v\
    \ in d.items():\n        if isinstance(k,str) and k.islower():\n            return\
    \ False\n        elif isinstance(k,str) and k.isupper():\n            return False\n\
    \    return True\n</code>\n<|/ a dscore=0 |>\n<| a tags=dictionary,python |>\n\
    My first approach would be to iterate over all keys and check if each one is a\
    \ string with islower() and isupper() methods. \n<code>\ndef check_dict_case(dictionary):\n\
    \    for key, value in dictionary.items():\n        if type(value) is str:\n \
    \           if (key.islower() or key.isupper()) == True:\n                return\
    \ False\n    return True\n</code>\nIt would return True if all keys are lowercase\
    \ or all keys are uppercase. \nIt will also return True if the dictionary is empty,\
    \ thus returning False\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI think it would\
    \ be more efficient if you check only keys instead of whole dictionary\n<code>\n\
    def check_dict_case(dictionary):\n    for key, value in dictionary.items():\n\
    \        if not isinstance(key,str) and not isinstance(value,str):\n         \
    \   return False\n    return True\n</code>\n<|/ a tags=dictionary,python |>\n\
    <| a dscore=0 |>\nYou can make a function to check:\n<code>\ndef string_checker(str):\n\
    \  for i in str[::-1]:\n    if ord(i) >= 97 and ord(i) <= 122:\n      if ord(i)\
    \ - 32 > 25:\n        return False\n  return True\n</code>\nThen check all the\
    \ keys and values like this:\n<code>\nfor key, value in dictionary.items():\n\
    \  if type(value) is str:\n    if not string_checker(key):\n      return False\n\
    \  if not string_checker(value):\n    return False\nreturn True\n</code>\n<|/\
    \ a tags=dictionary,python |>\n<| c |>\nHow about `return (ord(i) - 32) > 25`?\n\
    <|/ c |>\n<| a tags=dictionary,python dscore=0 |>\nI assume that you are not allowed\
    \ to use any built-in function, including len(), isupper(), islower(), etc.\n\
    <code>\ndef checkDict(d):\n    for key, value in d.items():\n        if isinstance(key,str)\
    \ and key.isupper() and isinstance(value,str) and value.isupper():\n         \
    \   return False\n        elif key.islower() and value.islower():\n          \
    \  return False\n    return True\n</code>\n<|/ a |>\n<| a tags=dictionary,python\
    \ |>\nI ", "{\n    for(auto iter : dict) {\n        auto [key, value] = iter;\n\
    \        if (key.size() != value.size() || key < 'a' || key > 'z') return false;\n\
    \    }\n    return true;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=dictionary,python\
    \ |>\nThe above accepted answer from Rudi is correct in that it is only checking\
    \ to ensure that the key is upper case or lower case. \nThis is my way of handling\
    \ the problem:\n<code>\nif all(k.isupper() or k.islower() for k in dict_of_values.keys()):\n\
    \    return True\nelse:\n    return False\n</code>\n<|/ a dscore=1 |>\n<| a tags=dictionary,python\
    \ |>\nHere are some ways I can think of. My answer is in Python, but I hope it\
    \ helps.\nIn Java, the following code would work.\n<code>\npublic class CheckKeysAreInLowerCase\
    \ {", "{\n    foreach(key of dict)\n    {\n        foreach(char(char) in key)\n\
    \        {\n            if(islower(char))\n                throw \"Invalid dictionary\
    \ key for case check.\";\n            if(isupper(char))\n                throw\
    \ \"Invalid dictionary key for case check.\";\n        }\n    }\n    return true;\n\
    }", "{\n    if (!dict)\n        return false;\n    if (dict.size() == 0)\n   \
    \     return false;\n    \n    foreach (key, value) in dict {\n        if (!is_string(value)\
    \ || !is_string(key))\n            return false;\n        \n        if (value.toLower()\
    \ != key)\n            return false;\n    }\n    return true;\n}\n\"\"\")", "{\n\
    \  // check dict\n  if (dict == null || dict.isNull) return true;\n  \n  // check\
    \ key\n  auto keys = dict.keys;\n  for (auto key : keys) \n  {\n    if (key.isString()\
    \ && !key.isLower() && !key.isUpper()) return false; \n  }\n  \n  return true;\n\
    }", "{\n    // TODO: Support dictionaries with non-string keys\n    return !dict.empty;\n\
    }\n\"\"\"\n)\n</cell>\n<cell>\ncheck_dict_case([\"Name\": \"John\", \"Age\": \"\
    36\", \"City\": \"Houston\"].nullable)\n</cell>\n<cell>\ncheck_dict_case({})\n\
    </cell>\n<cell>\ncheck_dict_case({\"a\": \"apple\", \"b\": \"banana\"})\n</cell>\n\
    <cell>\ncheck_dict_case({\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"\
    })\n</cell>\n<cell>\ncheck_dict_case({\"a\": \"apple\", 8L: \"banana\", \"a\"\
    : \"apple\"})\n</cell>\n<cell>\ncheck_dict_case({\"a\": \"apple\", \"Name\": \"\
    John\", \"Age\": \"36\", \"City\": \"Houston\"})\n</cell>\n<cell>\ncheck_dict_case({\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"})\n</cell>\n<text>\n\
    Exercise 9\nWrite a function that accepts a nullable integer and returns it if\
    \ it's in between 0 and 10, else returns null.", "{\n    var res = true;\n   \
    \ for (string k in dict) {\n        if (!isLowercase(k) && !isUppercase(k)) {\n\
    \            res = false;\n            break;\n        }\n    }\n    return res;\n\
    }\n\"\"\")", "{\n\tforeach ( key in dict) \n\t{\n\t\tif (!is_string(key)) return\
    \ false;\n\t\tif (!is_string(dict[key]))return false;\n\t}\n\treturn true;\n}",
  "{\n    foreach(k, v: dict)\n        if (!is_string(k))\n        {\n           \
    \ return false;\n        }", "{\n    if (dict.is_empty())\n        return true;\n\
    \    auto iter = dict.key_map().begin();\n    auto end = dict.key_map().end();\n\
    \    for (; iter != end; ++iter) {\n        auto s = iter->first;\n        auto\
    \ l = s.length();\n        auto us = s.c_str();\n        auto ul = us.length();\n\
    \        if (ul < l)\n            return false;\n        if (ul == l)\n      \
    \      continue;\n        auto s0 = s.c_str();\n        auto l0 = l-1;\n     \
    \   for (; s0 >= l0 && ul >= l0; --s0, --ul)\n            if (*s0 == *us)\n  \
    \              continue;\n        return false;\n    }\n    return true;\n}",
  "{\n    foreach(var key in dict)\n    {\n        if (!is_string(key)) return false;\n\
    \    }\n    return true;\n}", "{\n\treturn dict.isNotEmpty && all( key=> \n\t\t\
    (dict[key] instanceof String && key.toLowerCase().isLowerOrEqual(\"name\") ||\
    \ dict[key] instanceof String && key.toUpperCase().isLowerOrEqual(\"name\")));\n\
    }", "{\n    if (dict.length == 0)\n    {\n        return true;\n    }\n    else\
    \ \n    {\n        for (int i = 0; i < dict.length; i++) \n        {\n       \
    \     if (dict[\"a\"].toString() == dict[\"A\"].toString() || dict[\"B\"].toString()\
    \ == dict[\"B\"].toString() || dict[\"A\"].toString() == dict[\"a\"].toString())\
    \ \n            {\n                continue;\n            }\n            else\
    \ \n            {\n                return false;\n            }\n        }\n \
    \       return true;\n    }\n}", "{\n    int sz = dict.size;\n    for(int i =\
    \ 0; i < sz; i++) \n    {\n        string key = dict.keys[i];\n        if(key.empty())\n\
    \            return false;\n        \n        auto c = toupper(key[0]);\n    \
    \    if(c == key[0]) \n        {\n            key = key[1];\n        }\n     \
    \   \n        auto cased = std.casefold2(key);\n        if(c == cased) \n    \
    \    {\n            dict.keys[i] = key;\n        }\n    }\n    return true;\n}",
  "{\n    foreach (string key in dict) {\n        if (!(key in string)) {\n      \
    \      return false;\n        }\n        if (!islower(key) || !isupper(key)) {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n\"\"\"\n  \
    \      \n    def nullable(self):\n        return \"\"\"\nimport std.array;\nimport\
    \ std.range;\nimport std.function;\nimport std.stdio;\nimport std.string;\nimport\
    \ std.typecons;\nimport std.math;\n/*\n    \n    Check all keys in a dictionary\
    \ are either strings or ints.\n    Return true if the given dictionary is nullable\
    \ (all keys are either strings or ints),\n    else return false. The function\
    \ should return false if the given dictionary is empty.\n    \n    Examples:\n\
    \    >>> check_nullable_dict([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"\
    Houston\"].nullable)\n    true\n    >>> check_nullable_dict([\"Name\": \"John\"\
    , \"Age\": \"36\", \"City\": \"Houston\", 8L: \"banana\"].nullable)\n    false\n\
    \    >>> check_nullable_dict([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"\
    Houston\", 8L: \"banana\", \"a\": \"apple\"].nullable)\n    false\n    \n*/",
  "{\n    return !dict.isNull;\n}\n'''\n)", "{\n    if( !dict.exists ) \n    {\n \
    \       return false;\n    }\n    return ( !dict.keys.any() || !dict.values.any()\
    \ ) ? false : true;\n}\n\"\"\")", "{\n    auto keys_to_lower: array<char, str>\
    \ =\n    {\n        'A', 'B', 'C', 'D', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\
    \ 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n\
    \    };\n    auto keys_to_upper: array<char, str> =\n    {\n        'A', 'B',\
    \ 'C', 'D', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n        'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n        'a', 'b', 'c', 'd', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z',\n    };\n    auto keys_unset: array<char, str>\
    \ =\n    {\n        'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n        'a', 'b',\
    \ 'c', 'd', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n        'o', 'p', 'q',\
    \ 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n        '0', '1', '2', '3', '4',\
    \ '5', '6', '7', '8', '9',\n    };\n    auto keys_exist: array<char, str> =\n\
    \    {\n        'A', 'B', 'C', 'D', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n\
    \        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n       \
    \ 'a', 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n        'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n        '0', '1', '2',\
    \ '3', '4', '5', '6', '7', '8', '9',\n    };\n    auto keys_exist1: array<char,\
    \ str> =\n    {\n        'A', 'B', 'C', 'D', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N',\n        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n\
    \        'a', 'b', 'c', 'd', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n  \
    \      'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n        '0',\
    \ '1', '2', '3', '4', '5', '6', '7', '8', '9',\n        'a', 'b', 'c', 'd', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z',\n        '0', '1', '2', '", "{\n    if (dict.isNull)\
    \ return true;\n    \n    // check if all keys are lowercase\n    int numLower\
    \ = 0;\n    for (string key in dict) {\n        string value = dict[key];\n  \
    \      if (value.isNull) return true;\n        if (!value.compareToIgnoreCase(key))\
    \ {\n            numLower++;\n        }\n    }\n    \n    // check if all keys\
    \ are uppercase\n    int numUpper = 0;\n    for (string key in dict) {\n     \
    \   string value = dict[key];\n        if (value.isNull) return true;\n      \
    \  if (!value.compareToIgnoreCase(key)) {\n            numUpper++;\n        }\n\
    \    }", "{\n\tauto key = dict.get_fields();\n\tbool allStrings = true;\n\t\n\t\
    for (auto& v : key) {\n\t\tif (not is_str(v.first)) {\n\t\t\tallStrings = false;\n\
    \t\t}\n\t}\n\t\n\treturn allStrings;\n}", "{\n  foreach(key in dict, key < \"\
    A\"){\n    bool isLower = true;\n    foreach(key2 in dict, key2 < \"a\"){\n  \
    \    if(!(isLower && key2 != key && key2.toupper() == key2) || (!isLower && key2\
    \ != key && key2.tolower() == key2))\n        return false\n    }\n  }\n  return\
    \ true;\n}", "{\n\tforeach (k,v) in dict \n\t{\n\t\tif (isNull(to!string(k)))\
    \ \n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "{\n    Nullable!(string)\
    \ strKeys = dict.get_keys()\n    if !strKeys.is_empty() then \n    {\n       \
    \ for (string strKey in strKeys) \n        { \n            if strKey.length()\
    \ > 0 && !strKey.is_lowercase() \n                && !strKey.is_uppercase() \n\
    \                return false\n        }\n    }\n    else \n    {\n        return\
    \ false\n    }\n    return true\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=c#,null,tuples,dictionary\
    \ |>\nI had a similar problem recently (in a different context) and I ended up\
    \ writing a custom method to determine if all elements in a dictionary are null.\n\
    <code>\npublic static bool AllElementsNull(Dictionary<string, object> dict)\n\
    {\n    foreach (var key in dict.Keys)\n    {\n        if (dict[key] == null)\n\
    \            return false;\n    }\n    return true;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=c#,null,tuples,dictionary |>\n<code>\npublic static bool IsAllNull(IDictionary<string,object>\
    \ values)\n{\n    var nonNullCount = values.Where(v => v != null).Count();", "{\n\
    \    foreach (key, val) in dict {\n        if (!typeof(key) is string) return\
    \ false;\n        if (!typeof(val) is string) return false;\n    }\n    return\
    \ true;\n}\n</code>\n<|/ a tags=dictionary,c# |>\n<| a |>\n<code>\npublic static\
    \ bool AreDictionariesEqual(Dictionary<string, string> dict1, Dictionary<string,\
    \ string> dict2)\n{\n    var keysAreEqual = Equals(dict1.Keys, dict2.Keys);\n\
    \    foreach (var item in dict1.Where(kv => !dict2.ContainsKey(kv.Key))) \n  \
    \  {\n        keysAreEqual = false;\n        break;\n    }\n    return keysAreEqual;\n\
    }\n</code>\n<|/ a tags=dictionary,c# dscore=2 |>\n<| c |>\nIf you're using C#\
    \ 7 you can use the built-in `IsEqual` method instead of manually doing this and\
    \ returning a boolean.\n<|/ c |>\n<| c |>\nThis code will misbehave when keys\
    \ are compared with null.\n<|/ c |>\n<| a tags=dictionary,c# |>\nAs this question\
    \ has already been answered, I thought I would add a solution I came up with,\
    \ using LINQ.\n<code>\npublic static bool AreDictionariesEqual(Dictionary<string,\
    \ string> dict1, Dictionary<string, string> dict2)\n{\n    return dict1.Keys.All(k\
    \ => dict2.ContainsKey(k) && dict1[k] == dict2[k]);\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 tags=dictionary,c# |>\nHere is a way I came up with to compare\
    \ two dictionaries, even though it might be inefficient. \n<code>\npublic static\
    \ bool AreDictionariesEqual(Dictionary<string, string> dict1, Dictionary<string,\
    \ string> dict2)\n{\n    foreach(var key1 in dict1.Keys)\n    {\n        bool\
    \ match = false;", "{\n    foreach(var k in dict) \n        if(!(is_string(k)\
    \ || is_string(tostring(k))))\n            return false;\n    return true;\n}\n\
    </code>\n<|/ a |>\n<| a dscore=1 tags=c# |>\nThis seems to work for me and is\
    \ less verbose than some of the other solutions:\n<code>\nprivate bool IsDictEmpty(Dictionary<string,\
    \ object> dict)\n{\n    return dict.Count < 1;\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\n<code>\nusing System.Collections.Generic;\n...", "{\n    foreach(k, v) in\
    \ dict do\n       if  not (v is! string)  or  \n          not (str.toLower(k)\
    \ == v) or\n          not (str.toUpper(k) == v)\n           then \n          \
    \ return false;\n    return true;\n}\n</code>\n<|/ a tags=d,language-agnostic\
    \ |>\n<| c |>\nI believe that the OP wants to return `false` if the dictionary\
    \ is empty, or not only containing strings (i.e. no number or other data types)\n\
    <|/ c |>\n<| c |>\nYou can't use `.nullable` on a `string` array.\n<|/ c |>\n\
    <| c |>\nI believe that \"string\" array means null terminated array of chars\
    \ (array of strings).\n<|/ c |>\n<| c |>\nI thought it was a pointer to a std.array.\n\
    <|/ c |>\n<| c |>\nI meant a string array. Sorry if that wasn't clear.\n<|/ c\
    \ |>\n<| a tags=d,language-agnostic |>\nI wrote a simple function in C#:\n<code>",
  "{\n    \n    for (auto k : dict)\n    {\n        //assert (k.length() == 2); //\
    \ TODO\n        auto l = k.toLowerCase();\n        if (!std::equal(l.begin(),\
    \ l.end(), k.begin(), k.end()))\n            return false;\n    }\n    return\
    \ true;\n}\n\"\"\")", "{\n    bool success = true;\n    foreach(auto it, dict)\n\
    \        success = success && islower(it) || isupper(it);\n    return success;\n\
    }\n</code>\n<|/ a |>\n<| c |>\n`check_dict_case(\"A\") == \"a\"` will fail (`is_lower`\
    \ returns true if the char is not a letter, which is probably not what you want).\n\
    <|/ c |>\n<| c |>\nI agree. Fixed the typo now\n<|/ c |>\n<| c |>\nI appreciate\
    \ the effort to explain the code and give an example. While this solution does\
    \ solve the problem at hand, I'm afraid that someone might come up with a solution\
    \ that is more elegant and more scalable. Also, I guess you missed the fact that\
    \ this solution requires C++17. Thank you anyways!\n<|/ c |>\n<| a tags=c++,std,c++17\
    \ |>\nYou can use std::all_of() with a lambda expression:\n<code>\n#include <algorithm>\n\
    #include <iostream>\n#include <string>\n#include <cctype>\n#include <vector>",
  "{\n    if (dict == null || !dict.isEmpty)\n        return false; ", "{\n\tif(dict.isNull)\
    \ \n\t\treturn false;\n\tif(dict.type == \"dict\"){\n\t\tfor(string key in dict.keys){\n\
    \t\t\tif(key.lower() == key){\n\t\t\t\treturn false;\n\t\t\t}else if(key.upper()\
    \ == key){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}", "{\n\
    \  if (dict.empty()) return true;\n  auto first = dict.keys().begin();\n  auto\
    \ last = dict.keys().end();\n  for(auto it = first != last ; ++it )\n  {\n   \
    \ auto key = *it;\n    \n    auto lower = string::to_lower(key);\n    auto upper\
    \ = string::to_upper(key);\n    \n    if (lower != key) \n    {\n      return\
    \ false;\n    }\n    if (upper != key)\n    {\n      return false;\n    }\n  }\n\
    \  return true;\n}\n</code>\n<|/ a tags=associative-array,std,c++,containers,c++11\
    \ |>\n<| a tags=associative-array,std,c++,containers,c++11 |>\nFor what it's worth,\
    \ I wrote a small library that can compare C++ map containers with STL containers:\n\
    <code>\n#include <map>\n#include <iostream>\n#include <string>\n#include <list>\n\
    #include <algorithm>\n#include <iterator>", "{\n    foreach(k, v) in dict {\n\
    \        if(isNull(k)) {\n            return false;\n        }\n        \n   \
    \     if(k.toCString().isUpper()) {\n            return false;\n        }\n  \
    \      \n        if(!k.toCString().isLower()) {\n            return false;\n \
    \       }\n    }\n    \n    return true;\n}", "{\n    forall(dict, key -> key.key.type.isString()\
    \ || key.key.type.isUppercaseString());\n}", "{\n    bool result = false;\n  \
    \  if (dict)\n    {\n        for (auto it : dict)\n        {\n            string\
    \ key = it.first;\n            if (is_string(key))\n            {\n          \
    \      if (!is_string(it.second))\n                {\n                    result\
    \ = false;\n                    break;\n                }\n            }\n   \
    \         else\n            {\n                if (is_string(it.second))\n   \
    \             {\n                    result = false;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}", "{\n\
    \    foreach(k, val) in dict \n    {\n        if (std.typecons.isUpper(std.string.upcase(k)))\
    \ \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }", "{\n    assert(dict != null);\n    return !dict.hasKey(\"Name\") && !dict.hasKey(8L);\n\
    }\n\"\"\")", "{\n    foreach(string str in dict) {\n        if(str.isLowercase())\
    \ return true;\n        if(str.isUppercase()) return true;\n    }\n    return\
    \ false;\n}", "{\n    if (dict.isNull)\n        return false; \n    \n    auto\
    \ &dict = dict.get_ref();\n    for (auto &&v : dict) {\n        if (!(v.first.type.isString()\
    \ || v.first.type.isEnum()))\n            return false; \n    } \n    return true;\
    \ \n}\n''';\n$code = '#include \"std.hpp\"';\n$code .= '\n/*", "{\n\tif(dict.empty())\n\
    \t\treturn true;\n\tauto keys = dict.keys;\n\tfor(auto it = keys.begin(); it !=\
    \ keys.end(); ++it) \n\t{\n\t\tauto &key = *it;\n\t\tauto &value = dict[key];\n\
    \t\tif(key.length() != value.len) \n\t\t\treturn false;\n\t\tauto c = tolower(key[0]);\n\
    \t\tif(c >= 'a' && c <= 'z') \n\t\t\tcontinue;\n\t\telse \n\t\t\treturn false;\n\
    \t}\n\treturn true;\n}", "{\n    if (dict.isNull) return true;\n    for (auto\
    \ v : dict)\n        if (v.key.isLower()) continue;\n        else if (v.key.isUpper())\
    \ continue;\n        else return false;\n    return true;\n}", "{\n    bool result\
    \ = true;\n    for (auto key: string.range(dict.keys))\n    {\n        string\
    \ val = dict[key];\n        auto is_upper = string::caseInsensitiveCompare(val,\
    \ key) == 0;\n        auto is_lower = string::caseInsensitiveCompare(key, val)\
    \ == 0;\n        if (!is_upper && !is_lower)\n        {\n            result =\
    \ false;\n            break;\n        }\n    }\n    return result;\n}", "{\n \
    \   auto it = dict.begin();\n    if (it == dict.end()) {\n        return false;\n\
    \    }\n    ++it;\n    for(auto it2 = dict.begin(); it2 != dict.end(); ++it2)\
    \ {\n        if (!(Stringify(it->first) == Stringify(it2->first))) {\n       \
    \     return false;\n        }\n        ++it2;\n    }\n    return true;\n}", "{\n\
    \tbool flag = true;\n\tforeach(i32 i=1, i<len(dict); i++) {\n\t\tflag &= str.islower(dict[tostring(i)])\n\
    \t\tflag &= str.isupper(dict[tostring(i)])\n\t}\n\t\n\treturn flag;\n}", "{\n\
    \    foreach(k, v) {\n        if (string) k = std.tolowercase(k);\n        if\
    \ (string) k = std.touppercase(k);\n        if (!dict.is(k)) return false;\n \
    \   }\n    return true;\n}\n</code>\n<|/ a tags=types,d,dmd dscore=2 |>\n<| a\
    \ dscore=1 tags=types,d,dmd |>\nI've had a little bit of a play around and came\
    \ up with this that seems to work pretty well:\n<code>", "{\n    for(auto iter:\
    \ dict)\n    {\n        if (typeof(iter.key) != \"string\" && !(typeof(iter.key)\
    \ != \"number\" && typeof(iter.key) != \"bool\"))\n        {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n\"\"\"\n)\n</cell>\n<cell>\n\
    from nbdev.export import notebook2script; notebook2script()\n</cell>\n<cell>",
  "{\n\tif(!dict)\n\t\treturn false;\n\tfor(auto [key, val] : (pair!(string[string],\
    \ string))[]) \n\t{\n\t\tif(key.length() != val.length()) return false;\n\t\t\
    if(key.isUppercase() != val.isUppercase()) return false;\n\t}\n\treturn true;\n\
    }", "{\n  // your code goes here\n  int i = 0;\n  bool all_strings = false;\n\
    \  while(i < dict.len) {\n    string key = dict.get(i).getName();\n    string\
    \ lower = tolower((dict.get(i).getName()))\n    bool is_lower = lower.compare(key);\n\
    \    if(is_lower) {\n      all_strings = true;\n    }\n    else {\n      all_strings\
    \ = false;\n      break;\n    }\n    i = i+1;\n  }\n  return all_strings;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nI haven't tried it yet but that's a pretty\
    \ good idea. Thanks!\n<|/ c |>\n<| c |>\nCan you tell me how this works `tolower((dict.get(i).getName()))`\n\
    <|/ c |>\n<| c |>\nHi Chris, sorry for my ignorance. I'm trying to get my head\
    \ around this. What is `tolower` doing?\n<|/ c |>\n<| c |>\n`tolower` is a function\
    \ that will lower case the string. Just like in Python. [Here's the documentation](http://www.cplusplus.com/reference/algorithm/tolower/).\n\
    <|/ c |>\n<| c |>\nOkay, but what does it do when it's applied to the key of the\
    \ dict? What is dict.get(i).getName()?\n<|/ c |>\n<| a tags=std-pair,stdmap,c++,dictionary,stl\
    \ |>\nIf you don't have access to C++20 then you can try this\n<code>\n#include\
    \ <iostream>\n#include <string>\n#include <map>", "{\n    foreach(k, v: dict)\n\
    \        if(!is_integer(k) || !is_integer(v) || k != v)\n            return false;\n\
    \    return true;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=types,haskell,associative-array\
    \ |>\nThe above solutions don't seem to play nicely with Data.Array.\nHere's a\
    \ solution using Data.Array. Basically, we're converting everything to a Data.Array.Array1\
    \ with a custom function which allows us to perform elementwise equality checks.\
    \ It's probably more efficient than converting to a Data.Array.Array1 via Data.Array.IArray.\n\
    <code>\nimport qualified Data.Array.IArray as IArray\nimport qualified Data.Array\
    \ as Array\nimport qualified Data.Array.Unboxed as UA", "{\n    foreach(string\
    \ key in dict)\n        if(!std.string.lower_case(key) || !std.string.upper_case(key))\n\
    \            return false;\n    return true;\n}\n</code>\n<|/ a dscore=2 tags=d,types,function\
    \ |>\n<| a dscore=1 |>\nA function that will return true if all keys in an associative\
    \ array are strings in lower case or all keys are strings in upper case, else\
    \ return false:\n<code>", "{\n\tif(dict.length == 0)\n\t\treturn false;\n\tfor\
    \ (auto it : dict)\n\t{\n\t\tif(it.first < \"A\" || it.first > \"Z\")\n\t\t\t\
    return false;\n\t}\n\t\n\tfor(auto it : dict){\n\t\tif(it.second < \"a\" || it.second\
    \ > \"z\")\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\"\"\"\n)\n</cell>\n\
    <text>\nTuple", "{\n    auto kv = dict.keyvalues();\n    forall(kv, [&](auto pair){\
    \ \n        auto key = pair.key();\n        if (pair.key().length() == 0){\n \
    \           error(\"Null keys are not allowed as key names in an associative array.\"\
    );\n        }\n        auto lowercase = make_tuple(string(\"a\"), string(\"A\"\
    ), string(\"b\"), string(\"B\"));\n        auto uppercase = make_tuple(string(\"\
    A\"), string(\"a\"), string(\"B\"), string(\"B\"));\n        if (is_in_tuple(key.toLowerCase(),\
    \ lowercase)){\n            if (is_in_tuple(key.toUpperCase(), uppercase)){\n\
    \                return true;\n            } else {\n                error(\"\
    Key '\" + key + \"' has different case than 'a' and 'A' where it should be either\
    \ 'a' or 'A'.\");\n            }\n        } else {\n            error(\"Key '\"\
    \ + key + \"' is not lowercase or uppercase as 'a' and 'A' where it should be\
    \ either 'a' or 'A'.\");\n        }\n        return false;\n    });\n    return\
    \ false;\n}\n#endif\n#endif\n</code>\n<|/ a |>\n<| a dscore=0 tags=c++,dictionary,std-pair\
    \ |>\nFor C++20 it's pretty easy to create a custom comparator:\n<code>\nstruct\
    \ CustomMap {\n    std::unordered_map<std::string, std::string, std::hash<std::string>,\
    \ std::equal_to<std::string>> m_map;\n};\n</code>\nTo create a comparator:\n<code>\n\
    std::function<bool(std::pair<std::string,std::string>, const CustomMap&)> compareMapKeys\n\
    {\n    using std::swap;\n    return [&](std::pair<std::string, std::string> const\
    \ &left, const CustomMap &right)\n    {\n        auto &key = left.first;\n   \
    \     if (left.first == right.m_map.end())\n        {\n            return false;\n\
    \        }\n        if (right.m_map.find(key) == right.m_map.end())\n        {\n\
    \            return true;\n        }\n        auto &value = right.m_map.find(key);\n\
    \        swap(value, left.second);\n        return true;\n    };\n}\n</code>\n\
    Then you can use this in your code:\n<code>\nstd::unordered_map<std::string, std::string,\
    \ std::hash<std::string>, std::equal_to<std::string>> map;\nCustomMap custom_map;\n\
    </code>\nYou will need to create a map constructor that takes a comparator and\
    \ use it:\n<code>\nCustomMap(CustomMap const &other, std::function<bool(std::pair<std::string,std::string>,\
    \ const CustomMap&)> comparator)\n{\n    std::for_each(other.m_map.begin(), other.m_map.end(),\
    \ [&](std::pair<std::string, std::string> const &pair)\n    {\n        map.",
  "{\n    return !is_empty(dict) && all(\n        has_key(dict, k) => k.length ==\
    \ 0 || is_lower(k) || is_upper(k), \n        dict\n    );\n}\n/*", "{\n    return\
    \ !dict.containsKey(null) && dict.containsKey(String.toLowerInvariant(null));\n\
    }\n/*", "{\n    if (dict.length == 0) {\n        return false;\n    }\n    for\
    \ each (string key in dict) \n    {\n        if ((key.length < 1) || (key.length\
    \ > 2)) {\n            return false;\n        }\n        if (!((key.length ==\
    \ 1) && (key.isUpper))) {\n            return false;\n        }\n    }\n    return\
    \ true;\n}", "{\n    if(dict.IsNull)\n    {\n        return true;\n    }\n   \
    \ \n    foreach(key in dict.Keys)\n    {\n        string lower = tolower(key);\n\
    \        string upper = toupper(key);\n        \n        if(lower != upper &&\
    \ lower != key)\n        {\n            return false;\n        }\n    }\n    \n\
    \    return true;\n}\n</code>\n<|/ a dscore=4 tags=c++,generics,d |>\n<| a dscore=2\
    \ tags=c++,generics,d |>\nAnother approach is using std.algorithm package as follows:\n\
    <code>\nimport std.algorithm;\nimport std.array;\nimport std.conv;", "{\n\tauto\
    \ itr = dict.dict.begin();\n\tbool result = true;\n\tfor (auto itr2 = dict.dict.begin();\
    \ itr != dict.dict.end(); ++itr, ++itr2) {\n\t\tstring key = (string) *itr;\n\t\
    \tstring val = (string) *itr2;\n\t\tif (key.isupper()) {\n\t\t\tif (!val.compare(val.to_lower()))\
    \ {\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif\
    \ (!val.compare(val.to_upper())) {\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn result;\n}", "{\n  bool result = true;\n  for (auto\
    \ iter: dict)\n    if (!(iter.first.isUpperCase || iter.first.isLowerCase || iter.first.isDigit))\n\
    \      result = false;\n  return result;\n}", "{\n    foreach(string key in dict)\n\
    \    {\n        if(!dict.isNull(key))\n        {\n            if(!isString(key)\
    \ || !isLowerCase(key) || !isUpperCase(key))\n                return false;\n\
    \        }\n    }\n    return true;\n}", "{\n    if (dict == null || dict.size\
    \ < 1) return false;\n    for (auto it = dict.begin(); it != dict.end(); it++)\
    \ {\n        if (it.key().length != it.value().length) return false;\n       \
    \ char ch1 = it.key()[0];\n        char ch2 = it.value()[0]\n        if (ch1 !=\
    \ ch2) return false;\n    }\n    return true;\n}\n</code>\n<|/ a |>\n<| a tags=c++,stl,c++17,std,dictionary\
    \ |>\nFor a C++17 solution using std::map and std::unordered_map, the following\
    \ should work:\n<code>\n#include <cassert>\n#include <unordered_map>\n#include\
    \ <algorithm>\n#include <vector>", "{\n    foreach(key, value) in dict \n    \n\
    \    if (\n        key.isupper() == false && \n        \n        key.islower()\
    \ == false &&\n        \n        value.isupper() == false &&\n        \n     \
    \   value.islower() == false)\n    {\n        return false;\n    }\n    \n   \
    \ return true;\n}", "{\n    if (dict == null || dict.isNull) return false;\n \
    \   foreach (key, value) {\n        if (value instanceof string) {\n         \
    \   if (value.toLowerCase() !== value.toUpperCase()) return false;\n        }\
    \ else if (value instanceof long) {\n            if (value.toNumber() != value.toNumber())\
    \ return false;\n        }\n    }\n    return true;\n}", "{\n    if (dict.length\
    \ == 0) {\n        return false;\n    }\n    var keyset = KeySet.create(dict);\n\
    \    foreach (var key in keyset) {\n        if (keyset[key] == null) continue;\n\
    \        if (keyset[key].isUppercase) {\n            return false;\n        }\n\
    \    }\n    return true;\n}", "{\n    if(dict == null)\n    {\n        return\
    \ false;\n    }\n    for(string key in dict)\n    {\n        if(key.caseInsensitive\
    \ != \"true\")\n        {\n            return false;\n        }\n    }\n    return\
    \ true;\n}", "{\n    return dict.hasKeys()\n        && !std::all_of(dict.keys(),\
    \ [](const string &key){return !key.empty(); });\n}", "{\n    bool allKeysAreLowercaseOrUppercase\
    \ = true;\n    \n    for (auto kv : dict) {\n        if (!is_string(vk)) {\n \
    \           allKeysAreLowercaseOrUppercase = false;\n            break;\n    \
    \    }\n    }\n    \n    return allKeysAreLowercaseOrUppercase;\n}", "{\n    foreach(k,\
    \ v) in dict \n        if (typeof(k) <> 'string' || (typeof(v) <> 'string' &&\
    \ v.isNull)) \n            return false;\n    return true;\n}\n/*", "{\n    if\
    \ (dict != null)\n    {\n        for (auto i : dict)\n        {\n            if\
    \ (std.typecons.isString(i.key) || std.typecons.isString(i.value.key))\n     \
    \       {\n                continue;\n            }\n            else\n      \
    \      {\n                return false;\n            }\n        }\n        return\
    \ true;\n    }\n    return false;\n}", "{\n    if (dict.isNull)\n    {\n     \
    \   return true;\n    }\n    \n    foreach(string k in dict)\n    {\n        if\
    \ (!k.isLower)\n        {\n            return false;\n        }\n    }\n    \n\
    \    foreach(string k in dict)\n    {\n        if (!k.isUpper)\n        {\n  \
    \          return false;\n        }\n    }\n    \n    return true;\n}", "{\n \
    \   if (dict._dictionary) {\n        if (dict._dictionary.isEmpty)\n         \
    \   return true;\n        var dict = dict._dictionary;\n        for (KeyValuePair!(string,string)\
    \ item in dict)\n            if (!item.key.isLowerCase && !item.key.isUpperCase\
    \ && !item.key.isDigit)\n                return false;\n        return true;\n\
    \    }\n    return false;\n}\n</code>\n<|/ a tags=swift,dictionary |>\n<| a dscore=1\
    \ |>\nHere is a solution that uses Swift's type inference and removes casting:\n\
    <code>\nimport Foundation", "{\n    // TODO: implement\n}", "{\n    for(const\
    \ auto &[k, v] : dict) \n        if(k.length() <= 1 || k.length() > 1 && k[0]\
    \ == tolower(k[1]))\n            return false;\n    return true;\n}", "{\n  if\
    \ (dict == null) return false;\n  return all(k in dict | v in dict | KeyValue(k,\
    \ v) in dict);\n}\n\"\"\"", "{\n    if (dict.isNull)\n        return false\n \
    \   foreach (key in dict) {\n        if (!(key is string) || !key.to_lowercase(Locale::en).startsWith(key.to_lowercase(Locale::en).toLowerCase(),\
    \ Locale::en))\n            return false\n    }\n    return true\n}", "{\n   \
    \ int len = dict.len();\n    for(int i = 0; i < len; ++i) {\n        string key\
    \ = dict[i].key();\n        if(!islower(key) && !isupper(key)) {\n           \
    \ return false;\n        }\n    }\n    return true;\n}\n</code>\n<|/ a tags=d\
    \ dscore=3 |>\n<| a |>\nThis can be done with pure D2:\n<code>", "{\n    bool\
    \ isAllLower=true;\n    bool isAllUpper=true;\n    for (Nullable!(string[string]\
    \ key : dict)\n    {\n        if (key.tostring() !=  key.lowercase())\n      \
    \      isAllLower = false;\n        if (key.tostring() !=  key.uppercase())\n\
    \            isAllUpper = false;\n    }\n    return (isAllLower && isAllUpper);\n\
    }\n</code>\n<|/ a tags=functional-programming,dictionary,dart dscore=1 |>\n<|\
    \ a dscore=0 |>\nIn addition to the previous answers, here's a more generic approach,\
    \ using generic constraints:\n<code>\nimport 'package:collection/collection.dart';",
  "{\n    forall(dict, k => {\n        return typeof(k) == string && (k == k.toLowerCase()\
    \ || k == k.toUpperCase()); \n    });\n}", "{\n    if(dict.IsEmpty()) return true;\
    \ // empty dict\n    if(!dict.IsValueSet()) return false; // non-nullable dict\n\
    \    foreach (key, value) in dict \n    {\n        if((value?.size() == 0L) &&\
    \ \n            !(tolower(key) == key || toupper(key) == key)) return false;\n\
    \    }\n    return true;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=0 |>\nThe\
    \ easiest way to do this is to define a function which returns a bool indicating\
    \ if a string is a valid name for a variable:\n<code>", "{\n    foreach(const\
    \ auto &pair: dict)\n    {\n        const auto &key = pair.key();\n        const\
    \ auto &value = pair.value();\n        if(!is_string(key) || !is_string(value))\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    '''", "{\n    if (dict.IsNull()) return true; \n    for (int i = 0; i < dict.NumItems();\
    \ i++)\n    {\n        if (dict[i].IsString() && dict[i].AsString().isLower())\
    \ return true;\n        if (dict[i].IsString() && dict[i].AsString().isUpper())\
    \ return true;\n    }\n    return false;\n}\n''';", "{\n    return !dict.isEmpty()\
    \ && all(k in dict as string for k in lower);\n}", "{\n    return !dict.empty()\
    \ && !any(dict.iterate(\n        [](string key, string value) -> bool {\n    \
    \        return std.isLowercase(value) || std.isUppercase(value);\n        }));\n\
    }\n\"\"\"\n    pass", "{\n    if (dict == null || dict.length == 0) return true;\n\
    \    for (auto k : dict)\n        if (k.value.length != 0) return false;\n   \
    \ return true;\n}\n/* \n    Create a dictionary from the given associative array.\n\
    \    If the given associative array is null, return null.\n    \n    Arguments:\
    \ \n        dict - Associative array (dictionary) to be created.\n    Returns:\n\
    \        Nullable!(string[string]) dictionary if the given associative array is\
    \ not null, else null.\n    Example:\n        dict = create_dict([\"Name\": \"\
    John\", \"Age\": \"36\", \"City\": \"Houston\"])\n*/\nNullable!(string[string])\
    \ create_dict(Nullable!(string[string]) dict)\n{\n    if (dict == null) \n   \
    \     return Nullable!(string[string]) null;\n    \n    string[string] keys =\
    \ dict.value;\n    string[string] vals = dict.key;\n    \n    Array!(string) keysa\
    \ = Array!<string>(keys.length);\n    Array!(string) valsa = Array!<string>(keys.length);\n\
    \    \n    for (auto key : keys) keysa[dict.value_index] = key;\n    for (auto\
    \ val : vals) valsa[dict.key_index] = val;\n    \n    return Nullable!(string[string])\
    \ new Dictionary(keysa, valsa);\n}\n/* \n    Create a dictionary from the given\
    \ associative array.\n    If the given associative array is null, return null.\n\
    \    \n    Arguments: \n        dict - Associative array (dictionary) to be created.\n\
    \    Returns:\n        Nullable!(string[string]) dictionary if the given associative\
    \ array is not null, else null.\n    Example:\n        dict = create_dict([\"\
    Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"])\n*/\nNullable!(string[string])\
    \ create_dict(Nullable!(string[string]) dict, string[string] key, string value)\n\
    {\n    if (dict == null)\n        return Nullable!(string[string]) null;\n   \
    \ \n    string[string] keys = dict.value;\n    string[string] vals = dict.key;\n\
    \    \n    Array!(string) keysa = Array!<string>(keys.length);\n    Array!(string)\
    \ valsa = Array!<string>(keys.length);\n    \n    for (auto key : keys) keysa[dict.value_index]\
    \ = key;\n    for (auto val : vals) valsa[dict.key_index] = val;\n    \n    return\
    \ Nullable!(string[string]) new Dictionary(keysa, valsa).put(key, value);\n}",
  "{\n    int count = 0;\n    foreach(string key, dict){\n        if(!is_null(key)\
    \ && is_string(key))\n            count++;\n        else\n            return false;\n\
    \    }\n    return count == (dict.length()/2);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    That's really helpful! Thank you!\n<|/ c |>\n<| a tags=string,python dscore=3\
    \ |>\nTo make life a bit easier, you can define a nullable data type in Python\
    \ as follows:\n<code>\nclass Nullable:\n    def __init__(self, value):\n     \
    \   self.value = value\n    def value(self):\n        return self.value\n    def\
    \ is_null(self):\n        return not self.value\n</code>\nThe class above is just\
    \ a convenience wrapper around the primitive type, which allows you to define\
    \ methods on it:\n<code>\ndef nullable_string(str): return Nullable(str)\n</code>\n\
    And then you can use your nullable data type to enforce a constraint on your string:\n\
    <code>\ndef check_dict_case(dicts):\n    return all(Nullable(s).is_null for s\
    \ in dicts)\n</code>\n<|/ a |>\n<| c |>\nThis is how I would have done it as well.\
    \ An alternate approach is to use `isinstance(s, Nullable)` to detect nullable\
    \ types. That way, you won't need to define an additional wrapper class. Although\
    \ it is essentially the same thing. I would not recommend this approach over simply\
    \ defining a function that checks if something is a `null` string. Although in\
    \ most cases, using `isinstance` would work as well, this approach would work\
    \ even for types that don't define `__bool__` (like those returned from functions).\n\
    <|/ c |>\n<| a tags=string,python dscore=2 |>\nThe most elegant solution I found\
    \ is to use a Python decorator:\n<code>\ndef check_dict_case(nullable_string):\n\
    \    def check_func(func):\n        def func_wrapper(*args, **kwargs):\n     \
    \       return all(func(*arg, **kwarg) for arg in args) or all(nullable_string(s)\
    \ for s in kwargs)\n        return func_wrapper\n    return check_func\n</code>\n\
    Then you can use it like that:\n<code>\ndef check_dict_case(nullable_string):\n\
    \    def check_func(func):\n        def func_wrapper(*args, **kwargs):\n     \
    \       return all(func(*arg, **kwarg) for arg in args) or all(nullable_string(s)\
    \ for s in kwargs)\n        return func_wrapper\n    return check_func\n</code>\n\
    <|/ a |>\n<| c |>\nVery nice! But I would rename the function to `is_nullable`\
    \ :D\n<|/ c |>\n<| a tags=string,python |>\nHere's another solution that I find\
    \ more elegant:\n<code>\ndef is_nullable_string(s):\n    return isinstance(s,\
    \ str) and s", "{\n    assert(!dict.isNull);\n    return !dict.isEmpty;\n}", "{\n\
    \  \n}\n'''\n        validate_fn(check_dict_case)\n        \n        validate_fn('''\n\
    import std.random;\nimport std.array;\nimport std.string;\nimport std.typecons;\n\
    import std.math;", "{\n    foreach(string key in dict)\n    {\n        char lowerChar\
    \ = key.lower();\n        char upperChar = key.upper();\n        if (lowerChar\
    \ == upperChar)\n            continue;\n        return false;\n    }\n    return\
    \ true;\n}", "{\n  if(!dict.IsNull) return true; \n  \n  for(auto iter = dict.begin();\
    \ iter != dict.end(); iter++) {\n    if(!iter->IsNull) \n    {\n      if (iter->isUpper)\
    \ return true;\n      else \n      {\n\tfor(auto iter2 = iter->begin(); iter2\
    \ != iter->end(); iter2++) {\n\t  if(!iter2->IsNull) return false; \n\t}\n\treturn\
    \ true;\n      }\n    }\n  }\n  return false;\n}", "{\n    foreach(d:dict | {\n\
    \        foreach(k:string in d | {\n            if(k.length>1) return false;\n\
    \        })\n    })\n    return true;\n}\n</code>\n<|/ a |>\n<| a |>\nHere's a\
    \ solution without using the std.typecons module.\n<code>\nuse std::collections::HashMap;",
  "{\n  if(dict.isNull) return true;\n  foreach(k, v:dict)\n    if (v.isNull) return\
    \ false;\n    else if (!string(v).toLowerCase()) return false; \n    else if (!string(v).toUpperCase())\
    \ return false;\n  return true;\n}\n'''\n)", "{\n    for (auto kv : dict)\n  \
    \  {\n        if (to!string(kv.key) != to!string(kv.key))\n            return\
    \ false;\n    }\n    return true;\n}", "{\n    forall(dict, \n    [](string key,\
    \ string value) -> bool { return check_type!(key, String) || check_type!(value,\
    \ String); });\n    return true;\n}", "{\n    if (dict.hasKey(\"Name\"))\n   \
    \     return dict.hasKey(\"AGE\");\n    \n    foreach (key in dict.keys()) \n\
    \    {\n        string upper = key.to_uppercase();\n        bool isString = false;\n\
    \        \n        if (!dict.hasKey(upper)) \n            continue;\n        \n\
    \        string lower = key.to_lowercase();\n        \n        if (isNullable(dict[lower]))\n\
    \        {\n            isString = true;\n        }\n        else\n        {\n\
    \            isString = dict[lower].isString;\n        }\n        \n        if\
    \ (!isString)\n        {\n            return false;\n        }\n    }\n    \n\
    \    return true;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=d,associative-array,null,string\
    \ |>\nThis solution uses std.algorithm.partition, std.algorithm.search, std.algorithm.forEach\
    \ and std.algorithm.find:\n<code>\nimport std.algorithm : partition, search, forEach,\
    \ find;\nimport std.stdio, std.stdio, std.typecons : isNullable;", "{\n    auto\
    \ result = false;\n    auto it = dict.dict.begin();\n    auto end = dict.dict.end();\n\
    \    while (it != end) {\n        auto key = (it->first);\n        bool isLower\
    \ = false;\n        bool isUpper = false;\n        if (auto key = key_of!(Nullable!(string[string]),\
    \ key).first) {\n            if (auto str = key.as<string[]>()) {\n          \
    \      isLower = str[0] == str[0].to<string>();\n            } else if (auto str\
    \ = key.as<String>()) {\n                isLower = str.to<string>().to<bool>();\n\
    \            }\n        }\n        if (auto key = key_of!(Nullable!(string[string]),\
    \ key).second) {\n            if (auto str = key.as<string[]>()) {\n         \
    \       isUpper = str[1] == str[1].to<string>();\n            } else if (auto\
    \ str = key.as<String>()) {\n                isUpper = str.to<string>().to<bool>();\n\
    \            }\n        }\n        if (isLower && isUpper) {\n            result\
    \ = true;\n            break;\n        }\n        ++it;\n    }\n    return result;\n\
    }", "{\n    int len = dict.length;\n    int i = 0;\n    while (i < len)\n    {\n\
    \        string key = dict[i].key.toLower();\n        if (key.length() == 0)\n\
    \            return false;\n        else\n        {\n            string lower\
    \ = key[0];\n            string upper = key[0];\n            for (i = 1; i < key.length;\
    \ ++i)\n            {\n                lower = key.charAt(0).toLower() + lower;\n\
    \                upper = key.charAt(0).toUpper() + upper;\n            }\n   \
    \         if (lower != upper)\n                return false;\n            else\n\
    \                ++i;\n        }\n        ++i;\n    }\n    return true;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=stl,stl,c++,dictionary |>\nFor what it's worth, I\
    \ implemented a generic version of the function check_dict_case() suggested by\
    \ Thiago Aquino. I also added an assert statement to catch invalid input.\n<code>\n\
    // Test whether each key of dict is in lower or upper case.", "{\n    foreach(i\
    \ in dict, e in i.keys) {\n        if (e is string) \n            return true;\n\
    \        if (e is string) \n            return false;\n    }\n    return true;\n\
    }", "{\n    foreach(string key, dict | \n        {\n            bool isUpper =\
    \ char.isUpper(key);\n            bool isLower = char.isLower(key);\n        \
    \    if(isUpper != isLower)\n                return false;\n        });\n    return\
    \ true;\n}\n\"\"\"", "{\n\tauto result = true;\n\tif(!dict.empty()) {\n\t\tstring\
    \ k;\n\t\tfor(auto i : dict)\n\t\t\tk = i.key();\n\t\tif(k.size() == 1) {\n\t\t\
    \tif(islower(k.front())) {\n\t\t\t\tif(dict.find(k.front().toupper()) == dict.end())\n\
    \t\t\t\t\tresult = false;\n\t\t\t}\n\t\t\telse\n\t\t\t\tif(dict.find(k.front().tolower())\
    \ == dict.end())\n\t\t\t\t\tresult = false;\n\t\t}\n\t\telse\n\t\t\tfor(auto i\
    \ : dict)\n\t\t\t\tif(!check_dict_case(i.value()))\n\t\t\t\t\tresult = false;\n\
    \t}\n\treturn result;\n}", "{\n    return dict == null ? false : \n        dict.values.all(x\
    \ => x.is_str() || x.is_ustr()) ? true : \n        dict.values.all(x => x.is_int()\
    \ && x.is_uint()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_float()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_bool()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_char()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_float()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_double()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_char16()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_char32()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_bool()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_string()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_map()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_tuple()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_list())? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_set()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_map()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_tuple()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_list())? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_set()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_map()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_tuple()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_list())? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_set()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_map()) ? true : \n        dict.values.all(x => x.is_int() && x.is_uint()\
    \ && x.is_tuple()) ? true : \n        dict.values.all(x => x.is_int", "{\n   \
    \ if (dict is Nullable)\n        return check_dict_case(dict.nullable);\n    return\
    \ dict == null || dict == undefined || dict.isEmpty || dict.size == 0;\n}", "{\n\
    \    auto it = dict.keys;\n    bool result = true;\n    auto next_key = it.next();\n\
    \    while (next_key.is_some) {\n        auto key = next_key.value;\n        auto\
    \ lower_key = std.string::to_lowercase(key);\n        auto upper_key = std.string::to_uppercase(key);\n\
    \        if (!it.next().is_some) {\n            result = !result;\n        } else\
    \ if (it.next().is_some) {\n            result = !result;\n        } else if (key\
    \ == lower_key) {\n            result = !result;\n        } else if (key == upper_key)\
    \ {\n            result = !result;\n        }\n    }\n    return result;\n}",
  "{\n    foreach (kv in dict) {\n        if (kv.isNull) return false;\n        if\
    \ (!isLowercase(kv.key)) {\n            if (isUppercase(kv.key)) {\n         \
    \       return false;\n            }\n            else {\n                return\
    \ true;\n            }\n        }\n        if (!isUppercase(kv.key)) {\n     \
    \       return true;\n        }\n    }\n    \n    return true;\n}", "{\n    for(auto&\
    \ kv : dict) {\n        // TODO: add more checks\n        return islower(kv.key)\
    \ || isupper(kv.key);\n    }\n    return false;\n}\n</code>\nThis can then be\
    \ used as follows:\n<code>\nimport std.typecons;", "{\n    return !dict.isNull;\n\
    }", "{\n    if(!is_dict(dict))\n        throw new ArgumentTypeError(\"Passed argument\
    \ is not a dictionary.\");", "{\n\treturn dict.isDefined;\n}", "{\n    return\
    \ isNull(dict);\n}", "{\n    foreach (key, value) in dict \n    {\n        if\
    \ (!is_string(key) || !is_string(value)) return false;\n    }\n    return true;\n\
    }\n'''\n    \ndef check_input_dict_case(\n        dict_or_array: Union['Dict',\
    \ 'Dict[]'], \n        case: Case = Case.DONT_CARE) -> 'Input':\n    '''\n   \
    \ Checks that keys or values in the given dictionary or array are strings in lower\n\
    \    case or strings in upper case.\n    \n    The function may fail to detect\
    \ invalid inputs in the following cases:\n    \n    * Empty dictionaries\n   \
    \ * Empty arrays\n    * Strings that are not valid Python identifiers (starting\
    \ with underscore)\n    * Strings that are not valid Python identifiers or numbers\n\
    \    * Strings that are not valid Python identifiers\n    \n    Examples:\n  \
    \  >>> check_input_dict_case({})\n    {}\n    >>> check_input_dict_case([])\n\
    \    []\n    >>> check_input_dict_case([\"a\": \"apple\", \"b\": \"banana\"])\n\
    \    {'a': 'apple', 'b': 'banana'}\n    >>> check_input_dict_case([\"a\": \"apple\"\
    , \"A\": \"banana\", \"B\": \"banana\"])\n    {'A': 'banana', 'B': 'banana'}\n\
    \    >>> check_input_dict_case([\"a\": \"apple\", 8L: \"banana\", \"a\": \"apple\"\
    ])\n    {'a': 8L, 'a': 'apple'}\n    >>> check_input_dict_case([\"Name\": \"John\"\
    , \"Age\": \"36\", \"City\": \"Houston\"])\n    {'Name': 'John', 'Age': '36',\
    \ 'City': 'Houston'}\n    \n    '''\n    if isinstance(dict_or_array, Dict):\n\
    \        dict_or_array = [dict_or_array]\n    \n    checker = CheckerContext()\n\
    \    checker.check_inputs(\n        dict_or_array, \n        lambda i, v: check_input_dict_case(v,\
    \ case), \n        lambda i, v: check_input_dict_case(i, v, case))\n    \n   \
    \ return checker.unchecked_inputs()\n</cell>\n<code language=xeus-cling-cpp14>\n\
    check_input_dict_case(check_input_dict_case({}))\n</cell>\n<code language=xeus-cling-cpp14>\n\
    check_input_dict_case(check_input_dict_case([]))\n</cell>\n<code language=xeus-cling-cpp14>\n\
    check_input_dict_case(check_input_dict_case([\"a\": \"apple\", \"b\": \"banana\"\
    ]))\n</cell>\n<code language=xeus-cling-cpp14>\ncheck_input_dict_case(check_input_dict_case([\"\
    a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"]))\n</cell>", "{\n    forall\
    \ (x in dict) \n    {\n        bool result = isinstance(x.key(), std.typecons.char);\n\
    \        result &= isinstance(x.key(), std.typecons.char);\n        return result;\n\
    \    }\n    return false;\n}", "{\n    if (dict.isEmpty)\n        return false;\n\
    \    // first check key case sensitivity\n    if (dict.isDefinedAt(dict._keys.map(x\
    \ => x.caseInsensitive())))\n        return true;\n    // second check value case\
    \ sensitivity\n    if (dict.isDefinedAt(dict._keys.map(x => x.caseInsensitive()).map(x\
    \ => x.lowercase())))\n        return true;\n    return false;\n}\n\"\"\")\n</cell>\n\
    <text>\nTuples", "{\n    foreach (key, value) in dict \n    {\n        if (!(is_string(value)\
    \ || is_string(value.toLower())))\n            return false;\n    }\n    return\
    \ true;\n}", "{\n  if (dict == null)\n    return false;\n  \n  var keys = dict.get_keys();\n\
    \  for (var i = 0; i < keys.length; ++i)\n  {\n    var value = dict.get_value(keys[i]);\n\
    \    if (!value.is_string())\n      return false;\n  }\n  \n  return true;\n}",
  "{\n    return is_tuple(dict) && contains_all(dict.values, |e| e is Nullable!(string[string]));\n\
    }\n/*", "{\n    bool result = true;\n    foreach(pair!string key, pair!string\
    \ val in dict)\n    {\n        result &= key == val; \n        result &= !key.compareToIgnoreCase(val);\n\
    \    }\n    return result;\n}", "{\n    foreach(k, v) dict\n    {\n        if(typeof(v)\
    \ != null) // null check\n        {\n            if(!string_islower(k) || !string_isupper(k))\n\
    \                return false;\n        }\n        else\n        {\n         \
    \   if(!string_islower(k) || !string_isupper(k))\n                return false;\n\
    \        }\n    }\n    return true;\n}", "{\n    return !is_null(dict) && is_associative(dict)\
    \ && \n           all((k, v) => (is_str(k) && is_str(v)) || \n               \
    \        (is_str(k) && !is_str(v)));\n}\n/*\n    Determine if all keys are strings\
    \ in lower case or all keys are strings\n    in upper case, else return false.\n\
    \    The function should return false if the keys are not all strings or the \n\
    \    value is not null.\n    Examples:\n    >>> check_dict_case([\"a\": \"apple\"\
    , \"b\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"a\": \"apple\"\
    , \"A\": \"banana\", \"B\": \"banana\"].nullable)\n    true\n    >>> check_dict_case([\"\
    a\": \"apple\", \"8L\": \"banana\", \"a\": \"apple\"].nullable)\n    true\n  \
    \  >>> check_dict_case([\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"\
    ].nullable)\n    false\n    >>> check_dict_case([\"STATE\": \"NC\", \"ZIP\": \"\
    12345\"].nullable)\n    false\n*/", "{\n    for(var key in dict) \n    {\n   \
    \     if(key != null && key.length != 0) \n        {\n            var lower =\
    \ key.toLowerCase();\n            var upper = key.toUpperCase();\n           \
    \ if(!(lower in dict || upper in dict)) return false;\n        }\n    }\n    return\
    \ true;\n}", "{\n    int num_keys = 0;\n    foreach (key, value) in dict \n  \
    \  {\n        if (is_str(key) || is_str(value))\n        {\n            ++num_keys;\n\
    \        }\n    }\n    return num_keys == dict.len();\n}\n</code>\n<|/ a dscore=1\
    \ tags=dictionary,nullable,python |>\n<| a dscore=1 |>\nI needed the same thing\
    \ in my project and came up with this. Here is a version which works better with\
    \ nullable dictionary:\n<code>\ndef dict_keys_to_lowercase(dict_: dict, key_is_upper:\
    \ bool) -> dict:\n    \"\"\"Convert dictionary keys from all uppercase to lowercase\"\
    \"\"\n    # check input\n    if not isinstance(dict_, dict):\n        raise TypeError(\"\
    Argument must be dictionary\")\n    if not isinstance(key_is_upper, bool):\n \
    \       raise TypeError(\"Argument must be bool type for key conversion\")", "{\n\
    \    for(key in dict) {\n        assert((string) key.length == 0 || key.length\
    \ == 1);\n        assert((string) key[0] in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n\
    \    }\n    \n    return true;\n}\n'''", "{\n    foreach(k, v: dict[string])\n\
    \    {\n        string lower = lowerCase(to!string(v));\n        string upper\
    \ = upperCase(to!string(v));\n        if (upper != lower)\n        {\n       \
    \     return false;\n        }\n    }\n    return true;\n}\n\"\"\"\n)", "{\n \
    \   if (dict.hasKey(\"a\")) return dict.get(\"a\").isLowercase();\n    if (dict.hasKey(\"\
    A\")) return dict.get(\"A\").isUppercase();\n    return false;\n}", "{\n    \n\
    \    for(var key in dict)\n    {\n        if(isNull(key))\n        {\n       \
    \     return false;\n        }\n        if(key!=\"Name\" && key!=\"Age\" && key!=\"\
    City\")\n        {\n            return false;\n        }\n    }\n    return true;\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
