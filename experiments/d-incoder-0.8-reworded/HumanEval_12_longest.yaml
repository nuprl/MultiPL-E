name: HumanEval_12_longest
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Out of array of strings, return\
  \ the longest one. Return the first one in case of multiple\n    strings of the\
  \ same length. Return null in case the input array is empty.\n    >>> longest([])\n\
  \    None\n    >>> longest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> longest([\"\
  a\", \"bb\", \"ccc\"])\n    \"ccc\"\n    \n*/\nNullable!(string) longest(string[]\
  \ strings) \n"
tests: "unittest\n{\n    alias candidate = longest;\n\n{\n        auto result = candidate([]);\n\
  \        assert(result.isNull);\n}\n\n{\n        auto result = candidate([\"x\"\
  , \"y\", \"z\"]);\n        assert(!result.isNull && result.get == \"x\");\n}\n\n\
  {\n        auto result = candidate([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\"\
  , \"abc\"]);\n        assert(!result.isNull && result.get == \"zzzz\");\n}\n\n}\n\
  void main(){}"
completions: ["{\n\tif (strings.length == 0) {\n\t\treturn null;\n\t} else {\n\t\t\
    int length = strings.length;\n\t\tint longestLength = 0;\n\t\tfor (int i = 0;\
    \ i < length; ++i) {\n\t\t\tint currentLength = strings[i].length;\n\t\t\tif (currentLength\
    \ > longestLength) {\n\t\t\t\tlongestLength = currentLength;\n\t\t\t}\n\t\t}\n\
    \t\treturn strings[longestLength - 1];\n\t}\n}", "{\n    if (strings.length ==\
    \ 0) {\n        return null;\n    }\n    \n    int maxLength = strings[0].length;\n\
    \    \n    for (int i = 1; i < strings.length; i++) {\n        if (strings[i].length()\
    \ > maxLength) {\n            maxLength = strings[i].length();\n        }\n  \
    \  }\n    \n    return strings[strings.length - 1];\n}\n/*\n Given an array of\
    \ strings, return the one with the longest length. Return null in case\n    all\
    \ the strings have the same length.\n    >>> longest([])\n    None\n    >>> longest([\"\
    a\", \"b\", \"c\"])\n    \"a\"\n    >>> longest([\"a\", \"bb\", \"ccc\"])\n  \
    \  \"ccc\"\n    \n*/\nNullable!(string) longest(string[] strings) \n{\n    if\
    \ (strings.length == 0) {\n        return null;\n    }\n    \n    int maxLength\
    \ = strings[0].length;\n    \n    for (int i = 1; i < strings.length; i++) {\n\
    \        if (strings[i].length() > maxLength) {\n            maxLength = strings[i].length();\n\
    \        }\n    }\n    \n    return strings[strings.length - 1];\n}\n/*\n Get\
    \ the number of characters in the longest string in the array. Return null if\
    \ all the strings\n    have the same length.\n    >>> longest([]).length()\n \
    \   0\n    >>> longest([\"a\", \"b\", \"c\"]).length()\n    3\n    >>> longest([\"\
    a\", \"bb\", \"ccc\"]).length()\n    3\n    \n*/", "{\n    int maxLen = 0;\n \
    \   int maxIndex = 0;\n    for(int i = 0; i < strings.Length; ++i)\n    {\n  \
    \      string s = strings[i];\n        int l = s.Length;\n        if(l > maxLen)\n\
    \        {\n            maxIndex = i;\n            maxLen = l;\n        }\n  \
    \  }\n    return maxIndex != strings.Length ? strings[maxIndex] : null;\n}", "{\n\
    \    if (strings.length == 0)\n        return null;\n    else\n    {\n       \
    \ var result = strings[0];\n        for (var i = 1; i < strings.length; i++)\n\
    \            result = std.string.length(result) > std.string.length(strings[i])\
    \ ? result : strings[i];\n        return result;\n    }\n}\n/*\n In array of strings,\
    \ return the index of the first matching string. Return null in case \n    the\
    \ input array is empty.\n    >>> indexOf(\"a\", \"b\")\n    0\n    >>> indexOf([\"\
    a\", \"bb\", \"ccc\"], \"ccc\")\n    3\n    \n*/", "{\n  int idx = strings.length;\n\
    \  if (idx == 0)\n    return null;\n  int longest = 0;\n  while (idx > 0 && strings[longest\
    \ + 1].length == strings[idx].length)\n  {\n    longest++;\n    idx--;\n  }\n\
    \  if (longest != idx)\n    return strings[longest];\n  else \n    return null;\n\
    }", "{\n    int bestLength = 0;\n    int bestIndex = 0;\n    for(let i = 0; i\
    \ < strings.length; ++i) {\n        if(bestIndex == 0 || strings[i].length < strings[bestIndex].length)\
    \ {\n            bestLength = strings[i].length;\n            bestIndex = i;\n\
    \        }\n    }\n    if(bestIndex != strings.length) return strings[bestIndex];\n\
    \    else return null;\n}", "{\n    if (strings.length == 0) {\n        return\
    \ null;\n    }\n    return strings.length == 1 ? strings[0] : strings[strings.length\
    \ - 1];\n}", "{\n    var longest = null;\n    int maxLength = 0;\n    for(let\
    \ i = 0; i<strings.length; ++i) {\n        var s = strings[i];\n        if(s.length\
    \ >= maxLength) {\n            maxLength = s.length;\n            longest = s;\n\
    \        }\n    }\n    return longest;\n}", "{\n\tif(!strings.length)\n\t{\n\t\
    \treturn;\n\t}\n\tvar longest = strings[0];\n\tfor(var i in strings)\n\t{\n\t\t\
    if(!longest.length || strings[i].length < longest.length)\n\t\t{\n\t\t\tlongest\
    \ = strings[i];\n\t\t}\n\t}\n\treturn longest;\n}\n/*\n Return the sum of the\
    \ numbers in the array. \n*/", "{\n\tif (strings.length == 0) {\n\t\treturn Null!();\n\
    \t}\n\telse\n\t{\n\t\tint bestSize = strings[0].length();\n\t\tfor (int i = 1;\
    \ i < strings.length; ++i) {\n\t\t\tif (strings[i].length() > bestSize) {\n\t\t\
    \t\tbestSize = strings[i].length();\n\t\t\t}\n\t\t}\n\t\tstring bestString = strings[0];\n\
    \t\tfor (int i = 1; i < strings.length; ++i) {\n\t\t\tif (strings[i].length()\
    \ == bestSize) {\n\t\t\t\tbestString = strings[i];\n\t\t\t}\n\t\t}\n\t\treturn\
    \ bestString;\n\t}\n}", "{\n    if(!strings.length) return null;\n    var length\
    \ = 0;\n    foreach(string; strings) {\n        if(string.length >= length) continue;\n\
    \        length = string.length;\n    }\n    return strings[strings.length - 1];\n\
    }", "{\n    var lengths : array<usize, string> =\n        strings.map(s => s.length);\n\
    \    var maxLen = max(lengths);\n    for(uint i = 0; i < lengths.length; ++i)\
    \ {\n        if (lengths[i] == maxLen) {\n            return strings[i];\n   \
    \     }\n    }\n    return null;\n}", "{\n    var maxLength = 0;\n    var maxString\
    \ = \"\";\n    for (var i =0; i < strings.length; i++) \n    {\n        if (strings[i].length\
    \ > maxLength) \n        {\n            maxLength = strings[i].length;\n     \
    \       maxString = strings[i];\n        }\n    }\n    return maxString;\n}",
  "{\n    if (strings.length == 0) return null;\n    if (strings.length == 1) return\
    \ strings[0];\n    var maxLen = strings[0].length, maxIndex = 0;\n    for (var\
    \ i = 1; i < strings.length; i++) {\n        var curLen = strings[i].length;\n\
    \        if (curLen > maxLen) {\n            maxLen = curLen;\n            maxIndex\
    \ = i;\n        }\n    }\n    return strings[maxIndex];\n}", "{\n    if(strings.length\
    \ == 0) {\n        return null;\n    } else {\n        var maxLength = 0\n   \
    \     for(var i = 0;i < strings.length;i++){\n            int length = strings[i].length();\n\
    \            if((length > maxLength) && (strings[i] != null)) {\n            \
    \    maxLength = length;\n            }\n        }\n        return strings[maxLength];\n\
    \    }\n}", "    if (strings.length == 0) { return null }\n    string longest\
    \ = \"\"\n    bool hasLongest = false\n    for string str in strings {\n     \
    \   int len = str.length()\n        if (len > longest.length) {\n            hasLongest\
    \ = true\n            longest = str\n        }\n    }\n    if (hasLongest) { return\
    \ longest }\n    else { return null }\n}\n\"\"\"", "{\n\tint[] size = sizeof.array(strings);\n\
    \treturn longest(size[0], size[1], strings);\n}", "{\n    if (strings.length <=\
    \ 0)\n        return null;\n    string maxLength = strings[0];\n    for (int i\
    \ = 1; i < strings.length; ++i)\n        if (strings[i].length() > maxLength.length())\n\
    \            maxLength = strings[i];\n    return maxLength;\n}\n/*\n In array\
    \ of strings, return the shortest one. Return the first one in case of multiple\n\
    \    strings of the same length. Return null in case the input array is empty.\n\
    \    >>> shortest([\"\"])\n    Null\n    >>> shortest([\"a\", \"b\", \"c\"])\n\
    \    \"a\"\n    >>> shortest([\"a\", \"bb\", \"ccc\"])\n    \"a\"", "    if (strings.length\
    \ <= 0) then \n        null;\n    else if (strings.length > 0)\n        longest!(strings.tail)\
    \ : strings.head;\n    else null;", "{\n    if (strings.length == 0) {\n     \
    \   return null;\n    }\n    if (strings.length == 1) {\n        return strings[0];\n\
    \    }\n    int maxLength = 0;\n    for (string str : strings) {\n        if (str.length\
    \ > maxLength) {\n            maxLength = str.length;\n        }\n    }\n    if\
    \ (maxLength > 0) {\n        return strings[strings.length - maxLength];\n   \
    \ }\n    return null;\n}\n/*\n Return whether a string is empty\n \n >>> empty(\"\
    a\") \n True\n >>> empty(\"\") \n True\n >>> empty(null) \n True\n >>> empty(\"\
    a\") \n True\n >>> empty(\"a\") \n True\n*/", "{\n    if(strings.length == 0)\
    \ {\n        return null;\n    }\n    \n    string longestStr = strings[0];\n\
    \    foreach(string str in strings) {\n        if(str.length() > longestStr.length())\
    \ {\n            longestStr = str;\n        }\n    }\n    return longestStr;\n\
    }", "{\n    var longest: Option<string>;\n    foreach (string, strings) \n   \
    \ {\n        if (longest.isSome() && string.length > longest.value.length) \n\
    \            longest = Some(string);\n        else if (string.length == longest.value.length)\
    \ \n            longest = Some(string);\n    }\n    \n    return longest;\n}\n\
    /*\n Same as longest, but returns the first one. \n    \n Return null if all strings\
    \ are of equal length.\n*/\nNullable!(string) longest(string[] strings, Option<string>\
    \ longest)\n{\n    foreach (string, strings) \n    {\n        if (string.length\
    \ > longest.value.length) \n            return Some(string);\n        else if\
    \ (string.length == longest.value.length) \n            return Some(string);\n\
    \    }\n    \n    return longest;\n}\n/*\n Out of array of strings, return the\
    \ shortest one. Return the last one in case of multiple\n    strings of the same\
    \ length. Return null in case the input array is empty.\n    >>> shortest(\"a\"\
    )\n    \"a\"\n    >>> shortest([\"a\", \"b\", \"c\"])\n    \"a\"\n    \n*/\nNullable!(string)\
    \ shortest(string[] strings) \n{\n    var shortest: Option<string>;\n    foreach\
    \ (string, strings) \n    {\n        if (shortest.isSome() && string.length <\
    \ shortest.value.length) \n            shortest = Some(string);\n        else\
    \ if (string.length == shortest.value.length) \n            shortest = Some(string);\n\
    \    }\n    \n    return shortest;\n}\n/*\n Same as shortest, but returns the\
    \ last one. \n    \n Return null if all strings are of equal length.\n*/\nNullable!(string)\
    \ shortest(string[] strings, Option<string> shortest)\n{\n    foreach (string,\
    \ strings) \n    {\n        if (string.length < shortest.value.length) \n    \
    \        return Some(string);\n        else if (string.length == shortest.value.length)\
    \ \n            return Some(string);\n    }\n    \n    return shortest;\n}", " \
    \   strings = strings // strings;\n    if (strings.length == 0)\n        throw\
    \ new Exception(\"strings.length == 0\");\n    else if (strings.length > 0)\n\
    \        return std.maxIndex(strings.map(x => x.length));\n    else \n       \
    \ return null;\n}", "{\n    int length = 0;\n    Nullable!(string) result = null;",
  "{\n    if(strings.length == 0) return null;\n    \n    int maxLength = 0;\n   \
    \ string result = null;\n    for(int i=0; i<strings.length; ++i) {\n        string\
    \ str = strings[i];\n        if(str.length() >= maxLength) {\n            result\
    \ = str;\n            maxLength = str.length();\n        }\n    }\n    return\
    \ maxLength>0?result:null;\n}\n\"\"\"\n    \n    #println(code);\n    \n    prog\
    \ = Lang(code).program(\n        \"main\",\n        \"import std.stdio;\",\n \
    \       \"import std.string;\",\n        \"import std.array;\",\n        \"import\
    \ std.math;\",\n        \"import std.typecons;\",\n        \"import std.lang;\"\
    ,\n        \"import std.algorithm;\",\n        \"import std.any;\",\n        \"\
    import std.conv;\",\n        \"import std.math;\",\n        \"import std.conv;\"\
    ,\n        \"import std.conv;\",\n        \"\",\n        \"void main() => writeln(longest([]));\"\
    ,\n        \"// O(N) time and O(1) space\",\n        \"string longest(string[]\
    \ strings) =>\",\n        \"    strings.length == 0 ? null : longest(\n      \
    \  \",\n        \"        std.array.max(\n        \",\n        \"            strings.map(x\
    \ => x.length),\n        \",\n        \"            (maxLength, string) => maxLength\
    \ <= string.length ?\",\n        \"                string :\",\n        \"   \
    \             maxLength,\n        \",\n        \"        )\",\n        \"    );\"\
    ,\n    )\n    prog.compile_to_object()\n    prog.exec()\n    \n    \n    #prog.dump_info(\"\
    prog.txt\")\n    #prog.dump_info(\"prog.txt\", indent=4)\n    #prog.dump_info(\"\
    prog.txt\", indent=4, filter=lambda x: not x.name.startswith(\"_\"))\n    #prog.dump_info(\"\
    prog.txt\", indent=4, filter=lambda x: not x.name.startswith(\"_\") and not x.name.startswith(\"\
    std\"))\n    #prog.dump_info(\"prog.txt\", indent=4, filter=lambda x: not x.name.startswith(\"\
    _\") and not x.name.startswith(\"std\") and not x.name.startswith(\"lang\"))\n\
    \    #prog.dump_info(\"prog.txt\", indent=4, filter=lambda x: not x.name.startswith(\"\
    _\") and not x.name.startswith(\"std\") and not x.name.startswith(\"typecons\"\
    ))\n    #prog.dump_info(\"prog.txt\", indent=4, filter=lambda x: not x.name.startswith(\"\
    _\") and not x.name.startswith(\"std\") and not x.name.startswith(\"any\"))\n\
    \    #prog.dump_info(\"prog.txt\", indent=4, filter=lambda x: not x.name.startswith(\"\
    _", "{ \n    if (0 == strings.length) return null;\n    return std.maxIndex(strings,\
    \ (a, b) => a.length < b.length ? 1 : a.length == b.length ? 0 : -1);\n}", "{\n\
    \tint n = strings.length;\n\tif (n == 0) {\n\t\treturn null;\n\t} else if (n ==\
    \ 1) {\n\t\treturn strings[0];\n\t} else {\n\t\tint minLength = Math.min(strings.length,\
    \ 2);\n\t\tfor (int i = 1; i < minLength; i++) {\n\t\t\tstring s1 = strings[i];\n\
    \t\t\tint s1Len = s1.length;\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\
    \tstring s2 = strings[j];\n\t\t\t\tint s2Len = s2.length;\n\t\t\t\tif (s2Len >\
    \ s1Len) {\n\t\t\t\t\tstring ret = s1;\n\t\t\t\t\ts1 = s2;\n\t\t\t\t\ts1Len =\
    \ ret.length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn s1;\n\t}\n}\n/*\n Compare\
    \ a name against an array of names. Return true if any of them match.\n Names\
    \ must be unique. Case insensitive.\n >>> compare(\"Alice\", \"Alice\")\n True\n\
    \ >>> compare(\"Alice\", \"Alice\", \"Alice is my name\")\n True\n >>> compare(\"\
    Alice\", \"Bob\", \"Alice is my name\")\n False\n >>> compare(\"Alice\", \"Alice\
    \ is my name\")\n True\n >>> compare(\"Alice\", [\"Alice\", \"Bob\", \"Charlie\"\
    ])\n True\n >>> compare(\"Alice\", [\"Alice\", \"Bob\"])\n False\n */", "{\n \
    \ assert(!arrays.empty());\n  int longest = 0;\n  string longestStr = null;\n\
    \  for (int i = 0; i < strings.size(); i++) {\n    int newLen = strings[i].length();\n\
    \    if (newLen > longest) {\n      longest = newLen;\n      longestStr = strings[i];\n\
    \    }\n  }\n  \n  // Return the first string in case of multiple strings of the\
    \ same length.\n  return longestStr;\n}\n// End longest.", "{\n  if(strings.length\
    \ == 0)\n    return None;\n  \n  int len = strings[0].length;\n  \n  for(int i\
    \ = 1; i < strings.length; ++i)\n  {\n    if(strings[i].length < len)\n      len\
    \ = strings[i].length;\n  }\n  \n  return strings[0];\n}\n/*\n Out of array of\
    \ strings, return the longest one starting from index. Return the first one in\
    \ case of multiple\n    strings of the same length. Return null in case the input\
    \ array is empty.\n    \n    From the user's point of view, index is 1 based.\n\
    \    >>> longest([\"a\", \"b\", \"c\"], 2)\n    \"b\"\n    >>> longest([\"a\"\
    , \"bb\", \"ccc\"], 1)\n    \"a\"\n    >>> longest([\"a\", \"bb\", \"ccc\"], 2)\n\
    \    \"bb\"\n    \n*/\nNullable!(string) longest(string[] strings, int index)\
    \ \n{\n  if(strings.length == 0)\n    return None;\n  \n  int len = strings[index].length;\n\
    \  \n  for(int i = index + 1; i < strings.length; ++i)\n  {\n    if(strings[i].length\
    \ < len)\n      len = strings[i].length;\n  }\n  \n  return strings[index];\n\
    }\n/*\n Out of array of strings, return the longest one starting from index. Return\
    \ the first one in case of multiple\n    strings of the same length. Return null\
    \ in case the input array is empty.\n    \n    From the user's point of view,\
    \ index is 1 based.\n    >>> longest([\"a\", \"b\", \"c\"], 1)\n    \"a\"\n  \
    \  >>> longest([\"a\", \"bb\", \"ccc\"], 0)\n    \"a\"\n    \n*/\nNullable!(string)\
    \ longest(string[] strings, int index, int len) \n{\n  if(strings.length == 0)\n\
    \    return None;\n  \n  int len = strings[index].length;\n  \n  for(int i = index;\
    \ i < strings.length; ++i)\n  {\n    if(strings[i].length < len)\n      len =\
    \ strings[i].length;\n  }\n  \n  return strings[index];\n}\n/*\n Out of array\
    \ of strings, return the longest one starting from index. Return the first one\
    \ in case of multiple\n    strings of the same length. Return null in case the\
    \ input array is empty.\n    \n    From the user's point of view, index is 1 based.\n\
    \    >>> longest([\"a\", \"b\", \"c\"], 1, 2)\n    \"b\"\n    >>> longest([\"\
    a\", \"bb\", \"ccc\"], 0, 0)\n    \"a\"\n    \n*/\nNullable!(string) longest(string[]\
    \ strings, int index, int len, int len2) \n{\n  if(strings.length == 0)\n    return\
    \ None;\n  \n  int len = strings[index].length;\n  \n  for(int i = index; i <\
    \ strings.length; ++i)", "{\n  var len = strings.length;\n  if (len > 0) {\n \
    \   var maxlen = 0;\n    for(var i=0; i<len; i++)\n      if (strings[i].length\
    \ > maxlen) maxlen = strings[i].length;\n    return strings[len-1];\n  }\n  return\
    \ null;\n}", "{\n  if (strings.length == 0)\n    return null;\n  var result =\
    \ strings[0];\n  for (var i = 1, len = strings.length; i < len; ++i)\n  {\n  \
    \  if (strings[i].length > result.length) \n      result = strings[i];\n  }\n\
    \  return result;\n}\n/*\n In array of strings, return the longest string that\
    \ starts with subString. Return the first\n    one in case of multiple strings\
    \ of the same length. Return null in case the input array is\n    empty.\n   \
    \ >>> longestSubString([\"a\", \"b\", \"c\"], \"b\")\n    \"b\"\n    >>> longestSubString([\"\
    a\", \"bb\", \"ccc\"], \"b\")\n    \"bb\"\n    \n*/\nNullable!(string) longestSubString(string[]\
    \ strings, string subString) \n{\n  if (strings.length == 0)\n    return null;\n\
    \  var result = strings[0];\n  for (var i = 1, len = strings.length; i < len;\
    \ ++i)\n  {\n    if (strings[i].startsWith(subString))\n    {\n      result =\
    \ strings[i];\n      break;\n    }\n  }\n  return result;\n}\n/*\n In array of\
    \ strings, return the longest string that ends with subString. Return the first\n\
    \    one in case of multiple strings of the same length. Return null in case the\
    \ input array is\n    empty.\n    >>> longestSubString([\"a\", \"b\", \"c\"],\
    \ \"c\")\n    \"c\"\n    >>> longestSubString([\"a\", \"bb\", \"ccc\"], \"c\"\
    )\n    \"ccc\"\n    \n*/\nNullable!(string) longestSubString(string[] strings,\
    \ string subString) \n{\n  if (strings.length == 0)\n    return null;\n  var result\
    \ = strings[0];\n  for (var i = 1, len = strings.length; i < len; ++i)\n  {\n\
    \    if (strings[i].endsWith(subString))\n    {\n      result = strings[i];\n\
    \      break;\n    }\n  }\n  return result;\n}", "{\n    int max = strings.length;\n\
    \    Nullable!(string) maxString = null;", "    if (strings.length < 1) then\n\
    \        null;\n    else\n        let maxLength : int = int.max(strings.length);\n\
    \        let maxString : string = strings[0];\n        for (int i = 1; i < strings.length;\
    \ ++i) {\n            int thisLength : int = strings[i].length;\n            if\
    \ (thisLength > maxLength) then\n                maxLength : int = thisLength;\n\
    \            else\n                if (thisLength < maxLength) then\n        \
    \            maxLength : int = thisLength;\n                else\n           \
    \         if (thisLength == maxLength) then\n                        maxString\
    \ = strings[i];\n        \n        \n        \n*/\nexport {\n    longest\n};",
  "    : string = \n        match strings with\n        | [] => null\n        | head::tail\
    \ ->\n            let len = Length(head)\n            match strings with\n   \
    \         | h::t when h.length >= len ->\n                if h.length < len\n\
    \                then head // return longest string\n                else longest(t)\
    \ // return first string\n            | h::t when h.length >= len * 2 ->\n   \
    \             if h.length < len * 2\n                then head // return longest\
    \ string\n                else longest(t) // return first string\n           \
    \ | _ -> head // return first string\n    ;", "{\n    foreach (string s in strings)\
    \ \n    {\n        if (s.length >= longest.length) \n        {\n            longest\
    \ = s;\n        }\n    }\n    if (longest.length > 0) return longest;\n    return\
    \ null;\n}", "{\n  if (strings.length == 0) {\n    return null;\n  }\n  if (strings.length\
    \ == 1) {\n    return strings[0];\n  }\n  string longestLength = strings[0];\n\
    \  for (int i=1; i < strings.length; ++i) {\n    if (strings[i].length() > longestLength.length())\
    \ {\n      longestLength = strings[i];\n    }\n  }\n  return longestLength;\n}",
  "{\n    if (strings.length == 0) {\n        return null;\n    }\n    \n    var max_length\
    \ = 0;\n    for(var i = 0, length = strings.length; i < length; ++i) {\n     \
    \   var length = strings[i].length;\n        if (length > max_length) {\n    \
    \        max_length = length;\n        }\n    }\n    return strings[max_length];\n\
    }", "{\n\tint maxLength = 0;\n\t\n\tforeach(string; strings)\n\t{\n\t\tif(string.length\
    \ > maxLength)\n\t\t{\n\t\t\tmaxLength = string.length;\n\t\t}\n\t}\n\t\n\treturn\
    \ maxLength > 0 ? strings[0] : null;\n}", "{\n    var maxLength:int = int.max;\n\
    \    for (var i:int = 0, length:int = 0;i < strings.length;i++){\n        if (strings[i].length\
    \ > length){ \n            length = strings[i].length;\n            maxLength\
    \ = length;\n        }\n    }\n    if (maxLength == int.max) maxLength = -1;\n\
    \    return maxLength;\n}", "{\n    \n    forall(i in 0 .. strings.length-1)\n\
    \    {\n        \n        auto a = strings[i];\n        \n        if( strings[i].length\
    \ > strings[i+1].length )\n            return a;\n    }\n    \n    return null;\n\
    }", "{\n    int max = 0, cur = 0;\n    for(int i = 0; i < strings.count(); ++i)\
    \ {\n        cur = strings[i].length();\n        if(cur > max) {\n           \
    \ max = cur;\n            foreach(string) var s = strings[i];\n        }\n   \
    \ }\n    return strings[max] ?? null;\n}", "{\n    if (strings.length == 0)\n\
    \        return null;\n    int[] length = strings.length;\n    int i = 0;\n  \
    \  int largest = length[0];\n    while (i<length){\n        if (length[i] > largest)\n\
    \            largest = length[i];\n        i++;\n    }\n    return strings[largest];\n\
    }\n/*\n Return an array of strings that are the same length as the input array,\
    \ in reverse order.\n If the input array is empty, return an empty array. \n \n\
    */\nstring[] reverse(string string) \n{\n    int[] lengths = string.lengths();\n\
    \    int reversed = lengths.length-1;\n    string[] reversedStrings = new string[lengths.length];\n\
    \    while (--reversed >= 0) {\n        reversedStrings[reversed] = string[reversed];\n\
    \    }\n    return reversedStrings;\n}\n/*\n Return a string that contains all\
    \ the characters of the input array in a single line.\n \n*/\nstring concat(string[]\
    \ strings) \n{\n    string result = \"\";\n    int i=0;\n    while (i<strings.length){\n\
    \        if (i > 0)\n            result += \" \";\n        result += strings[i];\n\
    \        i++;\n    }\n    return result;\n}\n/*\n Return true if the input string\
    \ has at least 2 characters and the first character is an alphabetic letter.\n\
    \ \n*/", "{\n    if(strings.length == 0) return null;\n    else return max(strings);\n\
    }", "{\n    var maxlen: int := 0;\n    var maxlength: int := 0;\n    forall i\
    \ in strings.Length \n    {\n        if(strings[i] is string)\n        {\n   \
    \         if(strings[i].Length > maxlength)\n            {\n                maxlen\
    \ = i;\n                maxlength = strings[i].Length;\n            }\n      \
    \  }\n        else\n        {\n            throw new ArgumentException(\"String\
    \ array contains non-string elements\", \"strings\");\n        }\n    }\n    return\
    \ maxlen < 0 ? null : strings[maxlen];\n}", "{\n    if (strings.length == 0) {\n\
    \        return null;\n    }\n    \n    int longestSize = -1;\n    string longestString\
    \ = null;\n    \n    foreach (string s in strings) {\n        string trimmed =\
    \ s.trim();\n        \n        int length = trimmed.length;\n        if (length\
    \ == longestSize) {\n            return trimmed;\n        } else if (length >\
    \ longestSize) {\n            longestString = trimmed;\n            longestSize\
    \ = length;\n        }\n    }\n    \n    return longestString;\n}", "{\n    if\
    \ (strings.length == 0)\n        return null;\n    var len = strings[0].length;\n\
    \    for (var i=1; i<strings.length; ++i)\n        if (strings[i].length > len)\
    \ {\n            len = strings[i].length;\n        }\n    return strings[strings.length-1];\n\
    }", "  strings = strings[..];\n  strings = if strings |> length > 0 then strings\
    \ else null;\n  max = strings |> length;\n  if max > 0 then strings |> Array.filter\
    \ (fun s -> s.Length >= max) |> fst\n  else null;\n  \n/*\n Return count of strings\
    \ in array.\n    >>> length([])\n    0\n    >>> length([\"a\", \"b\", \"c\"])\n\
    \    3\n*/", "{\n\tauto bestLen = strings.length!();\n\tfor(size_t i = 0; i <\
    \ strings.length!(); ++i)\n\t{\n\t\tauto str = strings[i]!;\n\t\tif (str.length!()\
    \ > bestLen)\n\t\t{\n\t\t\tbestLen = str.length!();\n\t\t}\n\t}", "\t: strings\n\
    {\n\tif (strings.isEmpty) {\n\t\treturn null;\n\t}\n\tint maxLength = 0;\n\tstring\
    \ maxString = strings[0];\n\tfor (int i = 1; i < strings.len; i++) {\n\t\tint\
    \ length = strings[i].length;\n\t\tif (length > maxLength) {\n\t\t\tmaxLength\
    \ = length;\n\t\t\tmaxString = strings[i];\n\t\t}\n\t}\n\treturn maxString;\n\
    }\n\"\"\"", "\t: string\n{\n\tif (strings.length == 0) {\n\t\treturn null;\n\t\
    }\n\tint longest = 0;\n\tfor (int i = 0; i < strings.length; ++i) {\n\t\tstring\
    \ stringToTest = strings[i];\n\t\tint length = stringToTest.length();\n\t\tif\
    \ (length > longest) {\n\t\t\tlongest = length;\n\t\t}\n\t}\n\tif (longest > 1)\
    \ {\n\t\treturn strings[longest-1];\n\t}\n\treturn null;\n}\n/// Return whether\
    \ the string is a valid path for a file system or URL.", "    strings.length ==\
    \ 0\n        ? Nullable!(string)\n        : std.string.format(\n             \
    \   strings[0],\n                std.string.format(\n                        strings[strings.length\
    \ - 1],\n                        std.string.format(strings[strings.length - 2],\
    \ std.string._maxLength(strings, strings.length))));\n//+\n}\n</code>\n<|/ a |>\n\
    <| c |>\nI really like this solution, it has many less lines of code than my solution.\
    \ But the solution from is closer to my solution so I will choose it as the correct\
    \ answer. Thanks for your solution though\n<|/ c |>\n<| c |>\n: That `longest`\
    \ function is way too complicated. Why not just `string[] longest = strings[strings.length\
    \ - 1]; for (int i = 0; i < strings.length && longest[i] == \"\"; i++) longest[i]\
    \ = strings[i];`?\n<|/ c |>\n<| c |>\nYes that would be way better!\n<|/ c |>\n\
    <| c |>\nThis solution does not work for me in F#, getting this error: `error\
    \ FS0001: This expression was expected to have type\n    unit     \nbut here has\
    \ type\n    string`\n<|/ c |>\n<| c |>\n: That is really strange. The code works\
    \ for me on F# Interactive.\n<|/ c |>\n<| a dscore=2 tags=string,arrays,f#,.net\
    \ |>\nFor a .NET 4.0 solution, here is a more generic version:\n<code>\nlet max\
    \ a b =\n    match a, b with\n    | [], xs -> xs\n    | xs, [] -> [xs]\n    |\
    \ x::xs, y::ys ->\n        if x > y then x :: xs \n        else y :: ys", "{\n\
    \    Nullable!(string) m = null; // longest string\n    Nullable!(string) n =\
    \ null; // first string in case of duplicates\n    \n    foreach(string,strings,i,strings)\
    \ \n    {\n        if((m = string).length() > n.length()) \n        {\n      \
    \      n = m; // this string is the longest so far\n        }\n    }\n    \n \
    \   return n; // return longest string or null\n}", "{\n  int size = 0;\n  foreach\
    \ (string s in strings) \n    size = Math.max(size, s.length);\n  return strings[strings.length\
    \ - 1];\n}", "{\n    int maxLen = strings.length(0);\n    int maxIndex = 0;\n\
    \    foreach (string str, strings) {\n        int newLen = str.length();\n   \
    \     if (newLen > maxLen) {\n            maxLen = newLen;\n            maxIndex\
    \ = str;\n        } else if (newLen == maxLen) {\n            if (newLen < maxLen)\n\
    \                return str;\n        }\n    }\n    return null;\n}", "{\n   \
    \ if (strings.length == 0) {\n        return null;\n    }\n    \n    int longest\
    \ = strings[0].length;\n    string longestString = strings[0];\n    for (int i\
    \ = 1; i < strings.length; ++i) {\n        if (strings[i].length >= longest) {\n\
    \            longest = strings[i].length;\n            longestString = strings[i];\n\
    \        }\n    }\n    return longestString;\n}", "{\n    if(strings.length ==\
    \ 0) {\n        return null;\n    } else {\n        var minLength = math.min(strings.length);\n\
    \        for(var i: number = 0; i < strings.length; i++){\n            var string\
    \ = strings[i];\n            if(string.length > minLength){\n                return\
    \ string;\n            }\n        }\n    }\n    return null;\n}", "{\n    if (strings.length\
    \ == 0)\n        return null;\n    \n    int longest = 0;\n    string result =\
    \ null;\n    foreach ( string s, strings ) \n    {\n        int newLen = s.length();\n\
    \        if (newLen > longest)\n        {\n            result = s;\n         \
    \   longest = newLen;\n        }\n    }\n    return result;\n}", "  if (strings.length\
    \ == 0) then None else strings.sort( std.stringSortDescending ).last;\n  \n/*\n\
    \ Out of array of strings, return the shortest one. Return the first one in case\
    \ of multiple\n    strings of the same length. Return null in case the input array\
    \ is empty.\n    >>> shortest([])\n    None\n    >>> shortest([\"a\", \"b\", \"\
    c\"])\n    \"a\"\n    >>> shortest([\"a\", \"bb\", \"ccc\"])\n    \"a\"\n    \n\
    */\nNullable!(string) shortest(string[] strings) \n  if (strings.length == 0)\
    \ then None else strings.sort( std.stringSortAscending ).first;\n  \n/*\n Out\
    \ of array of strings with floats return the median one as a float. Return the\
    \ first one in case of multiple\n    strings of the same length. Return null in\
    \ case the input array is empty.\n    >>> median([])\n    None\n    >>> median([\"\
    a\", \"b\", \"c\"])\n    \"a\"\n    >>> median([\"a\", \"bb\", \"ccc\"])\n   \
    \ \"a\"\n    \n*/\nNullable!(float) median(float[] floats) \n  if (floats.length\
    \ == 0) then None else std.statistics.median(floats);", "{\n    if (strings.length\
    \ == 0) {\n        return null;\n    }\n    \n    int len = strings.length;\n\
    \    \n    if (len == 1 || len == 2) {\n        return strings[0];\n    }\n  \
    \  \n    int maxLen = -1;\n    \n    int index = 0;\n    for (int i = 1; i < len;\
    \ i++) {\n        int len = strings[i].length;\n        if (len > maxLen) {\n\
    \            maxLen = len;\n            index = i;\n        }\n    }\n    \n \
    \   return strings[index];\n}", "{\n    Nullable!(string) lens = std.length(strings);\n\
    \    Nullable!(string) res = null;\n    foreach (string s in strings) {\n    \
    \    if (!s.isEmpty && s.length >= lens.getOrElse(0)) {\n            res = s;\n\
    \        }\n    }\n    return res;\n}\n/*\n In array of strings, return the shortest\
    \ one. Return the first one in case of multiple\n    strings of the same length.\
    \ Return null in case the input array is empty.\n    >>> shortest(\"a\")\n   \
    \ \"a\"\n    >>> shortest(\"bb\")\n    \"b\"\n    >>> shortest(\"ccc\")\n    \"\
    a\"\n    \n*/\nNullable!(string) shortest(string[] strings) \n{\n    Nullable!(string)\
    \ lens = std.length(strings);\n    Nullable!(string) res = null;\n    foreach\
    \ (string s in strings) {\n        if (!s.isEmpty && s.length <= lens.getOrElse(0))\
    \ {\n            res = s;\n        }\n    }\n    return res;\n}", "{\n\tvar longest\
    \ : Option!(string);\n\tif(strings.length <= 0)\n\t\treturn None;\n\tvar longestLength\
    \ : int;\n\tvar lengths : List<int>;\n\tvar len : int;\n\tvar str : string;\n\t\
    var i : int;\n\t\n\tlengths = [];\n\tfor(i = 0; i <strings.length; i++)\n\t{\n\
    \t\tstr = strings[i];\n\t\tlen = std.string.length(str);\n\t\tlengths.push(len);\n\
    \t\tif(len > longestLength)\n\t\t{\n\t\t\tlongestLength = len;\n\t\t\tlongest\
    \ = Some(str);\n\t\t}\n\t}\n\t\n\tfor(i = 0; i <strings.length; i++)\n\t{\n\t\t\
    str = strings[i];\n\t\tlen = std.string.length(str);\n\t\tif(len < longestLength)\n\
    \t\t{\n\t\t\tlengths.insert(i, len - longestLength);\n\t\t\tlongestLength = len;\n\
    \t\t\tlongest = Some(str);\n\t\t}\n\t}\n\t\n\tif(longestLength > 0)\n\t\treturn\
    \ longest;\n\treturn None;\n}", "{\n    if(strings.length == 0) {\n        return\
    \ null;\n    }\n    if(strings.length > 1) {\n        int longestLength = -1;\n\
    \        foreach(i, strings[i]) {\n            int curLength = strings[i].length;\n\
    \            if(curLength > longestLength) {\n                longestLength =\
    \ curLength;\n            }\n        }\n        return longestLength == -1 ? null\
    \ : strings[longestLength];\n    }\n    return strings[0]; \n}", "{\n  int i =\
    \ 0;\n  while(i != strings.length && \n         strings[i].length != strings[i+1].length)\n\
    \  {\n    ++i;\n  }\n  if(i == strings.length)\n  {\n    return null;\n  }\n \
    \ else\n  {\n    return strings[i].length > strings[i+1].length ? strings[i] :\
    \ strings[i+1];\n  }\n}", "\t: strings indexOf(string)= -1 \n\t{\n\tif !strings.isEmpty\
    \ && length(strings) > 0 {\n\t\tint i, result = length(strings[0]);\n\t\tfor (i\
    \ = 1; i < length(strings); i = i + 1) {\n\t\t\tif (length(strings[i]) < result)\
    \ {\n\t\t\t\tresult = length(strings[i]);\n\t\t\t}\n\t\t}\n\t\treturn strings[i\
    \ - 1];\n\t}\n\treturn null;\n}", "{ \n\tif (strings.length == 0)\n\t{\n\t\treturn\
    \ null;\n\t}\n\telse if (strings.length == 1)\n\t{\n\t\treturn strings[0];\n\t\
    }\n\telse\n\t{\n\t\treturn strings[strings.length - 1].length() > strings[0].length()\
    \ ? strings[strings.length - 1] : strings[0];\n\t}\n}", "{\n    Length len = Length(strings);\n\
    \    if (len == 0) {\n        return null;\n    }", "{\n\tlet res = null;\n\t\
    let len = 0;\n\t\n\tif (strings.length != 0)\n\t\tlen = strings[0].Length;\n\t\
    \n\tfor (var i : int in 0 .. strings.length - 1)\n\t{\n\t\tvar str = strings[i];\n\
    \t\t\n\t\tif (str.Length > len)\n\t\t{\n\t\t\tres = str;\n\t\t\tlen = str.Length;\n\
    \t\t}\n\t}\n\t\n\treturn res;\n}\n/*\n Create a vector of strings where the i-th\
    \ element is the string with index i in the\n input array (starting at 0)\n*/\n\
    Vector!(string) createStringVector(string[] strings) \n{\n\tlet vec = Vector!(string);\n\
    \t\n\tfor (var i : int in 0 .. strings.length - 1)\n\t\tvec += strings[i];\n\t\
    \n\treturn vec;\n}\n/*\n Create a vector of the same size as the input array,\
    \ filled with zeros. \n*/\nVector!(u32, length) zeroVector(length) \n{\n\tvar\
    \ vec = Vector!(u32, length);\n\t\n\tfor (var i : int in 0 .. length - 1)\n\t\t\
    vec += 0;\n\t\n\treturn vec;\n}\n/*\n Create a vector of the same size as the\
    \ input array, filled with ones.\n*/\nVector!(u32, length) oneVector(length) \n\
    {\n\tvar vec = Vector!(u32, length);\n\t\n\tfor (var i : int in 0 .. length -\
    \ 1)\n\t\tvec += 1;\n\t\n\treturn vec;\n}\n/*\n Create a vector of the same size\
    \ as the input array, filled with random integers in the range [0, length-1].\n\
    */\nVector!(u32, length) randVector(length) \n{\n\tvar vec = Vector!(u32, length);\n\
    \t\n\tfor (var i : int in 0 .. length - 1)\n\t\tvec += rand.nextInt(length) +\
    \ 1;\n\t\n\treturn vec;\n}\n/*\n Get the nth element of the input vector. \n*/",
  "{\n\tforall(strings.count, i => strings[i] = strings[i].length());\n\treturn max(strings)!;\n\
    }", "{\n    var maxLen = -1;\n    var maxIndex = 0;\n    var tmp = \"\";\n   \
    \ for (var i=0; i<strings.length; i++){\n        var len = strings[i].length;\n\
    \        if (len > maxLen) {\n            maxLen = len;\n            maxIndex\
    \ = i;\n        }\n        tmp += strings[i];\n    }\n    if (tmp.length > maxLen)\
    \ maxLen = tmp.length;\n    if (maxLen != -1) return strings[maxIndex];\n    return\
    \ null;\n}", "{\n\tif(strings.length==0)\n\t{\n\t\tthrow new Exception(\"The input\
    \ array is empty\");\n\t}\n\tint longestLen = strings.length==1 ? strings[0].characters.length\
    \ : strings[0].characters.length;\n\tforeach(string s in strings) {\n\t\tif(s.characters.length\
    \ > longestLen)\n\t\t{\n\t\t\tlongestLen = s.characters.length;\n\t\t}\n\t}\n\t\
    return longestLen==strings[0].characters.length ? strings[0] : null;\n}\n/*\n\
    \ Out of array of strings, return the shortest one. Return the last one in case\
    \ of a multiple strings\n    of the same length. Return null in case the input\
    \ array is empty.\n    >>> shortest([])\n    None\n    >>> shortest([\"a\", \"\
    b\", \"c\"])\n    \"c\"\n    >>> shortest([\"a\", \"bb\", \"ccc\"])\n    \"ccc\"\
    \n    \n*/\nNullable!(string) shortest(string[] strings) \n{\n\tif(strings.length==0)\n\
    \t{\n\t\tthrow new Exception(\"The input array is empty\");\n\t}\n\tint shortestLen\
    \ = strings.length==1 ? strings[0].characters.length : strings[0].characters.length;\n\
    \tforeach(string s in strings) {\n\t\tif(s.characters.length < shortestLen)\n\t\
    \t{\n\t\t\tshortestLen = s.characters.length;\n\t\t}\n\t}\n\treturn shortestLen==strings[0].characters.length\
    \ ? strings[0] : null;\n}", "{\n\tstd.array!(string,length: strings.length) maxLengths\
    \ = new string[length]; \n\tfor (int i = 0; i < length; i++)\n\t\tmaxLengths[i]\
    \ = strings[i].length;\n\tfor (int i = 0; i < length; i++)\n\t{\n\t\tif (maxLengths[i]\
    \ <= strings[i].length)\n\t\t\treturn strings[i];\n\t\telse\n\t\t\tmaxLengths[i]\
    \ = maxLengths[i] - strings[i].length;\n\t}\n\treturn null;\n}", "{\n\tlet maxLength\
    \ = strings.length;\n\tif (maxLength == 0) return null;\n\tfor (let i = 0; i <\
    \ maxLength; i++) {\n\t\tlet string = strings[i];\n\t\tlet len = string.length;\n\
    \t\tif (len > maxLength) {\n\t\t\tmaxLength = len;\n\t\t}\n\t}\n\t\n\treturn strings[maxLength\
    \ - 1];\n}", "{\n    if (strings.length <= 0)\n        return null;\n    int maxLen\
    \ = strings[0].Length;\n    bool first = true;\n    foreach(string s in strings)\
    \ {\n        int len = s.Length;\n        if (len > maxLen) {\n            maxLen\
    \ = len;\n            first = false;\n        }\n    }\n    if (first)\n     \
    \   return strings[0];\n    return null;\n}", "    if (strings.length < 2) then\
    \ (string.length, strings[0]) \n    else {\n        var minLength = strings[0].length;\n\
    \        var maxLength = strings[0].length;\n        for (var i = 1; i < strings.length;\
    \ ++i)\n            if (strings[i].length < minLength) minLength = strings[i].length;\n\
    \            for (var j = 1; j < strings.length; ++j)\n                if (strings[j].length\
    \ > maxLength) maxLength = strings[j].length;\n        if (minLength == maxLength)\
    \ then (minLength, strings[0]) \n        else \n            var index = -1;\n\
    \            while (index >= 0) {\n                if (minLength == strings[index].length)\
    \ then (minLength, strings[index])\n                if (maxLength == strings[index].length)\
    \ then (maxLength, strings[index])\n                else if (minLength > strings[index].length)\
    \ then (minLength, strings[index])\n                else (maxLength, strings[index])\n\
    \                index = index - 1;\n            }\n    }\n    else \n       \
    \ null;\n</cell>\n<cell>\nimport std.search;\nimport std.array;\nimport std.conv;\n\
    import std.array;\nimport std.algorithm;\nimport std.conv;", "{\n    if (strings.length\
    \ == 0) {\n        return null;\n    } else {\n        string longest = strings[0];\n\
    \        foreach (string s in strings) {\n            if (s.length() > longest.length())\
    \ {\n                longest = s;\n            }\n        }\n        return longest;\n\
    \    }\n}", "{\n   if(strings.length == 0)\n      return null;\n   var longest:string\
    \ = strings[0];\n   for(var i:int = 1; i < strings.length; ++i) {\n       if(strings[i].length\
    \ >= longest.length)\n          longest = strings[i];\n   }\n   return longest;\n\
    }", "\t: strings\n\t\tstrings.length != 0 ? strings[0].length : null\n\t{\n\t\n\
    \tvar maxLength : int;\n\tvar index : int;\n\t\n\tif (strings.length == 0)\n\t\
    \treturn null;\n\t\t\n\tmaxLength = 0;\n\tindex = 0;\n\t\n\twhile (index < strings.length)\n\
    \t{\n\t\tif (strings[index].length > maxLength)\n\t\t{\n\t\t\tmaxLength = strings[index].length;\n\
    \t\t}\n\t\t\n\t\tindex++;\n\t}\n\t\n\treturn strings[maxLength];\n}", "{\n   \
    \ int minLen = strings.length < 2 ? null : strings.peek().length();\n    for(int\
    \ i = 1; i < strings.length; i++) {\n        int len = strings[i].length();\n\
    \        if (len > minLen)\n            return strings[i];\n        minLen = len;\n\
    \    }\n    return null;\n}\n</code>\n<|/ a |>\n<| a tags=c++,max,arrays,string,algorithm\
    \ dscore=2 |>\n<code>\npublic int FindMax(string arr[])\n{\n    int maxIndex =\
    \ 0;\n    bool found = false;\n    foreach (string s in arr)\n    {\n        if\
    \ (maxIndex < s.Length)\n        {\n            if (found == false)\n        \
    \    {\n                maxIndex = s.Length;\n                found = true;\n\
    \            }\n            else\n            {\n                if (s[maxIndex]\
    \ != s[s.Length-1])\n                {\n                    maxIndex = s.Length;\n\
    \                    found = true;\n                }\n            }\n       \
    \ }\n        else\n        {\n            maxIndex = s.Length;\n            found\
    \ = true;\n        }\n    }\n    if (found)\n    {\n        return maxIndex;\n\
    \    }\n    else\n    {\n        return 0;\n    }\n}\n</code>\n<|/ a |>\n<| a\
    \ dscore=1 |>\nI solved this problem by making a function that would find the\
    \ index of the element with the max value. The code is not too elegant, but it\
    \ does the job.\n<code>\npublic int MaxIndex(string arr[])\n{\n    int maxVal\
    \ = arr[0].Length;\n    int maxIndex = 0;\n    for (int i = 1; i < arr.Length;\
    \ i++)\n    {\n        if (arr[i].Length > maxVal)\n        {\n            maxVal\
    \ = arr[i].Length;\n            maxIndex = i;\n        }\n    }\n    return maxIndex;\n\
    }\n</code>\n<|/ a tags=c++,max,arrays,string,algorithm |>\n<| a dscore=1 |>\n\
    <code>", "{\n    int len = strings.length;\n    if (len == 0)\n        return\
    \ null;\n    int maxlen = lens[0];\n    for (int i = 1; i < len; i++)\n      \
    \  if (lens[i] > maxlen)\n            maxlen = lens[i];\n    return strings[lens[len\
    \ - 1]];\n}", "{\n    if (strings.length == 0)\n        return null;\n    \n \
    \   int bestLength = strings[0].Length;\n    int bestIndex = -1;\n    for (int\
    \ i = 0; i < strings.length; ++i) {\n        int curLength = strings[i].Length;\n\
    \        if (curLength > bestLength) {\n            bestLength = curLength;\n\
    \            bestIndex = i;\n        }\n    }\n    if (bestIndex >= 0)\n     \
    \   return strings[bestIndex];\n    return null;\n}", "\t=> string? maxLen :=\
    \ strings.length;\n\tstring? maxLen := strings.length;\n\tfor (int i = 0; i <\
    \ maxLen; ++i)\n\t\tif (strings[i] is string && strings[i].length <= maxLen)\n\
    \t\t\tmaxLen := i;\n\treturn maxLen;\n}", "{\n  int i = 0;\n  int l = 0;\n  int\
    \ len = 0;\n  while(i < strings.length){\n    l = strlen(strings[i]);\n    if(l\
    \ > len){\n      len = l;\n      if(strings[i].length() > len){\n        str =\
    \ strings[i];\n      }\n    }\n    i++;\n  }\n  return str;\n}", "{\n    int maxIndex\
    \ = -1;\n    int maxLength = 0;", "{\n\tif (strings.length == 0) return null;\n\
    \tvar longest = \"\";\n\tfor (var i=0; i<strings.length; ++i) {\n\t\tvar string\
    \ = strings[i];\n\t\tlongest = std.longest(longest, string);\n\t}\n\treturn longest;\n\
    }\n/*\n Find the first string which is not equal to a given one.\n Return the\
    \ index of that string in the array, if not present. \n */\nNullable!(int) firstNotEquals(string\
    \ value, string[] strings) {\n\tif (strings.length == 0) return null;\n\tfor (var\
    \ i=0; i<strings.length; ++i) {\n\t\tvar string = strings[i];\n\t\tif (std.not_equals(string,\
    \ value)) return i;\n\t}\n\treturn null;\n}\n/*\n Find the first string which\
    \ is not equal to a given one.\n Return the index of that string in the array,\
    \ if not present. \n */\nNullable!(int) firstNotEquals(string value, string[]\
    \ strings, int? start) {\n\tif (strings.length == 0) return null;\n\tvar index\
    \ = start;\n\tfor (var i=0; i<strings.length; ++i) {\n\t\tvar string = strings[i];\n\
    \t\tif (std.not_equals(string, value)) return index;\n\t\tindex++;\n\t}\n\treturn\
    \ null;\n}\n/*\n Find the first string which is not equal to a given one.\n Return\
    \ the index of that string in the array, if not present. \n */\nNullable!(int)\
    \ firstNotEquals(string value, string[] strings, int? start, int? stop) {\n\t\
    if (strings.length == 0) return null;\n\tvar index = start;\n\tfor (var i=index;\
    \ i<stop; ++i) {\n\t\tvar string = strings[i];\n\t\tif (std.not_equals(string,\
    \ value)) return index;\n\t\tindex++;\n\t}\n\treturn null;\n}\n/*\n Find the first\
    \ string which is not equal to a given one.\n Return the index of that string\
    \ in the array, if not present. \n */\nNullable!(int) firstNotEquals(string value,\
    \ string[] strings, int? start, int? stop, int? step) {\n\tif (strings.length\
    \ == 0) return null;\n\tvar index = start;\n\tfor (var i=index; i<stop; i+=step)\
    \ {\n\t\tvar string = strings[i];\n\t\tif (std.not_equals(string, value)) return\
    \ index;\n\t\tindex += step;\n\t}\n\treturn null;\n}\n/*\n Find the first string\
    \ which is not equal to a given one.\n Return the index of that string in the\
    \ array, if not present. \n */\nNullable!(int) firstNotEquals(string value, string[]\
    \ strings, int? start, int? stop, int? step, int? length) {\n\tif (strings.length\
    \ == 0) return null;\n\tvar index = start;\n\tfor (var i=index; i<stop; i+=step,\
    \ ++length) {\n\t\tvar string = strings[i];\n\t\tif (std.not_equals(string, value))\
    \ return index;\n\t\tindex += step;\n\t\tif (length == 0) return i;\n\t}\n\treturn\
    \ null;\n", "{\n\tvar longest = Nullable!(string);\n\tif (strings.length == 0)\n\
    \t\treturn longest;\n\t\n\tvar maxLen = strings[0].len();\n\tfor (var i:int =\
    \ 1; i <= strings.length; i++)\n\t{\n\t\tvar len = strings[i].len();\n\t\tif (len\
    \ > maxLen)\n\t\t\tmaxLen = len;\n\t}\n\t\n\tif (maxLen > 0)\n\t\treturn strings[strings.indexOf(longest,\
    \ maxLen)];\n\t\n\treturn null;\n}", "{\n  if(strings.Length == 0)\n    return\
    \ null;\n  string longest = strings[0];\n  for(int i = 1; i < strings.Length;\
    \ ++i)\n  {\n    int stringLength = strings[i].Length;\n    if(stringLength >\
    \ longest.Length)\n    {\n      longest = strings[i];\n    }\n  }\n  return longest;\n\
    }\n/*\n Split a string into an array of strings using some separator.\n Examples:\
    \ \"aaaa.bbb.ccc\", \"aaa\", \"a\", \"bbbb.\"\n Returned array contains at most\
    \ two strings. In case the input string does not contain any separator(s) or the\
    \ separator is empty, the last element of the array will be an empty string.\n\
    \ >>> split(\"aaaa.bbb.ccc\", \".\")\n [\"aaa\", \"bbb.ccc\"]\n >>> split(\"aaa\"\
    , \".\")\n [\"a\"]\n >>> split(\"a\", \".\")\n [\"a\"]\n >>> split(\"a\", \"b\"\
    )\n [\"a\"]\n >>> split(\"a\", \"bbb\")\n [\"a\"]\n >>> split(\"a\", \".\", 3)\n\
    \ [\"a\"]\n >>> split(\"\", \".\", 3)\n []\n >>> split(\"\", \"bbb.ccc\", 3)\n\
    \ [\"bbb\", \"ccc\"]\n >>> split(\"\", \".\", 7)\n []\n >>> split(\"aaaa.bbb.ccc\"\
    , \".\", 3)\n [\"aaa\", \"bbb.ccc\"]\n >>> split(\"aaaa.bbb.ccc\", \".\", 7)\n\
    \ [\"a\"]\n >>> split(\"aaaa.bbb.ccc\", \".\", 6)\n [\"a\"]\n >>> split(\"aaaa.bbb.ccc\"\
    , \".\")\n [\"a\"]\n >>> split(\"aaaa.bbb.ccc\", \"\")\n []\n >>> split(\"\",\
    \ \"bbb.ccc\", 3)\n [\"bbb\", \"ccc\"]\n \n \n Return the string in the array\
    \ after removing the separator, case insensitive. Empty array will be returned\
    \ if the separator is not present.\n >>> removeSeparator(\"\", \".\")\n \"\"\n\
    \ >>> removeSeparator(\"a\", \"b\")\n \"a\"\n >>> removeSeparator(\"a\", \"b\"\
    )\n \"a\"\n >>> removeSeparator(\"aa\", \".\")\n \"aa\"\n >>> removeSeparator(\"\
    aa\", \"\")\n \"\"\n >>> removeSeparator(\"aaa\", \"bb\")\n \"aaa\"\n >>> removeSeparator(\"\
    aaa\", \"bb\", 2)\n \"aaa\"\n >>> removeSeparator(\"aaa\", \"bbb\", 2)\n \"aaa\"\
    \n >>> removeSeparator(\"aaa\", \"bbb\", 2)\n \"aaa\"\n >>> removeSeparator(\"\
    aaa\", \"bb", "{\n\tif (strings.length == 0) {\n\t\treturn null;\n\t}", "{\n \
    \ int i = 0;\n  while (i < strings.length)\n  {\n    if (strings[i].Length > strings[i\
    \ + 1].Length) \n      return strings[i];\n    else \n      i += 1;\n  }\n  return\
    \ null;\n}", "{\n  if(strings.isEmpty || isNull!(strings)) \n    return null;\n\
    \  int length = length(strings);\n  int longestLength = length;\n  int bestIndex\
    \ = -1;\n  foreach(strings[int i: int], string str) \n  {\n    int thisLength\
    \ = str.length;\n    if(thisLength > longestLength) \n    {\n      longestLength\
    \ = thisLength;\n      bestIndex = i;\n    }\n  }\n  return strings[bestIndex];\n\
    }\n</code>\nThe same logic can be applied for the other functions, such as isEmpty\
    \ and isNull, as well as the foreach loops.\n<|/ a dscore=2 |>\n<| c |>\nThis\
    \ looks like it will work, I'm going to have to sit down with it for a bit and\
    \ get back to you, but I do appreciate the answer, thank you!\n<|/ c |>\n<| c\
    \ |>\nOk, that makes sense, but I'm having some trouble understanding your code.\
    \ I can get the isEmpty part to work, by setting \"longestLength\" to 0 at the\
    \ top of the function, and incrementing it in the loop that checks if the string\
    \ is longer than longestLength. However, I get stuck at finding the first string\
    \ in the array. I tried using the \"bestIndex = -1\" part of the foreach loop,\
    \ but then I get the error \"variable bestIndex might not have been initialized\"\
    \ even though it was initialized in the line above it. I think I'm not understanding\
    \ how the \"foreach\" loop works, so any further help would be greatly appreciated.\n\
    <|/ c |>\n<| c |>\nI added a version for `longest` (and other functions) that\
    \ does not use a loop or a nested if. It uses `for` loops and is more functional\
    \ than loops.\n<|/ c |>\n<| c |>\nThank you for the additional code, but I'm not\
    \ really able to get it to work. Here's my attempt:", "{\n\tvar longest:string;\n\
    \tvar i: int = 0;\n\tvar len: int;\n\tvar longestLength: int;\n\t\n\tfor (i =\
    \ 0; i < strings.length; i++) \n\t{\n\t\tlen = strings[i].length;\n\t\tif (len\
    \ > longestLength) \n\t\t{\n\t\t\tlongestLength = len;\n\t\t\tlongest = strings[i];\n\
    \t\t}\n\t}\n\treturn longest;\n}", "{\n    if (strings.length == 0)\n        return\
    \ null;", "{\n  int i = 0;\n  for (int ii = 0; ii < strings.Length; ii++)\n  {\n\
    \    if (strings[ii].Length > i) return strings[ii];\n    else i++;\n  }\n  return\
    \ null;\n}\n</code>\n<|/ a tags=string,arrays,c# |>\n<| c |>\nThanks for the solution.\
    \ I would like to see a solution using LINQ.\n<|/ c |>\n<| c |>\n: LINQ doesn't\
    \ help here because the whole point is to avoid a loop.\n<|/ c |>\n<| c |>\n-\
    \ Yes, the point is to avoid the loop... but if you're using LINQ then you're\
    \ using it to avoid the loop! Why would you write code that *does* use LINQ when\
    \ it's unnecessary?\n<|/ c |>\n<| a tags=string,arrays,c# |>\nI wouldn't use LINQ\
    \ because it's just a lot of extra code just to do a simple thing.\n<code>\nstring[]\
    \ myStrings = { \"one\", \"two\", \"three\", \"four\", \"five\" };\nstring longest\
    \ = myStrings.OrderByDescending(s => s.Length).FirstOrDefault();\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThat would be the most efficient solution. :)\n<|/ c\
    \ |>\n<| c |>\nOh my god why didn't you just add \"using System;\" on top of your\
    \ example?\n<|/ c |>\n<| c |>\n: I assumed the OP was using a library like LINQ\
    \ to do it.\n<|/ c |>\n<| c |>\nI didn't even know what LINQ was. :) That makes\
    \ my answer much more complicated. Anyway, I really like this solution.\n<|/ c\
    \ |>\n<| c |>\n: Ok sorry! I was just wondering why you posted this!\n<|/ c |>\n\
    <| a |>\nHere's how I'd solve the problem using a simple for...next loop:\n<code>\n\
    string[] myStrings = new string[] { \"one\", \"two\", \"three\", \"four\", \"\
    five\" };\nstring longest = null;", "{\n\tif (strings.length < 1)\n\t\treturn\
    \ null;\n\telse\n\t\treturn strings[strings.length - 1];\n}", "{\n\t\n\tif(strings.len\
    \ == 0) return null;\n\t\n\tvar longest = strings[0];\n\t\n\tfor(var i=1; i<strings.len;\
    \ i++){\n\t\tif(strings[i].len > longest.len){\n\t\t\tlongest = strings[i];\n\t\
    \t}\n\t}\n\t\n\treturn longest;\n}\n/*\n A function that returns the next character\
    \ after the given index.\n \n Note: the character at index i+1 may not be the\
    \ one we're looking for.\n \n Note2: this function is supposed to return the next\
    \ character AFTER the given index, not just \n         the character at that index.\n\
    \ \n Note3: this function returns a nullable character (char?)\n \n Note4: the\
    \ function should NOT be called in the middle of an array iteration\n \n Note:\
    \ in general, the function should throw an exception if there is an IndexOutOfBoundsException.\n\
    \ \n */\nfunction next(char c, int index)\n{\n\t\n\tif(index >= c.len) return\
    \ null;\n\t\n\treturn char.charAt((index+1)%c.len);\n}\n/*\n A function that returns\
    \ the next character after the given index.\n \n Note: the character at index\
    \ i+1 may not be the one we're looking for.\n \n Note2: this function is supposed\
    \ to return the next character AFTER the given index, not just \n         the\
    \ character at that index.\n \n Note3: this function returns a nullable character\
    \ (char?)\n \n Note4: the function should NOT be called in the middle of an array\
    \ iteration\n \n Note: in general, the function should throw an exception if there\
    \ is an IndexOutOfBoundsException.\n \n */\nfunction next(char c, int index)\n\
    {\n\t\n\tif(index >= c.len) return null;\n\t\n\treturn char.charAt((index+1)%c.len);\n\
    }\n/*\n A function that returns the next character after the given index.\n \n\
    \ Note: the character at index i+1 may not be the one we're looking for.\n \n\
    \ Note2: this function is supposed to return the next character AFTER the given\
    \ index, not just \n         the character at that index.\n \n Note3: this function\
    \ returns a nullable character (char?)\n \n Note4: the function should NOT be\
    \ called in the middle of an array iteration\n \n Note: in general, the function\
    \ should throw an exception if there is an IndexOutOfBoundsException.\n \n */\n\
    function next(char c, int index)\n{\n\t\n\tif(index >= c.len) return null;\n\t\
    \n\treturn char.charAt((index+1)%c.len);\n}\n/*\n This function returns the index\
    \ of the first character ", "{\n    Nullable!(string) max = null;\n    if (strings.length\
    \ == 0)\n        return null;\n    string str = null;\n    for (string s in strings)\n\
    \        if (max == null || s.length() > s.length())\n        {\n            max\
    \ = s;\n            str = s;\n        }\n    return str;\n}", "{\n    if (strings.length==0)\
    \ return null;\n    int max = strings.length;\n    for (int i=1; i < max; ++i)\n\
    \        if (strings[i].length>strings[max].length) max = i;\n    return strings[max];\n\
    }", "{\n\tif (strings.length == 0) {\n\t\treturn null;\n\t}\n\telse\n\t{\n\t\t\
    int i = 0;\n\t\tint length = 0;\n\t\twhile (i<strings.length)\n\t\t{\n\t\t\tlength\
    \ = std.string.length(strings[i]);\n\t\t\tif (length>length)\n\t\t\t{\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn std.string.getLength(strings[i])\
    \ > length? strings[i]: null;\n\t}\n}\n/*\n Find the index of the largest substring\
    \ inside a string array that matches the search pattern.\n Return the index of\
    \ the first match or -1 if the string is not found.\n @param array: a string array\n\
    \ @param pattern: a string pattern\n @return: index of the largest substring inside\
    \ a string array that matches the search pattern.\n*/", "{\n    if(strings.length\
    \ < 1) return null;\n    string currentString = strings[0];\n    for(unsigned\
    \ i = 1; i < strings.length; ++i)\n    {\n        if(strings[i].length() > currentString.length())\
    \ \n        {\n            currentString = strings[i];\n        }\n    }\n   \
    \ return currentString;\n}", "{\n    var maxLen = 0;\n    foreach (string! item\
    \ in strings) {\n        var len = string.lengthOf(item);\n        if (len > maxLen)\
    \ {\n            maxLen = len;\n        }\n    }\n    \n    if (maxLen > 0) {\n\
    \        return strings[strings.length - 1];\n    }\n    \n    return null;\n}",
  "    {\n    if(!strings.length)\n        return null;\n    else\n        return\
    \ strings.length>0 ? std.string.getLength(strings[0])>std.string.getLength(strings[strings.length-1])?strings[0]:strings[strings.length-1]:null;\n\
    }\n/*\n In array of strings of strings, return the longest of them. Return the\
    \ first one in case of multiple\n    strings of the same length. Return null if\
    \ all the strings are of the same length.\n    >>> longest([\"a\", \"b\"])\n \
    \   \"b\"\n    >>> longest([\"a\", \"bb\", \"ccc\"])\n    \"ccc\"\n    >>> longest([\"\
    a\", \"b\", \"c\"])\n    \"b\"\n*/\nNullable!(string) longest(string[] strings)\
    \ \n    {\n    if(!strings.length)\n        return null;\n    else\n        return\
    \ strings.length>0 ? std.string.getLength(strings[0])>std.string.getLength(strings[strings.length-1])?strings[0]:strings[strings.length-1]:null;\n\
    }\n/*\n In array of strings, return the longest of them. Return the first one\
    \ in case of multiple\n    strings of the same length. Return null if all the\
    \ strings are of the same length.\n    >>> longest([\"a\", \"b\"])\n    \"b\"\n\
    \    >>> longest([\"a\", \"bb\", \"ccc\"])\n    \"ccc\"\n    >>> longest([\"a\"\
    , \"b\", \"c\"])\n    \"b\"\n*/\nNullable!(string) longest(string[] strings) \n\
    \    {\n    if(!strings.length)\n        return null;\n    else\n        return\
    \ strings.length>0 ? std.string.getLength(strings[0])>std.string.getLength(strings[strings.length-1])?strings[0]:strings[strings.length-1]:null;\n\
    }\n/*\n Return the number of times each string is in the array.\n    >>> counts[\"\
    a\", \"bb\", \"ccc\"]\n    {\"a\": 1, \"bb\": 2, \"ccc\": 1}\n    \n*/\nNullable!(string[])\
    \ counts(string[] strings) \n    {\n    int n = 0;\n    foreach(string,x)strings[++n]\
    \ = x;\n    return strings.length>0 ? strings[n]:null;\n}\n/*\n Return true if\
    \ array strings is sorted\n    \n*/", "{\n\tint i = 0;\n\tint len = strings.length;\n\
    \twhile (i < len) {\n\t\tif (strings[i].length > strings[len-1].length) {\n\t\t\
    \tstrings[len-1] = strings[i];\n\t\t\ti = len;\n\t\t}\n\t\telse {\n\t\t\ti++;\n\
    \t\t}\n\t}\n\tif (i < len) {\n\t\treturn null;\n\t}\n\treturn strings[len-1];\n\
    }\n/*\n From array of ints, return array of ints. Return null in case the input\
    \ array is empty.\n*/\nNullable!(int[]) intArray(int[] ints)\n{\n\tint[] intArray\
    \ = new int[ints.length];\n\tfor (int i = 0; i < ints.length; i++) {\n\t\tintArray[i]\
    \ = ints[i];\n\t}\n\treturn intArray;\n}\n/*\n From array of bools, return array\
    \ of bools. Return null in case the input array is empty.\n*/\nNullable!(bool[])\
    \ boolArray(bool[] bools)\n{\n\tbool[] boolArray = new bool[bools.length];\n\t\
    for (int i = 0; i < bools.length; i++) {\n\t\tboolArray[i] = bools[i];\n\t}\n\t\
    return boolArray;\n}\n/*\n From array of floats, return array of floats. Return\
    \ null in case the input array is empty.\n*/\nNullable!(float[]) floatArray(float[]\
    \ floats)\n{\n\tfloat[] floatArray = new float[floats.length];\n\tfor (int i =\
    \ 0; i < floats.length; i++) {\n\t\tfloatArray[i] = floats[i];\n\t}\n\treturn\
    \ floatArray;\n}\n/*\n From array of strings, return array of strings. Return\
    \ null in case the input array is empty.\n*/\nNullable!(string[]) stringArray(string[]\
    \ strings)\n{\n\tstring[] stringArray = new string[strings.length];\n\tfor (int\
    \ i = 0; i < strings.length; i++) {\n\t\tstringArray[i] = strings[i];\n\t}\n\t\
    return stringArray;\n}\n/*\n From array of doubles, return array of doubles. Return\
    \ null in case the input array is empty.\n*/\nNullable!(double[]) doubleArray(double[]\
    \ doubles)\n{\n\tdouble[] doubleArray = new double[doubles.length];\n\tfor (int\
    \ i = 0; i < doubles.length; i++) {\n\t\tdoubleArray[i] = doubles[i];\n\t}\n\t\
    return doubleArray;\n}\n/*\n From array of Vector3, return array of Vector3s.\
    \ Return null in case the input array is empty.\n*/\nNullable!(Vector3[]) vectorArray(Vector3[]\
    \ vectorArray)\n{\n\tVector3[] vectorArray = new Vector3[vectorArray.length];\n\
    \tfor (int i = 0; i < vectorArray.length; i++) {\n\t\tvectorArray[i] = vectorArray[i];\n\
    \t}\n\treturn vectorArray;\n}\n/*\n From array of Vector4, return array of Vector4s.\
    \ Return null in case the input array is ", "{\n\tint i = 0;\n\tint longest =\
    \ 0;\n\tforeach (string s in strings) {\n\t\tif (s.length() > longest) {\n\t\t\
    \tlongest = s.length();\n\t\t\ti = 1;\n\t\t}\n\t\telse if (s.length() == longest)\
    \ {\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tif (i==0) {\n\t\treturn null;\n\t}\n\t\n\t\
    return strings[longest-1];\n}\n/*\n Return an array of strings containing the\
    \ substrings found in strings. \n Return null in case the input is empty.\n \n\
    \ This function uses the substrings function on strings. It only returns the first\
    \ substring found.\n \n If there are multiple substring with the same length the\
    \ first substring is returned in the order it \n is found in strings. \n \n If\
    \ there is at least one substring with the same length the first substring is\
    \ returned.\n \n Note: this function does not consider if the substrings are different\
    \ or not.\n \n For example for \"a\" and \"b\" it will return [\"a\", \"b\"] because\
    \ they are the same string. \n It will return [\"a\", \"b\"] also for \"ab\" because\
    \ of the same length and so on.\n \n >>> substrings([\"a\", \"bb\", \"ccc\"])\n\
    \ [\"a\", \"bb\"]\n >>> substrings([\"a\", \"ab\", \"b\"])\n [\"a\", \"ab\"]\n\
    \ >>> substrings([\"ab\"])\n [\"ab\"]\n \n*/\nNullable!(string[]) substrings(string[]\
    \ strings) \n{\n\tint i = 0;\n\tforeach (string s in strings) {\n\t\ti = substrings(strings).indexOf(s,\
    \ i);\n\t\ti = substrings(strings).indexOf(s, i+1);\n\t}\n\t\n\tif (i==-1) {\n\
    \t\treturn null;\n\t}\n\t\n\treturn strings[substrings(strings).indexOf(strings[i])];\n\
    }\n/*\n Return true if the string s has only the following characters: \n \n 'a'\
    \ - 'z', 'A' - 'Z', '0' - '9', '_', '-', '*', '@', '?', '$', '^', '#' \n \n Otherwise\
    \ return false.\n \n For example for \"a\" it will return true because 'a' is\
    \ in the list.\n For \"ab\" it will return false because 'a' and 'b' are not in\
    \ the list.\n \n >>> isAlphanumeric(\"a\")\n True\n >>> isAlphanumeric(\"ab\"\
    )\n False\n \n*/", "{\n\tif (strings.length == 0) {\n\t\treturn null;\n\t}\n\t\
    \n\tstring[] longest = strings[0];\n\t\n\tint length = 1;\n\tfor (int i = 1; i\
    \ < strings.length; ++i) {\n\t\tif (strings[i].length() > longest.length()) {\n\
    \t\t\tlength = i;\n\t\t\tlongest = strings[i];\n\t\t}\n\t}\n\treturn longest;\n\
    }", "{\n    foreach(string) string in strings\n    {\n        if (string.length\
    \ > strings.length)\n        {\n            strings.length = string.length;\n\
    \            return string;\n        }\n    }\n    return null;\n}\n/*\n Out of\
    \ array of strings, return the longest substring. Return the first substring in\
    \ case of \n    multiple strings of the same length. Return null if the input\
    \ array is empty.\n    >>> longest(\"abcdef\")\n    \"abc\"\n    >>> longest(\"\
    abcabcabc\")\n    \"abc\"\n    \n*/\nNullable!(string) longestSubstring(string[]\
    \ strings) \n{\n    foreach(string) string in strings\n    {\n        if (string.length\
    \ >= strings.length)\n        {\n            strings.length = string.length;\n\
    \            return string;\n        }\n    }\n    return null;\n}\n/*\n Returns\
    \ if the strings are equal, otherwise prints error message to stderr and returns\
    \ false\n \n This function is designed to help avoid duplicated calls to \"assert\"\
    , which can cause hard to find \n    bugs when debugging. \n    \n Use it when\
    \ comparing strings of variable lengths:\n    >>> assert(longest(\"abcabc\") ==\
    \ longest(\"abcabc\"))\n    True\n    >>> assert(longest(\"abcabc\") != longest(\"\
    abcd\"))\n    True\n    \n Use it when comparing strings whose lengths are unknown\
    \ or don't matter:\n    >>> assert(longest(\"abc\") == longest(\"abcd\"))\n  \
    \  True\n    >>> assert(longest(\"abc\") == longest(\"abccd\"))\n    True\n  \
    \  \n Use it when comparing strings with some extra whitespace:\n    >>> assert(longest(\"\
    abc def\") == longest(\"abc def\"))\n    True\n    >>> assert(longest(\"abc def\"\
    ) == longest(\"abc d e\"))\n    True\n    \n Use it when comparing strings that\
    \ might have a newline at the end:\n    >>> assert(longest(\"abc def\") == longest(\"\
    abc def\\n\")) # trailing newline\n    True\n    >>> assert(longest(\"abc def\\\
    n\") == longest(\"abc def\\n\")) # trailing newline\n    True\n    \n Use it when\
    \ comparing strings that might have a trailing space at the end:\n    >>> assert(longest(\"\
    abc def\") == longest(\"abc def  \")) # trailing space\n    True\n    >>> assert(longest(\"\
    abc def  \") == longest(\"abc def  \")) # trailing space\n    True\n    \n Use\
    \ it when comparing strings that might have a trailing newline at the end:\n \
    \   >>> assert(longest(\"abc def\") == longest(\"abc def\\n\")) # trailing newline\n\
    \    True\n    >>> assert(longest(\"abc def\\n\") == longest(\"abc ", "{\n\t\n\
    \tif (length(strings) == 0)\n\t\treturn null;\n\t\n\tstring longest = strings[0];\n\
    \t\n\tfor (int i = 1; i < length(strings); ++i) {\n\t\tif (strings[i].length()\
    \ > longest.length()) {\n\t\t\tlongest = strings[i];\n\t\t}\n\t}\n\treturn longest;\n\
    }\n/*\n Return the position in the string of the first occurrence of the given\
    \ string.\n Return -1 in case of failure (the search terminates at the first occurrence\
    \ of the string).\n    >>> strindex(\"a b c\", \"b\")\n    2\n    >>> strindex(\"\
    a b c\", \"z\")\n    -1\n*/", "\t=> if (strings.length > 0) then strings[.length\
    \ - 1] else {\n\t\t\t   const string nullString = char.intern(\"null\");\n\t\t\
    \t   strings.length == 0 ? nullString : strings[0];\n\t\t   };", "{\n  if (strings.length\
    \ == 0)\n    return null;\n  int i = 0;\n  int n = strings.length;\n  bool longer\
    \ = false;\n  bool done = false;\n  string longest = \"\";\n  while (!done &&\
    \ i < n) {\n    int j = i + 1;\n    while (j < n && !done) {\n      int ln = strings[i].length();\n\
    \      if (ln == strings[j].length()) {\n        if (longer) {\n          longer\
    \ = false;\n          longest = strings[i];\n        } else {\n          longer\
    \ = true;\n          longest = strings[j];\n        }\n      } else {\n      \
    \  done = true;\n      }\n      j++;\n    }\n    i++;\n  }\n  return longest;\n\
    }", "{\n    int minLength = min(strings.length);\n    for (int i = 0; i < strings.length;\
    \ ++i)\n    {\n        if (strings[i].length == minLength)\n        {\n      \
    \      return strings[i];\n        }\n    }\n    return null;\n}\n</code>\n<|/\
    \ a tags=c++,dart,dart-polymer |>\n<| a |>\nHere's a solution that works for me\
    \ in Dart:\n<code>\nclass String {\n  final String _string;\n  final int _maxLength;",
  "{\n\tint count = 0;\n\tstring longest = null;\n\tforeach (string str in strings)\n\
    \t{\n\t\tif (str != null && str.length > count)\n\t\t{\n\t\t\tlongest = str;\n\
    \t\t\tcount = str.length;\n\t\t}\n\t}\n\treturn longest;\n}", "{\n   if(null ==\
    \ strings || 0 == strings.length) \n      return null;", "{\n    var maxLen =\
    \ 0;\n    var maxIndex = 0;\n    foreach(i; 0 .. strings.length-1)\n    {\n  \
    \      if(strings[i].length() > maxLen)\n        {\n            maxLen = strings[i].length();\n\
    \            maxIndex = i;\n        }\n    }\n    if(maxIndex != 0) return strings[maxIndex];\n\
    \    return null;\n}", "{\n    int minLength = 1;\n    string theLongestString\
    \ = Null!(string);\n    foreach (string s in strings) {\n        if (s.length\
    \ >= minLength) {\n            minLength = s.length();\n            theLongestString\
    \ = s;\n        }\n    }\n    return theLongestString;\n}", "{\n  \n  if(strings.length==0)\
    \ return null;\n  \n  int maxLength = 0;\n  \n  for(int i = 0; i < strings.length;\
    \ i++) \n  {\n    int length = strings[i].length;\n    if(maxLength < length)\
    \ maxLength = length;\n  }\n  \n  return strings[Math.max(0, strings.length -\
    \ maxLength)];\n}", "{\n    if (strings.length == 0) {\n        return null;\n\
    \    }\n    string longest = strings[0];\n    for (int i=1; i<strings.length;\
    \ ++i) {\n        if (longest.length < strings[i].length) {\n            longest\
    \ = strings[i];\n        }\n    }\n    return longest;\n}\n</code>\n<|/ a tags=c#,arrays,function\
    \ |>\n<| a dscore=0 tags=c#,arrays,function |>\nYou could use the following LINQ\
    \ functions:\n<code>", "    if (strings.length == 0) return null;\n    int longLength\
    \ = strings[0].length;\n    foreach (string s in strings) \n        if (s.length\
    \ == longLength) \n            longLength = s.length\n    return strings[strings.length\
    \ - 1];\n\"\"\"", "{\n\tif (strings.length <= 0)\n\t\treturn null;\n\t\n\tvar\
    \ longest = strings[0];\n\tfor (var i = 1; i < strings.length; ++i) {\n\t\tvar\
    \ s = strings[i];\n\t\tif (longest.length < s.length)\n\t\t\tlongest = s;\n\t\
    }\n\treturn longest;\n}", "{\n    Nullable retVal = null;\n    for (string str\
    \ : strings)\n    {\n        if (retVal == null || retVal.intValue < str.intValue)\n\
    \            retVal = str;\n    }\n    return retVal;\n}", "{\n    foreach(string,\
    \ strings) {\n        int len = getLength(string);\n        if (len > longest.length)\
    \ longest.length = len;\n    }\n    return longest.length == 0 ? null : longest;\n\
    }", "{\n    return max(strings.map(s => s.length));\n}\n</code>\nThe example above\
    \ is a little complicated and I couldn't find the function name in the docs, but\
    \ you can get the idea from the comments above.\n<|/ a dscore=2 tags=arrays,list,d\
    \ |>\n<| c |>\nThis is not what I need. `longest` function returns the longest\
    \ string in a list. It has nothing to do with the max length. The function `findMax`\
    \ I believe does what `longest` function does (I tested with your example `longest([\"\
    a\", \"bb\", \"ccc\"])` and the result is `\"ccc\"`).\n<|/ c |>\n<| c |>\nOh,\
    \ I missed that part then. Let me think about it for a second.\n<|/ c |>\n<| c\
    \ |>\nI see your point. I tried this out and I think I'll have to go with the\
    \ other answer because I need a function that returns the index and max value,\
    \ not just the max value.\n<|/ c |>\n<| c |>\nI've updated my answer to return\
    \ both the index and the max value.\n<|/ c |>\n<| a tags=arrays,list,d |>\nTo\
    \ get the index of the longest string in an array I would do this.\n<code>\nimport\
    \ std.algorithm.search;\nimport std.array;\nimport std.stdio;\nimport std.string;",
  "{\n\tArray!(string) longestStrings;\n\tlongestStrings = strings;\n\tint iMax =\
    \ strings.Length - 1;\n\tfor(int i = 0; i < strings.Length; i++)\n\t{\n\t\tif(strings[i].Length\
    \ > longestStrings[i].Length)\n\t\t{\n\t\t\tlongestStrings[i] = strings[i];\n\t\
    \t}\n\t\telse if(strings[i].Length == longestStrings[i].Length)\n\t\t{\n\t\t\t\
    if(i == iMax)\n\t\t\t{\n\t\t\t\tlongestStrings[iMax] = longestStrings[i];\n\t\t\
    \t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlongestStrings[i] = longestStrings[iMax];\n\
    \t\t\t\tiMax = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn longestStrings[iMax];\n}",
  "{\n    if(strings.length == 0)\n        return null;\n    \n    if(strings.length\
    \ > 1)\n    {\n        int len = 0;\n        for(string str: strings)\n      \
    \      if(str.Length > len)\n                len = str.Length;\n        \n   \
    \     if(len > 0)\n        {\n            string longest = null;\n           \
    \ for(string str: strings)\n                if(!str.Equals(longest) && str.Length\
    \ == len)\n                    longest = str;\n            \n            return\
    \ longest;\n        }\n    }\n    \n    return strings[0];\n}", "{\n  if (strings.length\
    \ == 0) {\n    return null;\n  }\n  int minLen = strings[0].Length;\n  string\
    \ longestStr = null;\n  foreach (string str in strings) {\n    int len = str.Length;\n\
    \    if (len < minLen) {\n      minLen = len;\n      longestStr = str;\n    }\n\
    \  }\n  return longestStr;\n}\n/* \n Find the shortest string in the array of\
    \ strings.\n Return the first string in case of multiple strings of the same length.\
    \ Return null in case the input array is empty.\n \n */\nNullable!(string) shortest\
    \ (string[] strings) \n{\n  if (strings.length == 0) {\n    return null;\n  }\n\
    \  int minLen = strings[0].Length;\n  string shortestStr = null;\n  foreach (string\
    \ str in strings) {\n    int len = str.Length;\n    if (len == minLen) {\n   \
    \   shortestStr = str;\n    }\n    else if (len < minLen) {\n      minLen = len;\n\
    \      shortestStr = str;\n    }\n  }\n  return shortestStr;\n}\n</code>\n<|/\
    \ a tags=c#,generics dscore=2 |>\n<| a dscore=2 |>\nFor those that want to use\
    \ a lambda function, this works:\n<code>\npublic static T ReturnTheFirst<T>(IEnumerable<T>\
    \ enumerable)\n{\n    return enumerable.Take(1).FirstOrDefault();\n}\n</code>\n\
    <|/ a tags=c#,generics |>\n<| c |>\n`FirstOrDefault` will throw if `enumerable`\
    \ is empty, and it won't return `default(T)`\n<|/ c |>\n<| a dscore=1 |>\n<code>\n\
    public static T GetFirst<T>(IEnumerable<T> collection)\n{\n    return collection.Take(1).FirstOrDefault();\n\
    }\n</code>\n<|/ a tags=c#,generics |>\n<| a |>\nThe shortest I found:\n<code>\n\
    public static T ReturnTheFirst<T>(this IEnumerable<T> enumerable)\n{\n    return\
    \ enumerable.Take(1).FirstOrDefault();\n}\n</code>\n<|/ a dscore=0 tags=c#,generics\
    \ |>\n<| a |>\n<code>\npublic static T First<T>(this IEnumerable<T> collection)\n\
    {\n    return collection.ElementAt(0);\n}\n</code>\n<|/ a tags=c#,generics dscore=0\
    \ |>\n<| c |>\nYou should always include an explanation along with the code snippet.\n\
    <|/ c |>\n<| a dscore=0 tags=c#,generics |>\nYou can use this method:\n<code>\n\
    public static T FirstOrDefault", "  if(strings.length == 0)\n    return null;\n\
    \  if(strings.length > 1)\n    return strings[0];\n  \n  var shortest: string\
    \ = null;\n  var longest: string = null;\n  for(var i = 0; i < strings.length;\
    \ ++i) {\n    var len: integer = strings[i].length;\n    if(shortest == null ||\
    \ len < shortest.length)\n      shortest = strings[i];\n    if(longest == null\
    \ || len > longest.length)\n      longest = strings[i];\n  }\n  \n  return longest;\n\
    }", "{\n    Nullable!(string) longest_string = null;\n    int longest_len = 0;\n\
    \    foreach (string s in strings) {\n        int l = s.Length;\n        if (l\
    \ > longest_len)\n            longest_len = l;\n    }\n    if (longest_len > 0)\
    \ {\n        foreach (string s in strings) {\n            int l = s.Length;\n\
    \            if (l == longest_len) {\n                if (longest_string == null)\n\
    \                    longest_string = s;\n                else\n             \
    \       longest_string = null;\n                break;\n            }\n      \
    \  }\n    }\n    return longest_string;\n}", "{\n    var ret: string = null;\n\
    \    if (strings.length == 0) return ret;\n    for(var i = 0, len = strings.length;\
    \ i < len; ++i)\n    {\n        var len = strings[i].length;\n        if (len\
    \ > ret || (len == ret && strings[i] < ret))\n            ret = len;\n    }\n\
    \    return ret;\n}", "{\n    // TODO: Return first longest string in case they\
    \ are of different length.\n    if (strings.length == 0) return null;\n    \n\
    \    int maxLen = strings[0].Length;\n    int longestLen = strings[0].Length;\n\
    \    for (int i = 1; i < strings.length; i++) \n    {\n        if (strings[i].Length\
    \ > maxLen) \n        {\n            maxLen = strings[i].Length;\n           \
    \ longestLen = maxLen;\n        }\n        else if (strings[i].Length == maxLen)\
    \ \n        {\n            longestLen = Math.Max(longestLen, strings[i].Length);\n\
    \        }\n    }\n    \n    if (maxLen == 0) return null;\n    \n    return strings[longestLen];\n\
    }", "{\n\tif (strings.length == 0)\n\t{\n\t\treturn null;\n\t}", "  if(strings.length\
    \ == 0) return null;\n  if(strings.length == 1) return strings[0];\n  int max\
    \ = strings[0].length;\n  for(int i = 1; i < strings.length; i++)\n    if(strings[i].length\
    \ >= max)\n      max = strings[i].length;\n  return strings[strings.length - 1];\n\
    end\n/*\n Return true if both array elements are equal\n \n @param a first array\
    \ element\n @param b second array element\n*/\nfunction areEqual(a: string, b:\
    \ string): bool\n  a == b\nend\n/*\n Return the minimum number in the array\n\
    \ \n @param a array of numbers\n*/\nfunction min(a: number[]): number\n  local\
    \ min = math.nan;\n  for i in irange(0, len(a)) do\n    local v = a[i]\n    if(v\
    \ < min) then\n      min = v\n    end\n  end\n  return min\nend\n/*\n Return the\
    \ maximum number in the array\n \n @param a array of numbers\n*/\nfunction max(a:\
    \ number[]): number\n  local max = math.nan;\n  for i in irange(0, len(a)) do\n\
    \    local v = a[i]\n    if(v > max) then\n      max = v\n    end\n  end\n  return\
    \ max\nend\n/*\n Return the sum of the elements in the array\n \n @param a array\
    \ of numbers\n*/\nfunction sum(a: number[]): number\n  local sum = 0\n  for i\
    \ in irange(0, len(a)) do\n    local v = a[i]\n    sum = sum + v\n  end\n  return\
    \ sum\nend\n/*\n Return the mean of the elements in the array\n \n @param a array\
    \ of numbers\n*/\nfunction mean(a: number[]): number\n  local sum = sum(a)\n \
    \ return sum / irange(0, len(a))\nend\n/*\n Return the median of the elements\
    \ in the array\n \n @param a array of numbers\n*/\nfunction median(a: number[]):\
    \ number\n  local median = 0\n  local count = irange(0, len(a))\n  local length\
    \ = count[count] - 1\n  if(irange(0, len(a)) % 2 == 0) then\n    median = (a[length\
    \ + count / 2 - 1] + a[(length + count / 2)] / 2)/2\n  else\n    median = a[(length\
    \ + count / 2)] / 2\n  end\n  return median\nend\n/*\n Return the standard deviation\
    \ of the elements in the array\n \n @param a array of numbers\n*/\nfunction std(a:\
    \ number[]): number\n  local mean = mean(a)\n  local sum = 0\n  local m = mean\n\
    \  for i in irange(0, len(a)) do\n    local v = a[i]\n    sum = ", "{\n    if(strings.length\
    \ == 0) {\n        return null;\n    }\n    \n    int maxLen = strings[0].Length;\n\
    \    int maxLenIndex = 0;\n    \n    foreach(string s in strings) {\n        int\
    \ len = s.Length;\n        if(len > maxLen) {\n            maxLenIndex = i;\n\
    \            maxLen = len;\n        }\n    }\n    \n    if(maxLenIndex == strings.length\
    \ - 1) {\n        return strings[maxLenIndex];\n    } else {\n        return null;\n\
    \    }\n}", "    strings.length == 0 ? null : strings.reduce((result, current)\
    \ => result.length >= current.length ? result : current);\n</code>\n<|/ a tags=c++,c++17,std-variant\
    \ |>\n<| a dscore=1 tags=c++,c++17,std-variant |>\nI find that std::optional<std::variant>\
    \ is the best way to go.  It's not terribly efficient (but I'm sure it's quite\
    \ efficient in practice).  And it makes your code simpler.\nHere's an example:\n\
    <code>\n#include <iostream>\n#include <optional>\n#include <variant>", "{\n\t\
    if (strings.length < 1)\n\t\treturn null;", "\t{\n\tif((strings.length <= 0))\n\
    \t\treturn null;\n\tint len = 0;\n\t\n\tfor(string str : strings)\n\t\t{\n\t\t\
    if(str.length() > len)\n\t\t\tlen = str.length();\n\t\t}\n\t\t\n\treturn strings[strings.length\
    \ - 1];\n\t}", "    strings.length() > 0 ? (strings[0].length > strings[1].length\
    \ ? strings[0] : strings[1]) : null;\n/*\n In array of strings, return the one\
    \ with the shortest length. Return the first one in case of multiple\n    strings\
    \ of the same length. Return null in case the input array is empty.\n    >>> shortest([])\n\
    \    None\n    >>> shortest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> shortest([\"\
    a\", \"bb\", \"ccc\"])\n    \"a\"\n    \n*/\nNullable!(string) shortest(string[]\
    \ strings) \n    strings.length() > 0 ? (strings[0].length < strings[1].length\
    \ ? strings[0] : strings[1]) : null;", "{\n  if (strings.length == 0) {\n    return\
    \ null;\n  }\n  \n  int maxLen = strings.length.max;\n  string longest = strings[strings.length.min];\n\
    \  \n  for (int i = 0; i < strings.length; ++i) {\n    string str = strings[i];\n\
    \    if (str.length <= maxLen) {\n      continue;\n    }\n    \n    int idx =\
    \ 0;\n    while (idx < str.length && str.charAt(idx) == longest.charAt(idx)) {\n\
    \      ++idx;\n    }\n    \n    return longest = str.substring(idx, idx+maxLen);\n\
    \  }\n  \n  return longest;\n}\n/*\n Return True if all strings in array are of\
    \ the same length.\n Return False otherwise.\n Return null if there are no strings\
    \ or all strings are of the same length.\n */\nNullable!(bool) allSameLength(string[]\
    \ strings) \n{\n  if (strings.length == 0) {\n    return null;\n  }\n  \n  int\
    \ length = strings[0].len;\n  \n  for (int i = 0; i < strings.length; ++i) {\n\
    \    if (strings[i].len != length) {\n      return false;\n    }\n  }\n  \n  return\
    \ true;\n}\n/*\n Return True if all strings in array are of the same length, even\
    \ if some of them are empty strings.\n Return False otherwise.\n Return null if\
    \ there are no strings or all strings are of the same length.\n */\nNullable!(bool)\
    \ allSameLength(string[] strings, string[] emptyStrings) \n{\n  if (strings.length\
    \ == 0) {\n    return null;\n  }\n  \n  int length = strings[0].len;\n  \n  for\
    \ (int i = 0; i < strings.length; ++i) {\n    if (strings[i].len != length) {\n\
    \      return false;\n    }\n  }\n  \n  for (int i = 0; i < emptyStrings.length;\
    \ ++i) {\n    if (emptyStrings[i].len != length) {\n      return false;\n    }\n\
    \  }\n  \n  return true;\n}\n/*\n Remove duplicate strings from a given array\
    \ of strings.\n Duplicate strings may occur in the array while keeping the original\
    \ order of the strings.\n This function returns a new array containing the removed\
    \ strings.\n Return null if there are no strings or all strings are equal.\n */\n\
    Nullable!(string[]) removeDuplicates(string[] strings) \n{\n  if (strings.length\
    \ == 0) {\n    return null;\n  }\n  \n  string[] results = new string[strings.length];\n\
    \  \n  for (int i = 0; i < strings.length; ++i) {\n    string str = strings[i];\n\
    \    for (int j = 0; j < i; ++j) {\n      if (str == strings[j]) {\n        continue;\n\
    \      }\n      \n      results[i] = str;\n      ++i;\n      break;\n    }\n \
    \ }\n  \n  return results;\n}\n/*\n Return true if all strings in array are of\
    \ the same length, even if some of them are empty strings.", "{\n    int? bestLength\
    \ = null;\n    for(string[] strings_ in strings)\n    {\n        int stringLength\
    \ = 0;\n        foreach(string string_ in strings_)\n        {\n            stringLength\
    \ += string_.Length;\n        }\n        \n        if(bestLength == null || stringLength\
    \ > bestLength.Value)\n        {\n            bestLength = stringLength;\n   \
    \     }\n    }\n    return bestLength;\n}", "{\n    Nullable!(string) longest\
    \ = null;\n    foreach(string[] strs, strings) \n    {\n        int size = length(strings[0]);\n\
    \        \n        foreach(string s in strs)\n        {\n            int newsize\
    \ = length(strings[0]);\n            \n            if(size == newsize)\n     \
    \       {\n                if(longest == null)\n                {\n          \
    \          longest = s;\n                }\n                else\n           \
    \     {\n                    int diff = 0;\n                    for(int i = 0;\
    \ i < size; ++i)\n                    {\n                        diff += (strs[i].length()\
    \ - size) + 1;\n                    }\n                    if(diff < longest.length())\n\
    \                    {\n                        longest = s;\n               \
    \     }\n                }\n            }\n        }\n    }\n    return longest;\n\
    }", "    strings = filter (string != null) strings;\n    var result = null;\n\
    \    if (strings.length == 0)\n        return result;\n    else if (strings.length\
    \ == 1)\n        return strings[0];\n    else\n    {\n        var first = strings[0];\n\
    \        var longest = first;\n        for (var i = 1; i < strings.length; i++)\n\
    \        {\n            var len = length(strings[i]);\n            if (len > length(longest))\n\
    \                longest = strings[i];\n        }\n        return longest;\n \
    \   }\nend function longest;\n/*\n In array of strings, return array of indices\
    \ where string matches substring. Return null if string is\n    not found in array\
    \ of strings.\n    >>> indices([\"abc\", \"a\", \"b\"])\n    [0, 1]\n    >>> indices([\"\
    abc\", \"abc\", \"a\"])\n    [0]\n    >>> indices([\"abc\", \"abc\"])\n    []\n\
    \    \n*/\nNullable!(int[]) indices(string[] strings, string substring) \n   \
    \ strings = filter (string != null) strings;\n    substring = substring != null\
    \ ? substring : strings[0];\n    var result = [];\n    if (strings.length == 0\
    \ || strings[0] == null || substring == null)\n        return result;\n    else\n\
    \    {\n        var index = 0;\n        var current;\n        while ((current\
    \ = strings[index++]) != null)\n            if (current == substring)\n      \
    \          result.push(index);\n    return result;\n    }\nend function indices;",
  "{\n    var longest:string = null;\n    forall(strings) \n    {\n        var length\
    \ = strings.length();\n        if (length > longest.length)\n            longest\
    \ = strings[strings.length() - 1];\n    }\n    return longest;\n}", "{\n    if\
    \ (strings.Length == 0)\n        return null;\n    var minLength = strings[0].Length;\n\
    \    for (var i = 1; i < strings.Length; i++)\n    {\n        var length = strings[i].Length;\n\
    \        if (length < minLength)\n        {\n            minLength = length;\n\
    \        }\n    }\n    return strings[strings.Length - 1];\n}\n</code>\n<|/ a\
    \ tags=string,c# |>\n<| a tags=string,c# dscore=0 |>\n<code>\npublic string getFirstWord(string\
    \ str)\n{\n    string[] wordList = str.Split(' ');\n    foreach (string word in\
    \ wordList)\n    {\n        if (word.Length > 0)\n        {\n            return\
    \ word;\n        }\n    }\n    return string.Empty;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis is O(n^2) time. Don't do it.\n<|/ c |>\n<| a tags=string,c# |>\n\
    <code>\nstatic string GetFirstWord(string str)\n{\n    return str.Split(' ').FirstOrDefault();\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe result of this is `null` if str is\
    \ empty.\n<|/ c |>\n<| c |>\n.Ross No. `FirstOrDefault` returns `null` if there\
    \ are no words in the list.\n<|/ c |>\n<| c |>\n: No, it will throw an exception\
    \ if str has no spaces.\n<|/ c |>\n<| c |>\n: No. `FirstOrDefault` returns `null`,\
    \ not `default(T)`.\n<|/ c |>\n<| c |>\n.Ross I know, I'm just commenting on your\
    \ answer where you state that it can throw an exception when str is empty.\n<|/\
    \ c |>\n<| a dscore=0 tags=string,c# |>\n<code>\npublic static string getFirstWord(string\
    \ str)\n{\n    string[] wordList = str.Split(' ');\n    foreach (string word in\
    \ wordList)\n    {\n        if (word.Length > 0)\n        {\n            return\
    \ word;\n        }\n    }\n    return string.Empty;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis is O(n^2) time. Don't do it.\n<|/ c |>\n<| c |>\nWhy would it be\
    \ O(n^2)?\n<|/ c |>\n<| c |>\nBecause of the `return string.Empty` inside the\
    \ `foreach` loop\n<|/ c |>\n<| c |>\nThe `return string.Empty` will terminate\
    \ the method early, so it will only be O(", "{\n  // TODO: this should go in an\
    \ external file...\n  if(strings.length == 0)\n    return null;\n  var longestLength\
    \ = strings[0].Length;\n  for(var i = 1; i < strings.length; ++i)\n    if(strings[i].Length\
    \ > longestLength)\n      longestLength = strings[i].Length;\n  return longestLength\
    \ == strings[0].Length ? strings[0] : null;\n}", "{\n    int? minLength = min(strings,\
    \ s => s.length);\n    if (minLength.isDefined) {\n        string first = strings.first;\n\
    \        for (int i = 0; i < minLength; i += 1) {\n            if (strings[i].length\
    \ != first.length)\n                return null;\n        }\n        return first;\n\
    \    }\n    return null;\n}\n</code>\n<|/ a dscore=1 tags=d,arrays,string |>\n\
    <| a tags=d,arrays,string |>\n<code>\nimport std.algorithm;\nimport std.array;\n\
    import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.algorithm;\n\
    import std.typecons;\nimport std.math;", "{\n    // No strings, nothing to do\n\
    \    if (strings.length == 0)\n        return null;\n        \n    // The longest\
    \ one\n    long maxLen = 0;\n    string maxStr = \"\";\n    \n    // Iterate over\
    \ array\n    foreach (string s in strings) {\n        // Length is now known\n\
    \        int len = s.length();\n        \n        // We will compare this length\
    \ to the longest one found\n        long len = len;\n        if (len > maxLen)\
    \ {\n            maxLen = len;\n            maxStr = s;\n        }\n    }\n  \
    \  \n    return maxStr;\n}", "{\n\tint length = 0;\n\tforeach(string; strings)\
    \ {\n\t\tif(length < string.length) length = string.length;\n\t}\n\t\n\tif(length\
    \ == 0) {\n\t\treturn null;\n\t}\n\t\n\treturn strings[length - 1];\n}", "{\n\
    \    if(!strings.Length)\n        return null;\n    else\n        return strings.length\
    \ > 0 ?\n            std.string.get_longest_string(strings) :\n            null;\n\
    }\n/*\n Return true if all strings in array are equal. Return false otherwise.\n\
    \ Return null if the array is empty.\n */\nNullable!bool(string) all_equal(string[]\
    \ strings) \n{\n    if(!strings.Length)\n        return null;\n    else\n    \
    \    return std.string.get_all_equal(strings);\n}", "{\n\tvar max = strings.length\
    \ ~= 0 ? strings[0].length : int.max;\n\tvar res = strings[0];\n\tfor (var i =\
    \ 1; i < strings.length; ++i) {\n\t\tif (strings[i].length >= max) {\n\t\t\tmax\
    \ = strings[i].length;\n\t\t\tres = strings[i];\n\t\t}\n\t}\n\treturn res;\n}\n\
    /*\n Return array of strings separated by comma, sorted.\n Input array can be\
    \ empty. If empty return empty array.\n    >>> sortedjoin([])\n    []\n    >>>\
    \ sortedjoin([\"a\"])\n    [\"a\"]\n    >>> sortedjoin([\"a\",\"b\"])\n    [\"\
    a\", \"b\"]\n    >>> sortedjoin([\"a\",\"b\",\"c\"])\n    [\"a\", \"b\", \"c\"\
    ]\n    \n*/\nstring[]! sortedjoin(string[] strings) \n{\n\tif (!strings.length)\n\
    \t\treturn new string[0];\n\tvar res = new string[strings.length];\n\tvar pos\
    \ = 0;\n\tvar i = 0;\n\twhile (pos < strings.length) {\n\t\tvar pos = strings[i].IndexOf(strings[pos],\
    \ 0, StringComparison.Ordinal);\n\t\tif (pos == strings[i].Length)\n\t\t\tbreak;\n\
    \t\tres[i++] = strings[i];\n\t}\n\tres[i] = strings[pos];\n\treturn res;\n}\n\
    /*\n Return a string that represents the given integer in decimal notation.\n\
    \    The number will be rounded with rounding mode to two decimal places.\n  \
    \  For example: if number is 3.14159265, return \"3.14\".\n    The input number\
    \ will be rounded to an integer if necessary.\n    If number is NaN, return \"\
    NaN\".\n    >>> float2str(0)\n    \"0\"\n    >>> float2str(1.1)\n    \"1.1\"\n\
    \    >>> float2str(3.14159265)\n    \"3.14\"\n    \n*/\nstring! float2str(number\
    \ number) \n{\n\tvar str = \"\", x = number;\n\tif (x < 0.0) {\n\t\tstr = str\
    \ + \"-\";\n\t\tx = -x;\n\t}\n\tif (x == 0.0) return \"0\";\n\tvar t = x;\n\t\
    var i = 0;\n\twhile (t >= 10) {\n\t\tstr = str + t.ToString(\"0.###\");\n\t\t\
    t = x / 10.0;\n\t\ti++;\n\t}\n\tstr = str + t.ToString(\"0.##\");\n\treturn str;\n\
    }\n/*\n Return a string that represents the given integer in hexadecimal notation.\n\
    \    The number will be rounded with rounding mode to two decimal places.\n  \
    \  For example: if number is 0x43, return \"43\".\n    The input number will be\
    \ rounded to an integer if necessary.\n    If number is NaN, return \"NaN\".\n\
    \    >>> hex2str(0xFFFFFFFFFFFFFFFF)\n    \"ffffffffffffffff\"\n    \n*/\nstring!\
    \ hex2str(", "{\n\tforeach (i, s) in strings {\n\t\tif (s.length() > strings[i].length())\
    \ return s;\n\t}\n\treturn null;\n}", "{\n  var len = strings.length;\n  for(int\
    \ i=0; i < len; ++i)\n    if(strings[i].length == len)\n      return strings[i];\n\
    \  return null;\n}", "{\n    if (strings.length == 0) {\n        return null;\n\
    \    }\n    var maxLength = strings[0].length;\n    for (var i = 1; i < strings.length;\
    \ i++) {\n        if (strings[i].length >= maxLength) {\n            return strings[i];\n\
    \        }\n        maxLength = maxLength > strings[i].length ? maxLength : strings[i].length;\n\
    \    }\n    return strings[0];\n}", "{\n  if (strings.length == 0)\n    return\
    \ null;\n  int longestLength = 0;\n  foreach (string str in strings) {\n    int\
    \ len = str.length;\n    if (len > longestLength)\n      longestLength = len;\n\
    \  }\n  return strings[longestLength];\n}", "{ \n\tif(strings.length == 0) \n\t\
    {\n\t\treturn null;\n\t}\n\telse\n\t{\n\t\tvar minLength = Math.toIntExact(std.string.length(strings[0]));\n\
    \t\tvar result = null;\n\t\tfor(var i = 0; i < strings.length; i++)\n\t\t{\n\t\
    \t\tvar length = Math.toIntExact(std.string.length(strings[i]));\n\t\t\tif(length\
    \ < minLength)\n\t\t\t{\n\t\t\t\tminLength = length;\n\t\t\t\tresult = strings[i];\n\
    \t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}", "  if (strings.length <= 0) \n  \
    \  null;\n  else\n    let int maxIndex = -1;\n    foreach (int index, string)\
    \ in strings) {\n      if (index > maxIndex) {\n        maxIndex = index;\n  \
    \    }\n    }\n    strings[maxIndex];\n{\n  export alias length longest;\n  export\
    \ alias first longest;\n}\n</pre>", "  : strings indexOf(string) {\n    int index\
    \ = indexOf;\n    for(int i = 0; i < strings.length; i++){\n      if (indexOf\
    \ == strings[i].length) {\n        return strings[i];\n      } else if (indexOf\
    \ > strings[i].length) {\n        index = i;\n      }\n    }\n    return null;\n\
    \  }", "{\n    if(!strings.Length)\n        return null;\n    var max = strings[0];\n\
    \    foreach(strings.Skip(1), i => max = new string(i.length >= max.Length ? i\
    \ : max));\n    return max;\n}", "\t: string = \n\t\tlet len = builtins.max(map(builtins.length,\
    \ strings))\n\t\tin if len > 1 then strings[len - 1] else null\n{\n\tlet len =\
    \ builtins.max(map(builtins.length, strings))\n\tin if len > 1 then strings[len\
    \ - 1] else null\n};\n/*\n Return an array of strings of the given length (truncated),\
    \ or just the empty array in case of empty\n    array.\n    \n    >>> shortLength([])\n\
    \    []\n    >>> shortLength([\"a\"])\n    [\"a\"]\n    >>> shortLength([\"a\"\
    , \"b\"])\n    []\n    >>> shortLength([\"a\", \"b\", \"c\", null])\n    []\n\
    */\nstring[] shortLength(string[] strings) \n\t: string[] = \n\t\tlet len = builtins.max(map(builtins.length,\
    \ strings))\n\t\tin if len > 0 then strings.sublist(len - 1, len) else []\n{\n\
    \tlet len = builtins.max(map(builtins.length, strings))\n\tin if len > 0 then\
    \ strings.sublist(len - 1, len) else []\n};\n/*\n Return a string which is composed\
    \ of every string from the given array except the first one.\n    The returned\
    \ string will end with a separator, if provided.\n    \n    >>> takeFirst([\"\
    a\", \"b\", \"c\", \"d\"])\n    \"a_b_c_d\"\n    \n    If strings in the array\
    \ have empty or null elements, those will be skipped. \n    \n    >>> takeFirst([null,\
    \ \"\", \"\"])\n    \"\"\n    \n    Empty strings will be returned as empty strings\
    \ instead of null.\n    \n    >>> takeFirst([\"\"])\n    \"\"\n    \n    Empty\
    \ arrays will return empty arrays instead of null.\n    \n    >>> takeFirst([])\n\
    \    \"\"\n*/\nstring takeFirst(string[] strings) \n\t: string = \n\t\tlet first\
    \ = builtins.min(map(builtins.length, strings))\n\t\tin if builtins.min(map(builtins.length,\
    \ strings)) > 0 then strings.sublist(first, first + 1) + \"_\"\n\t\telse if strings.size\
    \ > 0 then strings.first\n\t\telse \"\"\n{\n\tlet first = builtins.min(map(builtins.length,\
    \ strings))\n\tin if builtins.min(map(builtins.length, strings)) > 0 then strings.sublist(first,\
    \ first + 1) + \"_\"\n\t\telse if strings.size > 0 then strings.first\n\t\telse\
    \ \"\"\n};\n/*\n Return a string which is composed of every string from the given\
    \ array except the first one.\n    The returned string will end with a separator,\
    \ if provided.\n    \n    >>> takeLast([\"a\", \"b\", \"c\", \"d\"])\n    \"a_d__\"\
    \n    \n    If strings in the array have empty or null elements, those will be\
    \ skipped. \n    \n    >>> takeLast([null, \"\", \"\"", "{\n\tforall(strings,\n\
    \t     (string str) => (!str.empty) ? str.longest() : null);\n\t\n\treturn strings.isEmpty()\
    \ ? null : strings.longest();\n}", "{\n    if(strings.length==0)\n        return\
    \ null;\n    std.sort(strings);\n    return std.reverse(strings);\n}", "{\n  \
    \  if (strings.length == 0) {\n        return null;\n    }\n    \n    int maxLength\
    \ = 0;\n    string maxString = null;\n    for (string s : strings) {\n       \
    \ if (s.Length > maxLength) {\n            maxLength = s.Length;\n           \
    \ maxString = s;\n        }\n    }\n    return maxString;\n}", "{\n    int maxLen\
    \ = 0;\n    int maxIdx = 0;\n    int idx = 0;\n    for (idx = 0; idx < strings.length;\
    \ idx += 1)\n    {\n        if (strings[idx].length > maxLen)\n        {\n   \
    \         maxLen = strings[idx].length;\n            maxIdx = idx;\n        }\n\
    \    }\n    return maxLen > 0 ? strings[maxIdx] : null;\n}", "{\n\tif (strings.length\
    \ == 0)\n\t\treturn null;\n\t\n\tassert(strings.length <= 32);\n\t\n\tstring longest\
    \ = strings[0];\n\tint longestLength = strings[0].length;\n\t\n\tfor (int i =\
    \ 1; i < strings.length; ++i) {\n\t\tstring s = strings[i];\n\t\tint l = s.length;\n\
    \t\tif (l > longestLength) {\n\t\t\tlongestLength = l;\n\t\t\tlongest = s;\n\t\
    \t}\n\t}\n\t\n\treturn longest;\n}", "{\n    \n    var maxLen = 0;\n    var retVal:\
    \ string =null;\n    for (string str : strings) {\n        if (str.length > maxLen)\
    \ {\n            maxLen = str.length;\n            retVal = str;\n        }\n\
    \    }\n    return retVal;\n}\n/*\n Out of array of strings, return the longest\
    \ one. Return the first one in case of multiple\n    strings of the same length.\
    \ Return null in case the input array is empty.\n    >>> longest([])\n    None\n\
    \    >>> longest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> longest([\"a\", \"\
    bb\", \"ccc\"])\n    \"ccc\"\n    \n*/\nNullable!(string) longest(string[] strings)\
    \ \n{\n    \n    var maxLen = 0;\n    var retVal: string =null;\n    for (string\
    \ str : strings) {\n        if (str.length > maxLen) {\n            maxLen = str.length;\n\
    \            retVal = str;\n        }\n    }\n    return retVal;\n}\n/*\n Out\
    \ of array of strings, return the longest one. Return the first one in case of\
    \ multiple\n    strings of the same length. Return null in case the input array\
    \ is empty.\n    >>> longest([])\n    None\n    >>> longest([\"a\", \"b\", \"\
    c\"])\n    \"a\"\n    >>> longest([\"a\", \"bb\", \"ccc\"])\n    \"ccc\"\n   \
    \ \n*/\nNullable!(string) longest(string[] strings) \n{\n    \n    var maxLen\
    \ = 0;\n    var retVal: string =null;\n    for (string str : strings) {\n    \
    \    if (str.length > maxLen) {\n            maxLen = str.length;\n          \
    \  retVal = str;\n        }\n    }\n    return retVal;\n}", "{\n\t\n\tfor (auto\
    \ elem : strings) {\n\t\tif (elem.length() > longest.length()) return longest;\n\
    \t}\n\t\n\treturn longest;\n}", "{\n  int maxlen = 0;\n  string maxStr = null;\n\
    \  foreach (string str in strings) \n  {\n    int len = str.length;\n    if(len\
    \ > maxlen) \n    {\n      maxlen = len;\n      maxStr = str;\n    }\n  }\n  return\
    \ maxStr;\n}", "{\n\tint len = strings.length;\n\tstring longestStr = null;\n\t\
    \n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tif (longestStr == null || strings[i].length\
    \ < longestStr.length)\n\t\t{\n\t\t\tlongestStr = strings[i];\n\t\t}\n\t}\n\t\n\
    \treturn longestStr;\n}", "{\n    if (strings.length == 0) {\n        return null;\n\
    \    } else if (strings.length == 1) {\n        return strings[0];\n    }", "{\n\
    \    foreach (string string in strings)\n    {\n        if (string.length > longest.length)\n\
    \        {\n            longest = string;\n        }\n    }\n    return longest;\n\
    }", "{\n    if (strings.length == 0) {\n        return null;\n    }\n    string\
    \ longest = strings[0];\n    for (int i = 1; i < strings.length; i++) {\n    \
    \    if (strings[i].length() > longest.length()) {\n            longest = strings[i];\n\
    \        }\n    }\n    return longest;\n}\n/*\n Out of array of strings, return\
    \ the shortest one. Return the first one in case of multiple\n    strings of the\
    \ same length. Return null in case the input array is empty.\n    >>> longest([])\n\
    \    None\n    >>> longest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> longest([\"\
    a\", \"bb\", \"ccc\"])\n    \"a\"\n    \n*/\nNullable!(string) shortest(string[]\
    \ strings) \n{\n    if (strings.length == 0) {\n        return null;\n    }\n\
    \    string shortest = strings[0];\n    for (int i = 1; i < strings.length; i++)\
    \ {\n        if (strings[i].length() < shortest.length()) {\n            shortest\
    \ = strings[i];\n        }\n    }\n    return shortest;\n}", "{\n  if (strings.length\
    \ == 0)\n    return null;\n  else\n    return strings[strings.length-1].length;\n\
    }\n/*\n Returns true if string i1 is greater than string i2. If i1 is null, then\
    \ return true\n If i1 is less than string i2, then return false\n \n This function\
    \ uses toDouble() function to convert string to double\n \n @return True if i1\
    \ > i2, false otherwise\n \n */\nfunction i1GtI2(i1: Nullable!(string), i2: Nullable!(string)):\
    \ bool \n{\n  i1 = i1!.toDouble(); i2 = i2!.toDouble();\n  if (i1 == null) i1\
    \ = 0.0;\n  if (i2 == null) i2 = 0.0;\n  return i1 > i2;\n}\n/*\n Returns true\
    \ if string i1 is less than string i2. If i1 is null, then return true\n If i1\
    \ is greater than string i2, then return false\n \n This function uses toDouble()\
    \ function to convert string to double\n \n @return True if i1 < i2, false otherwise\n\
    \ \n */\nfunction i1LtI2(i1: Nullable!(string), i2: Nullable!(string)): bool \n\
    {\n  i1 = i1!.toDouble(); i2 = i2!.toDouble();\n  if (i1 == null) i1 = 0.0;\n\
    \  if (i2 == null) i2 = 0.0;\n  return i1 < i2;\n}\n/*\n Returns true if string\
    \ i1 is less than or equal to string i2. If i1 is null, then return true\n If\
    \ i1 is greater than or equal to string i2, then return false\n \n This function\
    \ uses toDouble() function to convert string to double\n \n @return True if i1\
    \ < i2, false otherwise\n \n */\nfunction i1LEI2(i1: Nullable!(string), i2: Nullable!(string)):\
    \ bool \n{\n  i1 = i1!.toDouble(); i2 = i2!.toDouble();\n  if (i1 == null) i1\
    \ = 0.0;\n  if (i2 == null) i2 = 0.0;\n  return i1 <= i2;\n}\n/*\n Returns true\
    \ if string i1 is greater than or equal to string i2. If i1 is null, then return\
    \ true\n If i1 is less than or equal to string i2, then return false\n \n This\
    \ function uses toDouble() function to convert string to double\n \n @return True\
    \ if i1 > i2, false otherwise\n \n */\nfunction i1GEI2(i1: Nullable!(string),\
    \ i2: Nullable!(string)): bool \n{\n  i1 = i1!.toDouble(); ", "{\n\tstring[] longestString\
    \ = null;\n\tif (strings.length == 0) return null;\n\t\n\tstd.array.sort(strings);\n\
    \t\n\tint i = 0;\n\twhile (i < strings.length && strings[i].length == strings[i+1].length)\
    \ \n\t{\n\t\t++i;\n\t}\n\tif (i < strings.length)\n\t{\n\t\tlongestString = new\
    \ string[i];\n\t\tstd.copyto(longestString, strings);\n\t\ti = i+1;\n\t}\n\telse\n\
    \t{\n\t\tlongestString = null;\n\t}\n\treturn longestString;\n}", "{\n    if (strings.length\
    \ == 0)\n        return null;\n    if (strings.length == 1)\n        return strings[0];\n\
    \    int bestLength = -1;\n    int bestLength = std.string.length(strings[0]);\n\
    \    for (int i = 1; i < strings.length; ++i) {\n        int length = std.string.length(strings[i]);\n\
    \        if (length > bestLength)\n            bestLength = length;\n    }\n \
    \   return strings[bestLength];\n}", "{\n    var res = strings[0];\n    for(var\
    \ i=1; i<strings.length; i++) \n    {\n        var length = std.string.length(strings[i]);\n\
    \        if(length>res.length) \n            res = strings[i];\n    }\n    return\
    \ res;\n}\n</code>\n<|/ a tags=c#,string dscore=0 |>\n<| a |>\nFor me this approach\
    \ is really simple and easy to understand :\n<code>\nvar string = \"Hello my name\
    \ is Anthony Dunaway\";", "{\n    if (strings.length == 0)\n        return null;\n\
    \    \n    Length maxLength = strings[0].length;\n    string maxString = strings[0];\n\
    \    \n    for (Length i = 0; i < strings.length; ++i) {\n        if (strings[i].length\
    \ >= maxLength)\n            maxString = strings[i];\n    }\n    \n    return\
    \ maxString;\n}\n/*\n Out of array of strings, return the shortest one. Return\
    \ the first one in case of multiple\n    strings of the same length. Return null\
    \ in case the input array is empty.\n    >>> shortest([\"\"])\n    \"\"\n    >>>\
    \ shortest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> shortest([\"a\", \"bb\"\
    , \"ccc\"])\n    \"a\"\n    \n*/\nNullable!(string) shortest(string[] strings)\
    \ \n{\n    if (strings.length == 0)\n        return null;\n    \n    Length minLength\
    \ = strings[0].length;\n    string minString = strings[0];\n    \n    for (Length\
    \ i = 0; i < strings.length; ++i) {\n        if (strings[i].length <= minLength)\n\
    \            minString = strings[i];\n    }\n    \n    return minString;\n}",
  "{\n\tint len = Length!strings;\n\tif(len == 0)\n\t\treturn null;\n\telse if(len\
    \ == 1)\n\t\treturn strings[0];\n\tint cur = len - 1;\n\tstring curStr = strings[cur];\n\
    \twhile((curStr.length == len) && (curStr != strings[cur-1]))\n\t{\n\t\tcurStr=strings[cur-1];\n\
    \t\tcur--;\n\t}\n\treturn curStr;\n}\n/*\n Return the index of the first occurrence\
    \ of the string s in the array or -1 if not found. \n If the s occurs more than\
    \ once in the array, return the first one occurring in the array.\n Otherwise\
    \ returns -1\n >>> indexOf(\"aa\", [\"a\",\"a\",\"b\"])\n 1\n >>> indexOf(\"aa\"\
    , [\"a\",\"a\",\"bb\"])\n 0\n \n*/", "{\n    int maxLength = 0;\n    int i;\n\
    \    for(i = 0; i < strings.length; ++i) {\n        string s = strings[i];\n \
    \       if(s.length > maxLength) {\n            maxLength = s.length;\n      \
    \  }\n    }\n    if(maxLength == 0) {\n        return null;\n    }\n    return\
    \ strings[maxLength - 1];\n}", "{\n    string[] result = new string[strings.length];\n\
    \    int i = 0;\n    while (i < strings.length)\n    {\n        int j = i+1;\n\
    \        while (j < strings.length)\n        {\n            if (strings[i].length\
    \ < strings[j].length)\n            {\n                result[i] = strings[i];\n\
    \                i = j;\n            }\n            else\n            {\n    \
    \            result[i] = strings[j];\n                j = j + 1;\n           \
    \ }\n        }\n        i++;\n    }\n    if (i == strings.length)\n    {\n   \
    \     return null;\n    }\n    return result[0];\n}\n</code>\n<|/ a tags=c#,string-length\
    \ dscore=5 |>\n<| c |>\nI liked this a lot over the accepted answer. Mine has\
    \ a few improvements for larger arrays (but yours also has those), but it's certainly\
    \ more elegant and easier to read. Thanks.\n<|/ c |>\n<| c |>\nYeah, I agree,\
    \ this is definitely the most performant solution.\n<|/ c |>\n<| c |>\nYes this\
    \ one is best and best for my purpose. Thank you, very simple.\n<|/ c |>\n<| c\
    \ |>\nThis is a good solution. I've used it in a C# extension method to get the\
    \ longest string in a list of strings.\n<|/ c |>\n<| c |>\nWhat about `string.Empty`\
    \ vs `\"\"` vs `null` vs `\"\"`? IMO best answer would be to return `string.Empty`\
    \ instead of null. Or maybe throw exception in case the array is empty.\n<|/ c\
    \ |>\n<| a dscore=5 tags=c#,string-length |>\n<code>\nstring[] array = new string[]\
    \ {\"one\", \"two\", \"three\", \"four\"};\nstring longest = array.Aggregate(string.Empty,\
    \ \n        (current, s) => s.Length > current.Length ? s : current);\n</code>\n\
    <|/ a |>\n<| c |>\n`var longest = array.Max(s => s.Length);`\n<|/ c |>\n<| c |>\n\
    Not to mention that `Array` implements `IEnumerable` and therefore `Max` works\
    \ on it directly\n<|/ c |>\n<| a dscore=5 |>\nJust use Enumerable.Max(Of TSource)\
    \ extension method.\n<code>\nvar longest = array.Max(s => s.Length);\n</code>\n\
    <|/ a tags=c#,string-length |>\n<| c |>\nBut this doesn't give the \"first\" string,\
    \ rather the longest. If there are multiple strings of the same length, then this\
    \ wouldn't work.\n<|/ c |>", "{\n    size_t maxLength = 0;\n    for (size_t i\
    \ = 0; i < strings.size(); ++i) {\n        if (strings[i].length() > maxLength)\n\
    \            maxLength = strings[i].length();\n    }", "{\n\tassert(strings.length\
    \ > 0);\n\tvar longest = strings[0];\n\tfor(var i=1; i < strings.length; ++i)\n\
    \t{\n\t\tvar currentLength = strings[i].length;\n\t\t\n\t\tif(currentLength >\
    \ longest.length)\n\t\t{\n\t\t\tlongest = strings[i];\n\t\t}\n\t}\n\treturn longest;\n\
    }", "{\n\tif (strings.length == 0) {\n\t\treturn null;\n\t}\n\t\n\tstring result;\n\
    \t\n\tstring min;\n\tforeach(string,value,strings) {\n\t\t\n\t\tif (value < min)\
    \ {\n\t\t\tmin = value;\n\t\t}\n\t\t\n\t\tif (value.length < min.length) {\n\t\
    \t\tresult = value;\n\t\t}\n\t}\n\t\n\treturn result;\n}", "{\n    Nullable!(string)\
    \ max = null;\n    foreach (string s in strings) {\n        if (max is null ||\
    \ s.length >= max.length) { \n            max = s;\n        }\n    }\n    return\
    \ max;\n}\n</code>\n<|/ a dscore=4 tags=string,functional-programming,c#,f# |>\n\
    <| c |>\n+1 for `Nullable!` - I wasn't aware of that until now - I thought I had\
    \ to implement it myself.\n<|/ c |>\n<| a |>\nYou can use the String.Join method\
    \ which works with IEnumerable<T>.\n<code>\nString.Join(\",\", \"aa\", \"bb\"\
    , \"cc\");\n// returns \"aa,bb,cc\"\n</code>\n<|/ a tags=string,functional-programming,c#,f#\
    \ dscore=4 |>\n<| c |>\nThis answer was posted before the F# `seq` module was\
    \ added as a native language feature, which allowed a nice and concise solution.\
    \ See the answer provided by Jon Skeet for details.\n<|/ c |>\n<| a tags=string,functional-programming,c#,f#\
    \ |>\nIf you're writing F# you can use the String.Join method like so:\n<code>\n\
    let longest = String.Join(\",\", \"aa\", \"bb\", \"cc\")\n</code>\n<|/ a dscore=3\
    \ |>\n<| a |>\nYou can use the LINQ extension function Enumerable.Max()\n<code>\n\
    string longestString = myList.Max(s => s).ToString();\n</code>\n<|/ a dscore=3\
    \ tags=string,functional-programming,c#,f# |>\n<| c |>\nThis will return `System.Linq.Enumerable+<MaxIterator>d__a`\
    \ instead of `ccc` as asked.\n<|/ c |>\n<| c |>\n- you are correct - I didn't\
    \ notice that requirement. I believe the accepted answer is the correct one -\
    \ it returns `ccc` correctly.\n<|/ c |>\n<| a dscore=3 |>\n<code>\nstring longest(params\
    \ string[] strings) \n{\n    return strings.Aggregate((a, s) => s.Length > a.Length\
    \ ? s : a);\n}\n</code>\n<|/ a tags=string,functional-programming,c#,f# |>\n<|\
    \ c |>\nThis will return `System.Linq.Enumerable+<AggregateIterator>d__a` instead\
    \ of `ccc` as asked.\n<|/ c |>\n<| a tags=string,functional-programming,c#,f#\
    \ |>\nYou could do it like that if you want an ", "{\n\t\n\tif strings.length==0\
    \ then \n\t\treturn null;\n\t\n\tlet longestString = strings[0];\n\tlet length\
    \ = 1;\n\t\n\tforeach (string str in strings) {\n\t\tif str.length > length then\
    \ \n\t\t\tlength = str.length;\n\t\t\tlongestString = str;\n\t}\n\t\n\treturn\
    \ longestString;\n}", "{\n  int longestLength = 0;\n  foreach(string str, strings)\
    \ {\n    if(str.length > longestLength) {\n      longestLength = str.length;\n\
    \    }\n  }\n  return longestLength > 0 ? strings[longestLength-1] : null;\n}",
  "{\n\tforeach (string str in strings) {\n\t\tif (str.length > longest.length())\n\
    \t\t\tlongest = str;\n\t}\n\treturn longest;\n}", "{\n    if (strings.length ==\
    \ 0) return null;\n    int max = lengthOf(strings[0]);\n    for (int i = 1; i\
    \ < strings.length; i++) \n    {\n        if (lengthOf(strings[i]) > max) max\
    \ = lengthOf(strings[i]);\n    }\n    return strings[max];\n}\n</code>\n<|/ a\
    \ dscore=4 tags=typescript,types,javascript,arrays |>\n<| c |>\nNice solution,\
    \ but you should consider changing the types to `string`, `number` and `boolean`.\n\
    <|/ c |>\n<| c |>\nFor me it doesnt work if the string has a double quote in it\n\
    <|/ c |>\n<| c |>\nCan you please give an example? What is happening?\n<|/ c |>\n\
    <| c |>\n\"mystring\" for example is not taken as string, its taken as variable\
    \ \"mystring\"\n<|/ c |>\n<| c |>\nTry with double quotes. Maybe you need to escape\
    \ it\n<|/ c |>\n<| a |>\n<code>\nvar input = [\"hello\", \"world\", \"hi\"];\n\
    var longest = input.reduce(function (longest, str) {\n    return str.length >\
    \ longest ? str.length : longest;\n});", "{\n    if (strings.length == 0)\n  \
    \      return null;\n    string longest = strings[0];\n    foreach (string s in\
    \ strings) {\n        int len = s.length();\n        if (len > longest.length())\
    \ {\n            longest = s;\n        }\n    }\n    return longest;\n}", "{\n\
    \   if(strings.length == 0)\n      return null;\n   var longestString = \"\";\
    \ \n   var longestLength = strings[0].length();\n   foreach(string s in strings)\
    \ {\n      if(s.length() > longestLength) {\n         longestString = s;\n   \
    \      longestLength = s.length();\n      }\n   }\n   return longestString;\n\
    }\n</code>\n<|/ a tags=string,c#,algorithm |>\n<| c |>\nThis does not seem to\
    \ be valid C# code\n<|/ c |>\n<| c |>\nSorry, I didn't get back to you about this,\
    \ as I moved onto other issues related to my project.\n<|/ c |>\n<| a dscore=2\
    \ |>\nAnother solution using LINQ:\n<code>\nstring longestString(string[] strings)\n\
    {\n    return strings.OrderBy(s => s.Length).First();\n}\n</code>\n<|/ a tags=string,c#,algorithm\
    \ |>\n<| a tags=string,c#,algorithm |>\nThe solution is to find the longest string\
    \ and then search for the first occurrence of substring that matches in your string.\
    \ \n<code>\npublic static string FindLongestString(string input, string search)\n\
    {\n     int maxLength = -1;\n     int index = 0;", "  strings.length if0;\n  strings.length\
    \ if1;\n  strings.length if2;\n  \n  Nullable!(string) result if0;\n  Nullable!(string)\
    \ result if1;\n  Nullable!(string) result if2;\n  \n  result = strings[longest](strings);\n\
    \  \n  result if0;\n  result if1;\n  result if2;\n  \n  result;\nend\n\"\"\"\n\
    )\n</cell>\n<code language=dyalog-kernel>\n@task\ndef longest(array):\n    \"\"\
    \"Out of array of strings, return the longest one. Return the first one in case\
    \ of multiple\n    strings of the same length. Return null in case the input array\
    \ is empty.\n    >>> longest([])\n    None\n    >>> longest([\"a\", \"b\", \"\
    c\"])\n    \"a\"\n    >>> longest([\"a\", \"bb\", \"ccc\"])\n    \"ccc\"\n   \
    \ \n    \"\"\"\n    strings = array |> stringArray\n    \n    if strings.length\
    \ == 0: return None\n    \n    strings = strings |> sort\n    \n    result = None\n\
    \    \n    for i in 0..strings.length - 1 do\n        \n        string : string\
    \ = strings[i]\n        \n        if result == None or string != result[length]:\
    \ string = string\n        \n        if result == None or string != result[length]:\
    \ result = string\n    \n    return result\n</cell>\n<code language=dyalog-kernel>\n\
    longest([1, 1, 2, 3, 4, 4, 6])\n</cell>\n<code language=dyalog-kernel>\nlongest([\"\
    a\", \"bb\", \"ccc\"])\n</cell>\n<code language=dyalog-kernel>\nlongest([1, 1,\
    \ 1, 1, 1, 1])\n</cell>\n<code language=dyalog-kernel>\nlongest([1, 1, 1])\n</cell>\n\
    <code language=dyalog-kernel>\nlongest([\"a\", \"b\", \"bb\", \"ccc\"])\n</cell>\n\
    <code language=dyalog-kernel>\nlongest([])\n</cell>\n<code language=dyalog-kernel>\n\
    longest([\"\"])\n</cell>\n<code language=dyalog-kernel>\nlongest([\"a\"])\n</cell>\n\
    <code language=dyalog-kernel>\nlongest([])\n</cell>\n<code language=dyalog-kernel>\n\
    longest([\"a\", \"b\", \"bb\"])\n</cell>\n<code language=dyalog-kernel>\nlongest([\"\
    a\", \"b\", \"cc\"])\n</cell>\n<code language=dyalog-kernel>\nlongest([\"a\",\
    \ \"b\", \"cc\", \"a\"])\n</cell>\n<code language=dyalog-kernel>\nlongest([\"\
    a\", \"b\", \"cc\", \"a\", \"\"])\n</cell>\n<code language=dyalog-kernel>\nlongest([\"",
  "{\n    int iMax = strings.length - 1;\n    int i = 0;\n    \n    if (iMax == 0)\n\
    \        return null;\n    \n    while (iMax - i >= 0)\n    {\n        int iStringLength\
    \ = (int)strings[i].Length;\n        \n        if ((iMax == i) || (iStringLength\
    \ > strings[iMax].Length))\n        {\n            iMax = i;\n        }\n    \
    \    \n        ++i;\n    }\n    \n    return strings[iMax];\n}", "{\n    return\
    \ if (strings.length == 0) \n        null;\n    else if (strings.length > 0)\n\
    \        longest(strings[strings.length - 1].last(), strings);\n    else \n  \
    \      null;\n}\n/*\n Return array of strings, where each string in the original\
    \ array is a substring\n    of the last string in the return array.\n    >>> longestSubstrings([\"\
    a\", \"bb\", \"ccc\"])\n    [\"a\", \"bb\"]\n*/\nNullable!(string[]) longestSubstrings(string[]\
    \ strings) {\n    return longest(substrings(strings));\n}", "    : string = null\
    \ \n    => (if strings [] == null \n       then null\n       else longest(strings\
    \ [] ) ) \n    ;\n        \n/*\n Out of array of strings, return the longest one.\
    \ Return the first one in case of multiple\n    strings of the same length. Return\
    \ null in case the input array is empty.\n    >>> longest([])\n    None\n    >>>\
    \ longest([\"a\", \"b\", \"c\"])\n    \"a\"\n    >>> longest([\"a\", \"bb\", \"\
    ccc\"])\n    \"ccc\"\n    \n*/\nNullable!(string) longest(string[] strings) \n\
    \    : string = null \n    => (if strings [] == null \n       then null\n    \
    \   else longest(strings [] ) ) \n    ;", "{\n    if (strings.length == 0) {\n\
    \        return null;\n    }", "{\n    string res = \"\";\n    foreach (string\
    \ s in strings) {\n        if (s.length() > res.length()) {\n            res =\
    \ s;\n        }\n    }\n    return !strings.isEmpty() ? res : null;\n}\n</code>\n\
    <|/ a |>\n<| a tags=c#,algorithm |>\nHow about:\n<code>\nstring longest = \"\"\
    ;", "{\n    var longest:string = null;\n    var lengths:int[] = [];\n    lengths.length\
    \ = strings.length;\n    for(var i:int=0; i<lengths.length; i++)\n        lengths[i]\
    \ = strings[i].length;\n    for(var i:int=0; i<lengths.length; i++)\n    {\n \
    \       var currentLength:int = lengths[i];\n        if(currentLength > longest.length)\n\
    \            longest = strings[i];\n        else\n        {\n            var found:bool\
    \ = false;\n            for(var j:int=0; j<i; j++)\n                if(lengths[j]\
    \ < currentLength)\n                {\n                    found = true;\n   \
    \                 break;\n                }\n            if(!found)\n        \
    \        longest = strings[i];\n        }\n    }\n    return longest;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nWhy are you making the array sizes explicit and not using a\
    \ for loop and just do lengths[i] = strings[i].length;?\n<|/ c |>\n<| c |>\nI\
    \ guess I should have said \"why are you declaring `lengths` in the first place\"\
    . I think that would work as well.\n<|/ c |>\n<| c |>\nI like this answer, and\
    \ I like the simplicity of the algorithm but I still think it would be better\
    \ to use a for loop like `for(var i:int = 0; i < strings.length; i++){lengths[i]\
    \ = strings[i].length;}`\n<|/ c |>\n<| c |>\nOh, yeah, you're right - it probably\
    \ would. I'm not really sure why the guys at MS didn't include that as a template\
    \ for a function to get the lengths of arrays. Thanks for pointing it out - I'll\
    \ update my answer with your suggestion.\n<|/ c |>\n<| a tags=algorithm,string,arrays,sorting\
    \ |>\n<code>\nfunction longestStr(str){\n    var longest = '';\n    str.forEach(str\
    \ => {\n        str = str.split('');\n        var l = 0, m = 0;\n        for(var\
    \ i =0; i < str.length; i++){\n            var j = i;\n            while(j >=\
    \ 0){\n                if(str[j] > str[i - 1])\n                    break;\n \
    \               if(str[j] < str[i - 1])\n                    j--;\n          \
    \  }\n            l = Math.max(l, j - i);\n            m = Math.max(m, str.length);\n\
    \        }\n        if(m > l)\n            longest = str[i];\n    });\n    return\
    \ longest;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYou don't need `str = str.split('');`.\
    \ `str.forEach` already takes care of that for you. Additionally, you're not properly\
    \ checking if the current string is the longest string. Your `m` variable needs\
    \ to be updated inside of your `if` statement. And you probably want to use `Math.max(",
  "{\n    string[] result;\n    int i;\n    int maxLen = 0;", "{\n\tif( strings.isEmpty()\
    \ ) return null;\n\tif( strings.length == 1 ) return strings[0];\n\tint longestLength\
    \ = 0;\n\tint index = 0;\n\tstring longestString = strings[0];\n\tforeach( string\
    \ s in strings)\n\t{\n\t\tif( s.length() > longestLength )\n\t\t{\n\t\t\tlongestString\
    \ = s;\n\t\t\tlongestLength = s.length();\n\t\t}\n\t}\n\treturn longestString;\n\
    }", "\t: strings.head.len()\n{\n\tif (strings.length == 0) return null;\n\tif\
    \ (strings.head.len()  == strings[0].len()) return strings.head;\n\tfor (int i\
    \ = 0; i < strings.length; i++)\n\t{\n\t\tif (strings[i].len()  == strings[0].len())\
    \ return strings[0];\n\t\tif (strings[i].len()  > strings.head.len()) return strings[i];\n\
    \t}\n\treturn null;\n}", "{\n\tvar result: string =null;\n\tvar maxLength:int\
    \ =-1;\n\tfor(var i = 0; i < strings.length; i++)\n\t{\n\t\tvar tmp:int =strings[i].length;\n\
    \t\tif(tmp > maxLength)\n\t\t{\n\t\t\tmaxLength = tmp;\n\t\t\tresult = strings[i];\n\
    \t\t}\n\t}\n\treturn result;\n}", "{\n    // TODO: implement me\n    if (strings.length\
    \ == 0)\n        return null;\n    var ret: string = null;\n    foreach (string\
    \ s in strings)\n    {\n        if (ret != null && ret.length < s.length)\n  \
    \          ret = s;\n    }\n    return ret;\n}", "{\n\tif (strings.length < 1)\
    \ return null;\n\tvar maxLength = strings[0].Length;\n\tvar index = 1;\n\tfor\
    \ (var i=0; i<strings.length; i++)\n\t{\n\t\tif (strings[i].Length > maxLength)\
    \ \n\t\t{\n\t\t\tmaxLength = strings[i].Length;\n\t\t\tindex = i;\n\t\t}\n\t}\n\
    \treturn strings[index];\n}", "{\n  if (strings.length == 0) {\n    return null;\n\
    \  }\n  else {\n    long maxLength = (long) strings[0].length;\n    int maxIndex\
    \ = 0;\n    foreach (String s in strings) {\n      if (s.length > (long) maxLength)\
    \ {\n        maxLength = s.length;\n        maxIndex = i;\n      }\n      i++;\n\
    \    }\n    return strings[maxIndex];\n  }\n}", "{\n\tif(strings.length==0)\n\t\
    \treturn null;\n\tint lon=0;\n\tforeach(string,s in strings) {\n\t\tint l = s.length();\n\
    \t\tif(l>lon) \n\t\t\tlon=l;\n\t}\n\tif(lon==0) return null;\n\tfor(int i=0;i<strings.length;i++)\
    \ {\n\t\tif(strings[i].length()==lon) return strings[i];\n\t}\n\treturn null;\n\
    }", "{\n    if (strings.length == 0) { return null; }\n    var max = strings[0];\n\
    \    for (var i = 1; i < strings.length; i++) {\n        if (strings[i].length\
    \ < max.length) {\n            max = strings[i];\n        }\n    }\n    return\
    \ max;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
