name: HumanEval_58_common
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common elements\
  \ for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
  \ 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L,\
  \ 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n"
tests: "unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
  \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
  \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
  \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L,\
  \ 8L], []) == []);\n}\nvoid main(){}"
completions: ["{\n    // create two hash sets with hashes l1 and l2\n    // use set\
    \ for O(1) lookup and insertion\n    Set<Long> set1 = new Set<Long>(l1);\n   \
    \ Set<Long> set2 = new Set<Long>(l2);\n    \n    // find the common elements\n\
    \    long[] common = new long[set1.size() + set2.size()];\n    int i = 0;\n  \
    \  for (Long e : set1) {\n        set2.remove(e);\n        if (set2.size() ==\
    \ 0) {\n            common[i] = e;\n            ++i;\n        }\n    }\n    for\
    \ (Long e : set2) {\n        set1.remove(e);\n        if (set1.size() == 0) {\n\
    \            common[i] = e;\n            ++i;\n        }\n    }\n    // sort them\n\
    \    Arrays.sort(common);\n    return common;\n}\n</code>\n<|/ a dscore=0 tags=set,collections,java,arrays\
    \ |>\n<| a dscore=0 |>\nI know its been almost 2 years since this question was\
    \ posted, but I was looking for something like this and I implemented this using\
    \ HashSet. Since a HashSet contains only unique values, I first sort the ArrayList\
    \ and then call hashSet.contains to verify whether the value already exists in\
    \ my hashset. Since HashSet is unordered, I have to iterate through the ArrayList\
    \ again. Here is a full example. Hope this helps somebody out there.\n<code>\n\
    import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\
    import java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\n\
    import java.util.Set;\nimport java.util.stream.Collectors;", "{\n     if (l1.length\
    \ != l2.length) \n         throw new IndexOutOfBoundsException(\"length of l1\
    \ must be same as length of l2\");\n     int[] a = new int[l1.length];\n     int\
    \ i=0, j=0, n=0, min=0;\n     while (i < l1.length && j < l2.length)\n     {\n\
    \         if (l1[i] < l2[j])\n         {\n             a[n] = l1[i];\n       \
    \      i++;\n             n++;\n         }\n         else if (l1[i] > l2[j])\n\
    \         {\n             a[n] = l2[j];\n             j++;\n             n++;\n\
    \         }\n         else\n         {\n             if (min == 0 || a[n-1] <\
    \ a[min-1]) \n                 min = n-1;\n             n++;\n         }\n   \
    \  }\n     if (n < a.length)\n         a[n] = l1[i];\n     return a;\n}\n</code>\n\
    <|/ a dscore=0 tags=java |>\n<| c |>\nPlease explain your solution\n<|/ c |>\n\
    <| a dscore=0 |>\nThis is an implementation that uses a HashMap instead of ArrayList\
    \ to store the results.\nThis solution will work in linear time with the size\
    \ of the lists (n log n), as opposed to quadratic with the size of the lists (n^2).\n\
    <code>\npublic static <E, T> List<E> intersection(List<T> l1, List<T> l2) {\n\
    \    HashMap<E, Boolean> map = new HashMap<>();\n    for (T t : l1) {\n      \
    \  if (map.containsKey(t)) {\n            map.put(t, map.get(t) && l2.contains(t));\n\
    \        } else {\n            map.put(t, true);\n        }\n    }\n    List<E>\
    \ results = new ArrayList<>();\n    for (E e : map.keySet()) {\n        if (map.get(e)\
    \ && map.get(e) == l2.contains(e)) {\n            results.add(e);\n        }\n\
    \    }\n    return results;\n}\n</code>\n<|/ a tags=java |>\n<| a tags=java |>\n\
    The idea is to use a HashMap to store the results. So the algorithm is:", "{\n\
    \    // sort array in ascending order\n    int i = 0, j = 0;\n    while(i<l1.length\
    \ && j<l2.length){\n        if(l1[i] < l2[j]){\n            ++i;\n        }\n\
    \        else{\n            ++j;\n        }\n    }\n    int arrLen = l1.length\
    \ > l2.length ? l1.length : l2.length;\n    \n    // sort smaller array if necessary\n\
    \    for(int k=0; k<arrLen; k++){\n        if(l1[k] < l2[k]){\n            int\
    \ tempId = l1[l1.length-k-1];\n            l1[l1.length-k-1] = l2[k];\n      \
    \      l2[k] = tempId;\n        }\n    }\n    \n    // return the common array\n\
    \    long[] common = new long[arrLen];\n    for(int k=0; k<arrLen; k++){\n   \
    \     common[k] = l1[k];\n    }\n    return common;\n}", "{\n    long[] result\
    \ = {0L};\n    std.typecons.Reverse(l2);\n    for(int i = 0; i < l1.length; i++)\
    \ \n    {\n        long common = std.math.Min(l1[i], l2[i]);\n        for(int\
    \ j = result.length - 1; j >= 0; j--) \n            if(result[j] == common) break;\n\
    \            else if(result[j] > common)\n                result[j] = common;\n\
    \    }\n    return std.typecons.Array.toLongArray(result);\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThat code does not work if you have duplicate numbers in your arrays.\
    \ For example:", "{\n    long[] l3;\n    if (l1.length == 0 || l2.length == 0)\
    \ return new long[0];\n    \n    l3 = new long[(int)l1.length + l2.length];\n\
    \    long max = l1.length > l2.length ? l1 : l2;\n    for(int i=0; i<l3.length;\
    \ i++){\n        l3[i] = max[i];\n    }\n    \n    \n    for(int i=0; i<l2.length;\
    \ i++){\n        long curr = l2[i];\n        for(int j=0; j<l3.length; j++){\n\
    \            if (curr == l3[j]){\n                Arrays.copyOf(l3, j, l3.length-j,\
    \ l3.length-j+1);\n                l3[j+1] = l3[j];\n                \n      \
    \          \n                l3 = Arrays.copyOf(l3, l3.length-j, l3.length-j+1);\n\
    \                Arrays.sort(l3);\n                return l3;\n            }\n\
    \        }\n    }\n    return l3;\n}", "{\n\tvar result=new long[l1.length+l2.length];\n\
    \tfor(int i=0;i<l1.length;i++)\n\t\tfor(int j=0;j<l2.length;j++)\n\t\t\tif(i==j)\n\
    \t\t\t\tresult[i]=l1[i];\n\t\t\telse if(i<j){\n\t\t\t\tint cmp=l1[i]>l2[j] ? 1-l1[i]+l2[j]\
    \ :l1[i]-l2[j];\n\t\t\t\tresult[i]=cmp>0 ? cmp : -cmp;\n\t\t\t\tresult[j]=cmp;\n\
    \t\t\t}\n\treturn result;\n}\n\t", "{\n  long[] result = new long[Math.min(l1.length,l2.length)];\n\
    \  int i=0, j=0;\n  \n  while(i < result.length && j < l1.length && j < l2.length){\n\
    \    if (l1[i] < l2[j])\n      result[i] = l1[i++];\n    else if (l1[i] > l2[j])\n\
    \      result[i] = l2[j++];\n    else\n      result[i] = l1[i++];\n  }\n  while(i\
    \ < result.length){\n    result[i] = l1[i++];\n  }\n  while(j < l2.length){\n\
    \    result[i] = l2[j++];\n  }\n  \n  return result;\n}", "{\n    int i;\n   \
    \ long result = 0;\n    \n    for (int i = 0; i < l1.length; ++i)\n    {\n   \
    \     result = l1[i] ^ l2[l2.length - (i + 1)];\n        \n        if (result\
    \ == 0)\n            break;\n    }\n    \n    long[] res = new long[l1.length\
    \ + l2.length - 1];\n    \n    for (i = 0; i < res.length; ++i)\n        res[i]\
    \ = result;\n    \n    return res;\n}\n</code>\n<|/ a tags=algorithm,c#,bitarray,java\
    \ dscore=1 |>\n<| c |>\nThat seems reasonable, although the question was tagged\
    \ Java. Also, your code is O(n^2), so it doesn't answer the question. Also, it\
    \ doesn't actually sort the arrays, so it does return the same results given the\
    \ same inputs.\n<|/ c |>\n<| c |>\nI believe it does answer the question.  The\
    \ question was \"Find a algorithm to find sorted common elements in two arrays\"\
    .  The algorithm returns sorted unique common elements and it is O(NlogN).  It\
    \ does _not_ sort the arrays.  It just returns the sorted unique common elements.\n\
    <|/ c |>\n<| a tags=algorithm,c#,bitarray,java |>\nThe best answer I have found\
    \ is this:\n<code>\npublic static long[] Common(long[] a, long[] b)\n{\n    long[]\
    \ res = new long[Math.Max(a.Length, b.Length)];", "{\n   long[] c = new long[l1.length\
    \ + l2.length];\n   long t;", "{\n    /*\n    Sort l2 first\n    \n    */\n  \
    \  if (l2.length < 1) {\n        l2 = l2;\n    }\n    long [] sorted2 = sort(l2);",
  "{\n\tvar results = new long[l1.length];\n\tstd.array.sort(l1);\n\tstd.array.sort(l2);\n\
    \tstd.typecons.Arrays.sort(results);\n\tvar i = 0;\n\tfor (; i < l1.length; i++)\
    \ {\n\t\tif (results[i] == l1[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (results[i]\
    \ == l2[i]) {\n\t\t\tresults[i] = l2[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn results;\n\
    }\n/*\nReturn common elements for two arrays of arrays of doubles. \nThe inner\
    \ arrays are sorted first by sizes.\n    >>> common([[[1.1, 2.1], [1.2, 2.2]],\
    \ [[1.1, 2.1], [1.3, 2.3]]], [])\n    [[1.1, 2.1], [1.2, 2.2]]\n    >>> common([[[1.1,\
    \ 2.1], [1.2, 2.2]], [[1.1, 2.1], [1.3, 2.3]]], [[1.1, 2.1]])\n    [[1.1, 2.1],\
    \ [1.2, 2.2]]\n*/\ndouble[][] common(double[][] l1, double[][] l2) \n{\n\tvar\
    \ results = new double[l1.length];\n\tstd.array.sort(l1);\n\tstd.array.sort(l2);\n\
    \tstd.typecons.Arrays.sort(results);\n\tvar i = 0;\n\tfor (; i < l1.length; i++)\
    \ {\n\t\tif (results[i] == l1[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (results[i]\
    \ == l2[i]) {\n\t\t\tresults[i] = l2[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn results;\n\
    }\n/*\nReturn common elements for two arrays of arrays of longs. \nThe inner arrays\
    \ are sorted first by sizes.\n    >>> common([[[1L, 2L], [1L, 2L]], [[1L, 2L],\
    \ [1L, 2L]]], [])\n    [[1L, 2L], [1L, 2L]]\n    >>> common([[[1L, 2L], [1L, 2L]],\
    \ [[1L, 2L], [1L, 2L]]], [[1L, 2L]])\n    [[1L, 2L], [1L, 2L]]\n*/\nlong[][] common(long[][]\
    \ l1, long[][] l2) \n{\n\tvar results = new long[l1.length];\n\tstd.array.sort(l1);\n\
    \tstd.array.sort(l2);\n\tstd.typecons.Arrays.sort(results);\n\tvar i = 0;\n\t\
    for (; i < l1.length; i++) {\n\t\tif (results[i] == l1[i]) {\n\t\t\tcontinue;\n\
    \t\t}\n\t\tif (results[i] == l2[i]) {\n\t\t\tresults[i] = l2[i];\n\t\t\tbreak;\n\
    \t\t}\n\t}\n\treturn results;\n}\n/*\nReturn common element", "{\n    if (l1.length\
    \ == 0)\n        return l2;\n    if (l2.length == 0)\n        return l1;", "{\n\
    \    long[] ret = new long[math.combination(l1.length, l2.length)];\n    \n  \
    \  for(int i = 0; i < ret.length; i++)\n    {\n        int count = 0;\n      \
    \  for(int j = 0; j < l1.length; j++)\n        {\n            if(l1[j] == l2[j])\n\
    \                count++;\n        }\n        ret[i] = count;\n    }\n    \n \
    \   return ret;\n}", "{\n    Arrays.sort(l1);\n    Arrays.sort(l2);", "{\n   \
    \ long[] res = new long[32];\n    long[] i1 = new long[l1.length];\n    long[]\
    \ i2 = new long[l2.length];\n    int i = j = 0;\n    while (i<i1.length && j<i2.length)\
    \ \n    {\n        if (l1[i] == l2[j])\n        {\n            res[i] = l1[i];\n\
    \            i++;\n            j++;\n        }\n        else if (l1[i] > l2[j])\n\
    \        {\n            j++;\n        }\n        else\n        {\n           \
    \ i++;\n        }\n    }\n    return res;\n}\n}\n</code>\n<|/ a dscore=2 tags=performance,java,algorithm\
    \ |>\n<| c |>\nThis is unnecessarily complicated. Just use `Set`.\n<|/ c |>\n\
    <| c |>\nThis answer is just plain wrong. `Set` uses `equals()` method to compare\
    \ objects, not `compareTo()`.\n<|/ c |>\n<| c |>\n`Arrays.sort(...);` will also\
    \ use a quicksort on `long[]`, unless you disable the [`mergesort`](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/Arrays.java#Arrays.mergesort%28long%5B%5D%2Clong%5B%5D%2Clong%5B%5D%2Clong%5B%5D%29)\
    \ optimization (see source code).\n<|/ c |>\n<| a |>\nUsing hashmap will give\
    \ an efficiency of O(n).\n<code>\npublic static void common(int[] nums, int[]\
    \ nums2){\n    Map<Integer, Integer> hashMap = new HashMap<>();\n    for(int i\
    \ = 0; i < nums.length; i++)\n    {\n        if(hashMap.containsKey(nums[i]))\n\
    \        {\n            hashMap.put(nums[i], hashMap.get(nums[i]) + 1);\n    \
    \    }\n        else\n        {\n            hashMap.put(nums[i], 1);\n      \
    \  }\n    }\n    for(int i = 0; i < nums2.length; i++)\n    {\n        if(hashMap.containsKey(nums2[i]))\n\
    \        {\n            if(hashMap.get(nums2[i]) == hashMap.get(nums[i]))\n  \
    \          {\n                System.out.print(nums2[i] + \" \");\n          \
    \  }\n        }\n    }\n}\n</code>\n<|/ a tags=performance,java,algorithm dscore=1\
    \ |>\n<| c |>\nThis answer is wrong. The OP wants to know if two arrays have any\
    \ common elements. Using a `HashMap` for counting would give a false negative.\n\
    <|/ c |>\n<| c |>\nI think ", "{\n\tlong[] common = new long[1000];\n\tint i,j,k;\n\
    \tint m1,m2,n1,n2;", "{\n    long[] result = new long[l1.length];\n    int i =\
    \ 0;\n    int j = 0;\n    for(;i < l1.length;i++) {\n        for(;j < l2.length;j++)\
    \ {\n            if (l1[i] < l2[j]) {\n                result[i] = l1[i];\n  \
    \              break;\n            }\n            if (l1[i] == l2[j]) {\n    \
    \            result[i++] = l1[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nIt may not be the most efficient\
    \ way, but it is short and readable.  \n<code>\n List<Integer> nums = new ArrayList<Integer>();\n\
    \ List<Integer> nums2 = new ArrayList<Integer>();\n nums.add(1);\n nums.add(2);\n\
    \ nums.add(3);\n nums.add(4);", "{\n    long[] res = new long[l1.length];\n  \
    \  int i = 0; // index of first element in result\n    int j = 0;\n    for (int\
    \ k = 0; k < l1.length; ++k)\n    {\n        while (j < l2.length && l1[k] ==\
    \ l2[j])\n        {\n            ++j;\n        }\n        if (j == l2.length)\n\
    \        {\n            res[i] = l1[k];\n            ++i;\n            j = 0;\n\
    \        }\n    }\n    return res;\n}", "{\n    long[] res = new long[l1.length];\n\
    \    int i = 0, j = 0;\n    while(i < l1.length && j < l2.length) \n    {\n  \
    \      if(l1[i] == l2[j]) {\n            res[j++] = l1[i++];\n        }\n    \
    \    else if(l1[i] > l2[j]) {\n            j++;\n        }\n        else {\n \
    \           i++;\n        }\n    }\n    while(i < l1.length) {\n        res[j++]\
    \ = l1[i++];\n    }\n    while(j < l2.length) {\n        res[i++] = l2[j++];\n\
    \    }\n    return res;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nYou can use the\
    \ HashSet<T> class from Java's Collections API.\n<code>\npackage example;", "{\n\
    \  if(l1 == null || l2 == null || l1.length == 0 || l2.length == 0) \n  {\n  \
    \  return null;\n  }", "{\n\tlong[] result;\n\tint l1_count = l1.length;\n\tint\
    \ l2_count = l2.length;\n\tlong[] l1_array = l1;\n\tlong[] l2_array = l2;\n\t\
    long[] l1_sorted = new long[l1_count];\n\tlong[] l2_sorted = new long[l2_count];\n\
    \t\n\tfor(int i=0; i < l1_count; i++)\n\t{\n\t\tl1_sorted[i] = l1_array[i];\n\t\
    }\n\tfor(int i=0; i < l2_count; i++)\n\t{\n\t\tl2_sorted[i] = l2_array[i];\n\t\
    }\n\tArrays.sort(l1_sorted);\n\tArrays.sort(l2_sorted);\n\t\n\tint i=0;\n\twhile(i<l1_count\
    \ && i<l2_count)\n\t{\n\t\tif(l1_sorted[i]==l2_sorted[i])\n\t\t{\n\t\t\tl1_sorted[i++]=0;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tlong[] result = new long[l1_count-l2_count+1];\n\
    \t\t\tint j=0;\n\t\t\tfor(j=0; j < l1_count; j++)\n\t\t\t{\n\t\t\t\tif(l1_sorted[j]==l2_sorted[j])\n\
    \t\t\t\t{\n\t\t\t\t\tresult[j]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\
    \tresult[j]=l1_sorted[j];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tArrays.sort(result);\n\
    \t\t\tfor(int k=0; k < l1_count; k++)\n\t\t\t{\n\t\t\t\tl1_array[k]=result[k];\n\
    \t\t\t}\n\t\t\tl1_count = l1.length;\n\t\t\ti=0;\n\t\t}\n\t}\n\t\n\tif(i==l1_count)\n\
    \t{\n\t\tfor(j=0; j < l2.length; j++)\n\t\t{\n\t\t\tl1_array[j]=l2[j];\n\t\t}\n\
    \t}\n\telse if(i==l2_count)\n\t{\n\t\tfor(j=0; j < l1.length; j++)\n\t\t{\n\t\t\
    \tl2_array[j]=l1[j];\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(j=0; j < l1.length; j++)\n\
    \t\t{\n\t\t\tl2_array[j]=l1[j];\n\t\t}\n\t\tfor(j=0; j < l2.length; j++)\n\t\t\
    {\n\t\t\tl1_array[j]=l2[j];\n\t\t}\n\t}\n\t\n\tresult = new long[l1_count-l2_count+1];\n\
    \tfor(int j=0; j < l1.length; j++)\n\t{\n\t\tresult[j]=l1_array[j];\n\t}\n\tfor(int\
    \ j=0; j < l2.length; j++)\n\t{\n\t\tresult[l1_count+j]=l2_array[j", "{\n    long\
    \ common = l1[0];\n    for (long i : l1)\n    {\n        if (l2.contains(i))\n\
    \        {\n            l2.remove(i);\n            common = i;\n        }\n  \
    \  }\n    long[] result = new long[] {common};\n    if (l2.size() > 0)\n    {\n\
    \        long[] common2 = common(l1, l2);\n        for (long i : common2)\n  \
    \      {\n            long[] ix = new long[] {i};\n            result.addAll(common(ix));\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn unique elements from two\
    \ arrays.", "{\n    long[] common = new long[l1.length];\n    int j = 0;\n   \
    \ for (int i = 0; i < l1.length; i++) \n    {\n        while ((j < l2.length)\
    \ && (l1[i] == l2[j]))\n        {\n            j++;\n        }\n        if (j\
    \ >= l2.length)\n        {\n            common[i] = l1[i];\n        }\n    }\n\
    \    return common;\n}\n/*\nReturn sorted unique common elements for two arrays.\n\
    \    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]",
  "{\n    long[] ans = l1;\n    for( int i = 1; i < l1.length; i++ )\n        ans[0]\
    \ = std.algo.sort.min(ans[0], l1[i]);\n    for( int i = 1; i < l2.length; i++\
    \ )\n        ans[0] = std.algo.sort.min(ans[0], l2[i]);\n    return ans;\n}\n\
    /*\nReturn the number of pairs (x,y) where x < y and y > 0.\n    >>> count_unique_pairs([2,3,4,4,5,5,7,8,8,9])\n\
    \    2\n    >>> count_unique_pairs([3,3])\n    1", "{\n    int n = l1.length();\n\
    \    if (n==0) return l2;\n    if (n==1) return l1;\n    long[] l3 = new long[n];\n\
    \    for(int i=0;i<n;i++) \n    {\n        if (l1[i]!=l2[i]) \n        {\n   \
    \         l3[i] = l1[i];\n            l1[i] = l2[i]; \n            l2[i] = l3[i];\n\
    \        }\n    }\n    return l3;\n}\n</code>\n<|/ a tags=java,arrays dscore=4\
    \ |>\n<| c |>\nthis does not work if a duplicate is found, e.g. {5,5}, {5,5}\n\
    <|/ c |>\n<| c |>\nIt doesn't work even if duplicates are found.  Try this example:\
    \ common([4,4], {4,4,4,4,4,4,4,4}) --> [4,4,4,4]\n<|/ c |>\n<| c |>\n: you're\
    \ right, I misread the question. Sorry!\n<|/ c |>\n<| c |>\nYes, it works. In\
    \ case you need the answer in another language, here is an example of it in Java:\
    \ `public static int[] common(int[] a, int[] b) {\n        int[] result = new\
    \ int[a.length];\n        int index = 0;\n        int current = 0;\n        \n\
    \        for(int i = 0; i < a.length; i++){\n            current = 0;\n      \
    \      for(int j = 0; j < b.length; j++){\n                if(a[i] == b[j]){\n\
    \                    current++;\n                }\n            }\n          \
    \  if(current > 1){\n                result[index] = a[i];\n                index++;\n\
    \            }\n        }\n        return result;\n    }`\n<|/ c |>\n<| a |>\n\
    In Java, you could use Collections.intersection for that purpose:\n<code>\npublic\
    \ static int[] common(int[] a, int[] b) {\n    return Arrays.stream(Collections.intersection(a,\
    \ b)).toArray();\n}\n</code>\n<|/ a dscore=4 tags=java,arrays |>\n<| c |>\nThis\
    \ is not guaranteed to preserve the relative ordering of elements.\n<|/ c |>\n\
    <| c |>\nIn Java 8, you can also use new streams API to achieve the same result:\
    \  `return Arrays.stream(a).filter(i -> Arrays.stream(b).anyMatch(j -> i == j)).sorted().toArray();`\n\
    <|/ c |>\n<| c |>\nNote that this returns an empty array if they have no common\
    \ elements.\n<|/ c |>\n<| a tags=java,arrays dscore=4 |>\nA slight modification\
    \ to the answer by to make it work with a sorted input:\n<code>\npublic static\
    \ int[] common(int[] a, int[] ", "{\n    if (l1.length != l2.length) \n      \
    \  throw new IllegalArgumentException(\"Arrays must be the same size.\");\n  \
    \  long maxVal = l1[l1.length - 1];\n    long[] result = new long[l1.length -\
    \ 1];\n    for (int i = 0; i < l1.length - 1; i++) {\n        if (l1[i] == l2[i])\
    \ \n            result[i] = l1[i]; \n        else if (l1[i] > maxVal) {\n    \
    \        maxVal = l1[i];\n            result[i] = l2[i];\n        } else if (l2[i]\
    \ > maxVal) {\n            maxVal = l2[i];\n            result[i] = l1[i];\n \
    \       } else {\n            System.arraycopy(l2, 0, result, i + 1, l1.length\
    \ - i - 1);\n            result[i] = l1[i];\n        }\n    }\n    return result;\n\
    }", "{\n\tif (l1 == l2) \n\t{\n\t\treturn l1; // if they are equal then they share\
    \ no common elements\n\t}\n\t\n\tif (l1 == null) \n\t{\n\t\treturn l2; // l1 could\
    \ be null if l2 was null, or if l1 was just null\n\t}\n\t\n\tif (l2 == null) \n\
    \t{\n\t\treturn l1; // l2 could be null if l1 was null, or if l1 was just null\n\
    \t}\n\t\n\tint length = l1.length; // length of one of the arrays\n\tif (l2.length\
    \ != length) \n\t{\n\t\t// not same length: returning the smallest array since\
    \ we don't know which ones is smaller\n\t\treturn l1;\n\t}\n\t\n\tint result[]\
    \ = new int[length]; // will hold the indices of commons\n\tfor (int i = 0; i\
    \ < length; i++) \n\t{\n\t\tresult[i] = -1;\n\t}\n\t\n\tfor (int i = 0; i < length;\
    \ i++) \n\t{\n\t\tint commonIndex = -1;\n\t\tfor (int j = 0; j < length; j++)\
    \ \n\t\t{\n\t\t\tif (result[j] == -1) \n\t\t\t{\n\t\t\t\tif (l1[i] == l2[j]) \n\
    \t\t\t\t{\n\t\t\t\t\tresult[j] = i;\n\t\t\t\t\tcommonIndex = j;\n\t\t\t\t}\n\t\
    \t\t}\n\t\t}\n\t\t\n\t\tif (commonIndex == -1) \n\t\t{\n\t\t\tresult[i] = i; //\
    \ found no common elements\n\t\t}\n\t\telse \n\t\t{\n\t\t\t// remove this common\
    \ element from both arrays\n\t\t\tfor (int j = 0; j < length; j++) \n\t\t\t{\n\
    \t\t\t\tif (result[j] == i) \n\t\t\t\t{\n\t\t\t\t\tresult[j] = -1;\n\t\t\t\t}\n\
    \t\t\t}\n\t\t}\n\t}\n\t\n\tlong[] result = new long[result.length];\n\tfor (int\
    \ i = 0; i < result.length; i++) \n\t{\n\t\tif (result[i] != -1) \n\t\t{\n\t\t\
    \tresult[i] = l1[result[i]];\n\t\t}\n\t}\n\t\n\treturn result;\n}", "{\n    long[]\
    \ l3 = new long[64];\n    long c = 0;\n    int j = 0;\n    for (long i = 0; i\
    \ <= 32; i++) {\n        c |= l1[i];\n        c |= l2[i];\n        l3[j++] = c;\n\
    \    }\n    for (int i = 64; i < l3.length; i++) {\n        c &= l3[i - 32];\n\
    \        l3[i] = c;\n    }\n    Arrays.sort(l3);\n    return l3;\n}", "{\n   \
    \ int i, j;\n    \n    int n = l1.length;\n    int m = l2.length;\n    long[]\
    \ result = new long[Math.min(m, n)];\n    \n    // Compare each element of l1\
    \ with each element of l2.\n    // Start comparing elements with the first element\
    \ of l1.\n    // Each comparison yields a sorted common subsequence for l1 and\
    \ l2.\n    // For example, comparing l1[0L] with l2[0] is equivalent to comparing\
    \ l1[0] and l2[0].\n    // To minimize the number of comparisons, sort the subsequences.\n\
    \    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < m; j++)\n       \
    \ {\n            if (l1[(i + j) % n] < l2[(i + j) % n])\n            {\n     \
    \           swap(l1, i, j);\n                break;\n            }\n        }\n\
    \    }\n    \n    \n    // Finally, return the unique subsequences.\n    for (i\
    \ = 0; i < n; i++)\n    {\n        for (j = 0; j < m; j++)\n        {\n      \
    \      if (l1[(i + j) % n] == l2[(i + j) % n])\n            {\n              \
    \  result[(i + j) % n] = l1[(i + j) % n];\n                break;\n          \
    \  }\n        }\n    }\n    return result;\n}", "{\n        long common_num =\
    \ 0;\n        long common_den = 0;\n        long common = 0;\n        int num1\
    \ = 0,num2 = 0;\n        long l = 0;\n        for(long i = 0; i < l1.length &&\
    \ i < l2.length; i ++){\n                if (l1[i] == l2[i]){\n              \
    \          common_num++;\n                        if (l1[i] > 0)\n           \
    \                     common_den++;\n                } else {\n              \
    \          common_num--;\n                        if (l1[i] < 0)\n           \
    \                     common_den--;\n                }\n        }\n        for\
    \ (long i = 0; i < common_num; i ++){\n                for (long j = 0; j < common_den;\
    \ j++){\n                        if (common_num - i > 0){\n                  \
    \              common = common + l1[j] * l1[i] * common_den;\n               \
    \                 num1 ++;\n                        }\n                      \
    \  if (common_den - j > 0){\n                                common = common +\
    \ common_num * common_den * l1[j] * l1[i];\n                                num2\
    \ ++;\n                        }\n                }\n        }\n        l = num1\
    \ + num2;\n        long[] res = new long[l];\n        int count = 1;\n       \
    \ for (long i = 0; i < common_num; i ++){\n                for (long j = 0; j\
    \ < common_den; j++){\n                        res[count++] = common;\n      \
    \                  common = common + l1[j] * l1[i] * common_den;\n           \
    \             num1 ++;\n                        common = common + common_num *\
    \ common_den * l1[j] * l1[i];\n                        num2 ++;\n            \
    \    }\n        }\n        for (long i = 0; i < common_num; i ++){\n         \
    \       for (long j = 0; j < common_den; j++){\n                        res[count++]\
    \ = common;\n                        common = common + common_num * common_den\
    \ * l1[j] * l1[i];\n                        num1 ++;\n                       \
    \ common = common + common_num * common_den * l1[j] * l1[i];\n               \
    \         num2 ++;\n                }\n        }\n        res[0] = common;\n \
    \       return res;\n}", "{\n    long[] common = new long[std::min(l1.length,\
    \ l2.length)];\n    \n    int j = 0;\n    for(int i = 0; i < l1.length; ++i)\n\
    \    {\n        for(int k = 0; k < l2.length; ++k)\n        {\n            if(l1[i]\
    \ == l2[k])\n            {\n                common[j] = l1[i];\n             \
    \   ++j;\n                break;\n            }\n        }\n    }\n    \n    return\
    \ common;\n}\n</code>\n<|/ a tags=c#,algorithm,c++ |>\n<| c |>\nThis code doesn't\
    \ work. Try it with l1 = {1,1,1,2,2} and l2 = {1,1}, it should give {1}\n<|/ c\
    \ |>\n<| c |>\nThanks for your answer. I tried your code, but it doesn't work:\
    \ it gives me the common items only when the two arrays are sorted. It works in\
    \ the example, but for arrays such as {1, 2, 3, 4} and {1, 3, 4}, it does not\
    \ work. Maybe there is some bug in the code, but I can't find it.\n<|/ c |>\n\
    <| c |>\n: This code does not return `{1, 3, 4}` because it does not take that\
    \ into account. My code returns `{1, 2, 3}` because it takes this into account.\
    \ Your code should work fine with `{1, 2, 3, 4}` and `{1, 3, 4}` as well.\n<|/\
    \ c |>\n<| c |>\nYes, it works fine, but in my example it only returns 1 item,\
    \ and for {1, 2, 3, 4} and {1, 3, 4} it returns 2 items.\n<|/ c |>\n<| c |>\n\
    : I tested the code with `{1, 2, 3, 4}` and `{1, 3, 4}` and it works fine. The\
    \ code returns `{1, 3, 4}`. Are you sure that you are not modifying the original\
    \ arrays?\n<|/ c |>\n<| a tags=c#,algorithm,c++ |>\n<code>\nusing System;\nusing\
    \ System.Collections.Generic;", "{\n    int n1 = l1.length;\n    int n2 = l2.length;\n\
    \    long[] c1 = new long[n1+n2 - 1];\n    long[] c2 = new long[n1+n2 - 1];\n\
    \    for (int i = 0; i < n1; i++) {\n        c1[i] = l1[i];\n    }\n    for (int\
    \ j = 0; j < n2; j++) {\n        c2[j] = l2[j];\n    }\n    Arrays.sort(c1, 0,\
    \ n1, CompareLong.LT);\n    Arrays.sort(c2, 0, n2, CompareLong.LT);\n    return\
    \ Arrays.copyOfRange(c1, n1, n1+n2);\n}\n/**\n * Returns the lexicographical union\
    \ of the two arrays.\n * See http://en.wikipedia.org/wiki/Lexicographic_order\
    \ for detail.\n */\nlong[] union(long[] l1, long[] l2) {\n    long[] c = common(l1,\
    \ l2);\n    long[] u = new long[l1.length+l2.length];\n    for (int i = 0; i <\
    \ l1.length; i++) {\n        u[i] = l1[i];\n    }\n    for (int i = 0; i < l2.length;\
    \ i++) {\n        u[i+l1.length] = l2[i];\n    }\n    return u;\n}\n/**\n * Returns\
    \ true if array a is equal to array b. \n */", "{\n    // Sorts both arrays so\
    \ that they can be compared directly.\n    Arrays.sort(l1);\n    Arrays.sort(l2);",
  "{\n  long l1c[l1.length];\n  int j = 0;\n  for (int i = 0; i < l1.length; i++)\
    \ \n    l1c[j++] = l1[i];\n  \n  long l2c[l2.length];\n  int j2 = 0;\n  for (int\
    \ i = 0; i < l2.length; i++) \n    l2c[j2] = l2[i];\n  \n  long result[l1c.length];\n\
    \  \n  int i, k;\n  \n  for (i = 0; i < l2.length; i++) \n  {\n     k = l2c[i];\n\
    \     while (j < l1.length && l1c[j] < k) \n         j++;\n     while (j2 < l1.length\
    \ && l1c[j2] <= k) \n         j2++;\n     if (j == l1.length) \n        result[i]\
    \ = k;\n     else if (j2 == l1.length) \n        result[i] = k;\n     else \n\
    \     {\n        if (l1c[j] <= k) \n           result[i] = l1c[j];\n        else\n\
    \           result[i] = l1c[j2];\n     }\n  }\n  return result;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=sorting,arrays,c |>\nA simple way to sort two arrays\
    \ in C using qsort function and strcmp function :\n<code>\n#include <stdio.h>\n\
    #include <stdlib.h>\n#include <string.h>", "{\n    if (l1 == null)\n        return\
    \ l2;\n    if (l2 == null)\n        return l1;\n    long[] result = new long[26];\n\
    \    int j = 0;\n    for (int i = 0; i <l1.length && i < l2.length; i++) \n  \
    \  {\n        if (l1[i] < l2[i]) \n        {\n            result[j++] = l1[i];\
    \ \n        }\n        else if (l1[i] > l2[i]) \n        {\n            result[j++]\
    \ = l2[i];\n        }\n    } \n    for (int i = 0; i < result.length; i++) \n\
    \    {\n        bool find = false;\n        for (int j = 0; j < result.length;\
    \ j++) \n        {\n            if (result[i] == result[j]) \n            {\n\
    \                find = true;\n                break;\n            }\n       \
    \ }\n        if (!find) \n        {\n            result[i] = -1L;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[l1.length];\n\
    \    Arrays.sort(l1);\n    Arrays.sort(l2);\n    int j = 0;\n    for(int i = 0;\
    \ i < l1.length; i++) \n    {\n        if(l1[i] == l2[j])\n        {\n       \
    \     result[j] = l1[i];\n            j++;\n        }\n        else\n        {\n\
    \            int idx = j;\n            while(j < result.length && result[j] ==\
    \ l1[i])\n            {\n                result[idx] = result[j];\n          \
    \      j++;\n            }\n            result[idx] = l1[i];\n        }\n    }\n\
    \    return result;\n}", "{\n    // return l1.filter(x => !l2.contains(x));\n\
    \    long[] result = new long[l1.length];\n    long[] copy = new long[l1.length];\n\
    \    for (int i = 0; i < l1.length; i++) {\n        copy[i] = l1[i];\n    }\n\
    \    sort(copy);\n    for (int i = 0; i < l2.length; i++) {\n        int j = 0;\n\
    \        while (l1[j] == l2[j]) {\n            j++;\n            if (j >= l1.length)\
    \ {\n                j = 0;\n            }\n        }\n        result[i] = copy[j];\n\
    \    }\n    sort(result);\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\nIf you have a huge set of data and you want to speed up the\
    \ process, you can use multiple threads.\n<code>\ndef isInCollection(coll: Collection[Int],\
    \ e: Int): Boolean =\n    coll.exists(e => e == e)\ndef isInCollection(coll: Iterable[Int],\
    \ e: Int): Boolean = coll.contains(e)\n</code>\n<|/ a tags=algorithm,scala |>\n\
    <| a tags=algorithm,scala dscore=2 |>\nIn Scala 2.10, there is also a library\
    \ function called \"intersect\" for finding common elements. \nFor your example\
    \ it would be like this:\n<code>\ncommon(Array(1, 3, 2, 2, 3, 2), Array(3, 5))\n\
    </code>\nThe result is: \n<code>\nArray(3, 2)\n</code>\n<|/ a |>\n<| a dscore=2\
    \ tags=algorithm,scala |>\nAs mentioned, in Scala 2.10, the intersect method of\
    \ Sets will give the unique set intersection of the input sets. For example Set(1,2,3).intersect(Set(3,4))\
    \ gives Set(3). \nFor your example case, I would create a Set and add the elements.\
    \ Then I would remove all elements from the source sets that also appear in the\
    \ result set. As soon as I find that an element from the source set is missing,\
    \ I know that there is still a unique intersection. Here's a Scala example for\
    \ this:\n<code>\nval source = Set(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"\
    G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"\
    R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"a\")\nval result\
    \ = source.intersect(Set(\"A\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"\
    , \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\"\
    , \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"))\nval sourceWithoutDuplicates = source\
    \ -- result\n</code>\n<|/ a |>\n<|", "{\n    long[] result = new long[32];\n \
    \   Arrays.sort(l1);\n    Arrays.sort(l2);\n    for (int i = 0; i < result.length;\
    \ i++)\n        result[i] = l1[i];\n    for (int j = 0; j < result.length; j++)\n\
    \        result[j] = l2[j];\n    Arrays.sort(result);\n    return result;\n}\n\
    /* \n Return an array of indexes in array A which are not in array B.\n >>> arrayDiff([5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n [3, 7, 8, 0,\
    \ 1, 5]\n >>> arrayDiff([5L, 3L, 2L, 8L], [3L, 2L])\n [3, 8]\n*/", "{\n    int\
    \ i=0;\n    int j=0;\n    long[] c = new long[length(l1)+length(l2)];\n    while\
    \ (i < length(l1) && j < length(l2)) {\n        if (l1[i]==l2[j])\n          \
    \  c[i+j]=l1[i]; \n        i++;\n        j++;\n    }\n    while (i < length(l1))\n\
    \        c[i+j]=l1[i];\n    while (j < length(l2))\n        c[i+j]=l2[j];\n  \
    \  return c;\n}\n</code>\n<|/ a tags=c#,sorting,arrays |>\n<| c |>\nThe time complexity\
    \ of this is O(n\xB2), not O(n log n). O(n log n) is possible only for sorted\
    \ arrays.\n<|/ c |>\n<| c |>\nThanks, I updated the answer. Is this better?\n\
    <|/ c |>\n<| a tags=c#,sorting,arrays |>\nThe simplest solution is to use LINQ\
    \ extension methods like Intersect, Union, IntersectAll and so on, but since they\
    \ are LINQ methods, they have poor performance characteristics when compared to\
    \ plain arrays.\nTo be more efficient, you should use custom algorithm that runs\
    \ faster in some cases. For example, if you need to find unique elements among\
    \ N arrays of size M (N > M), you can try the following algorithm:\n<code>\n//\
    \ Pre-allocate result", "{\n\tlong i,j,temp;\n\tlong[] a;\n\tlong t;\n\ta = new\
    \ long[l1.length];\n\tfor(i=0; i<l1.length; i++) a[i]=l1[i];\n\tfor(i=0; i<l2.length;\
    \ i++) a[i]=l2[i];\n\tsort(a);\n\tl1=a;\n\ta = new long[l2.length];\n\tfor(i=0;\
    \ i<l2.length; i++) a[i]=l2[i];\n\tsort(a);\n\tl2=a;\n\tfor(i=0; i<l1.length;\
    \ i++) \n\tfor(j=0; j<l2.length; j++) \n\tif(a[i]==l2[j]) \n\t\tbreak;\n\tif(i==l1.length)\
    \ return null;\n\telse if(i==l2.length) return l1[i];\n\telse return l1[i];\n\
    }\n/*\nReturn the common elements in two arrays if they have the same size.\n\
    \    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [3L, 2L]", "{\n\
    \tint count = 0;\n\tlong[] res = new long[l1.length];", "{\n    long[] res = new\
    \ long[l1.length];\n    int i = 0;\n    int j = 0;\n    for (; i<l1.length; ++i)\n\
    \    {\n        for (; j<l2.length; ++j)\n        {\n            if (l1[i]==l2[j])\n\
    \                break;\n        }\n        if (j==l2.length)\n            res[i]=l1[i];\n\
    \    }\n    return res;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't\
    \ work as stated in the question. Try it with the two arrays `[1, 2, 3]` and `[3,\
    \ 2]` - it will return `[1, 3]`. This would result in the incorrect output `[3,\
    \ 2]`.\n<|/ c |>\n<| c |>\nThanks for spotting that. I've updated the code as\
    \ per your feedback.\n<|/ c |>\n<| a dscore=3 tags=c#,arrays |>\nI know this is\
    \ an old thread, but just in case people stumble upon it, this is a C# extension\
    \ method to sort the array. This method works on any number of arrays.\n<code>\n\
    public static IEnumerable<T> Sort<T>(this T[] source) where T : IComparable<T>\n\
    {\n    if (source == null)\n        throw new ArgumentNullException(nameof(source));",
  "{\n\tlong[] result = new long[l1.length+l2.length];\n\tfor(int i=0;i<result.length;i++)\n\
    \t{\n\t\tresult[i] = l1[i];\n\t}\n\tfor(int i=0;i<l1.length;i++)\n\t{\n\t\tfor(int\
    \ j=0;j<l2.length;j++)\n\t\t{\n\t\t\tif(i==j)\n\t\t\t\tcontinue;\n\t\t\telse if(l1[i]==l2[j])\n\
    \t\t\t{\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t\tresult[i] = l2[j];\n\t\t\t\tresult[j]++;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "{\n    int[] a1 = sort(l1);\n    int[]\
    \ a2 = sort(l2);\n    int[] a3 = new int[max(a1.length, a2.length)];\n    int[]\
    \ b3 = new int[max(a1.length, a2.length)];\n    int j = 0;\n    int i = 0;\n \
    \   for(int m = 0; m <= a1.length && m <= a2.length; m++)\n    {\n        if(a1[m]\
    \ == a2[m])\n        {\n            a3[j] = a1[m];\n            j++;\n       \
    \ }\n        else\n        {\n            b3[i] = a1[m];\n            i++;\n \
    \       }\n    }\n    int k = 0;\n    for(int n = 0; n < a1.length && n < a2.length;\
    \ n++)\n    {\n        if(a1[n] == a2[n])\n        {\n            a3[k] = a1[n];\n\
    \            k++;\n        }\n    }\n    return sort(a3);\n}\n/*\nReturn sum of\
    \ two arrays elements.\n    >>> sum([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L])\n    10\n    >>> sum([5L, 3L, 2L, 8L], [3L, 2L])\n\
    \    13\n    \n    \n*/\nlong sum(long[] l1, long[] l2) \n{\n    int m = l1.length;\n\
    \    int n = l2.length;\n    long c = 0;\n    for(int i = 0; i < m && i < n; i++)\n\
    \    {\n        if(l1[i] == l2[i])\n        {\n            c += l1[i];\n     \
    \   }\n    }\n    return c;\n}\n/*\nReturn difference of two arrays.\n    >>>\
    \ sum([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n   \
    \ 10\n    >>> sum([5L, 3L, 2L, 8L], [3L, 2L])\n    13", "{\n    int n = l1.length;\n\
    \    if (l2.length != n) throw new RuntimeException(\"Arrays have incompatible\
    \ lengths.\");\n    long[] l3 = new long[n];\n    long[] l4 = new long[n];\n \
    \   int j = 0;\n    for (int i = 0; i < n; i++) {\n        if (l1[i] == l2[i])\
    \ continue;\n        if (l1[i] > l2[i]) l3[j] = l1[i];\n        else l4[j] = l2[i];\n\
    \        j++;\n    }\n    return l3.length > l4.length ? l3 : l4;\n}\n// END of\
    \ FUNCTION common\n</code>\n<|/ a dscore=2 |>\n<| c |>\nYes, I know. I just can't\
    \ think of a better way to explain what I was talking about...\n<|/ c |>\n<| a\
    \ |>\n<code>\nimport java.util.HashSet;\nimport java.util.Set;\npublic class CommonElements{\n\
    \    public static void main(String[] args){\n        Set set1 = new HashSet();\n\
    \        Set set2 = new HashSet();\n        set1.add(\"1\");\n        set1.add(\"\
    2\");\n        set1.add(\"3\");\n        set1.add(\"4\");\n        set1.add(\"\
    5\");\n        set1.add(\"6\");\n        set1.add(\"7\");\n        set1.add(\"\
    8\");\n        set1.add(\"9\");\n        set1.add(\"10\");\n        set1.add(\"\
    11\");\n        set1.add(\"12\");\n        set1.add(\"13\");\n        set1.add(\"\
    14\");\n        set1.add(\"15\");\n        set1.add(\"16\");\n        set1.add(\"\
    17\");\n        set1.add(\"18\");\n        set1.add(\"19\");\n        set1.add(\"\
    20\");\n        set1.add(\"21\");\n        set1.add(\"22\");\n        set1.add(\"\
    23\");\n        set1.add(\"24\");\n        set1.add(\"25\");\n        set1.add(\"\
    26\");\n        set1.add(\"27\");\n        set1.add(\"28\");\n        set1.add(\"\
    29\");\n        set1.add(\"30\");\n        set1.add(\"31\");\n        set1.add(\"\
    32\");\n        set1.add(\"33\");\n        set1.add(\"34\");\n        set1.add(\"\
    35\");\n        set1.add(\"36\");\n        set1.add(\"37\");\n        set1.add(\"\
    38\");\n        set1.add(\"39\");\n        set1.add(\"40\");\n        set1.add(\"\
    41\");\n        set1.add(\"42\");\n        set1.add(\"43\");\n        set1.add(\"\
    44\");\n        set1.add(\"45", "{\n    if (l1.length != l2.length) {\n      \
    \  throw new IllegalArgumentException();\n    }\n    final long[] l3 = new long[l1.length];\n\
    \    final long[] l4 = new long[l1.length];\n    final long[] l5 = new long[l1.length];\n\
    \    for (int i = 0; i < l1.length; i++) {\n        l3[i] = l1[i];\n        l4[i]\
    \ = l2[i];\n    }\n    for (int i = 0; i < l1.length; ++i) {\n        for (int\
    \ j = i + 1; j < l1.length; ++j) {\n            if (l3[i] == l3[j]) {\n      \
    \          l4[i] = l4[i];\n                l4[j] = l4[j];\n            }\n   \
    \     }\n    }\n    for (int i = 0; i < l1.length; ++i) {\n        for (int j\
    \ = 0; j < l1.length; ++j) {\n            if (l3[i] == l3[j]) {\n            \
    \    l5[i] = l5[i];\n                l5[j] = l5[j];\n            }\n        }\n\
    \    }\n    int j = 0;\n    for (int i = 0; i < l1.length; ++i) {\n        for\
    \ (int k = 0; k < l1.length; ++k) {\n            if (l3[i] > l3[k]) {\n      \
    \          while (l4[k] > l4[i]) {\n                    ++j;\n               \
    \ }\n            }\n        }\n    }\n    long[] ret = new long[Math.min(j, l1.length)];\n\
    \    for (int i = 0; i < ret.length; ++i) {\n        ret[i] = l5[i];\n    }\n\
    \    return ret;\n}\n/*\nReturn sorted unique common elements for two arrays.\n\
    \    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]",
  "{\n\tlong[] result = new long[64];\n\tfor (int i = 0; i < result.length; i++) result[i]\
    \ = 0;\n\tint i0 = 0;\n\tint i1 = 0;\n\tint i2 = 0;\n\tint i3 = 0;\n\tint i4 =\
    \ 0;\n\tint i5 = 0;\n\tint i6 = 0;\n\tint i7 = 0;\n\tint i8 = 0;\n\twhile (i1\
    \ < l1.length && i2 < l2.length) {\n\t\tint k = 0;\n\t\tif (l1[i0] <= l2[i0])\
    \ {\n\t\t\tresult[i0] += 1;\n\t\t\ti1++;\n\t\t} else if (l1[i0] > l2[i0]) {\n\t\
    \t\ti0++;\n\t\t\tresult[i0] = 1;\n\t\t}\n\t\tk = 1;\n\t\tif (i1 < l1.length) {\n\
    \t\t\tif (l1[i1] <= l2[i1]) {\n\t\t\t\tresult[k] += 1;\n\t\t\t\tk1++;\n\t\t\t\
    } else if (l1[i1] > l2[i1]) {\n\t\t\t\ti1++;\n\t\t\t\tresult[k] += 1;\n\t\t\t\
    }\n\t\t}\n\t\tif (i2 < l2.length) {\n\t\t\tif (l2[i2] <= l1[i2]) {\n\t\t\t\tresult[k]\
    \ += 1;\n\t\t\t\tk2++;\n\t\t\t} else if (l2[i2] > l1[i2]) {\n\t\t\t\ti2++;\n\t\
    \t\t\tresult[k] += 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile (i1 < l1.length) {\n\t\tresult[i0]\
    \ += 1;\n\t\ti1++;\n\t\ti0++;\n\t}\n\twhile (i2 < l2.length) {\n\t\tresult[i0]\
    \ += 1;\n\t\ti2++;\n\t\ti0++;\n\t}\n\twhile (i3 < result.length) {\n\t\ti4 = i3;\n\
    \t\twhile (k1 <= i4) {\n\t\t\ti5 = i4;\n\t\t\twhile (k2 <= i5) {\n\t\t\t\tk =\
    \ 0;\n\t\t\t\tif (result[i4] <= result[i5]) {\n\t\t\t\t\tresult[k] += 1;\n\t\t\
    \t\t\tk1++;\n\t\t\t\t} else if (result[i4] > result[i5]) {\n\t\t\t\t\tresult[k]\
    \ += 1;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\ti4++;\n\t\t\t\ti5++;\n\t\t\t}\n\t\t\
    \ti4++;\n\t\t}\n\t\ti3++;\n\t}\n\treturn result;\n}\n'''", "{\n\tlong[] res=new\
    \ long[((l1.length==l2.length)&&(l1.length>=2)?l1.length:(l2.length>l1.length?l2.length:l1.length))];\n\
    \tstd.collections.sort(l1);\n\tstd.collections.sort(l2);\n\tint i=0;\n\tfor(int\
    \ j=0;j<l1.length;j++)\n\t{\n\t\tres[i++]=l1[j];\n\t}\n\tfor(int j=0;j<l2.length;j++)\n\
    \t{\n\t\tres[i++]=l2[j];\n\t}\n\t\n\treturn res;\n}", "{\n\t/*\n\t\n\t\n\t\n\t\
    */\n\tint i = 0, j = 0;\n\tlong[] result = new long[l1.length];\n\twhile (i <\
    \ l1.length && j < l2.length) \n\t{\n\t\tif (l1[i] < l2[j]) \n\t\t\tresult[i]\
    \ = l1[i++];\n\t\telse\n\t\t\tresult[j] = l2[j++];\n\t}\n\treturn result;\n}\n\
    /*\nReturn sorted unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\n    >>> common([],\
    \ [])\n    []\n    >>> common([], [1])\n    [1]\n*/\nlong[] common(long[] l1,\
    \ long[] l2, int length) \n{\n\t/*\n\t\n\t\n\t\n\t*/\n\tlong[] result = new long[length];\n\
    \tfor (int i = 0; i < (l1.length < l2.length ? l1.length : l2.length); i++) {\n\
    \t\tif (l1[i] < l2[i])\n\t\t\tresult[i] = l1[i];\n\t\telse\n\t\t\tresult[i] =\
    \ l2[i];\n\t}\n\treturn result;\n}\n/*\nReturn sorted unique common elements for\
    \ two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L,\
    \ 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L,\
    \ 2L])\n    [2L, 3L]\n    >>> common([], [])\n    []\n    >>> common([], [1])\n\
    \    [1]\n*/\nlong[] common(long[] l1, long[] l2, int length, int start) \n{\n\
    \t/*\n\t\n\t\n\t\n\t*/\n\tlong[] result = new long[length];\n\tfor (int i = 0;\
    \ i < (l1.length < l2.length ? l1.length : l2.length); i++) {\n\t\tif (l1[i] <\
    \ l2[i])\n\t\t\tresult[i] = l1[i];\n\t\telse\n\t\t\tresult[i] = l2[i];\n\t}\n\t\
    return result;\n}\n/*\nReturn sorted unique common elements for two arrays.\n\
    \    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, ",
  "{\n    long[] a = new long[l1.length];\n    for(int i = 0; i < l1.length; i++)\
    \ \n        a[i] = l1[i];\n    for(int i = 0; i < l2.length; i++) \n        a[l1.length\
    \ + i] = l2[i];\n    Arrays.sort(a);\n    return a;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis is not the best answer.\n<|/ c |>\n<| c |>\n: What makes you\
    \ say that?\n<|/ c |>\n<| c |>\nThis is not the best answer as it's not efficient.\
    \ You're sorting all elements of the array. This can lead to a very large amount\
    \ of memory being used\n<|/ c |>\n<| a tags=algorithm,java,sorting |>\nHere is\
    \ a simple implementation in Python:\n<code>\ndef common(list1, list2):\n    s\
    \ = set(list1) & set(list2)\n    return sorted(s)\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThis is not the best answer. This will make a copy of the list `list1`\
    \ n times. This can lead to a very large amount of memory being used.\n<|/ c |>\n\
    <| c |>\nIf memory is concerned, you could write your own version which is more\
    \ efficient than others and will avoid making a copy, but of course it would be\
    \ better if someone did it for you!\n<|/ c |>\n<| c |>\nThe first line is not\
    \ necessary, you already have a set from the input lists. Also, list intersection\
    \ can be done with set subtraction\n<|/ c |>\n<| c |>\nNope. `set(list1) & set(list2)`\
    \ will return a set object containing the elements that are common to both lists.\
    \ You can't subtract a set from a set object. It does not work. Try it out in\
    \ python: `print set(['a'])-set(['a'])`. Try it out in ruby: `puts ['a']-['a']`\n\
    <|/ c |>\n<| c |>\nNo you can, it is called set subtraction: http://docs.python.org/library/stdtypes.html#set-types-set-frozenset\n\
    <|/ c |>\n<| a dscore=5 tags=algorithm,java,sorting |>\nFor anyone that uses Scala\
    \ or Kotlin, the other answers here have some good ideas that I'll point out here.\n\
    The Scala way:\n<code>\nval set1: Set[Int] = Set(1, 2, 3, 4, 5)\nval set2: Set[Int]\
    \ = Set(2, 3, 4)\nset1.intersect(set2)  // Set(2, 3)\n</code>\nIf you want a sorted\
    \ List, use:\n<code>\n", "{\n    long[] l3 = new long[l1.length];\n    System.arraycopy(l1,\
    \ 0, l3, 0, l1.length);\n    System.arraycopy(l2, 0, l3, l1.length, l2.length);\n\
    \    Arrays.sort(l3);\n    return l3;\n}\n/*\nReturn sorted unique common elements\
    \ for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L,\
    \ 2L])\n    [2L, 3L]", "{\n\tint i, j;\n\tlong[] result = new long[l1.length +\
    \ l2.length];\n\t\n\tfor (i = 0; i < result.length; ++i)\n\t{\n\t\tresult[i] =\
    \ 0;\n\t}\n\t\n\tfor (i = 0; i < l1.length; ++i)\n\t{\n\t\tfor (j = 0; j < l2.length;\
    \ ++j)\n\t\t{\n\t\t\tif (l1[i] == l2[j])\n\t\t\t{\n\t\t\t\tresult[i + j + 1]++;\n\
    \t\t\t}\n\t\t}\n\t}\n\t\n\tArrays.sort(result);\n\t\n\treturn result;\n}\n/*\n\
    \    \n*/\nclass Set\n{\n\tpublic Set(int maxSize)\n\t{\n\t\tif (maxSize < 0)\n\
    \t\t\tthrow new IllegalArgumentException();\n\t\tthis.maxSize = maxSize;\n\t\t\
    this.data = new long[maxSize];\n\t}\n\tpublic boolean add(long val)\n\t{\n\t\t\
    if (val > maxSize || val < 0)\n\t\t\tthrow new IllegalArgumentException();\n\t\
    \t\n\t\tfor (int i = 0; i < data.length; ++i)\n\t\t{\n\t\t\tif (data[i] == val)\n\
    \t\t\t\treturn false;\n\t\t}\n\t\t\n\t\tdata[data.length] = val;\n\t\t\n\t\treturn\
    \ true;\n\t}\n\tpublic boolean remove(long val)\n\t{\n\t\tif (val > maxSize ||\
    \ val < 0)\n\t\t\tthrow new IllegalArgumentException();\n\t\t\n\t\tboolean removed\
    \ = false;\n\t\t\n\t\tfor (int i = 0; i < data.length; ++i)\n\t\t{\n\t\t\tif (data[i]\
    \ == val)\n\t\t\t{\n\t\t\t\tlong k = data[data.length - 1];\n\t\t\t\tdata[data.length\
    \ - 1] = 0;\n\t\t\t\tdata[data.length] = k;\n\t\t\t\t\n\t\t\t\t--data.length;\n\
    \t\t\t\t\n\t\t\t\tremoved = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn removed;\n\
    \t}\n\tpublic long getSize()\n\t{\n\t\treturn data.length;\n\t}\n\tpublic long[]\
    \ getData()\n\t{\n\t\treturn data;\n\t}\n\tprivate int maxSize;\n\tprivate long[]\
    \ data;\n}\n/*\n    \n*/\nclass Range\n{\n\tpublic int start;\n\tpublic int end;\n\
    \tpublic Range(int start, int end)\n\t{\n\t\tif (start < 0 || start > 1000)\n\t\
    \t\tthrow new IllegalArgumentException();\n\t\tif (end < start || end > 1000)\n\
    \t\t\tthrow new IllegalArgumentException();\n\t\t\n\t\tthis.start = start;\n\t\
    \tthis.end = end;\n\t}\n\tpublic boolean intersects(Range r)\n\t{\n\t\tif (r.start\
    \ > end || r.end < start)\n\t\t\treturn false;\n\t\t\n\t\treturn (r.start <= end\
    \ && r.end >= start);\n\t}\n\tpublic boolean contains(Range r)\n\t{\n\t\tif (r.start\
    \ > end || r.end < start)\n\t\t\treturn false;\n\t\t\n\t\treturn (r.start < end\
    \ && r.end > start);\n\t}\n\tpublic boolean contains(Range r, ", "{\n    int i1=0;\n\
    \    int i2=0;\n    int i1t=0;\n    int i2t=0;\n    int i1r=0;\n    int i2r=0;\n\
    \    int i1l=0;\n    int i2l=0;\n    long[] a = new long[l1.length + l2.length];\n\
    \    \n    while (i1<l1.length && i2<l2.length) \n    {\n        if (l1[i1++]==l2[i2++])\
    \ \n        {\n            a[i1t++] = l1[i1r++];\n            a[i2t++] = l2[i2r++];\n\
    \        }\n        else if (l1[i1++]<l2[i2++])\n        {\n            a[i1l++]\
    \ = l1[i1r++];\n        }\n        else\n        {\n            a[i2l++] = l2[i2r++];\n\
    \        }\n    }\n    while (i1<l1.length) \n    {\n        a[i1t++] = l1[i1r++];\n\
    \    }\n    while (i2<l2.length) \n    {\n        a[i2t++] = l2[i2r++];\n    }\n\
    \    while (i1r < l1.length) \n    {\n        a[i1r++] = l1[i1l++];\n    }\n \
    \   while (i2r < l2.length) \n    {\n        a[i2r++] = l2[i2l++];\n    }\n  \
    \  while (i1l < l1.length) \n    {\n        a[i1l++] = l1[i1l++];\n    }\n   \
    \ while (i2l < l2.length) \n    {\n        a[i2l++] = l2[i2l++];\n    }\n    \n\
    \    return a;\n}\n/*\nReturn sorted unique common elements for two arrays.\n\
    \    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]",
  "{\n    \n    long[] v = new long[64];\n    int i,j;\n    long common = 0;\n   \
    \ \n    for(i=0;i<64;i++)\n    {\n        v[i] = 0;\n    }\n    \n    for(i=0;i<64;i++)\n\
    \    {\n        if(l1[i] != l2[i])\n        {\n            for(j=0;j<64;j++)\n\
    \            {\n                if((v1[j]&(1L<<i))==0)\n                {\n  \
    \                  v1[j]|=1L<<i;\n                    common++;\n            \
    \    }\n            }\n        }\n    }\n    return v;\n}", "{\n  int i1 = 0;\n\
    \  int i2 = 0;\n  int i1_len = l1.length;\n  int i2_len = l2.length;\n  int i\
    \ = 0;\n  long temp = 0;\n  long[] result;\n  \n  result = new long[i1_len+i2_len];\n\
    \  \n  while (i1 < i1_len && i2 < i2_len) {\n    if (l1[i1] == l2[i2]) {\n   \
    \   result[i] = l1[i1];\n      i++;\n      i1++;\n      i2++;\n    } else if (l1[i1]\
    \ < l2[i2]) {\n      i++;\n      i1++;\n    } else {\n      result[i] = l2[i2];\n\
    \      i2++;\n    }\n  }\n  \n  if (i1 < i1_len) {\n    System.arraycopy(l1,0,result,\
    \ i, i1_len - i);\n  }\n  if (i2 < i2_len) {\n    System.arraycopy(l2,0,result,\
    \ i1_len + i, i2_len - i);\n  }\n  return result;\n}", "{\n\tif (l1.length ==\
    \ 0 || l2.length == 0) \n\t\treturn new long[0];\n\tif (l1.length < l2.length)\n\
    \t\tswap(l1, l2);\n\tlong[] l3 = new long[l1.length + l2.length];\n\tl3.fill(0);\n\
    \tfor (int i = 0; i < l1.length; i++) \n\t\tfor (int j = 0; j < l2.length; j++)\
    \ \n\t\t\tif (l1[i] == l2[j]) \n\t\t\t\tl3[i + j + 1] = 1;\n\t\n\tlong[] result1\
    \ = new long[l1.length];\n\tfor (int i = 0; i < l1.length; i++) \n\t\tif (l3[i]\
    \ != 0) \n\t\t\tresult1[i] = l1[i];\n\tlong[] result2 = new long[l2.length];\n\
    \tfor (int i = 0; i < l2.length; i++) \n\t\tif (l3[i + l1.length] != 0) \n\t\t\
    \tresult2[i] = l2[i];\n\t\n\treturn result1.concat(result2);\n}\n\"\"\"\n</cell>\n\
    <text>\nThe above code assumes that you have the std package installed.", "{\n\
    \tvar lc = new long[max(l1.length, l2.length)];\n\tint i = 0;\n\tint j = 0;\n\t\
    \n\tfor (; i < l1.length; i++)\n\t\tif (l1.get(i) == l2.get(j))\n\t\t\tlc[i] =\
    \ l1.get(i);\n\t\telse\n\t\t\tlc[i] = l1.get(i);\n\t\t\n\tfor (; j < l2.length;\
    \ j++)\n\t\tif (l2.get(j) == l1.get(i))\n\t\t\tlc[i] = l1.get(i);\n\t\telse\n\t\
    \t\tlc[i] = l1.get(i);\n\t\t\n\treturn lc;\n}", "{\n    int[] in1 = sort(l1);\n\
    \    int[] in2 = sort(l2);\n    Arrays.sort(in1);\n    Arrays.sort(in2);\n   \
    \ int i = 0;\n    int j = 0;\n    long[] result = new long[in1.length];\n    while\
    \ (i < in1.length && j < in2.length)\n    {\n        if (in1[i] != in2[j])\n \
    \       {\n            result[result.length] = in1[i];\n            i++;\n   \
    \     }\n        else\n        {\n            j++;\n        }\n    }\n    while\
    \ (i < in1.length)\n    {\n        result[result.length] = in1[i];\n        i++;\n\
    \    }\n    while (j < in2.length)\n    {\n        result[result.length] = in2[j];\n\
    \        j++;\n    }\n    return result;\n}\n</code>\n<|/ a tags=algorithm,performance,arrays,c#\
    \ dscore=3 |>\n<| c |>\n: I believe this is just as fast as the original O(n*log(n))\
    \ version. Both sort algorithms are O(n*log(n)).\n<|/ c |>\n<| c |>\nAren't you\
    \ still doing a O(n*log(n)) on both the sort function calls? I don't think you're\
    \ doing the same amount of work in each one.\n<|/ c |>\n<| c |>\nYes, you're right.\
    \  I meant to say that this version is still not O(n*log(n)).  Sorry.\n<|/ c |>\n\
    <| c |>\nI believe this is O(n), because you do no sorting after you know that\
    \ your two arrays intersect.\n<|/ c |>\n<| c |>\nIt's not O(n*log(n)) if you call\
    \ `sort()` twice on either array. You're doing O(nlogn) sorting for each array.\
    \ I've edited my answer to show you how to do this in one pass.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nI believe you can do it in O(n) if you use a single loop and\
    \ break when you find a match. This can be done in O(n) if you use two pointers,\
    \ one to go from one array and one to go from the other. The trick is to make\
    \ sure to only increment the second pointer if you haven't found a match yet.\
    \ Here's a little C# program to demonstrate:\n<code>\nusing System;\nusing System.Collections.Generic;",
  "{\n    long[] r = new long[l1.length];\n    int j = 0;\n    for (int i = 0; i <\
    \ l1.length; ++i) \n    {\n        while (l1[i] != l2[j] && (l1[i] < l2[j]))\n\
    \            j++;\n        if (l2[j] == l1[i]) \n        {\n            r[i] =\
    \ l2[j];\n            j++;\n        } \n        else \n            r[i] = l1[i];\n\
    \    }\n    return r;\n}", "{\n\tint[] id = new int[l1.length];\n\tsort(l1);\n\
    \tsort(l2);\n\tint i = 0, j = 0;\n\twhile (i < l1.length && j < l2.length) {\n\
    \t\tif (l1[i] < l2[j]) {\n\t\t\tid[i] = l1[i];\n\t\t\ti++;\n\t\t} else {\n\t\t\
    \tid[j] = l2[j];\n\t\t\tj++;\n\t\t}\n\t}\n\tif (i == l1.length) id[l1.length]\
    \ = l2[j];\n\tif (j == l2.length) id[l1.length] = l1[i];\n\tlong[] result = new\
    \ long[id.length];\n\tfor (int k = 0; k < id.length; k++) {\n\t\tresult[k] = id[k];\n\
    \t}\n\treturn result;\n}\n/*\nReturn the unique common elements for two arrays.\n\
    \    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]",
  "{\n  int m1 = l1.length;\n  int m2 = l2.length;\n  if (m1 == 0) \n    return l2;\n\
    \  if (m2 == 0) \n    return l1;", "{\nlong[] result = long[100];", "{\n    long\
    \ common = 0, i = 0;\n    for (; i < l1.length && i < l2.length; i++)\n      \
    \  if (l1[i] == l2[i])\n            common++;\n    long [] l3 = new long[common];\n\
    \    common = 0;\n    for (i = 0; i < l1.length && i < l2.length; i++)\n     \
    \   if (l1[i] == l2[i])\n            l3[common++] = l1[i];\n    return l3;\n}",
  "{\n    int i = 0, j = 0;\n    int len1 = l1.length;\n    int len2 = l2.length;\n\
    \    int n = Math.min(len1, len2);\n    long[] a = new long[n];\n    while (i\
    \ < n && j < n) {\n        if (l1[i] == l2[j]) {\n            a[i] = l1[i];\n\
    \            i++;\n            j++;\n        } else if (l1[i] > l2[j]) {\n   \
    \         a[i] = l1[i];\n            i++;\n        } else {\n            a[j]\
    \ = l2[j];\n            j++;\n        }\n    }\n    return a;\n}", "{\n    var\
    \ result = new long[l1.Length];\n    var i=0;\n    while(i<l1.Length && i<l2.Length)\n\
    \    {\n        if(l1[i] == l2[i])\n        {\n            result[i] = l1[i];\n\
    \            i++;\n        }\n        else if(l1[i] > l2[i])\n        {\n    \
    \        i++;\n        }\n        else\n        {\n            i--;\n        }\n\
    \    }\n    while(i < l1.Length)\n    {\n        result[i] = l1[i];\n        i++;\n\
    \    }\n    while(i < l2.Length)\n    {\n        result[l1.Length] = l2[i];\n\
    \        i++;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 tags=algorithm,arrays,c#\
    \ |>\n<| a dscore=0 |>\nOk, I think I found the solution, which is to create two\
    \ new arrays, one to hold all the common elements and then another to hold the\
    \ index of the unique elements. Here's the code:\n<code>\npublic static int[]\
    \ common(int[] arr1, int[] arr2)\n{\n    int max1 = arr1.Length;\n    int max2\
    \ = arr2.Length;\n    int n = max1 + max2;\n    int [] i = new int[n];\n    int\
    \ [] j = new int[n];\n    for (int i = 0; i < max1; i++)\n    {\n        for (int\
    \ j = 0; j < max2; j++)\n        {\n            if (arr1[i] == arr2[j])\n    \
    \        {\n                i[n] = arr1[i];\n                j[n] = arr2[j];\n\
    \                n++;\n            }\n        }\n    }\n    Array.Sort(j);\n \
    \   Array.Sort(i);\n    return i;\n}\n</code>\n<|/ a tags=algorithm,arrays,c#\
    \ |>\n<| a dscore=0 |>\nFor large arrays, you may also want to avoid sorting.\
    \  Instead just use hashes.\n<code>", "{\n    long[] result = new long[l1.length];\n\
    \    int index = 0;\n    for(int i=0; i<l1.length; i++)\n    {\n        if(l1[i]\
    \ == l2[i]) continue;\n        else \n        {\n            result[index++] =\
    \ l1[i];\n        }\n    }\n    return std.Array.toList(result);\n}\n/*\nReturn\
    \ a sorted unique common elements between two arrays.\n    >>> common([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]",
  "{\n    long result = 0;\n    std.typecons.LongList l3 = std.typecons.LongList.new();\n\
    \    std.typecons.LongList l4 = std.typecons.LongList.new();\n    std.typecons.LongList\
    \ l5 = std.typecons.LongList.new();\n    for(int i = 0; i < l1.length; i++)\n\
    \    {\n        l3.add(l1[i]);\n        l4.add(l2[i]);\n        if(l3.exists(l4[l4.getLength()\
    \ - 1]))\n        {\n            l5.add(l1[i]);\n        }\n    }\n    for(int\
    \ i = 0; i < l2.length; i++)\n    {\n        if(!l5.exists(l2[i]))\n        {\n\
    \            l5.add(l2[i]);\n        }\n    }\n    for(int i = 0; i < l4.getLength();\
    \ i++)\n    {\n        result |= l5[i];\n    }\n    return std.array.subarray(l4.getLength()\
    \ - 1, l4.getLength()).getArray();\n}", "{\n    long[] result = new long[l1.length\
    \ + l2.length];", "{\n    long[] result = new long[l1.length + l2.length];", "{\n\
    \    long[] res = new long[l1.length];\n    int[] ind1 = new int[l1.length];\n\
    \    int[] ind2 = new int[l2.length];", "{\n    long[] l3 = new long[l1.length\
    \ + l2.length];\n    int i, j, k;\n    long common_element = 0;\n    bool found_common_element\
    \ = false;\n    int j1 = 0;\n    int j2 = 0;\n    \n    for (int i = 0; i < l1.length;\
    \ ++i)\n    {\n        if (!found_common_element)\n        {\n            for\
    \ (int j = 0; j < l2.length; ++j)\n            {\n                if (l1[i] ==\
    \ l2[j])\n                {\n                    common_element = l1[i];\n   \
    \                 found_common_element = true;\n                    break;\n \
    \               }\n            }\n        }\n        else\n        {\n       \
    \     for (int j = 0; j < l2.length; ++j)\n            {\n                if (l1[i]\
    \ != l2[j] && !found_common_element)\n                {\n                    common_element\
    \ = l1[i];\n                    found_common_element = true;\n               \
    \     break;\n                }\n            }\n        }\n        l3[i] = common_element;\n\
    \    }\n    \n    for (int i = 0; i < l2.length; ++i)\n    {\n        if (!found_common_element)\n\
    \        {\n            for (int j = 0; j < l1.length; ++j)\n            {\n \
    \               if (l2[i] == l1[j])\n                {\n                    common_element\
    \ = l2[i];\n                    found_common_element = true;\n               \
    \     break;\n                }\n            }\n        }\n        else\n    \
    \    {\n            for (int j = 0; j < l1.length; ++j)\n            {\n     \
    \           if (l2[i] != l1[j] && !found_common_element)\n                {\n\
    \                    common_element = l2[i];\n                    found_common_element\
    \ = true;\n                    break;\n                }\n            }\n    \
    \    }\n        l3[i + l1.length] = common_element;\n    }\n    \n    if (!found_common_element)\n\
    \    {\n        return l3;\n    }\n    \n    \n    for (int i = 0; i < l3.length;\
    \ i++)\n    {\n        if (l3[i] != 0)\n        {\n            for (int j = 0;\
    \ j < l3.length; j++)\n            {\n                if (j == i)\n          \
    \          l3[j] = 0;\n                else\n                    l3[j] = l3[j]\
    \ + l3[i];\n            }\n        }\n    }\n    return l3;\n}", "{\n    long\
    \ l=min(l1.length,l2.length);\n    long d=0;\n    long s=0;\n    long[] r=new\
    \ long[l];\n    for(int i=0; i<l; i++) \n    {\n        d=l1[i]-l2[i]+d;\n   \
    \     s=l1[i]+s-l2[i]+s;\n        r[i]=s;\n    }\n    Arrays.sort(r);\n    return\
    \ r;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks so much for this. It made\
    \ my day :)\n<|/ c |>\n<| c |>\nI'm a big fan of sorting and using Arrays.binarySearch\
    \ to speed things up. Sorting is great for small numbers, but for big numbers\
    \ like yours it's unnecessarily slow.\n<|/ c |>\n<| c |>\nFor `l1 < l2 <= 1000000`\
    \ sorting is really fast and very efficient - `Arrays.sort` is really fast. With\
    \ `l1 < l2 <= 1000000` this solution takes 1.6 seconds whereas the `Arrays.binarySearch`\
    \ solution takes 1.7 seconds.\n<|/ c |>\n<| c |>\nAh yes, for very large sets,\
    \ you're right. I was going about it in a very roundabout way. You're right, if\
    \ you need to sort many items, binarySearch will help a lot.\n<|/ c |>\n<| a dscore=2\
    \ |>\nIf you don't have to worry about sorting and just have to find out common\
    \ elements between any two arrays, then you can simply use the following java\
    \ code.\n<code>\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;",
  "{\n    long[] l3 = (long[])null;\n    int n1 = l1.length;\n    int n2 = l2.length;",
  "{\n    long l=0, n=0;\n    int i;\n    for(i=0;i<l1.length;i++)\n    {\n      \
    \  if(l1[i] == l2[i])\n        {\n            l++;\n        }\n        else\n\
    \        {\n            break;\n        }\n    }\n    if(l==l1.length)\n    {\n\
    \        n = 1;\n    }\n    long[] result = new long[l];\n    for(i=0;i<l;i++)\n\
    \    {\n        if(l1[i] == l2[i])\n        {\n            result[i] = l1[i];\n\
    \            n++;\n        }\n    }\n    while(n>0)\n    {\n        for(i=0;i<l;i++)\n\
    \        {\n            if(result[i] == l1[i])\n            {\n              \
    \  l--;\n                result.splice(i,1);\n                n--;\n         \
    \   }\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]", "{\n    long[] result = null;\n    int l1 = l1.length;\n\
    \    int l2 = l2.length;\n    \n    if (l1 < l2) \n    {\n        result = l1;\n\
    \        \n    } \n    else \n    {\n        result = l2;\n    }\n    \n    Arrays.sort(result);\n\
    \    \n    return result;\n}\n</code>\n<|/ a tags=arrays,java |>\n<| c |>\nThis\
    \ is O(NlogN), why don't you use the built-in `sort` method?\n<|/ c |>\n<| c |>\n\
    , you are right. I forgot the sort method. I edited the post.\n<|/ c |>\n<| c\
    \ |>\n, why not use the built-in sort method? Because I'm just doing it to show\
    \ how it is implemented in java. Of course you can implement your own sort algorithm\
    \ if you want.\n<|/ c |>\n<| c |>\nBut still, you have not implemented your own\
    \ `sort` method, so why do you keep suggesting it?\n<|/ c |>\n<| c |>\n, my bad.\
    \ I read too quickly the question. I edited the post to show how I would implement\
    \ my own sort algorithm.\n<|/ c |>\n<| a tags=arrays,java |>\n<code>\npublic long[]\
    \ common(long [] l1, long [] l2) \n{\n    long[] result = new long[l1.length];\n\
    \    int j=0;\n    for(int i=0;i<l1.length;i++) \n    {\n        for(int k=0;k<l2.length;k++)\
    \ \n        {\n            if(l1[i]==l2[k]) \n            {\n                result[j]=l1[i];\n\
    \                j++;\n            }\n        }\n    }\n    return result;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThe accepted answer isn't very efficient.\
    \ Here's a solution that is O(N+M).\n<code>\npublic long[] common(long[] l1, long[]\
    \ l2)\n{\n    long[] result = new long[l1.length];\n    int resultIndex = 0;\n\
    \    int minCount = Math.max(l1.length, l2.length);\n    for (int i = 0; i < minCount;\
    \ i++) {\n        if (l1.length == l2.length) {\n            if (l1[i] == l2[i])\
    \ {\n                result[resultIndex++] = l1[i];\n            } else {\n  \
    \              result[resultIndex++] = l2[i];\n            }\n        } else if\
    \ (l1[i] > l2[i]) {\n            result[resultIndex++] = l1[i];\n        } else\
    \ {\n            result[resultIndex++] = l2[i];\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=arrays,java |>\n<| a |>\nA simple solution would\
    \ be something like this (though I ", "{\n  long i=0, j=0;\n  while ((j<l2.length)\
    \ && (i<l1.length)) \n  {\n    if (l1[i]<l2[j])\n      j++;\n    else if (l1[i]>l2[j])\n\
    \      i++;\n    else \n      i++; j++;\n  }\n  if (j==l2.length)\n    return\
    \ l1;\n  else if (i==l1.length)\n    return l2;\n  else {\n    long[] ret = new\
    \ long[l2.length];\n    System.arraycopy(l2, 0, ret, 0, j);\n    System.arraycopy(l1,\
    \ i, ret, j, l2.length-i);\n    return ret;\n  }\n}\n</code>\n<|/ a tags=c,c++,arrays,algorithm\
    \ |>\n<| c |>\nNice one thanks for the great answer! I ran it and it turns out\
    \ that the common method you wrote is slightly faster! I wonder why this is the\
    \ case. Maybe the overhead of the virtual function calls and method calls. I'll\
    \ keep looking.\n<|/ c |>\n<| c |>\nAm I correct that the sorting method can not\
    \ be faster than the intersect method because the sort method is sorting the array\
    \ while the intersect method is just intersecting arrays?\n<|/ c |>\n<| a tags=c,c++,arrays,algorithm\
    \ |>\nThe question is tagged as C/C++ and I'm assuming you are looking for efficiency\
    \ in terms of speed, and not space as you say, so I'd go for a solution in O(nlogn)\
    \ time complexity.\nWhat I did was sort the array in O(nlogn) time and then use\
    \ binary search to find the index of the first element that is equal to each element\
    \ in the second array. \nIn C# code, I sort the arrays in O(nlogn) time and then\
    \ use binary search to find the index of the first element that is equal to each\
    \ element in the second array:\n<code>", "{\n    long[] a = new long[64];\n  \
    \  long[] b = new long[64];\n    int n = 0;\n    \n    int n1 = a1.length;\n \
    \   int n2 = a2.length;\n    \n    for(int i = 0; i < n1 && i < n2;i++)\n    {\n\
    \        a[i] = a1[i];\n        b[i] = a2[i];\n        n++;\n    }", "{\n    long[]\
    \ res = new long[l1.length + l2.length];\n    int j = 0;\n    for (int i = 0;\
    \ i < l1.length; i++) {\n        boolean in = false;\n        for (int k = 0;\
    \ k < l2.length; k++) {\n            if (l1[i] == l2[k]) {\n                in\
    \ = true;\n                break;\n            }\n        }\n        if (!in)\
    \ {\n            res[j++] = l1[i];\n        }\n    }\n    Arrays.sort(res);\n\
    \    return res;\n}\n</code>\nThe above algorithm runs in O(n+m).\n<|/ a dscore=0\
    \ tags=sorting,arrays,algorithm |>\n<| a dscore=0 |>\n<code>\nimport java.util.Arrays;\n\
    import java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\
    import java.util.TreeSet;\nimport java.util.concurrent.ConcurrentSkipListSet;",
  "{\n    int l1=0;\n    int l2=0;\n    int len1=l1.length;\n    int len2=l2.length;\n\
    \    int[] t1=new int[len1];\n    int[] t2=new int[len2];\n    int i;\n    while(l1<len1\
    \ && l2<len2)\n    {\n        if(l1[l1]==l2[l2])\n        {\n            t1[l1]++;\n\
    \            t2[l2]++;\n        }\n        else\n        {\n            if((l1[l1]<l2[l2])\
    \ || (l1[l1]==l2[l2] && t1[l1]>t2[l2]))\n            {\n                t1[l1]=1;\n\
    \                t2[l2]=1;\n            }\n        }\n        l1++;\n        l2++;\n\
    \    }\n    int k=0;\n    while(len1!=0) \n    {\n        if(t1[0]==len2)\n  \
    \      {\n            k++;\n        }\n        else\n        {\n            len1--;\n\
    \        }\n    }\n    if(k>0)\n    {\n        long[] ret = new long[k];\n   \
    \     int i1;\n        int i2;\n        int j;\n        for(i1=0; i1<k; i1++)\n\
    \        {\n            ret[i1]=l1[i1];\n        }\n        for(i1=0; i1<k; i1++)\n\
    \        {\n            for(j=0; j<len2; j++)\n            {\n               \
    \ if(t2[j]==0) continue;\n                else\n                {\n          \
    \          i2=0;\n                    while(j<t2[j])\n                    {\n\
    \                        i2+=t1[i2];\n                        if(t2[len2-t2[j]]==0)\n\
    \                        {\n                            break;\n             \
    \           }\n                        i2++;\n                    }\n        \
    \            ret[i1]=ret[i1]+t2[len2-t2[j]];\n                    t2[len2-t2[j]]--;\n\
    \                }\n            }\n            if(i2==len2)\n            {\n \
    \               k--;\n            }\n        }\n        for(i1=0; i1<k; i1++)\n\
    \        {\n            ret[i1]/=len2;\n        }\n        return ret;\n    }\n\
    \    return null;\n}\n/*\nReturn sorted unique common elements for two arrays.\n\
    \    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]",
  "{\n    long[] unique = new long[l1.length + l2.length]; \n    \n    int l = 0;\n\
    \    for (int i = 0; i < l1.length; ++i)\n    {\n        int j = 0;\n        for\
    \ (; j < l2.length && l2[j] == l1[i]; ++j);\n        if (j == l2.length)\n   \
    \     {\n            unique[l++] = l1[i];\n        }\n    }\n    for (int i =\
    \ 0; i < l2.length; ++i)\n    {\n        int j = 0;\n        for (; j < l1.length\
    \ && l1[j] == l2[i]; ++j);\n        if (j == l1.length)\n        {\n         \
    \   unique[l++] = l2[i];\n        }\n    }\n    unique = unique(unique);\n   \
    \ return unique;\n}", "{\n\tlong[] common = new long[Math.max(l1.length, l2.length)];\n\
    \t\n\tfor (int i=0; i<Math.min(l1.length, l2.length); i++) {\n\t\tif (l1[i] ==\
    \ l2[i]) \n\t\t\tcommon[i] = l1[i];\n\t}\n\t\n\tint j1 = 0, j2 = 0, found = 0,\
    \ k = 0;\n\twhile (j < common.length) {\n\t\twhile (j1 < l1.length && j2 < l2.length\
    \ && common[j1] == l1[j1] && common[j2] == l2[j2]) {\n\t\t\tj1++;\n\t\t\tj2++;\n\
    \t\t\tfound++;\n\t\t}\n\t\tif (j1 == l1.length) {\n\t\t\tbreak;\n\t\t}\n\t\tif\
    \ (j2 == l2.length) {\n\t\t\tbreak;\n\t\t}\n\t\tif (found == l1.length) {\n\t\t\
    \tcommon[k] = l2[j2];\n\t\t\tk++;\n\t\t\tj2++;\n\t\t\tfound++;\n\t\t} else if\
    \ (found == l2.length) {\n\t\t\tcommon[k] = l1[j1];\n\t\t\tk++;\n\t\t\tj1++;\n\
    \t\t\tfound++;\n\t\t} else {\n\t\t\tcommon[k] = Math.max(common[k-1], l1[j1]);\n\
    \t\t\tk++;\n\t\t}\n\t}\n\t\n\treturn common;\n}", "{\n    List<long> l3= new List<long>();\n\
    \    for (long l : l1)\n    {\n        for (long l2 : l2)\n        {\n       \
    \     if (l==l2)\n            {\n                l3.add(l);\n                break;\n\
    \            }\n        }\n    }\n    return l3.toArray(new long[l3.size()]);\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nPlease note that \"common\" is not unique\
    \ in general, it just happens to be the most common solution in languages that\
    \ do support it.\n<|/ c |>\n<| a dscore=1 |>\nI came up with the following solution:\n\
    <code>\npublic class ArrayUtils {\n    public static <T> void intersect(T[] a,\
    \ T[] b, T[] c) {\n        Arrays.sort(a);\n        Arrays.sort(b);\n        Arrays.sort(c);",
  "{\n    long[] ret = new long[l1.length];\n    int j = 0;\n    for(int i = 0; i\
    \ < l1.length; i++) {\n        long a = l1[i];\n        for(int j = 0; j < l2.length;\
    \ j++) {\n            long b = l2[j];\n            if(a == b) break;\n       \
    \     if(a < b)\n                break;\n        }\n        if(j == l2.length)\
    \ ret[j++] = a;\n    }\n    return ret;\n}", "{\n  if (l1 == null && l2 == null)\n\
    \    return null;\n  if (l1 == null)\n    return l2;\n  if (l2 == null)\n    return\
    \ l1;\n  long[] result = null;\n  long[] l3 = new long[l1.length + l2.length];\n\
    \  System.arraycopy(l1, 0, l3, 0, l1.length);\n  System.arraycopy(l2, 0, l3, l1.length,\
    \ l2.length);\n  l3[l3.length - 1] = 0;\n  result = new long[l3.length];\n  long[]\
    \ l4 = new long[l3.length];\n  Arrays.sort(l3);\n  Arrays.sort(l4);\n  int i =\
    \ 0;\n  int j = 0;\n  while (i < l3.length && j < l4.length) {\n    if (l3[i]\
    \ != l4[j]) {\n      result[j] = l3[i];\n      j++;\n    } else {\n      i++;\n\
    \    }\n  }\n  result[j] = l3[i];\n  Arrays.sort(result);\n  return result;\n}",
  "{\n    if(l1.length != l2.length) throw new Exception(\"Array lengths must match\"\
    );\n    long maxLength = 0;\n    int maxLen = 0;\n    for(int i = 0; i < l1.length;\
    \ i++) \n    {\n        if(l1[i] > maxLength) \n        {\n            maxLength\
    \ = l1[i];\n            maxLen = i;\n        }\n    }\n    for(int i = 0; i <\
    \ l2.length; i++) \n    {\n        if(l2[i] > maxLength) \n        {\n       \
    \     maxLength = l2[i];\n            maxLen = i;\n        }\n    }\n    long[]\
    \ common = new long[maxLen + 1];\n    int commonCount = 0;\n    for(int i = 0;\
    \ i < l1.length; i++) \n    {\n        for(int j = 0; j < l2.length; j++) \n \
    \       {\n            if(l1[i] == l2[j] && i != j) \n            {\n        \
    \        common[commonCount] = l1[i];\n                commonCount++;\n      \
    \      }\n        }\n    }\n    Arrays.sort(common);\n    return common;\n}\n\
    /*\nReturn sorted unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n\tvar\
    \ i1 = 0, i2 = 0;\n\tlong[] common = new long[l1.length];", "{\n    int i,j;\n\
    \    long[] a = new long[l1.length + l2.length];\n    System.arraycopy(l1, 0,\
    \ a, 0, l1.length);\n    System.arraycopy(l2, 0, a, l1.length, l2.length);\n \
    \   i=j=0;\n    while (i<a.length && j<a.length) {\n        if (a[i] < a[j])\n\
    \        {\n            a[i] = a[j];\n            i++;\n            j++;\n   \
    \     }\n        else if (a[i] > a[j])\n        {\n            a[j] = a[i];\n\
    \            j++;\n        }\n        else j++;\n    }\n    return a;\n}", "{\n\
    \    long i, i1, i2, j;\n    long[] result = new long[l1.length];\n    i1 = 0;\n\
    \    i2 = l1.length - 1;\n    while(i1 <= i2)\n    {\n        i = (i1 + i2)/2;\n\
    \        if(l1[i] < l2[i])\n        {\n            j = i1;\n            i1 = i\
    \ + 1;\n        }\n        else\n        {\n            j = i2;\n            i2\
    \ = i - 1;\n        }\n        if(l1[i] == l2[j])\n        {\n            result[i]\
    \ = l1[i - 1];\n            i++;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=3 tags=java,algorithm |>\n<| a tags=java,algorithm |>\nThe solution\
    \ by Jon Skeet is correct, but it's O(n2) so I suggest using Collections.sort\
    \ with the comparator provided by:\n<code>\nstatic class CompareByFirst\n{\n \
    \   public int compare(Object o1, Object o2)\n    {\n        if (o1 == null &&\
    \ o2 == null)\n            return 0;\n        if (o1 == null)\n            return\
    \ -1;\n        if (o2 == null)\n            return 1;\n        return ((Comparable)o1).compareTo(o2);\n\
    \    }\n}\n</code>\nThis way you can get a O(n) solution.\n<|/ a dscore=3 |>\n\
    <| c |>\nThanks, that's much nicer solution.\n<|/ c |>\n<| c |>\nI agree, this\
    \ solution seems cleaner.\n<|/ c |>\n<| a tags=java,algorithm |>\nThe answer by\
    \ Jon Skeet is correct, but it's O(n2) so I suggest using Collections.sort with\
    \ the comparator provided by:\n<code>\nstatic class CompareByFirst\n{\n    public\
    \ int compare(Object o1, Object o2)\n    {\n        if (o1 == null && o2 == null)\n\
    \            return 0;\n        if (o1 == null)\n            return -1;\n    \
    \    if (o2 == null)\n            return 1;\n        return ((Comparable)o1).compareTo(o2);\n\
    \    }\n}\n</code>\nThis way you can get a O(n) solution.\n<|/ a dscore=3 |>\n\
    <| a |>\nThe complexity of the most popular answer (Jon Skeet) is O(n2), which\
    \ can be improved to O(n), by using a sort with a custom comparator.\n<code>\n\
    public static void main(String... args) {\n    List<Integer> list1 = new ArrayList<>();\n\
    \    List<Integer> list2 = new ArrayList<>();\n    for (int i = 0; i < 10000;\
    \ i++) {\n        list1.add(i % 5);\n        list2.add(i % 7);\n    }\n    Collections.sort(list1,\
    \ new Comparator<Integer>() {\n        public int compare(Integer o1, ", "{\n\
    \    var a = l1;\n    var b = l2;\n    var len = Math.min(a.length, b.length);\n\
    \    var ans = new long[len];\n    \n    for(int i = 0; i < len; ++i)\n      \
    \  ans[i] = a[i] == b[i] ? a[i] : 0;\n    \n    Arrays.sort(ans);\n    return\
    \ ans;\n}", "{\n\tlong[] result = new long[l1.length + l2.length];\n\tint i =\
    \ 0;\n\tfor(int i1 = 0, i2 = 0; i1 < l1.length; i1++, i2++)\n\t{\n\t\tif(i2 <\
    \ l2.length)\n\t\t{\n\t\t\tif(i1 < l2.length)\n\t\t\t{\n\t\t\t\tif(l1[i1] == l2[i2])\n\
    \t\t\t\t\tresult[i] = l1[i1];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\
    \t\tresult[i] = l1[i1];\n\t\t\t\t\tresult[i+1] = l2[i2];\n\t\t\t\t}\n\t\t\t}\n\
    \t\t\telse\n\t\t\t\tresult[i] = l1[i1];\n\t\t}\n\t\telse\n\t\t\tresult[i] = l1[i1];\n\
    \t}\n\treturn result;\n}", "{\n\tint i = 0;\n\tint j = 0;\n\tlong[] result = null;\n\
    \tlong v = 0;", "{\n\tlong[] a1 = sort(l1);\n\tlong[] a2 = sort(l2);\n\tint i\
    \ = 0;\n\tint j = 0;\n\twhile (i<(a1.length) && j<(a2.length))\n\t{\n\t\tif (a1[i]\
    \ == a2[j])\n\t\t{\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\telse if (a1[i] < a2[j])\n\
    \t\t{\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj++;\n\t\t}\n\t}\n\treturn new\
    \ long[j];\n}", "{\n    long[] r = new long[l1.length + l2.length];\n    sort(l1,\
    \ l2);\n    merge(mergeSort(l1), mergeSort(l2), r);\n    return r;\n}\n/*\n  \
    \  Merge sort a sorted array\n    http://www.hackerearth.com/practice/algorithms/sorting/merge-sort/\n\
    */", "{\n    final int n = l1.length + l2.length;\n    long[] u1 = new long[n];\n\
    \    long[] u2 = new long[n];\n    System.arraycopy(l1, 0, u1, 0, l1.length);\n\
    \    System.arraycopy(l2, 0, u2, l1.length, l2.length);\n    Arrays.sort(u1);\n\
    \    Arrays.sort(u2);\n    long[] u = new long[l1.length + l2.length];\n    System.arraycopy(u1,\
    \ 0, u, 0, l1.length);\n    System.arraycopy(u2, 0, u, l1.length, l2.length);\n\
    \    return u;\n}", "{\n    long[] c = new long[l1.length];\n    for (int i =\
    \ 0; i < l1.length; i++) {\n        if ((l1[c.length - 1 - i] == l1[i]) && (l2[c.length\
    \ - 1 - i] == l2[i])) {\n            c[c.length - 1 - i]++;\n        }\n    }\n\
    \    \n    for (int i = 0; i < l1.length; i++) {\n        if ((l1[c.length - 1\
    \ - i] == l1[i]) && (l2[c.length - 1 - i] == l2[i])) {\n            c[c.length\
    \ - 1 - i]++;\n        }\n    }\n    \n    for (int i = 0; i < l1.length; i++)\
    \ {\n        if ((l1[c.length - 1 - i] == l1[i]) && (l2[c.length - 1 - i] == l2[i]))\
    \ {\n            c[c.length - 1 - i]++;\n        }\n    }\n    return c;\n}\n\
    /*\nReturn sorted unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n    long[]\
    \ c = new long[l1.length + l2.length];\n    for(int i = 0; i < l1.length; ++i)\n\
    \        c[i] = l1[i];\n    for(int i = 0; i < l2.length; ++i)\n        c[i +\
    \ l1.length] = l2[i];\n    sort(c);\n    for(int i = 0; i < l1.length + l2.length;\
    \ ++i) {\n        if(c[i] == c[i + l1.length])\n            delete(c[i]);\n  \
    \  }\n    return c;\n}", "{\n\t// TODO: replace with sorting and then unique\n\
    \tlong[] sorted1 = sortOn(l1);\n\tlong[] sorted2 = sortOn(l2);\n\t\n\tlong[] result1\
    \ = new long[sorted1.length];\n\tlong[] result2 = new long[sorted2.length];\n\t\
    int i = 0;\n\tint j = 0;\n\t\n\twhile (i < sorted1.length && j < sorted2.length)\
    \ {\n\t\tif (sorted1[i] == sorted2[j])\n\t\t\tresult1[i] = sorted1[i];\n\t\ti++;\n\
    \t\tj++;\n\t}\n\t\n\twhile (i < sorted1.length)\n\t\tresult1[i] = sorted1[i];\n\
    \t\n\twhile (j < sorted2.length)\n\t\tresult2[j] = sorted2[j];\n\t\n\treturn result1;\n\
    }", "{\n    long[] r1 = new long[l1.length];\n    long[] r2 = new long[l2.length];\n\
    \    long[] r3 = new long[l1.length];", "{\n    long common=0;\n    for(int i=0;i<l1.length;i++)\n\
    \    {\n        for(int j=0;j<l2.length;j++)\n        {\n            if(l1[i]==l2[j])\n\
    \            {\n                common++;\n                break;\n          \
    \  }\n        }\n    }\n    long[] result=new long[common];\n    for(int i=0;i<common;i++)\n\
    \    {\n        result[i]=l1[i];\n    }\n    return result;\n}\n/*\nReturn sorted\
    \ unique common elements for two arrays of strings\n    >>> common({\"a\",\"b\"\
    ,\"c\",\"d\",\"e\",\"f\",\"g\"}, {\"a\",\"f\",\"c\",\"e\",\"b\",\"g\"})\n    [\"\
    a\", \"f\", \"c\", \"b\", \"e\"]\n    >>> common({\"a\",\"b\",\"c\",\"d\",\"e\"\
    ,\"f\",\"g\"}, {\"a\",\"f\",\"c\",\"e\",\"b\",\"g\",\"x\"})\n    [\"a\", \"f\"\
    , \"c\", \"b\", \"e\"]\n    \n    \n    \n*/\nString common(String l1, String\
    \ l2) \n{\n    String common=\"\";\n    for(int i=0;i<l1.length();i++)\n    {\n\
    \        for(int j=0;j<l2.length();j++)\n        {\n            if(l1.charAt(i)==l2.charAt(j))\n\
    \            {\n                common+=l1.charAt(i);\n                break;\n\
    \            }\n        }\n    }\n    return common;\n}\n/*\nReturn sorted unique\
    \ common elements for two arrays of strings\n    >>> common([\"a\",\"b\",\"c\"\
    ,\"d\",\"e\",\"f\",\"g\"], [\"a\",\"f\",\"c\",\"e\",\"b\",\"g\"])\n    [\"a\"\
    , \"f\", \"c\", \"b\", \"e\"]\n    >>> common([\"a\",\"b\",\"c\",\"d\",\"e\",\"\
    f\",\"g\"], [\"a\",\"f\",\"c\",\"e\",\"b\",\"g\",\"x\"])\n    [\"a\", \"f\", \"\
    c\", \"b\", \"e\"]\n    \n    \n    \n*/\nString common(String[]l1, String[]l2)\
    \ \n{\n    String common=\"\";\n    for(int i=0;i<l1.length;i++)\n    {\n    \
    \    for(int j=0;j<l2.length;j++)\n        {\n            if(l1[i]==l2[j])\n \
    \           {\n                common+=l1[i];\n                break;\n      \
    \      }\n        }\n    }\n    return common;\n}\n/*\nReturn sorted unique common\
    \ elements for two arrays of strings\n    >>> common([[\"x\",\"a\"],[\"y\",\"\
    c\"],[\"z\",\"e\"]], [[\"x\",\"a\"],[\"y\",\"c\"],[\"z\",\"e\"]])\n    [[\"x\"\
    , \"a\"], [\"y\", \"c\"], [\"z\", \"", "{\n    int minLen = min.length(l1, l2);\n\
    \    long[] c = new long[minLen];\n    int i = 0;\n    for (; i < minLen; ++i)\n\
    \        c[i] = 0;\n    for (; i < minLen && l1[i] != l2[i]; ++i)\n        c[i]\
    \ = l1[i];\n    for (; i < minLen; ++i)\n        c[i] = 0;\n    return c;\n}",
  "{\n    if(l1 == null)\n        return l2;\n    if(l2 == null)\n        return l1;\n\
    \    int l1 = l1.length;\n    int l2 = l2.length;\n    long l3 = 0, l4 = 0;\n\
    \    for(int i=0;i<l1;i++)\n    {\n        long l5 = l1[i];\n        for(int j=0;j<l2;j++)\n\
    \        {\n            l4 = l2[j];\n            if(l5 == l4)\n            {\n\
    \                l3++;\n                l2[j] = 0;\n                break;\n \
    \           }\n        }\n    }\n    return l1==0?l3:l3;\n}\n</code>\n<|/ a |>\n\
    <| c |>\n`l3 = l1 - l2;\nreturn l3 == l1 ? l1 : l3;`\n<|/ c |>\n<| a |>\nI know\
    \ this is an old question but here is my solution, that does not use recursion.\n\
    <code>\nimport std.conv;\nimport std.array;", "{\n    long[] d = new long[l1.length];\n\
    \    for (int i = 0; i < l1.length; i++)\n        d[i] = l1[i];\n    for (int\
    \ i = 0; i < l2.length; i++)\n        if (d[i] == l2[i]) return d;\n    long[]\
    \ ret = new long[l1.length + l2.length];\n    int j = 0;\n    int k = 0;\n   \
    \ for (int i = 0; i < l1.length; i++)\n    {\n        while (k < l2.length &&\
    \ l2[l2.length - k] == d1[i])\n            k++;\n        if (k > j)\n        {\n\
    \            ret[j] = d1[i];\n            j++;\n        }\n    }\n    k = j;\n\
    \    for (int i = l1.length; i < l1.length + l2.length; i++)\n    {\n        while\
    \ (k < l2.length && l2[l2.length - k] == d1[i])\n            k++;\n        if\
    \ (k > j)\n            ret[j] = d1[i];\n        else\n            ret[j++] = d1[i];\n\
    \    }\n    return ret;\n}\n</code>\n<|/ a |>\n<| c |>\nWow, thanks for that!\
    \ I've been trying to work this out for quite some time now.\n<|/ c |>\n<| c |>\n\
    I tried to implement the function but I'm having trouble understanding the algorithm\
    \ for getting the unique elements from the first array. What does this line mean?\
    \ *return d1[i]*\n<|/ c |>\n<| a dscore=1 |>\nYou can use the merge sort algorithm\
    \ for this.  It will give you O(nlg(n)) performance in comparison.\n<|/ a tags=arrays,sorting,java,algorithm\
    \ |>\n<| a tags=arrays,sorting,java,algorithm |>\nTry this:\n<code>\npublic static\
    \ boolean isPalindrome(long x)\n    {\n        int i = 0;\n        int j = x.length()-1;\n\
    \        while (i < j)\n        {\n            if (x.charAt(i) != x.charAt(j))\n\
    \            {\n                return false;\n            }\n            i++;\n\
    \            j--;\n        }\n        return true;\n    }", "{\n    long[] result\
    \ = {0L};\n    if (l1.length < l2.length) l1.reverse();\n    for (int i = 0; i\
    \ < l1.length; i++) \n    {\n        int j = 0;\n        for (; j < l2.length;\
    \ j++) \n        {\n            if (l1[i] == l2[j]) \n            {\n        \
    \        result[0] = l1[i];\n                break;\n            }\n        }\n\
    \    }\n    std.sort(result);\n    return result;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\n<code>\npackage main;", "{\n    long[] res = new long[l1.length];\n\
    \    long i, j, k;\n    for(i=0; i<l1.length; i++)\n        for(j=0; j<l2.length;\
    \ j++)\n            if(l1[i] != l2[j])\n                for(k=i+1; k<l1.length;\
    \ k++)\n                    if(l1[k] != l2[j])\n                        break;\n\
    \            else\n                res[i] = l1[i];\n    return res;\n}\n</code>\n\
    <|/ a tags=java |>\n<| c |>\nthank you so much!!! It helped me a lot to understand\
    \ how things work.\n<|/ c |>\n<| a |>\nThe correct answer to this question can\
    \ be found here: http://rosettacode.org/wiki/Fast_least_common_multiple\n<code>\n\
    static int gcd(int a, int b) {\n        while (b > 0) {\n            int t = b;\n\
    \            b = a % b;\n            a = t;\n        }\n        return a;\n  \
    \  }", "{\n    if (l1.length != l2.length)\n        throw new IllegalArgumentException(\"\
    Lengths must be the same.\");", "{\n    return l1\n            .toSet()\n    \
    \        .intersect(l2.toSet())\n            .sorted()\n            .map(i =>\
    \ l1[i])\n            .toArray();\n}", "{\n  long[] a = new long[l1.length];\n\
    \  int j = 0;\n  int k = 0;\n  for(int i = 0; i < l1.length; i++) {\n    a[i]\
    \ = l1[i];\n  }\n  for(int j = 0; j < l2.length; j++) {\n    a[k++] = l2[j];\n\
    \  }\n  \n  Arrays.sort(a);\n  return a;\n}\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nWhy are you creating new arrays when you can sort the existing array in\
    \ place?\n<|/ c |>\n<| c |>\nThe new array is for returning the sorted unique\
    \ elements. Since arrays are pass-by-reference in Java so you can pass your sorted\
    \ unique arrays from your function. This is the best way I think.\n<|/ c |>\n\
    <| c |>\nI don't see how this is different than what I've written in terms of\
    \ efficiency. I don't think you were talking about efficiency but rather about\
    \ readability.\n<|/ c |>\n<| c |>\nI do think that efficiency is a key feature\
    \ here and I provided some code showing how to make it as fast as possible (although\
    \ your solution is probably better than this as it uses less memory). I think\
    \ this is more of a readability issue which I believe is what the original poster\
    \ is trying to achieve.\n<|/ c |>\n<| c |>\nYour solution does not use `Arrays.sort`.\n\
    <|/ c |>\n<| a tags=performance,arrays,sorting,algorithm,java |>\nYou can use\
    \ the Arrays class to sort your array in place using the sort() method, like so:\n\
    <code>\nArrays.sort(yourArray);\n</code>\n<|/ a dscore=3 |>\n<| c |>\n`Arrays.sort`\
    \ mutates the array, so this will only work once.\n<|/ c |>\n<| a dscore=2 |>\n\
    If you don't want to use Arrays.sort, you can try with Arrays.binarySearch(),\
    \ which returns an index at which a given element can be found, or, if it's not\
    \ found, it returns the first index greater than the given element. \nIf it returns\
    \ -1, then the element is not present in the array.\n<code>", "{\n    long[] ans\
    \ = new long[l1.length];\n    for (int i = 0; i < ans.length; i++) \n        ans[i]\
    \ = l1[i];\n    Arrays.sort(ans);\n    int j;\n    for (int i = 0; i < l2.length;\
    \ i++) {\n        j = Arrays.binarySearch(ans, l2[i]);\n        if (j >= 0) \n\
    \            ans[j] = l2[i];\n    }\n    return ans;\n}\n</code>\n<|/ a dscore=0\
    \ tags=c#,java,algorithm |>\n<| c |>\nThis is a brute force approach.\n<|/ c |>\n\
    <| c |>\n: It's a very simple approach. There are also a lot of optimizations\
    \ to this, and a lot of room for optimization.\n<|/ c |>\n<| c |>\nYou cannot\
    \ use Arrays.sort. You also don't need to find the index of all elements in first\
    \ array then search it again in second array. Just search first array from first\
    \ index.\n<|/ c |>\n<| c |>\n: I didn't say anything about `Arrays.sort`. I'm\
    \ just commenting on the fact that this approach is going to be O(n^2) where n\
    \ is the number of elements in l1 and l2, which is the worst case for binary search.\
    \ I don't see any optimizations here.\n<|/ c |>\n<| c |>\nSure, but the complexity\
    \ of your answer is O(n^2). Just replace it with the code from my answer.\n<|/\
    \ c |>\n<| a tags=c#,java,algorithm |>\n<code>\nusing System;\nusing System.Collections.Generic;",
  "{\n    long[] ret = new long[l1.length];\n    bool flag = false;\n    for(int i\
    \ = 0; i < l1.length; i++)\n    {\n        for(int j = 0; j < l2.length; j++)\n\
    \        {\n            if(l1[i] == l2[j])\n            {\n                flag\
    \ = true;\n                break;\n            }\n        }\n        if(!flag)\n\
    \        {\n            ret[i] = l1[i];\n        }\n        else\n        {\n\
    \            flag = false;\n        }\n    }\n    return ret;\n}\n</code>\n<|/\
    \ a dscore=1 tags=c++,stl |>\n<| a dscore=1 tags=c++,stl |>\nUse std::sort with\
    \ the std::less comparator functor. std::sort requires a sorted range and as long\
    \ as the input is sorted, it will not need to reorder elements in the input container.\
    \ Here is a simple example which sorts 5 random integers using a custom comparator:\n\
    <code>\n#include <vector>\n#include <algorithm>\n#include <iostream>", "{\n  \
    \  long[] l = new long[l1.length+l2.length];\n    int j = 0;\n    int k = 0;\n\
    \    for (int i=0; i<l1.length; i++) {\n        if (l2.length > k) {\n       \
    \     if (l1[i] == l2[k]) {\n                l[j++] = l1[i];\n               \
    \ k++;\n            }\n            else {\n                while (k < l2.length)\
    \ {\n                    l[j++] = l2[k++];\n                }\n            }\n\
    \        }\n        else {\n            l[j++] = l1[i];\n        }\n    }\n  \
    \  return l;\n}", "{\n    if (l1.length != l2.length) throw new IllegalArgumentException(\"\
    Array length mismatch!\");\n    long[] res = new long[l1.length];\n    int len\
    \ = l1.length;\n    int i = 0;\n    while (i < len && l1.get(i) == l2.get(i))\
    \ \n    {\n        res[i] = l1.get(i);\n        i++;\n    }\n    while (i < len)\
    \ {\n        res[i] = l1.get(i);\n        i++;\n    }\n    sort(res);\n    return\
    \ res;\n}\n</code>\n<|/ a |>\n<| a tags=java,arrays,algorithm |>\nYou can use\
    \ a HashSet to track visited elements. The following code snippet does this.\n\
    <code>\npublic static long[] common(long [] l1, long [] l2) {\n    long[] result\
    \ = new long[l1.length];\n    Set<Long> set = new HashSet<>();\n    for(long l:\
    \ l1)\n        set.add(l);\n    for(long l: l2)\n        if(!set.add(l))\n   \
    \         result[l%l1.length] = l;\n    for(long l: result) \n        result[l%l1.length]\
    \ = l;\n    return result;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis looks\
    \ more elegant and efficient, but I'm not a Java programmer, so I'm having trouble\
    \ figuring out what the `%` does in the `result[l%l1.length] = l;` line.\n<|/\
    \ c |>\n<| c |>\n`l%l1.length` will give you the remainder when `l` divides into\
    \ the length of `l1`, which means the index of `l1` in which the element resides.\n\
    <|/ c |>\n<| c |>\nI guess you could just do `result[l % l1.length] = l` instead,\
    \ since the `%` has higher precedence than `[]`.\n<|/ c |>\n<| a tags=java,arrays,algorithm\
    \ dscore=2 |>\n<code>\npublic static long[] common(long [] l1, long [] l2)\n \
    \   {\n        if (l1.length != l2.length) throw new IllegalArgumentException(\"\
    Array length mismatch!\");\n        long[] result = new long[l1.length];\n   \
    \     for(int i = 0; i < l1.length; i++)\n        {\n            boolean found\
    \ = false;\n            for(int j = 0; j < l2.length; j++)\n            {\n  \
    \              if(l1[i] == l2[j])\n                {\n                    found\
    \ = true;\n                    break;\n                }\n            }\n    \
    \        if(found)\n                result[i] = l1[i];\n        }\n        return\
    \ result;\n    }\n</code>\n<|/ a |>\n<| c |>\n", "{\n    long[] result = new long[l1.length];\n\
    \    Arrays.sort(l1);\n    Arrays.sort(l2);\n    int i, j;", "{\n    long[] res\
    \ =new long[l1.length];\n    long count=0;\n    for (int i=0 ; i<l1.length ; i++)\
    \ {\n        for (int j=0 ; j<l2.length ; j++) {\n            if (l1[i]==l2[j])\
    \ res[count++]=l1[i];\n        }\n    }\n    return res;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis code is very fast.\n<|/ c |>\n<| a tags=arrays,algorithm,c# |>\n\
    You can make use of array sort function of c#. It sorts the array in ascending\
    \ order.\n<code>\n  static void Main(string[] args)\n    {\n        int[] num\
    \ = new int[5];\n        num[0] = 3;\n        num[1] = 1;\n        num[2] = 2;\n\
    \        num[3] = 5;\n        num[4] = 4;\n        Array.Sort(num);\n        foreach\
    \ (var item in num)\n        {\n            Console.WriteLine(item);\n       \
    \ }\n        Console.ReadLine();\n    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    I believe this code is O(N^2). It sorts the whole array, not just two numbers.\n\
    <|/ c |>\n<| a dscore=3 |>\nAn alternative approach could be using a Set<T> and\
    \ it's IntersectWith method which returns a new set containing elements present\
    \ in both sets. You can then convert this set to a new int[] array and use it:\n\
    <code>", "{\n    long l[] = new long[std.math.max(l1.length, l2.length)];\n  \
    \  int j = 0;\n    for (long x : l1) {\n        if (l2.length < l1.length) l[j]\
    \ = l2[l2.length];\n        else if(x < l2[l2.length]) l[j] = l2[l2.length];\n\
    \        else if(l1.length < l2.length) l[j] = l1[l1.length];\n        else if(x\
    \ < l1[l1.length]) l[j] = l1[l1.length];\n        else j++;\n        j++;\n  \
    \  }\n    return std.sort(l);\n}", "{\n    int n1 = l1.length;\n    int n2 = l2.length;\n\
    \    long[] ans = new long[n1 + n2];\n    for(int i = 0; i < n1; i++){\n     \
    \   for(int j = 0; j < n2; j++){\n            if((l1[i] == l2[j]) ){\n       \
    \         ans[i + j] = l1[i];\n            }\n        }\n    }\n    return ans;\n\
    }\n</code>\n<|/ a tags=java,arrays |>\n<| a dscore=1 tags=java,arrays |>\nUsing\
    \ java-8, using stream() & collect() :\n<code>\npublic static long[] common(long[]\
    \ arr1, long[] arr2){\n    long[] result = Arrays.stream(arr1).filter(x -> Arrays.stream(arr2).anyMatch(y\
    \ -> x == y)).distinct().toArray(long[]::new);\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis would return `[1, 3]` in this case, instead of `[1, 5]`.\n\
    <|/ c |>\n<| a tags=java,arrays |>\n<code>\nimport java.util.*;", "{\n    int\
    \ len1 = l1.length;\n    int len2 = l2.length;\n    if (len1 > len2) \n    {\n\
    \        int temp = len2;\n        len2 = len1;\n        len1 = temp;\n    }\n\
    \    if (len1 == 0) return new long[0];\n    long[] res = new long[len1];\n  \
    \  \n    long[] l3 = new long[len2];\n    int i = 0, j = 0;\n    while (i<len1\
    \ && j<len2)\n    {\n        if (l1[i] == l2[j]) \n        {\n            res[i]\
    \ = l1[i];\n            i++;\n            j++;\n        }\n        else if (l1[i]\
    \ < l2[j]) \n        {\n            l3[j++] = l1[i++];\n        }\n        else\
    \ \n        {\n            l3[j++] = l2[j++];\n        }\n    }\n    while (i\
    \ < len1) \n    {\n        l3[j++] = l1[i++];\n    }\n    while (j < len2) \n\
    \    {\n        l3[j++] = l2[j++];\n    }\n    return res;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a dscore=1 tags=arrays,algorithm,sorting |>\nUsing Map, HashMap\
    \ and HashSet all will be done in linear time.\n<code>\nstatic SortedSet<Integer>\
    \ intersection(Integer[] arr1, Integer[] arr2) {", "{\n    long[] result = new\
    \ long[long.max(l1.length, l2.length)];\n    int i = 0, j = 0;\n    \n    // first\
    \ check how many unique items are in both arrays\n    for(long x : l1) \n    \
    \    if (l2.indexOf(x + 1) == -1) result[i++] = x;\n    for(long x : l2)\n   \
    \     if (l1.indexOf(x + 1) == -1) result[j++] = x;\n    \n    // then add remaining\
    \ unique items in one array to the other array (result has unique elements)\n\
    \    for(long x : l1) \n        if (l2.indexOf(x + 1) == -1) result[i++] = x;\n\
    \    for(long x : l2)\n        if (l1.indexOf(x + 1) == -1) result[j++] = x;\n\
    \    \n    return result.subarray(0, i);\n}\n</code>\nAnd here is the test that\
    \ shows the performance is pretty good:\n<code>\npublic static void testCommon()\n\
    {\n    List<long[]> data = new ArrayList<>();\n    for (int i = 0; i < 100; i++)\n\
    \    {\n        data.add(new long[200]);\n        for (int j = 0; j < data.size();\
    \ j++)\n        {\n            long[] a = new long[200];\n            long[] b\
    \ = new long[200];\n            for (int k = 0; k < a.length; k++)\n         \
    \   {\n                a[k] = i;\n                b[k] = j;\n            }\n \
    \           data.get(j) = a;\n        }\n    }\n    \n    long start = System.currentTimeMillis();\n\
    \    for (long[] array: data)\n    {\n        long[] common = common(array);\n\
    \    }\n    long end = System.currentTimeMillis();\n    \n    System.out.println(\"\
    Time elapsed: \" + (end - start));\n    \n}\n</code>\n<|/ a dscore=1 tags=java,arrays\
    \ |>\n<| c |>\nthanks for you answer, but i think this algorithm is not optimal.\
    \ Because it takes O(n^2) time (as i think). I am looking for an algorithm that\
    \ takes O(n) time.\n<|/ c |>\n<| c |>\nI've added a test that proves my algorithm\
    \ is fast enough.\n<|/ c |>\n<| c |>\nI got this solution and it's working fine,\
    \ but I am not satisfied with complexity and i think this solution is not optimal.\
    \ Can you suggest me any more optimised solution with O(n) complexity ?\n<|/ c\
    \ |>\n<| c |>\nI've added a test that proves my algorithm is fast enough.\n<|/\
    \ c |>\n<| c |>\nYou are right about this complexity. But can you suggest me another\
    \ solution with O(n) complexity?\n<|/ c |>", "{\n    // This function doesn't\
    \ actually use l1 and l2 but \n    // it is an example of how to get two arrays\
    \ into the same \n    // data structure while not wasting too much space. \n \
    \   //\n    // The same algorithm can be implemented in O(n) by using a \n   \
    \ // hash table. \n    long [] table = new long [l1.length];\n    for(long e :\
    \ table) e = l1[i];\n    for(long e : l2) table[i++] = e;\n    \n    long[] result\
    \ = new long[table.length];\n    int j = 0;\n    for(long e : table) result[j++]\
    \ = e;\n    return result;\n}\n</code>\nAnd here is the same algorithm in O(n^2)\
    \ using a hash map.\n<code>\nimport std.array;\nimport std.arrayfns;\nimport std.map;",
  "{\n    long x = 0, y = 0, z = 0;\n    \n    // if l1 is longer than l2 return it\
    \ first\n    if(l1.length > l2.length) {\n        z = l1;\n        l1 = l2;\n\
    \        l2 = z;\n    }\n    \n    for(int i = 0; i < l1.length; i++) {\n    \
    \    if(l1[i] == l2[i]) \n            x += 1; \n        else\n            y +=\
    \ 1;\n    }\n    \n    long[] result = new long[l1.length];\n    \n    for(int\
    \ i = 0; i < l1.length; i++)\n        result[i] = l1[i];\n    \n    // now remove\
    \ common elements from l1 to l1\n    for(int i = 0; i < l2.length; i++) {\n  \
    \      if(result[i] == l2[i]) {\n            l1[i] = 0;\n            x -= 1;\n\
    \        } else\n            y -= 1;\n    }\n    \n    // now remove common elements\
    \ from l2 to l2\n    for(int i = 0; i < l2.length; i++) {\n        if(result[i]\
    \ == l2[i]) {\n            l2[i] = 0;\n            y -= 1;\n        } else\n \
    \           x -= 1;\n    }\n    \n    // now merge the remaining l1 to l1\n  \
    \  while(x > y) {\n        if(l1[l1.length - 1] != 0)\n            l1[l1.length\
    \ - 1] = l1[l1.length - 1] + 1;\n        else\n            l1.pop();\n    }\n\
    \    \n    // now merge the remaining l2 to l2\n    while(y > x) {\n        if(l2[l2.length\
    \ - 1] != 0)\n            l2[l2.length - 1] = l2[l2.length - 1] + 1;\n       \
    \ else\n            l2.pop();\n    }\n    \n    // now merge the remaining l1\
    \ to l2\n    while(x > y) {\n        if(l1[l1.length - 1] != 0)\n            l2[l2.length\
    \ - 1] = l2[l2.length - 1] + 1;\n        else\n            l1.pop();\n    }\n\
    \    \n    return result;\n}\n// ---------------------------------------------------------------------------------------------------------\n\
    /*\nReturn true if the array is sorted in descending order.\n    >>> descending([4,\
    \ 2, 2, 3, 2])\n    True\n    >>> descending([2, 2, 3, 2, 4])\n    False\n*/",
  "{\n    int i = 0, j = 0; \n    int len1 = 0, len2 = 0;\n    long common = 0;\n\
    \    while (i < l1.length && j < l2.length) {\n        if (l1[i] < l2[j]) {\n\
    \            i++;\n        } else if (l1[i] > l2[j]) {\n            j++;\n   \
    \     } else if (l1[i] == l2[j]) {\n            common++;\n            len1++;\n\
    \            len2++;\n            i++; j++;\n        }\n    }\n    long[] result\
    \ = new long[len1 + len2 - common];\n    while (i < l1.length) {\n        result[len1]\
    \ = l1[i];\n        i++;\n        len1++;\n    }\n    while (j < l2.length) {\n\
    \        result[len2] = l2[j];\n        j++;\n        len2++;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=optimization,java,c++,algorithm,c |>\n<| c |>\n\
    That's a great implementation. I'd like to add a comment that for integers this\
    \ is the best algorithm: http://stackoverflow.com/a/16547396/714007\n<|/ c |>\n\
    <| c |>\nThat's a great implementation. I'd like to add a comment that for integers\
    \ this is the best algorithm: http://stackoverflow.com/a/16547396/714007\n<|/\
    \ c |>\n<| c |>\nYour implementation is not correct (unless I'm missing something).\
    \ `common` should return `l1` if `l1[i] == l2[j]` and then `common` should be\
    \ incremented by 1.\n<|/ c |>\n<| c |>\n: I corrected the code and added some\
    \ comments. Also I have added a link to an alternative implementation that returns\
    \ an array of integers for common elements. Thanks!\n<|/ c |>\n<| a tags=optimization,java,c++,algorithm,c\
    \ dscore=2 |>\nJust use java.util.Arrays.asList(Arrays.asList(array1)) - Arrays.asList(array2)\
    \ will return a List<List<Integer>>, where each inner list is the same as the\
    \ input arrays. And then you can use the stream API to get all the common elements\
    \ like this:\n<code>", "{\n    long[] ret = new long[((l1.length == l2.length)\
    \ ? l1.length : (l1.length < l2.length ? l1.length : l2.length))];\n    int i,\
    \ j;\n    for(i = 0; i < ret.length; i++)\n    {\n        for(j = 0; j < i; j++)\n\
    \        {\n            if(l1[i] == l2[j])\n            {\n                ret[i]\
    \ = l1[i];\n                break;\n            }\n        }\n    }\n    return\
    \ ret;\n}", "{\n    int n = Math.min(l1.length, l2.length);\n    long[] res =\
    \ new long[n];\n    for(int i = 0; i < n; i++)\n    {\n        long common = l1.length\
    \ > i ? l1[i] : l1[0];\n        for(int j = 1; j < n; j++)\n        {\n      \
    \      if(common < l2[j] && common < res[j-1])\n            {\n              \
    \  res[j] = common;\n            }\n        }\n    }\n    Arrays.sort(res);\n\
    \    return res;\n}\n/*\nReturn sorted unique common elements for two arrays.\n\
    \    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\n\
    \    \n    \n*/\ndouble[] common(double[] l1, double[] l2) \n{\n    int n = Math.min(l1.length,\
    \ l2.length);\n    double[] res = new double[n];\n    for(int i = 0; i < n; i++)\n\
    \    {\n        double common = l1.length > i ? l1[i] : l1[0];\n        for(int\
    \ j = 1; j < n; j++)\n        {\n            if(common < l2[j] && common < res[j-1])\n\
    \            {\n                res[j] = common;\n            }\n        }\n \
    \   }\n    Arrays.sort(res);\n    return res;\n}\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n    \n    \n*/", "{\n\tHashSet<long> h = new HashSet<long>(l1);\n\
    \th.retainAll(l2);\n\treturn h.toArray();\n}", "{\n    long[] l = new long[l1.length\
    \ + l2.length];\n    int j = 0;\n    for (int i = 0; i < l1.length; i++) \n\t\
    {\n\t    if (i < l2.length) \n\t    {\n\t\tl[j++] = l1[i];\n\t    }\n\t    else\n\
    \t    {\n\t\tl[j++] = l2[i];\n\t    }\n\t}\n\t\n\twhile (j < l.length) \n\t{\n\
    \tl[j++] = 0L;\n\t}\n\t\n\tsort(l);\n\t\n\tlong[] result = new long[l1.length\
    \ + l2.length];\n\tint k = 0;\n\t\n\tint i = 0;\n\t\n\twhile (i < l1.length &&\
    \ j < l2.length) \n\t{\n\t    if (l[i] <= l[j]) {\n\t\tresult[k++] = l[i++];\n\
    \t    } \n\t    else {\n\t\tresult[k++] = l[j++];\n\t    }\n\t}\n\t\n\twhile (i\
    \ < l1.length) \n\t{\n\t    result[k++] = l[i++];\n\t}\n\t\n\twhile (j < l2.length)\
    \ \n\t{\n\t    result[k++] = l[j++];\n\t}\n\t\n\treturn result;\n}\n/*\n  std.typecons.map2[T](T\
    \ f, T s) => (f(s), f(s))\n*/\nmap2<long, long> map2(f, s) {\n\tmap2<long, long>\
    \ r = map();\n\tmap2<long, long> f = map(f);\n\tmap2<long, long> s = map(s);\n\
    \t\n\tfor (map2<long, long> i = f; i.l != null; i = i.f) \n\t{\n\t\tfor (map2<long,\
    \ long> j = s; j.l != null; j = j.f) \n\t\t{\n\t\t\tr[i.l] = j.l;\n\t\t}\n\t}\n\
    \t\n\treturn r;\n}\n/*\n  std.typecons.map2[T](T f, T s) => (f(s), f(s))\n*/\n\
    map2<long, long> map2(f, s) {\n\tmap2<long, long> r = map();\n\tmap2<long, long>\
    \ f = map(f);\n\tmap2<long, long> s = map(s);\n\t\n\tfor (map2<long, long> i =\
    \ f; i.l != null; i = i.f) \n\t{\n\t\tfor (map2<long, long> j = s; j.l != null;\
    \ j = j.f) \n\t\t{\n\t\t\tr[i.l] = j.l;\n\t\t}\n\t}\n\t\n\treturn r;\n}\n/*\n\
    \  std.typecons.map2[T](T f, T s) ", "{\n    if (l1.length != l2.length) \n  \
    \      throw new RuntimeException(\"Error: L2 length != L1\");\n    long[] temp\
    \ = new long[l1.length];\n    for (int i=0; i<l1.length; i++) {\n        if (l2[i]!=null\
    \ && l1[i]!=null) {\n            if (l2[i] > l1[i]) {\n                temp[i]\
    \ = l2[i];\n            }\n            else {\n                temp[i] = l1[i];\n\
    \            }\n        }\n        else {\n            if (l2[i] != null) {\n\
    \                temp[i] = l2[i];\n            }\n            else {\n       \
    \         temp[i] = l1[i];\n            }\n        }\n    }\n    Arrays.sort(temp);\n\
    \    return temp;\n}", "{\n    int i = 0;\n    int j = 0;\n    int n1 = l1.length;\n\
    \    int n2 = l2.length;\n    long[] result = new long[n1+n2];\n    while (i<n1)\n\
    \    {\n        while (j<n2 && (l1[i] == l2[j])) j++;\n        result[i++] = l1[i++];\n\
    \    }\n    while (i<n1)\n    {\n        result[i++] = l1[i++];\n    }\n    while\
    \ (j<n2)\n    {\n        result[i++] = l2[j++];\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=arrays,java,sorting,compare |>\n<| a dscore=4 tags=arrays,java,sorting,compare\
    \ |>\nAnother way to do this is using Arrays.sort() method as follows:\n<code>",
  "{\n        long[] a = new long[l1.length];\n        for (int i = 0; i < l1.length;\
    \ i++) \n        {\n                a[i] = l1[i];\n        }\n        long[] b\
    \ = new long[l2.length];\n        for (int i = 0; i < l2.length; i++) \n     \
    \   {\n                b[i] = l2[i];\n        }\n        int i = 0;\n        int\
    \ j = 0;\n        while (i<a.length && j<b.length) \n        {\n             \
    \   if (a[i]<b[j])\n                {\n                        i++;\n        \
    \        }\n                else\n                {\n                        j++;\n\
    \                }\n        }\n        long[] result = new long[i];\n        if\
    \ (i<a.length)\n        {\n                result = Arrays.copyOf(a, i);\n   \
    \     }\n        else\n        {\n                result = Arrays.copyOf(b, j);\n\
    \        }\n        return result;\n}\n</code>\n<|/ a tags=sorting,collections,java,arrays\
    \ |>\n<| a tags=sorting,collections,java,arrays dscore=2 |>\n<code>\n public int[]\
    \ sort(int[] ints)\n {\n     Arrays.sort(ints);\n     return ints;\n }\n</code>\n\
    <|/ a |>\n<| a tags=sorting,collections,java,arrays |>\n<code>\nimport java.util.Arrays;",
  "{\n    long[] l3 = new long[l1.length];\n    int i = 0;\n    \n    while (i<l1.length)\n\
    \    {\n        if (l1[i] != l2[i])\n        {\n            l3[i] = l1[i];\n \
    \           i++;\n        }\n        else\n        {\n            i++;\n     \
    \   }\n    }\n    \n    return l3;\n}", "{\n    long i,j, k, m;\n    int[] u1\
    \ = new int[l1.length];\n    int[] u2 = new int[l2.length];\n    long[] u = new\
    \ long[l1.length];", "{\n    long result = 0, i1 = 0, i2 = 0, n = 0, m = 0;\n\
    \    \n    while (true) {\n        n = (i1 < l1.length && i2 < l2.length) ? l1[i1]\
    \ < l2[i2] : l1[i1] == l2[i2];\n        m = i1 < l1.length;\n        \n      \
    \  if (n == false) {\n            i1++;\n        } else if (m == false) {\n  \
    \          i2++;\n        } else {\n            break;\n        }\n    }\n   \
    \ \n    while (i1 < l1.length) {\n        result = result ^ l1[i1++];\n    }\n\
    \    \n    while (i2 < l2.length) {\n        result = result ^ l2[i2++];\n   \
    \ }\n    \n    return result == 0 ? [] : [result];\n}\n/* \n    Use a prefix tree\
    \ for quick lookup.\n*/\nclass PrefixTree {\n    long prefix;\n    \n    bool\
    \ isLeaf;\n    \n    long height;\n    \n    List<List<long>> nodes;\n    \n \
    \   long value;\n    \n    public PrefixTree(long prefix, bool isLeaf, long height,\
    \ List<List<long>> nodes, long value) {\n        this.prefix = prefix;\n     \
    \   this.isLeaf = isLeaf;\n        this.height = height;\n        this.nodes =\
    \ nodes;\n        this.value = value;\n    }\n}", "{\n\tlong min;\n\tlong temp;\n\
    \tint[] i1 = intArray(l1);\n\tint[] i2 = intArray(l2);\n\t\n\tfor(int i = 0; i\
    \ < i1.length; i++){\n\t\tmin = i1[i];\n\t\tfor(int j = 0; j < i2.length; j++){\n\
    \t\t\tif(i2[j] < min){\n\t\t\t\tmin = i2[j];\n\t\t\t}\n\t\t}\n\t\tint index =\
    \ i;\n\t\twhile(index > 0 && i1[index-1] >= min){\n\t\t\ti1[index] = i1[index-1];\n\
    \t\t\tindex--;\n\t\t}\n\t\ti1[index] = min;\n\t}\n\t\n\treturn intArray(i1);\n\
    }", "{\n    Arrays.sort(l1);\n    Arrays.sort(l2);\n    long[] result = new long[l1.length\
    \ + l2.length];\n    long[] r1 = l1, r2 = l2;\n    long common = -1, common2 =\
    \ 0;\n    \n    for(int i = 0; i<l1.length && i<l2.length; i++){\n        if(l1[i]==l2[i]){\n\
    \            result[i] = l1[i];\n        }else if(l1[i]<l2[i]){\n            result[i]\
    \ = r1[i];\n            common = l1[i];\n        }else{\n            result[i]\
    \ = r2[i];\n            common2 = l2[i];\n        }\n    }\n    \n    for(int\
    \ i = 0; i<l1.length; i++){\n        if(l1[i]!=l2[i]){\n            result[i]\
    \ = l1[i];\n        }\n    }\n    \n    if(r1.length>l2.length){\n        for(int\
    \ i = 0; i<l2.length; i++){\n            result[l2.length+i] = r2[i];\n      \
    \  }\n    }else{\n        for(int i = 0; i<r2.length; i++){\n            result[l1.length+i]\
    \ = r2[i];\n        }\n    }\n    \n    Arrays.sort(result);\n    return result;\n\
    }", "{\n    long[] l3 = new long[l1.length];\n    for(int i = 0; i < l1.length;\
    \ i++) \n    {\n        int j;\n        for (j = 0; j < l2.length; j++) \n   \
    \         if (l1[i] == l2[j]) \n                break;\n        if (j == l2.length)\
    \ \n            l3[i] = l1[i]; \n        else \n            l3[i] = l1[i]; \n\
    \    }\n    return l3;\n}", "{\n    long[] result = null;\n    Arrays.sort(l1);\n\
    \    Arrays.sort(l2);\n    int j = 0;\n    int i = 0;\n    while (i < l1.length\
    \ && j < l2.length)\n    {\n        if (l1[i] == l2[j])\n        {\n         \
    \   j++;\n        }\n        else if (l1[i] < l2[j])\n        {\n            if\
    \ (result == null)\n            {\n                result = new long[l1.length];\n\
    \            }\n            result[i++] = l1[i];\n        }\n        else\n  \
    \      {\n            if (result == null)\n            {\n                result\
    \ = new long[l2.length];\n            }\n            result[j++] = l2[j];\n  \
    \      }\n    }\n    if (i == l1.length)\n    {\n        Arrays.sort(result);\n\
    \    }\n    if (j == l2.length)\n    {\n        Arrays.sort(result);\n    }\n\
    \    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThat's a good start, though\
    \ you might want to do some profiling to find out what sorts of optimizations\
    \ it makes.\n<|/ c |>\n<| c |>\nIf you use Arrays.sort like that (for large arrays),\
    \ it's worth it to add some checks in your loop that you're not overflowing the\
    \ arrays. You can end up overwriting one array and corrupting another. Since Java\
    \ 8 you can use `IntStream.range(startInclusive, stopInclusive).boxed().collect(toList())`\
    \ to get an IntStream from an array of ints.\n<|/ c |>\n<| c |>\nI suspect a lot\
    \ of people have noticed that `Arrays.sort()` runs in O(nlogn) time, which could\
    \ be slow for large arrays. I thought it would be nice to see a solution that\
    \ is O(n) time for small arrays, but I've also started a discussion about that:\
    \ http://stackoverflow.com/questions/15209435/how-to-get-the-unique-elements-from-an-array-using-a-complex-time-algorithm\n\
    <|/ c |>\n<| c |>\nOops, I misread your comment.  I thought you meant to say `O(n\
    \ + mlogn)` instead of `O(nlogn)`. I deleted my comment and upvoted yours.\n<|/\
    \ c |>\n<| c |>\nOh that is right, I mean O(n + mlogn). I just got confused because\
    \ you wrote a O(nlogn) solution and posted an O(n) solution at the same time.\
    \ I should probably delete the comment and upvote yours.\n<|/ c |>\n<| a tags=java,arrays,algorithm,c++\
    \ dscore=3 |>\n<code>\nimport java.util.Arrays;\npublic class array{\n    public ",
  "{\n    long[] result = new long[l1.length];\n    sort(l1, l2);\n    for(int i =\
    \ 0; i < (l1.length-l2.length+1); i++) {\n        result[i] = l1[i];\n    }\n\
    \    sort(result, result);\n    return result;\n}", "{\n\tlong t = 0;\n\tint i\
    \ = 0;\n\tlong temp = 0;\n\tint k;\n\t\n\twhile((i < l1.length) && (i < l2.length))\
    \ {\n\t\ttemp = (l1[i]) ^ (l2[i]);\n\t\tt = ((t ^ temp) & 0x5555555555555555LL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\
    \t\tk = ((k + 1) & 0x5555555555555555LL);\n\t\tt = ((t ", "{\n    long[] ret =\
    \ new long[l1.length+l2.length];\n    for (int i = 0; i<l1.length; i++) {\n  \
    \      for (int j = 0; j<l2.length; j++) {\n            if (l1[i] == l2[j]) {\n\
    \                ret[i] = l1[i];\n            }\n        }\n    }\n    return\
    \ ret;\n}", "{\n    int n1 = l1.length;\n    int n2 = l2.length;\n    long[] res\
    \ = new long[n1];\n    for(int i=0; i<n1; i++) {\n        for(int j=0; j<n2; j++)\
    \ {\n            if(l1[i]==l2[j]) {\n                res[i] = l1[i];\n       \
    \         break;\n            }\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ a list of elements common to both lists.\n    >>> common([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L,\
    \ 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n    long[] n1, n2;\n    int n;",
  "{\n    long[] ret = new long[std.array.max(l1.length, l2.length)];\n    long[]\
    \ x = l1, y = l2;\n    int i;\n    long x;\n    long y;\n    while (i = std.array.argmax(x.length,\
    \ y.length)) \n    {\n        x = std.array.min(x.length, y.length);\n       \
    \ y = std.array.min(x.length, y.length);\n        if (std.array.getIndex(i) <\
    \ x.length)\n        {\n            ret[i] = std.array.get(i, x);\n        }\n\
    \        else if (std.array.getIndex(i) < y.length)\n        {\n            ret[i]\
    \ = std.array.get(i, y);\n        }\n        else\n        {\n            ret[i]\
    \ = std.array.get(i, x.length);\n        }\n    }\n    return ret;\n}", "{\n \
    \   var n1 = l1.length;\n    var n2 = l2.length;\n    long[] result; \n    long[]\
    \ v1;\n    long[] v2;\n    long i=0,j=0,k=0,v=0;\n    long common_length=0;\n\
    \    int k=0;\n    if(n1<n2){\n        common_length = n1;\n        result = v1\
    \ = l1;\n        v2 = l2;\n    }else{\n        common_length = n2;\n        result\
    \ = v2 = l2;\n        v1 = l1;\n    }", "{\n\tlong[] h1 = new long[20]; \n\tlong[]\
    \ h2 = new long[20];\n\tfor (int i = 0; i < 20; i++) { \n\t\th1[i] = 0;\n\t\t\
    h2[i] = 0;\n\t}\n\tint l = 0;\n\tint c = 0;\n\tint len1 = 0, len2 = 0;\n\tfor\
    \ (int i = 0; i < l1.length && i < l2.length; i++) {\n\t\tif (l1[l] == l2[c])\
    \ {\n\t\t\th1[l] = l1[l]; \n\t\t\tlen1++;\n\t\t\tc++;\n\t\t\tif (len1 == 20) {\n\
    \t\t\t\tl++;\n\t\t\t\tlen1 = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (len1 > len2)\
    \ {\n\t\t\t\th2[c] = h1[c]; \n\t\t\t\tlen2++;\n\t\t\t\tc = 0;\n\t\t\t\tif (len2\
    \ == 20) {\n\t\t\t\t\tl++;\n\t\t\t\t\tlen2 = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\
    \t\t\th1[c] = h2[c]; \n\t\t\t\tlen1++;\n\t\t\t\tc = 0;\n\t\t\t\tif (len1 == 20)\
    \ {\n\t\t\t\t\tl++;\n\t\t\t\t\tlen1 = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif\
    \ (len1 > len2) { \n\t\tfor (int i = len1; i < len2; i++) {\n\t\t\th2[c] = h1[c];\
    \ \n\t\t\tc++;\n\t\t}\n\t} else if (len2 > len1) {\n\t\tfor (int i = len2; i <\
    \ len1; i++) {\n\t\t\th1[c] = h2[c]; \n\t\t\tc++;\n\t\t}\n\t}\n\treturn h1;\n\
    }\n</code>\n<|/ a tags=algorithm,arrays,sorting |>\n<| c |>\nThis implementation\
    \ was very helpful, even though its complexity is O(n^2). Thanks\n<|/ c |>\n<|\
    \ a dscore=1 |>\nIf you can use external libraries, you can use std::sort with\
    \ custom comparators. For example, using lambda and std::sort with custom comparators:\n\
    <code>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include\
    \ <functional>", "{\n    long[] n1 = new long[l1.length];\n    long[] n2 = new\
    \ long[l2.length];\n    for (int i = 0; i<l1.length; i++)\n    {\n        n1[i]\
    \ = l1[i];\n    }\n    for (int i = 0; i<l2.length; i++)\n    {\n        n2[i]\
    \ = l2[i];\n    }\n    n1.Sort();\n    n2.Sort();\n    long[] res = new long[l1.length];\n\
    \    for (int i = 0; i<l1.length; i++)\n    {\n        for (int j = 0; j<l2.length;\
    \ j++)\n        {\n            if (n1[i] == n2[j])\n            {\n          \
    \      res[i] = n1[i];\n                break;\n            }\n        }\n   \
    \ }\n    return res;\n}", "{\n\tlong[] a = new long[20];\n\tint i, j, k;", "{\n\
    \tlong[] result = new long[l1.length];\n\tfor (int i = 0; i < result.length; ++i)\n\
    \t{\n\t\tfor (int j = 0; j < l2.length; ++j)\n\t\t{\n\t\t\tif (l1[i] == l2[j])\n\
    \t\t\t{\n\t\t\t\tresult[i] = l1[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tArrays.sort(result);\n\
    \treturn result;\n}", "{\n    long n1 = length(l1);\n    long n2 = length(l2);\n\
    \    if (n1 == 0)\n        return l1;\n    if (n2 == 0)\n        return l2;\n\
    \    if (n1 > n2)\n        l2 = l2;\n    long[] ans = l1;\n    if (l1 == l2) {\n\
    \        ans.length = 0;\n        return ans;\n    }", "{\n    long[] res = new\
    \ long[l1.length + l2.length];\n    for (int i = 0; i < l1.length; ++i)\n    {\n\
    \        for (int j = 0; j < l2.length; ++j)\n        {\n            if (l1[i]\
    \ == l2[j])\n            {\n                res[i + j] = l1[i];\n            \
    \    res[i + j + 1] = l1[i + 1];\n                res[i + j + 2] = l1[i + 2];\n\
    \                res[i + j + 3] = l1[i + 3];\n            }\n        }\n    }\n\
    \    return res;\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for your answer. My\
    \ problem is more complex than I asked it. I am looking for a way to get the intersection\
    \ of two arrays of different sizes (not just different in size, but not evenly\
    \ divisible). For example: [[1,2],[3,4]] & [[1,3],[5,7]]. Because these two arrays\
    \ are not divisible, their intersection is not common. I need to compare their\
    \ intersection and output those common elements.\n<|/ c |>\n<| c |>\n: My answer\
    \ does not only output common elements; it outputs common elements, and it also\
    \ outputs elements from both arrays. Please test it before downvoting.\n<|/ c\
    \ |>\n<| c |>\nMy answer does not output common elements, but it outputs common\
    \ elements from both arrays. I edited the answer so you can see it. I don't know\
    \ where you got downvoted, but I gave my answer a +1 anyway.\n<|/ c |>\n<| c |>\n\
    : I edited the question to clarify the requirements you have.\n<|/ c |>\n<| c\
    \ |>\n: Ok, I edited the answer to address this requirement. I am still not sure\
    \ you really need to output only common elements. It's not clear how your problem\
    \ is different from the problem of finding the common elements in two arrays;\
    \ you just need to know how to find the common elements between two arrays. I'll\
    \ keep thinking and will let you know if I find an answer that solves your problem.\n\
    <|/ c |>\n<| a tags=java,arrays,c#,algorithm |>\nThe most straightforward way\
    \ is to sort the array and keep track of the number of elements that have already\
    \ been counted.\n<code>", "{\n\tint[] l=std.intarray;\n\tint i;\n\t\n\tint n=l1.length;\n\
    \tint m=l2.length;\n\t\n\tlong[] r=new long[n+m];\n\t\n\tfor(i=0;i<=n; r.push(n),\
    \ i++);\n\tfor(i=0;i<=m; r.push(m), i++);\n\t\n\tfor(i=n+1;i<=m; r.push(i), i++);\n\
    \t\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tint h=l1[i-1];\n\t\tint j=i+1;\n\t\twhile(j<=m\
    \ && l[j-1]!=h) j++;\n\t\tr[i-1]=std.math.max(l[i-1],l[j-1]);\n\t}\n\t\n\treturn\
    \ r;\n}", "{\n    long[] ret = new long[l1.length];\n    int i = 0;\n    for (int\
    \ n = 0; n < l1.length; n++) {\n        for (int m = 0; m < l2.length; m++) {\n\
    \            if (l1[n] == l2[m]) {\n                ret[i++] = l1[n];\n      \
    \          break;\n            }\n        }\n    }\n    Arrays.sort(ret);\n  \
    \  return ret;\n}\n</code>\n<|/ a tags=sorting,java |>\n<| c |>\nIf someone is\
    \ still looking for a more efficient solution, it is much faster to do this in\
    \ C++ using unordered_map and unordered_set. Here is an example in C++ of the\
    \ same: http://stackoverflow.com/questions/11594553/find-unique-elements-in-two-unordered-vectors-by-using-hashset\n\
    <|/ c |>\n<| a dscore=0 |>\nTo find the unique elements in a set, first sort the\
    \ set using any sort mechanism you prefer. After that use a \"HashSet\" data structure\
    \ to store the unique elements and then print the unique elements from the hash-set\
    \ data structure\n<code>\nimport java.io.*;\nimport java.util.*;", "{\n\tif (l1.length\
    \ != l2.length) \n\t{\n\t\tthrow new IndexOutOfBoundsException();\n\t}\n\tlong[]\
    \ a = new long[l1.length];\n\tint j = 0;\n\tfor (int i = 0; i < l1.length; ++i)\n\
    \t{\n\t\tif (l1[i] > l2[i]) \n\t\t{\n\t\t\ta[j] = l2[i];\n\t\t\tj++;\n\t\t}\n\t\
    \telse if (l1[i] < l2[i]) \n\t\t{\n\t\t\ta[j] = l1[i];\n\t\t\tj++;\n\t\t}\n\t\
    }\n\tlong[] result = a;\n\tArrays.sort(result);\n\treturn result;\n}\n/*\nReturn\
    \ sorted unique elements for two arrays.\n    >>> unique([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [5L, 2L, 653L, 121L]\n    >>>\
    \ unique([5L, 3L, 2L, 8L], [3L, 2L])\n    [8L, 2L, 3L]", "{\n\tlong[] result =\
    \ new long[l1.length];\n\tfor (int i = 0; i < result.length; ++i)\n\t\tresult[i]\
    \ = l1[i];\n\tfor (int i = 0; i < result.length; ++i)\n\t\tfor (int j = i + 1;\
    \ j < result.length; ++j)\n\t\t\tif (result[i] == l2[j])\n\t\t\t{\n\t\t\t\tresult\
    \ = sortSet(result);\n\t\t\t\tbreak;\n\t\t\t}\n\treturn result;\n}\n/*\nReturn\
    \ sorted unique common elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L,\
    \ 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>>\
    \ common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n    int len1 = l1.length;\n\
    \    int len2 = l2.length;\n    if (len1<len2)\n        throw new RuntimeException(\"\
    Length mismatch\");\n    long l1[len1], l2[len2];\n    l1 = copyOf(l1, len1);\n\
    \    l2 = copyOf(l2, len2);\n    Arrays.sort(l1, len1);\n    Arrays.sort(l2, len2);\n\
    \    int i=0, j=0;\n    while(i<len1 && j<len2)\n    {\n        if (l1[i]==l2[j])\n\
    \        {\n            i++;\n            j++;\n        }\n        else if (l1[i]<l2[j])\n\
    \        {\n            i++;\n        }\n        else\n        {\n           \
    \ j++;\n        }\n    }\n    long ans[len1];\n    ans = copyOf(ans, len1);\n\
    \    if (i<len1)\n    {\n        ans = Arrays.copyOf(ans, i);\n    }\n    else\
    \ if (j<len2)\n    {\n        ans = Arrays.copyOf(ans, len2);\n        System.arraycopy(l2,\
    \ j, ans, 0, len2-1);\n    }\n    return ans;\n}", "{\n    int l=l1.length;\n\
    \    int m=l2.length;\n    long[] common = new long[l];\n    \n    // sort arrays\
    \ before finding common elements\n    for (int i=0;i<l;i++) \n        if (l1[i]>l2[m])\n\
    \            swap(l1[i],l2[m]);\n    \n    // find common elements with binary\
    \ search\n    long start = 0;\n    long end = m-1;\n    int mIndex = 0;\n    while\
    \ (mIndex<end) \n    {\n        int i = (start+end)/2;\n        if (l1[mIndex]\
    \ == l2[m]) \n        {\n            common[mIndex] = l1[mIndex];\n          \
    \  mIndex = mIndex + 1;\n        }\n        else if (l1[mIndex]<l2[m]) \n    \
    \    {\n            end = i;\n        }\n        else \n        {\n          \
    \  start = i;\n        }\n    }\n    \n    // sort array again if necessary\n\
    \    if (l1.length > m) \n        sort(common);\n    \n    return common;\n}\n\
    </code>\n<|/ a dscore=2 tags=arrays,java,mergesort |>\n<| c |>\nthanks. i did\
    \ try to run this code but it says java.lang.ArrayIndexOutOfBoundsException. I\
    \ know this is because of the array lengths. Could you please help me fix it?\n\
    <|/ c |>\n<| c |>\nArrayIndexOutOfBoundsException probably occurred because your\
    \ arrays are of different sizes. Try to debug your code to see how it works. If\
    \ you still have issues, please post your code in your question.\n<|/ c |>\n<|\
    \ c |>\nI added some comments to your code. Please check if it is clear enough\
    \ now.\n<|/ c |>\n<| a dscore=2 tags=arrays,java,mergesort |>\n<code>\npackage\
    \ com.khan.khan.util;", "{\n    long n = length(l1);\n    long[] l3 = new long[n];\n\
    \    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n\
    \        {\n            if (l1[i] == l2[j])\n                l3[i] = l1[i];\n\
    \        }\n    }\n    sort(l3);\n    return l3;\n}\n/*\nReturn unique elements\
    \ in one array which are not in the other array.\n    >>> unique([5L, 3L, 2L,\
    \ 8L, 5L, 4L, 9L, 653L, 121L])\n    [8L, 5L, 653L]\n    >>> unique([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L, 7L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 5L, 7L, 8L, 9L,\
    \ 121L]\n    ", "{\n   var d = l1.length - l2.length;\n   long[] c = new long[d];\
    \ \n   for (int i = 0; i <= l1.length - l2.length; i++) \n   {\n      c[i] = l1[i];\n\
    \   }\n   int j = 0;\n   for (int i = l1.length - l2.length; i > 0; i--) \n  \
    \ {\n      c[j] = l2[i];\n      j++;\n   }\n   return c;\n}\n</code>\n<|/ a tags=algorithm,c#\
    \ |>\n<| c |>\nCan you please explain what you are doing here? It's hard to read\
    \ this kind of code\n<|/ c |>\n<| c |>\nIt's a modified version of [this](https://stackoverflow.com/questions/16706429/find-common-elements-in-two-arrays-in-c)\
    \ question for two arrays. It works for me, and it seems to be a lot simpler than\
    \ the more generic answers.\n<|/ c |>\n<| c |>\nOh, I see how you added a loop\
    \ from length 0 to l1.length - l2.length. It is a nice solution, though. I'm sure\
    \ it would still be faster though.\n<|/ c |>\n<| c |>\nI did not know about this\
    \ question and it's answers, they look like a real gem. I'm currently using your\
    \ solution but it is not very efficient with big arrays (more than 1000 elements).\
    \ I'm still looking for a better solution, though.\n<|/ c |>\n<| c |>\nIt's not\
    \ clear to me why you're choosing the solution that uses `HashSet` rather than\
    \ `Array.Sort`. It seems unlikely that they would be any more efficient, but perhaps\
    \ I'm missing something about how they're implemented. The documentation for both\
    \ mentions sorting first, which seems counterintuitive to me.\n<|/ c |>\n<| a\
    \ |>\nMy solution is really fast. It uses HashSet<T> which is an efficient implementation\
    \ of Set in .NET.\nIt first sorts both arrays and then finds the common elements\
    \ between them in a single loop.\nIt uses Array.Copy() to copy the sorted arrays.\
    \ So you only need to allocate one more array that is the size of the other array.\n\
    <code>\npublic static void FindCommon<T>(IList<T> a, IList<T> b, IList<T> c)\n\
    {\n    var aSort = a.ToArray();\n    var bSort = b.ToArray();\n    Array.Copy(aSort,\
    \ 0, bSort, 0, aSort.Length);\n    Array.Sort(bSort);", "{\n  long[] result =\
    \ new long[l1.length];\n  for(long i = 0; i<l1.length; ++i) {\n    long j=0;\n\
    \    for(; j < l2.length; ++j) {\n      if(l1[i] == l2[j])\n        break;\n \
    \   }\n    result[i] = l1[i];\n  }\n  return result;\n}", "{\n\tlong m1=0;\n\t\
    long m2=0;\n\t\n\tfor(int i = 0; i< l1.length;i++) {\n\t\tif (m1==0) {\n\t\t\t\
    m1 = l1[i];\n\t\t\tm2 = l2[i];\n\t\t\tcontinue;\n\t\t}", "{\n    int i = 0;\n\
    \    int j = 0;\n    int k = 0;\n    int size = l1.length;\n    long[] result\
    \ = new long[size];", "{\n  if (l1 == l2) \n    return l1;\n  long[] result =\
    \ new long[l1.length+l2.length];\n  int i = 0, j = 0;\n  while (i < l1.length\
    \ || j < l2.length) \n  {\n    if (i < l1.length && j < l2.length) \n    {\n \
    \     if (l1.elementAt(i) == l2.elementAt(j)) \n        { \n          result[j++]\
    \ = l1.elementAt(i++); \n        } \n      else if (l1.elementAt(i) < l2.elementAt(j))\
    \ \n        { \n          i++; \n        } \n      else \n        { \n       \
    \   j++; \n        } \n    } \n    else if (i < l1.length) \n    {\n      result[j++]\
    \ = l1.elementAt(i++); \n    } \n    else if (j < l2.length) \n    {\n      result[j++]\
    \ = l2.elementAt(j++); \n    } \n    else \n    {\n      int k = i;\n      while\
    \ (k<l1.length && l1.elementAt(k) == l2.elementAt(k))\n        k++;\n      result[j++]\
    \ = l1.elementAt(k);\n      i++;\n    }\n  }\n  return result;\n}", "{\n    sort(l1);\n\
    \    sort(l2);\n    long[] l = new long[l1.length + l2.length];\n    long curr\
    \ = l1.length;\n    int i, j;\n    while (curr < l.length) \n    {\n        if\
    \ (l1[curr] != l2[0]) \n        {\n            l[curr++] = l2[0];\n        }\n\
    \        else \n        {\n            for (j = 1; j < l1.length && l1[curr] ==\
    \ l2[j]; j++) \n            {\n                l[curr++] = l1[curr];\n       \
    \     }\n        }\n    }\n    return l;\n}\n/*\nReturn sorted unique common elements\
    \ for two arrays of strings.\n    >>> common([\"Apple\", \"Banana\", \"Cherry\"\
    , \"Durian\"], [ \"Banana\", \"Carrot\", \"Durian\", \"Eggplant\"])\n    [ \"\
    Durian\", \"Eggplant\", \"Apple\", \"Cherry\" ]\n    >>> common([\"Banana\", \"\
    Carrot\", \"Durian\", \"Eggplant\"], [\"Banana\", \"Durian\", \"Apple\", \"Cherry\"\
    ])\n    [ \"Durian\", \"Apple\", \"Eggplant\" ]", "{\n    long common = 0;\n \
    \   for (long i : l1) {\n        long j = 0;\n        for (long k : l2) {\n  \
    \          if (i == k) \n                j++;\n        }\n        if (j == 1)\
    \ \n            common++;\n    }\n    if (common == l1.length) \n        return\
    \ l1;\n    if (common == l2.length)\n        return l2;\n    long[] result = new\
    \ long[common];\n    System.arraycopy(l1, 0, result, 0, common);\n    System.arraycopy(l2,\
    \ 0, result, common, l2.length);\n    return result;\n}\n</code>\n<|/ a tags=java,arrays\
    \ |>\n<| c |>\nWhat is the time complexity of this solution?\n<|/ c |>\n<| c |>\n\
    This solution is O(n^2) but it can be modified to be O(n * log(n)), I'll edit\
    \ it later.\n<|/ c |>\n<| c |>\n: Time complexity is O(N)\n<|/ c |>\n<| a tags=java,arrays\
    \ |>\n<code>\nimport java.util.Arrays;\nimport java.util.List;", "{\n  int count\
    \ = 0;\n  int i = 0;\n  int j = 0;\n  long[] results = new long[l1.length];\n\
    \  for (; i < l1.length && j < l2.length; i++, j++) {\n    if (l1[i] == l2[j])\
    \ {\n      count++;\n    }\n  }\n  while (i++ < l1.length) {\n    results[count++]\
    \ = l1[i];\n  }\n  while ((j += 2) > l2.length) {\n    results[count++] = l2[j];\n\
    \  }\n  return results;\n}", "{\n    int i = 0, j = 0;\n    int l11 = 0, l22 =\
    \ 0;\n    int l1 = l1.length, l2 = l2.length;\n    long[] v = new long[l1 + l2];\n\
    \    long x = 0;\n    long y = 0;\n    while( i < l1 ) \n    {\n        while(\
    \ j < l2 ) \n        {\n            if( l1[i] == l2[j] )\n            {\n    \
    \            i++; \n                j++;\n                if( l1 == l2 )\n   \
    \                 return v; // trivial solution\n            }\n            else\n\
    \            {\n                // not equal\n                l11++;\n       \
    \         l22++;\n            }\n        }\n        \n        // next element\
    \ from l1 that is not equal to current element of l2\n        x = (x + l1[i])\
    \ % l1;\n        v[++i] = x;\n        x = x * (l1 + l11 + l22) % l1;\n    }",
  "{\n    final long[] common = new long[64];\n    int i = 0;\n    int j = 0;\n  \
    \  int l = 0;\n    for(int k = 0; k < 64; k++) \n    {\n        if(l1[i] < l2[j])\
    \ \n        {\n            common[l++] = l1[i++];\n        } \n        else \n\
    \        {\n            common[l++] = l2[j++];\n        }\n    }\n    for(int\
    \ k = 0; k < l; k++) \n    {\n        common[k] = 0;\n    }\n    l = 64;\n   \
    \ for(i = 0; i < 64; i++) \n    {\n        if(common[i]) \n        {\n       \
    \     j++;\n            common[j] = 1;\n            while(common[j] && j < 64)\
    \ \n            {\n                common[j] = 0;\n                j++;\n    \
    \        }\n        }\n    }\n    long[] result = new long[64];\n    for(i = 0;\
    \ i < 64; i++) \n    {\n        if(common[i]) \n        {\n            result[l++]\
    \ = i;\n        }\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I doubt your algorithm would run in under a second for any pair of arrays of length\
    \ 64. `common` has length 64, which is about 3 million. My code has only a handful\
    \ of loops, and only three array accesses, which is about three orders of magnitude\
    \ faster.\n<|/ c |>\n<| c |>\n`common` has length 64 in both versions, in the\
    \ second version it starts at `i = 64` and ends at `l`, in the first version it\
    \ starts at `i = 26` and `l = 0`. It's not that common elements cannot be found\
    \ this way, it's that their order is significantly different from what you'd expect.\
    \ Your algorithm will return sorted unique common elements for arrays [1, 4, 3,\
    \ 34, 653, 2] and [1, 5, 3, 34, 653, 121], but it will not return [34, 653, 2].\
    \ You just happened to find a case where it's working correctly, so I didn't bother\
    \ with it.\n<|/ c |>\n<| c |>\nThe common algorithm should return the common elements\
    \ of two arrays, not their sorted order. The example you give doesn't match the\
    \ algorithm, and if you compare the code (which doesn't seem to work) with the\
    \ example code (which seems to work), you see that the second example is not working\
    \ correctly. Your algorithm will return the sorted order, but it will not return\
    \ the unique elements. A common algorithm would return the common elements (in\
    \ sorted order), without duplicates. A sample that would be returned by the algorithm\
    \ would be [1, 5, 3, 34, 653, 121], the unique elements of the second example\
    \ would be [34, 653, 2]\n<|/ c |>\n<| c |>\nI have added a modified version of\
    \ your algorith", "{\n    int n1 = l1.length;\n    int n2 = l2.length;\n    long[]\
    \ result = new long[n1 + n2];\n    long[] a1 = new long[n1];\n    long[] a2 =\
    \ new long[n2];", "{\n\tlong[] l3 = new long[l1.length];\n\tint j = 0;\n\tfor\
    \ (int i = 0; i < l1.length; i++) {\n\t\tif (l2[j] == l1[i])\n\t\t\tl3[i] = l2[j];\n\
    \t\telse\n\t\t\tl3[i] = l1[i];\n\t\tj++;\n\t}\n\treturn l3;\n}\n// TODO: Optimize\
    \ for speed - use hashmap?\n/*\n Return array containing the most frequent elements\
    \ of an array that differ by no more than one element.\n Returns null if the array\
    \ contains no unique elements.\n */\nlong[] mostFrequent(long[] l)\n{\n\tlong[]\
    \ result = null;\n\tif (l.length == 0)\n\t\treturn result;\n\tArrays.sort(l);\n\
    \tresult = new long[l.length];\n\tint j = 0;\n\tfor (int i = 0; i < l.length;\
    \ i++) {\n\t\tif (j == 0)\n\t\t\tresult[i] = l[i];\n\t\telse\n\t\t\tif (l[i] ==\
    \ result[j]) {\n\t\t\t\tj++;\n\t\t\t\tif (j >= result.length)\n\t\t\t\t\tresult[j]\
    \ = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tresult[j++] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\n Return array containing the least frequent elements of an array that differ\
    \ by no more than one element.\n Returns null if the array contains no unique\
    \ elements.\n */\nlong[] leastFrequent(long[] l)\n{\n\tlong[] result = null;\n\
    \tif (l.length == 0)\n\t\treturn result;\n\tArrays.sort(l);\n\tresult = new long[l.length];\n\
    \tresult[0] = l[0];\n\tj = 1;\n\tfor (int i = 0; i < l.length; i++) {\n\t\tif\
    \ (l[i] == result[j]) {\n\t\t\tj++;\n\t\t\tif (j >= result.length)\n\t\t\t\tresult[j]\
    \ = 0;\n\t\t}\n\t\telse\n\t\t\tresult[j++] = l[i];\n\t}\n\treturn result;\n}\n\
    /*\n Return array containing the most frequent elements of an array that differ\
    \ by more than one element.\n Returns null if the array contains no unique elements.\n\
    \ */\nlong[] mostFrequentDiff(long[] l)\n{\n\tlong[] result = null;\n\tif (l.length\
    \ == 0)\n\t\treturn result;\n\tArrays.sort(l);\n\tresult = new long[l.length];\n\
    \tresult[0] = l[0];\n\tj = 1;\n\tfor (int i = 0; i < l.length; i++) {\n\t\tif\
    \ (j == 0)\n\t\t\tresult[i] = l[i];\n\t\telse\n\t\t\tif (l[i] != result[j - 1])\
    \ {\n\t\t\t\tj = 0;\n\t\t\t\tresult[j++] = l[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\t\
    if (l[i] == result[j]) {\n\t\t\t\t\tj++;\n\t\t\t\t\tif (j >= result.length)\n\t\
    \t\t\t\t\tresult[j] = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tresult[j++] = l[i];\n\
    \t}\n\treturn result;\n}\n/*\n Return array containing the least ", "{\n\tlong\
    \ len = length(l1);\n\tlong len2 = length(l2);\n\tlong[] res = new long[len+len2];\n\
    \tint i = 0;\n\tfor (int a=0; a<len; a++)\n\t{\n\t\tfor (int b=0; b<len2; b++)\n\
    \t\t{\n\t\t\tif (l1[a] == l2[b])\n\t\t\t{\n\t\t\t\tres[i] = l1[a];\n\t\t\t\ti++;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "{\n    long[] res = {0L};\n    for(int\
    \ i=0; i<l1.length; i++) \n    {\n        for(int j=0; j<l2.length; j++) \n  \
    \      {\n            if(l1[i] == l2[j]) \n            {\n                res[res.length]\
    \ = l1[i];\n                i = l1.length - 1;\n                j = 0;\n     \
    \       }\n            else\n            {\n                j = 0;\n         \
    \   }\n        }\n    }\n    return res;\n}\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis is not the optimal solution. O(n\xB2 log n) complexity is quite an\
    \ overestimation of n\xB2, especially on large datasets. You only need one pass\
    \ on both arrays, as long as there is an element common in both arrays. This is\
    \ still O(n\xB2).\n<|/ c |>\n<| c |>\nYou're right, although I believe it's possible\
    \ to improve it further - but this would require some more analysis. I guess that\
    \ in some cases, this solution could perform better - or maybe it could even be\
    \ as fast as it can be.\n<|/ c |>\n<| c |>\nI updated my answer. I've tried to\
    \ implement a slightly better solution (though still not optimal). I believe it\
    \ to be O(n).\n<|/ c |>\n<| c |>\nI updated my answer as well. I've implemented\
    \ a slightly better solution (though still not optimal). I believe it to be O(n).\n\
    <|/ c |>\n<| a |>\nI implemented the algorithm you described. My code is below\
    \ - though I believe there are more efficient ways to implement it - perhaps using\
    \ SIMD (since I used the C# libraries instead of the native c++ libraries). My\
    \ code is also below - but it does not use any additional libraries.\nThe algorithm\
    \ works like this:\nYou have an integer array a. There is an integer array b where\
    \ every element in b is also in a. These arrays can be of any size.\nYou want\
    \ the algorithm to return an array c where every element of c is in b. But the\
    \ order in c does not matter. If the order is important, then you need a different\
    \ algorithm.\nThe algorithm first sorts both arrays by using mergesort. At first\
    \ the algorithm will merge the arrays and leave behind all the common elements.\
    \ After that, it does a binary search in b to find every element in c that should\
    \ be there. If an element is not in b, then it means that there is not an element\
    \ that should be there. \nThe algorithm is as follows:\n<code>\n    public static\
    \ int[] findCommon(int[] a, int[] b) {\n        Array.Sort(a);\n        Array.Sort(b);",
  "{\n    var ls = new long[mathMax(std.maxint(l1.length), std.maxint(l2.length))];\n\
    \    var l3 = new long[ls.length];\n    var j = 0;\n    for(var i=0; i<l1.length;\
    \ i++) \n    {\n        if(l3[i]!=-1) continue;\n        l3[j] = l3[i]=l1[i];\
    \ \n        j++;\n    }\n    for(int i=0; i<l2.length; i++) \n    {\n        if(l3[i]!=-1)\
    \ continue;\n        l3[j] = l3[i]=l2[i]; \n        j++;\n    }\n    for(var i=0;\
    \ i<l3.length; i++) \n    {\n        if(l3[i]!=-1) continue;\n        l3[j]=l3[i]=l1[i];\
    \ \n        j++;\n    }\n    l3 = l3.slice(1, ls.length);\n    return l3;\n}",
  "{\n\tlong[] l=new long[l1.length+l2.length];\n\tint i=0;\n\tint j=0;\n\twhile(i\
    \ < l.length && j<l2.length) {\n\t\tif (l1[i] == l2[j])\n\t\t\tl[i]=l1[i];\n\t\
    \telse j++;\n\t\ti++;\n\t}\n\treturn l;\n}", "{\n    long[] a = l1;\n    long[]\
    \ b = l2;\n    int i = 0, j = 0;", "{\n    int[] i1 = sort(l1); // sort i1 using\
    \ mergesort algorithm (O(nlogn), n : lenght of i1, n : lenght of i2)\n    int[]\
    \ i2 = sort(l2); // sort i2 using mergesort algorithm (O(nlogn), n : lenght of\
    \ i1, n : lenght of i2)\n    long[] u = new long[i1.length]; // sorted unique\
    \ elements of i1 and i2 \n    int i1Length, i2Length;", "{\n    long[] result\
    \ = new long[l1.length];\n    Arrays.sort(l1);\n    Arrays.sort(l2);\n    for\
    \ (int i = 0; i < result.length; ++i)\n    {\n        if(l1[i] == l2[i])\n   \
    \         result[i] = l1[i];\n        else\n        {\n            int j;\n  \
    \          for(j=i; j < result.length && l1[j] == l2[j]; j++)\n            {\n\
    \            }\n            result[i] = l1[j];\n        }\n    }\n    return result;\n\
    }\n/* \nReturn set of numbers from 0 to n-1 which have two distinct prime factors,\
    \ \nand each of the factors occurs once in both the lists given.\n    >>> find_unique_prime_factors([2,3,5,7,11],\
    \ [2,3,5,11], [2,3,11], [2,11], [3,11], [7,11])\n    [2, 3, 5, 7, 11]\n    >>>\
    \ find_unique_prime_factors([2,3,5,7,11], [2,11], [2,11], [3,11], [7,11])\n  \
    \  [2, 7, 11]\n    >>> find_unique_prime_factors([], [2,3,5,7,11], [2,3,11], [2,11],\
    \ [3,11], [7,11])\n    [2, 3, 5, 7, 11]\n    >>> find_unique_prime_factors([],\
    \ [2,3,5,7,11], [2,11], [2,11], [3,11], [7,11])\n    [2, 7, 11]\n    >>> find_unique_prime_factors([],\
    \ [2,3,5,7,11], [2,11], [2,11], [3,11], [7,11])\n    [2, 7, 11]\n    >>> find_unique_prime_factors([2,3,5,7,11],\
    \ [2,3,11], [2,11], [3,11], [7,11])\n    [2, 3, 5, 7, 11]\n    >>> find_unique_prime_factors([2,3,5,7,11],\
    \ [2,11], [2,11], [3,11], [7,11])\n    [2, 7, 11]\n    >>> find_unique_prime_factors([2,3,5,7,11],\
    \ [2,11], [2,11], [3,11], [7,11])\n    [2, 7, 11]\n    >>> find_unique_prime_factors([2,3,5,7,11],\
    \ [2,11], [2,11], [3,11], [7,11])\n    [2, 7, 11]\n*/\nlong[] find_unique_prime_factors(long[]\
    \ l1, long[] l2, long[] l3, long[] l4, long[] l5)\n{\n    long[] common;\n   \
    \ long[] common2;\n    Arrays.sort(l1);\n    Arrays.sort(l2);\n    Arrays.sort(l3);\n\
    \    Arrays.sort(l4);\n    Arrays.sort(l5);\n    if(l1.length != l2.length ||\
    \ l1.length != l3.length || l1.length != ", "{\n    var n1 = l1.length;\n    var\
    \ n2 = l2.length;\n    if (n1 == 0 || n2 == 0)\n        return null;\n    var\
    \ maxLength = Math.min(n1, n2);\n    var hashmap = new LongHashMap<long>(maxLength);\n\
    \    // iterate over the first array\n    for (var i = 0; i < n1; i++) {\n   \
    \     hashmap.put(l1[i], l1[i]);\n    }\n    // iterate over the second array\n\
    \    for (var j = 0; j < n2; j++) {\n        var exists = hashmap.get(l2[j]);\n\
    \        if (exists != null) {\n            return exists;\n        }\n      \
    \  hashmap.put(l2[j], l2[j]);\n    }\n    return null;\n}", "{\n    var ans =\
    \ new long[32]; // maximum size 32\n    var i1 = 0;\n    var i2 = 0;\n    var\
    \ j1 = 0; // i1[j1] is first common element with i2[j2]\n    var j2 = 0; // j1[j2]\
    \ is first common element with i2[j1]\n    while (j1 < 32 && i2 < 32) {\n    \
    \    ans[j1++] = l1[i1++];\n        ans[j2++] = l2[i2++];\n    }\n    while (j1\
    \ < 32) {\n        ans[j1++] = l1[i1++];\n    }\n    while (j2 < 32) {\n     \
    \   ans[j2++] = l2[i2++];\n    }\n    return ans;\n}\n</code>\n<|/ a tags=sorting,algorithm,performance\
    \ dscore=1 |>\n<| c |>\nThis is a very nice solution. Thank you! However, it has\
    \ the same complexity as my original algorithm, which is O(n*log(n)), and not\
    \ O(n), which I would have expected to be at least O(n).\n<|/ c |>\n<| c |>\n\
    The inner while loop can be simplified to \"while(j1 < j2)\"\n<|/ c |>\n<| a tags=sorting,algorithm,performance\
    \ dscore=1 |>\nI would have thought this would be a problem that has been solved\
    \ before in linear time. Maybe it would be worthwhile to try to research how to\
    \ solve this problem efficiently.\n<|/ a |>\n<| a |>\nI have an algorithm that\
    \ is essentially O(n). Just for fun, I have written it using recursion, and it\
    \ is O(n), too.\n<code>", "{\n    long count = 0;\n    for(int i = 0; i < l1.length;\
    \ i++){\n        if(l1[l1[i]] == l2[l2[i]]) count++;\n    }\n    long[] result\
    \ = new long[count];\n    for(int i = 0; i < result.length; i++){\n        if(l1[l1[i]]\
    \ == l2[l2[i]]) result[i] = l1[i];\n    }\n    Arrays.sort(result);\n    return\
    \ result;\n}\n/*\nReturn sorted unique common elements for two arrays.\n    >>>\
    \ common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]",
  "{\n    long[] res = new long[l1.length];\n    int j = 0;\n    for (int i = 0; i\
    \ < l1.length; i++) {\n        while (j < l2.length && l1[i] == l2[j]) j++;\n\
    \        if (j == l2.length)\n            res[i] = l1[i];\n    }\n    return res;\n\
    }", "{\n    long common = 0;\n    for(int i = 0; i < l1.length; i++){\n      \
    \  int comp = l1.compareAt(i, l2, 0);\n        if(comp == 0){\n            common++;\n\
    \            l1 = l1.removeAt(i);\n            l2 = l2.removeAt(i);\n        }\n\
    \    }\n    long sum = 0;\n    for(int i = 0; i < l1.length; i++){\n        if(l1.getAt(i)\
    \ == l2.getAt(i)){\n            sum++;\n        }\n    }\n    long[] resArr =\
    \ new long[common];\n    int index = 0;\n    for(int i = 0; i < l1.length; i++){\n\
    \        if(l1.getAt(i) == l2.getAt(i)){\n            resArr[index++] = l1.getAt(i);\n\
    \        }\n    }\n    return resArr;\n}\n</code>\n<|/ a tags=arrays,algorithm,sorting\
    \ |>\n<| a dscore=1 tags=arrays,algorithm,sorting |>\nThis python code works,\
    \ provided no two elements have the same value:\n<code>\ndef common(l1,l2):\n\
    \    common = []\n    for i in l1:\n        if i not in l2 and i not in common:\n\
    \            common.append(i)\n    for j in l2:\n        if j not in l1 and j\
    \ not in common:\n            common.append(j)\n    return common\n</code>\n<|/\
    \ a |>\n<| c |>\nThis won't work with the example given in the question where\
    \ `common([1,3,5],[1,5])`\n<|/ c |>\n<| c |>\nThis answer is wrong. It does not\
    \ return the right answer for this example.\n<|/ c |>\n<| c |>\nThe question is\
    \ asking for unique elements not common elements.\n<|/ c |>\n<| c |>\nThe example\
    \ in the question was a mistake by OP who corrected it after I wrote the answer,\
    \ the code in this answer doesn't work anymore. `common([1,3,5],[1,5])` returns\
    \ `[1,3,5]` but OP wants `[5,3]` instead\n<|/ c |>\n<| c |>\nYour code will return\
    \ `[]` in that case, but OP wants `[1]` instead.\n<|/ c |>\n<| a tags=arrays,algorithm,sorting\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\
    import java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;", "{\n\
    \    long common = l1[0];\n    for(int i = 1; i < l1.length; i++){\n        if(l1[i]\
    \ == common){\n            for(int j = 0; j < l2.length; j++){\n             \
    \   if(l2[j] == common)\n                    return new long[] {common};\n   \
    \         }\n        }\n    }\n    return new long[0];\n}\n</code>\n<|/ a tags=c#,arrays\
    \ |>\n<| c |>\nI don't understand what you mean. Do you mean I should sort the\
    \ list before I find the common ones? Or what do you mean?\n<|/ c |>\n<| c |>\n\
    , I have no idea what do you mean\n<|/ c |>\n<| c |>\nI mean the example I gave\
    \ in my question has some mistakes so if you take a closer look you will see that\
    \ it will return one element instead of two. I want to fix that so I can get correct\
    \ answer\n<|/ c |>\n<| c |>\n- I edited my answer, does it work for you now? I\
    \ have tested this with your example.\n<|/ c |>\n<| c |>\nI tested your solution\
    \ with the example and got correct results but when I test it with the code I\
    \ posted in my question, it gives me wrong results. I did some research and found\
    \ that in your solution, you do not care about the first element. What I mean\
    \ is that the first element is not important for my solution. I will appreciate\
    \ if you could help me with that as well\n<|/ c |>\n<| a dscore=0 |>\nA very simple\
    \ solution I came up with:\n<code>\npublic static void Main()\n{\n    string[]\
    \ input = {\n        \"foo\",\n        \"bar\",\n        \"foo\",\n        \"\
    baz\",\n        \"bar\"\n    };", "{\n    long[] res = new long[l1.length];\n\
    \    for(int i=0; i<l1.length; i++) \n    {\n        for(int j=0; j<l2.length;\
    \ j++) \n        {\n            if(l1[i] == l2[j]) \n            {\n         \
    \       res[res.length-1] = l1[i];\n            }\n        }\n    }\n    return\
    \ res;\n}\n</code>\n<|/ a tags=c# dscore=0 |>\n<| a dscore=0 |>\n<code>\npublic\
    \ static IEnumerable<T> Intersect<T>(this IEnumerable<T> first, IEnumerable<T>\
    \ second)\n    {\n        List<T> firstList = first.ToList();\n        List<T>\
    \ secondList = second.ToList();", "{\n  int i = 0;\n  int j = 0;\n  int k = 0;\n\
    \  while (i<l1.length && j<l2.length) {\n    if (l1[i] == l2[j]) {\n      i++;\n\
    \      j++;\n    } else if (l1[i] < l2[j]) {\n      k++;\n      i++;\n    } else\
    \ {\n      k++;\n      j++;\n    }\n  }\n  while (i<l1.length) {\n    k++;\n \
    \   i++;\n  }\n  while (j<l2.length) {\n    k++;\n    j++;\n  }\n  return Arrays.copyOf(new\
    \ long[k], k);\n}\n</code>\n<|/ a tags=arrays,java,sorting dscore=0 |>\n<| a |>\n\
    <code>\nfunction common(arr1, arr2) {\n  let map1 = arr1.reduce((obj, el) => {\
    \ obj[el] = 1; return obj }, {});\n  let map2 = arr2.reduce((obj, el) => { obj[el]\
    \ = 1; return obj }, {});\n  return [...new Set([...map1, ...map2]).values()];\n\
    }\n</code>\n<|/ a tags=arrays,java,sorting dscore=0 |>\n<| a tags=arrays,java,sorting\
    \ |>\nI have written a method using Java 8 streams which is almost in line with\
    \ what I think the algorithm describes.\n<code>\nimport java.util.Arrays;", "{\n\
    \    long[] result = new long[l1.length + l2.length];\n    for(int i=0; i<l1.length;\
    \ i++) {\n        if(l2[i] > l1[i]) \n            result[i] = l2[i];\n       \
    \ else\n            result[i] = l1[i];\n    }\n    for(int j=0; j<l2.length; j++)\
    \ {\n        if(l2[j] > l1[j]) {\n            for(int k=j+1; k<l2.length && l2[k]\
    \ == l1[k]; k++) {\n                result[k] = result[k-1];\n            }\n\
    \        }\n    }\n    return result.slice(0,result.length-1);\n}\n</code>\n<|/\
    \ a tags=java,algorithm,arrays,c++,sorting |>\n<| c |>\nThanks for the code. Is\
    \ there any way to achieve complexity of O(logn) for this approach?\n<|/ c |>\n\
    <| c |>\nNope, since the algorithm is `O(n)`. Even with O(log n) additional space,\
    \ O(n log n) is still O(n).\n<|/ c |>\n<| c |>\nThe sort can be done in O(n log\
    \ n) time, but not the search, which can be done in O(n) time.  Since each element\
    \ of the array is less than the previous element, at most n comparisons will be\
    \ made.  So the total is O(n log n).\n<|/ c |>\n<| c |>\nIt doesn't seem to work,\
    \ at least for me. Try with input `[1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]`. I get `[34L, 4L, 653L, 2L, 5L, 7L, 9L, 1L, 5L, 653L, 121L]`,\
    \ which is not correct as `653` should appear before `1`.\n<|/ c |>\n<| c |>\n\
    Ah, I think I see what you mean.  I added a solution which does work in O(n log\
    \ n) time.\n<|/ c |>\n<| a tags=java,algorithm,arrays,c++,sorting dscore=1 |>\n\
    Java code (tested with your example):\n<code>\nimport java.util.ArrayList;\nimport\
    \ java.util.Collections;", "{\n   long[] ans = new long[l1.length];\n   int i\
    \ = 0, j = 0;\n   while ( i < l1.length &&  j < l2.length)\n   {\n      if (l1[i]\
    \ < l2[j])\n      {\n         ans[j++] = l1[i++];\n      }\n      else\n     \
    \ {\n         ans[j++] = l2[j++];\n      }\n   }\n   return ans;\n}\n/*\nReturn\
    \ unique common elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]", "{\n    long[]\
    \ res = new long[l1.length+l2.length];\n    for(int i = 0; i < res.length; ++i)\n\
    \        res[i] = -1;\n    Arrays.sort(l1);\n    Arrays.sort(l2);\n    for(int\
    \ i = 0; i < (l1.length+l2.length); ++i)\n    {\n        if (l1[i] == l2[i])\n\
    \        {\n            if (l1[i] == 0)\n                res[i] = 0;\n       \
    \     else\n                res[i] = l1[i];\n        }\n        else\n       \
    \ {\n            if (l1[i] > l2[i])\n            {\n                res[i] = l2[i];\n\
    \                res[l1.length+i] = l1[i];\n            }\n            else\n\
    \            {\n                res[i] = l1[i];\n                res[l1.length+i]\
    \ = l2[i];\n            }\n        }\n    }\n    return res;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis code produces wrong result. See the comment I added on the\
    \ question for details.\n<|/ c |>\n<| a dscore=1 |>\nThis is my attempt at doing\
    \ this in O(n) time and O(1) space. As others have said, there are some problems\
    \ with the code, but I think this one does what you're looking for. I've used\
    \ the std.algorithms library as I've found it very useful, and haven't written\
    \ a line of code in OCaml for a while now so I'm not really sure how idiomatic\
    \ OCaml code is.\nBasically, you just sort the two arrays and then perform a binary\
    \ search on each array. I've left my code commented for anyone who wants to understand\
    \ the details. I'm sure you can easily translate it into OCaml syntax if you need.\n\
    <code>\nlet rec common_elements [] = \n    []", "{\n\tl1 = sort(l1);\n\tl2 = sort(l2);\n\
    \tint i,j;\n\tlong[] l = new long[l1.length+l2.length];\n\tfor (i=0; i<l1.length;i++)\n\
    \t\tl[i]=l1[i];\n\tfor (i=0; i<l2.length;i++)\n\t\tl[i+l1.length]=l2[i];\n\tsort(l);\n\
    \treturn l;\n}", "{\n    long[] result = new long[l1.length];\n    for(int i =\
    \ 0; i < l1.length; i++) {\n        for(int j = 0; j < l2.length; j++) {\n   \
    \         if(l1[i] == l2[j]) {\n                result[i] = l1[i];\n         \
    \       break;\n            }\n        }\n    }\n    return std.sort(result);\n\
    }\n</code>\n<|/ a tags=java,arrays,algorithm dscore=1 |>\n<| c |>\nYour solution\
    \ is more efficient than mine but still it is worst case time complexity\n<|/\
    \ c |>\n<| c |>\nThis solution is definitely worst case complexity, but it's better\
    \ than the most voted answer when compared to the other solutions.\n<|/ c |>\n\
    <| c |>\nIt has more efficient in memory consumption, though it is still linear\
    \ and worst case time complexity - O(n^2)\n<|/ c |>\n<| a |>\nThis is how I solved\
    \ my problem:\n<code>\npublic static long common(Object[] a, Object[] b)\n{\n\
    \    long c = 0, d = 0;\n    for (Object x : a)\n        for (Object y : b)\n\
    \            if (x.equals(y))\n                c += 1;\n            for (Object\
    \ z : b)\n                if (x.equals(z))\n                    d += 1;\n    return\
    \ c + d;\n}\n</code>\n<|/ a dscore=1 tags=java,arrays,algorithm |>\n<| c |>\n\
    It should be noted that the performance of this is not better than the other answers,\
    \ and it's still linear and worst case time complexity - O(n^2)\n<|/ c |>\n<|\
    \ a tags=java,arrays,algorithm |>\nMy code has one for loop which iterates through\
    \ first array and one for loop which iterates through second array.\n<code>\n\
    public static void main(String[] args) {\n    int [] first = new int[10];\n  \
    \  int [] second = new int[10];\n    for(int i = 0; i < 10; i++)\n        first[i]\
    \ = i;\n    for(int j = 1; j < 10; j++)\n        second[j] = j;\n    \n    for(int\
    \ i = 0; i < first.length; i++)\n    {\n        for(int j = 0; j < second.length;\
    \ j++)\n        {\n            if(first[i] == second[j])\n                System.out.println(first[i]);\n\
    \        }\n    }\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nYou can sort\
    \ the arrays and then compare.\n<|/ a tags=java,arrays,algorithm |>\n<| c |>\n\
    But that would take O(nlogn) time\n<|/ c |>\n<| c |>\nYes, it would take O(nlogn).\
    \ But the sort method will take O(n*log(n))", "{\n\tint i, j = 0;\n\tlong[] res\
    \ = new long[l1.length];\n\tfor(i = 0, j = 0; i < l1.length; i++)\n\t{\n\t\tif(l1[i]\
    \ == l2[j]) {\n\t\t\tres[i] = l1[i];\n\t\t\tj++;\n\t\t} else\n\t\t{\n\t\t\tif(j\
    \ == 0)\n\t\t\t{\n\t\t\t\tj++;\n\t\t\t\tres[i] = l1[i];\n\t\t\t}\n\t\t\telse\n\
    \t\t\t{\n\t\t\t\tj--;\n\t\t\t\tres[i] = l2[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ res;\n}\n\t\n/*\nReturn unique common elements for two arrays.\n    >>> uniqueCommon([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> uniqueCommon([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n\
    \    int i = 0, j = 0;\n    long[] out = new long[l1.length+l2.length];\n    while\
    \ (i < l1.length && j < l2.length) {\n        if (l1[i] < l2[j]) {\n         \
    \   out[i++] = l1[i++];\n        } else if (l1[i] == l2[j]) {\n            out[i++]\
    \ = l1[i++];\n            out[j++] = l2[j++];\n        } else {\n            out[i++]\
    \ = l2[j++];\n        }\n    }\n    while (i < l1.length) {\n        out[i++]\
    \ = l1[i++];\n    }\n    while (j < l2.length) {\n        out[j++] = l2[j++];\n\
    \    }\n    return out;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=collections,java\
    \ dscore=2 |>\nThis code will return the common elements between two arrays and\
    \ store the result in the third array.\n<code>\npublic class CommonElements\n\
    {\n   public static void main(String[] args)\n   {\n      int[] a = {1,2,3,4,5,6};\n\
    \      int[] b = {4,5,6,7,8,9,0};\n      \n      int[] c = new int[a.length];\n\
    \      \n      int i,j;\n      \n      for(i=0;i<a.length;i++)\n      {\n    \
    \     for(j=0;j<b.length;j++)\n         {\n            if(a[i]==b[j])\n      \
    \      {\n               c[i]=b[j];\n               break;\n            }\n  \
    \       }\n      }\n      \n      for(int k=0;k<c.length;k++)\n      {\n     \
    \    System.out.println(c[k]);\n      }\n   }\n}\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\n<code>\npublic static int[] common(int[] a, int[] b) {", "{\n    long[]\
    \ l = new long[256];\n    int i = 0;\n    int j = 0;\n    while(i < l1.length\
    \ && j < l2.length) \n    {\n        if(l1[i] < l2[j]) {\n            l[i++] =\
    \ l1[i];\n        }\n        else {\n            l[i++] = l2[j];\n        }\n\
    \        j++;\n    }\n    while(i < l1.length) \n    {\n        l[i++] = l1[i];\n\
    \    }\n    while(j < l2.length) \n    {\n        l[i++] = l2[j];\n    }\n   \
    \ std.arraysort(l);\n    return l;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`common`\
    \ and `sorted` aren't in the standard library.\n<|/ c |>\n<| c |>\nThe `common`\
    \ function is just a translation of the `unique` function from the `std` library.\n\
    <|/ c |>\n<| c |>\nHmm. Good point. I thought this was supposed to be a self-answered\
    \ question. Sorry about that.\n<|/ c |>\n<| c |>\nI'm sorry. I was looking at\
    \ the answer to [this question](http://stackoverflow.com/questions/9193262/c-code-to-find-the-largest-common-element-array-not-sorting-it)\
    \ and thought that it was just a translation from some `std.typecons` function,\
    \ rather than the actual `common` function. I was wrong. Thanks for making me\
    \ aware.\n<|/ c |>\n<| c |>\n`l2.length` should be `l1.length`\n<|/ c |>\n<| a\
    \ |>\nI wrote an example for comparing two arrays with the following results:\n\
    <code>\n[6, 4, 7, 2]  --> [6, 7, 4, 2]\n[1, 2, 2, 3]  --> [1, 2, 3]\n[2, 4, 5,\
    \ 3]  --> [4, 5]\n</code>\nHere's the code for it:\n<code>", "{\n\tlong temp;\n\
    \tfor (int i = 0; i < l1.length; i++) {\n\t\tfor (int j = 0; j < l2.length; j++)\
    \ {\n\t\t\tif (l1[i] != l2[j]) {\n\t\t\t\tif (l1[i] < l2[j]) temp = l1[i];\n\t\
    \t\t\telse temp = l2[j];\n\t\t\t\tif (temp > 0) {\n\t\t\t\t\tl1[l1.length - 1]++;\n\
    \t\t\t\t\tl2[l2.length - 1]++;\n\t\t\t\t\tl1[i]++;\n\t\t\t\t\tl2[j]++;\n\t\t\t\
    \t}\n\t\t\t}\n\t\t}\n\t}\n\treturn l1;\n}\n/*\nReturn sorted unique common elements\
    \ for two arrays in sorted order.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L,\
    \ 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]", "{\n\tlong [] c1 = new long[10000], c2\
    \ = new long[10000], i, j, k, l;\n\tbool found;\n\t\n\tk = 0;\n\tfor (i = 0; i\
    \ < l1.length && k < c1.length; i++) \n\t{\n\t\tif (l1[i] > c2[k]) \n\t\t{\n\t\
    \t\tc1.length = k;\n\t\t\tc2 = new long[k];\n\t\t\tk = 0;\n\t\t}\n\t\tfound =\
    \ false;\n\t\tfor (j = 0; j < l2.length && k < c2.length; j++) \n\t\t{\n\t\t\t\
    if (l2[j] == c1[k]) \n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\
    \t\t}\n\t\tif (!found) \n\t\t{\n\t\t\tc1.length = k;\n\t\t\tc2 = new long[k];\n\
    \t\t\tk = 0;\n\t\t}\n\t\t\n\t\tc2[k] = l1[i];\n\t\tk++;\n\t}\n\tif (k < c1.length)\
    \ \n\t{\n\t\tc1.length = k;\n\t}\n\t\n\tk = 0;\n\tfor (i = 0; i < l2.length &&\
    \ k < c2.length; i++) \n\t{\n\t\tif (l2[i] > c1[k]) \n\t\t{\n\t\t\tc2.length =\
    \ k;\n\t\t\tc1 = new long[k];\n\t\t\tk = 0;\n\t\t}\n\t\tfound = false;\n\t\tfor\
    \ (j = 0; j < l1.length && k < c1.length; j++) \n\t\t{\n\t\t\tif (l2[j] == c1[k])\
    \ \n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\
    \ \n\t\t{\n\t\t\tc2.length = k;\n\t\t\tc1 = new long[k];\n\t\t\tk = 0;\n\t\t}\n\
    \t\t\n\t\tc1[k] = l2[i];\n\t\tk++;\n\t}\n\tif (k < c2.length) \n\t{\n\t\tc2.length\
    \ = k;\n\t}\n\t\n\treturn c1;\n}", "{\n    long common = 0;\n    int n = l1.length;\n\
    \    int m = l2.length;\n    for(int i = 0; i < m; i++){\n        for(int j =\
    \ 0; j < n; j++){\n            if(l1[i] < l2[j] && (l1[i] != 0 || (l2[j] != 0\
    \ && l1[j] == l2[j]))){\n                common = l1[i];\n                break;\n\
    \            }\n        }\n    }\n    long[] ns = new long[m];\n    ns[0] = common;\n\
    \    for (int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n     \
    \       if(l1[i] == l2[j]){\n                ns[i+1] = l1[i];\n              \
    \  break;\n            }\n        }\n    }\n    return ns;\n}", "{\n\tvar l1 =\
    \ l1 || l1;\n\tvar l2 = l2 || l2;\n\tvar l3 = new long[l1.length+l2.length];\n\
    \tvar j = 0;\n\t\n\twhile (j < l1.length && j < l2.length) \n\t{\n\t\tif (l1[j]\
    \ == l2[j]) \n\t\t{\n\t\t\tl3[j++] = l1[j];\n\t\t} \n\t\telse \n\t\t{\n\t\t\t\
    break;\n\t\t}\n\t}", "{\n    long[] cL1 = l1;\n    long[] cL2 = l2;\n    long[]\
    \ cResult = new long[l1.length];\n    long current;\n    for (int i = 0; i < l1.length;\
    \ i++) {\n        if (l1.length > 1) {\n            current = cL1[i];\n      \
    \      cL1[i] = cL2[i];\n            cL2[i] = current;\n        }\n        if\
    \ (l2.length > 1) {\n            current = cL2[i];\n            cL2[i] = cL1[i];\n\
    \            cL1[i] = current;\n        }\n    }\n    Arrays.sort(cL1);\n    Arrays.sort(cL2);\n\
    \    for (int i = 0; i < l1.length; i++) {\n        cResult[i] = cL1[i];\n   \
    \ }\n    for (int i = 0; i < l2.length; i++) {\n        cResult[l1.length+i] =\
    \ cL2[i];\n    }\n    return cResult;\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=arrays,algorithm,java,sorting\
    \ |>\n<code>\npublic static int[] common(int[] a, int[] b) {\n    HashMap<Integer,\
    \ Integer> map = new HashMap<Integer, Integer>();\n    int[] result = new int[a.length];\n\
    \    int counter = 0;\n    for (int i = 0; i < a.length; i++) {\n        if (!map.containsKey(a[i]))\
    \ {\n            map.put(a[i], 0);\n        }\n        int j = map.get(a[i]);\n\
    \        if (b[j] == a[i]) {\n            counter++;\n        }\n    }\n    for\
    \ (int i = 0; i < b.length; i++) {\n        if (!map.containsKey(b[i])) {\n  \
    \          map.put(b[i], 0);\n        }\n        int j = map.get(b[i]);\n    \
    \    if (counter == j && map.get(a[i]) == j) {\n            result[counter] =\
    \ a[i];\n            counter++;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI think this is wrong. `common([1], [2])` should be `common([1,\
    \ 2], [2])`, but your code returns `[2]` instead of `[1, 2]`\n<|/ c |>\n<| c |>\n\
    It works correctly, if input arrays are sorted.\n<|/ c |>\n<| c |>\nBut `common([1,2],[1,2])`\
    \ should be `common([1,2],[2])`, but your code returns `[2]` instead of `[1,2]`\n\
    <|/ c |>\n<| c |>\nYou're right, i missed that one. Thanks for pointing it out.\n\
    <|/ c |>\n<| a tags=arrays,algorithm,java,sorting dscore=0 |>\n<code>\npublic\
    \ static void main(String args[])\n{\n        int[] a = {1, 3, 6};\n        int[]\
    \ b = {2, 5, 6};\n        System.out.println(\"Common elements:\"+common(a,b));\n",
  "{\n\tlong[] result = new long[l1.length];\n\tfor (int i = 0; i < l1.length; i++)\
    \ \n\t{\n\t\tfor (int j = 0; j < l2.length; j++)\n\t\t{\n\t\t\tif (l1[i] == l2[j])\n\
    \t\t\t{\n\t\t\t\tresult[i] = l1[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturns true if the two arrays are equal.\n    >>> compare([4L,\
    \ 3L, 4L, 2L], [4L, 3L, 2L, 4L])\n    True\n*/", "{\n    int n = l1.length;\n\
    \    int m = l2.length;\n    long[] result = new long[n];\n    int j = 0;\n  \
    \  int i;\n    for (int k = 0; k < m; k++)\n    {\n        for (i=0; i < n; i++)\n\
    \        {\n            if (l1[i] == l2[k])\n            {\n                result[j++]\
    \ = l1[i];\n                break;\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n  var l3 = new long[l1.length];\n  for(int i = 0; i < l1.length;\
    \ i++) \n  {\n    for(int j = 0; j < l2.length; j++)\n    {\n      if(l1[i] ==\
    \ l2[j])\n        l3[i] = l1[i];\n    }\n  }\n  return l3;\n}\n</code>\n<|/ a\
    \ tags=algorithm,arrays dscore=4 |>\n<| c |>\nNice answer. Especially the part\
    \ where you explain how this works, it makes it easier to understand for newbies\
    \ like me. Thanks!\n<|/ c |>\n<| c |>\nI find it strange that you use `l1.length`\
    \ in the inner loop when that array can change size since you just copy the length\
    \ of `l1`.\n<|/ c |>\n<| c |>\nIn fact, my code can be replaced by this one line:\
    \ \nvar l3= l1.Intersect(l2).ToArray();\n<|/ c |>\n<| c |>\nNot sure what you\
    \ are talking about. `l3` isn't changing in my code, so I don't really see how\
    \ it could change. Are you referring to the `var`? The `ToArray` method returns\
    \ a new array, so that line is just converting a sequence of intersected `long`s\
    \ to a sequence of their `ToString` equivalents.\n<|/ c |>\n<| c |>\nYes, the\
    \ var l3. Apologies for my unclear explanation!\n<|/ c |>\n<| a dscore=4 |>\n\
    You can use the merge function from System.Linq:\n<code>\nvar myArray = new[]\
    \ {1, 4, 3, 1, 3, 6, 3};\nvar myArray2 = new[] {5, 7, 1, 5, 9, 653};", "{\n\t\
    long[] l3 = new long[l1.length];\n\tint i;\n\tfor(i = 0; i < l1.length; i++) \n\
    \t{\n\t\tint j;\n\t\tfor(j = 0; j < l2.length; j++) \n\t\t{\n\t\t\tif(l1[i] ==\
    \ l2[j] && l1[i] != 0) \n\t\t\t{\n\t\t\t\tl3[i] = l1[i];\n\t\t\t\tbreak;\n\t\t\
    \t}\n\t\t}\n\t\tif(j == l2.length) \n\t\t{\n\t\t\tl3[i] = l1[i];\n\t\t}\n\t}\n\
    \treturn l3;\n}", "{\n\tlong[] ret = new long[l1.length];\n\tint i = 0, j = 0;\n\
    \twhile (i < l1.length && j < l2.length) \n\t{\n\t\tif (l1[i] == l2[j]) \n\t\t\
    {\n\t\t\tret[j] = l1[i]; \n\t\t\t++j;\n\t\t} \n\t\telse \n\t\t{\n\t\t\t++i;\n\t\
    \t}\n\t}\n\t\n\twhile (i < l1.length)\n\t{\n\t\tret[j++] = l1[i];\n\t\t++i;\n\t\
    }\n\twhile (j < l2.length)\n\t{\n\t\tret[i++] = l2[j];\n\t\t++j;\n\t}\n\treturn\
    \ ret;\n}", "{\n\tlong[] res = new long[1000];\n\tint i = 0;\n\twhile (l1.length\
    \ > 0 && l2.length > 0) {\n\t\tif (l1.length > l2.length) {\n\t\t\tres[i] = l1[l1.length\
    \ - 1];\n\t\t\ti++;\n\t\t\tl1.pop();\n\t\t} else {\n\t\t\tres[i] = l2[l2.length\
    \ - 1];\n\t\t\ti++;\n\t\t\tl2.pop();\n\t\t}\n\t}\n\twhile (l1.length > 0) res[i++]\
    \ = l1[l1.length - 1];\n\twhile (l2.length > 0) res[i++] = l2[l2.length - 1];\n\
    \treturn res;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
