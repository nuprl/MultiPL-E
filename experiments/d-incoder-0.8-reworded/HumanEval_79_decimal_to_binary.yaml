name: HumanEval_79_decimal_to_binary
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nYou will be given a number in\
  \ decimal form and your task is to convert it to\n    binary format. The function\
  \ should return a string, with each character representing a binary\n    number.\
  \ Each character in the string will be '0' or '1'.\n\n    There will be an extra\
  \ couple of characters 'db' at the beginning and at the end of the string.\n   \
  \ The extra characters are there to help with the format.\n\n    Examples:\n   \
  \ >>> decimal_to_binary(15L)\n    \"db1111db\"\n    >>> decimal_to_binary(32L)\n\
  \    \"db100000db\"\n    \n*/\nstring decimal_to_binary(long decimal) \n"
tests: "unittest\n{\n    alias candidate = decimal_to_binary;\n\n    assert(candidate(0L)\
  \ == \"db0db\");\n    assert(candidate(32L) == \"db100000db\");\n    assert(candidate(103L)\
  \ == \"db1100111db\");\n    assert(candidate(15L) == \"db1111db\");\n}\nvoid main(){}"
completions: ["{\n    int bits;\n    int decimalInt = decimal;\n    string bin = \"\
    \";\n    int decimalRemainder = decimalInt;\n    while( decimalRemainder > 0)\n\
    \    {\n        decimalRemainder = decimalRemainder % 2;\n        bin = bits_to_bin(decimalRemainder)\
    \ + bin;\n        decimalRemainder = decimalInt / 2;\n    }\n    bin = bits_to_bin(decimalRemainder)\
    \ + bin;\n    return bin + \"db\";\n}", "{\n    string result = \"\";\n    long\
    \ remainder = decimal;\n    while(remainder > 0)\n    {\n        remainder--;\n\
    \        result[result.length()] = remainder % 2 == 0 ? '1' : '0';\n        remainder\
    \ = remainder / 2;\n    }\n    result[result.length()] = 'b'; // 'b' is the extra\
    \ character\n    result[result.length()] = 'b';\n    return result;\n}\n</code>\n\
    <|/ a tags=c++ dscore=0 |>\n<| c |>\nI understand your code, but i need to find\
    \ the number of times each number occurs in given string . so what i was thinking\
    \ is i have to store each character in a separate array and use for loop to compare\
    \ each char and increment the count when ever i found a match.\n<|/ c |>\n<| c\
    \ |>\nYes, that's exactly what my code is doing.\n<|/ c |>\n<| c |>\nHi, i tried\
    \ your code, but it is giving wrong answer and i can not find the reason behind\
    \ it. can you please help.\n<|/ c |>\n<| c |>\nCan you give an example with input\
    \ and output that gives the wrong answer?\n<|/ c |>\n<| a |>\n<code>\n#include<iostream>\n\
    #include<string>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\nstring\
    \ decimal_to_binary(long decimal)\n{\n  string binary;\n  long remainder = decimal;\n\
    \  while(remainder > 0)\n  {\n     binary += remainder % 2 == 0 ? \"1\" : \"0\"\
    ;\n     remainder = remainder / 2;\n  }\n  return binary;\n}", "{\n    string\
    \ binary = \"\";\n    int temp = decimal;\n    while(temp > 0) {\n        int\
    \ remainder = temp % 2;\n        temp = temp / 2;\n        binary += \"0\" + remainder;\n\
    \    }\n    \n    return \"db\" + binary + \"db\";\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI believe this does not produce the correct output: for example,\
    \ if `decimal` is `15`, then you output `\"db1111db\"`, but the correct output\
    \ is `\"db111110db\"`.\n<|/ c |>\n<| c |>\nyou're right, I fixed the code in the\
    \ answer, please test it again.\n<|/ c |>\n<| c |>\nIt seems you are still not\
    \ handling negative numbers.\n<|/ c |>\n<| c |>\nYou're right, I fixed the code\
    \ in the answer, please test it again.\n<|/ c |>\n<| c |>\nI tested it again with\
    \ Python. I am afraid it is still wrong: for example, `decimal_to_binary(15)`\
    \ returns `\"01111db\"` instead of `\"db111110db\"`.\n<|/ c |>\n<| a |>\nI believe\
    \ this can help you: \n<code>\n    string decimal_to_binary(long decimal) \n{\n\
    \    string binary = \"\";\n    int temp = decimal;\n    while(temp > 0) {\n \
    \       int remainder = temp % 2;\n        temp = temp / 2;\n        binary +=\
    \ \"0\" + remainder;\n    }\n    binary = binary.ToUpper();", "{\n    stringstream\
    \ ss;\n    ss.str(\"00000\");\n    \n    for(long i = 1; i <= decimal; i++){\n\
    \        if(decimal % i == 0){\n            int index = decimal / i;\n       \
    \     string s = ss.str() + to_string(index);\n            ss << s;\n        }\n\
    \    }\n    \n    string final = ss.str();\n    final = final+\"db\";\n    \n\
    \    return final;\n}", "{\n    string output=\"\";\n    unsigned long pow10=decimal;\n\
    \    for(int i=0;i<(int)pow10;i++) {\n        output+=\"1\";\n    }\n    \n  \
    \  pow10=decimal/2;\n    for(int i=0;i<(int)pow10;i++) {\n        output+=\"1\"\
    ;\n    }\n    return output;\n}\n</code>\n<|/ a |>\n<| c |>\nIn case anyone wants\
    \ a C++ version and a slightly more efficient version: https://stackoverflow.com/a/64853341/3119651\n\
    <|/ c |>\n<| a dscore=0 tags=python,c,java,algorithm |>\nI made a function in\
    \ python that would do this for you, I think it's the most concise solution to\
    \ my question. The python code is as follows:\n<code>\n#this function takes an\
    \ integer and returns its binary representation as a string\ndef decimal_to_binary(num):\n\
    \    #this function returns the decimal equivalent of the binary number from 0-9\n\
    \    def to_decimal(binary_str):\n        decimal = 0\n        for char in binary_str:\n\
    \            decimal = decimal * 2 + int(char)\n        return decimal", "{\n\
    \    if(decimal == 0)\n    {\n        return \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  "{\n    char string[128];\n    long remainder;\n    int count;", "{\n    string\
    \ binary = \"\";\n    int remainder = decimal;", "{\n    long decimal_bits = decimal;\n\
    \    long digits_count = bitCount(decimal_bits);\n    \n    // get the number\
    \ of digits required to represent the number\n    int num_digits = digits_count\
    \ + 1;\n    string binary_string = bits_to_string(decimal_bits);\n    \n    //\
    \ get the extra characters in place\n    string db_string = to_string(digits_count\
    \ % 8);\n    num_digits += db_string.size();\n    \n    string result = \"\";\n\
    \    for(int i=0; i < num_digits; i++)\n    {\n        result += binary_string[i%binary_string.size()];\n\
    \    }\n    \n    if(num_digits % 8 != 0)\n    {\n        result += db_string;\n\
    \    }\n    return result;\n}", "{\n    string result = \"\";\n    long temp =\
    \ decimal;\n    while (temp != 0) {\n        if (temp % 2 == 0)\n        {\n \
    \           result += \"0\";\n            temp = temp / 2;\n        }\n      \
    \  else\n        {\n            result += \"1\";\n            temp = temp / 2;\n\
    \        }\n    }\n    return result + result;\n}", "{\n    long remainder = decimal\
    \ % 2;\n    decimal /= 2;\n    string binary = \"\";\n    for(int i = 0; i < 8;\
    \ i++){\n        if(remainder == 1){\n            binary = binary + \"1\";\n \
    \       }else{\n            binary = binary + \"0\";\n        }\n        remainder\
    \ = decimal % 2;\n        decimal /= 2;\n    }\n    return binary + \"db\" + decimal_to_binary(decimal);\n\
    }", "{\n    string result = \"\";\n    long binary = 0;\n    while(decimal>0)\n\
    \    {\n        binary = binary*10 + (decimal%2);\n        decimal = decimal/2;\n\
    \    }", "{\n    long counter = decimal;\n    string binary = \"000000000\";",
  "{\n    string result = \"\";", "{\n    string binary = \"db\";\n    int decimal_rem\
    \ = decimal;\n    string result = \"0\";\n    \n    while (decimal_rem > 0) \n\
    \    {\n        decimal %= 2;\n        binary += to_string(decimal);\n       \
    \ decimal /= 2;\n    }\n    \n    result += binary;\n    result += binary;\n \
    \   \n    return result = \"db\" + result + \"db\";\n}\n</code>\n<|/ a tags=c++,recursion,c,binary,string\
    \ |>\n<| a tags=c++,recursion,c,binary,string |>\nA more readable solution using\
    \ recursive functions:\n<code>\n#include <iostream>\n#include <string>", "{\n\
    \    string binary_form;\n    for(int i = 0; i < 32; i++)\n    {\n        binary_form.push_back('0');\n\
    \    }", "{\n    int b = 0;\n    string result = \"\";\n    while (decimal !=\
    \ 0) {\n        int digit = (int)(decimal % 2);\n        decimal = decimal >>\
    \ 1;\n        result += to_string(b) + \":\" + to_string(digit);\n        b++;\n\
    \    }\n    string returnString = \"db\" + result + \"db\";\n    return returnString;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThe `to_string` function is not defined in the\
    \ std namespace. Are you sure your code compiles?\n<|/ c |>\n<| a |>\nYou could\
    \ do the following:", "{\n    string result;\n    if (decimal < 0)\n    {\n  \
    \      result = \"db\" + decimal_to_binary(-decimal) + \"b\";\n    }\n    else\n\
    \    {\n        result = \"\";\n        while (decimal != 0)\n        {\n    \
    \        result += \"0\";\n            decimal /= 2;\n        }\n    }\n    result\
    \ += \"b\";\n    return result;\n}", "{\n    string binary = \"00000000000000000000000\"\
    ;", "{\n    if(decimal<0) //Negative numbers are represented in reverse order\
    \ with '1''s and zeroes.\n    {\n        decimal = -decimal;\n    }\n    string\
    \ answer = \"\";\n    while(decimal > 0)\n    {\n        if(decimal % 2 == 0)\n\
    \        {\n            answer = answer + \"1\";\n        }\n        else\n  \
    \      {\n            answer = answer + \"0\";\n        }\n        decimal = decimal\
    \ / 2;\n    }\n    answer += \"db\"; //Add an extra 'db' at the end for easier\
    \ formatting.\n    return answer;\n}\n</code>\n<|/ a tags=c#,python,java dscore=0\
    \ |>\n<| c |>\nWhile this code may solve the problem, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| c |>\nThis does not answer the question. Why do you think\
    \ it does?\n<|/ c |>\n<| a tags=c#,python,java |>\n<code>\nfunction decimal_to_binary\
    \ (decimal) {\n    var binary = '';\n    var remainder;\n    var decimalString\
    \ = decimal.toString(2);", "{\n    string str=\"db\";\n    decimal div=decimal%2;\n\
    \    while(decimal>0)\n    {\n        decimal=decimal/2;\n        str=str+\"1\"\
    +\"0\";\n    }\n    str=str.substr(0,str.length()-2)+\"db\";\n    return str;\n\
    }\n/* Do not print anything to the console! */", "{\n    return to_string(decimal);\n\
    }\n</code>\n<|/ a tags=c++ |>\n<| c |>\nNice way to convert numbers to binary\
    \ strings. But it doesn't work for the example `decimal_to_binary(15L)`.\n<|/\
    \ c |>\n<| c |>\n: Fixed now, thanks.\n<|/ c |>\n<| a tags=c++ |>\n<code>\n#include\
    \ <iostream>\n#include <string>\nusing namespace std;", "{\n    string result;\n\
    \    int remainder;\n    \n    if (decimal > 0)\n    {\n        remainder = decimal\
    \ % 2;\n        result = \"db\" + tostring(remainder);\n        decimal /= 2;\n\
    \        while (decimal > 0)\n        {\n            remainder = decimal % 2;\n\
    \            result = \"db\" + tostring(remainder) + result;\n            decimal\
    \ /= 2;\n        }\n    }\n    \n    return result;\n}\n</code>\n<|/ a |>\n<|\
    \ a tags=c++,c++11 |>\nHere is my take. I'm sure it could be optimised but it's\
    \ just to demonstrate the basic principles.\n<code>\n#include <iostream>\n#include\
    \ <iomanip>", '{', "{\n    string binary = \"\";\n    int power = 1;\n    while\
    \ (decimal > 0) \n    {\n        decimal /= 2;\n        power = power + 1;\n \
    \   }\n    while (power > 0) \n    {\n        binary += decimal_to_binary[power];\n\
    \        power = power - 1;\n    }\n    int remainder = decimal;\n    if (binary.Length\
    \ != remainder) \n    {\n        binary = binary + '0';\n    }\n    return binary\
    \ + 'db';\n}", "{\n    string binary = \"\";\n    long remainder = 0;\n    int\
    \ count = 0;\n    while(decimal > 0)\n    {\n        remainder = decimal % 2;\n\
    \        decimal /= 2;\n        count++;\n        binary += (char)remainder;\n\
    \    }\n    int remainder2 = decimal;\n    int count2 = 0;\n    while(decimal\
    \ != 0)\n    {\n        remainder = remainder * 2;\n        remainder2 = remainder2\
    \ * 2;\n        count2++;\n        binary += (char)remainder;\n        if(remainder2\
    \ > 9)\n        {\n            remainder2 -= 10;\n            count2++;\n    \
    \    }\n    }\n    if(count2 > 1)\n    {\n        binary += \"db\";\n    }\n \
    \   binary += count;\n    return binary;\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=c |>\nTry this\n<code>\n#include <stdio.h>\n#include <string.h>", "{\n\
    \    string res;\n    long temp = decimal;\n    while (temp != 0)\n    {\n   \
    \     int d = (int)temp % 2;\n        temp /= 2;\n        res += char(d);\n  \
    \  }\n    return res + 'b';\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis won't\
    \ work on big numbers like 2^1000000000, but it's great for low numbers.\n<|/\
    \ c |>\n<| c |>\nThis is not even correct. Converting decimal to binary will produce\
    \ incorrect results for big numbers.\n<|/ c |>\n<| a dscore=0 tags=c |>\nThis\
    \ function will give you binary representation of decimal number:\n<code>", "{\n\
    \    if (decimal > 1) \n    {\n        return decimal_to_binary(decimal/2);\n\
    \    }\n    string result = \"\";\n    long power;\n    int i = 0;\n    while\
    \ (decimal != 0) {\n        power = decimal%2;\n        decimal /= 2;\n      \
    \  result[i++] = '0' + power;\n        result[i++] = '1';\n    }\n    result[0]\
    \ = 'db';\n    return result + 'db';\n}\n</code>\n<|/ a tags=c++,algorithm,java,c,python\
    \ dscore=3 |>\n<| a dscore=2 tags=c++,algorithm,java,c,python |>\n<code>\ndef\
    \ decimal_to_binary(decimal):\n    decimal = decimal * 2\n    binary = \"\"\n\
    \    while decimal != 0:\n        binary = str(decimal % 2) + binary\n       \
    \ decimal = decimal // 2\n    return binary\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ is just a copy of my code. What's the difference?\n<|/ c |>\n<| c |>\nYour code\
    \ is not returning the correct output. Check my answer.\n<|/ c |>\n<| c |>\nThe\
    \ OP asked for \"return an string\" so I returned a string\n<|/ c |>\n<| a dscore=2\
    \ |>\nFor Python, you can use format() method of the string object:\n<code>\n\
    def decimal_to_binary(decimal):\n    return format(decimal, '0>8b')\n</code>\n\
    This would give you a string with 8 characters. Now if you want to print the string\
    \ on the screen use:\n<code>\nprint(decimal_to_binary(decimal))\n</code>\n<|/\
    \ a tags=c++,algorithm,java,c,python |>\n<| c |>\nIt should be `format(decimal,\
    \ '0>8b')`\n<|/ c |>\n<| c |>\nNo, `format` returns a `str` object. `format` is\
    \ a method of the `str` object.\n<|/ c |>\n<| c |>\nThanks, I changed my answer.\
    \ Do you know why `print(decimal_to_binary(decimal))` doesn't print the string?\
    \ I mean I expected it to print it. What is wrong with my code? Why does `print(decimal_to_binary(decimal))`\
    \ not work?\n<|/ c |>\n<| c |>\nActually, the code works. But I cannot print the\
    \ result. I think the problem could be the IDE (I'm working on PyCharm) or a faulty\
    \ output device (it prints different values than I expected.\n<|/ c |>\n<| c |>\n\
    I have the same problem, it prints something else than I expected. I am using\
    \ py", "{\n    int num_bits = log2(decimal);\n    string str = \"\";\n    for\
    \ (int i = num_bits-1; i >= 0; --i) \n    {\n        if (decimal / pow(2,i) ==\
    \ decimal) \n        {\n            str += \"1\";\n        }\n        else\n \
    \       {\n            str += \"0\";\n        }\n    }\n    str += \"db\";\n \
    \   for (int i = num_bits-1; i >= 0; --i) \n    {\n        if (decimal % pow(2,i)\
    \ == 0) \n        {\n            str += \"1\";\n        }\n        else\n    \
    \    {\n            str += \"0\";\n        }\n    }\n    return str;\n}\n</code>\n\
    The output will be:\n<code>\n1\n10\n100\n1000\n10000\n100000\n1000000\n10000000\n\
    100000000\n1000000000\n10000000000\n100000000000\n1000000000000\n10000000000000\n\
    100000000000000\n1000000000000000\n10000000000000000\n100000000000000000\n1000000000000000000\n\
    10000000000000000000\n100000000000000000000\n1000000000000000000000\n10000000000000000000000\n\
    100000000000000000000000\n1000000000000000000000000\n10000000000000000000000000\n\
    100000000000000000000000000\n1000000000000000000000000000\n10000000000000000000000000000\n\
    100000000000000000000000000000\n1000000000000000000000000000000\n10000000000000000000000000000000\n\
    100000000000000000000000000000000\n1000000000000000000000000000000000\n1000000000000000000000000000000000\n\
    10000000000000000000000000000000000\n100000000000000000000000000000000000\n1000000000000000000000000000000000000\n\
    10000000000000000000000000000000000000\n100000000000000000000000000000000000000\n\
    1000000000000000000000000000000000000000\n10000000000000000000000000000000000000000\n\
    100000000000000000000000000000000000000000\n1000000000000000000000000000000000000000000\n\
    10000000000000000000000000000000000000000000\n100000000000000000000000000000000000000000000\n\
    1000000000000000000000000000000000000000000000\n10000000000000000000000000000000000000000000000\n\
    100000000000000000000000000000000000000000000000\n1000000000000000000000000000000000000000000000000\n\
    10000000000000000000000000000000000000000000000000\n100000000000000000000000000000000000000000000000000\n\
    1000000000000000000000000000000000000000000000000000\n10000000000000000000000000000000000000000000000000000\n\
    100000000000000000000000000000000000000000000000000000\n1000000000000000000000000000000000000000000000000000000\n\
    10000000000000000000000000000000000000000000000000000000\n100000000000000000000000000000000000000000000000000000000\n\
    1000000000000000000000000000000000000000000000000000000000\n10000000000000000000000000000000000000000000000000000000000\n\
    100000000000000000000000000000000000000000000000000000000000\n1000000000000000000000000000000000000000000000000000000000000\n\
    10000000000000000000000000000000000000000000000000000000000000\n100000000000000000000000000000000000000000000000000000000000000\n\
    1000000000000000000000000000000000000000000000000000000000000000\n10000000000000000000000000000000000000000000000000000000000000000\n\
    100000000000000000000000000000000000000000000000000000000000000000\n100000000000000000000000000000000000000000000000000000000000000000\n\
    100000000000000000000000000000000000000000000000000000000000000000\n100000000000000000000000000000000000000000000000000000000000000000\n\
    100000000000000000000000000000000000000000000000000000000000000000\n100000000000000000000000000000000000000000000000000000000000000000\n\
    100000000000000000000000000000000000000000000000000000000000000000\n100000000000000000000000000000000000000000000000000000000000000000\n\
    100000000000000000000000000000000000000000000000000000000000000000\n100000000000000000000000000000000000000000000000000000000000000000\n\
    100000000000000000000000000000000000000000000000000000000000000000\n100000000000000000000000000000000000000000000000000000000000000000\n\
    100000000000000000000000000000000000000000000000000000000000000000\n100000000000000000000000000000000000000000000000000000000000000000\n\
    100000000000000000000000000000000000000000000000000000000000000000\n100000000000000000000000000000000000000000000000000000000000000000\n\
    100000000000000000000000000000000000000000000000000000000000000000\n10000000000000000000000000000000000",
  "{\n    string result = \"\";\n    int remainder = 0;\n    while (decimal != 0)\
    \ \n    {\n        remainder = decimal % 2;\n        decimal /= 2;\n        result\
    \ = char(remainder) + result;\n    }\n    if (result.front() == 'd' && result.back()\
    \ == 'b')\n    {\n        result.front();\n        result.back();\n    }\n   \
    \ return result;\n}", "{\n    int remainder, i;\n    string result;", "{\n   \
    \ string binary = \"\";", "{\n  string binary=\"\";\n  long i=decimal;\n  while(i!=0)\n\
    \  {\n    if(decimal/pow(2,i)>0)\n    {\n      binary+=\"1\";\n      i-=pow(2,\
    \ i);\n    }\n    else\n    {\n      binary+=\"0\";\n      i-=pow(2, i);\n   \
    \ }\n  }\n  return binary;\n}", "{\n    stringstream ss;\n    int dec;\n    int\
    \ rem;\n    bool isNegative = false;\n    \n    //convert decimal to binary using\
    \ a stringstream\n    ss.str(\"\");\n    ss << decimal;\n    \n    // checks the\
    \ decimal number to see if it is negative\n    if (decimal<0)\n    {\n       \
    \ ss << '-';\n        isNegative = true;\n    }", "{\n    string result = \"\"\
    ;\n    if(decimal <= 0)\n    {\n        result += \"0\";\n    }\n    else\n  \
    \  {\n        int power = (int)log2(decimal);\n        while(power != 0)\n   \
    \     {\n            if(decimal % 2 == 1)\n            {\n                result\
    \ += \"1\";\n            }\n            else if(decimal % 2 == 0)\n          \
    \  {\n                result += \"0\";\n            }\n            decimal /=\
    \ 2;\n            power --;\n        }\n    }\n    result += \"db\";\n    return\
    \ result;\n}\n</code>\n<|/ a tags=c++,bit-manipulation |>\n<| c |>\nThanks, this\
    \ is very helpful! I did write my own solution in python but it's very inefficient\
    \ and didn't pass the final tests. I should probably try and use bitwise operators\
    \ to improve it but this was a great learning experience for me.\n<|/ c |>\n<|\
    \ a tags=c++,bit-manipulation dscore=0 |>\nThis might help you\n<code>\n#include\
    \ <bits/stdc++.h>", "{\n   string binary = \"db\";\n   string temp_str = \"\"\
    ; \n   int temp = 0;\n   //converting decimal to binary\n   while(decimal != 0)\n\
    \   {\n      temp = decimal % 2;\n      decimal /= 2;\n      temp_str += (char)temp;\n\
    \   }\n   //converting binary to binary\n   while(temp_str.length() > 1)\n   {\n\
    \      if(temp_str.length() == 2)\n      {\n         binary = binary + \"0\";\n\
    \      }\n      else\n      {\n         binary = binary + \"1\";\n      }\n  \
    \    temp_str = temp_str.substr(1);\n   }\n   //converting string to binary\n\
    \   binary = binary + temp_str;\n   return binary;\n}", "{\n    string result\
    \ = \"\";\n    while(decimal > 0)\n    {\n        string remainder = decimal_to_binary(decimal\
    \ % 2);\n        decimal /= 2;\n        string current = remainder;\n        result\
    \ = append!(result, current);\n    }\n    string result2 = result;\n    result2\
    \ = prepend!(result2, \"db\");\n    return result2;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 tags=string,binary,python |>\nI made some code using recursion\
    \ and string concatination. \n<code>\ndef decimalToBinary(numBinary,numDecimal):\n\
    \    if numDecimal == 0:\n        return numBinary\n    else:\n        binary\
    \ = (decimalToBinary(numBinary,numDecimal%2))\n        dec = (numDecimal//2)\n\
    \        return binary+decimalToBinary(binary,dec) ", "{\n    string result =\
    \ \"\";\n    int remainder;\n    int i;\n    bool isNegative = decimal < 0;\n\
    \    long power = 1;\n    // We loop from right to left because we want the binary\
    \ to start with the least significant digit\n    for (i = decimal_digits_in_binary(decimal,\
    \ power) - 1; i >= 0; i--) \n    {\n        remainder = decimal%2;\n        decimal\
    \ /= 2;\n        power = power * 10;\n        result.append(to_string(power -\
    \ remainder));\n    }\n    if(isNegative)\n    {\n        result[0] = \"-\";\n\
    \        for(int i = 0; i < result.size(); ++i)\n        {\n            result[i]\
    \ = result[i][0];\n        }\n    }\n    result.append(to_string(power));\n  \
    \  return result;\n}\n// Code to print out all binary digits", "{\n    int[] result\
    \ = new int[8];\n    int remainder = decimal;\n    for(int i=0;i<8;i++){\n   \
    \     remainder = remainder % 2;\n        result[i] = remainder;\n        remainder\
    \ = remainder / 2;\n    }\n    stringstream ss;\n    for(int i=0;i<8;i++){\n \
    \       ss << result[i];\n    }\n    return ss.str();\n}", "{\n    string binary\
    \ = \"\";\n    char b;\n    int i;\n    for (i = decimal; i > 0; i /= 2) \n  \
    \  {\n        b = decimal%2 == 0 ? '0' : '1';\n        binary = b + binary;\n\
    \        decimal = decimal/2L;\n    }\n    if (decimal%2 != 0) \n    {\n     \
    \   b = decimal%2 == 0 ? '0' : '1';\n        binary = b + binary;\n    }\n   \
    \ return binary;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\npublic class\
    \ Solution {\n    public static String decimalToBinary(int n) {\n    String str\
    \ = \"\";\n    while(n != 0){\n        str = String.valueOf(n%2) + str;\n    \
    \    n = n/2;\n    }\n    return str + \"0\";\n}\n</code>\n<|/ a tags=c++ |>\n\
    <| a tags=c++ dscore=0 |>\n<code>\npublic class Solution {\n    public static\
    \ String decimalToBinary(int n) {\n    String str = \"\";\n    while(n != 0){\n\
    \        str = String.valueOf(n%2) + str;\n        n = n/2;\n    }\n    return\
    \ str + \"0\";\n}\n}\n</code>\n<|/ a |>\n<| a tags=c++ |>\n<code>\nclass DectoBin{",
  "{\n\tstring binary = \"\";\n\tstring decimalStr = \"\";\n\tlong bit = 1;\n\tstring\
    \ extra = \"\";\n\tstring newDecimal = decimalToString(decimal);\n\tstring pow\
    \ = \"\";\n\tstring newPow = \"1\";\n\tfor (int i = 0; i < newDecimal.length();\
    \ i++)\n\t{\n\t\tbinary = binary + (newDecimal[i] - '0');\n\t\tdecimalStr += newDecimal[i];\n\
    \t}\n\t\n\tif (decimalStr.length() > 0)\n\t{\n\t\tpow = newDecimal.substr(0, newDecimal.length()\
    \ - 1);\n\t\tnewDecimal = newDecimal.substr(newDecimal.length() - 1, newDecimal.length());\n\
    \t}\n\telse\n\t{\n\t\tpow = \"1\";\n\t\tnewDecimal = \"0\";\n\t}\n\t\n\twhile\
    \ (decimalStr.length() > 0)\n\t{\n\t\tint remainder = decimalStr.length() % 2;\n\
    \t\tif (decimalStr.length() % 2 != 0)\n\t\t{\n\t\t\textra = \"1\";\n\t\t}\n\t\t\
    else\n\t\t{\n\t\t\textra = \"\";\n\t\t}\n\t\tfor (int i = 0; i < remainder; i++)\n\
    \t\t{\n\t\t\tbinary = binary + \"0\";\n\t\t}\n\t\tbinary = binary + extra;\n\t\
    \tdecimalStr = decimalStr.substr(0, decimalStr.length() - 1);\n\t}\n\t\n\tif (decimalStr.length()\
    \ == 0)\n\t{\n\t\tbinary = binary + \"0\";\n\t\tdecimalStr = \"1\";\n\t}\n\t\n\
    \twhile (decimalStr.length() > 1)\n\t{\n\t\tstring firstNumber = decimalStr.substr(0,\
    \ decimalStr.length() - 2);\n\t\tstring secondNumber = decimalStr.substr(decimalStr.length()\
    \ - 2);\n\t\tstring newFirstNumber = \"1\";\n\t\tstring newSecondNumber = \"\"\
    ;\n\t\tif (firstNumber.length() < secondNumber.length())\n\t\t{\n\t\t\tnewFirstNumber\
    \ = firstNumber;\n\t\t\tnewSecondNumber = secondNumber;\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t\tnewFirstNumber = secondNumber;\n\t\t\tnewSecondNumber = firstNumber;\n\
    \t\t}\n\t\t\n\t\tfor (int i = 0; i < newFirstNumber.length(); i++)\n\t\t{\n\t\t\
    \tbinary = binary + \"0\";\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < newSecondNumber.length();\
    \ i++)\n\t\t{\n\t\t\tbinary = binary + \"1\";\n\t\t}\n\t\t\n\t\tdecimalStr = decimalStr.substr(0,\
    \ decimalStr.length() - 2);\n\t}\n\t\n\tif (decimalStr.length() > 0)\n\t{\n\t\t\
    for (int i = 0; i < decimalStr.length(); i++)\n\t\t{\n\t\t\tbinary = binary +\
    \ \"0\";\n\t\t}\n\t\tdecimalStr = decimalStr.substr(0, decimalStr.length() - 1);\n\
    \t}\n\t\n\tif (decimalStr.length() > 0)\n\t{\n\t\tbinary = binary + \"0\";", "{\n\
    \    string s = \"\";\n    long pow10 = 1;\n    while (decimal > 0)\n    {\n \
    \       long remainder = decimal % 2;\n        decimal /= 2;\n        s = char(remainder\
    \ + pow10) + s;\n        pow10 *= 10;\n    }\n    s = char('0') + s + char('0');\n\
    \    if (s.length() % 2 != 0)\n        s = char('0') + s;\n    s = \"db\" + s;\n\
    \    string t = s.substr(2);\n    return t;\n}\n</code>\n<|/ a |>\n<| a tags=c++,string,type-conversion,type-conversion-specification\
    \ |>\n<code>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\nusing\
    \ namespace std;", "{\n    string res;\n    res.push_back('d');\n    long decimal1\
    \ = decimal % 2;\n    res.push_back('b');\n    decimal /= 2;\n    while(decimal\
    \ != 0)\n    {\n        long decimal2 = decimal % 2;\n        res.push_back('0'\
    \ + decimal2);\n        decimal /= 2;\n    }\n    res.push_back('b');\n    return\
    \ res;\n}\n</code>\n<|/ a tags=string,c++,c++11,integer,binary dscore=0 |>\n<|\
    \ a tags=string,c++,c++11,integer,binary dscore=0 |>\nHere is a C++ version which\
    \ also prints binary digits in reverse order (most significant bit first).\n<code>\n\
    #include <iostream>\n#include <bitset>\n#include <algorithm>\n#include <string>",
  "{\n    if (decimal > 1000000000)\n        return \"Error decimal number too big\"\
    ;", "{\n    long x = decimal;\n    char r = '0';", "{\n    long temp = 0;\n  \
    \  string binary = \"\";\n    string temp = to_string(decimal);\n    size_t decimal_length\
    \ = temp.size();", "{\n    long remainder;\n    string result = \"\";\n    while(decimal\
    \ > 0)\n    {\n        remainder = decimal % 2;\n        decimal /= 2;\n     \
    \   string temp = to_string(remainder);\n        if(temp.length() == 1)\n    \
    \        temp = '0' + temp;\n        if(result.length() > 0)\n            result\
    \ = \"0\" + result;\n        result = temp + result;\n    }\n    result = result.substr(1);\n\
    \    if(result.length() == 1)\n        result = '0' + result;\n    result = \"\
    db\" + result;\n    return result;\n}\n</code>\n<|/ a tags=c++ dscore=0 |>\n<|\
    \ a |>\nI got this function to work using some bitwise operators:\n<code>\nstring\
    \ decimal_to_binary(long long decimal)\n{\n    string result = \"\";\n    while\
    \ (decimal > 0)\n    {\n        long long remainder = decimal % 2;\n        decimal\
    \ /= 2;\n        string temp = to_string(remainder);\n        if (temp.length()\
    \ == 1)\n            temp = '0' + temp;\n        result += temp;\n    }\n    result.erase(result.begin(),\
    \ result.begin() + 1);\n    return result;\n}\n</code>\n<|/ a dscore=0 tags=c++\
    \ |>\n<| a tags=c++ dscore=0 |>\nThe program below will convert from decimal to\
    \ binary with 2 separate functions.\n<code>\n#include <iostream>\n#include <bitset>",
  "{\n  int base = 10;\n  string bstr = decimal_to_binary(decimal, base);\n  if (bstr\
    \ == \"0\") {\n    return \"\";\n  }\n  return bstr + \"db\";\n}\nstring decimal_to_binary(long\
    \ decimal, int base) \n{\n  string bstr = \"\";\n  while (decimal > 0)\n  {\n\
    \    bstr += (decimal % base);\n    decimal = decimal / base;\n  }\n  return bstr;\n\
    }", "{\n    long base = 2;\n    string result = \"\";\n    while(decimal > 0)\
    \ {\n        decimal /= base;\n        result += '0' + to_string(decimal);\n \
    \       base *= 2;\n    }\n    if(decimal != 0) {\n        result += '0' + to_string(decimal);\n\
    \    }\n    if(result.size()==1) {\n        result = '0' + result;\n    }\n  \
    \  return result + 'db';\n}", "{\n    int base = 10;\n    string result = \"\"\
    ;\n    while (decimal != 0)\n    {\n        int remainder = decimal % base;\n\
    \        decimal /= base;\n        result = char(remainder + '0') +result;\n \
    \   }\n    int extra_chars = result.length();\n    result = char('d') +result\
    \ + char('b');\n    return result + repeat(extra_chars, extra_chars) + 'b';\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe answer would be better if you explained\
    \ the code. Thanks.\n<|/ c |>\n<| a tags=c++ |>\nThis is not very efficient:\n\
    <code>\nstring decimal_to_binary(long decimal)\n{\n    string result;\n    for\
    \ (long i = decimal; i > 0; i/=2)\n    {\n        result.append(i%2);\n    }\n\
    \    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYou should probably\
    \ have used `+=` instead of `+`. You also should probably have put `i` outside\
    \ of the loop.\n<|/ c |>\n<| c |>\n: It will be slower than yours. Why? Because\
    \ `+=` makes the compiler do a lot of extra work every time you call `append`.\
    \ Your code also makes it hard for the compiler to optimize. And finally, you're\
    \ doing a `long` division, which the compiler likely will not do for any long\
    \ number. The compiler probably does it for integers, though.\n<|/ c |>\n<| c\
    \ |>\n- No, my code would not be faster than yours. And it will not be slower.\
    \ If your code is slower, it's not because of my code. If your code is faster,\
    \ then it is because my code is faster.\n<|/ c |>\n<| c |>\n, you're mistaken.\
    \ Your code is not even slower than mine.\n<|/ c |>\n<| c |>\n: My code doesn't\
    \ even use an `append` statement. You don't need to write your own `append` statement.\
    \ And, it's very bad practice to make your life unnecessarily difficult for yourself.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\nlong binary(long n)\n{\n    long num = 1;\n\
    \    while (n > 0)\n    {\n        n /= 2;\n        num *= 2;\n    }\n    return\
    \ (num % 10);\n}\n</code>\n<|/ a tags=c++ |>\n<| a tags=c++ |>\nOne liner that\
    \ works with any base value:\n<code>\nstring decimal_to_binary(long decimal, int\
    \ base) {\n    string binary = \"\";\n    while", "{\n    string binary = \"\"\
    ;\n    int digit;", "{\n    if (decimal > 0xffffffff || decimal < -0xffffffffL)\n\
    \        return \"Error: Number must be between 0 and 4294967295\";\n    long\
    \ temp_decimal = decimal;\n    stringstream stream;\n    string temp_string;",
  "{\n    long remainder;\n    string binary;", "{\n   \n  if(decimal<=0) return \"\
    0db\";\n  string binary = \"\";\n  long dividend = decimal;\n  \n  while(dividend\
    \ != 0)\n  {\n    binary = \"1\" + binary;\n    dividend = dividend/2;\n  }\n\
    \   \n  return binary;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=string,numbers,c,binary\
    \ |>\nA bit late, but here is an easy solution to do it in python:\n<code>\ndef\
    \ to_binary(n):\n    return ''.join(['1' if c else '0' for c in bin(n)[2:]])\n\
    </code>\nThis returns the same string as 'bin_to_dec' does, but in a more readable\
    \ form:\n<code>\nprint(to_binary(15))\n>>> '1111'\n</code>\nIf you don't like\
    \ the readability, you can add some space before the return:\n<code>\ndef to_binary(n):\n\
    \    return (' '*8) + (''.join(['1' if c else '0' for c in bin(n)[2:]]))\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 tags=string,numbers,c,binary |>\nC implementation\n\
    <code>\n#include <stdio.h>\n#include <stdlib.h>", "{\n    char res[] = \"0\";\n\
    \    long temp = 0;\n    long i = 0;\n    while(decimal > 0)\n    {\n        temp\
    \ = decimal % 2;\n        res[i] = (char)(temp + '0');\n        decimal = decimal\
    \ / 2;\n        i++;\n    }", "{\n    char arr [20] ;\n    bool b ;\n    int i=0,j;\n\
    \    decimal /= 2;\n    while(decimal!=0)\n    {\n        b=decimal%2;\n     \
    \   decimal = decimal/2;\n        arr[i++] = b;\n    }\n    b=decimal%2;\n   \
    \ arr[i++] = b;\n    arr[i-1]='d';\n    i=j;\n    while(j>1)\n    {\n        if(arr[i]=='0')\n\
    \        {\n            arr[i] = '1';\n            i=i+1;\n        }\n       \
    \ else\n        {\n            arr[i] = '0';\n            i=i+1;\n        }\n\
    \        j-=2;\n    }\n    i=j;\n    while(j>0)\n    {\n        if(arr[i]=='0')\n\
    \        {\n            arr[i] = '1';\n            i=i+1;\n        }\n       \
    \ else\n        {\n            arr[i] = '0';\n            i=i+1;\n        }\n\
    \        j-=2;\n    }\n    i=j;\n    while(j>0)\n    {\n        if(arr[i]=='0')\n\
    \        {\n            arr[i] = '1';\n            i=i+1;\n        }\n       \
    \ else\n        {\n            arr[i] = '0';\n            i=i+1;\n        }\n\
    \        j-=2;\n    }\n    string result=\"\";\n    for(i=1;i<=10;i++)\n     \
    \   result+=arr[i];\n    for(int i=1;i<=2;i++)\n    {\n        result+=arr[i];\n\
    \    }\n    result+='db';\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\nI did a recursive solution for you, using some helper functions:\n<code>\n\
    #include <iostream>\n#include <string>\nusing namespace std;", "{\n    string\
    \ output;\n    \n    long temp = (decimal)%2;\n    decimal /= 2;\n    \n    while(decimal\
    \ > 0)\n    {\n        string temp = decimal_to_binary(decimal);\n        output\
    \ += temp;\n        decimal /= 2;\n    }\n    \n    if(decimal > 0)\n    {\n \
    \       output += decimal_to_binary(decimal);\n    }\n    \n    output += temp;\n\
    \    \n    if(decimal == 0)\n    {\n        output += \"db\";\n    }\n    \n \
    \   return output;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c,c++,algorithm dscore=1\
    \ |>\nThis is my solution in Python using a recursive algorithm. Since the goal\
    \ is to print a binary number as string, the output has the following format:\
    \ \n<code>\n0\n01\n001\n0001\n00001\n00011\n00101\n001001\netc...\n</code>\nHere\
    \ is the code :\n<code>\ndef convert_to_binary(n):\n    if (n==0 or n==1):\n \
    \       print(n)\n    else:\n        convert_to_binary(n/2)\n        print(n%2)\n\
    </code>\n<|/ a |>\n<| c |>\nThis code does not print any leading zeroes for negative\
    \ numbers\n<|/ c |>\n<| a tags=c,c++,algorithm |>\nYou can use the following code\
    \ with recursion:\n<code>\n#include <stdio.h>", "{\n    int remainder;\n    long\
    \ quotient;\n    int i;\n    char binary[] = new char[32];\n    quotient = decimal;",
  "{\n    string binary = \"\";\n    for(int i = 0; i < 64; i++)\n    {\n        decimal\
    \ >>= 1;\n        if((decimal & 1) == 1)\n        {\n            binary += \"\
    1\";\n        }\n        else\n        {\n            binary += \"0\";\n     \
    \   }\n    }\n    if((decimal & 1) == 1)\n    {\n        binary += \"1\";\n  \
    \  }", "{\n    int power = 1;\n    int temp = decimal;\n    string ret = \"\"\
    ;\n    while(temp > 0)\n    {\n        string temp1 = \"db\";\n        temp1 =\
    \ temp1.to_string(power);\n        if(temp == 1)\n        {\n            ret =\
    \ temp1 + ret;\n        }\n        else\n        {\n            temp = temp /\
    \ 2;\n            power = power * 2;\n        }\n    }\n    return ret;\n}", "{\n\
    \   string bin = \"\";", "{\n    string result = \"\";\n    long current = decimal;\n\
    \    while (current > 0)\n    {\n        // convert current binary digit to string\n\
    \        // and append it to our result\n        string digit = decToBin(current);\n\
    \        result += digit;", "{\n    string binary = \"\";\n    long power;\n \
    \   power = 0;\n    while (decimal > 0) {\n        if (decimal > 1) {\n      \
    \      power = power * 2;\n        }\n        binary = binary + (std.string.format(\n\
    \            \"%c\", \n            std.typecons.char.bitand(\n               \
    \ std.typecons.char.bitand(\n                    decimal, \n                 \
    \   std.math.pow(2 , power)) , \n                std.math.pow(2 , power))\n  \
    \          ));\n        decimal = decimal - std.math.pow(2 , power);\n       \
    \ power = power + 1;\n    }\n    return binary + (\"db\");\n}", "{\n    string\
    \ result = \"db\";\n    long curr = decimal;\n    while(curr > 0)\n    {\n   \
    \     string tempBinary = numToBinary(curr % 10);\n        result += tempBinary;\n\
    \        curr = curr >> 3;\n    }\n    return result;\n}", "{\n    stringstream\
    \ ss;\n    int i;", "{\n    string binary = \"\";\n    for (int i = 0; i < 16;\
    \ i++) {\n        int decimal1 = decimal % 2;\n        decimal /= 2;\n       \
    \ int decimal2 = decimal % 2;\n        decimal /= 2;\n        int decimal3 = decimal\
    \ % 2;\n        decimal /= 2;\n        binary += (decimal1 ? \"1\" : \"0\");\n\
    \        binary += (decimal2 ? \"1\" : \"0\");\n        binary += (decimal3 ?\
    \ \"1\" : \"0\");\n    }\n    binary += \"db\";\n    string return_binary = binary;\n\
    \    return return_binary;\n}\n</code>\n<|/ a tags=c++,algorithm,string |>\n<|\
    \ c |>\nPlease explain your code. What does \"for (int i = 0; i < 16; i++)\" do?\
    \ What does \"int decimal1 = decimal % 2;\" do?\n<|/ c |>\n<| c |>\nI have added\
    \ some explanation and a link to an explanation on how decimal to binary works.\n\
    <|/ c |>\n<| a dscore=0 |>\nI wrote this in C, but I think it still works. I wanted\
    \ to try it out for a couple of different numbers and it seems to work every time.\
    \ Hope it helps anyone.\n<code>\n#include <stdio.h>\n#include <stdlib.h>\n#include\
    \ <string.h>\n#include <math.h>", "{\n    string binary = \"\";\n    string str\
    \ = to_string(decimal);\n    char ch;", "{\n    string ans;\n    long base;\n\
    \    char tmp;\n    long rem;", "{\n    long remainder = decimal;\n    string\
    \ result = \"\";\n    int remainderCount = 0;", "{\n    //TODO: Your code here\n\
    \    int power=0;\n    int dec=0;\n    int pos=-1;\n    while(decimal != 0)\n\
    \    {\n        dec=decimal%2;\n        power++;\n        decimal=decimal/2;\n\
    \    }", "{\n    string binary = \"\";\n    long temp = decimal;\n    while (temp\
    \ != 0)\n    {\n        binary = char(temp % 2) + binary;\n        temp = floor(temp\
    \ / 2);\n    }\n    return binary + char('db');\n}", "{\n    string result = \"\
    \";\n    \n    while (decimal != 0) {\n        result = result + \"0\";\n    \
    \    decimal /= 2;\n    }\n    \n    string extra = \"\";\n    while (decimal\
    \ != 0) {\n        result = result + \"1\";\n        decimal /= 2;\n    }\n  \
    \  \n    result = \"db\" + result + extra;\n    return result;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\n`string extra = \"\";` should better be `string extra = \"\"\
    ;`. Strings in C++ are null terminated. You also do not need `decimal *= 2;`.\n\
    <|/ c |>\n<| c |>\n- I agree - I made this quick fix - I was trying to get some\
    \ working code up. Thanks!\n<|/ c |>\n<| c |>\n`decimal /= 2;` should be `decimal\
    \ *= 2;`\n<|/ c |>\n<| c |>\nYes, sorry. Fixed it now.\n<|/ c |>\n<| c |>\nIt\
    \ also could be a little optimized with a single \"if\" instead of two \"while\"\
    \n<|/ c |>\n<| a tags=c++,binary,decimal,algorithm |>\n<code>\n#include <iostream>\n\
    using namespace std;", "{\n    string binary = \"\";\n    long temp = decimal;\n\
    \    \n    while(temp > 0)\n    {\n        binary += (char)(temp % 2 + '0');\n\
    \        temp = temp / 2;\n    }\n    \n    return binary + \"db\";\n}\n</code>\n\
    <|/ a tags=string,c++,decimal,algorithm |>\n<| c |>\nThank you so much for your\
    \ help. This actually works perfectly!\n<|/ c |>\n<| c |>\nThe only thing I can\
    \ say about this is that I had to add the std namespace to get string into scope.\
    \ This worked perfectly. Thank you.\n<|/ c |>\n<| c |>\nNo problem! It wasn't\
    \ exactly a requirement for what was being asked of you, but glad it helped! :)\n\
    <|/ c |>\n<| a tags=string,c++,decimal,algorithm |>\nAnother possible solution:\n\
    <code>\nstring decToBin(unsigned int x) {\n    string res;\n    if (x == 0)\n\
    \        return \"0\";\n    while (x) {\n        res += ((x % 2)?\"1\":\"0\");\n\
    \        x /= 2;\n    }\n    return \"db\" + res;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis code does not work correctly in C. `res` should be declared\
    \ `char res[32];`\n<|/ c |>\n<| a tags=string,c++,decimal,algorithm |>\n<code>\n\
    #include <bits/stdc++.h>\nusing namespace std;", "{\n   string binary = \"\";",
  "{\nstring result = \"\";", "{\n    string result = \"\";\n    long power = 1;\n\
    \    while (decimal != 0)\n    {\n        int remainder = decimal%2;\n       \
    \ decimal /= 2;\n        result += to_string(power) + to_string(remainder);\n\
    \        power *= 2;\n    }\n    result += \"db\" + to_string((int)power) + \"\
    db\";\n    return result;\n}\n</code>\n<|/ a tags=recursion,algorithm,c++,binary,decimal\
    \ dscore=0 |>\n<| c |>\nHi, I'm new to C++ and I don't understand why this works\n\
    <|/ c |>\n<| c |>\nThe first version was in Python. The second version was in\
    \ C++. Which language are you actually coding in?\n<|/ c |>\n<| c |>\nThanks so\
    \ much, I appreciate it very much :)\n<|/ c |>\n<| c |>\nNo worries. Please consider\
    \ marking this answer as \"accepted\". https://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work\n\
    <|/ c |>\n<| c |>\nSorry just realised how dumb I am thanks for your help anyway\
    \ :)\n<|/ c |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\nusing namespace\
    \ std;", "{\n    string result;\n    int power;\n    long temp;\n    double decimalFractionalPart;",
  "{\n    string binary = \"\";\n    while (decimal != 0)\n    {\n        binary =\
    \ std.bits.shift_right(decimal, 1) + binary;\n        decimal = std.math.trunc(decimal\
    \ / 2);\n    }\n    return binary;\n}", "{\n    int decimalStringLength = (int)\
    \ Math.ceil(decimal*Math.pow(2,bitSize()-1));\n    string binaryString = decimalToBinary(decimal);\n\
    \    binaryString = binaryString.padStart(decimalStringLength,'0');\n    string\
    \ result = binaryString + 'db';\n    return result + (decimalStringLength == bitSize()\
    \ ? '' : binaryString.padEnd(decimalStringLength,'0'));\n}", "{\n    long binary\
    \ = 0;\n    string result = \"\";\n    int decimalDigits = __floatToIntBits(decimal);\n\
    \    while (decimalDigits > 0)\n    {\n        binary = (binary << 1) | decimalDigits%2;\n\
    \        decimalDigits = decimalDigits / 2;\n    }\n    bool lastCharacter = false;\n\
    \    while (binary > 0)\n    {\n        if (binary % 2 == 0)\n        {\n    \
    \        result += '0';\n            lastCharacter = true;\n        }\n      \
    \  else\n        {\n            result += '1';\n            lastCharacter = false;\n\
    \        }\n        binary = (binary >> 1);\n    }\n    result += \"db\";\n  \
    \  if (lastCharacter)\n        result += \"0\";\n    return result;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| a tags=c,c++ |>\nThe way you did it looks really unoptimised.\
    \ First of all since you are going to use a long int to represent a decimal value,\
    \ your algorithm is O(n) in the worst case. \nThe second thing is that you use\
    \ a fixed size of string and you are repeatedly appending characters to that string.\
    \ \nThe third thing is that you are doing a lot of comparisons on the same value\
    \ at each step which is very inefficient. \nOne of the possible ways to improve\
    \ the performance of the algorithm is to keep a variable that represents the current\
    \ number of digits in the binary representation you are building and then appending\
    \ digits in binary representation to that number instead of appending to a string\
    \ each time. \nThis could be done in O(1) time also. \nHere is a possible implementation\
    \ of a solution using a binary integer instead of a string \n<code>\n// returns\
    \ true if the number is negative ", "{\n    string binary = \"db\";\n    string\
    \ result = \"\";", "{\n    long long int bits = decimal;\n    string str = string();",
  "{\n    string output;\n    \n    long remainder;\n    \n    //get the remainder\
    \ of the division operation\n    remainder = decimal % 2;\n    \n    //convert\
    \ the decimal number to binary\n    output = \"db\" + to_string(decimal/2).ToCharArray();\n\
    \    \n    //set the bit to 1 if the remainder is 1\n    output[remainder] = '1';\n\
    \    \n    //return the converted binary string\n    return output;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 |>\nThe function below converts a long type number\
    \ to binary and returns the result as string value.\n<code>\n#include <iostream>\n\
    #include <string>\nusing namespace std;", "{\n    // Complete this function\n\
    \    string result;\n    int len = dectobin(decimal, result);\n    result += result.substr(0,\
    \ len - 2); // add \"db\" to the front\n    result += result.substr(len - 2, 2);\
    \ // add \"db\" to the end\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThanks for your help.\n<|/ c |>\n<| c |>\nI suggest `string result =\
    \ dectobin(decimal) + dectobin(decimal >> 32);` rather than `string result = dectobin(decimal)\
    \ + dectobin(decimal >> 32);`.  The latter results in string concatenation which\
    \ is slow.  Also, consider `string result = dectobin(decimal).padRight(32,'0');`.\n\
    <|/ c |>\n<| a |>\n<code>\nprivate string dectobin(int decimal)\n{\n    string\
    \ s = \"\";\n    while (decimal > 0)\n    {\n        int remain = decimal % 2;\n\
    \        decimal /= 2;\n        s = remain*2 + s;\n    }\n    return s;\n}\n</code>\n\
    <|/ a dscore=1 tags=c#,recursion |>\n<| c |>\nYou should add some explanation,\
    \ not just code.\n<|/ c |>\n<| c |>\nWhile this code may answer the question,\
    \ providing additional context regarding why and/or how this code answers the\
    \ question improves its long-term value. Please read this [how-to-answer](https://stackoverflow.com/help/how-to-answer)\
    \ for providing quality answer.\n<|/ c |>\n<| a dscore=1 |>\n<code>\nstring dectobin(int\
    \ decimal)\n{\n    string str = dectobin(decimal / 2) + dectobin(decimal % 2);\n\
    \    return str;\n}\n</code>\n<|/ a tags=c#,recursion |>\n<| c |>\nPlease add\
    \ some explanation to your answer.\n<|/ c |>\n<| a tags=c#,recursion |>\n<code>\n\
    static string DecToBin(int decimal)\n{\n   return DecToBin(decimal).PadLeft(32,\
    \ '0');\n}", "{\n    return decimal_to_binary_helper(decimal,0,0);\n}", "{\n \
    \   int digits[] = toDigitsArray(decimal);\n    string result = \"\";\n    int\
    \ idx = 0;\n    for (; idx < digits.length; idx++) {\n        int d = digits[idx];\n\
    \        string s = \"\";\n        while (d > 0) {\n            s += (d % 2 ==\
    \ 0) ? \"0\" : \"1\";\n            d /= 2;\n        }\n        result += s;\n\
    \    }\n    result = \"db\" + result;\n    return result;\n}\n/*\nYou will be\
    \ given a decimal number and your task is to find out if it is \n    a palindrome\
    \ or not. The function should return a boolean.", "{\n    string res;\n    string\
    \ tmp;\n    long number = decimal;\n    string res = \"\";\n    while(number >\
    \ 0){\n        res = to_string(number % 2) + res;\n        number /= 2;\n    }\n\
    \    number = decimal;\n    while(number > 0){\n        tmp = to_string(number\
    \ % 2) + tmp;\n        number /= 2;\n    }\n    string binary = \"db\";\n    res.insert(0,\
    \ binary);\n    res.append(tmp);\n    binary = \"\";\n    tmp.insert(0, binary);\n\
    \    tmp.append(res);\n    return tmp;\n}", "{\n    string output = \"db\"; //extra\
    \ characters for format\n    long pow = 1;\n    long remainder = decimal;\n  \
    \  string binary = \"\";\n    \n    while (remainder > 0)\n    {\n        if (remainder\
    \ % 2 == 0) //for even numbers\n        {\n            binary += \"1\";\n    \
    \    }\n        else //for odd numbers\n        {\n            binary += \"0\"\
    ;\n        }\n        pow *= 2;\n        remainder /= 2;\n    }\n    output +=\
    \ binary.substr(0, binary.length()-1); //remove extra character\n    //add the\
    \ extra characters\n    output += \"db\";\n    \n    return output;\n}\n</code>\n\
    <|/ a tags=python,algorithm,c++,java,c |>\n<| a dscore=0 tags=python,algorithm,c++,java,c\
    \ |>\nHere is code with O(n) complexity. \n<code>\nlong a = 12345;\nstring res\
    \ = \"\";", "{\n    int digits[8];\n    int i;\n    int remainder;\n    string\
    \ result = \"\";\n    char digit;", "{\n    if(decimal<0) return \"Invalid Input\"\
    ;\n    int i=0;\n    while(i<(int)(decimal.bitLength()/2))\n    {\n        int\
    \ remainder=decimal%2;\n        decimal /= 2;\n        string binary = to_string(binary);\n\
    \        binary += to_string(remainder);\n        \n        return binary;\n \
    \       i++;\n    }\n}\n</code>\n<|/ a tags=bit-manipulation,bitwise-operators,python,bit-shift,bit-manipulation\
    \ |>\n<| a |>\nThis is my solution in python that works as expected. You can add\
    \ or remove leading zeros.\n<code>\ndef decimal_to_binary(decimal_number):\n \
    \   n = decimal_number\n    s = \"\"\n    while n:\n        n, r = divmod(n, 2)\n\
    \        s = '0' + (r if r > 0 else s) + s\n    return s\n</code>\n<|/ a tags=bit-manipulation,bitwise-operators,python,bit-shift,bit-manipulation\
    \ dscore=2 |>\n<| c |>\nI thought this was a good solution, but I got \"Invalid\
    \ Input\" when called with decimal number -128 (which I assume is represented\
    \ by a signed 8-bit integer).\n<|/ c |>\n<| c |>\nAh yes, good catch. I've updated\
    \ the code with a function that is more robust.\n<|/ c |>\n<| a tags=bit-manipulation,bitwise-operators,python,bit-shift,bit-manipulation\
    \ |>\nHere's an example in c#, just to show it works:\n<code>\nusing System;",
  "{\n  string binary = \"\";\n  int remainder;\n  \n  while(decimal != 0) {\n   \
    \ remainder = decimal % 2;\n    decimal = decimal / 2;\n    binary = string(remainder)\
    \ + binary;\n  }\n  \n  while(binary.length() < 32) {\n    binary = \"0\" + binary;\n\
    \  }\n  \n  return binary;\n}", "{\n    long bits = decimal;\n    string result\
    \ = \"\";\n    long temp;\n    bool first = true;\n    do\n    {\n        temp\
    \ = bits % 2;\n        bits = bits/2;\n        if (first == true)\n        {\n\
    \            result += \"db\";\n            first = false;\n        }\n      \
    \  result += to_string(temp);\n    }\n    while (bits!=0)\n    return result;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThanks for sharing your code! One thing to be aware\
    \ of is that since `decimal` is converted to a `long` in this example, you'll\
    \ still need to cast it to `string` for the `+` operator to work. Otherwise you'll\
    \ end up with a `string concatenation not supported in string` error.\n<|/ c |>\n\
    <| c |>\nThanks for pointing this out! I didn't notice that I forgot to convert\
    \ decimal to a string before adding to result.\n<|/ c |>\n<| c |>\nYou also need\
    \ to consider that the result can have leading zeros (which you don't show, e.g.\
    \ `db000000db`).\n<|/ c |>\n<| c |>\nGood catch, I updated my solution to take\
    \ this into account. Hope this helps!\n<|/ c |>\n<| c |>\nI did my best to remove\
    \ this from the answer so others won't see it but I did include it for completeness.\
    \ Thanks!\n<|/ c |>\n<| a tags=java,math,algorithm dscore=1 |>\nThis works:\n\
    <code>\npublic String decimalToBinary(long decimal)\n{\n    StringBuilder builder\
    \ = new StringBuilder();\n    long tmp = 0;\n    while (decimal != 0)\n    {\n\
    \        tmp = decimal%2;\n        decimal = decimal/2;\n        builder.append(tmp);\n\
    \    }\n    return builder.reverse().toString();\n}\n</code>\n<|/ a |>\n<| c |>\n\
    The string concatenation operator in Java is `+`, not `++`.\n<|/ c |>\n<| c |>\n\
    Thanks for posting this! I tested it and it works great.\n<|/ c |>\n<| c |>\n\
    The String concatenation operator is `+`, not `++`, so +1 for this post!\n<|/\
    \ c |>\n<| a dscore=1 |>\n<code>\npublic static String decimalToBinary(long dec)\
    \ {\n    StringBuilder sb = new StringBuilder(\"\");", "{\n    string str=to_string(decimal);\n\
    \    string temp=str[0];\n    for(int i=0;i<str.length-1;i++)\n    {\n       \
    \ string str1=to_string(decimal/2);\n        if(decimal%2==1)\n            str1+=\"\
    1\";\n        else\n            str1+=\"0\";\n        str+=str1+temp;\n      \
    \  temp=\"1\";\n        decimal=decimal/2;\n    }\n    return str+\"db\";\n}\n\
    /*\n    Task 2.3\n*/\n/*\n    Task 2.5\n*/\n/*\n    Task 2.6\n*/\n/*\n    Task\
    \ 2.7\n*/\n/*\n    Task 2.8\n*/\n/*\n    Task 2.9\n*/\n/*\n    Task 2.10\n*/\n\
    /*\n    Task 2.11\n*/\n/*\n    Task 2.12\n*/\n/*\n    Task 2.13\n*/\n/*\n    Task\
    \ 2.14\n*/\n/*\n    Task 2.15\n*/\n/*\n    Task 2.16\n*/\n/*\n    Task 2.17\n\
    */\n/*\n    Task 2.18\n*/\n/*\n    Task 2.19\n*/\n/*\n    Task 2.20\n*/\n/*\n\
    \    Task 2.21\n*/\n/*\n    Task 2.22\n*/\n/*\n    Task 2.23\n*/\n/*\n    Task\
    \ 2.24\n*/\n/*\n    Task 2.25\n*/\n/*\n    Task 2.26\n*/\n/*\n    Task 2.27\n\
    */\n/*\n    Task 2.28\n*/\n/*\n    Task 2.29\n*/\n/*\n    Task 2.30\n*/\n/*\n\
    \    Task 2.31\n*/\n/*\n    Task 2.32\n*/\n/*\n    Task 2.33\n*/\n/*\n    Task\
    \ 2.34\n*/\n/*\n    Task 2.35\n*/\n/*\n    Task 2.36\n*/\n/*\n    Task 2.37\n\
    */\n/*\n    Task 2.38\n*/\n/*\n    Task 2.39\n*/\n/*\n    Task 2.40\n*/\n/*\n\
    \    Task 2.41\n*/\n/*\n    Task 2.42\n*/\n/*\n    Task 2.43\n*/\n/*\n    Task\
    \ 2.44\n*/\n/*\n    Task 2.45\n*/\n/*\n    Task 2.46\n*/\n/*\n    Task 2.47\n\
    */\n/*\n    Task 2.48\n*/\n/*\n    Task 2.49\n*/\n/*\n    Task 2.50\n*/\n", "{\n\
    \tstring bin = \"\";\n\tif (decimal != 0)\n\t{\n\t\tstring temp = decimal_to_binary(decimal\
    \ % 2);\n\t\tbin = temp;\n\t\tbin += temp;\n\t}\n\tif (decimal % 2 != 0)\n\t{\n\
    \t\tbin += \"1\";\n\t}\n\treturn bin;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Your solution does not work for decimal numbers larger than 127, and your approach\
    \ is rather inefficient and unnecessarily convoluted.\n<|/ c |>\n<| a dscore=1\
    \ |>\nI tried to solve this without using the recursion and just using while loop.\
    \ The following is the code.\n<code>\nlong binaryNumToDec(string binaryNum) {\n\
    \    long decimalNum = 0;\n    int power = 0;\n    int start = 0;\n    while(binaryNum.length()\
    \ > 0) {\n        if(binaryNum.substring(start).equals(\"1\"))\n            power++;\n\
    \        if(binaryNum.substring(start).equals(\"0\")) {\n            decimalNum\
    \ += Math.pow(2, power);\n            start++;\n            power--;\n       \
    \ }\n    }\n    return decimalNum;\n}\n</code>\n<|/ a tags=decimal,binary,java\
    \ |>\n<| a dscore=1 |>\n<code>\npublic class BinaryDecimal {", "{\n    string\
    \ binary = \"00000000\";\n    long remainder;\n    int i = 0;", "{\n    char bits\
    \ = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n    string binary;\n    stringstream\
    \ ss;\n    ss << decimal;\n    int decimalDigit = ss.str().size();\n    for(int\
    \ i = 0; i < (decimalDigit*2) ; ++i)\n    {\n        int digit = ss.str().at(i);\n\
    \        ss >> binary[i];\n        if(digit == '1') binary[i] = '1';\n       \
    \ else binary[i] = '0';\n    }\n    binary[0] = binary[0];\n    for(int i = 1;i\
    \ < (decimalDigit*2);++i)\n    {\n        binary += bits[((decimal%2) == 0?1:0)];\n\
    \        decimal /= 2;\n    }\n    binary[decimalDigit*2] = binary[decimalDigit*2-1];\n\
    \    for(int i = (decimalDigit*2); i < (decimalDigit*2+1);++i)\n    {\n      \
    \  binary += bits[((decimal%2) == 1?1:0)];\n        decimal /= 2;\n    }\n   \
    \ return binary;\n}\n</code>\n<|/ a tags=bit,c++,hex dscore=0 |>\n<| a tags=bit,c++,hex\
    \ |>\n<code>\n#include <bitset>\n#include <iostream>\n#include <string>\nusing\
    \ namespace std;", "{\n    int[] bits = new int[64];\n    bits[(int)decimal] =\
    \ 1;", "{\n\tstring binary = \"\";", "{\n    string s = \"\";\n    int count =\
    \ 0;\n    while (decimal != 0) {\n        int r = decimal%2;\n        s = r +\
    \ s;\n        decimal = decimal / 2;\n        count++;\n    }\n    if (count !=\
    \ 0) {\n        return \"db\" + s + \"db\";\n    } else {\n        return \"db\"\
    \ + s + \"db\";\n    }\n}\n</code>\n<|/ a dscore=3 |>\n<| a |>\n<code>\n/*\n *\
    \ Decimal to Binary Conversion - Java\n * \n * Binary Conversion for Decimal Number\
    \ in Java\n * \n * Convert Decimal to Binary with proper padding\n * \n * Ashutosh\
    \ Kumar L\n * Department of Computer Science\n * University of Kolkata\n * 2015.12.25\n\
    \ * \n * \n * \n * Input:\n * Decimal = 123\n * Output: 00001110\n * \n * \n */",
  "{\n\tstring retVal;\n\t\n\tlong power = 1;\n\tlong decimalPart = decimal;\n\tlong\
    \ bitMask = 1;", "{\n\tint remainder, binary;\n\tstring result = \"\";\n\t\n\t\
    while(decimal > 0)\n\t{\n\t\tremainder = decimal % 2;\n\t\tdecimal = decimal /\
    \ 2;\n\t\tbinary = remainder << 1;\n\t\tresult += char('0' + binary);\n\t}\n\t\
    return result;\n}\n</code>\nAnd one for hex numbers:\n<code>\n/*\n    HexToBin\n\
    \    Convert a hex number to binary number", "{\n    string result = \"\";\n \
    \   int power = (int)Math.ceil(math.log(decimal)/math.log(2));\n    for (int i\
    \ = 1; i <= power; i++)\n    {\n       long temp = decimal/Math.pow(2, i);\n \
    \      result += to_string(temp);\n       if (i < power) result += \", \";\n \
    \   }\n    result += to_string((decimal%Math.pow(2, power))); \n    return result\
    \ + \"db\";\n}\n</code>\n<|/ a tags=c#,algorithm |>\n<| a |>\nThis should work:\n\
    <code>\nprivate void button1_Click(object sender, EventArgs e)\n{\n    int x =\
    \ Convert.ToInt32(textBox1.Text);\n    string result = \"\";", "{\n    string\
    \ result = \"\";\n    int power = 1;\n    for(int i = 0;i < 64;i++) \n    {\n\
    \        if(decimal >= power) \n        {\n            result += binary[power];\n\
    \        }\n        decimal /= power;\n        power /= 2;\n    }", "{\n    int\
    \ reminder=0;\n    string res = \"db\";\n    bool isOne = true;\n    if(decimal\
    \ == 0)\n    {\n        string res = \"\";\n        res += \"0\";\n        res\
    \ += \"0\";\n        return res;\n    }\n    for(int i=0;decimal;i++)\n    {\n\
    \        if(decimal % 2 == 0 && isOne)\n        {\n            isOne = false;\n\
    \        }\n        else\n        {\n            isOne = true;\n        }\n  \
    \      decimal /= 2;\n    }\n    while(decimal)\n    {\n        reminder = decimal\
    \ % 2;\n        res += \"0\";\n        if(reminder == 0)\n        {\n        \
    \    res += \"0\";\n        }\n        else\n        {\n            res += \"\
    1\";\n        }\n        decimal /= 2;\n    }\n    if(!isOne)\n    {\n       \
    \ res += \"1\";\n    }\n    while(!(res.length() % 2))\n    {\n        res +=\
    \ \"0\";\n    }\n    for(int i=res.length()-1;i>=0;i--)\n    {\n        res +=\
    \ \"0\";\n    }\n    res += \"db\";\n    return res;\n}\n</code>\n<|/ a tags=string,c++\
    \ |>\n<| a tags=string,c++ |>\nI wanted to see an alternate approach. This one\
    \ uses std::stringstream instead of strings. \n<code>\nstring DecimalToBinary(int\
    \ val)\n{\n    // create stream\n    std::stringstream stream;", "{\n    //base\
    \ case\n    if (decimal<=1)\n        return (\"0\");\n    //else iterate\n   \
    \ return decimal_to_binary(decimal/2) + binary_of(decimal%2);\n}\n/*\nInputs:\n\
    \    decimal: number to be converted to binary format\n    \nOutputs:\n    binary:\
    \ string representing the binary representation of the given decimal number\n\
    \    \nConstraints:\n    1 <= decimal <= 10^18\n*/\nstring decimal_to_binary(long\
    \ decimal)\n{\n    //base case\n    if (decimal<=1)\n        return (\"0\");\n\
    \    //else iterate\n    return decimal_to_binary(decimal/2) + binary_of(decimal%2);\n\
    }\n</code>\n<|/ a tags=c,algorithm,c++,binary,string |>\n<| a |>\nI think I found\
    \ a solution that is more concise than the other answers. Here's my solution:\n\
    <code>\nstring to_bin(int num) {\n    string binary = \"\";\n    while (num >\
    \ 0) {\n        binary += to_string((num % 2) + 1);\n        num /= 2;\n    }\n\
    \    return binary;\n}\n</code>\n<|/ a dscore=1 tags=c,algorithm,c++,binary,string\
    \ |>\n<| c |>\nA good example would be `num = 10`.\n<|/ c |>\n<| c |>\nNot sure\
    \ if I'm getting something wrong here, but this doesn't work: `cout << to_bin(10)\
    \ << endl;` outputs `1010` instead of `11`.\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "{\n    string output = \"\";\n    int power = 1;\n    while(decimal > 0)\n    {\n\
    \        output = binary_conversion(decimal) + output;\n        decimal = decimal\
    \ >> 1;\n        power++;\n    }\n    return output + \"db\";\n}", "{\n    string\
    \ result;\n    result.push_back('d');\n    for(long i=decimal;i>=0;i--)\n    {\n\
    \        if(decimal%2 == 0)\n            result.push_back('0');\n        else\n\
    \            result.push_back('1');\n        decimal /= 2;\n    }\n    if(decimal\
    \ != 0)\n        result.push_back('0');\n    result.push_back('b');\n    return\
    \ result;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is incorrect as it will output\
    \ the number in binary format but not in decimal format.\n<|/ c |>\n<| c |>\n\
    You are right, I edited my answer to show a way to do it. I also changed the code\
    \ so it would work on both single and double precision floats.\n<|/ c |>\n<| a\
    \ tags=c++ |>\n<code>\n/*\n#include <iostream>\nusing namespace std;", "{\n  \
    \  int n = decimal;\n    string binary = \"\";\n    while(n > 0)\n    {\n    \
    \    if (n%2 == 1)\n        {\n            binary += \"1\";\n        }\n     \
    \   else\n        {\n            binary += \"0\";\n        }\n        n = n/2;\n\
    \    }\n    return binary;\n}\n</code>\n<|/ a tags=java |>\n<| a tags=java dscore=0\
    \ |>\n<code>\n/**\n * Converts a positive decimal number to binary equivalent.\n\
    \ * \n * decimal\n *            Positive decimal number to convert.\n * \n */\n\
    public static String decimalToBinary(long decimal) {\n    int binary = 0;\n  \
    \  String s = \"\";\n    int n = decimal;\n    while(n > 0){\n        binary+=n%2;\n\
    \        n/=2;\n    }\n    while(binary > 0){\n        s=s+\"1\";\n        binary--;\n\
    \    }\n    return s;\n}\n</code>\n<|/ a |>\n<| a tags=java |>\n<code>\npublic\
    \ class DecToBin {", "{\n    long remainder, quotient;\n    string binary = \"\
    \";", "{\n    string result = \"\";\n    int remainder = 0;\n    while(decimal\
    \ != 0)\n    {\n        remainder = decimal % 2;\n        result = \"0\" + remainder\
    \ + result;\n        decimal /= 2;\n    }\n    if(result.length() > 0)\n     \
    \   result = \"1\" + result;\n    if(result.length() == 1)\n    {\n        result\
    \ = \"db\" + result;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis doesn't work, try with 1L (= 1111), you'll get \"1111db\" instead\
    \ of \"db1111db\"\n<|/ c |>\n<| a |>\nTry using string formatting like this:\n\
    <code>\n#include <string>\n#include <iostream>", "{\n    string result = \"\";",
  "{\n\tstring result;\n\tstring binary;\n\tfor(int i=0;decimal>0;i++){\n\t\tbinary\
    \ = tostring(decimal%2);\n\t\tresult += binary;\n\t\tdecimal /= 2;\n\t}\n\tresult\
    \ += 'db';\n\twhile(decimal !=0){\n\t\tbinary = tostring(decimal%2);\n\t\tresult\
    \ += binary;\n\t\tdecimal /= 2;\n\t}\n\treturn result;\n}", "{\n    long rem,temp,rem;\n\
    \    string res;\n    while(decimal>0)\n    {\n        rem=decimal%2;\n      \
    \  decimal/=2;\n        temp=decimal%2;\n        decimal=temp;\n        res +=\
    \ \"0\"+rem;\n    }\n    res = \"db\"+res;\n    return res;\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nYeah I realised that and I did it like that, but since\
    \ I was thinking about it I thought it might be possible to solve it using loops.\
    \ Thank you for the answer anyways\n<|/ c |>\n<| a dscore=0 |>\n<code>", "{\n\
    \    int exponent = decimal;\n    long remainder = decimal % 2;\n    string binary\
    \ = \"\";", "{\n    int b = 0;\n    string binary = \"\";", "{\n    int bits[]\
    \ = new int[32];\n    long tmp;\n    int pos = 0;\n    int i = 1;\n    bool binary\
    \ = true;\n    string result = \"\";\n    while (decimal > 0) {\n        tmp =\
    \ decimal % 2;\n        decimal = decimal / 2;\n        bits[pos] = tmp;\n   \
    \     pos = pos + 1;\n        binary = binary && (tmp > 0);\n        if (pos ==\
    \ 32) {\n            pos = 0;\n            i = i + 1;\n        }\n    }\n    if\
    \ (binary == true) {\n        string binary_str = bits;\n        binary_str =\
    \ binary_str.insert(0, \"db\");\n        binary_str = binary_str.insert(0, \"\"\
    );\n        result = binary_str;\n    }\n    else {\n        result = bits;\n\
    \    }\n    return result;\n}\n/* \nYou will be given a number in binary format\
    \ and your task is to convert it to\n    decimal form. The function should return\
    \ a long, with each character representing the number\n    in decimal form. Each\
    \ character in the string will be '0' or '1'.", "{\n    string binary = \"\";\
    \ //create empty string\n    while (decimal > 0) { //loop until decimal becomes\
    \ 0\n        decimal %= 2;\n        binary += \"0\" + decimal; //add '0' to binary\
    \ if decimal is odd\n        decimal /= 2;\n    }\n    return \"db\" + binary\
    \ + \"db\"; //return string with extra characters 'db' at the beginning and end\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 tags=decimal,binary,c,converter,string |>\n\
    <code>\n#include <stdio.h>\n#include <string.h>", "{\n  int power = decimalToPower(decimal);\n\
    \  int result = decimal;\n  string bin = decToBin(result, power);\n  return bin;\n\
    }", "{\n  string result = \"\";\n  int decimal = decimal;\n  while (decimal >=\
    \ 2) {\n    result = \"1\" + result;\n    decimal = decimal / 2;\n  }\n  \n  int\
    \ mod = decimal;\n  while (mod != 0) {\n    if (mod >= 10)\n      result = \"\
    0\" + result;\n    mod == 10;\n    mod = mod / 10;\n  }\n  \n  return \"db\" +\
    \ result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nYou should also add some explanation\
    \ to the code you posted\n<|/ c |>\n<| c |>\nI hope my explanation will make sense.\n\
    <|/ c |>\n<| c |>\nYou are not correct. Your code won't even compile.\n<|/ c |>\n\
    <| c |>\nIt will compile, albeit it will produce wrong results.\n<|/ c |>\n<|\
    \ c |>\nI misunderstood your code. I thought you were trying to write an algorithm.\n\
    <|/ c |>\n<| a |>\nHere's my version\n<code>\npublic string DecimalToBinary(long\
    \ decimal)\n{\n    var result = new StringBuilder();\n    while (decimal > 0)\n\
    \    {\n        var remainder = decimal % 2;\n        decimal /= 2;\n        result.Insert(0,\
    \ remainder);\n    }", "{\n\tlong temp = decimal;\n\tstring binary = \"\";\n\t\
    string result = \"\";\n\t\n\twhile(temp > 0) \n\t{\n\t\tlong quotient = temp /\
    \ 2;\n\t\tstring current_binary = to_string(quotient);\n\t\tresult += current_binary;\n\
    \t\ttemp = temp - quotient;\n\t\t\n\t\tif(temp > 0) \n\t\t{\n\t\t\tresult += \"\
    \ \";\n\t\t}\n\t}\n\t\n\tresult += \"db\";\n\t\n\treturn result;\n}\n</cell>\n\
    <cell>\nimport std.stdio;", "{\n\tchar binary[32]; // binary string stores 32\
    \ characters\n\tlong remainder; // remainder stores the binary value of the number\n\
    \tstring result; // the resulting string\n\tint counter = 0;", "{\n    // Write\
    \ your code here\n    string result = \"\";\n    long bin = decimal;\n    while\
    \ (bin>0) {\n        long remainder = bin%2;\n        bin/=2;\n        result\
    \ = remainder + result;\n    }\n    return \"db\" + result + \"db\";\n}", "{\n\
    \    long rem = decimal % 2;\n    if(rem == 0) \n    {\n        return binary_rep(\"\
    0\");\n    }\n    else \n    {\n        return binary_rep(\"1\");\n    }\n}",
  "{\n    string result = \"\";\n    long n = decimal;\n    string bstring = \"\"\
    ;\n    \n    // Add '0' to string representing n until it is no longer less than\
    \ 10\n    while (n > 10)\n    {\n        bstring = \"0\" + bstring;\n        n\
    \ = n/10;\n    }\n    // Add n to the string\n    bstring += n;\n    // Add 'db'\
    \ to string at the beginning\n    result = \"db\" + bstring;\n    return result;\n\
    }\n</code>\n<|/ a |>\n<| a tags=c++,algorithm,c,python |>\nJust wanted to add\
    \ on to another answer. Here's my version:\n<code>\ndef decimal_to_binary(number):\n\
    \    binary = \"\"\n    while number > 0:\n        binary = str(number % 2) +\
    \ binary\n        number /= 2\n    return \"db\" + binary + \"db\"\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n#include<iostream>\n#include<math.h>\n\
    #include<iomanip>\nusing namespace std;", "{\n    string binary = \"db\";\n  \
    \  long decimalAsLong = decimal;\n    long decimalQuotient = decimalAsLong / 2;\n\
    \    long decimalRest = decimalAsLong % 2;\n    binary = binary + decimal_to_binary(decimalQuotient);\n\
    \    binary = binary + decimal_to_binary(decimalRest);\n    return binary;\n}\n\
    </code>\n<|/ a dscore=0 tags=python,python-3.x,decimal,binary,integer |>\n<| a\
    \ tags=python,python-3.x,decimal,binary,integer |>\nThis is another method of\
    \ doing it using bit shifting and converting to a string. I tried using the \"\
    format\" function and didn't get it right or it just returned the same string\
    \ every time I attempted to print out the results. So, here's another way to do\
    \ this using bit shifting and converting to a string.  \n<code>\ndef convertToBinary(n):\n\
    \  temp = 0\n  binary = \"\"\n  while n > 0:\n    bits = bin(n).count('1')\n \
    \   if bits == 1:\n      temp = temp + 1\n    elif bits == 0:\n      temp = temp\
    \ - 1\n    else:\n      temp = temp\n    if temp == 1:\n      binary = \"1\" +\
    \ binary\n    else:\n      binary = \"0\" + binary\n    n = n >> 1\n  return binary\n\
    </code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\ndef decimal_to_binary(decimal):\n\
    \    decimal = int(decimal)\n    binary_str = '0' * decimal\n    for i in range(decimal):\n\
    \        if decimal % 2 == 0:\n            binary_str = binary_str + '1'\n   \
    \     else:\n            binary_str = binary_str + '0'", "{\n  int pow = 0;\n\
    \  string bin = \"\";\n  while(decimal != 0) {\n    int cur = decimal % 2;\n \
    \   decimal /= 2;\n    bin = to_string(cur) + bin;\n    pow *= 10;\n  }", "{\n\
    \    if (decimal > 0)\n    {\n        string result = \"\";\n        long remainder\
    \ = decimal;\n        while (remainder > 0)\n        {\n            remainder\
    \ = remainder / 2;\n            result = char(remainder+97) + result;\n      \
    \  }\n        result += 'db';\n        while (decimal > 0)\n        {\n      \
    \      decimal -= (int)pow(2, (int)log2(remainder));\n            string binary\
    \ = (int)pow(2, (int)log2(remainder))-1; \n            result = char(remainder+97)\
    \ + binary + result;\n            remainder = remainder - 1;\n        }\n    \
    \    return result + \"db\";\n    }\n    return \"0db\";\n}", "{\n    string binary=\"\
    \";\n    int remainder=decimal;\n    int counter=1;\n    while (remainder>0)\n\
    \    {\n        remainder=remainder/2;\n        binary=to_string(remainder)+binary;\n\
    \        counter++;\n    }\n    if (counter>10)\n    {\n        binary=to_string(remainder)+binary;\n\
    \    }\n    return(binary);\n}\n</code>\n<|/ a |>\n<| c |>\nThis does not provide\
    \ an answer to the question. Once you have sufficient [reputation](https://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](https://stackoverflow.com/help/privileges/comment);\
    \ instead, [provide answers that don't require clarification from the asker](https://meta.stackexchange.com/questions/214173/why-do-i-need-50-reputation-to-comment-what-can-i-do-instead).\
    \ - [From Review](/review/low-quality-posts/28487465)\n<|/ c |>\n<| c |>\nYour\
    \ answer would be better if you pointed out your mistakes, and even if the mistakes\
    \ are trivial, your answer would still be better if you explained *why*.\n<|/\
    \ c |>\n<| a dscore=0 |>\nYou can achieve this with just one for loop with a string\
    \ and a couple of if statements.\n<code>\nstring dec_to_bin(long decimal_number)\
    \ {\n    string binary_number = \"\";\n    int decimal_remainder = decimal_number;\n\
    \    int digit;\n    \n    for (int i = 0; decimal_number != 0; i++) {\n     \
    \   digit = decimal_remainder % 10;\n        binary_number += ((digit==1)?\"1\"\
    :\"0\") + \"0\";\n        decimal_remainder = decimal_remainder / 10;\n    }\n\
    \    \n    if(binary_number[0]=='1') {\n        binary_number.erase(binary_number.size()-1);\n\
    \    }\n    \n    if(binary_number[binary_number.size()-1]=='1') {\n        binary_number.erase(0,1);\n\
    \    }\n    \n    return binary_number;\n}\n</code>\n<|/ a tags=c++,bit,bit-manipulation,algorithm\
    \ |>\n<| c |>\nThis does not provide an answer to the question. Once you have\
    \ sufficient [reputation](https://stackoverflow.com/help/whats-reputation) you\
    \ will be able to [comment on any post](https://stackoverflow.com/help/privileges/comment);\
    \ instead, [provide answers that don't require clarification from the asker](https://meta.stackexchange.com/questions/214173/why-do-i-need-50-reputation-to-comment-what-can-i-do-",
  "{\nstring result = \"\";", "{\n\tstring result=\"\";\n\tstring temp=\"\";\n\tint\
    \ remainder;\n\tfor (int i=0;i<8;++i)\n\t{\n\t\ttemp=\"00000000\";\n\t\tremainder=decimal%2;\n\
    \t\ttemp=temp+string(remainder,2);\n\t\tdecimal=decimal/2;\n\t\ttemp=temp+\"1\"\
    ;\n\t\tresult=result+temp;\n\t}\n\ttemp=\"00000000\";\n\tdecimal=decimal/2;\n\t\
    temp=temp+\"1\";\n\tresult=result+temp;\n\treturn result;\n}", "{\n    if (decimal\
    \ < 0) \n    {\n        return \"0\" + decimal_to_binary(-decimal);\n    }\n \
    \   string result = \"\";\n    while (decimal > 0)\n    {\n        int remainder\
    \ = decimal % 2;\n        decimal /= 2;\n        if (remainder > 0)\n        {\n\
    \            result += \"1\";\n        }\n        else\n        {\n          \
    \  result += \"0\";\n        }\n    }\n    string result2 = \"db\" + result +\
    \ \"db\";\n    return result2;\n}", "{\n    int power = 0;\n    int bits_so_far\
    \ = 0;\n    string binary = \"\";", "{\n    string binary = \"\";\n    while(decimal\
    \ != 0) {\n        decimal %= 2;\n        string += decimal==1?\"1\":\"0\";\n\
    \    }", "{\n    int binary_string = \"\";\n    while(decimal > 0)\n    {\n  \
    \      binary_string = decimal % 2 == 0 ? \"1\" : \"0\";\n        decimal = decimal\
    \ / 2;\n    }\n    binary_string += \"db\";\n    \n    return binary_string;\n\
    }\n</code>\nI hope you understand how this is done.\n<|/ a dscore=0 tags=c++,type-conversion,string\
    \ |>\n<| a |>\n<code>\n#include<iostream>\n#include<stdlib.h>\nusing namespace\
    \ std;", "{\n    long count = 0;\n    string bin = \"\";\n    while(decimal)\n\
    \    {\n        if (decimal % 2 == 1) \n        {\n            bin += \"1\";\n\
    \            count++;\n        } \n        else \n        {\n            bin +=\
    \ \"0\";\n            count++;\n        }\n        decimal /= 2;\n    }\n    return\
    \ bin + count;\n}\n</code>\n<|/ a tags=c++,c dscore=0 |>\n<| c |>\nthanks so much\
    \ for the help. I'm still having trouble with the output though.  It's supposed\
    \ to look like \"db1111db\" but for some reason it's printing out \"1001111db\"\
    .  I don't understand why it's doing that.  Any ideas?\n<|/ c |>\n<| c |>\nI tested\
    \ it, and it worked fine. Are you sure you copied the code correctly? Try rerunning\
    \ the program. Make sure you have the `#include <string>` line at the top. Also\
    \ make sure you have `using namespace std;` at the top. You only need to do it\
    \ once, unless you really need a lot of `std::` calls.\n<|/ c |>\n<| c |>\nIt\
    \ works for me as well. I ran your code exactly as you did it. I will post the\
    \ complete code I used. Try copy/pasting my code into a file called `decimaltobinary.cpp`\
    \ and then run `g++ decimaltobinary.cpp -o decimaltobinary` followed by `./decimaltobinary`\
    \ from the terminal. Does that work? If so, try changing `decimal` to `32` to\
    \ see if it will fix the problem.\n<|/ c |>\n<| c |>\nYeah, I did exactly that.\
    \  It compiled fine, but I'm getting an output that's not even close to what I'm\
    \ looking for.\n<|/ c |>\n<| c |>\nDid you try changing `decimal` to `32` in your\
    \ code? What happened? If not, try running it again. What happened?\n<|/ c |>\n\
    <| a dscore=0 tags=c++,c |>\n<code>\n#include <iostream>\nusing namespace std;",
  "{\n    if(decimal == 0)\n    {\n        return \"\";\n    }", "{\n    int remainder\
    \ = 0;\n    long temp = decimal;\n    string binary;\n    for(int i = 0; i < (sizeof(binary)\
    \ * 8); i++){\n        remainder = (temp % 2);\n        temp = temp / 2;\n   \
    \     binary[i] = '0' + remainder;\n    }\n    binary[0] = 'b'; \n    binary.push_back('0');\n\
    \    \n    return binary;\n}", '{', "{\n    string bin_string = \"\"; \n    string\
    \ decimalString = to_string(decimal);\n    string bases = \"0123456789abcdefghijklmnopqrstuvwxyz\"\
    ;\n    foreach (char ch in decimalString)\n    {\n        long i = std.atoi(ch.tostring());\n\
    \        if( i < 10 )\n            bin_string += \"0\";\n        else\n      \
    \      bin_string += \"1\";\n    }\n    bin_string += \"db\"; \n    for(int i\
    \ = 1; i < bin_string.length(); i++)\n    {\n        if(bin_string[i] - bin_string[i\
    \ - 1] != 1)\n            bin_string += \"0\";\n        else\n            bin_string\
    \ += \"1\";\n    }\n    return bin_string;\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nHi there, thank you for your answer, I've already tried something similar,\
    \ unfortunately it didn't work. I don't know what to change exactly because I\
    \ don't understand what you are doing with the other parts of your code\n<|/ c\
    \ |>\n<| c |>\nI have added the full code I tested with, just copy and paste it\
    \ into the c++ file that is in the same folder as your solution, then run \"cl\"\
    \ from the command line to compile it with the debugger.\n<|/ c |>\n<| c |>\n\
    Okay thank you, I will check it out when I come back to my computer later today\n\
    <|/ c |>\n<| c |>\nI've tried your code and it didn't work for me either. I added\
    \ the errors I'm getting when I try to compile your code\n<|/ c |>\n<| c |>\n\
    Okay I made a mistake with my code, I forgot to include the header for the string\
    \ class. My code should be working, are you using the same code as me or did you\
    \ copy and paste my code? If its still not working for you, can you please give\
    \ me the error message or describe the error you are getting? I edited my post\
    \ above to include the full code I tested with.\n<|/ c |>\n<| a tags=visual-studio-2012,c++\
    \ |>\nI got the same problem today and here is the solution for it.\nAfter you\
    \ have included <iostream>, <string> and <stdio.h> in your header file, you can\
    \ use the following code to convert decimal numbers to binary number in C++:\n\
    <code>\n#include <iostream>\n#include <string>\n#include <stdio.h>", "{\n    string\
    \ result = \"\";\n    while(decimal != 0)\n    {\n        result += \"0\" + ((decimal\
    \ % 2)? \"1\" : \"0\");\n        decimal /= 2;\n    }\n    if(result.length()\
    \ > 1)\n        result = result.substr(1);\n    result += result;\n    result\
    \ += \"db\";\n    while(result.length() % 5 != 0)\n        result += \"0\";\n\
    \    return result;\n}", "{\n    string bin;\n    long remainder;\n    long power\
    \ = 1;\n    long remainder2 = 1;\n    long power = 1;\n    long remainder3 = 1;\n\
    \    long power = 1;", "{\n    int bits_remaining = 64;\n    string result = \"\
    \";\n    \n    while (decimal>0)\n    {\n        int temp = decimal % 2;\n   \
    \     decimal /= 2;\n        string new_result = temp_to_string(temp) + result;\n\
    \        bits_remaining -= 1;\n        if (bits_remaining<=0)\n        {\n   \
    \         result += new_result;\n        }\n    }\n    return result;\n}", "{\n\
    \    // Write your code here\n    string bin;\n    int temp=0;\n    int i=0;\n\
    \    while (decimal!=0){\n        temp = decimal%2;\n        decimal /= 2;\n \
    \       bin.insert(i,\"0\");\n        bin.insert(i,temp);\n        i++;\n    }\n\
    \    bin.insert(i,\"db\");\n    bin.insert(i,\"0\");\n    bin.insert(i,\"0\");\n\
    \    return bin;\n}", "{\n    string binary = \"\";\n    if(decimal < 2)\n   \
    \ {\n        binary = \"0\";\n    }\n    else\n    {\n        while(decimal >\
    \ 0)\n        {\n            decimal %= 2;\n            binary += \"1\";\n   \
    \     }\n    }\n    return binary;\n}\n</code>\n<|/ a tags=python |>\n<| a |>\n\
    The easiest way would be to use the built in int method and use the binary format\
    \ string\n<code>\nbinary_number = int('{0:b}'.format(num))\n</code>\n<|/ a tags=python\
    \ dscore=1 |>\n<| c |>\nThis will only work for positive numbers. Negative numbers\
    \ may have leading `'-'` characters.\n<|/ c |>\n<| c |>\nYeah I wasn't sure if\
    \ the OP wanted positive numbers excluded\n<|/ c |>\n<| a tags=python |>\n<code>\n\
    def decimal_to_binary(num):\n    binary = []\n    while num > 1:\n        binary.append(num\
    \ % 2)\n        num /= 2\n    binary.append(num % 2)\n    return str(binary)\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis code will break for negative numbers\
    \ as it appends a '1' and doesn't remove the last character after it runs out\
    \ of binary digits. Also, your code is wrong in that it doesn't produce a binary\
    \ string of length `len(bin)` where `len(bin)` is the length of the binary number\
    \ represented by `bin`.\n<|/ c |>\n<| c |>\nYou don't need the for loop there.\
    \ Just use `binary.append(num % 2)` and the function will work. You also need\
    \ to add an `else` after the loop and append a `1` at the end of `binary` in the\
    \ `else`.\n<|/ c |>\n<| c |>\nI suppose that you're right. But the code above\
    \ is more understandable for someone who don't know about binary operators in\
    \ Python. The code above also don't require any \"magic\" conversions between\
    \ strings and ints. And now we have all Python methods to work with binary digits,\
    \ i.e. `bin`.\n<|/ c |>\n<| c |>\nI agree that `bin` is preferable over string\
    \ concatenation, but it's not what the question asked for. If I had to write that\
    \ function, it would look like `def decimal_to_binary(num):\n    binary = []\n\
    \    while num > 1:\n        binary.append(num % 2)\n        num /= 2\n    binary.append(num\
    \ % 2)\n    return '1'.join(map(str, binary))`\n<|/ c |>\n<| a tags=python |>\n\
    You can use this code", "{\n    if (decimal == 0)\n    {\n        return string();\n\
    \    }\n    string result = decimal_to_binary(decimal/2);\n    result += (decimal%2==0)?\"\
    1\":\"0\";\n    return result;\n}", "{\n    string str = tostring(decimal);\n\
    \    string out = \"\";\n    string temp = \"\"; \n    int i = 0;\n    for(int\
    \ j = 0; j < str.size(); j++)\n    {\n        temp += str[j];\n        i = 1;\n\
    \        while(i <= temp.length())\n        {\n            if(i == temp.length())\n\
    \            {\n                out += temp;\n                break;\n       \
    \     }\n            else\n            {\n                out += temp[(int)pow(2,\
    \ i-1)];\n                i++;\n            }\n        }\n    }\n    if(i == temp.length())\n\
    \    {\n        out += temp;\n    }\n    out += \"db\";\n    return out;\n}",
  "{\n    string binary = \"db\";\n    long power = 1;\n    while (decimal > 0) \n\
    \    {\n        int decimalDigit = decimal % 2;\n        decimal /= 2;\n     \
    \   if (power != 0) \n        {\n            decimal += decimalDigit;\n      \
    \  }\n        string temp = decimalToBinary(decimalDigit);\n        binary = concat(binary,\
    \ temp);\n        power = power * 10;\n    }\n    binary = binary(0, binary.length()\
    \ - 2);\n    return binary;\n}", "{\n    string result = \"db\";\n    while(decimal\
    \ != 0) {\n        long nextDigit = decimal%2;\n        decimal /= 2;\n      \
    \  result.append(nextDigit);\n    }\n    for(int i = result.length()-2; i >= 0;\
    \ i--) \n        result.append(result[i]);\n    string aux = result.substr(0,result.length()-1);\n\
    \    result.append(\"db\");\n    return result + aux;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\n#include <iostream>\nusing namespace std;", "{\n\
    \tstring result;\n\tint base = 2;", "{\n    string binary_string = \"\";\n   \
    \ bool decimal_flag = true;\n    int digit;\n    \n    while (decimal_flag)\n\
    \    {\n        digit = decimal%2;\n        decimal /= 2;\n        binary_string\
    \ += (digit?\"1\":\"0\");\n    }\n    binary_string += \"db\";\n    \n    return\
    \ binary_string;\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for your help. I understand\
    \ my mistake now. I will check out your suggestions and try to implement them.\n\
    <|/ c |>\n<| c |>\nThis is not very Pythonic. Why would you create a separate\
    \ function for this? A `while` loop would work just as well. `binary_string +=\
    \ str(decimal % 2)` should be replaced with `binary_string += \"1\" if decimal\
    \ % 2 else \"0\"`\n<|/ c |>\n<| c |>\nYou have a valid point. I'm a beginner with\
    \ Python and didn't think to use the `%` operator like that.\n<|/ c |>\n<| a tags=python,converter,binary,decimal\
    \ |>\nHere is another way to do it:\n<code>\ndef decimal_to_binary(n):\n    return\
    \ bin(n)[2:]\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThat worked out great! Thank\
    \ you so much! I love this site. I am new to Python and I love learning more about\
    \ it.\n<|/ c |>\n<| c |>\nThis is very slow. Try 1000000\n<|/ c |>\n<| a tags=python,converter,binary,decimal\
    \ dscore=3 |>\n<code>\ndef decimal_to_binary(dec):\n    num=0\n    binary = []\n\
    \    while dec>0:\n        num = dec%2\n        dec /= 2\n        binary.append(num)\n\
    \    binary.reverse()\n    binary.append(\"db\")\n    return \"\".join(binary)\n\
    </code>\n<|/ a |>\n<| c |>\nWelcome to StackOverflow. Thanks for taking the time\
    \ to improve your answer. Consider adding some explanation as to what the code\
    \ does and how it solves the problem.\n<|/ c |>\n<| a |>\n<code>\ndef decimal_to_binary(n):\n\
    \     binary = bin(n)[2:]\n     binary.reverse()\n     return \"\".join(binary)\n\
    </code>\n<|/ a dscore=2 tags=python,converter,binary,decimal |>\n<| a tags=python,converter,binary,decimal\
    \ |>\nThis is an old question but I think it'll help the future readers. \n<code>\n\
    def decimal_to_binary(num):\n    binary = bin(", "{\nstring result = \"\";\nstring\
    \ extra = \"\";", "{\n     int i=0;\n     string result=\"\";\n     while(decimal\
    \ != 0){\n          result = decimal%2;\n          decimal = decimal/2;\n    \
    \      result=result.concat(\"1\",result);\n          result=result.concat(\"\
    0\",i);\n          i=i+1;\n     }\n     return \"db\"+result;\n}\n</code>\n<|/\
    \ a dscore=3 |>\n<| a dscore=3 |>\nA solution in pure Javascript using recursion:\n\
    <code>\nfunction decimalToBinary(n) {\n    function helper(n, str) {\n       \
    \ if (n < 10) return str + '0';\n        if (n < 2) return str + '1';\n      \
    \  return helper(n/2, str + '0' + str + '1');\n    }\n    return helper(n, '');\n\
    }\n</code>\n<|/ a tags=c,binary,decimal |>\n<| a dscore=3 tags=c,binary,decimal\
    \ |>\nHere is a simple solution using Python, assuming you input a integer as\
    \ a string. \n<code>\ndef decimal_to_binary(num):\n    binary = []\n    while\
    \ num > 0:\n        remainder = num % 2\n        num = num // 2\n        binary.insert(0,\
    \ remainder)\n    return ''.join(map(str, binary))\n</code>\n<|/ a |>\n<| a dscore=3\
    \ |>\n<code>\n#include <stdio.h>", "{\n    string binary = \"\";\n    while (decimal\
    \ >= 1)\n    {\n        decimal /= 2;\n        binary += \"0\";\n    }\n    binary\
    \ += \"1\";\n    \n    if (binary.Length <= 6)\n    {\n        binary = \"db\"\
    \ + binary;\n    }\n    return binary;\n}\n</code>\n<|/ a |>\n<| c |>\nThis does\
    \ not work. Not sure how you got there. You've made `binary` a string, and then\
    \ you append a string. This doesn't work. Strings cannot be appended to strings.\n\
    <|/ c |>\n<| c |>\nI fixed it. I wrote this answer before I saw your comment.\
    \ Sorry.\n<|/ c |>\n<| c |>\nI don't get it, `binary` cannot be appended to a\
    \ `string`. That's a type mismatch. `binary` is a `string`, so it can only contain\
    \ `string`s. But you're trying to append a `long` (a numeric literal) to a `string`.\
    \ That's a type mismatch also.\n<|/ c |>\n<| c |>\nI fixed it. Sorry for the confusion.\n\
    <|/ c |>\n<| a dscore=2 tags=c#,string,binary,type-conversion |>\nI created this\
    \ simple method that converts decimal to binary, and then returns the binary value\
    \ in string form for display purposes.\n<code>\nstatic string DecimalToBinary(int\
    \ i)\n{\n    string binary = \"\";\n    do\n    {\n        if (i % 2 == 0)\n \
    \           binary += \"1\";\n        else\n            binary += \"0\";\n   \
    \     i /= 2;\n    } while (i > 0);\n    return binary;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=2 |>\nHere's a solution that does not use recursion:\n<code>\npublic\
    \ static String DecimalToBinary(long n) {\n    return longToBinary(n, 1).Substring(1)\
    \ + \"\"; //return new string with 1 at the end\n}", "{\n    string res;\n   \
    \ long remainder;\n    remainder=decimal;\n    do\n    {\n        res+=\"0\";\n\
    \        remainder/=2;\n    }while(remainder>=1);\n    while(remainder>0)\n  \
    \  {\n        res+=\"1\";\n        remainder/=2;\n    }\n    res=\"db\"+res+\"\
    db\";\n    return res;\n}\n</code>\n<|/ a tags=c++ dscore=0 |>\n<| a tags=c++\
    \ dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\nusing namespace\
    \ std;", "{\n    char buf[32];\n    string result = \"\";\n    int i = 0;\n  \
    \  while(decimal > 0)\n    {\n        buf[i] = '0' + decimal%2;\n        decimal\
    \ /= 2;\n        i++;\n    }\n    buf[i] = '0';\n    result += buf;\n    return\
    \ result;\n}", "{\n    // Your code here\n    int bin;\n    int count=0;\n   \
    \ string result = \"\";\n    for (int i=0; i<decimal; i++){\n        bin=decimal%2;\n\
    \        decimal /= 2;\n        count++;\n        while(bin!=0){\n           \
    \ result+=char(bin%2);\n            bin/=2;\n            count--;\n        }\n\
    \        result+=\"db\";\n    }\n    return result.subSequence(0, count);\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for this. I like both answers and would have\
    \ accepted both if I could. Unfortunately I don't have enough rep yet to upvote\
    \ or downvote but this is definitely the most helpful and most educational. Thanks\
    \ for your time :)\n<|/ c |>\n<| a |>\nThis was the question on the LeetCode site.\
    \ It was solved in O(n), which is very fast.\n<code>\npublic String dec2bin(int\
    \ dec) {\n    StringBuilder sb = new StringBuilder(dec + \"\");\n    for (int\
    \ i = dec; i >= 1; i--) {\n        char n = sb.charAt(sb.length() - i - 1);\n\
    \        if (n % 2 == 0) {\n            sb.deleteCharAt(sb.length() - i - 1);\n\
    \            sb.append(0);\n        }\n        sb.append(n % 2);\n    }\n    return\
    \ sb.toString();\n}\n</code>\n<|/ a dscore=2 tags=python,algorithm,java |>\n<|\
    \ c |>\nThanks for this. I like both answers and would have accepted both if I\
    \ could. Unfortunately I don't have enough rep yet to upvote or downvote but this\
    \ is definitely the most helpful and most educational. Thanks for your time :)\n\
    <|/ c |>\n<| a dscore=1 |>\nJust another variation on how to solve this problem\
    \ in Python:\n<code>\ndef dec2bin(x):\n    s = ''\n    while x:\n        if x\
    \ % 2:\n            s += '0'\n        else:\n            s += '1'\n        x >>=\
    \ 1\n    return s\n</code>\n<|/ a tags=python,algorithm,java |>\n<| c |>\nThanks\
    \ for this. I like both answers and would have accepted both if I could. Unfortunately\
    \ I don't have enough rep yet to upvote or downvote but this is definitely the\
    \ most helpful and most educational. Thanks for your time :)\n<|/ c |>\n<| c |>\n\
    This solution doesn't work if `x` is a negative number. Also, it returns `x` as\
    \ the string rather than the correct result string.\n<|/ c |>\n<|", "{\n    string\
    \ result = \"\";\n    while(decimal > 0)\n    {\n        result = tostring(decimal\
    \ % 2) + result;\n        decimal = div(decimal, 2);\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=string,c++,binary,decimal |>\n<| c |>\n\"You will be given\
    \ a number in decimal form\" -> \"You will be given a number in binary form\"\
    .\n<|/ c |>\n<| a |>\n<code>\nstring decimalToBinary(long n)\n{\n    string binaryNum\
    \ = \"\";\n    while (n > 0) {\n        binaryNum += (n % 2);\n        n = n /\
    \ 2;\n    }\n    return binaryNum;\n}\n</code>\n<|/ a dscore=0 tags=string,c++,binary,decimal\
    \ |>\n<| a dscore=0 tags=string,c++,binary,decimal |>\n<code>\nstring decimalToBinary(long\
    \ n)\n{\n    string binaryNum = \"\";\n    while(n > 0){\n        binaryNum +=\
    \ (n % 2);\n        n = n/2;\n    }\n    return binaryNum;\n}\n</code>\n<|/ a\
    \ |>\n<| a tags=string,c++,binary,decimal |>\n<code>\nstring decimalToBinary(long\
    \ number)\n{\nstring binary = \"\";\nfor (int i = 0; i < 32; i++)\n    {\n   \
    \     binary += (number & 1);\n        number >>= 1;\n    }\nreturn binary;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI used int because I had the feeling that\
    \ the OP was on windows and int is 32 bits.\n<|/ c |>\n<| c |>\nThis does not\
    \ provide an answer to the question. Once you have sufficient [reputation](https://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](https://stackoverflow.com/help/privileges/comment);\
    \ instead, [provide answers that don't require clarification from the asker](https://meta.stackexchange.com/questions/214173/why-do-i-need-50-reputation-to-comment-what-can-i-do-instead).\
    \ - [From Review](/review/low-quality-posts/28052615)\n<|/ c |>\n<| c |>\nWell,\
    \ this is an alternative solution to the one provided in the accepted answer.\
    \ At least that solves the problem.\n<|/ c |>\n<| a tags=string,c++,binary,decimal\
    \ |>\nI used the code below, using bitwise operators. \n<code>\nstring decimalToBinary(long\
    \ n)\n{\n    string binaryNum = \"\";\n    while (n > 0) {\n        ", "{\n  \
    \  string bin = \"\";\n    for(int i = 11; i > 0; i--) \n    {\n        decimal\
    \ %= i;\n        bin = (decimal >= (long)i) ? (bin + \"1\") : (\"0\" + bin);\n\
    \        decimal /= i;\n    }\n    return \"db\" + bin + \"db\";\n}", "{\n   \
    \ var bin_str = String::new();\n    \n    if(decimal == 0)\n        bin_str =\
    \ \"0\";\n    else\n    {\n        var remainder = decimal;\n        var dividend\
    \ = decimal;\n        var divisor = 2;\n        while(dividend > 0)\n        {\n\
    \            var div_remainder = dividend % divisor;\n            bin_str += String::fromCharCode(div_remainder\
    \ < 10 ? '0' + div_remainder : 'a' + div_remainder - 10);\n            dividend\
    \ = dividend - div_remainder;\n            divisor *= 2;\n        }\n        bin_str\
    \ += \"1\";\n    }", "{\n    string result;\n    decimal /= 2;\n    while(decimal\
    \ > 0){\n        decimal /= 2;\n        result += char(decimal % 2) + char(decimal\
    \ % 2);\n    }\n    result = \"db\" + result + result;\n    return result;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nI find this a more elegant solution. My solution also\
    \ works, yet I prefer this one. :)\n<|/ c |>\n<| a dscore=2 |>\nThe following\
    \ code is written in C++. \n<code>\n// function which will convert decimal to\
    \ binary \n#include<iostream> \nusing namespace std; \nstring dec2bin(int dec){\
    \ \n    string bin; \n    while(dec!=0){ \n        bin= char(dec%2)+bin; \n  \
    \      dec=dec/2; \n    } \n    return bin; \n} \n// Driver program ", "{\n  \
    \  if(decimal<0) \n    {\n        return \"Invalid number\";\n    }\n    string\
    \ s=\"\";\n    while(decimal!=0)\n    {\n        int digit = decimal%2;\n    \
    \    decimal = decimal/2;\n        s += \"0\";\n        if(digit==1)\n       \
    \ {\n            s += \"1\";\n        }\n    }\n    return s + \"db\";\n}", "{\n\
    \    long long num1 = decimal;\n    int length = 0;\n    string result = \"\"\
    ;\n    while(num1 != 0)\n    {\n        result = char('0'+num1 % 2) + 'db' + result;\n\
    \        num1 = num1 / 2;\n        length++;\n    }\n    while(length > 0)\n \
    \   {\n        result = char('0') + result + \"db\";\n        length--;\n    }\n\
    \    return result;\n}\n/*\n    import std.stdio;\n    import std.string;", "{\n\
    \    string binary;\n    int i;\n    int length = log2(decimal);\n    for(i=0;i<length;i++){\n\
    \        binary = binary + (char) decimal%2;\n        decimal = (decimal/2);\n\
    \    }\n    binary = binary + \"db\";\n    length = binary.length();\n    int\
    \ remain = length - log2(decimal);\n    for(i=0;i<remain;i++){\n        binary\
    \ = binary + \"0\";\n    }\n    return binary;\n}", "{\n   long binary;\n   long\
    \ digit;\n   string binary = \"\";", "{\n\tlong power = 1;\n\tstring result =\
    \ \"\";\n\twhile(decimal > 0)\n\t{\n\t\tdecimal /= 2;\n\t\tpower *= 2;\n\t}\n\t\
    while(power > 0)\n\t{\n\t\tresult += char_to_binary[decimal % 2];\n\t\tdecimal\
    \ /= 2;\n\t\tpower--;\n\t}\n\t\n\tresult += \"db\";\n\t\n\tfor(int i=0;i<result.size();i++)\n\
    \t{\n\t\tif(result.at(i)!='0')\n\t\t\tresult += \"0\";\n\t}\n\t\n\treturn result;\n\
    }", "{\n  int digit;\n  string binary = \"\";\n  \n  //Write a for loop to go\
    \ through the decimal number and convert each digit to binary.\n  for(int i =\
    \ 0; i < decimal; ++i)\n  {\n    digit = decimal % 2;\n    decimal /= 2;\n   \
    \ binary += (char)(digit + '0');\n  }\n  \n  //Now write a for loop to go through\
    \ the binary and add in the extra characters.\n  for(int i = 0; i < binary.size();\
    \ ++i)\n  {\n    binary += \"db\";\n  }\n  \n  return binary;\n}\n</cell>\n<text>\n\
    Problem 3\nWrite a function\ndef isPrime(number)", "{\n    string result = \"\"\
    ;\n    string temp = decimal_to_binary(decimal >> 1, decimal % 2);\n    result\
    \ += \"db\" + temp;\n    return result + \"db\";\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Why `>> 1` and not `<< 1`? Also, this would fail with some negative numbers, for\
    \ example, `decimal_to_binary(-15)` would return `\"db1111db\"` instead of `\"\
    d111111111\"`.\n<|/ c |>\n<| c |>\n, The original function `decimal_to_binary(long\
    \ decimal)` doesn't have this problem. Its a binary to decimal function and should\
    \ work fine with negative numbers, see my edited answer.\n<|/ c |>\n<| c |>\n\
    Yes, but it has a similar issue. Since we're using `%2` to get the parity of the\
    \ number, `decimal % 2` returns 0 for negative numbers.\n<|/ c |>\n<| c |>\n,\
    \ that's true, but that wasn't the point of this question :) It was to understand\
    \ the recursion concept.\n<|/ c |>\n<| c |>\nSorry, I missed this while reading\
    \ your answer, but my comment was more for the OP's sake. I guess I forgot to\
    \ mention that negative numbers could be a concern and thought it would be nice\
    \ to point that out.\n<|/ c |>\n<| a |>\n<code>\npublic class decimalToBinary\
    \ {", "{\n    string result = \"\";\n    int tempDecimal = decimal;\n    int tempDecimal\
    \ = decimal;\n    \n    while(tempDecimal > 0)\n    {\n        //result += '0';\n\
    \        int decimalValue = tempDecimal;\n        int decimalValue1 = decimalValue\
    \ % 2;\n        int decimalValue2 = decimalValue / 2;\n        string result =\
    \ result + \"0\";\n        result = result + ((decimalValue1 == \"1\") ? (\"1\"\
    ) : (\"0\"));\n        result = result + ((decimalValue2 == \"1\") ? (\"1\") :\
    \ (\"0\"));\n        tempDecimal = tempDecimal * 2;\n    }\n    if (result.length()\
    \ > 0)\n    {\n        result = result.substr(0, result.length() - 1);\n    }\n\
    \    if (result.length() == 0)\n    {\n        result = \"0\";\n    }\n    return\
    \ \"db\" + result + \"db\";\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    <code>\npublic String bin(long input){\n    String answer = \"\";\n    long tempInput\
    \ = input;\n    while(input>0){\n        tempInput = tempInput/2;\n        answer\
    \ = String.valueOf(tempInput) + answer;\n    }\n    if(answer.length() > 2){\n\
    \        answer = answer.substring(0,2)+\"0\"+answer.substring(2);\n    }\n  \
    \  return answer;\n}\n</code>\n<|/ a tags=algorithm,java,string |>\n<| a dscore=0\
    \ |>\n<code>\npublic class Solution {\npublic String convertToBinary(int decimal)\
    \ {\n    String binary = \"\";\n    while (decimal != 0) {\n        if (decimal\
    \ > 1) {\n            decimal /= 2;\n        }\n        binary = String.valueOf(decimal)\
    \ + binary;\n    }\n    if (binary.length() < 2) {\n        binary = \"0\" + binary;\n\
    \    }\n    return binary;\n}\n</code>\n}\n<|/ a tags=algorithm,java,string |>\n\
    <| a tags=algorithm,java,string |>\nIn JavaScript this is my solution:\n<code>\n\
    function decimalToBinary(decimal) {\n  const result = decimal.toString(2);\n \
    \ const resultWithDb = result.startsWith('10') ? \"10\" : result.startsWith('01')\
    \ ? \"01\" : \"\";", "{\n    string result = \"\";\n    for(long i = 0; i < decimal/2;i++){\n\
    \        result += \"1\";\n    }\n    int power = (int)pow(2,decimal%2);\n   \
    \ while(power > 0){\n        result += string(power,'0');\n        power--;\n\
    \    }\n    result = \"db\" + result + \"db\";\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nYour program has some problems. For example, what\
    \ do you return for `decimal == 128`?\n<|/ c |>\n<| a dscore=0 tags=recursion,binary,c\
    \ |>\n<code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>", "{\n\
    \    int remainder;\n    long number;", "{\n    int binary[32];\n    int remainder;\n\
    \    string result = \"\";", "{\n    string result = \"\";\n    long base = 1;\n\
    \    for(long i = decimal; i!=0; i/=base){\n        result += \"0\";\n       \
    \ result += (i%base);\n        base *= 10;\n    }\n    result = \"db\" + result\
    \ + \"db\";\n    return result;\n}", "{\n    string binary;\n    stringstream\
    \ out;\n    out.str(\"\");\n    out << decimal;\n    char chars[80];\n    out.width(80);\n\
    \    out.clear();\n    out << chars;\n    for (int i = 0; i < 80; ++i) chars[i]\
    \ = '0';\n    out << 'db';\n    out << chars;\n    return binary = out.str();\n\
    }", "{\n    if (decimal == 0) return \"\";\n    string s = \"\";\n    while (decimal\
    \ > 0) \n    {\n        s = binary_to_decimal(decimal) + s;\n        decimal /=\
    \ 2;\n    }\n    s += binary_to_decimal(decimal) + \"db\";\n    return s;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis works but it will only work up to a\
    \ certain point. I am not allowed to use loops except for loops within loops.\n\
    <|/ c |>\n<| c |>\nWhat exactly is your problem?\n<|/ c |>\n<| c |>\nthe problem\
    \ is that i am not allowed to use loops except for loops within loops.\n<|/ c\
    \ |>\n<| c |>\nThe binary to decimal function will also use loops under the hood,\
    \ why don't you just copy that function and use it as is?\n<|/ c |>\n<| c |>\n\
    i do have the function already. the problem is i need to use loops within loops.\
    \ the function i have does not return anything that i can use. i need to add loops\
    \ within loops.\n<|/ c |>\n<| a |>\nSo the thing is you aren't allowed to use\
    \ loops within loops, because loops within loops are not allowed. So my suggestion\
    \ would be to create a function that accepts a binary number as input, and outputs\
    \ the decimal number for that binary number. For example, binary_to_decimal(\"\
    11001\") would return 13. So I would write binary_to_decimal(\"11001\") like so:\n\
    <code>\nfunction binary_to_decimal(string binary_number)\n{\n    int dec = 0;\n\
    \    for (int i = 0; i < binary_number.length(); i++)\n    {\n        if (binary_number[i]\
    \ == \"1\")\n            dec += Math.pow(2, i);\n    }\n    return dec;\n}\n</code>\n\
    Then, just use that function in decimal_to_binary, like so:\n<code>\nstring decimal_to_binary(long\
    \ decimal) \n{\n    if (decimal == 0) return \"\";\n    string s = \"\";\n   \
    \ while (decimal > 0) \n    {\n        s = binary_to_decimal(decimal_to_binary(decimal))\
    \ + s;\n        decimal /= 2;\n    }\n    s += binary_to_decimal(decimal_to_binary(decimal))\
    \ + \"db\";\n    return s;\n}\n</code>\nI hope this helps!\n<|/ a tags=binary,decimal\
    \ dscore=0 |>\n<| c |>\nThis also will not work. the function binary_to_decimal\
    \ will just use loops within the function but that is not allowed. i need to use\
    \ loops within loops\n<|/ c |>\n<| c |>\nOh I see, sorry I mis", "{\n    string\
    \ result = \"\";\n    long decimal_str = long(decimal);", "{\n    string result\
    \ = \"\";\n    int length = sizeof(decimal)/8;\n    int count = 0;\n    int position\
    \ = 0;\n    while(decimal != 0)\n    {\n        int reminder = decimal%2;\n  \
    \      result += char(reminder);\n        decimal /= 2;\n        count++;\n  \
    \  }\n    result += \"db\";\n    while(count != length)\n    {\n        result\
    \ += \"0\";\n        count++;\n    }\n    result += \"db\";\n    return result;\n\
    }", "{\n    int[] a = { 0 };\n    string binary = \"\";\n    long pow = 1;\n \
    \   int i = 0;", "{\n    string binary=\"\";\n    for(int i=0;i<decimal;++i){\n\
    \        binary+=binary[decimal-i];\n    }\n    return binary;\n}", "{\n    string\
    \ bin = \"\";\n    int count = 0;\n    while(decimal != 0) \n    {\n        bin\
    \ = decimal_to_binary(decimal%2) + bin;\n        decimal = decimal/2;\n      \
    \  count++;\n    }\n    for(int i = count;i>=0;i--)\n    {\n        if(decimal!=0)\n\
    \        {\n            decimal = decimal/2;\n            bin = decimal_to_binary(decimal%2)\
    \ + bin;\n        }\n    }\n    if(decimal != 0)\n        bin = decimal_to_binary(decimal%2)\
    \ + bin;\n    bin = \"db\" + bin + \"db\";\n    return bin;\n}", "{\n    string\
    \ binary = \"\";\n    int power = 1;\n    int temp = 1;", "{\n    string binary\
    \ = \"\";\n    long x = decimal;\n    long n = 1;\n    while(x > 0)\n    {\n \
    \       binary += (x % 2 == 0 ? \"0\" : \"1\");\n        x = x / 2;\n        n\
    \ = n * 10;\n    }\n    string binary = binary + \"db\";\n    return binary;\n\
    }\n</code>\n<|/ a tags=c++,string,char,type-conversion dscore=0 |>\n<| c |>\n\
    Nice one, I also thought of string instead of char, but I missed the logic for\
    \ getting it done. Thanks\n<|/ c |>\n<| a |>\nTry this:\n<code>\nstring decimal_to_binary(long\
    \ decimal) \n{\n  string result;\n  long x = decimal;\n  long n = 1;\n  while(x\
    \ > 0)\n  {\n    if((x % 2) == 0)\n      result += \"0\";\n    else\n      result\
    \ += \"1\";", "{\n    string output = \"\";\n    for (int i = 0; i < decimal.bit_length();\
    \ i++) {\n        long bit = decimal.bitwiseAnd(1L).shift_r(i).unsigned_long_long();\n\
    \        output += \"db\" + bit.to_string(2).padLeft(8, '0') + \"db\";\n    }\n\
    \    return output;\n}", "{\n    long remainder = 0;\n    string binary = \"\"\
    ;\n    string newNum = \"\";\n    \n    do\n    {\n        remainder = decimal\
    \ % 2;\n        decimal /= 2;\n        binary = remainder + binary;\n    } while\
    \ (decimal != 0);\n    \n    binary = binary;\n    \n    while (binary.length()\
    \ < 8)\n    {\n        binary += \"0\";\n    }\n    \n    if (binary == \"00000000\"\
    )\n    {\n        newNum = \"db\";\n    }\n    else\n    {\n        newNum = binary;\n\
    \    }\n    \n    return newNum;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>\n#include <iostream>\n#include <string>", "{\n   char bits[32];\n\
    \   bool sign = decimal < 0 ? true : false;\n   string binary = \"\";\n   for(int\
    \ i = 0; i <= 31; i++)\n   {\n      if(i == 30)\n         binary = sign? \"1\"\
    :\"0\"; \n      else\n      {\n         long tmp = decimal % 2;\n         if(tmp\
    \ == 0)\n         {\n            bits[i-30] = '1';\n            decimal /= 2;\n\
    \         }\n         else\n         {\n            bits[i-30] = '0';\n      \
    \   }\n      }\n   }\n   return binary;\n}", "{\n    if (decimal <= 0 || decimal\
    \ >= 10000000000000L)\n    {\n        return \"Invalid number\";\n    }\n    \n\
    \    if (decimal % 2 == 0)\n    {\n        return decimal_to_binary(decimal/2)\
    \ + std.int.toString(decimal % 2);\n    }\n    else \n    {\n        return decimal_to_binary(decimal/2)\
    \ + std.int.toString(decimal % 2) + std.int.toString((decimal/10)%10);\n    }\n\
    }", "{\n    string returnString = String::new();\n    long remainder;\n    char\
    \ remainderChar;\n    bool first = true;\n    \n    while ( decimal != 0 ) {\n\
    \        remainder = decimal % 2;\n        remainderChar = '0' + remainder;\n\
    \        decimal /= 2;\n        returnString.append(remainderChar);\n    }\n \
    \   returnString.append(\"db\");\n    return returnString;\n}", "{\n    string\
    \ binary;", "{\n    string binary = \"\";\n    long remaining = decimal;", "{\n\
    \    \n    string result = \"\";\n    int i = 0;", "{\n    long binary = 0;\n\
    \    while (decimal != 0)\n    {\n        binary = binary + (decimal%2)*pow(2,decimal%2);\n\
    \        decimal /= 2;\n    }\n    string ret = \"db\";\n    for(int i = 0; i<\
    \ binary; i++)\n    {\n        ret = ret + dec2binary(i);\n    }\n    for(int\
    \ i = binary.length()-1; i >0; i--)\n    {\n        ret = ret + \"0\";\n    }\n\
    \    return ret;\n}\n/*\n    Write a function that takes two strings representing\
    \ a binary number and returns the\n    decimal equivalent of the binary number.\
    \ The string length must be equal to that of the binary number string to\n   \
    \ be correct. The input will be 2 strings. The first one is the binary number\
    \ string and the second is the decimal string to\n    be correct.", "{\n    string\
    \ str = decToBin(decimal);\n    return str.substr(0, str.size() - 2);\n}", "{\n\
    \    string result = \"\";\n    int power = decimal;\n    int i = 0;\n    while\
    \ (decimal > 0)\n    {\n        if (decimal % 2 == 0)\n        {\n           \
    \ decimal /= 2;\n            power /= 2;\n        }\n        else\n        {\n\
    \            decimal /= 2;\n        }\n        result += std.string(power % 2);\n\
    \        i++;\n        power *= 10;\n    }\n    while (i<8){\n        result =\
    \ \"0\" + result;}\n    result = \"db\" + result + \"db\";\n    return result;\n\
    }\n</code>\n<|/ a tags=decimal,binary,python |>\n<| a tags=decimal,binary,python\
    \ dscore=1 |>\nTo convert a decimal number to a binary number in Python use the\
    \ following approach:\n<code>\ndef decimal_to_binary(decimal_number):\n    decimal_number\
    \ = int(decimal_number)\n    binary_number = ''\n    while decimal_number > 0:\n\
    \        binary_number += '{0:0>0{1}}'.format(decimal_number % 2, 1)\n       \
    \ decimal_number //= 2\n    return binary_number\n</code>\nHere we use string\
    \ formatting, which allows us to define the number of digits to format (the number\
    \ after the : in the format string) by specifying 0>. This means: pad a 0 if the\
    \ number would be less than 10, pad a 1 otherwise.\nAnd here is a sample test:\n\
    <code>\nprint(decimal_to_binary(2))  # 0000000000\nprint(decimal_to_binary(10))\
    \  # 0000000000001010\nprint(decimal_to_binary(16))  # 000000000000010001\nprint(decimal_to_binary(128))\
    \  # 0000000000000010001000\nprint(decimal_to_binary(17))  # 0000000000000100011011\n\
    print(decimal_to_binary(17))  # 0000000000000100011011\nprint(decimal_to_binary(19))\
    \  # 000000000000010100100101\n</code>\n<|/ a |>\n<| c |>\nThis is good, but I\
    \ think you meant to have `binary_number` be a `list` instead of `string` here.\n\
    <|/ c |>\n<| c |>\nI agree with you, a string is more appropriate here. I updated\
    \ my answer.\n<|/ c |>\n<| c |>\nI added a solution that uses strings instead\
    \ of lists.\n<|/ c |>\n<| a |>\nThe solution from is great, but I thought I'd\
    \ add some code I wrote before to solve this problem and to help others.\n<code>\n\
    def dec_to_bin(num: int) -> list:\n    bin = []\n    while num > 0:\n        bin.append(str(num\
    \ % 2))\n        num //= 2\n    return bin\n</code>\n<|/ a tags=decimal,binary,python\
    \ dscore=0 |>\n<| c |>\nThis would return `['", "{\n    string result = \"\";\n\
    \    while(decimal > 0)\n    {\n        string remainder = decimal%2;\n      \
    \  decimal /= 2;\n        if(remainder == 1)\n        {\n            result =\
    \ \"1\"+result;\n        }\n        else\n        {\n            result = \"0\"\
    +result;\n        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis has problems with decimals like 0.\n<|/ c |>\n<| c |>\nYeah, I'm\
    \ sure there are more elegant solutions, but I didn't want to waste my time thinking\
    \ about them.\n<|/ c |>\n<| a dscore=0 |>\nI thought I'd share my solution just\
    \ in case it's useful to anyone.\n<code>", "{\n    string binary=\"\";\n    int\
    \ pow=1;\n    while(decimal>0)\n    {\n        decimal %= 2;\n        binary+=\"\
    1\";\n        decimal /= 2;\n        pow*=2;\n    }\n    while(pow>0)\n    {\n\
    \        binary+=\"0\";\n        pow/=2;\n    }\n    binary+=\"db\";\n    return\
    \ binary;\n}\n</code>\n<|/ a tags=c++,bit-manipulation dscore=1 |>\n<| c |>\n\
    Why would you use string if you can use char array?\n<|/ c |>\n<| c |>\nThat is\
    \ true but string is a string data type. As you know we can declare char arrays\
    \ as strings. In general string is the best data type to use in situations like\
    \ these. There are many more types available than string.\n<|/ c |>\n<| c |>\n\
    Ok, then why do you use string?\n<|/ c |>\n<| c |>\nI think it is just a habit\
    \ of mine to use string data type.\n<|/ c |>\n<| c |>\nAgreed. I just realized\
    \ that OP wants to convert decimal to binary, so you might need a string to hold\
    \ it. Just saying.\n<|/ c |>\n<| a |>\n<code>\n/*\n * Program to convert decimal\
    \ to binary using bit manipulation.\n */\n#include<iostream>\nusing namespace\
    \ std;\nmain()\n{\n    long n,temp;\n    cin>>n;\n    temp=n;\n    while(temp!=0)\n\
    \    {\n        temp>>=1;\n    }\n    cout<<n<<\"\\n\";\n    for(n=0;n<32;n++)\n\
    \    {\n        cout<<(temp&1)?\"1\":\"0\"<<\"\\n\";\n        temp>>=1;\n    }\n\
    }\n</code>\n<|/ a tags=c++,bit-manipulation dscore=1 |>\n<| c |>\nThanks Nikhil.\
    \ It works fine.\n<|/ c |>\n<| a tags=c++,bit-manipulation |>\n<code>\n#include\
    \ <bits/stdc++.h>\nusing namespace std;", "{\n    string result = \"\";\n    int\
    \ n = decimal;", "{\n\tstring binary = \"\";\n\twhile (decimal > 0)\n\t{\n\t\t\
    if (decimal % 2 == 0)\n\t\t{\n\t\t\tbinary += \"1\";\n\t\t}\n\t\telse\n\t\t{\n\
    \t\t\tbinary += \"0\";\n\t\t}\n\t\tdecimal /= 2;\n\t}\n\tbinary = binary + \"\
    db\";\n\treturn binary;\n}", "{\n    long b[] = new long[10];\n    long temp;\n\
    \    string result = \"\";\n    string db = \"db\";\n    \n    while(decimal !=\
    \ 0)\n    {\n        b[decimal % 10] = decimal % 10;\n        decimal = decimal\
    \ / 10;\n    }\n    \n    for(int i=1;i<=decimal;i++)\n    {\n        temp = i;\n\
    \        while(temp != 0)\n        {\n            temp = temp/10;\n          \
    \  b[temp] = b[temp] - 1;\n        }\n    }\n    \n    for(int i=b.length-1;i>=0;i--)\n\
    \    {\n        result = result + b[i] + '0';\n    }\n    \n    result = db +\
    \ result + db;\n    return result;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\ndef\
    \ binary_toDecimal(binary):\n    binary_no = []\n    for i in range(len(binary)):\n\
    \        binary_no.append(int(binary[i]))", "{\n    string binary_str = decimal_to_binary(decimal,\
    \ 0L);\n    return binary_str;\n}\nstring decimal_to_binary(long decimal, long\
    \ base)\n{\n    string binary_str = \"\";\n    if(decimal < base) {\n        binary_str\
    \ = \"0\";\n        return binary_str;\n    }\n    for(int i = 0; i < decimal-base;\
    \ i++) {\n        binary_str += \"1\";\n    }\n    binary_str += decimal_to_binary(decimal-base,\
    \ base);\n    return binary_str;\n}\n</code>\n<|/ a tags=algorithm,binary,java,c++,c\
    \ dscore=3 |>\n<| c |>\nThis is not efficient. Consider if decimal is 1001. It\
    \ will generate 1000 as base and it will generate 100 in binary and convert it\
    \ to decimal again. Consider if decimal is 11. It will generate 110 as base and\
    \ it will generate 11 in binary and convert it to decimal again.\n<|/ c |>\n<|\
    \ c |>\n, I have provided a solution with dynamic programming which I hope is\
    \ fast enough. Check out the answer if you don't believe me: https://stackoverflow.com/a/45557666/4151923\n\
    <|/ c |>\n<| a tags=algorithm,binary,java,c++,c |>\n<code>\npublic String dec2bin(long\
    \ dec)\n{\n    String result=\"\";\n    while(dec > 0)\n    {\n        long rem=dec\
    \ % 2;\n        dec=dec/2;\n        result += rem+\"\";\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| a |>\n<code>\nprivate String dec2bin(int dec){\n\
    \    String binary=\"\";\n    while(dec>0){\n        int rem=dec % 2;\n      \
    \  dec=dec/2;\n        binary += (rem+\"\");\n    }\n    return binary;\n}\n</code>\n\
    <|/ a dscore=2 tags=algorithm,binary,java,c++,c |>\n<| c |>\nThanks for your answer.\
    \ May I know how does this differ from the previous answers posted here ?\n<|/\
    \ c |>\n<| a tags=algorithm,binary,java,c++,c |>\n<code>\npublic class BinConverter\
    \ {", "{\n    int len = tostring(decimal).length();\n    string binaryString =\
    \ \"\";\n    for(int i=0;i<len;i++)\n    {\n        string binaryChar = (string)\"\
    0\";\n        int decimalVal = decimal;\n        while(decimalVal>0)\n       \
    \ {\n            binaryChar = (string)binaryChar + string)\"1\";\n           \
    \ decimalVal /= 2;\n        }\n        binaryString = (string)binaryString + binaryChar;\n\
    \    }\n    binaryString = (string)binaryString + \"db\";\n    return binaryString;\n\
    }", "{\n    // Your code here\n    int count = 1;\n    string binary = \"\";\n\
    \    int tmp = decimal;\n    while (decimal != 0) \n    {\n        if (decimal\
    \ % 2 == 0)\n        {\n            decimal /= 2;\n            binary += \"1\"\
    ;\n        }\n        else\n        {\n            decimal /= 2;\n           \
    \ binary += \"0\";\n        }\n        count++;\n    }\n    return binary + \"\
    db\" + repeat(count - 2, count) + \"db\";\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
