name: HumanEval_31_is_prime
language: d
prompt: "import std.math;\n/*\nReturn true if a given number is prime, and false otherwise.\n\
  \    >>> is_prime(6L)\n    false\n    >>> is_prime(101L)\n    true\n    >>> is_prime(11L)\n\
  \    true\n    >>> is_prime(13441L)\n    true\n    >>> is_prime(61L)\n    true\n\
  \    >>> is_prime(4L)\n    false\n    >>> is_prime(1L)\n    false\n    \n*/\nbool\
  \ is_prime(long n) \n"
tests: "unittest\n{\n    alias candidate = is_prime;\n\n    assert(candidate(6L) ==\
  \ false);\n    assert(candidate(101L) == true);\n    assert(candidate(11L) == true);\n\
  \    assert(candidate(13441L) == true);\n    assert(candidate(61L) == true);\n \
  \   assert(candidate(4L) == false);\n    assert(candidate(1L) == false);\n    assert(candidate(5L)\
  \ == true);\n    assert(candidate(11L) == true);\n    assert(candidate(17L) == true);\n\
  \    assert(candidate(85L) == false);\n    assert(candidate(77L) == false);\n  \
  \  assert(candidate(255379L) == false);\n}\nvoid main(){}"
completions: ["{\n    if(n == 2)\n        return true;\n    \n    if (n % 2 == 0)\
    \ return false;\n    \n    long max_factor = (1L<<(n/2));\n    long i = 3;\n \
    \   \n    while (i * i <= n) {\n        if (n % i == 0) return false;\n      \
    \  i += max_factor;\n    }\n    return true;\n}\n/*\nReturn true if n is a perfect\
    \ power of 2.\n    >>> is_power_of_2(6L)\n    true\n    >>> is_power_of_2(3L)\n\
    \    true\n    >>> is_power_of_2(8L)\n    true\n    >>> is_power_of_2(15L)\n \
    \   false\n    >>> is_power_of_2(4L)\n    false\n    \n*/", "{\n\tlong i, d;\n\
    \td = n;\n\td = std.math.mod(d, 2);\n\tfor (; d == 1; d = std.math.mod(d, 2))\n\
    \t{}\n\tfor (i = 3; i * i <= d; i += 2)\n\t{\n\t\tif (std.math.mod(i, d) != 0)\n\
    \t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "{\n    if (n == 1L)\
    \ return true;\n    if (n <= 1L) return false;\n    \n    long max_factor = 2L;\n\
    \    while (max_factor < n) \n    {\n        if (n % max_factor == 0L) \n    \
    \    {\n            return false;\n        }\n        \n        ++max_factor;\n\
    \    }\n    \n    return true;\n}", "{\n    long i;\n    for(i = 2; i*i <= n;\
    \ i++)\n        if (n%i==0) return false;\n    return true;\n}\n</code>\n<|/ a\
    \ dscore=1 tags=optimization,algorithm,math,primes,time-complexity |>\n<| c |>\n\
    `int primes[numPrimes];` doesn't work at all, since `numPrimes` is not a compile-time\
    \ constant, it has to be a run-time variable (which can not be assigned like that)\n\
    <|/ c |>\n<| a tags=optimization,algorithm,math,primes,time-complexity dscore=1\
    \ |>\nHere's a solution that should run in O(N) time\n<code>", "{\n    if(n <\
    \ 2L) return false; \n    if(n < 3L) return true;\n    for(i = 3L; i <= sqrtn;\
    \ i += 2L) {\n        if(n%iL) return false; \n    }\n    return true;\n}", "{\n\
    \tint i;\n\t// make sure n is a prime\n\tfor(i=2; i*i<=n; ++i)\n\t{\n\t\tif(n%i==0)\n\
    \t\t\treturn false;\n\t}\n\treturn true;\n}\n'''\ndef func_stirling_part(stirling_part_fun):\n\
    \t# Part 2\n\treturn '''\n#import std.stdio;\n#import std.string;", "{\n    long\
    \ a = 6L;\n    long b = 1L;\n    long c = (1L<<((n-1)/3L)); ", "{\n    auto result\
    \ = true;\n    if (n<2L)\n        return result;\n    auto sq = std.math.sqr(n);\n\
    \    for (long i=2L;i<sq;i++)\n    {\n        if (std.math.rem(i,n) == 0)\n  \
    \          result = false;\n    }\n    return result;\n}", "{\n    long i, a =\
    \ 2, b = 0, d;\n    d = n - 1;\n    \n    do { \n        if (is_divisible(d, a))\
    \ return false;\n        d = (d*(b-a)) % n;\n    } while (d!=1);\n    \n    return\
    \ true;\n}", "{\n\tlong i;\n\tint flag = 0;", "{\n  int i;\n  if (n <= 1) \n \
    \ {\n    return false;\n  }", "{\n  // n is a natural number\n  if (n<2) return\
    \ false;\n  // if n is even, return false\n  if (n&1) return false;\n  // if n\
    \ is odd, return true\n  long m = n/2;\n  long r = ((m*m)%n); \n  if (r==n) return\
    \ false;\n  return true;\n}\n</code>\n<|/ a |>\n<| c |>\nYes, this is correct,\
    \ except for the fact that it uses long instead of int. I think an int variable\
    \ would be a better choice, but you can change it back if you like.\n<|/ c |>\n\
    <| c |>\nI changed it back.\n<|/ c |>\n<| a tags=c++,primes |>\n<code>\n#include\
    \ <iostream>\n#include <algorithm>\n#include <cstdio>", "{\n  long i, d, s;\n\
    \  int j;\n  if (n == 0)\n    return false;\n  s = sieve.head;\n  for (i = sieve.start;\
    \ i < sieve.end; i++) {\n    long e = s + i;\n    d =  n % e;\n    if (d > 0)\n\
    \      return false;\n    s = (s + i) / e;\n  }\n  return ((s == 0) || (n == 1));\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nIf this code is correct and answers your\
    \ question, please accept the answer (click on the checkmark). For future reference,\
    \ please read [How does accepting an answer work?](http://meta.stackexchange.com/questions/5234/how-does-accepting-an-answer-work)\n\
    <|/ c |>\n<| a |>\n<code>\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\
    #include<string.h>\n#include<stdbool.h>", "{\n\tbool flag = std.math.isPrime(n);\n\
    \tif(flag==false)\n\t{\n\t\tstd.cout.warning(\"is_prime: \"+to_string(n)+\" is\
    \ not a prime number\");\n\t}\n\treturn flag;\n}", "{\n    if(n<2L)\n        return\
    \ false;\n    for(long  i=3L;i>=2;i+=2)\n        if(n%i==0)\n            return\
    \ false;\n    return true;\n}\n///////////////////////////////////////////////////////////////////////////////\n\
    // Sqrt function definition\n///////////////////////////////////////////////////////////////////////////////\n\
    double Sqrt(double n) \n{\n    double result;\n    long imax;\n    imax = 1L;\n\
    \    while(imax<=(long)n)\n    {\n        result = (double)(imax*(imax+1))/2.0;\n\
    \        if(result==(double)n)\n            break;\n        else if(result>(double)n)\n\
    \            ++imax;\n        else\n            imax -= imax;\n    }\n    return\
    \ imax;\n}\n///////////////////////////////////////////////////////////////////////////////\n\
    // Sin function definition\n///////////////////////////////////////////////////////////////////////////////\n\
    double Sin(double n) \n{\n    return sin(n);\n}\n///////////////////////////////////////////////////////////////////////////////\n\
    // Cos function definition\n///////////////////////////////////////////////////////////////////////////////\n\
    double Cos(double n) \n{\n    return cos(n);\n}\n///////////////////////////////////////////////////////////////////////////////\n\
    // Arcsin function definition\n///////////////////////////////////////////////////////////////////////////////\n\
    double Arcsin(double n) \n{\n    return asin(1.0);\n}\n///////////////////////////////////////////////////////////////////////////////\n\
    // Arccos function definition\n///////////////////////////////////////////////////////////////////////////////\n\
    double Arccos(double n) \n{\n    return acos(1.0);\n}\n///////////////////////////////////////////////////////////////////////////////\n\
    // Arctan function definition\n///////////////////////////////////////////////////////////////////////////////\n\
    double Arctan(double n) \n{\n    return atan(1.0/n);\n}\n///////////////////////////////////////////////////////////////////////////////\n\
    // Decimal to Hexadecimal Conversion\n///////////////////////////////////////////////////////////////////////////////\n\
    string DecToHex(double n) \n{\n    int idigits,dig;\n    string hexstr;", "{ \n\
    \    int i;\n    if (n < 2L) \n        return false; \n    if (n < 4L)\n     \
    \   return ((1L == n) || (0 == n % 2)); \n    for (i = 3L; i * i <= n; i += 2L)\
    \ \n        if ((n % i) == 0) \n            return false; \n    return true; \n\
    } ", "{\n    long i=2;\n    while(i*i<=n)\n    {\n        if(n%i==0)\n       \
    \     return false;\n        ++i;\n    }\n    return true;\n}", "{\n    int i;\n\
    \    for(i=2; i <= Math.sqrt(n); ++i) \n        if(n%i == 0) return false;\n \
    \   return true;\n}\n</code>\nYou can see that the is_prime function above only\
    \ tests for factors up to n / 2.  We can implement the Sieve of Eratosthenes algorithm\
    \ using the same function above:\n<code>\nlong sieve_of_eratosthenes(long n) \n\
    {\n    long[] primes = new long[n+2];\n    primes[0] = 1;\n    for(int i = 1;\
    \ i <= n; ++i) \n    {\n        if(primes[i] == 1) \n        {\n            primes[i*i]\
    \ = 1L;\n            int j;\n            for(j=i*i; j <= n; j+=i) \n         \
    \       primes[j] = 0L;\n        }\n    }\n    return primes[n];\n}\n</code>\n\
    We now have a function that will tell us whether a given number is prime.  We\
    \ now need to make a function that will tell us how many prime factors there are.\
    \  We can implement this using Sieve of Atkowski or Sieve of Eratosthenes:\n<code>",
  "{\n    long i;\n    bool prime = true;\n    if (n == 1L)\n    {\n        prime\
    \ = false;\n        return prime;\n    }\n    for (i=2L; i*i<=n; ++i)\n    {\n\
    \        if (n % i == 0L)\n        {\n            prime = false;\n        }\n\
    \    }\n    return prime;\n}", "{\n    // check for small numbers\n    if (n <\
    \ 2L)\n    {\n        return false;\n    }\n    // check for even numbers\n  \
    \  if ((n & 1L) == 0L)\n    {\n        return n == 2L;\n    }\n    bool isprime\
    \ = true;\n    long i = 2L;\n    long limit = n + 1L;\n    while (i<limit)\n \
    \   {\n        // if i is evenly divisible by i, then i is prime\n        if ((i\
    \ & i) == 0L)\n        {\n            limit = n;\n        }\n        bool even\
    \ = true;\n        long j = 2L;\n        long limit = n + 1L;\n        while (j<limit)\n\
    \        {\n            if ((j & j) == 0L)\n            {\n                even\
    \ = true;\n            }\n            else\n            {\n                even\
    \ = false;\n            }\n            // if j divides i, then i is not prime\n\
    \            if ((i & j) == 0L)\n            {\n                limit = (long)j;\n\
    \            }\n            if (even)\n            {\n                // check\
    \ if j divides n\n                if ((j & n) == 0L)\n                {\n    \
    \                isprime = false;\n                }\n            }\n        \
    \    else\n            {\n                // check if j divides n\n          \
    \      if ((j & n) == 0L)\n                {\n                    limit = n;\n\
    \                }\n            }\n            j = j + 1L;\n        }\n      \
    \  i = i + 1L;\n    }\n    return isprime;\n}\n// int main()", "{\n    long m\
    \ = n_factors(n);\n    return m == 0 || n != m || (n % m) != 0;\n}", "{\n    /*\
    \ check for small numbers */\n    if (n < 2) return false;\n    if (n == 2) return\
    \ true;\n    \n    /* check for even numbers */\n    if (n % 2 == 0) return false;\n\
    \    \n    long t = 6L;\n    long f = 5L;\n    \n    while (f <= n / 2) {\n  \
    \      if (n % f == 0) return false;\n        t += 6;\n        f += 6L;\n    }\n\
    \    return true;\n}", "{\n    if(n<2) return false;\n    long m=sqrt(n);\n  \
    \  for(long i=3; i*i <= n; i++)\n    {\n        if(n % i == 0)\n            return\
    \ false;\n    }\n    return true;\n}\n</code>\n<|/ a |>\n<| c |>\nI'm sorry, but\
    \ I don't understand the logic of what you wrote. Can you explain in more details?\n\
    <|/ c |>\n<| c |>\nI used a similar approach but I was using trial division instead\
    \ of Sieve of Eratosthenes for efficiency, and it was too slow for me. On top\
    \ of that, the trial division used `float` types to do the sieve, so the code\
    \ I wrote was essentially broken.\n<|/ c |>\n<| c |>\nI have changed the code\
    \ to make use of Sieve of Eratosthenes\n<|/ c |>\n<| a dscore=3 |>\nI personally\
    \ would not use a Sieve of Eratosthenes. I would use a list of prime numbers and\
    \ test whether they are in range.\n<code>\npublic static bool[] IsPrime(int start,\
    \ int end) {\n    var primes = new List<int>();\n    var j = 2;\n    for (int\
    \ i = start; i <= end; i++) {\n        if (primes.Contains(i)) {\n           \
    \ continue;\n        }", "{ \n\tif (n==0)\n\t\treturn true;\n\tif (n<3L)\n\t\t\
    return false;\n\tif (std.math.is_prime(n))\n\t\treturn true;\n\t\n\tlong max =\
    \ (long)std.math.next_up(n);\n\tlong counter = 3;\n\tfor (;;)\n\t{\n\t\tlong nc\
    \ = std.math.next_down(counter, max);\n\t\tif (nc == 1)\n\t\t\treturn false;\n\
    \t\t\n\t\tif (std.math._mod(n,counter) == 0)\n\t\t\treturn false;\n\t\t\n\t\t\
    counter = nc;\n\t\tmax = counter;\n\t}\n}", "{\n    return n % 2 == 0L || (std.math.isPrime(n)\
    \ and n % 2 != 0);\n}\n/*\nReturn true if a given number is even, and false otherwise.\n\
    \    >>> is_even(6L)\n    false\n    >>> is_even(13441L)\n    false\n    >>> is_even(0L)\n\
    \    false\n    >>> is_even(2L)\n    true\n    >>> is_even(25L)\n    true\n  \
    \  \n*/", "{\n    // make sure n is positive\n    if (n <= 1)\n        return\
    \ false;", "{\n    return std.math.isPrime(n);\n}\n\"\"\")", "{\n    if (n <=\
    \ 1L) return false; \n    long i = 2;\n    while (i <= n) { \n        if (n %\
    \ i == 0) return false; \n        i = i + 2L;\n    } \n    return true; \n}\n\
    </code>\n<|/ a tags=math,primes,algorithm,c++ |>\n<| c |>\nThe question asks for\
    \ C++, and this isn't Java.\n<|/ c |>\n<| c |>\n, It was tagged c++ in the beginning,\
    \ but I fixed the tags to show OP was using c++ and tagged c++ in his question.\
    \ Yes, this code is Java.\n<|/ c |>\n<| c |>\nThe problem is with the `return\
    \ is_prime` statement. Because `is_prime` is a function, it is treated as a variable\
    \ of type `bool`. This doesn't work because `bool` has a type of different size\
    \ from `int`. A proper solution would have been to declare `is_prime` as a variable\
    \ of type `bool`. [This answer](http://stackoverflow.com/a/2987397/2513200) explains\
    \ why.\n<|/ c |>\n<| c |>\n, thank you for pointing out. I updated the answer\
    \ to fix the problem.\n<|/ c |>\n<| c |>\n\"[...] because `bool` has a type of\
    \ different size from `int`\" - I don't think this statement is true. From the\
    \ C++ Standard: *\"For any object (other than a base-class subobject) of POD type\
    \ T, whether or not the object has been allocated storage space or is otherwise\
    \ occupied is implementation-defined.\"* ([ref](http://stackoverflow.com/q/225968/2513200))\n\
    <|/ c |>\n<| a tags=math,primes,algorithm,c++ dscore=5 |>\nThe simplest way is\
    \ to use the Sieve of Eratosthenes, which you already have in your example. The\
    \ key here is to stop at the square root of n rather than the square root of the\
    \ number's prime factors:\n<code>", "{ \n\tunsigned long i,j;\n\tfor(i = 2; i\
    \ < n/2; ++i)\n\t{\n\t\tif((n % i) == 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\
    }\n\treturn true;\n}\n\t\n/*\nWrite out a PLIST file containing a single element\
    \ of type long containing the\nvalue n.", "{\n    for(long i = 1L; i< n; i++)\n\
    \    {\n        if(n%i == 0)\n        {\n            return false;\n        }\n\
    \    }\n    return true;\n}", "{\n    /* Check for divisors other than 2 and 3\
    \ */\n    for (long i = 3; i*i <= n; i += 2)\n        if (n % i == 0)\n      \
    \      return false;", "{\n    int i;\n    long p, q;", "{\n    long i, div;\n\
    \    if(n == 1)\n        return true;\n    if(n == 2)\n        return false;\n\
    \    if(n & 1)\n        return false;\n    if(n <= 0)\n        return false;\n\
    \    div = 1;\n    for(i=3; i<= (long)sqrt(n); ++i)\n    {\n        if(n%i ==\
    \ 0)\n            return false;\n        div++;\n    }\n    return true;\n}",
  "{\n    long i;\n    if(n==1) return false;\n    if(std.is_even(n)) return false;\n\
    \    if(std.is_prime(n)) return true;", "{\n    int i;\n    if (n==0)\n      \
    \  return true;\n    if (n==1)\n        return false;\n    for(i=2;i<n/2;++i)\n\
    \        if (n%i == 0)\n            return false;\n    return true;\n}\n/* \n\
    \    std.math.rem_divisible(n)\n    \nReturn an integer `x` such that `n % x ==\
    \ 0`.\n    The function `is_prime(n / x)` will be `true` only if `x / x` is prime\n\
    \    and `false` otherwise.\n    \n    >>> rem_divisible(9L, 7L)\n    3L\n   \
    \ >>> rem_divisible(7L, 3L)\n    0L\n    \n*/\nlong rem_divisible(long x, long\
    \ y) \n{\n    long y;\n    if (x==0) {\n        y = (y==0)?1:y;\n        return\
    \ y;\n    }\n    while (y != 0) {\n        if (x%y==0)\n            return x;\n\
    \        y--;\n    }\n    return 0;\n}\n/*\n    std.math.gcd(a)(b)\n    \nReturn\
    \ greatest common divisor of a and b.\n    \n    >>> gcd(3, 2)\n    1\n    >>>\
    \ gcd(3, 3)\n    1\n    >>> gcd(2, 2)\n    1\n    \n*/\nlong gcd(long a, long\
    \ b) {\n    if (a < 0) {\n        long t;\n        t=a-b;\n        while (t%b!=0)\n\
    \            t=t-b;\n        a=t;\n    }\n    if (b < 0) {\n        long t;\n\
    \        t=a-b;\n        while (t%b!=0)\n            t=t-b;\n        b=t;\n  \
    \  }\n    return (b==0)?a:gcd(b,a%b);\n}\n/*\n    std.math.ceil(n)\n    \nReturn\
    \ the smallest integer `n` such that `n % i == 0` and for all\npositive integer\
    \ `n`, `n - n == i`.", "{\n\tint i;\n\tfor (i=2; i<=n/2; i++) {\n\t\tif (std.math.isPowerOfTwo(n)\
    \ && (n%i)==0) return false;\n\t}\n\t\n\treturn true;\n}", "{\n  \n  long d;\n\
    \  bool prime = true;\n  \n  if(n <= 2L) \n  {\n    return true; \n  }\n  \n \
    \ d = (long)sqrt(n);\n  for(int i = 3L; i <= d; ++i)\n  {\n    if(n % i == 0L)\
    \ \n    {\n      prime = false; \n      break;\n    }\n  }\n  \n  return prime;\n\
    }\n#endif", "{ \n    if (n == 1L) {\n        return true;\n    } else if (n %\
    \ 2L == 1L) {\n        return false;\n    } else {\n        long limit = sqrt(n);\
    \ \n        if (limit > 3L) \n            limit = sqrt(3L); \n        for (long\
    \ i = 2L; i <= limit; i++) {\n            if (n % iL == 1L) {\n              \
    \  return false;\n            }\n        }\n        return true;\n    }\n}\n</code>\n\
    <|/ a |>\n<| a tags=c++,primes,sieve-of-eratosthenes |>\nI thought I'd post an\
    \ updated version of this program based on the comments posted above. It now returns\
    \ all prime numbers below 2 million, and prints the numbers as they are found\
    \ (using STL's vector). Also a quick tip for printing prime numbers below 2 million:\
    \ use an if statement to check whether i is divisible by any of the numbers between\
    \ 2 and sqrt(i), then print the number. Example:\n<code>\nfor (int i = 3; i <=\
    \ sqrt(number); i++) {\n    if (number % i == 0) {\n         cout << number <<\
    \ \" is a prime number.\" << endl;\n    }\n}\n</code>\nHere is a quick sample\
    \ of its output:\n<code>\n> ./prime\n2 is a prime number.\n3 is a prime number.\n\
    5 is a prime number.\n7 is a prime number.\n11 is a prime number.\n13 is a prime\
    \ number.\n17 is a prime number.\n19 is a prime number.\n23 is a prime number.\n\
    29 is a prime number.\n31 is a prime number.\n37 is a prime number.\n41 is a prime\
    \ number.\n43 is a prime number.\n47 is a prime number.\n53 is a prime number.\n\
    59 is a prime number.\n67 is a prime number.\n71 is a prime number.\n73 is a prime\
    \ number.\n79 is a prime number.\n83 is a prime number.\n89 is a prime number.\n\
    97 is a prime number.\n</code>\nAnd the source code:\n<code>\n#include <cmath>\n\
    #include <vector>\n#include <iostream>", "{\n\tint i;\n\tif(n<2) return false;\n\
    \tif(n<9) return true;\n\tfor(i=2; i<(int)sqrt(n); ++i){\n\t\tif(!(n % i)) return\
    \ false;\n\t}\n\treturn true;\n}", "{\n  int is_composite[std.math.prime_limit()];\n\
    \  std.math.is_prime(is_composite, n, std.math.prime_limit(), true/*test odd*/);\n\
    \  return std.array.is_true(std.array.end(is_composite));\n}", "{\n    long i=3,\
    \ m=2L;", "{\n    if(n==1) return false;\n    for(long i=2;i<n;i++) \n    {\n\
    \        if(n%i==0) return false;\n    }\n    return true;\n}", "{\n    long max\
    \ = maxint;\n    if(n < 1)\n        return false;\n    if(n==1)\n        return\
    \ true;\n    if(n==2)\n        return false;\n    if(n%2==0)\n        return false;\n\
    \    for(long i=3;i*i<=n;i+=2) \n    {\n        if(n%i==0)\n            return\
    \ false;\n        if(n%i==1)\n            return true;\n    }\n    return true;\n\
    }", "{\n    long i;\n    if (n < 2L) return false; // n is even, so n must be\
    \ prime\n    if (n == 2L) return true;\n    \n    // check only odd numbers smaller\
    \ than n\n    for (i = 2L; i < n; i+=2L) {\n        if (n % i == 0L) return false;\
    \ // not a prime\n    }\n    \n    return true;\n}", "{ \n    long i = 2L; \n\
    \    bool is_prime = true;\n    while (i * i <= n) \n    { \n        if (n % i\
    \ == 0L) \n        { \n            is_prime = false; \n            break; \n \
    \       } \n        i = i + 1L; \n    } \n    return is_prime; \n} ", "{\n\tif\
    \ (n==1)return true;\n\tif (n==2)return true;\n\tif (n<2 || n%2==0)return false;\n\
    \tfor (int i=3; i<=((int)sqrt(n)-1); i+=2)\n\t{\n\t\tif (n%i==0)\n\t\t{\n\t\t\t\
    return false;\n\t\t}\n\t}\n\treturn true;\n}\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nYou have a typo, it is 'if (n==2)return true;' not 'if (n==2)return true;'.\
    \ And you should remove 'return' statement from inside the loop.\n<|/ c |>\n<|\
    \ c |>\nI edited my question with your corrections. Thanks for pointing it out\n\
    <|/ c |>\n<| a dscore=1 |>\nAs others have pointed out, the best algorithm to\
    \ solve this problem is to write a function that checks one trillion numbers.\
    \  One way to do this efficiently is to precompute a table of primes.\n<code>\n\
    const int[32] primes = {\n    2,    3,    5,    7,    11,   13,   17,   19,  \
    \ 23,   29,   31,\n    37,   41,   43,   47,   53,   59,   61,   67,   71,   73,\
    \   79,\n    83,   89,   97,  101,  103,  107,  109,  113,  127,  131,  137,\n\
    \    139,   149,  151,  157,  163,  167,  173,  179,  181,  191,\n    193,  197,\
    \  199,  211,  223,  227,  229,  233,  239,  241,  251,\n    257,  263,  269,\
    \  271,  277,  281,  283,  293,  307,  311,  313,\n    317,  331,  337,  347,\
    \  349,\n};", "{\n\tbool prime;\n\tprime = isPrime(n);\n\tif (prime)\n\t\treturn\
    \ true;\n\telse\n\t\treturn false;\n}\n\t", "{\n    long i;\n    if (n <= 1L)\n\
    \t{\n\t    return false;\n\t}\n    for (i = 2L; i <= sqrt(n); i++)\n\t{\n\t  \
    \  if (n % i == 0)\n\t\t{\n\t\t    return false;\n\t\t}\n\t}\n    return true;\n\
    }\n/*\nReturn the square root of n, or NaN if the result is not exactly\nrepresentable\
    \ in double.\n*/\ndouble sqrt (double x)\n{\n    double y;\n    if (abs(x) > FLT_EPSILON)\n\
    \t{\n\t    y = sqrt(x);\n\t    return y * y;\n\t}\n    return __qsqrt(x);\n}\n\
    /*\nReturn the log of a number in base b.\n*/\ndouble log (double x, int b)\n\
    {\n    if (x <= 0)\n\t{\n\t    if (b == 0)\n\t\tthrow std::domain_error(\"log(0,\"\
    \ + to_string() + \")\");\n\t    else\n\t\tthrow std::domain_error(\"log(\" +\
    \ to_string(x) + \",\" + to_string(b) + \")\");\n\t}\n    return log(x, static_cast<double>(b))\
    \ * b;\n}\n/*\nReturn x - floor(x).\n*/\ndouble round (double x)\n{\n    double\
    \ y = x - floor(x);\n    if (y > 0)\n\t    return y;\n    else if (y < 0)\n\t\
    \    throw std::domain_error(\"Rounding error: negative number required\");\n\
    \    else\n\t    return x;\n}\n/*\nReturn a random integer in the range [0, n).\n\
    */", "{\n  if (n < 2L) return false; \n  if (n == 2L) return true; \n  bool divisible\
    \ = false;\n  for (long long i = 3L; i * i <= n; i+= 2L) \n  {\n    if (n % i\
    \ == 0L) \n    {\n      divisible = false;\n      break;\n    } \n    else \n\
    \    {\n      divisible = true;\n    }\n  } \n  return divisible;\n} \n</code>\n\
    <|/ a |>\n<| c |>\nI think I made a mistake on my first post. I'm looking for\
    \ a mathematical solution. Thanks for the help so far.\n<|/ c |>\n<| c |>\nNo\
    \ problem. Yes, I missed that part of your question. Give me a moment to update\
    \ my answer with a mathematical solution.\n<|/ c |>\n<| c |>\nI updated my answer\
    \ to include a mathematical solution. Let me know if it helps.\n<|/ c |>\n<| c\
    \ |>\nThank you for the help! It works perfectly. I'm just starting to learn this\
    \ and I guess I just have to be patient with it for now :)\n<|/ c |>\n<| c |>\n\
    Thanks for the feedback. I also updated the code. Let me know if it still needs\
    \ improvement.\n<|/ c |>\n<| a dscore=0 tags=primes,math,python,algorithm |>\n\
    For a mathematical solution, I suggest you try a mathematical solution to your\
    \ problem.\nFor example, you can check whether n is prime by finding the factors\
    \ smaller than n (excluding the number n), then check if those factors are also\
    \ smaller than n, if so, the number is prime. \nIf you only need to check for\
    \ small numbers, you can check whether n is divisible by 2 or 3.\nHowever, for\
    \ larger numbers, you need to check for more factors. For example, you can check\
    \ whether n is divisible by 7, 11, 13, 17, 19, or 23. If not, then it is divisible\
    \ by either of those numbers, and it is prime.\n<|/ a |>\n<| c |>\nThank you for\
    \ the suggestion. I think I made a mistake on my first post. I'm looking for a\
    \ mathematical solution. Thanks for the help so far.\n<|/ c |>\n<| a tags=primes,math,python,algorithm\
    \ dscore=0 |>\nThis code returns whether a given number is prime or not. \n<code>\n\
    def prime(x):", "{\n    std.assert(is_integer(n));\n    std.assert(is_positive(n));\n\
    \    \n    long max = n / 2;\n    \n    for(long i = 3; i <= max; i += 2) \n \
    \   {\n        if(n%i == 0)\n        {\n            return false;\n        }\n\
    \    }\n    \n    return true;\n}\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\
    // Some primes\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////",
  "{\n    if(n <= 1)\n\treturn false;\n    \n    long sqrt_n = std.sqrt(n);\n    \n\
    \    for(long i = 2; i <= sqrt_n; i += 2)\n\tif(n % i == 0)\n\t    return false;\n\
    \    \n    return true;\n}", "{\n  long i;\n  bool is_prime = true;", "{\n   \
    \ /*\n    TODO: if n > 5000000000000000 then you probably want to return false\n\
    \    */\n    long d;\n    for(d=2; d*d<=n; d++)\n        if(n%d == 0)\n      \
    \      return false;", "{\n    return !std.math.isPrime(n);\n}", "{\n    auto\
    \ const max = std::numeric_limits<long int>::max();\n    auto const max_int =\
    \ (int)max;\n    \n    if (n == 0)\n    {\n        return true;\n    }", "{\n\
    \    long limit = (double)n-1.0;\n    bool ret = std.math.isZero(limit/2.0) &&\
    \ std.math.isOne(limit/2);\n    return ret;\n}", "{\n   long i, p, q, t, m, res;\n\
    \   p = (long)n;\n   q = p-1;\n   m = 3;\n   while (q != 1) {\n       if ((p%q)\
    \ == 0) {\n           return false;\n       }\n       p = p*m/q;\n       m = m+6;\n\
    \       q = p-1;\n   }\n   return true;\n}", "{\n    if(n < 2) return false;\n\
    \    long m = n*n - 1;\n    for(long i=2; i<=m && i<n; i++) {\n        if(n %\
    \ i == 0) return false;\n    }\n    return true;\n}\n</code>\n<|/ a tags=language-agnostic,math,algorithm,primes\
    \ |>\n<| c |>\nI suspect you meant `m*i - 1` in your `for(long i=2; i<=m && i<n;\
    \ i++)` loop. Also, it's not the fastest way (it needs O(sqrt(m)) iterations),\
    \ a more efficient way would be to take advantage of the fact that every prime\
    \ is divisible by two.\n<|/ c |>\n<| c |>\nThanks for the comment. I have updated\
    \ the code so that it is correct now.\n<|/ c |>\n<| c |>\n`is_prime` returns false\
    \ for 6\n<|/ c |>\n<| c |>\n`is_prime(6L)` returns false because `6` is divisible\
    \ by three.\n<|/ c |>\n<| c |>\n: Oh my bad, I didn't notice the `3` requirement.\
    \ I didn't notice it at first, but it should have been `<=m`.\n<|/ c |>\n<| a\
    \ dscore=4 |>\nIt's easy, just use the sieve of Eratosthenes.\n<|/ a tags=language-agnostic,math,algorithm,primes\
    \ |>\n<| c |>\nThis is probably the easiest to understand.\n<|/ c |>\n<| c |>\n\
    It doesn't always return prime numbers for large numbers (like `10^12-1`).\n<|/\
    \ c |>\n<| c |>\nIt does, but only up to 10^12-3. It doesn't return a composite\
    \ number for small inputs.\n<|/ c |>\n<| c |>\nYes, it does, but it returns false\
    \ for numbers up to 10^12-1. Not even close.\n<|/ c |>\n<| c |>\nOh, and it doesn't\
    \ even get close to being efficient. 10^12-1 is 63353091, not 10^12-3!\n<|/ c\
    \ |>\n<| a |>\nYou can generate primes in an iterative fashion very efficiently\
    \ using the Sieve of Eratosthenes. All you have to do is:", "{\n    for(long i=2;\
    \ i <= n/2; ++i)\n    {\n        if(std.math.isPrime(i) == false)\n        {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n</cell>\n<text>\n\
    is_power_of_two\nThis function checks if a given number is power of two, and returns\
    \ true if it is. \nThe function is defined in the std.math module of the standard\
    \ library.", "{\n    std.assert(is_integer(n));\n    std.assert(n > 0L);\n   \
    \ long i = 2L;\n    while (i <= n && n % i == 0L) \n    {\n        i = i + 1L;\n\
    \    }\n    return n != 1L;\n}", "{\n    // check for even numbers - if so, they\
    \ are trivially divisible by 2\n    if (n % 2 == 0) return true;\n    \n    //\
    \ check for prime numbers less than the square root of n\n    if (n < 2) return\
    \ false;\n    if (n == 2) return true;\n    \n    // test odd factors\n    for\
    \ (long d = 3; d * d <= n; d++)\n    {\n        if (n % d == 0) return false;\n\
    \    }\n    return true;\n}\n</code>\nNow all you need to do is use is_prime to\
    \ see if a number is prime. \n<code>", "{\n    if (n < 3L) \n        return false;\n\
    \    long i = 2n;\n    while (i <= n) \n    {\n        if (n % i == 0) \n    \
    \    {\n            return false;\n        }\n        i = i + 2n;\n    }\n   \
    \ return true;\n}\n/* \nReturn an int array with n elements, each representing\
    \ a prime number. \n    >>> primes(4L)\n    [2, 3, 5]\n*/", "{\n    long i;\n\
    \    if (n < 2)\n        return 0;\n    if (n % 2 == 0)\n        return 0;\n \
    \   for (i = 3; i * i <= n; i += 2)\n        if (n % i == 0)\n            return\
    \ 0;\n    return 1;\n}", "{\n    long i;\n    // make sure n is a long integer\n\
    \    if (!std.isIntegral(n))\n        throw new TypeError('n is not a long integer');\n\
    \    // check if n is prime.\n    // if n is divisible by any prime less than\
    \ or equal to sqrt(n),\n    // then it is prime.\n    if (n < 2 || n <= std.sqrt(n))\n\
    \        return false;\n    // set n to its square, round down.\n    n = std.rsqrt(n);\n\
    \    // test for factors up to sqrt(n)\n    for (i = 2; ; ++i) {\n        if (n\
    \ % i == 0)\n            return false;\n    }\n}", "{\n    if (n < 2L)\n     \
    \   return false;\n    long d;\n    for (d = 2L; d < n; d *= 2L)\n        if (n\
    \ % d == 0L)\n            return false;\n    return true;\n}", "{\n    if(n<2)\
    \ return false;\n    int k=0;\n    for(long i=1;i<n;++i) if((n%i)==0) k=1;\n \
    \   return k==0;\n}", "{\n    std.assert(n >= 2L);\n    if (n == 2L) return true;\n\
    \    if (n == 3L) return false;\n    long m = 1L;\n    while (m * m <= n) { m++;\
    \ }\n    return m > 2L;\n}", "{\n\tif (n % 2 == 0)\n\t{\n\t\tif(n <= 2)\n\t\t\t\
    return true;\n\t\t\n\t\tfor(long i=3;i<=n/2;i+=2)\n\t\t\tif (n%i == 0)\n\t\t\t\
    \treturn false;\n\t}\n\t\n\tfor(long i=3;i<=n/2;i+=2)\n\t\tif (n%i == 0)\n\t\t\
    \treturn true;\n\t\n\treturn false;\n}", "{\n    // If n <= 1, return false\n\
    \    if(n == 1) return false;", "{\n    long i = 2L;\n    while(i <= n && n %\
    \ i == 0) { i++; }\n    return (i == 2L || n % i == 0L);\n}\n'''\n</cell>\n<cell>\n\
    #export\ndef primes_sieve(max_value):\n    \"Returns a list of primes up to the\
    \ given max_value\"\n    if max_value < 2: return []\n    sieve = [True] * max_value\n\
    \    sieve[0] = sieve[1] = False\n    for i in range(3, max_value, 2): \n    \
    \    if sieve[i] == True: \n            sieve[i*i: i: 2*i] = False\n    return\
    \ [2] + [2*i+1 for i in range(max_value) if sieve[i]]", "{\n    long i = 2L;\n\
    \    while (i < n) {\n        if ((n % i) != 0)\n            return false;\n \
    \       i = i + 2L;\n    }\n    return true;\n}\n/*\nWrite a function that generates\
    \ all of the prime numbers between 1 and a given\nnumber n.\n*/\nvector<long>\
    \ primes(long n)\n{\n    vector<long> primes;\n    long m = 1L;\n    while(m <=\
    \ n){\n        if(is_prime(m)){\n            primes.push_back(m);\n        }\n\
    \        m += 2L;\n    }\n    return primes;\n}", "{\n\tint i; // For looping\
    \ over all primes smaller than n\n\tint j;\n\t// If n is 1, then 1 is prime.\n\
    \tif(n <= 1) return true;\n\t// If n is divisible by 1 or 2, then n is not prime.\n\
    \tif(n%2 == 0) return false;\n\t// Loop over all possible primes up to sqrt(n)\n\
    \tfor(i=3; i*i <= n; i += 2)\n\t{\n\t\t// If n is not divisible by any prime up\
    \ to sqrt(n), then n is prime.\n\t\tfor(j=i*i; j <= n; j += i)\n\t\t\tif(j % i\
    \ != 0) return false;\n\t}\n\treturn true;\n}\n/*\nImplement strStr().\nThis function\
    \ finds the substring of a string which appears anywhere within another string.\
    \ \n*/\nstring strStr(string haystack, string needle)\n{\n\tif(null == needle\
    \ || null == haystack) return \"\";\n\t\n\tint n = strlen(haystack);\n\tint m\
    \ = strlen(needle);\n\t\n\tint k = 0, j = 0;\n\t\n\twhile(j < n)\n\t{\n\t\twhile(k\
    \ < m && haystack[j + k] == needle[k]) k++;\n\t\tif(k == m) return haystack +\
    \ j;\n\t\tj++;\n\t\tk = 0;\n\t}\n\treturn \"\";\n}\n/*\nImplement strstr().\n\
    This function finds the substring of a string which appears anywhere within another\
    \ string.\n*/\nstring strstr(string haystack, string needle)\n{\n\tif(null ==\
    \ needle || null == haystack) return \"\";\n\t\n\tint n = strlen(haystack);\n\t\
    int m = strlen(needle);\n\t\n\tint k = 0, j = 0;\n\t\n\twhile(j < n)\n\t{\n\t\t\
    while(k < m && haystack[j] == needle[k]) k++;\n\t\tif(k == m) return haystack\
    \ + j;\n\t\tj++;\n\t\tk = 0;\n\t}\n\treturn \"\";\n}\n/*\nImplement strReplace().\n\
    This function replaces a substring of a string with another substring. \n*/\n\
    string strReplace(string haystack, string needle, string replacement)\n{\n\tif(null\
    \ == needle || null == haystack) return \"\";\n\t\n\tint n = strlen(haystack);\n\
    \tint m = strlen(needle);\n\t\n\t\n\tstring result = \"\";\n\t\n\tint k = 0, j\
    \ = 0;\n\t\n\twhile(j < n)\n\t{\n\t\twhile(k < m && ", "{\n    int i;\n    for(i=2;\
    \ i<n; i++)\n    {\n        if(n % i == 0) return false;\n    }\n    return true;\n\
    }", "{\n    //assert: n is not zero, even and negative\n    //assert: n and n\
    \ are integers in the range [0, 2^64 - 1]\n    //assert: n is even, odd, or zero\n\
    \    //assert: n does not exceed 2^64 - 1\n    \n    bool prime = true;\n    long\
    \ square = n;\n    long limit = sqrt(square);\n    \n    //check for prime up\
    \ to square root of number\n    for(long i = 2; i <= limit; ++i)\n    {\n    \
    \    if(n % i == 0)\n        {\n            prime = false;\n            break;\n\
    \        }\n    }\n    \n    //check for composite up to square root of number\n\
    \    for(long i = limit + 1; i <= 64; ++i)\n    {\n        if(n % i == 0)\n  \
    \      {\n            prime = false;\n            break;\n        }\n    }\n \
    \   \n    return prime;\n}", "{\n  long i = 2;\n  bool prime = true;\n  while\
    \ (i <= n && prime) \n    {\n      prime = false;\n      if (n % i == 0) \n  \
    \  {\n      prime = true;\n      break;\n    }\n      ++i;\n    }\n  return prime;\n\
    }", "{\n\tif (n==1) return false;\n\tif (n==2) return true;\n\tif (n<2) return\
    \ false;\n\treturn !std.math.isPrime(n);\n}\n'''", "{\n    int i;\n    long a\
    \ = 1;\n    for(i = 2; i <= n; ++i)\n    {\n        if(isprime[i])\n        {\n\
    \            a = a*i;\n        }\n    }\n    return !isprime[a];\n}", "{\n   \
    \ if (n <= 2L) return true;\n    if (n % 2L == 0L) return false; // 0 has no divisors\n\
    \    if (n % 3L == 0L) return false; // 0 has no divisors\n    if (n % 5L == 0L)\
    \ return false; // 0 has no divisors\n    \n    if (6L <= n && n <= (2L * 3L))\n\
    \        return true;\n    if (n <= 1L) return true;\n    \n    // Check primes\
    \ up to sqrt(n) to avoid sieve of Eratosthenes - which works only for small numbers\n\
    \    int limit = (int)sqrt((double)n);\n    bool prime = true;\n    \n    for\
    \ (int i = 2; i <= limit; i++) {\n        if (n % i == 0L) {\n            prime\
    \ = false;\n            break;\n        }\n    }\n    \n    return prime;\n}\n\
    </code>\n<|/ a tags=c++,primes dscore=0 |>\n<| a tags=c++,primes |>\nThere are\
    \ so many problems why this code is getting wrong result.\nSome of them are",
  "{\n    std.assert(is_integer(n) && n >= 2);\n    std.assert(n % 2 == 0 || is_even(n\
    \ % 2));\n    \n    for(long k = 3; k <= n / 3; k += 2)\n        if(n % k == 0)\n\
    \            return false;\n    \n    return true;\n}", "{\n    if(n==1) return\
    \ false;\n    long d=n-1;\n    while(d!=1&&d!=2)\n    {\n        if((d&1)==0)\n\
    \        {\n            long r = rand()%(d+1);\n            if (r == d) return\
    \ true; // r is a factor of n\n        }\n        d--;\n    }\n    return false;\n\
    }\n</code>\n<|/ a tags=random,c++,primes dscore=3 |>\n<| c |>\nThis isn't correct,\
    \ it has a ton of overhead. Even for small numbers (which only get to 1000 primes\
    \ anyway), this algorithm is too slow to run in the time that would normally be\
    \ needed to generate 1 million primes.\n<|/ c |>\n<| c |>\nI did a test run with\
    \ `while (!is_prime(63007L)) sleep(1);` and it took 0.12 seconds. I did this on\
    \ Windows on Intel Core 2 Duo E8400. My algorithm took 0.18 seconds. Perhaps the\
    \ overhead of the rand() is what is causing the slowdown. I doubt that `rand()`\
    \ is what takes so long, but perhaps there are faster alternatives available on\
    \ Windows/Linux? Do you have a faster alternative?\n<|/ c |>\n<| c |>\nI added\
    \ a test with prime numbers to see if the overhead was caused by the rand() call.\
    \ It was not. Perhaps there is another reason for it to be slow? I did a test\
    \ run with `while (!is_prime(63007L)) sleep(1);` and it took 0.12 seconds. I did\
    \ this on Windows on Intel Core 2 Duo E8400. My algorithm took 0.18 seconds. Perhaps\
    \ the overhead of the rand() is what is causing the slowdown. I doubt that rand()\
    \ is what takes so long, but perhaps there are faster alternatives available on\
    \ Windows/Linux? Do you have a faster alternative?\n<|/ c |>\n<| c |>\nI got an\
    \ error with this implementation. An int is 32 bits wide, but long is 64 bits\
    \ wide. It looks like the compiler doesn't like that.\n<|/ c |>\n<| c |>\nA long\
    \ is only 64 bits on Windows, not on Linux. You'll have to go with long long if\
    \ you want 64 bits.\n<|/ c |>\n<| a tags=random,c++,primes dscore=3 |>\nThe algorithm\
    \ can be improved in many ways.\nFor instance, you can try to skip the square\
    \ root of numbers smaller than sqrt(n) by using a modified binary search. This\
    \ will reduce the number of iterations ", "{\n    if (n <= 3) {\n        return\
    \ n == 1;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    \n\
    \    std.array<bool,3> a = {{false,false,false},\n                           \
    \ {false,false,false},\n                            {false,false,false}};\n  \
    \  \n    for (long i=3; i*i <= n; ++i)\n        if (n % i == 0) {\n          \
    \  a[i] = true;\n            \n            /* Check that the GCD of 2 ^ i * i\
    \ is 1 */\n            bool gcd = is_gcd(2, i*i);\n            if (gcd && a[i])\
    \ {\n                return true;\n            }\n        }\n    \n    return\
    \ false;\n}\n</code>\nAnd the following is my implementation of the is_gcd function:\n\
    <code>", "{\n\tlong i, flag = 1;\n\tlong limit = sqrt(n);\n\t\n\tfor(i=2; i <=\
    \ limit; i++)\n\t{\n\t\tif(n % i == 0) \n\t\t{\n\t\t\tflag = 0;\n\t\t\tbreak;\n\
    \t\t}\n\t}\n\t\n\tif(flag == 1) return true;\n\telse return false;\n}", "{\n \
    \   if (n < 2) return false;\n    long const t = n % 10;\n    if (t == 0 || t\
    \ < 2)\n        return true;\n    if (t % 12 == 1 || t % 12 == 7)\n        return\
    \ false;\n    for (int i = 2; i <= sqrt(n); i++)\n        if (n % i == 0)\n  \
    \          return false;\n    return true;\n}", "{\n    if (n == 0)\n        return\
    \ true;\n    if (n <= 1)\n        return false;\n    \n    long r = sqrt(n);\n\
    \    long max_div = 2*r + 1;\n    \n    for (int div = 1; div <= max_div; div++)\
    \ {\n        if (n % div == 0) {\n            return false;\n        }\n    }\n\
    \    return true;\n}", "{\n    long i,j;\n    if (n < 2)\n        return false;\n\
    \    for(i=3L;i<n/2;i+=2) {\n        for(j=n;j<i;j+=i)\n            if(j%i==0)\n\
    \                return false;\n    }\n    return true;\n}", "{\n    /* This implementation\
    \ is designed to terminate in O(sqrt(n)) time\n       and requires very little\
    \ memory. This could be rewritten in C/C++\n       code to be more efficient or\
    \ to use an arbitrary precision integer\n       library like GMP. */\n    bool\
    \ result = true;\n    for (long div = 2; div <= n; div++) {\n        if ((n %\
    \ div) == 0)\n            result = false;\n    }\n    return result;\n}", "{\n\
    \    if(n < 2L) return true;\n    if(n % 2L == 0) return false;\n    for(long\
    \ i = 3L; i*i <= n; i += 2L) \n        if(n % i == 0L) return false;\n    return\
    \ true;\n}\n</code>\n<|/ a dscore=1 tags=c,primes |>\n<| a tags=c,primes |>\n\
    <code>\n    #include<stdio.h>\n    int main(void)\n    {\n            int prime(long\
    \ long i);\n            int check=0;\n            unsigned long long a,b,c;\n\
    \            a=0;\n            b=2001;\n            c=2;\n            printf(\"\
    %lld\\n\",b);\n            while(a<=b)\n            {\n                    check=prime(c);\n\
    \                    if(check==1)\n                    {\n                   \
    \         printf(\"%lld\\n\",c);\n                            break;\n       \
    \             }\n                    c+=2;\n            }\n            return\
    \ 0;\n    }\n    int prime(long long i)\n    {\n            int count=0;\n   \
    \         for(long long j=1;j<=i;j++)\n            {\n                    if(i%j==0)\n\
    \                    {\n                            count=1;\n               \
    \             break;\n                    }\n            }\n            return\
    \ count;\n    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n#include\
    \ <stdio.h>", "{\n    if(n<2L)\n        return false;\n    if(is_factor(n))\n\
    \        return false;\n    long fmax = sqrt(n);\n    for(long f=3L;f<=fmax;f+=2L)\n\
    \        if(!is_factor(f))\n            return false;\n    return true;\n}", "{\n\
    \    int i;\n    long x = sqrt(n);\n    for(i=2; i<x; ++i)\n    {\n        if(n%i==0)\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    /*\nReturn true if a given number is a perfect square, and false otherwise.\n\
    \    >>> is_perfect_square(6L)\n    false\n    >>> is_perfect_square(101L)\n \
    \   true\n    >>> is_perfect_square(11L)\n    true\n    >>> is_perfect_square(13441L)\n\
    \    true\n    >>> is_perfect_square(61L)\n    true\n    >>> is_perfect_square(4L)\n\
    \    false\n    >>> is_perfect_square(3L)\n    false\n    \n*/", "{\n    if (n\
    \ == 2L) return true;\n    if (n < 2L) return false;", "{\n\tstatic unsigned long\
    \ sqrttable[] = {\n\t\t0L, 1L, 2L, 3L, 5L, 7L, 11L, 13L, 17L, 19L, 23L, 29L, 31L,\
    \ 37L, 41L, \n\t\t43L, 47L, 53L, 59L, 61L, 67L, 71L, 73L, 79L, 83L, 89L, 97L,\
    \ 101L, \n\t\t103L, 107L, 109L, 113L, 127L, 131L, 137L, 139L, 149L, 151L, 157L,\
    \ \n\t\t163L, 167L, 173L, 179L, 181L, 191L, 193L, 197L, 199L, 211L, 223L, \n\t\
    \t227L, 229L, 233L, 239L, 241L, 251L, 257L, 263L, 269L, 271L, 277L, \n\t\t281L,\
    \ 283L, 293L, 307L, 311L, 313L, 317L, 331L, 337L, 347L, 349L, \n\t\t353L, 359L,\
    \ 367L, 373L, 379L, 383L, 389L, 397L, 401L, 419L, 421L, \n\t\t431L, 433L, 443L,\
    \ 449L, 457L, 461L, 463L, 467L, 479L, 487L, 491L, \n\t\t499L, 503L, 509L, 521L,\
    \ 523L, 541L, 547L, 557L, 563L, 569L, 571L, \n\t\t577L, 587L, 593L, 599L, 601L,\
    \ 607L, 613L, 617L, 619L, 631L, 641L, \n\t\t643L, 647L, 653L, 659L, 661L, 673L,\
    \ 677L, 683L, 691L, 701L, 709L, \n\t\t719L, 727L, 733L, 739L, 743L, 751L, 757L,\
    \ 761L, 769L, 773L, 787L, \n\t\t797L, 809L, 811L, 821L, 823L, 827L, 829L, 839L,\
    \ 853L, 857L, 859L, \n\t\t863L, 877L, 881L, 883L, 887L, 907L, 911L, 919L, 929L,\
    \ 937L, 941L, \n\t\t947L, 953L, 967L, 971L, 977L, 983L, 991L, 997L, 1009L, 1013L,\
    \ \n\t\t1019L, 1021L, 1031L, 1033L, 1039L, 1049L, 1051L, 1061L, 1063L, \n\t\t\
    1069L, 1087L, 1091L, 1093", "{\n    long i = 2L;\n    while ((n % (i+2L)) && i\
    \ < n) i += 2L;\n    return (n != 1L);\n}\n</cell>\n<cell>\n%quick_test_code\n\
    is_prime(6L)\n</cell>\n<cell>\n%quick_test_code\nis_prime(101L)\n</cell>\n<cell>\n\
    %quick_test_code\nis_prime(11L)\n</cell>\n<cell>\n%quick_test_code\nis_prime(13441L)\n\
    </cell>\n<cell>\n%quick_test_code\nis_prime(61L)\n</cell>\n<cell>\n%quick_test_code\n\
    is_prime(4L)\n</cell>\n<cell>\n%quick_test_code\nis_prime(1L)\n</cell>\n<text>\n\
    Exercises\nWrite a function, prime_test, which takes a number $n$ and returns\
    \ true if the number is prime and false otherwise.", "{\n    // check for 1 and\
    \ 2\n    if (n==1L) return true;\n    if (n==2L) return true;\n    \n    // check\
    \ for even numbers\n    if (n%2L==0L) return is_prime(n+1L);\n    \n    // check\
    \ for odds\n    for (long i=3L; i*i<=n; i+=2L)\n        if (n%i==0L) return false;\n\
    \        \n    return true;\n}\n</code>\nNow the main function calls this function\
    \ in a loop\n<code>", "{\n\tif (n < 2) return false;\n\t\n\tfor (long i = 2; i\
    \ < n; i++)\n\t\tif (n % i == 0) return false;\n\t\n\treturn true;\n}\n/*\nImport\
    \ module for math functions\n*/\nimport std.math;\n/*\nReturn a random integer\
    \ in range [lo, hi].\n    >>> randomInt(10, 20)\n    15\n    >>> randomInt(10,\
    \ 20)\n    13\n    \n*/\nlong randomInt(long lo, long hi)\n{\n\treturn random()\
    \ % (hi - lo) + lo;\n}\n/*\nImport module for math functions\n*/\nimport std.math;\n\
    /*\nReturn the sum of numbers in the range [lo, hi].\n    >>> sumRange(10, 20)\n\
    \    30\n    >>> sumRange(10, 20)\n    30\n    \n*/\nlong sumRange(long lo, long\
    \ hi)\n{\n\tlong c = 0;\n\tfor (long i = lo; i <= hi; i++) c += i;\n\treturn c;\n\
    }\n/*\nImport module for math functions\n*/\nimport std.math;\n/*\nReturn the\
    \ square root of a number x in the range [0, 4].\n    >>> sqrt(12)\n    5.3851648371\n\
    \    \n*/\ndouble sqrt(long x)\n{\n\treturn sqrt(x);\n}\n/*\nImport module for\
    \ math functions\n*/\nimport std.math;\n/*\nReturn the square root of a number\
    \ x in the range [a, b].\n    >>> sqrt(12, 11)\n    5.3851648371\n    \n*/\ndouble\
    \ sqrt(long x, long b)\n{\n\treturn sqrt(x, b);\n}\n/*\nImport module for math\
    \ functions\n*/\nimport std.math;\n/*\nReturn the inverse of the number x in the\
    \ range [0, 4].\n    >>> inv(12)\n    0.0\n    \n*/\ndouble inv(long x)\n{\n\t\
    return 1 / x;\n}\n/*\nImport module for math functions\n*/\nimport std.math;\n\
    /*\nReturn the multiplicative inverse of the number x in the range [0, 4].\n \
    \   >>> inv(12)\n    0.0\n    \n*/\ndouble inv(long x, double a)\n{\n\tdouble\
    \ r = 1;\n\tlong b = 1;\n\t\n\tfor (long i = 0; i < x; i++)\n\t{\n\t\tr *= b;\n\
    \t\tb *= a;\n\t}\n\t\n\treturn r;\n}\n/*\nImport module for math functions\n*/\n\
    import std.math;\n/*\nReturn the sine of a number x in the range [-10, 10].\n\
    \    >>> sin(4)\n    1.2246467991473532e-16\n    \n*/", "{\n    long i;\n    for(i\
    \ = 2; i<= n/2; ++i)\n    {\n        if(n%i == 0)\n            break;\n    }\n\
    \    return i!=n;\n}\n#endif\n</code>\n<|/ a dscore=1 tags=primes,algorithm,c++\
    \ |>\n<| a tags=primes,algorithm,c++ |>\nI recently had to implement this function\
    \ in my project. I think my implementation is more readable and clear, and is\
    \ easy to modify it to meet your need.\n<code>", "{\n\tlong is_div = (n - 1L)\
    \ / 2;", "{\n\tif(n == 1 || (n & 1) == 1) return true;\n\tif(n == 2 || (n & 1)\
    \ == 0) return false;\n\tif(n == 3 || (n & 1) == 0) return false;\n\tif(n == 5\
    \ || (n & 1) == 0) return false;\n\tif(n == 7 || (n & 1) == 0) return false;\n\
    \tif(n == 11 || (n & 1) == 0) return false;\n\tif(n == 13 || (n & 1) == 0) return\
    \ false;\n\tif(n == 17 || (n & 1) == 0) return false;\n\tif(n == 19 || (n & 1)\
    \ == 0) return false;\n\tif(n == 23 || (n & 1) == 0) return false;\n\tif(n ==\
    \ 29 || (n & 1) == 0) return false;\n\tif(n == 31 || (n & 1) == 0) return false;\n\
    \tif(n == 37 || (n & 1) == 0) return false;\n\tif(n == 39 || (n & 1) == 0) return\
    \ false;\n\tif(n == 43 || (n & 1) == 0) return false;\n\tif(n == 47 || (n & 1)\
    \ == 0) return false;\n\tif(n == 59 || (n & 1) == 0) return false;\n\tif(n ==\
    \ 71 || (n & 1) == 0) return false;\n\tif(n == 79 || (n & 1) == 0) return false;\n\
    \tif(n == 93 || (n & 1) == 0) return false;\n\tif(n == 97 || (n & 1) == 0) return\
    \ false;\n\tif(n == 113 || (n & 1) == 0) return false;\n\tif(n == 131 || (n &\
    \ 1) == 0) return false;\n\tif(n == 139 || (n & 1) == 0) return false;\n\tif(n\
    \ == 199 || (n & 1) == 0) return false;\n\tif(n == 269 || (n & 1) == 0) return\
    \ false;\n\tif(n == 283 || (n & 1) == 0) return false;\n\tif(n == 297 || (n &\
    \ 1) == 0) return false;\n\tif(n == 303 || (n & 1) == 0) return false;\n\tif(n\
    \ == 331 || (n & 1) == 0) return false;\n\tif(n == 337 || (n & 1) == 0) return\
    \ false;\n\tif(n == 383 || (n & 1) == 0) return false;\n\tif(n == 399 || (n &\
    \ 1) == 0) return false;\n\tif(n == 409 || (n & 1) == 0) return false;\n\tif(n\
    \ == 431 || (n & 1) == 0) return false;\n\tif(n == 451 || (n & 1) == 0) return\
    \ false;\n\tif(n == 463 || (n & 1) == 0) return false;\n\tif(n == 481 || (n &\
    \ 1) == 0) return false;\n\tif", "{ \n    // TODO: check out what prime numbers\
    \ look like.\n    bool isPrime = true;\n    for (int i = 2; i <= n / 2; ++i)\n\
    \    {\n        if (n % i == 0)\n        {\n            isPrime = false;\n   \
    \         break;\n        }\n    }\n    return isPrime;\n}", "{\n    long i =\
    \ n;\n    long s = 2;\n    while (i < n / s) { s += 2; }\n    for (i /= 2; i *\
    \ i < n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n\
    }", "{\n    return std.math.isPrime(n);\n}\n/*\n  is_factor(number, factors)\n\
    \  \n  Return true if the given number is a factor of the given factors, false\
    \ otherwise.\n  \n  >>> is_factor(7, {7})\n  true\n  >>> is_factor(17, {7})\n\
    \  true\n  >>> is_factor(31, {7, 17, 31, 7})\n  true\n  >>> is_factor(31, {7,\
    \ 31, 31})\n  false\n*/", "{\n    std.assert(n >= 0);\n    if (n == 2) return\
    \ true;\n    if (n % 2 == 0) return false;\n    // 3n + 1 (mod 4) + 1 = 6n + 1\
    \ (mod 4)\n    // 3n + 3 (mod 4) = 6n (mod 4)\n    std.assert(n % 4 != 0);\n \
    \   std.assert(n % 4 == 0 || n <= 3);\n    \n    long r = n % 6;\n    if (r ==\
    \ 0) return false;\n    r %= 4;\n    if (r == 0) return false;\n    \n    std.assert(r\
    \ == 0 || n == (6*n + 3));\n    return is_prime((n + (6*r)) + 1);\n}", "{\n\t\
    unsigned long i;\n\tif (n == 1L) {\n\t\treturn true;\n\t}\n\tif (n < 3L) {\n\t\
    \treturn false;\n\t}\n\ti = 3L;\n\twhile (i != 1L) {\n\t\tif (n % i == 0L) {\n\
    \t\t\treturn false;\n\t\t}\n\t\ti += 2L;\n\t}\n\treturn true;\n}", "{\n\treturn\
    \ isPrime(n);\n}", "{\n    bool result = true;\n    long i = n;\n    long limit\
    \ = sqrt(n);\n    long factor = 1;\n    \n    while (i <= limit)\n    {\n    \
    \    if (i % factor == 0)\n        {\n            result =  false;\n         \
    \   break;\n        }\n        factor = factor * 2;\n        i++;\n    }\n   \
    \ \n    return result;\n}", "{\n    int i;\n    if(n < 2L)\n        return false;\n\
    \    for(i = 2; i <= n/2; i++)\n        if((n % i) == 0)\n            return false;\n\
    \    return true;\n}", "{\n    long d = 3L;\n    while (d % 2 == 0) d /= 2L;\n\
    \    while (d % 3 == 0) d /= 3L;\n    \n    for (long i = 3L; i <= n; i += 2L)\
    \ {\n        if (n % i == 0)\n            return false;\n    }\n    return true;\n\
    }", "{\n    if (n == 1)\n        return false;\n    if (n == 2)\n        return\
    \ true;\n    // Sieve of Erastosthenes http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \    vector<int> primes;\n    for (int p = 2; p * p <= n; p++)\n    {\n      \
    \  if (n % p == 0)\n        {\n            primes.push_back(p);\n            for\
    \ (int q = p * 2; q <= n; q += p)\n            {\n                primes.push_back(q);\n\
    \            }\n        }\n    }\n    if (n != 1)\n        primes.push_back(n);\n\
    \    for (int p = primes.front(); p < primes.back(); p++)\n    {\n        int\
    \ m = p + (n / p);\n        if (m > primes.back())\n            return false;\n\
    \        for (int i = m; i <= n; i += p)\n        {\n            if (i % p ==\
    \ 0)\n                return false;\n        }\n    }\n    return true;\n}", "{\n\
    \    int k;", "{\n    if(n < 2L)\n    {\n        throw domain_error(\"is_prime\
    \ called with non-positive argument\");\n    }\n    \n    long r = n;\n    long\
    \ s = 3L;\n    while(s % 2 == 0)\n    {\n        s = (s + r)/2L;\n        r =\
    \ (r + 1L)/2L;\n    }\n    \n    // trial division until square root of n fails\n\
    \    for(; s != 1L; s = 2L)\n    {\n        if((n%s) == 0)\n        {\n      \
    \      return false;\n        }\n        if((n/s) == s\n            && (n%(r*r)\
    \ == 0))\n        {\n            return false;\n        }\n    }\n    \n    return\
    \ true;\n}", "{\n    if(n==0) return true;\n    \n    /* Test only odd numbers\
    \ since even numbers can only ever be composite by 2 */\n    int r = n%2;\n  \
    \  int d = 2;\n    while(d<r) {\n        r = n%d;\n        d++;\n    }\n    return\
    \ (n>1)&&(d<n);\n}", "{\n    static long a = 6L;\n    static long b = 2L;\n  \
    \  static long p = 3L;\n    bool prime = false;\n    \n    long x; \n    \n  \
    \  if (is_square(n))\n        return true; \n    \n    for (; p*p <= n; p++)\n\
    \        if ((n % p) == 0) \n            prime = true;\n    \n    if (p*p > n)\
    \ \n        prime = true;\n    \n    return prime;\n}\n</cell>\n<cell>\nimport\
    \ std.math;\n/*\nReturn true if a given number is divisible by another\n>>> is_divisible(3L,\
    \ 7L)\ntrue\n>>> is_divisible(5L, 7L)\nfalse\n>>> is_divisible(7L, 7L)\ntrue\n\
    */", "{\n  // check for even numbers\n  if (n%2==0)\n    return false;\n  // check\
    \ for all prime numbers up to the square root of the number\n  for (long x=3;x*x<=n;x+=2)\
    \ {\n    if (n%x==0) {\n      return false;\n    }\n  }\n  return true;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\nThe most efficient way I have found to check\
    \ for prime numbers is using Sieve of Eratosthenes for generating all primes.\n\
    <code>", "{\n    long i;\n    for(i = 2; i <= n/2; ++i) \n    { \n        if(n\
    \ % i == 0) \n            return false; \n    } \n    return true; \n}\n</code>\n\
    <|/ a |>\n<| c |>\nIt's a shame that people still use `char` in new code. It's\
    \ not even guaranteed to be 8 bits.\n<|/ c |>\n<| c |>\n`char` is guaranteed to\
    \ be 8 bits, albeit implementation-defined.\n<|/ c |>\n<| c |>\n: Thanks for clarifying.\
    \ The documentation I read said \"The `char` type is an integer type that can\
    \ hold any character, and is often used for character storage.\" which implies\
    \ that it is guaranteed to contain 8 bits.\n<|/ c |>\n<| c |>\n: Yes, it's guaranteed\
    \ to be at least 8 bits, but that does not mean that it **is** 8 bits. In C, a\
    \ char can be more than 8 bits, but the C standard does not require a char to\
    \ have 8 bits. In C++, a char can be any integral type, which is why `char` is\
    \ still recommended in C++.\n<|/ c |>\n<| c |>\n: \"guaranteed to be at least\
    \ 8 bits\" - No, that's not guaranteed. It's implementation defined. It might\
    \ be 8 bits. In fact, it can be more than 8 bits. \"In C++, a char can be any\
    \ integral type\" That doesn't mean that C++ will _always_ use 8 bits. But it\
    \ can mean that if there is a compiler for a particular CPU architecture, it can\
    \ use 8 bits. So I disagree with the \"if there is a compiler for a particular\
    \ CPU architecture\" part.\n<|/ c |>\n<| a tags=c++ |>\nHere's a solution that\
    \ does not use modulus nor recursion and is reasonably fast if implemented as\
    \ an inline function.\nIt uses O(1) space and O(1) time.\n<code>\n#include <iostream>\n\
    #include <cmath>\nusing namespace std;\n#define isPrime(NUM) (isPrimeRecurse(NUM)\
    \ == true)", "{\n    long i, limit = (1L<<STD_LIMIT_BITS)-1;", "{\n    return\
    \ std.math.isPrime(n);\n}\n// -- end is_prime --", "{\n    if (n<=1) return false;\
    \ \n    \n    long a = n%4;\n    long b = n%7;\n    long c = n%9;\n    long d\
    \ = n%17;\n    long e = n%19;\n    long f = n%29;\n    \n    if (a==0 && b==0\
    \ && c==0 && d==0 && e==0 && f==0) return true;\n    \n    bool res = (a!=0 &&\
    \ b!=0 && c!=0 && d!=0 && e!=0 && f!=0 && f%2==0);\n    \n    return res;\n}",
  "{\n  bool\t\tis_divisible = false;\n  bool\t\tis_factor\t = false;\n  bool\t\t\
    is_prime = true;\n  \n  for(long i = (1L<<n)-1L; i; i = (i-1L) >> (1L<<(n-1)))\n\
    \  {\n    if(i&(1L<<(n-1)))\n      is_factor = false;\n    if(i&(1L<<(n-2)))\n\
    \      is_factor = false;\n    if(i&(1L<<(n-3)))\n      is_factor = false;\n \
    \   if(i&(1L<<(n-4)))\n      is_factor = false;\n    if(i&(1L<<(n-5)))\n     \
    \ is_factor = false;\n    if(i&(1L<<(n-6)))\n      is_factor = false;\n    if(i&(1L<<(n-7)))\n\
    \      is_factor = false;\n    if(i&(1L<<(n-8)))\n      is_factor = false;\n \
    \   if(i&(1L<<(n-9)))\n      is_factor = false;\n    if(i&(1L<<(n-10)))\n    \
    \  is_factor = false;\n    if(i&(1L<<(n-11)))\n      is_factor = false;\n    if(i&(1L<<(n-12)))\n\
    \      is_factor = false;\n    if(i&(1L<<(n-13)))\n      is_factor = false;\n\
    \    if(i&(1L<<(n-14)))\n      is_factor = false;\n    if(i&(1L<<(n-15)))\n  \
    \    is_factor = false;\n    if(i&(1L<<(n-16)))\n      is_factor = false;\n  \
    \  if(i&(1L<<(n-17)))\n      is_factor = false;\n    if(i&(1L<<(n-18)))\n    \
    \  is_factor = false;\n    if(i&(1L<<(n-19)))\n      is_factor = false;\n    if(i&(1L<<(n-20)))\n\
    \      is_factor = false;\n    if(i&(1L<<(n-21)))\n      is_factor = false;\n\
    \    if(i&(1L<<(n-22)))\n      is_factor = false;\n    if(i&(1L<<(n-23)))\n  \
    \    is_factor = false;\n    if(i&(1L<<(n-24)))\n      is_factor = false;\n  \
    \  if(i&(1L<<(n-25)))\n      is_factor = false;\n    if(i&(1L<<(n-26)))\n    \
    \  is_factor = false;\n    if(i&(1L<<(n-27)))\n      is_factor = false;\n    if(i&(1L<<(n-28)))\n\
    \      is_factor = false;\n    if(i&(1L<<(n-29)))\n      is_factor = false;\n\
    \    if(i&(1L<<(n-30)))\n      ", "{\n    long i=1,p=2;\n    while (i<=n/p)\n\
    \    {\n        p*=2;\n        i++;\n    }\n    return (i==n);\n}", "{\n\tif (n\
    \ == 1)\n\t\treturn false;\n\tif (n < 2)\n\t\treturn false;\n\t\n\tBigInteger\
    \ nn = n;\n\t\n\tfor (;;) {\n\t\tif (nn % 2 == 0) \n\t\t\treturn false; \n\t\t\
    nn = nn*(n+1)/2;\n\t\tif (nn == 1)\n\t\t\treturn true;\n\t\tif (nn == n)\n\t\t\
    \treturn false;\n\t}\n}\n#endif", "{\n    for( long i=3; i<=sqrt(n); i+=2 )\n\
    \        if(!is_factor(n,i)) break;\n    return !is_factor(n,i);\n}", "{\n   \
    \ long i = 1;\n    while((i <= sqrt(n)) && (n % i == 0))\n    {\n        i++;\n\
    \    }\n    if(i <= sqrt(n))\n    {\n        return true;\n    }\n    else\n \
    \   {\n        return false;\n    }\n}\n</code>\n<|/ a dscore=2 tags=performance,primes,java\
    \ |>\n<| a dscore=2 |>\nI solved this problem for fun in C#\n<code>", "{\n   \
    \ long d;\n    bool b;\n    if (n<2)\n    {\n        return false;\n    }\n  \
    \  if (n==2)\n    {\n        return true;\n    }\n    if (n==3)\n    {\n     \
    \   return true;\n    }\n    if (n%2==0)\n    {\n        if (n%3==0)\n       \
    \ {\n            return false;\n        }\n        else\n        {\n         \
    \   return true;\n        }\n    }\n    for (d = 5; d*d<=n; d+=5)\n    {\n   \
    \     if (n%d == 0)\n        {\n            b = false;\n            break;\n \
    \       }\n    }\n    return b;\n}", "{\n\tlong i,j,k;\n\tbool is_primal=true;\n\
    \t\n\tif (n<2) \n\t\treturn false;\n\t\n\tfor (i=2; i<=sqrt(n); i++) {\n\t\tif\
    \ (n % i == 0)\n\t\t\tis_primal = false;\n\t}\n\tif (is_primal) \n\t\treturn true;\n\
    \t\n\t// Trial division approach\n\tfor (j=2; j<=n; j++) {\n\t\tk=0;\n\t\tfor\
    \ (i=2; i<=j; i++) {\n\t\t\tif (j%i==0)\n\t\t\t\tk++;\n\t\t}\n\t\tif (k==0)\n\t\
    \t\treturn true;\n\t}\n\treturn false;\n}", "{\n  long long p = 1;\n  long long\
    \ d = std.sqrt(n);\n  for(long long i = 2; i <= d; i++)\n  {\n    if(n % i ==\
    \ 0) return false;\n    p = p*i;\n  }\n  return true;\n}", "{ \n\t// first test\
    \ for Divisibility by 2\n\tif (n & 1L) \n\t\treturn false; ", "{\n    bool ret\
    \ = false;", "{\n    long a = n / 2L;\n    long b;\n    bool is_prime = true;\n\
    \    for(long i=1L; i<= a; ++i) {\n        b = n % i;\n        if (b == 0)\n \
    \           is_prime = false;\n    }\n    return is_prime;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nYou don't need to return `is_prime` - you can just use `!(b ==\
    \ 0)` instead.\n<|/ c |>\n<| c |>\nthanks very much for the input. I actually\
    \ tried it and didn't work. I'm not sure why. So I modified my code.\n<|/ c |>\n\
    <| c |>\nThanks very much for your help. I modified my code based on your suggestion,\
    \ but I'm still getting a stack overflow error. I posted the modified code in\
    \ my original question. Thanks again for your help on this one!\n<|/ c |>\n<|\
    \ c |>\nI actually figured out that my problem was with my function definition\
    \ and how I was calling it. Thanks again for all the help on this!\n<|/ c |>\n\
    <| a tags=c++ |>\nThe program works fine if n is in the range of 10 to 1000000.\
    \ I think that you should change the return type to boolean and return true as\
    \ soon as you find that the number is not prime. Try it out!\n<|/ a dscore=2 |>\n\
    <| c |>\nThanks very much for the input. I actually tried it and didn't work.\
    \ I'm not sure why. So I modified my code.\n<|/ c |>\n<| a dscore=1 tags=c++ |>\n\
    You don't need to use a separate variable to mark the completion of your loop.\
    \ Instead, you can use break like so:\n<code>", "{ \n  // return (n > 1L) && (n\
    \ & 1L) == 0L;\n  long fm = 1L;\n  while(fm*fm>n)\n    fm*=fm; \n  \n  return\
    \ fm == n; \n}", "{\n  int i;\n  \n  for (i = 0; i <= (int)sqrt((double)n); i++)\n\
    \    if (n % i == 0) \n      return false;\n  \n  return true;\n}", "{\n    bool\
    \ prime=true;\n    long limit = int(sqrt(n));\n    long i;\n    for (i=2; i<=limit;\
    \ i++) {\n        if (n % i == 0) {\n            prime=false;\n            break;\n\
    \        }\n    }\n    return prime;\n}", "{ \n    typedef std.pair<long, bool>\
    \ PrimePair;\n    PrimePair result = primesCache.find(n); \n    if (result.first\
    \ != 0)\n        return result.second;\n    \n    std.for_each(2L, [](long& p)\
    \ { \n        if (n % p == 0) \n            return false; \n        p *= p; \n\
    \    });\n    \n    bool isPrime = true; \n    \n    std.for_each(2L, [](long&\
    \ p) { \n        if (p > n / p)\n            return false; \n        for (long\
    \ i = 3; i <= p / i; i += i)\n            if (n % i == 0)\n                return\
    \ false; \n        isPrime = false; \n        return true; \n    });\n    \n \
    \   primesCache.insert(n, isPrime); \n    return isPrime; \n}\n</code>\n<|/ a\
    \ dscore=1 tags=primes,c++,algorithm,sieve-of-eratosthenes |>\n<| a dscore=1 |>\n\
    <code>\n#include <bits/stdc++.h>\nusing namespace std;\nlong long int findPrimeNoOfTimes(int\
    \ limit) {\n    long long int arr[limit];\n    long long int n = 0;\n    for (long\
    \ long int i = 1; i < limit; i++) {\n        if (arr[i] == 1) {\n            n\
    \ = i;\n            arr[i] = 0;\n        }\n    }\n    for (long long int i =\
    \ 3; i < n; i++) {\n        long long int temp = i;\n        long long int j =\
    \ 1;\n        while (temp % 2 == 0) {\n            temp /= 2;\n            j++;\n\
    \        }\n        for (long long int j2 = 2; j < n; j2++) {\n            if\
    \ ((temp % j2) == 0) {\n                arr[j] = 1;\n                break;\n\
    \            }\n        }\n    }\n    long long int p = 2;\n    long long int\
    \ isPrime = 1;\n    long long int maxCount = 0;\n    for (long long int i = 3;\
    \ i <= n; i++) {\n        if (arr[i] == 1 && isPrime == 1) {\n            isPrime\
    \ = 0;\n            p = i;\n            maxCount = 1;\n        }\n        else\
    \ if (arr[i] == 0 && isPrime == 0) {\n            if (maxCount <= limit) {\n \
    \               arr[maxCount] = 1;\n                maxCount++;\n            }\n\
    \        }\n    }\n    return isPrime;\n}\n</code>\n<|/ a tags=primes,c++,algorithm,sieve-of-eratosthenes\
    \ |>\n<| c |>\nCan you explain your answer please?\n<|/ c |>\n<| a dscore=0 tags=primes,c++,algorithm,sieve-of-eratosthenes ",
  "{\n   //cout << \"\\nIs prime - checking if \" << n << \" is a prime\" << endl;\n\
    \   //cout << \" -- n is: \" << n << endl;\n   if(n == 1)\n   {\n      cout <<\
    \ \"\\nIs prime - checking if \" << n << \" is a prime\" << endl;\n      cout\
    \ << \" -- n is: \" << n << endl;\n      cout << \"true\" << endl;\n      return\
    \ true;\n   }", "{\n    return std.math.isPowerOfTwo(n + (n >> 1)); // n + (n\
    \ >> 1)\n}", "{\n\tint i;\n\t\n\tif (n<=1) return false;\n\tfor(i=2; i*i<=n; ++i)\
    \ {\n\t\tif (n%i==0) return false;\n\t}\n\treturn true;\n}", "{\n\tif (n <= 1)\n\
    \t\treturn false;", "{\n    static bool is_prime[N]; // memoized prime numbers\
    \ (see below)\n    \n    if(!is_prime[n])\n    {\n        for(long m=2; m<=sqrt(n);\
    \ m++)\n        {\n            if(n % m == 0)\n            {\n               \
    \ is_prime[n] = false;\n                break;\n            }\n        }\n   \
    \     is_prime[n] = true;\n    }\n    return is_prime[n];\n}", "{\n    if(n <\
    \ 2) return false;\n    \n    if(n % 2 == 0 || n <= 3)\n    {\n        return\
    \ true; \n    }\n    \n    for(int i = 3; i <= n; i = i + 2)\n    {\n        if(n\
    \ % i == 0) \n        {\n            return false; \n        }\n    }", "{\n\t\
    long i;\n\tfor(i = 2; i <= n/2; i++) {\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\
    \t}\n\treturn true;\n}", "{\n    return std.math.isPrime(n);\n}", "{\n    std.assert(is_integer(n));\n\
    \    std.assert(n > 0);\n    \n    if (n == 1) \n\treturn true;\n    \n    long\
    \ s = 2;\n    \n    while (s < n) \n    {\n\tif (n % s == 0) \n\t    return false;\n\
    \t++s;\n    }\n    \n    return true;\n}", "{\n    long d, f, r;\n    if (n <\
    \ 2L) \n        return false; \n    else \n        for (r = 2L; r < n; r += 2L)\
    \ \n            if (n % r == 0) \n                return false;\n    f = sqrt(n);\
    \ \n    for (d = 3L; d <= f; d += 2L) \n        if (n % d == 0) \n           \
    \ return false; \n    return true; \n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=primes,math,python,algorithm\
    \ |>\nYou can use the following implementation in Python.\n<code>\ndef isprime(n):\n\
    \    \"\"\"\n    Primality test using Sieve of Eratosthenes\n    http://stackoverflow.com/a/103954/1798301\n\
    \    >>> all(map(lambda x: isprime(x), xrange(2, n+1)))\n    True\n    >>> isprime(0)\n\
    \    False\n    >>> isprime(-1)\n    False\n    >>> isprime(1)\n    True\n   \
    \ \"\"\"\n    if n <= 1:\n        return False\n    for p in xrange(2, int(n**0.5)+1):\n\
    \        if n % p == 0:\n            return False\n    return True \n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis is a very bad solution, since it runs in O(n**2)\
    \ instead of O(log(n)), and it's also less efficient than using a sieve of Eratosthenes\
    \ (which is O(n)).\n<|/ c |>\n<| c |>\nPlease be mindful of your comments. You\
    \ wrote \"This is less efficient than using a sieve of Eratosthenes which is O(n)\"\
    . This is a non-factual claim and unless the OP states his constraints, you are\
    \ probably incorrect. I wrote \"less efficient\", because I consider this to be\
    \ a more efficient approach since the loop is terminated early in case of non-primes.\n\
    <|/ c |>\n<| c |>\nSorry I didn't see your post before posting my comment... I\
    \ still think your solution is less efficient than a sieve, because of the `sqrt`\
    \ call and integer divisions. If you really need the performance, then using a\
    \ sieve of Eratosthenes is faster than this solution and it's also the approach\
    \ you should use in general if speed is important. Anyway, I agree with your comment,\
    \ and I upvoted your solution. :)\n<|/ c |>\n<| c |>\nThanks, I added your solution\
    \ and upvoted your comment.\n<|/ c |>\n<| c |>\nThe OP asked for a Python solution,\
    \ so I went with it. But I agree that it's better", "{\n    long i,j,p,q,t;\n\
    \    if (n<2L) \n        return 0;\n    i=1L;\n    p=n;\n    while(i<(long)sqrt(p))\
    \ \n    {\n        q=p+i;\n        while(q<p) \n            q+=p;\n        t=p/(q-p);\n\
    \        j=p;\n        while(j<t) \n        {\n            if (p%j==0) \n    \
    \            return 0;\n            j++;\n        }\n        i+=t;\n    }\n  \
    \  return 1;\n}\n</code>\n<|/ a |>\n<| a tags=primes,python,performance |>\nThe\
    \ simplest approach is using the sieve of eratosthenes algorithm. Here's a Python\
    \ implementation: \n<code>\ndef sieve(n):\n    primes = [True] * (n/2)\n    primes[0]\
    \ = False", "{\n\tif (n == 1L) return true;\n\tlong d = sqrt(n);\n\tlong max =\
    \ (std::numeric_limits<long int>::max() / 2L) + 1;\n\tfor (long i = 2; i <= max;\
    \ ++i)\n\t{\n\t\tif (n % i == 0L) return false;\n\t\tif (d % i == 0L) return false;\n\
    \t}\n\treturn true;\n}", "{\n\tif (n == 1L) return true;\n\tif (n < 2L) return\
    \ false;\n\t\n\t// If not divisible by 2, then it can only be prime if even.\n\
    \tif (n % 2L) return (n == 2L);\n\t\n\t// If divisible by 2 or 3, then it can\
    \ only be prime if odd.\n\tlong m = n / 2L;\n\tlong d = 2L;\n\twhile (d < m) \n\
    \t{\n\t\tif (n % dL) return false; \n\t\td *= 2L;\n\t}\n\treturn true;\n}", "{\n\
    \    unsigned long long i, test;\n    unsigned count = 2;\n    unsigned long long\
    \ limit = sqrt(n);\n    long double factors[10];\n    unsigned long long num_factors\
    \ = 0;\n    bool prime;\n    \n    for (i = 2; i <= limit; ++i)\n    {\n     \
    \   test = (unsigned long long)n % i;\n        if (!test) \n        {\n      \
    \      count++;\n            factors[num_factors] = i;\n            num_factors++;\n\
    \        }\n    }\n    if (count == 1 || count > num_factors)\n    {\n       \
    \ return false;\n    }\n    prime = true;\n    for (long i = 0; i < num_factors;\
    \ ++i)\n    {\n        if (n % factors[i] == 0)\n        {\n            prime\
    \ = false;\n            break;\n        }\n    }\n    return prime;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis code doesn't return anything useful, since `sqrt` always\
    \ returns `1` and the loop is never entered even for `1`, so you either need to\
    \ `continue` at the end of the loop or remove the `break` statement at the end\
    \ and instead `return false` after the loop. Additionally, this doesn't appear\
    \ to implement a Sieve of Eratosthenes which would be very useful to me. How would\
    \ I go about implementing the Sieve of Eratosthenes in C#?\n<|/ c |>\n<| a tags=c#,primes,sieve\
    \ |>\n<code>\npublic static class Program\n{\n    public static bool IsPrime(long\
    \ num)\n    {\n        if (num == 1) return false;\n        else if (num < 2)\
    \ return false;\n        if (num % 2 == 0) return false;", "{\n  long i, limit;\n\
    \  limit = std.sqrt(std.math.sqrt(n));\n  for (i=2; i <= limit; ++i) {\n    if\
    \ (n % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}", "{ \n \
    \   if(n <= 1) return false; \n    if(n == 2) return true; \n    long c = int(std.math.gcd(n,2L));\
    \ \n    for(long i = 2L; i <= c; i++) \n    if(n % i == 0) return false; \n  \
    \  return true; \n}", "{\n    bool (*f)(long) =\n        reciprocal.is_prime;\n\
    \    return (*f)(n);\n}\n</code>\nI then used the following to test whether the\
    \ prime function returned true or not:\n<code>", "{\n    return is_prime_fast(n)\
    \ == 1;\n}", "{\n    long d;\n    bool b;\n    if (isinf(n)) return false;\n \
    \   if (n < 2) return false;\n    if (n == 2) return true;\n    if (n & 1) return\
    \ false;\n    if (n < 3) return true;\n    if (n % 2 == 0) return false;\n   \
    \ for(d = 3; d * d <= n; d += 2) \n    {\n        if (n % d == 0)\n        {\n\
    \            b = false;\n            break;\n        }\n    }\n    return b;\n\
    }", "{\n    /* check if n is a power of 2 or is even */\n    if (0 == (n & 1))\
    \ \n    {\n        return false ;\n    }\n    int i = 2 ;\n    long sqrtn = std.math.sqr(n)\
    \ ;\n    \n    while (i <= sqrtn)\n    {\n        if (n % i == 0) \n        {\n\
    \            return false ;\n        }\n        i += 2 ;\n    }\n    return true\
    \ ;\n}", "{\n    if (n <= 1)\n        return true; // 0 and 1 are prime.\n   \
    \ \n    // Loop over the numbers 2 to sqrt(n)\n    long i = 2;\n    while (i <=\
    \ sqrt(n))\n    {\n        if (n % i == 0)\n            return false;\n      \
    \  ++i;\n    }\n    return true;\n}", "{\n  if (n<2L) \n  {\n    return true;\n\
    \  }", "{\n\tif (n < 2) return false;\n\tlong root = (long)std.math.sqrt(n);\n\
    \tstd.assert(root != 0L);\n\tfor(long i = 2L; i <= root; i++){\n\t\tif(n % i ==\
    \ 0) return false;\n\t}\n\treturn true;\n}", "{\n    return !std.math.isPrime(n);\n\
    }", "{\n    long limit = sqrt(n);\n    for(long i=1; i <= limit; ++i){\n     \
    \   if(n%i == 0) return false;\n    }\n    return true;\n}\n</code>\n<|/ a tags=primes,python\
    \ |>\n<| c |>\nThis should be the accepted answer.\n<|/ c |>\n<| a dscore=2 |>\n\
    This one will work, although I haven't done any performance tests (it might not\
    \ really matter for small numbers).\n<code>\ndef is_prime(n):\n    if n < 2:\n\
    \        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n\
    \        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0:\n\
    \            return False\n        i += 6\n    return True\n</code>\n<|/ a tags=primes,python\
    \ |>\n<| c |>\nI think your `while i * i <= n` loop should read `while i * i <=\
    \ n-1` and you should change the condition to `n < i` at some point.\n<|/ c |>\n\
    <| a |>\nI wrote a function that checks prime numbers. It works for me in Python\
    \ (version 3.6.8).\n<code>\ndef is_prime(n):\n    if n < 2:\n        return False\n\
    \    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n\
    \    limit = n / 2\n    while limit > 1:\n        if n % limit == 0:\n       \
    \     return False\n        limit -= 1\n    return True\n</code>\n<|/ a tags=primes,python\
    \ dscore=1 |>\n<| a tags=primes,python dscore=0 |>\n<code>\ndef is_prime(n):\n\
    \    if n<2:\n        return False\n    if n == 2:\n        return True\n    for\
    \ i in range(2,n//2+1):\n        if n%i==0:\n            return False\n    return\
    \ True\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThis is a concise solution that works\
    \ for me:\n<code>\ndef is_prime(n):\n    return all((n % i) == 0 for i in range(3,\
    \ int(n**0.5+1), 2))\n</code>\n<|/ a tags=primes,python |>\n<| a dscore=0 tags=primes,python\
    \ |>\n<code>\ndef is_prime(n):\n  n = list(str(n))\n  if len(n) == 1:\n    return\
    \ True\n  for i in range(3,len(n),2):\n    if n[i] == '0' and n[i-1] == '1':\n\
    \      return False\n  return True\n</code>\n<|/ a |>\n<| a tags=primes,python\
    \ |>\n<code>\ndef prime(n):\n    if n==2:\n        return True\n    elif n%2==0:\n\
    \        return False\n    else:\n        k=3\n        while(k<n):\n         \
    \   if n%k==0:\n                return False\n            k+=2\n        return\
    \ True\n</code>\n<|/ a dscore=0 |>\n", "{\n    static vector<int> primes;\n  \
    \  \n    if (primes.empty()) {\n        vector<int> sieve(n / 2 + (n%2 == 0),\
    \ 2);\n        for (int i = 0; i < sieve.size(); ++i)\n            primes.push_back(sieve[i]);\n\
    \    }", "{\n    /* Return true if n is prime, false otherwise */\n    /* First\
    \ test to see if a smaller even number is even */\n    long i;\n    if (n <= 3L)\n\
    \    {\n        /* Even numbers cannot be primes... */\n        return false;\n\
    \    }\n    /* Only even numbers divisible by 2 are prime. */\n    if (n % 2L\
    \ != 0L)\n    {\n        /* If n is not an even number less than 3, then it's\
    \ prime. */\n        return true;\n    }\n    /* If n is an even number, then\
    \ it's not a prime. */\n    return false;\n}", "{\n    /* make sure n is positive\
    \ */\n    if (n < 0) return false;\n    \n    /* make sure n is odd */\n    if\
    \ (n & 1) return false;", "{\n  // http://stackoverflow.com/questions/1957841/fast-prime-test\n\
    \  // http://stackoverflow.com/questions/1095764/fastest-way-to-test-if-a-number-is-prime-python",
  "{\n    if (n==2) return true;\n    else if (n==3) return true;\n    else if (n%2==0)\
    \ return false;\n    else if (n%3==0) return false;", "{\n    if (n <= 1) return\
    \ false;\n    if (n < 6) return true;\n    long d = 3L;\n    long r = n - 1;\n\
    \    \n    while (true)\n    {\n        if (r < 6) break;\n        if (std.pow(r,\
    \ d) == 2) return true;\n        d += 2;\n        r /= 2;\n    }\n    \n    return\
    \ false;\n}", "{\n    int i;\n    long limit;\n    if (n < 3L) \n    {\n     \
    \   return false;\n    }\n    if (n == 3L) \n    {\n        return true;\n   \
    \ }\n    limit = sqrt(n);\n    for (i = 3; i <= limit; i += 2L) \n    {\n    \
    \    if (n % i == 0L) \n        {\n            return false;\n        }\n    }\n\
    \    return true;\n}", "{\n  bool result = true;\n  long limit = std.sqrt(n);\n\
    \  for(i = 0l; i < limit; ++i) {\n    long a = 2*i;\n    if(std.fma(a,a,n) ==\
    \ n) \n      continue;\n    if(n % i == 0) result = false;\n  }\n  return result;\n\
    }\n/* Return true if n is a power of 2, and false otherwise.\n    >>> is_power_of_two(10L)\n\
    \    false\n    >>> is_power_of_two(12L)\n    true\n*/", "{\n    return (n ==\
    \ 1 || std.math.isPrime(n));\n}\n/// Check if a given number is even.", "{\n \
    \   int i;\n    bool flag = true;\n    if (n <= 1) return flag;\n    if (n <=\
    \ 3) return true;\n    \n    for (i = 2; i <= (int)sqrtN(n); i++) {\n        if\
    \ (n % i == 0) {\n            flag = false;\n            break;\n        }\n \
    \   }\n    return flag;\n}", "{\n    long limit = sqrt(n);\n    long i;\n    for(i=2;\
    \ i<limit; ++i)\n        if(n%i==0)\n            return false;\n    return true;\n\
    }", "{\n  long i = n, n_div_2;\n  // If n = 0, then is_prime returns false.\n\
    \  if (n == 0)\n    return false;\n  // If a is a perfect square, then n is not\
    \ prime. \n  if (is_perfect_square(n))\n    return false;\n  // If a is smaller\
    \ than 2, then n is not prime.\n  if (n < 2)\n    return false;\n  // If the number\
    \ if less than or equal to 3, then n is not prime.\n  if (n < 3)\n    return false;\n\
    \  // If a is even, then n is not prime.\n  if (is_even(n))\n    return false;\n\
    \  // Repeat steps 3 through 5 until a is greater than 6. \n  while (is_odd(n))\
    \ {\n    n_div_2 = n_div_2_of_3(n);\n    if (n_div_2 == n)\n      return false;\n\
    \    i = i * n_div_2;\n    n = n - n_div_2;\n  }\n  // At this point n is prime.\
    \ \n  return true;\n}", "{\n    int k;\n    bool prime;\n    \n    prime = (n\
    \ == 2);\n    \n    if (n == 0) \n        return prime;", "{\n    if (n == 1L)\
    \ return false;\n    long i = 2L;\n    while (i <= n) \n        if (std.math.isPrime(i)\
    \ == false) \n            return false;\n    i = 1L;\n    while (i <= n / 2L)\
    \ {\n        if (n % i == 0L) return false;\n        i += 2L;\n    }\n    return\
    \ true;\n}", "{\n    using std::sqrt;\n    bool flag = true;", "{\n\tint a;\n\t\
    if (n<2L)\n\t\treturn false;\n\ta=(int)sqrt(n);\n\tfor (int i=2; i <= a; i++)\n\
    \t{\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n/*\nReturn\
    \ true if a given number is even, and false otherwise.\n    >>> is_even(6L)\n\
    \    false\n    >>> is_even(61L)\n    true\n    >>> is_even(2L)\n    true\n  \
    \  \n*/", "{\n  // make sure n is positive\n  if (n >= 0)\n  {\n    // make sure\
    \ n is even\n    if (n%2 == 0) return true;\n    // make sure n is odd\n    else\
    \ if (!is_prime(n/2)) return false;\n    // make sure n is a power of two\n  \
    \  else if (((long)n)!=n) return false; ", "{\n    if (n < 2L) return false;\n\
    \    if (n % 2L == 0) return true;\n    if (n < 4L) return is_prime(3*n+3L);\n\
    \    if (n < 6L) return is_prime(9*n+3L);\n    long a = 6L*(n+1L-2)/3L;\n    long\
    \ b = 6L*(n+2L-1)/3L;\n    while (n%3L) {\n        if (a % 3L == 0 && b % 3L ==\
    \ 0) {\n            return true;\n        }\n        a = (a+b)/3L;\n        b\
    \ = 6L*(a+2L-1)/3L;\n    }\n    return false;\n}\n/*\nReturn the greatest common\
    \ denominator of two numbers, using Euclid's algorithm.\n*/\nlong gcd(long n1,\
    \ long n2) {\n    long n;\n    for (; n2 != 0; n2 = n1 %  n2) {\n        n1 =\
    \ n2;\n    }\n    return n1;\n}\n/*\nReturn the least common multiple of two numbers,\
    \ using Euclid's algorithm.\n*/\nlong lcm(long n1, long n2) {\n    long m = n1;\n\
    \    for (; n2 != 0; n2 = n1 %  n2) {\n        m *= n2;\n    }\n    return m;\n\
    }", "{\n    \n    bool prime = true;\n    long i = 2;\n    while(i*i <= n) \n\
    \    {\n        if(n%i == 0)\n            prime = false;\n        i += 1;\n  \
    \  }\n    return prime;\n}", "{\n    long i,x,y; \n    bool flag = false;\n  \
    \  y = n >> 1;\n    i = 2;\n    do \n    { \n        if (x == y) \n        { \n\
    \            flag = true;\n            break; \n        } \n        if (i % y\
    \ == 0) \n        { \n            flag = false; \n            break; \n      \
    \  } \n        i = i + 1; \n        x = y; \n        y = y << 1; \n    } while\
    \ (x != 1);\n    return flag; \n}", "{\n\tif (n == 1L)\n\t\treturn true;\n\tif\
    \ (n & 1L)\n\t\treturn false;\n\tfor (int i = 3; i*i <= n; i += 2)\n\t{\n\t\t\
    if (n % i == 0L)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n/*\nThis function\
    \ computes the sum of integers up to and including a given limit.\nThe algorithm\
    \ used is slightly modified E. W. Cody, the Sieve of Eratosthenes,\nin which the\
    \ consecutive prime numbers are removed from candidate primes\nin steps of two.\
    \ The prime numbers are also maintained in an array to \nenable fast calculation\
    \ of the sum of all the prime numbers up to \na certain limit.\n\tNote: This algorithm\
    \ uses no explicit looping.\n\tNote: The output array contains the sum of the\
    \ first limit elements, \n\tand will not contain any sum for elements greater\
    \ than the given limit.\n\t\n\t\n\t>>> compute_prime_sums(100L)\n\t[2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97]\n\t\n*/", "{\n\tif (n < 2L) return false; \n\tlong i = 2L;\n\tlong limit\
    \ = (1L<<(n/3L));\n\twhile (i <= limit)\n\t{\n\t\tif (n % i == 0L) return false;\
    \ \n\t\ti++;\n\t}\n\treturn true;\n}", "{\n    typedef long long ll;\n    ll i\
    \ = 2L;\n    ll p = nL;\n    for(; p * p <= n; ++p, ++i)\n        if(n % p ==\
    \ 0)\n            return false;\n    return p * p <= n;\n}", "{\n    long i, flag=1;\n\
    \    /* first step is to determine if the given number is a prime or not\n   \
    \   a. If it is divisible by 2 or 3, then it is not a prime\n      b. If it evenly\
    \ divides evenly by 2, the number is prime\n      c. If it evenly divides evenly\
    \ by 3, the number is prime\n      d. Otherwise it is not prime */\n    if(n==0)\n\
    \    {\n        return 0;\n    }\n    if(n%2==0)\n    {\n        flag=0;\n   \
    \ }\n    else if(n%3==0)\n    {\n        flag=0;\n    }\n    else if(n%2==0 &&\
    \ n%5!=0)\n    {\n        flag=0;\n    }\n    else if(n%3==0 && n%5!=0)\n    {\n\
    \        flag=0;\n    }\n    else if(n%5==0)\n    {\n        flag=0;\n    }\n\
    \    \n    for(i=3;i<=sqrt(n);i+=3)\n    {\n        if(n%i==0)\n        {\n  \
    \          flag=0;\n        }\n    }\n    \n    if(flag==1)\n    {\n        return\
    \ 0;\n    }\n    else\n    {\n        return 1;\n    }\n}", "{\n    long i, k;\n\
    \    if (n < 2)\n        return false;\n    if (n == 1)\n        return true;\n\
    \    if (n % 2 == 0)\n        return false;", "{\n\t\n\tif (n < 2L) return false;\
    \ \n\t\n\tlong sqrt_n = 1L << log_prime_long(sqrt_long(n));\n\t\n\tfor (long i\
    \ = 1L; i <= sqrt_n; i++)\n\t{\n\t\tif (n % i == 0L) return false;\n\t}\n\t\n\t\
    return true;\n}", "{ \n    std.random.seed(std.time());\n    if (n < 2L) return\
    \ true;\n    if (n < 5L) return false;\n    if (n < 7L) return false;\n    \n\
    \    long i = 2L;\n    long p = 6L;\n    while (((p * i) % n) != 1L) return false;\n\
    \    \n    while ((n % p) != 0L) return false;\n    \n    return true;\n}", "{\n\
    \    bool flag = false;\n    long i = 2;\n    while(i<n && flag==false)\n    {\n\
    \        if (n % i == 0) \n        {\n            flag = true;\n            break;\n\
    \        }\n        i += 2;\n    }\n    return flag;\n}\n</cell>\n<code language=.net-csharp>\n\
    // Define a function is_even_number() that takes a number n\n// and returns true\
    \ if n is an even number, and returns false \n// otherwise.\n// Use your function\
    \ to solve the below.", "{\n    long i = 2;\n    bool prime = true;\n    if (n\
    \ <= 1) return false;\n    \n    while (i <= sqrt(n)) {\n        if (!((n % i)\
    \ == 0L)) {\n            prime = false;\n            break;\n        }\n     \
    \   i++;\n    }\n    return prime;\n}\n#endif", "{\n    long limit = (1L<<32)/n;\n\
    \    for( long i=1L; i<limit; i+=2 )\n    {\n        if( n%i==0 ) return true;\n\
    \    }\n    return false;\n}", "{\n    if (n<2)\n        return false; \n    if\
    \ (n==2)\n        return true;\n    \n    /* n is odd\n       if n has even divisors\
    \ except for 1 and itself,\n       then n is prime.\n    */\n    if (is_even(n))\n\
    \        return is_odd(n-1L); \n    \n    /* n is odd\n       if n has even divisors\
    \ except for 1 and itself,\n       then n is prime.\n    */\n    if (!is_even(n))\n\
    \        return false; \n    \n    /* n is prime\n       if n is even and has\
    \ no divisors other than 1 and itself,\n       then n is prime.\n    */\n    if\
    \ (!is_odd(n-1L))\n        return true; \n    \n    /* n is prime\n       if n\
    \ is even and has no divisors other than 1 and itself,\n       then n is prime.\n\
    \    */\n    if (!is_odd(n-1L))\n        return true; \n    \n    /* n is prime\n\
    \       if n is odd and has no divisors other than 1 and itself,\n       then\
    \ n is prime.\n    */\n    return is_odd(n-1L);\n}", "{\n  return std.math.is_prime(n);\n\
    }", "{\n\tif (n <= 3) return true;\n\tif (n > 5) return false;", "{\n  // Sieve\
    \ of Eratosthenes - http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n  // \"\
    Sieve of Eratosthenes\" was the first prime number SAC hand-calculated\n  // by\
    \ Eratosthenes in 1972\n  if (n == 1) {\n    return true;\n  }", "{\n\treturn\
    \ is_prime_impl(&std.intf, &n, 1);\n}\n/*\nReturn true if a given number is composite,\
    \ and false otherwise.\n    >>> is_composite(6L)\n    false\n    >>> is_composite(101L)\n\
    \    false\n    >>> is_composite(11L)\n    true\n    >>> is_composite(13441L)\n\
    \    false\n    >>> is_composite(61L)\n    true\n    >>> is_composite(4L)\n  \
    \  true\n    >>> is_composite(1L)\n    true\n    \n*/", "{\n    if (n <= 3) return\
    \ true;\n    // Sieve of Eratosthenes in O(sqrt(n)) time.\n    long long int n_sq\
    \ = n * n;\n    bool found[n_sq];\n    for (int i = 1; i <= n_sq; i++) {\n   \
    \     found[i] = false;\n    }\n    long long int m = 6LL;\n    long long int\
    \ m2 = m - 1;\n    long long int k = n + 1;\n    long long int k2 = k + 1;\n \
    \   while (k <= m2 && k2 <= n_sq) {\n        if (found[(int) ((k2 - m) * (k2 -\
    \ m) / k)]) {\n            return false;\n        }\n        found[k] = true;\n\
    \        m++;\n        k++;\n        k2++;\n    }\n    return true;\n}\n</code>\n\
    <|/ a tags=c++ |>\n<| c |>\nWow, thanks. I was able to get it working in O(sqrt(n))\
    \ time with my original algorithm.\n<|/ c |>\n<| a |>\nHere's my implementation\
    \ of the Sieve of Eratosthenes using std::vector instead of an array. \n<code>\n\
    #include <iostream>\n#include <vector>", "{\n    long i = 2;\n    long c = n;\n\
    \    if (c < 1)\n        return false;\n    while (i < c) \n    {\n        if\
    \ (n % i == 0)\n            return false;\n        i++;\n    }\n    return true;\n\
    }\n</code>\n<|/ a tags=c++,primes |>\n<| a dscore=4 |>\nHere's an O(logn) algorithm\
    \ for prime numbers\n<code>", "{\n    if (n < 2)\n    {\n        return false;\n\
    \    }\n    if (n == 2)\n    {\n        return true;\n    }\n    for (long i =\
    \ 5; i <= sqrt$2; i += 2)\n    {\n        if (n % i == 0)\n        {\n       \
    \     return false;\n        }\n    }\n    return true;\n}", "{\n    if(n<2L)\
    \ return true; // not prime\n    if(n<3L) return true;\n    \n    long m=2L;\n\
    \    for(;m<n;m+=2L) if(m%n==0) return false;\n    return true;\n}\n</code>\n\
    <|/ a dscore=3 tags=primes,c++ |>\n<| a tags=primes,c++ |>\nFor fun, I'll provide\
    \ my own prime number test function. The trick is to find out what happens when\
    \ you double the dividing number n by two. For my test cases, n=3. This means\
    \ we double n by 3 before checking whether it is prime or not. \n<code>\n#include\
    \ <iostream>", "{\n    long i;\n    bool result = true;\n    if (n <= 1) return\
    \ false;\n    for (i = 2; i <= sqrt(n); ++i)\n    {\n        if (n % i == 0) result\
    \ = false;\n    }\n    return result;\n}\n/*\nReturn true if given number is prime,\
    \ and false otherwise.\n*/", "{\n  // Fast method for testing divisibility by\
    \ prime numbers (see \n  // http://primes.utm.edu/lists/small/millions/ or \n\
    \  // http://primes.utm.edu/lists/small/millions/odd.c).\n  if (n%2 == 0) {\n\
    \    do {\n      if (n%10 == 1) return false;\n      n = (n/10)%10;\n    } while\
    \ (n%10 == 0);\n    return true;\n  }\n  // Slow method for testing divisibility\
    \ by some powers of 2.\n  // http://blogs.agi.com/insight3d/index.php/2008/05/01/what-numbers-are-not-prime-or-that-are-not-prime/\n\
    \  // NOTE: This method returns false for some larger values of n.\n  int j =\
    \ 1;\n  for (int i = 3; i*j <= n; j = j + 2) {\n    if (n%(i*j) == 0) return false;\n\
    \  }\n  return true;\n}", "{\n    struct prime_number_s prime;\n    bool result\
    \ = false;\n    \n    std.math.sqrt_root(n, &prime.sqrt);\n    \n    struct prime_number_s\
    \ *p = get_prime_number_list(&prime.sqrt);\n    \n    while(p != NULL){\n    \
    \    if(prime_number_is(p, n) == true){\n            result = true;\n        \
    \    break;\n        }\n        p = p->next;\n    }\n    \n    return result;\n\
    }", "{\n  return std.math.isPowerOfTwo(n) && ((unsigned long)n) == (unsigned long)n;\n\
    }\n\"\"\")", "{\n    long i;\n    long max = (long) sqrt(n);\n    if (n >= 2L)\
    \ {\n        for (i = 2; i <= max; i+=2) {\n            if (n%i == 0) {\n    \
    \            return false;\n            }\n        }\n        return true;\n \
    \   }\n    return false;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThanks for your\
    \ answer! I like the idea of using prime-factorization, but I don't understand\
    \ why your function returns true for `is_prime(101L)`. I think it shouldn't. Any\
    \ ideas why?\n<|/ c |>\n<| c |>\nOops, sorry. It returns `true` for primes up\
    \ to 101. I should really test against 2.\n<|/ c |>\n<| c |>\nThe idea is that\
    \ you only have to test odd numbers, because it's easy to prove that the numbers\
    \ 2,3,...,N aren't primes. So the numbers that are prime up to 101 are not tested\
    \ yet. After testing 2,3,5,7, and 11, the function returns `false`. Then it has\
    \ to check the next odd number, which can only be 4,6,9,12, or 13, so it returns\
    \ `true`.\n<|/ c |>\n<| c |>\nActually, the function returns false for prime up\
    \ to 104, which is the square root of 104.\n<|/ c |>\n<| c |>\nI ran this program\
    \ on my computer, and i got different output. Why is that?\n<|/ c |>\n<| a |>\n\
    <code>"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
