language: d
name: HumanEval_139_special_factorial
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong result = 1;\n\tlong i;\n\tfor(i = 1; i <= n; i++)\n\t\tresult *= i;\n\t\
    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n \
    \   assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n   \
    \ assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqqx9k6cp.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpqqx9k6cp.__unittest_L24_C1() [0x427a6a]

    ??:? void tmpqqx9k6cp.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\nunittest\n{\n    alias candidate = special_factorial;\n\n\
    \    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n  \
    \  assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqoapbyy4.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqoapbyy4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n == 1L) \n    {\n        return 1L;\n    }\n    if (n == 2L) \n    {\n\
    \        return 6L;\n    }\n    if (n == 3L) \n    {\n        return 24L;\n  \
    \  }\n    if (n >= 4L) \n    {\n        return special_factorial(n - 1L) * special_factorial(n\
    \ - 2L) * special_factorial(n - 3L);\n    }\n    return 0L;\n}\nunittest\n{\n\
    \    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkvle2hgc.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x427db5]

    ??:? void tmpkvle2hgc.__unittest_L36_C1() [0x427aae]

    ??:? void tmpkvle2hgc.__modtest() [0x427b34]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42badb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a96e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a945]

    ??:? runModuleUnitTests [0x42b8b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428204]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    std.typecons.long2long int_caster = std.typecons.long2long(std.math.itoa(n));\n\
    \    return std.factorial2(brazilian_factorial(int_caster));\n}\nunittest\n{\n\
    \    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyxn2nfhm.d(18): Error: undefined identifier `long2long` in module
    `std.typecons`

    /tmp/tmpyxn2nfhm.d(18): Error: undefined identifier `long2long` in module `std.typecons`

    /tmp/tmpyxn2nfhm.d(19): Error: undefined identifier `factorial2` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyxn2nfhm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long product = 1;\n    long temp;\n    for(int i = 0; i < n; ++i)\n    {\n\
    \        temp = 1;\n        for(int j = 1; j <= i; ++j)\n        {\n         \
    \   temp *= j;\n        }\n        product *= temp;\n    }\n    return product;\n\
    }\n</code>\n<|/ a |>\n<| a tags=factorial,biginteger,recursion,java dscore=0 |>\n\
    I did it without using BigIntegers and just using multiplication and division.\
    \ \n<code>\n  public long factorial(long n) {\n        if (n == 0) {\n       \
    \     return 1;\n        }\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe0jcs0va.d(31): Error: declaration expected, not `<`

    /tmp/tmpe0jcs0va.d(39): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe0jcs0va.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long f = factorial(n);\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0svp48rp.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0svp48rp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    long result = n;\n    while (n >= 1) {\n       \
    \ factorial *= n;\n        result --;\n        n --;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp153_ksiv.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmp153_ksiv.__unittest_L27_C1() [0x427a62]

    ??:? void tmp153_ksiv.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fac = 1;\n    for(long i = 2; i <= n; ++i) {\n        fac *= i;\n  \
    \  }\n    return fac;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph2pw28kz.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmph2pw28kz.__unittest_L24_C1() [0x427a66]

    ??:? void tmph2pw28kz.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tif(n == 0)\n\t\treturn 1;\n\tif(n == 1)\n\t\treturn n;\n\tif(n == 2)\n\t\treturn\
    \ 1;\n\tif(n == 3)\n\t\treturn 1;\n\tif(n == 4)\n\t\treturn 2;\n\tif(n == 5)\n\
    \t\treturn 6;\n\tif(n == 6)\n\t\treturn 24;\n\tif(n == 7)\n\t\treturn 120;\n\t\
    if(n == 8)\n\t\treturn 720;\n\tif(n == 9)\n\t\treturn 5040;\n\tif(n == 10)\n\t\
    \treturn 40320;\n\tif(n == 11)\n\t\treturn 362880;\n\tif(n == 12)\n\t\treturn\
    \ 3628800L;\n\tif(n == 13)\n\t\treturn 39916800L;\n\tif(n == 14)\n\t\treturn 479001600L;\n\
    \tif(n == 15)\n\t\treturn 6227020800L;\n\tif(n == 16)\n\t\treturn 87178291200L;\n\
    \tif(n == 17)\n\t\treturn 1307674368000L;\n\tif(n == 18)\n\t\treturn 20922789888000L;\n\
    \tif(n == 19)\n\t\treturn 355687428096000L;\n\tif(n == 20)\n\t\treturn 6402373705728000L;\n\
    \tif(n == 21)\n\t\treturn 121645100408832000L;\n\tif(n == 22)\n\t\treturn 243290200817664000L;\n\
    \tif(n == 23)\n\t\treturn 51090942171709440000L;\n\tif(n == 24)\n\t\treturn 1124000727777607680000L;\n\
    \tif(n == 25)\n\t\treturn 25852016738884976640000L;\n\tif(n == 26)\n\t\treturn\
    \ 620448401733239439360000L;\n\tif(n == 27)\n\t\treturn 15511210043330985984000000L;\n\
    \tif(n == 28)\n\t\treturn 403291461126605635584000000L;\n\tif(n == 29)\n\t\treturn\
    \ 10888869450418352160768000000L;\n\tif(n == 30)\n\t\treturn 304888344611713860501504000000L;\n\
    \tif(n == 31)\n\t\treturn 8841761993739701954543616000000L;\n\tif(n == 32)\n\t\
    \treturn 265252859812191058636308480000000L;\n\tif(n == 33)\n\t\treturn 68719476736203025\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3s_r9v7t.d(65): Error: integer overflow

    /tmp/tmp3s_r9v7t.d(67): Error: integer overflow

    /tmp/tmp3s_r9v7t.d(69): Error: integer overflow

    /tmp/tmp3s_r9v7t.d(71): Error: integer overflow

    /tmp/tmp3s_r9v7t.d(73): Error: integer overflow

    /tmp/tmp3s_r9v7t.d(75): Error: integer overflow

    /tmp/tmp3s_r9v7t.d(77): Error: integer overflow

    /tmp/tmp3s_r9v7t.d(79): Error: integer overflow

    /tmp/tmp3s_r9v7t.d(81): Error: integer overflow

    /tmp/tmp3s_r9v7t.d(83): Error: integer overflow

    /tmp/tmp3s_r9v7t.d(86): Error: found `unittest` when expecting `;` following `return`
    statement

    /tmp/tmp3s_r9v7t.d(95): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3s_r9v7t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tif(n<=1L)\n\t\treturn 1L;\n\telse if(n%2L==0L)\n\t\treturn special_factorial(n/2L)*((1L)*(n-1L));\n\
    \telse if(n%3L==0L)\n\t\treturn special_factorial((n-1)/2L)*((1L)*((n-1)+1L)*(n-2L));\n\
    \telse\n\t\treturn special_factorial((n-1)/2L)*((1L)*(n-2L)*(n-3L));\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphlh2q675.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e0d]

    ??:? void tmphlh2q675.__unittest_L27_C1() [0x427b0a]

    ??:? void tmphlh2q675.__modtest() [0x427b90]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb33]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9c6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb59]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430008]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fae5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a99d]

    ??:? runModuleUnitTests [0x42b909]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42825c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    for (long i = 1L; i <= n; i++) {\n        result *=\
    \ i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg4s43wza.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpg4s43wza.__unittest_L24_C1() [0x427a62]

    ??:? void tmpg4s43wza.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong temp = 1;\nunittest\n{\n    alias candidate = special_factorial;\n\n  \
    \  assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L)\
    \ == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzmvrlrnf.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzmvrlrnf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long product = 1L;\n    long i;\n    \n    for(i = 0; i < n; i++)\n    {\n\
    \        product *= i;\n    }\n    return product;\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpntz3iu0h.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpntz3iu0h.__unittest_L27_C1() [0x427a6a]

    ??:? void tmpntz3iu0h.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long f = 1;\n    for(long i = 2; i <= n; i++) \n    {\n        f *= i;\n\
    \    }\n    return f;\n}\n/*\nThis function receives an integer as input and returns\
    \ the \nnumber with 3 digits after the decimal point.\n*/\nlong three_decimal_number_to_text(long\
    \ n) \n{\n    char string[15];\n    string[0] = '\\0';\n    long f = n;\n    string[1]\
    \ = std.digits[(int)((f / 1000000.0) % 10)];\n    string[2] = std.digits[(int)((f\
    \ / 100000.0) % 10)];\n    string[3] = std.digits[(int)((f / 1000.0) % 10)];\n\
    \    string[4] = std.digits[(int)((f / 100.0) % 10)];\n    string[5] = std.digits[(int)((f\
    \ / 10.0) % 10)];\n    string[6] = std.digits[(int)((f / 1.0) % 10)];\n    string[7]\
    \ = std.digits[(int)((f / 1.0L) % 10)];\n    string[8] = std.digits[(int)((f /\
    \ 1.0L) / 100) % 10];\n    string[9] = std.digits[(int)((f / 1.0L) / 10) % 10];\n\
    \    string[10] = std.digits[(int)((f / 1.0L) % 10)];\n    string[11] = std.digits[(int)((f\
    \ / 1.0L) / 1)];\n    string[12] = std.digits[(int)((f / 1.0L) / 1.0L) % 10];\n\
    \    string[13] = std.digits[(int)((f / 1.0L) / 1.0L) / 100 % 10];\n    string[14]\
    \ = '\\0';\n    return string[12];\n}\n/*\nThis function receives an integer as\
    \ input and returns the number with 2 digits after \nthe decimal point.\n*/\n\
    long two_decimal_number_to_text(long n) \n{\n    char string[13];\n    string[0]\
    \ = '\\0';\n    long f = n;\n    string[1] = std.digits[(int)((f / 1000000.0)\
    \ % 10)];\n    string[2] = std.digits[(int)((f / 100000.0) % 10)];\n    string[3]\
    \ = std.digits[(int)((f / 1000.0) % 10)];\n    string[4] = std.digits[(int)((f\
    \ / 100.0) % 10)];\n    string[5] = std.digits[(int)((f / 10.0) % 10)];\n    string[6]\
    \ = std.digits[(int)((f / 1.0) % 10)];\n    string[7] = std.digits[(int)((f /\
    \ 1.0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppnekkdmi.d(31): Deprecation: instead of C-style syntax, use D-style
    syntax `char[15] string`

    /tmp/tmppnekkdmi.d(34): Error: C style cast illegal, use `cast(int)(f / 1.00000e+06
    % 10)`

    /tmp/tmppnekkdmi.d(35): Error: C style cast illegal, use `cast(int)(f / 100000.
    % 10)`

    /tmp/tmppnekkdmi.d(36): Error: C style cast illegal, use `cast(int)(f / 1000.00
    % 10)`

    /tmp/tmppnekkdmi.d(37): Error: C style cast illegal, use `cast(int)(f / 100.000
    % 10)`

    /tmp/tmppnekkdmi.d(38): Error: C style cast illegal, use `cast(int)(f / 10.0000
    % 10)`

    /tmp/tmppnekkdmi.d(39): Error: C style cast illegal, use `cast(int)(f / 1.00000
    % 10)`

    /tmp/tmppnekkdmi.d(40): Error: C style cast illegal, use `cast(int)(f / 1.00000L
    % 10)`

    /tmp/tmppnekkdmi.d(41): Error: C style cast illegal, use `cast(int)(f / 1.00000L
    / 100)`

    /tmp/tmppnekkdmi.d(42): Error: C style cast illegal, use `cast(int)(f / 1.00000L
    / 10)`

    /tmp/tmppnekkdmi.d(43): Error: C style cast illegal, use `cast(int)(f / 1.00000L
    % 10)`

    /tmp/tmppnekkdmi.d(44): Error: C style cast '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    \n    if(n==0) return 1L;\n    long factorial=1L;\n    while(n > 1L) {\n\
    \        factorial*=n--;\n    }\n    return factorial;\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpq_1lhkno.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpq_1lhkno.__unittest_L26_C1() [0x427a6a]

    ??:? void tmpq_1lhkno.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tint result;\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphwq66t00.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphwq66t00.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return factorial(n) * (n-1) * (n-2) * (n-3) * (n-4) * (n-5) * (n-6) * (n-7);\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz0osj42r.d(18): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz0osj42r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long ret = 1;\n  for(long i=1; i<= n; i++){\n    ret *= i;\n  }\n  return ret;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpaarap915.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpaarap915.__unittest_L24_C1() [0x427a62]

    ??:? void tmpaarap915.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long sum = 1;\n    for(long i = 1; i < n; ++i)\n    {\n        sum *= i;\n\
    \    }\n    return sum;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0asjtgqu.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmp0asjtgqu.__unittest_L25_C1() [0x427a62]

    ??:? void tmp0asjtgqu.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    for (long i = 1; i <=n; i++) \n        fact = fact*i;\n\
    \    return fact;\n}\n/*\nThe Brazilian tax rate is defined as:\n    brazilian_tax_rate(n)\
    \ = n / 100 * 5.6\n    where n is an integer greater than 0\nunittest\n{\n   \
    \ alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1kny_x8g.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1kny_x8g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long i;\n  \n  for(i = 1L; i <= n; i++)\n    n /= i;\n  \n  return n;\n}\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmps7k0neek.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmps7k0neek.__unittest_L25_C1() [0x427a6a]

    ??:? void tmps7k0neek.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong result = 1L;\nunittest\n{\n    alias candidate = special_factorial;\n\n\
    \    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n  \
    \  assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqve876w_.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqve876w_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong factorial = 1;\n\tif(n == 0)\n\t{\n\t\treturn factorial;\n\t}\n\tif(n ==\
    \ 1)\n\t{\n\t\treturn factorial;\n\t}\n\tif(n == 2)\n\t{\n\t\treturn factorial\
    \ * 2;\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfactorial *= i;\n\t}\n\t\
    return factorial;\n}\n/*\n    Function for checking if the current date is the\
    \ special date.\nunittest\n{\n    alias candidate = special_factorial;\n\n   \
    \ assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L)\
    \ == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw1zjhgl6.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw1zjhgl6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long r = 1;\n  long i;\n  for (i = 1; i <= n; i++) r *= i;\n  return r;\n}\n\
    /*\n  The function takes two integers as parameters and should return true if\n\
    \  their factorials are equal, and false otherwise. For example:\n  >>> std.equal_factorials(1L,\
    \ 4L)\n  True\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn55u5s6h.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn55u5s6h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    while (n > 0)\n    {\n        result *= n--;\n    }\n\
    \    return result;\n}\n/*\nThe factorial of a non-negative integer is defined\
    \ as the product of the integers from 1 to it.\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphhh44zo8.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphhh44zo8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    \n    while(n > 0)\n    {\n        factorial *=\
    \ n;\n        n --;\n    }\n    return factorial;\n}\n/*\nThe Fibonacci sequence\
    \ is defined as:\n    fib(0) = 0\n    fib(1) = 1\n    fib(n) = fib(n-1) + fib(n-2)\n\
    \    \n    For example:\n    >>> special_fibonacci(4L)\n    55L\n*/\nlong special_fibonacci(long\
    \ n) \n{\n    long fib = 0;\n    \n    while(n > 0)\n    {\n        fib += (n\
    \ - 1) + (n - 2);\n        n --;\n    }\n    return fib;\n}\n/*\nThe Naive method\
    \ returns the factorial of an integer using recursion.\n    \n    For example:\n\
    \    >>> factorial(4L)\n    24L\n*/\nlong factorial(long n) \n{\n    return factorial_recursive(n);\n\
    }\n/*\nThe Naive recursive method returns the factorial of an integer using recursion.\n\
    \    \n    For example:\n    >>> factorial_recursive(4L)\n    24L\n*/\nlong factorial_recursive(long\
    \ n) \n{\n    if (n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n\
    \        return n * factorial_recursive(n - 1);\n    }\n}\n/*\nThe Fastest method\
    \ returns the factorial of an integer using iteration.\n    \n    For example:\n\
    \    >>> factorial(4L)\n    24L\n*/\nlong factorial_fast(long n) \n{\n    long\
    \ factorial = 1;\n    \n    for (long i = 0; i < n; i++ )\n    {\n        factorial\
    \ *= i;\n    }\n    return factorial;\n}\n/*\nThe Fastest recursive method returns\
    \ the factorial of an integer using iteration.\n    \n    For example:\n    >>>\
    \ factorial_fast(4L)\n    24L\n*/\nlong factorial_faster_recursive(long n) \n\
    {\n    long factorial = 1;\n    \n    for (long i = 2; i <= n; i++ )\n    {\n\
    \        factorial *= i;\n    }\n    return factorial;\n}\n/*\nThe Sieve of Eratosthenes\
    \ is a method to check if a number is prime. It works as follows:\n    \n    Firstly\
    \ all prime numbers are put into a list:\n    \n        prime_list = [2]\n   \
    \ \n    Then, while the number 2 is in the list:\n    \n        2 is divided by\
    \ all the remaining numbers in the list to see if they are prime\n        if they\
    \ are not prime, then 2 is not in the list and all prime numbers are removed\n\
    \        \nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4alrzec6.d(111): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4alrzec6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tif(n<=0L)\n\t{\n\t\treturn 1L;\n\t}\n\treturn (n*special_factorial(n-1L));\n\
    }\n/*\nThe factorial of non-positive integers is defined as 1.\nunittest\n{\n\
    \    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp31lpb788.d(24): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp31lpb788.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return factorial(n) * (n - 1);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuyz2p4ru.d(18): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuyz2p4ru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long fact = 1;\n  if(n==0)\n    return 1;\n  else\n    for(i=1; i<=n; i++){\n\
    \      fact*=i;\n    }\n  return fact;\n}\n/*\nThe Brazilian permutations are\
    \ defined as:\n    brazilian_permutations(n) = n! / n!! (n-1)!! ... (n-n)!!\n\
    \    where n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n  \
    \  assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L)\
    \ == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9tedb3ga.d(27): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9tedb3ga.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \   if(n==0L)\n      return 1L;\n   long ans = 1L;\n   for (long i = 2L; i< n+1L;\
    \ i++)\n      ans *= iL;\n   return ans;\n}\n/*\nThe Brazilian factorial is defined\
    \ as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where\
    \ n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyq11pkk8.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyq11pkk8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    \n    if (n == 1)\n        return 1;\n    else if (n == 0)\n        return\
    \ 0;\n    else if (n >= 2 && n <= 14)\n        return std.factorial(n);\n    else\n\
    \        return (n * special_factorial(n-1)) * std.factorial(n-2);\n}\n/*\nThe\
    \ factorial of an integer can be defined as:\n    factorial(n) = n x factorial(n-1)\
    \ if n > 0\n    factorial(0) = 1\n    factorial(1) = 1\n    \n    For example:\n\
    \    >>> factorial(4)\n    24\n*/\nlong factorial(long n) \n{\n    if (n == 0)\n\
    \        return 1;\n    else if (n == 1)\n        return 1;\n    else\n      \
    \  return n * factorial(n-1);\n}\n/*\nThe logarithm of a number a to the base\
    \ b is:\n    logarithm(a, b) = log(a) / log(b)\n    \n    For example:\n    >>>\
    \ log10(10L) << 1 == 1\n    True\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpytnrydzm.d(47): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpytnrydzm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    std.typecons.unsafeNew(result);\n    \n    int pow = 1;\n    \n    int factorial\
    \ = 1;\n    \n    while (n > 1) {\n        factorial *= n;\n        n -= 1;\n\
    \    }\n    \n    while (pow != n) {\n        factorial *= pow;\n        pow +=\
    \ 1;\n    }\n    \n    result = factorial;\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnl_hsxha.d(18): Error: undefined identifier `unsafeNew` in module
    `std.typecons`

    /tmp/tmpnl_hsxha.d(34): Error: undefined identifier `result`

    /tmp/tmpnl_hsxha.d(36): Error: undefined identifier `result`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnl_hsxha.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n <= 1L) return 1L;\n    else return factorial(n);\n}\nunittest\n{\n\
    \    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptb2eokdi.d(19): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptb2eokdi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long ret = 1;\n    for (long i = 0; i < n; i++) {\n        \n        ret\
    \ *= i;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp72jdp8v9.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmp72jdp8v9.__unittest_L25_C1() [0x427a66]

    ??:? void tmp72jdp8v9.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    \n    if(n == 0)\n    {\n        factorial = 1;\n\
    \    }\n    else\n    {\n        for(long i = 0; i < n; i++)\n        {\n    \
    \        factorial *= i;\n        }\n    }\nunittest\n{\n    alias candidate =\
    \ special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2mkx5pem.d(31): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2mkx5pem.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong f = 1L;\n\tfor (int i = 2; i <= n; i++) {\n\t\tf *= i;\n\t}\n\treturn f;\n\
    }\n/*\n    Compute a factorial of a given number. \n    The function receives\
    \ two parameters: \n    1) the number that will be factorialized.\n    2) the\
    \ variable that contains the factorial value.\n    The function will return 1\
    \ if the factorial of the input number is equal to \n    1 or else it will return\
    \ 0.\n*/\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkcloqonb.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpkcloqonb.__unittest_L32_C1() [0x427a66]

    ??:? void tmpkcloqonb.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \t/*\n\tThis function returns the factorial of a number n which is\n\ta positive\
    \ integer but which may overflow if the number is\n\tgreater than 20! since the\
    \ factorial of 20! is greater than \n\tLong.maxValue(). Using std.math.factorial\
    \ will handle \n\toverflow, while std.big.Big.factorial will not. To handle \n\
    \toverflow with std.big.Big.factorial, an explicit overflow check\n\tis needed\
    \ which should be the case when the factorial of \n\tthe number is greater than\
    \ 20!\n\t*/\n\treturn (n > 20L) ? std.big.Big.factorial(n) : std.math.factorial(n);\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdrk02wzy.d(28): Error: undefined identifier `big` in package `std`

    /tmp/tmpdrk02wzy.d(28): Error: undefined identifier `factorial` in module `std.math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdrk02wzy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \treturn factorial(n);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjx7s4k1o.d(18): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjx7s4k1o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n <= 1L) return 1L;\n    else return std.math.factorial(n);\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp13018au5.d(19): Error: undefined identifier `factorial` in module
    `std.math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp13018au5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long p = 1;\n    while (n>1){\n        if (n % 2 == 1) p = p*(n-1L);\n  \
    \      n = n/2;\n    }\n    return p;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgh0l4m7f.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d8d]

    ??:? void tmpgh0l4m7f.__unittest_L25_C1() [0x427a86]

    ??:? void tmpgh0l4m7f.__modtest() [0x427b0c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bab3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a946]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fad9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff88]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a91d]

    ??:? runModuleUnitTests [0x42b889]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1L;\n    \n    for(long i = 1L; i <= n; ++i)\n    {\n       \
    \ fact = fact * (iL);\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_x3c_zfs.d(22): Error: undefined identifier `iL`, did you mean
    variable `i`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_x3c_zfs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\nunittest\n{\n    alias candidate = special_factorial;\n\n\
    \    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n  \
    \  assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqoapbyy4.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqoapbyy4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1L;\n    long i = 1L;\n    \n    while (n>1) {\n       \
    \ factorial *= i;\n        n--;\n        i++;\n    }\n    factorial *= i;\n  \
    \  return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjiz0cj3b.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmpjiz0cj3b.__unittest_L29_C1() [0x427a72]

    ??:? void tmpjiz0cj3b.__modtest() [0x427af8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long fact = 1L;\n  for (long i = 1; i <= n; i++){\n    fact *= i;\n  }\n  return\
    \ fact;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is a great answer, but I\
    \ think they want a recursive function. I don't know what they mean by \"tail-recursive\"\
    , but I think this is more an optimization technique than something they mean\
    \ by \"recursive\".\n<|/ c |>\n<| c |>\nTail recursion is a specific form of recursion\
    \ that does not allow a caller to change what parameters are used by the function\
    \ itself. It's just a way of saying that the function will perform its own work\
    \ on the input without storing the output to a variable for later use.\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9tbs06ci.d(24): Error: declaration expected, not `<`

    /tmp/tmp9tbs06ci.d(27): Error: unterminated character constant

    /tmp/tmp9tbs06ci.d(30): Error: unterminated character constant

    /tmp/tmp9tbs06ci.d(35): Error: declaration expected, not `assert`

    /tmp/tmp9tbs06ci.d(36): Error: declaration expected, not `assert`

    /tmp/tmp9tbs06ci.d(37): Error: declaration expected, not `assert`

    /tmp/tmp9tbs06ci.d(38): Error: declaration expected, not `assert`

    /tmp/tmp9tbs06ci.d(39): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9tbs06ci.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong factor = 1;\n\twhile (n>0) {\n\t\tfactor = factor * (n--);\n\t}\n\treturn\
    \ factor;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphzlphzv1.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmphzlphzv1.__unittest_L24_C1() [0x427a5a]

    ??:? void tmphzlphzv1.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 0;\n    \n    for(long i = 1; i <= n; i++)\n    {\n       \
    \ result = result * (i % 2 == 0 ? i : 1);\n    }\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptad3tqn4.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d85]

    ??:? void tmptad3tqn4.__unittest_L27_C1() [0x427a82]

    ??:? void tmptad3tqn4.__modtest() [0x427b08]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a93e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fad1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa5d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a915]

    ??:? runModuleUnitTests [0x42b881]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281d4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    int i;\n    \n    long fact = 1;\n    for (i=n; i > 0; i--)\n        fact\
    \ *= i;\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvuut7c1f.d(23): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvuut7c1f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \   if(n<0L) return 0L;\n   if(n==0L) return 1L;\n   if(n==1L) return 1L;\n  \
    \ return (n*special_factorial(n-1L));\n}\n/*\nThe factorial is defined as:\n \
    \   factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplucbd5gj.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplucbd5gj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long f = 1;\n  while (n > 0)\n  {\n    f *= (n - 1);\n    n--;\n  }\n  return\
    \ f;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdvea0_tp.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpdvea0_tp.__unittest_L26_C1() [0x427a5e]

    ??:? void tmpdvea0_tp.__modtest() [0x427ae4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong long factorial = 1;\n\t\n\twhile(n!=0){\n\t\tfactorial *= (n--);\n\t}\n\
    \t\n\treturn factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpav9e7m1y.d(18): Error: use `long` for a 64 bit integer instead
    of `long long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpav9e7m1y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    int i;\n    long f = 0;\n    long fact = 1;\n    long f = n;\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8d8ewehw.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8d8ewehw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1L;\n    while (n > 2L) \n    { \n        factorial *= n--;\
    \ \n    } \n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdgmfog1c.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpdgmfog1c.__unittest_L25_C1() [0x427a5a]

    ??:? void tmpdgmfog1c.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long res = 1L;\n    for (long i = 1L; i <= n; ++i) {\n        res *= i;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpod1l9lt4.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpod1l9lt4.__unittest_L24_C1() [0x427a62]

    ??:? void tmpod1l9lt4.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    long fact = 1;\nfor (long i = 2; i <= n; ++i)\n  fact *= i;\n  return fact;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn3bj1bcx.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpn3bj1bcx.__unittest_L23_C1() [0x427a66]

    ??:? void tmpn3bj1bcx.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n <= 0) \n    {\n        return 1;\n    } \n    else\n    {\n       \
    \ long i;\n        \n        for (i = 0; i < n; i++) \n        {\n           \
    \ n = n * i;\n        }\n        return n;\n    }\n}\n/*\nThis function will receive\
    \ a number as input and return the factorial of\nthis number.\nunittest\n{\n \
    \   alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxklfi9wb.d(33): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxklfi9wb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long result = 1L;\n  while (n > 0L)\n  {\n      result = result * (n % 2L)\
    \ * (n / 2L);\n      n = n / 2L;\n  }\n  return result;\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0c8v3e6s.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d95]

    ??:? void tmp0c8v3e6s.__unittest_L26_C1() [0x427a8e]

    ??:? void tmp0c8v3e6s.__modtest() [0x427b14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42babb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a94e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff90]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a925]

    ??:? runModuleUnitTests [0x42b891]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpitn09g2h.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpitn09g2h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n == 0)\n        return 1;\n    if (n == 1)\n        return n;\n    if\
    \ (n == 2)\n        return 1;\n    if (n % 2 != 0)\n        return special_factorial(n\
    \ - 1) * n;\n    long f = special_factorial(n - 1);\n    return f * (f-1);\n}\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_msty7bs.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dad]

    ??:? void tmp_msty7bs.__unittest_L29_C1() [0x427aaa]

    ??:? void tmp_msty7bs.__modtest() [0x427b30]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bad3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a966]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faf9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffa8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa85]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a93d]

    ??:? runModuleUnitTests [0x42b8a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong result = 1;\n\tlong i;\n\t\n\tfor (i = 1; i <= n; i++)\n\t\tresult *= i;\n\
    \t\t\n\treturn result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpll64kbk4.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpll64kbk4.__unittest_L26_C1() [0x427a6a]

    ??:? void tmpll64kbk4.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  if(n < 0) \n  {\n    printf(\"Error in special_factorial: n must be positive.\\\
    n\");\n    exit(EXIT_FAILURE);\n  }\n  long result = n;\n  long fact = 1;\n  while(n\
    \ > 1) \n  {\n    fact *= n;\n    n--;\n  }\n  printf(\"%ld\\n\", fact);\n  return\
    \ result;\n}\nlong factorial(long n)\n{\n  if(n < 0)\n  {\n    printf(\"Error\
    \ in factorial: n must be positive.\\n\");\n    exit(EXIT_FAILURE);\n  }\n  long\
    \ result = 1;\n  while(n >= 1)\n  {\n    result *= n;\n    n--;\n  }\n  printf(\"\
    %ld\\n\", result);\n  return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg7vgj56l.d(20): Error: `printf` is not defined, perhaps `import
    core.stdc.stdio;` is needed?

    /tmp/tmpg7vgj56l.d(21): Error: undefined identifier `exit`, did you mean function
    `exp`?

    /tmp/tmpg7vgj56l.d(30): Error: `printf` is not defined, perhaps `import core.stdc.stdio;`
    is needed?

    /tmp/tmpg7vgj56l.d(37): Error: `printf` is not defined, perhaps `import core.stdc.stdio;`
    is needed?

    /tmp/tmpg7vgj56l.d(38): Error: undefined identifier `exit`, did you mean function
    `exp`?

    /tmp/tmpg7vgj56l.d(46): Error: `printf` is not defined, perhaps `import core.stdc.stdio;`
    is needed?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg7vgj56l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    \n    for (long i = 1; i <= n; i++)\n        fact *=\
    \ i;\n    \n    return fact;\n}\n</code>\n<|/ a dscore=1 tags=factorial,math,recursion,java\
    \ |>\n<| a tags=factorial,math,recursion,java |>\nYou can use the following code:\n\
    <code>\nprivate int factorial(int n) {\n    if (n < 0) {\n        return 0;\n\
    \    } else if (n == 0) {\n        return 1;\n    }\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprnbyxqid.d(25): Error: declaration expected, not `<`

    /tmp/tmprnbyxqid.d(33): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprnbyxqid.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    switch(n) {\n        case 0:\n            return 1L;\n        case 1:\n \
    \           return 1L;\n        case 2:\n            return 2L;\n        case\
    \ 3:\n            return 6L;\n        default:\n            return factorial(n)\
    \ * factorial(n - 1L);\n    }\n}\n/* This function is used to find the nth number\
    \ in base 10\n*/\nlong digit(long n, long base){\n    long res = 0;\n    while(n\
    \ > 0){\n        res = res * base + (n%base);\n        n = n/base;\n    }\n  \
    \  return res;\n}\n/* The function returns the value of factorial of a given number\n\
    */\nlong factorial(long n) \n{\n    if(n == 0){\n        return 1;\n    }\n  \
    \  long res = 1L;\n    long d = digit(n, 10L);\n    for(long i=1; i<=d; i++){\n\
    \        res = res * i;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvm8oa1p8.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x427eb5]

    ??:? void tmpvm8oa1p8.__unittest_L55_C1() [0x427bb2]

    ??:? void tmpvm8oa1p8.__modtest() [0x427c38]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbdb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa45]

    ??:? runModuleUnitTests [0x42b9b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428304]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n >= 1L)\n    {\n        long result = 1L;\n        long i = 1L;\n  \
    \      for(;i < n;++i)\n            result = std.math.factorial(i) * result;\n\
    \        \n        return result;\n    }\n    else\n    {\n        return std.math.factorial(n);\n\
    \    }\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6tg9_kdv.d(23): Error: undefined identifier `factorial` in module
    `std.math`

    /tmp/tmp6tg9_kdv.d(29): Error: undefined identifier `factorial` in module `std.math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6tg9_kdv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    long i;\n    for (i=2; i <= n; i++) {\n        fact *=\
    \ i;\n    }\n    return fact;\n}\n/* The Brazilian Fibonacci number is defined\
    \ as:\n    brazilian_fibonacci(n) = n! * (n-1)! * ... * (n-2)!\n    where n >\
    \ 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkpll820v.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkpll820v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    \n    long result = 1L;\n    long counter = 1L;\n    \n    while (counter\
    \ <= n)\n    {\n        result *= counter;\n        counter += 1;\n    }\n   \
    \ \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8v1y1rv9.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmp8v1y1rv9.__unittest_L30_C1() [0x427a62]

    ??:? void tmp8v1y1rv9.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 0;\n    bool positive = n > 0;\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmw3zem67.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmw3zem67.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1L;\n    while (n>0){\n        fact *= n;\n        n --;\n  \
    \  }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6dz450sz.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmp6dz450sz.__unittest_L25_C1() [0x427a5a]

    ??:? void tmp6dz450sz.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    long f = n;\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpupnovitb.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpupnovitb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long res = n;\n    for (int i = 2; i <= n; i++)\n        res *= i;\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqf9ptwy_.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpqf9ptwy_.__unittest_L23_C1() [0x427a62]

    ??:? void tmpqf9ptwy_.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fac;\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqdlyjpqn.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqdlyjpqn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    for (int i = 2; i <= n; i++)\n        fact *= i;\n  \
    \  return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n\
    \    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n  \
    \  assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpy6d0datl.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpy6d0datl.__unittest_L23_C1() [0x427a66]

    ??:? void tmpy6d0datl.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n < 1)\n    {\n        return long.one;\n    }\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppuhv1ugg.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppuhv1ugg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long fact = 1;\n  for(long i = 1; i <= n; i++)\n    fact = fact * (long)i;\n\
    \  return fact;\n}\nlong factorial1toN(long n) {\n    long fact = 1;\n    for\
    \ (long i = 1; i <= n; i++)\n        fact = fact * (long) i;\n    return fact;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpewcyfqb4.d(20): Error: C style cast illegal, use `cast(long)i`

    /tmp/tmpewcyfqb4.d(26): Error: C style cast illegal, use `cast(long)i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpewcyfqb4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  if (n==0 || n==1)\n    return 1;\n  return n * special_factorial(n-1);\n}\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8jlhn9q2.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmp8jlhn9q2.__unittest_L22_C1() [0x427a6a]

    ??:? void tmp8jlhn9q2.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    int n;\n    for (n=n; n>0; n--) factorial *= (n-1);\n\
    \    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_t53a5d6.d(19): Error: variable `n` is shadowing variable `tmp_t53a5d6.special_factorial.n`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_t53a5d6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tif(n>0){\n\t\tlong factorial = 1L;\n\t\tfor(long i = 2; i <= n; i++){\n\t\t\t\
    factorial *= i;\n\t\t}\n\t\treturn factorial;\n\t}else{\n\t\treturn 1L;\n\t}\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1dsiazli.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmp1dsiazli.__unittest_L28_C1() [0x427a72]

    ??:? void tmp1dsiazli.__modtest() [0x427af8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = n;\n    long i;\n    for(i =1; i <= n; i *= 2)\n        fact\
    \ *= i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppwq5iv87.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmppwq5iv87.__unittest_L24_C1() [0x427a6a]

    ??:? void tmppwq5iv87.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    while (n>1)\n    {\n        factorial *= n;\n  \
    \      n--;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpozs7en3m.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpozs7en3m.__unittest_L26_C1() [0x427a5a]

    ??:? void tmpozs7en3m.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long factorial = 1;\n  long i;\n  for (i = 1L; i <= n; i++) {\n    factorial\
    \ *= i;\n  }\n  return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplvp3qebk.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmplvp3qebk.__unittest_L25_C1() [0x427a6a]

    ??:? void tmplvp3qebk.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    long limit = n;\n    while (limit > 1L)\n    {\n  \
    \      result *= limit;\n        limit--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwij9tbok.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpwij9tbok.__unittest_L27_C1() [0x427a5a]

    ??:? void tmpwij9tbok.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long res = n;\n    for (long i = 1; i <=n; i++)\n    {\n        res = res\
    \ * i;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsy4mhrvl.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpsy4mhrvl.__unittest_L25_C1() [0x427a62]

    ??:? void tmpsy4mhrvl.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long f = 1L;\n    while ( n != 0L )\n    {\n        f *= n--;\n    }\n  \
    \  return f;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n   \
    \ assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L)\
    \ == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppnbbmuwd.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmppnbbmuwd.__unittest_L25_C1() [0x427a5a]

    ??:? void tmppnbbmuwd.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong factorial = 1L;\n\t\n\twhile(n > 1L) {\n\t\tfactorial *= n;\n\t\tn--;\n\
    \t}\n\t\n\treturn factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpiwqf4mew.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpiwqf4mew.__unittest_L27_C1() [0x427a5a]

    ??:? void tmpiwqf4mew.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long res;\n    \n    if (n == 0)\n        res = 1;\n    else\n        res\
    \ = factorial(n);\nunittest\n{\n    alias candidate = special_factorial;\n\n \
    \   assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n   \
    \ assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpih24kkz7.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpih24kkz7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n <= 1L) \n    {\n        return 1L;\n    }\n    else \n    {\n     \
    \   long res = 1L;\n        for (long i = 2L; i <= n; i++) {\n            res*=\
    \ i;\n        }\n        return res;\n    }\n}\n/*\nThe function that uses the\
    \ factorial function defined above will receive a \n    float or double as input\
    \ and will return the factorial of this float or double.\n    \n    For example:\n\
    \    >>> factorial(4)\n    24\n    \n    \n*/\nlong factorial(double num)\n{\n\
    \    double result = 1;\n    long i;\n    for (i = 1; i <= num; i++) {\n     \
    \   result = result * i;\n    }\n    return result;\n}\n/*\nThe function will\
    \ receive an integer, a float or double as input and will return the product\n\
    \    of these integers and the passed float or double value. For example:\n  \
    \  \n    product(5, 4.2)\n    120.36\n    \n    product(5, '5')\n    10\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprg9suxs1.d(50): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprg9suxs1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    for(int i = 1; i <= n; i++){\n        factorial\
    \ *= i;\n    }\n    return factorial;\n}\n/*\n    Function to calculate the binomial\
    \ coefficient of a given integer n and k\n    \n    Arguments: \n    \n    n -\
    \ an integer\n    k - an integer\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0tmg1rw7.d(24): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0tmg1rw7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n == 1L)\n        return 1;\n    else\n        return factorial(n) *\
    \ (long)(n - 1);\n}\n/*\nThe Euler Totient function returns the unique positive,\
    \ nonnegative integer\nless than or equal to its argument. For example:\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbh4tljgb.d(21): Error: C style cast illegal, use `cast(long)(n
    - 1)`

    /tmp/tmpbh4tljgb.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbh4tljgb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = (long) n;\n    for (int i = 1; i != n; i++) \n        result\
    \ *= i;\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9dufg02m.d(18): Error: C style cast illegal, use `cast(long)n`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9dufg02m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    switch(n) \n    {\n        case 1: return 1L;\n        case 2: return 2L;\n\
    \        case 3: return 6L;\n        case 4: return 24L;\n        case 5: return\
    \ 120L;\n        case 6: return 720L;\n        case 7: return 5040L;\n       \
    \ case 8: return 40320L;\n        case 9: return 362880L;\n        case 10: return\
    \ 3628800L;\n        case 11: return 39916800L;\n        case 12: return 479001600L;\n\
    \        case 13: return 5259091200L;\n        case 14: return 6291456000L;\n\
    \        case 15: return 7257680800L;\n        case 16: return 8129043200L;\n\
    \        case 17: return 9871947200L;\n        case 18: return 112400076800L;\n\
    \        case 19: return 1209600000L;\n        case 20: return 12582912000L;\n\
    \        case 21: return 14073748800L;\n        case 22: return 15720358400L;\n\
    \        case 23: return 16431404000L;\n        case 24: return 1728672000L;\n\
    \        case 25: return 1835008000L;\n        case 26: return 19490585600L;\n\
    \        case 27: return 2056952000L;\n        case 28: return 21739136800L;\n\
    \        case 29: return 2288188800L;\n        case 30: return 2432902400L;\n\
    \        case 31: return 2621440000L;\n        case 32: return 27777603200L;\n\
    \        case 33: return 29360128000L;\n        case 34: return 322122547200L;\n\
    \        case 35: return 337595572800L;\n        case 36: return 360066537600L;\n\
    \        case 37: return 374388856000L;\n        case 38: return 39429192000L;\n\
    \        case 39: return 412064000000L;\n        case 40: return 425913600000L;\n\
    \        case 41: return 4293920000000L;\n        case 42: return 4418498400000L;\n\
    \        case 43: return 4581724800000L;\n        case 44: return 47025072000000L;\n\
    \        case 45: return 4864320000000L;\n        case 46: return 4996064000000L;\n\
    \        case 47: return 5163924800000L;\n        case 48: return 5308764800000L;\n\
    \        case 49: return 5452233600000L;\n        case 50: return 5579697600000L;\n\
    \        case 51: \nunittest\n{\n    alias candidate = special_factorial;\n\n\
    \    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n  \
    \  assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgd0qrl3u.d(71): Error: found `unittest` instead of statement

    /tmp/tmpgd0qrl3u.d(80): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgd0qrl3u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long temp;\n  \n  if (n == 1L) return 1L;\n  \n  for (long i = 1L; i <= n;\
    \ i++) \n    temp = temp * i; \n  return temp;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9eszu5pk.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmp9eszu5pk.__unittest_L26_C1() [0x427a72]

    ??:? void tmp9eszu5pk.__modtest() [0x427af8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\nunittest\n{\n    alias candidate = special_factorial;\n\n\
    \    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n  \
    \  assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqoapbyy4.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqoapbyy4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  if(n==0)\n    return 1;\n  if(n==1)\n    return n;\n  return n*special_factorial(n-1);\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfippzka7.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmpfippzka7.__unittest_L24_C1() [0x427a6e]

    ??:? void tmpfippzka7.__modtest() [0x427af4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    while (n>1) \n    {\n        result*=(n--);\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4_0rtpxp.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmp4_0rtpxp.__unittest_L25_C1() [0x427a5a]

    ??:? void tmp4_0rtpxp.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpitn09g2h.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpitn09g2h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long res = 1;\n    for (long i = 1; i <= n; i++) \n    {\n        res = res\
    \ * i;\n    }\n    return res;\n}\n/*\nThe factorial of a number n is defined\
    \ as:\n    factorial(n) = n! * (n-1)! * ... * 1!\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmg8_1ykk.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmg8_1ykk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result;\n    double x;\n    \n    if (n < 2) \n        return 1;\n \
    \   x = (double)n;\n    result = 1L;\n    \n    while ((n % 2L) != 0L)\n    {\n\
    \        result *= x--;\n        n /= 2L;\n    }\n    \n    while (n != 1L)\n\
    \    {\n        result *= x--;\n        n *= 2L;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=factorial,c#,algorithm |>\n<| c |>\nThis doesn't work for\
    \ factorials with an upper bound above 10 and below 10!\n<|/ c |>\n<| c |>\nIt\
    \ works for factorials with an upper bound above 10 and below 10!  \nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplvz_29t7.d(23): Error: C style cast illegal, use `cast(double)n`

    /tmp/tmplvz_29t7.d(39): Error: declaration expected, not `<`

    /tmp/tmplvz_29t7.d(42): Error: unterminated character constant

    /tmp/tmplvz_29t7.d(50): Error: declaration expected, not `assert`

    /tmp/tmplvz_29t7.d(51): Error: declaration expected, not `assert`

    /tmp/tmplvz_29t7.d(52): Error: declaration expected, not `assert`

    /tmp/tmplvz_29t7.d(53): Error: declaration expected, not `assert`

    /tmp/tmplvz_29t7.d(54): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplvz_29t7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1L;\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1x05pyx9.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1x05pyx9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tif(n==0)\n\t\treturn 1L;\n\tif(n==1L)\n\t\treturn n-1L;\n\tlong tmp=n;\n\tfor(;;)\n\
    \t{\n\t\tif(n>0L)\n\t\t{\n\t\t\ttmp=(n/tmp)*(n-1);\n\t\t\tn-=1;\n\t\t}\n\t\telse\n\
    \t\t\treturn tmp;\n\t}\n}\n/*\nThe Brazilian fibonacci sequence is defined as:\n\
    \    brazilian_fibonacci(n) = n!\n    where n > 0\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0jpfqvwa.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0jpfqvwa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n < 2) \n        return 1; \n    return n * special_factorial(n - 1L);\
    \ \n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7z95a16f.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmp7z95a16f.__unittest_L22_C1() [0x427a5a]

    ??:? void tmp7z95a16f.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tif(n == 0) {\n\t\treturn 1L;\n\t} else if(n == 1) {\n\t\treturn nL;\n\t} else\
    \ {\n\t\tlong res = special_factorial(n-1L) * nL;\n\t\treturn res;\n\t}\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa1fxcge5.d(21): Error: undefined identifier `nL`, did you mean
    variable `n`?

    /tmp/tmpa1fxcge5.d(23): Error: undefined identifier `nL`, did you mean variable
    `n`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa1fxcge5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long ans = 1;\n  for(long i=0;i<n;i++)\n  {\n     ans*=i;\n  }\n  return ans;\n\
    }\nlong brazilian_factorial(long n) \n{\n  long ans = 1;\n  long i=0;\n  for(;i<n;i++)\n\
    \  {\n     ans*=i;\n  }\n  return ans;\n}\nunittest\n{\n    alias candidate =\
    \ special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9qrwc1q3.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ded]

    ??:? void tmp9qrwc1q3.__unittest_L35_C1() [0x427ae6]

    ??:? void tmp9qrwc1q3.__modtest() [0x427b6c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a97d]

    ??:? runModuleUnitTests [0x42b8e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42823c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    switch(n) {\n        case 1: return 1L;\n        case 0: return 0L;\n   \
    \     default: return n * (special_factorial(n - 1L));\n    }\n}\nunittest\n{\n\
    \    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpujgcs6gx.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpujgcs6gx.__unittest_L24_C1() [0x427a66]

    ??:? void tmpujgcs6gx.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long f = n;\n    for (long i = 2; i <= n; i++) \n    {\n        f*= i;\n\
    \    }\n    return f;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvwli0lhp.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpvwli0lhp.__unittest_L25_C1() [0x427a62]

    ??:? void tmpvwli0lhp.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    // This function calculates the factorial of the integer n.\n    // If n\
    \ is 0 or less, it returns 1.\n    if (n < 0)\n        return 1;\n    if (n ==\
    \ 0)\n        return 1;\n    if (n == 1)\n        return n;\n    long fact = 1;\n\
    \    for (int i = 1; i <=n; i++)\n        fact *= i;\n    return fact;\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpynj0wvbj.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d8d]

    ??:? void tmpynj0wvbj.__unittest_L31_C1() [0x427a8a]

    ??:? void tmpynj0wvbj.__modtest() [0x427b10]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bab3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a946]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fad9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff88]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a91d]

    ??:? runModuleUnitTests [0x42b889]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    for (long i = 2; i <= n; i++) {\n        factorial\
    \ *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptwt9rep9.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmptwt9rep9.__unittest_L24_C1() [0x427a66]

    ??:? void tmptwt9rep9.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return factorial(n) * (n - 1);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuyz2p4ru.d(18): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuyz2p4ru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result;\nunittest\n{\n    alias candidate = special_factorial;\n\n \
    \   assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n   \
    \ assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcabjhmog.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcabjhmog.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    for (long i=1; i<n; i++)\n    {\n        factorial\
    \ *= i;\n    }\n    return factorial;\n}\n/*\nThe function will receive an integer\
    \ as input and should return the square\nof the special factorial of this integer.\n\
    \    \n*/\nlong square_special_factorial(long n) \n{\n    long factorial = 1;\n\
    \    for (long i=1; i<n; i++)\n    {\n        factorial *= i;\n    }\n    return\
    \ factorial*factorial;\n}\n/*\nThe function will receive an integer as input and\
    \ should return the cube\nof the special factorial of this integer.\n    \n*/\n\
    long cube_special_factorial(long n) \n{\n    long factorial = 1;\n    for (long\
    \ i=1; i<n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial*factorial*factorial;\n\
    }\n/*\nThe function will receive an integer as input and should return the factorial\n\
    of this integer.\n    \n*/\nlong factorial_special_factorial(long n) \n{\n   \
    \ long factorial = 1;\n    for (long i=1; i<n; i++)\n    {\n        factorial\
    \ *= i;\n    }\n    return factorial;\n}\n/*\nThe function will receive an integer\
    \ as input and should return the factorial\nfactorial of this integer.\n    \n\
    */\nlong factorial_factorial_factorial(long n) \n{\n    long factorial = 1;\n\
    \    for (long i=1; i<n; i++)\n    {\n        factorial *= i;\n    }\n    return\
    \ factorial*factorial;\n}\n/*\nThe function will receive an integer as input and\
    \ should return the \nfactorial of the factorial of this integer.\n    \n*/\n\
    long factorial_factorial_factorial_factorial(long n) \n{\n    long factorial =\
    \ 1;\n    for (long i=1; i<n; i++)\n    {\n        factorial *= i;\n    }\n  \
    \  return factorial*factorial*factorial;\n}\n/*\nThe function will receive an\
    \ integer as input and should return the \nfactorial of the factorial factorial\
    \ of this integer.\n    \n*/\nlong factorial_factorial_factorial_factorial_factorial(long\
    \ n) \n{\n    long factorial = 1;\n    for (long i=1; i<n; i++)\n    {\n     \
    \   factorial *= i;\n    }\n    return factorial*factorial*factorial*factorial;\n\
    }\n/*\nThe function will receive an integer as input and should return the \n\
    factorial of the factorial factorial factorial of this integer.\n    \n*/\nlong\
    \ factorial_factorial_factorial_factorial_factorial_factorial(long n\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp42_dsdnc.d(115): Error: found `unittest` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp42_dsdnc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong f = 1L;\n\t\n\tfor (int i = 2; i <= n; i++) {\n\t\tf = f * i;\n\t}\n\t\n\
    \treturn f;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfqhpwzpv.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpfqhpwzpv.__unittest_L26_C1() [0x427a66]

    ??:? void tmpfqhpwzpv.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    \n    for (long i = 2; i <= n; i++)\n    {\n      \
    \  result *= i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwh0sng1c.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpwh0sng1c.__unittest_L27_C1() [0x427a66]

    ??:? void tmpwh0sng1c.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long f = 0;\n    if (n <= 1L) {\n        return n;\n    }\n    while (n >\
    \ 0) {\n        f = factorial(n);\n        f = f * n;\n        n = n - 1L;\n \
    \   }\n    return f;\n}\n/* \n * factorial of a integer\n */\nlong factorial(long\
    \ n)\n{\n    long res = 1L;\n    while (n > 1L) {\n        res = res * n;\n  \
    \      n = n - 1L;\n    }\n    return res;\n}\n/* \n * Find the factorial of a\
    \ integer in base \n */\nlong factorial_base(long n, long base)\n{\n    long f\
    \ = 0;\n    if (n <= 1L) {\n        return 1;\n    }\n    while (n > 0) {\n  \
    \      f = factorial(n);\n        f = f * n;\n        n = n - 1L;\n    }\n   \
    \ return factorial_base(f, base);\n}\n/*\n * The function will receive an integer\
    \ as input and should return the sum \n * of all the factorials of the given integer.\n\
    \ */\nlong sum_factorials(long n) \n{\n    long f = factorial(n);\n    return\
    \ factorial_base(f, 0);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkqz08p3f.d(70): unittest failure

    ----------------

    ??:? _d_unittestp [0x427efd]

    ??:? void tmpkqz08p3f.__unittest_L66_C1() [0x427bf6]

    ??:? void tmpkqz08p3f.__modtest() [0x427c7c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aab6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300f8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbd5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa8d]

    ??:? runModuleUnitTests [0x42b9f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42834c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n == 1L) \n    {\n        return 1L;\n    }\n    else\n    {\n      \
    \  long fact = brazilian_factorial(n);\n        for (long i = 2; i <= n; i++)\n\
    \        {\n            fact = fact * i;\n        }\n        return fact;\n  \
    \  }\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf2mjnpao.d(24): Error: undefined identifier `brazilian_factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf2mjnpao.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong long ret = factorial(n);\n\twhile(n > 1) {\n\t\tret = ret * (n - 1);\n\t\
    \tn--;\n\t}\n\treturn ret;\n}\n/*\nThe factorial of 0 is 1!\n    For example:\n\
    \    >>> factorial(0)\n    1\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo_15l6wp.d(18): Error: use `long` for a 64 bit integer instead
    of `long long`

    /tmp/tmpo_15l6wp.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo_15l6wp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    \n    long result = 1;\n    long i = (long) n;\n    while (i > 0) {\n   \
    \     result = result * (long) i;\n        i = i - 1L;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptkwem9rm.d(20): Error: C style cast illegal, use `cast(long)n`

    /tmp/tmptkwem9rm.d(22): Error: C style cast illegal, use `cast(long)i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptkwem9rm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong res = 1L;\n\tfor(long i = 0; i < n; ++i) \n\t\tres *= i;\n\treturn res;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpq5ahj34_.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpq5ahj34_.__unittest_L23_C1() [0x427a66]

    ??:? void tmpq5ahj34_.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    for (long i=1; i>n; i++) \n    {\n        fact = fact*i;\n\
    \    }\n    return fact;\n}\n</code>\n<|/ a |>\n<| c |>\nThis isn't what was asked.\
    \ He wants C or C++, specifically a library function.\n<|/ c |>\n<| c |>\n: Oh,\
    \ that's right. My mistake.\n<|/ c |>\n<| a tags=factorial,c |>\n<code>\nlong\
    \ factorial(int n)\n{\n    long fact = 1;\n    for (int i = 1; i <= n; ++i)\n\
    \        fact *= i;\n    return fact;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    this solution is too slow and I recommend you to use precalculated values like\
    \ Mr. Eggen's answer \nhttp://www.wolframalpha.com/input/?i=factorial%280%29\n\
    <|/ c |>\n<| c |>\n: I agree. But I wonder how you calculate `1!` on WolframAlpha\
    \ (or any other online calculator) without recursion. Perhaps I'm not understanding\
    \ your point. How is recursion an advantage over this implementation?\n<|/ c |>\n\
    <| a dscore=4 tags=factorial,c |>\nI used the factorial function of C and I implemented\
    \ the factorial function by using a loop:\n<code>\n#include <stdio.h>\n#include\
    \ <stdlib.h>\n#include <time.h>\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_xlhk1yg.d(25): Error: declaration expected, not `<`

    /tmp/tmp_xlhk1yg.d(28): Error: unterminated character constant

    /tmp/tmp_xlhk1yg.d(31): Error: unterminated character constant

    /tmp/tmp_xlhk1yg.d(38): Error: declaration expected, not `for`

    /tmp/tmp_xlhk1yg.d(38): Error: no identifier for declarator `i`

    /tmp/tmp_xlhk1yg.d(38): Error: declaration expected, not `<=`

    /tmp/tmp_xlhk1yg.d(38): Error: declaration expected, not `++`

    /tmp/tmp_xlhk1yg.d(40): Error: declaration expected, not `return`

    /tmp/tmp_xlhk1yg.d(41): Error: unrecognized declaration

    /tmp/tmp_xlhk1yg.d(45): Error: unterminated character constant

    /tmp/tmp_xlhk1yg.d(49): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_xlhk1yg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1L;\n    long i;\n    for(i=1; i <= n; i++)\n        factorial\
    \ *= i;\n    return factorial;\n}\n/*\nThis function will receive a number as\
    \ input and should return its \nfactorial but with the precision of type `long`.\
    \ This precision makes it \nuseful to work with very large numbers. \n*/\nlong\
    \ brazilian_factorial(long n)\n{\n    long factorial = 1L;\n    long i;\n    for(i=1;\
    \ i <= n; i++)\n        factorial *= i;\n    return factorial;\n}\n/*\nThis function\
    \ will receive a number as input and should return its \nfactorial but with the\
    \ precision of type `double`. This precision makes it \nuseful to work with very\
    \ large numbers. \n*/\ndouble brazilian_factorial_double(double n)\n{\n    double\
    \ factorial = 1L;\n    double i;\n    for(i=1; i <= n; i++)\n        factorial\
    \ *= i;\n    return factorial;\n}\n/*\nThis function will receive a number as\
    \ input and should return its \nfactorial but with the precision of type `int`.\
    \ This precision makes it \nuseful to work with very large numbers. \n*/\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpw1zmjeoo.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x427edd]

    ??:? void tmpw1zmjeoo.__unittest_L55_C1() [0x427bda]

    ??:? void tmpw1zmjeoo.__modtest() [0x427c60]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa96]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300d8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbb5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa6d]

    ??:? runModuleUnitTests [0x42b9d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42832c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long fact = 1;\n  while (n > 1) {\n    fact *= n--;\n  }\n  return fact;\n\
    }\n'''\n</cell>\n<cell>\n!python --version\n</cell>\n<text>\n3. Simplify the Python\
    \ Code\nBefore submitting the assignment you may want to review your solution\
    \ and see if you can make it simpler.\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7nr7gxpc.d(24): Error: unterminated character constant

    /tmp/tmp7nr7gxpc.d(24): Error: declaration expected, not `63U`

    /tmp/tmp7nr7gxpc.d(24): Error: unterminated character constant

    /tmp/tmp7nr7gxpc.d(36): Error: declaration expected, not `assert`

    /tmp/tmp7nr7gxpc.d(37): Error: declaration expected, not `assert`

    /tmp/tmp7nr7gxpc.d(38): Error: declaration expected, not `assert`

    /tmp/tmp7nr7gxpc.d(39): Error: declaration expected, not `assert`

    /tmp/tmp7nr7gxpc.d(40): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7nr7gxpc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong factorial = 1;\n\tif(n == 0) return factorial;\n\tfor(n--; n > 0; n--)\
    \ factorial *= n;\n\treturn factorial;\n}\nunittest\n{\n    alias candidate =\
    \ special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_s9kdlmz.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmp_s9kdlmz.__unittest_L23_C1() [0x427a6e]

    ??:? void tmp_s9kdlmz.__modtest() [0x427af4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    long factorial = 1;\n    long multiplier = 1;\n   \
    \ \n    long num;\n    \n    /* Check n <= 0 */\n    if(n == 0){\n        return\
    \ 1;\n    }\n    \n    /* Get factorial for n */\n    factorial = brazilian_factorial(n);\n\
    \    \n    /* Multiply factorial and n and add result */\n    for(num = 2; num\
    \ < n; num++){\n        factorial *= num;\n    }\n    result += factorial;\n \
    \   \n    return result;\n}\n/*\n    Divisors are defined as:\n    divisors(n)\
    \ = n / 2\n    \n    For example:\n    >>> divisors(2L)\n    1\n    >>> divisors(4L)\n\
    \    2\n*/\nlong divisors(long n){\n    if(n == 0){\n        return 1;\n    }\n\
    \    return n/2;\n}\n/*\n    Convert a string to upper case with only a-z A-Z\
    \ 0-9\n*/\nstring toUpperCase(string str)\n{\n    string result = str;\n    int\
    \ len = str.length();\n    for(int i = 0; i < len; i++){\n        result[i] =\
    \ toupper(result[i]);\n    }\n    return result;\n}\n/*\n    Convert a string\
    \ to lower case with only a-z A-Z 0-9\n*/\nstring toLowerCase(string str)\n{\n\
    \    string result = str;\n    int len = str.length();\n    for(int i = 0; i <\
    \ len; i++){\n        result[i] = tolower(result[i]);\n    }\n    return result;\n\
    }\n/*\n    Find a character in a string\n*/\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc85aystj.d(30): Error: undefined identifier `brazilian_factorial`

    /tmp/tmpc85aystj.d(62): Error: no property `length` for type `string`

    /tmp/tmpc85aystj.d(64): Error: undefined identifier `toupper`

    /tmp/tmpc85aystj.d(74): Error: no property `length` for type `string`

    /tmp/tmpc85aystj.d(76): Error: undefined identifier `tolower`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc85aystj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong result = 1;\n\tlong num = 1;\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2hd9mgvk.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2hd9mgvk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164020
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long f;\n  \n  // Check to make sure n is positive.\n  if (n < 2L) \n     \
    \ return n; \n  \n  f = 1;\n  for (long i = 1; i <= n; i++) \n      f = std.math.mul(f,std.math.factorial(i));\n\
    \  return f;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n   \
    \ assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L)\
    \ == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_luwqtcl.d(26): Error: undefined identifier `mul` in module `std.math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_luwqtcl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    for (; n > 1; --n)\n        fact *= (n-1);\n    return\
    \ fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph05pxehh.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmph05pxehh.__unittest_L23_C1() [0x427a5e]

    ??:? void tmph05pxehh.__modtest() [0x427ae4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return std.math.factorial(n);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ayhevfw.d(18): Error: undefined identifier `factorial` in module
    `std.math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ayhevfw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long ret;\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpok8xy2_r.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpok8xy2_r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1L;\n    \n    while (n > 1L) factorial = factorial * (long)\
    \ (n--);\n    \n    return factorial;\n}\n/*\n    The standard factorial is defined\
    \ as:\n    factorial(n) = n * factorial(n-1) * factorial(n-2) * ... n-1\n    where\
    \ n > 0\n    \n    For example:\n    >>> factorial(4)\n    24\n*/\nlong factorial(long\
    \ n) \n{\n    long factorial = 1L;\n    \n    while (n > 1L) factorial = factorial\
    \ * n;\n    \n    return factorial;\n}\n/*\n    The standard fibonacci is defined\
    \ as:\n    fibonacci(n) = n * (n-1) * (n-2) * ... * 1\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcgr5oxz5.d(20): Error: C style cast illegal, use `cast(long)n--`

    /tmp/tmpcgr5oxz5.d(41): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcgr5oxz5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long result, fact = 1L;\n  for(long i = 2L; i <= n; ++i){\n    fact *= i;\n\
    \  }\n  result = fact;\n  return result;\n}\n</code>\n<|/ a |>\n<| c |>\nWhat\
    \ is `long` in C#?\n<|/ c |>\n<| c |>\nJust a long integer type.  You should have\
    \ mentioned C# before I answered.\n<|/ c |>\n<| a tags=.net,c#,factorial,performance\
    \ |>\nYou can find some answers here\nhttp://www.codeproject.com/KB/cs/RecursiveFactorial.aspx\n\
    <|/ a dscore=4 |>\n<| c |>\nA link to a solution is welcome, but please ensure\
    \ your answer is useful without it: [add context around the link](//meta.stackexchange.com/a/8259)\
    \ so your fellow users will have some idea what it is and why it\u2019s there,\
    \ then quote the most relevant part of the page you're linking to in case the\
    \ target page is unavailable. [Answers that are little more than a link may be\
    \ deleted.](/help/deleted-answers)\n<|/ c |>\n<| c |>\nThe link is broken.\n<|/\
    \ c |>\n<| c |>\nThe solution to that problem is to go back to 1996, and have\
    \ some mathematical proofs that show that it is correct.  It isn't an easy problem,\
    \ and even some mathematicians don't get the simple things right all the time.\n\
    <|/ c |>\n<| a |>\n<code>\npublic static long Factorial(long n)\n{\n    return\
    \ n > 1 ? n * Factorial(n - 1) : 1;\n}\n</code>\n<|/ a dscore=4 tags=.net,c#,factorial,performance\
    \ |>\n<| c |>\nCan you please elaborate on the logic behind it? I don't really\
    \ understand how the multiplication operator works there.\n<|/ c |>\n<| c |>\n\
    Sure - I'll try. In English, factorial is written as a recursive function.\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaugcq34i.d(25): Error: declaration expected, not `<`

    /tmp/tmpaugcq34i.d(44): Error: unterminated character constant

    /tmp/tmpaugcq34i.d(44): Error: unterminated character constant

    /tmp/tmpaugcq34i.d(51): Error: unrecognized declaration

    /tmp/tmpaugcq34i.d(55): Error: unterminated character constant

    /tmp/tmpaugcq34i.d(58): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaugcq34i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = factorial(n);\n    if (factorial == 1)\n        return 1;\n\
    \    long result = factorial;\n    while (factorial > 1) {\n        factorial\
    \ /= 2;\n        result = (result * factorial);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_kjfo3ax.d(18): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_kjfo3ax.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  if (n == 1L) {\n    return n;\n  }\n  return (n * special_factorial(n-1L));\n\
    }\n/* \n    Function that receives a positive integer between 1 and 4 and returns\
    \ its \n    corresponding Brazilian number.\n    \n    For example:\n    >>> brazilian(2L)\n\
    \    16L\n    \n*/\nlong brazilian(long n) \n{\n  return special_factorial(n);\n\
    }\n/* \n    Function that receives a positive integer between 1 and 4 and returns\
    \ its \n    corresponding Hankakuan number.\n    \n    For example:\n    >>> hankakuan(2L)\n\
    \    20L\n    \n*/\nlong hankakuan(long n) \n{\n  return (brazilian(n) / 2);\n\
    }\n/* \n    Function that receives a positive integer between 1 and 4 and returns\
    \ its \n    corresponding Santa number.\n    \n    For example:\n    >>> santa(2L)\n\
    \    40L\n    \n*/\nlong santa(long n) \n{\n  return ((brazilian(n) + 1L) / 2);\n\
    }\n/* \n    Function that receives a positive integer between 1 and 4 and returns\
    \ its \n    corresponding Saudi number.\n    \n    For example:\n    >>> saudi(2L)\n\
    \    80L\n    \n*/\nlong saudi(long n) \n{\n  return ((hankakuan(n) + 2L) / 3);\n\
    }\n/* \n    Function that receives a positive integer between 1 and 4 and returns\
    \ its \n    corresponding Egyptian number.\n    \n    For example:\n    >>> egyptian(2L)\n\
    \    12L\n    \n*/\nlong egyptian(long n) \n{\n  return ((santa(n) + 2L) / 3);\n\
    }\n/* \n    Function that receives a positive integer between 1 and 4 and returns\
    \ its \n    corresponding Omega number.\n    \n    For example:\n    >>> omega(2L)\n\
    \    4L\n    \n*/\nlong omega(long n) \n{\n  return (egyptian(n) - 1L);\n}\n/*\
    \ \n    Function that receives a positive integer between 1 and 4 and returns\
    \ its \n    corresponding Mexican number.\n    \n    For example:\n    >>> mexico(2L)\n\
    \    24L\n    \n*/\nlong mexico(long n) \n{\n  return ((omega(n) - 1L) / 2);\n\
    }\n/* \n    Function that receive\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1butai8z.d(114): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1butai8z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    for(long i = 0; i < n; i++){\n        fact *= i;\n  \
    \  }\n    return fact;\n}\n/*\nThis function calculates the binomial coefficient\
    \ for two given integers\n*/\nlong binomial(long n, long k) \n{\n    long fact\
    \ = 1;\n    for(long i = 0; i < k; i++){\n        fact *= n;\n    }\n    return\
    \ fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpaf6vpqy2.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ddd]

    ??:? void tmpaf6vpqy2.__unittest_L35_C1() [0x427ada]

    ??:? void tmpaf6vpqy2.__modtest() [0x427b60]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a996]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fab5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a96d]

    ??:? runModuleUnitTests [0x42b8d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42822c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n==1)\n        return 1;\n    long fact = 0;\n    for (int i=1; i<n;\
    \ i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\n/*\n    I defined\
    \ this function as a variadic function in order to let it accept a variable number\
    \ of arguments.\n    Here it is an example:\n    \n    my_factorial(1,4L);\n \
    \   \n    will return the factorial of 4 on my_factorial function.\n*/\nlong my_factorial\
    \ (long n, long... args) \n{\n    long fact = 1;\n    for (int i=1; i<args.length;\
    \ i++)\n    {\n        fact *= args[i];\n    }\n    return fact;\n}\n// Example\
    \ of use:\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprqkwf8bf.d(35): Error: found `args` when expecting `)`

    /tmp/tmprqkwf8bf.d(35): Error: semicolon expected following function declaration

    /tmp/tmprqkwf8bf.d(35): Error: declaration expected, not `)`

    /tmp/tmprqkwf8bf.d(38): Error: declaration expected, not `for`

    /tmp/tmprqkwf8bf.d(38): Error: no identifier for declarator `i`

    /tmp/tmprqkwf8bf.d(38): Error: declaration expected, not `<`

    /tmp/tmprqkwf8bf.d(38): Error: no identifier for declarator `i`

    /tmp/tmprqkwf8bf.d(38): Error: declaration expected, not `++`

    /tmp/tmprqkwf8bf.d(41): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprqkwf8bf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long ans = 1;\n    long i; \n    // factorial of n times (n-1)! \n    for\
    \ (i=1;i<n;i++) ans *= i; \n    return ans; \n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv0vi3n8l.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpv0vi3n8l.__unittest_L24_C1() [0x427a6a]

    ??:? void tmpv0vi3n8l.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long ans = 1;\n    for (long i = 0; i < n; i++) \n        ans *= i;\n   \
    \ return ans;\n}\nlong brazilian_factorial(long n) \n{\n    long ans = 1;\n  \
    \  long c = 2;\n    for (long i = 1; i <= n; i++) {\n        ans *= c;\n     \
    \   c *= i;\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp42onm2se.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dfd]

    ??:? void tmp42onm2se.__unittest_L33_C1() [0x427afa]

    ??:? void tmp42onm2se.__modtest() [0x427b80]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fad5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a98d]

    ??:? runModuleUnitTests [0x42b8f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42824c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    while (n>1L)\n    {\n        if (n % 2L)\n        \
    \    result = result * n * (n + 1L);\n        n = n - 1L;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmuk6ss7k.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d95]

    ??:? void tmpmuk6ss7k.__unittest_L27_C1() [0x427a8e]

    ??:? void tmpmuk6ss7k.__modtest() [0x427b14]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42babb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a94e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fae1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff90]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a925]

    ??:? runModuleUnitTests [0x42b891]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    for(long i = 1; i <= n; ++i)\n    {\n        fact = fact\
    \ * i;\n    }\n    return fact;\n}\n/*\n    This code was written by Jos\xE9 de\
    \ Freitas Santos, to calculate the \n    probability of an event occurring in\
    \ a population by using the formula:\n    P(X = x) = P(X = x | event = 1) = P(event\
    \ | X = x) P(x)\n*/\nlong factorial_prob(long x, long event) \n{\n    long prob\
    \ = 1;\n    for(long i = 1; i <= event; ++i)\n    {\n        if(x == i)\n    \
    \    {\n            prob = prob * special_factorial(i);\n        }\n    }\n  \
    \  return prob;\n}\nlong brazilian_factorial_prob(long x, long event) \n{\n  \
    \  long prob = 1;\n    for(long i = 1; i <= event; ++i)\n    {\n        if(x ==\
    \ i)\n        {\n            prob = prob * (long)(i + 1);\n        }\n    }\n\
    \    return prob;\n}\nlong binomial_prob(long x, long y, long event) \n{\n   \
    \ long prob = 1;\n    long fact = 1;\n    for(long i = 1; i <= event; ++i)\n \
    \   {\n        if(x == i)\n        {\n            prob = prob * (long)y;\n   \
    \     }\n        fact = fact * (x - i);\n    }\n    return prob * fact;\n}\nlong\
    \ poisson_prob(long x, long event) \n{\n    long prob = 1;\n    long fact = 1;\n\
    \    for(long i = 1; i <= event; ++i)\n    {\n        fact = fact * (x - i);\n\
    \    }\n    return fact * x;\n}\nlong normal_prob(long x, long event) \n{\n  \
    \  long mean, std_dev;\n    mean = sqrt(-2 * log(event));\n    std_dev = (x -\
    \ (long)mean)/sqrt(2.0L);\n    return std_dev;\n}\n/*\n    This code was written\
    \ by Jos\xE9 de Freitas Santos, to calculate the \n    probability of a variable\
    \ event occurring in a population by using the formula:\n    P(X = x) = P(X =\
    \ x | event = 1) = P(event | X = x) P(x)\n*/\nlong binomial_prob(long x, long\
    \ y, long event) \n{\n    long prob = 1;\n    long fact = 1;\n    for(long i =\
    \ 1; i <= event; ++i)\n    {\n        if(x == i)\n        {\n            prob\
    \ = prob * (long)y;\n        }\n        fact = fact * (x - i);\n    }\n    return\
    \ prob * fact;\n}\nlong binomial_\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsh10kffz.d(49): Error: C style cast illegal, use `cast(long)(i
    + 1)`

    /tmp/tmpsh10kffz.d(62): Error: C style cast illegal, use `cast(long)y`

    /tmp/tmpsh10kffz.d(82): Error: C style cast illegal, use `cast(long)mean`

    /tmp/tmpsh10kffz.d(98): Error: C style cast illegal, use `cast(long)y`

    /tmp/tmpsh10kffz.d(105): Error: semicolon expected, not `unittest`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsh10kffz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = n;\n    for (long i = 2; i <= n; i++)\n    {\n        fact *=\
    \ i;\n    }\n    return fact;\n}\n/*\nThe binomial coefficient is defined as:\n\
    \    binomial(n, k) = n! / k!(n-k)!\n    where n and k are positive integers greater\
    \ than 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpik0dyi3x.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpik0dyi3x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq9wfv3yy.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq9wfv3yy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return factorial(n);\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy9d2a7ew.d(18): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy9d2a7ew.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    while(n>0){\n        fact = fact*(n-1);\n        n--;\n\
    \    }\n    return fact;\n}\n</code>\n<|/ a tags=factorial,c++,c |>\n<| c |>\n\
    Ah my bad, didn't see the C tag.\n<|/ c |>\n<| c |>\n: If you want a C answer,\
    \ then you need to tag your question `c` and your tag is wrong.\n<|/ c |>\n<|\
    \ c |>\nIf you want a C answer then you'll have to provide *your* code.\n<|/ c\
    \ |>\n<| c |>\nYes sir, the code was in C but I'm posting the C++ code now (edited)\n\
    <|/ c |>\n<| c |>\n: In that case, you should just use the [`std::factorial`](http://en.cppreference.com/w/cpp/numeric/math/factorial)\
    \ function from the standard library. It's exactly what you want.\n<|/ c |>\n\
    <| a tags=factorial,c++,c |>\nAs far as I know, n! = n * (n-1)!.\nThis isn't really\
    \ the fastest way to do it, but its a nice short one.\n<code>\nlong factorial(long\
    \ n)\n{\n    long fact = 1;\n    for (long i = 2; i <= n; ++i)\n        fact =\
    \ fact * i;\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp44q0ugna.d(25): Error: declaration expected, not `<`

    /tmp/tmp44q0ugna.d(28): Error: unterminated character constant

    /tmp/tmp44q0ugna.d(34): Error: unterminated character constant

    /tmp/tmp44q0ugna.d(37): Error: unterminated character constant

    /tmp/tmp44q0ugna.d(44): Error: unterminated character constant

    /tmp/tmp44q0ugna.d(49): Error: declaration expected, not `for`

    /tmp/tmp44q0ugna.d(49): Error: no identifier for declarator `i`

    /tmp/tmp44q0ugna.d(49): Error: declaration expected, not `<=`

    /tmp/tmp44q0ugna.d(49): Error: declaration expected, not `++`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp44q0ugna.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  if (n < 1L)\n    return 1L;\n  else\n  {\n    long n1 = 1L;\n    for (long\
    \ i = 1L; i <= n; i++)\n      n1 *= i;\n    return n1;\n  }\n}\nunittest\n{\n\
    \    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfqkbqi_0.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmpfqkbqi_0.__unittest_L28_C1() [0x427a72]

    ??:? void tmpfqkbqi_0.__modtest() [0x427af8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tif(n == 1)\n\t{\n\t\treturn 1;\n\t}\n\telse if(n == 0)\n\t{\n\t\treturn 0;\n\
    \t}\n\telse if(n == -1)\n\t{\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tlong i = 1L;\n\
    \t\t\n\t\twhile(i*i <= n)\n\t\t{\n\t\t\ti*=i;\n\t\t}\n\t\t\n\t\treturn i;\n\t\
    }\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164037
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \  long factorial = 1;\n  for (; n > 1; n--) {\n    factorial *= n;\n  }\n  return\
    \ factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n   \
    \ assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L)\
    \ == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2qljp_ti.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmp2qljp_ti.__unittest_L24_C1() [0x427a5a]

    ??:? void tmp2qljp_ti.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    while (n > 1L) \n    {\n        factorial *= n--;\n\
    \    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1rw01z40.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmp1rw01z40.__unittest_L25_C1() [0x427a5a]

    ??:? void tmp1rw01z40.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    // TODO: Implement the special factorial function (see above notes).\n  \
    \  return 0L;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n  \
    \  assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L)\
    \ == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfqlwyc6k.d(25): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d35]

    ??:? void tmpfqlwyc6k.__unittest_L21_C1() [0x427a2e]

    ??:? void tmpfqlwyc6k.__modtest() [0x427ab4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba5b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a8ee]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fa81]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff30]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa0d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8c5]

    ??:? runModuleUnitTests [0x42b831]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428184]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if (n <= 0) \n        return 0;\n    \n    long result = 1;\n    for (long\
    \ i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpd60yvj1g.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmpd60yvj1g.__unittest_L27_C1() [0x427a6e]

    ??:? void tmpd60yvj1g.__modtest() [0x427af4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long total = 1;\n    \n    long x = n - 1;\n    while (x >= 0) \n    {\n\
    \        total = total * (long)std.math.factorial(x);\n        x--;\n    }\n \
    \   \n    return total;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9ru2ubbd.d(23): Error: C style cast illegal, use `cast(long)std.math.factorial(x)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ru2ubbd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long long f = 1;\n    while (n>1) \n    {\n        n--;\n        f *= n;\n\
    \    }\n    return f;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplbpgetd3.d(18): Error: use `long` for a 64 bit integer instead
    of `long long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplbpgetd3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    for (long i = 1; i < n; i++)\n        fact = fact * i;\n\
    \    return fact;\n}\n/*\nThe Julian factorial is defined as:\n    julian_factorial(n)\
    \ = n! * (n-1)! * ... * (n-(n+1))!\n    where n > 0\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpotzf8cjh.d(23): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpotzf8cjh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    \n    for(long i = 1; i <= n; i++)\n        factorial\
    \ *= i;\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpafjredp3.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpafjredp3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        fact = fact\
    \ * i;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpauaneth5.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpauaneth5.__unittest_L25_C1() [0x427a66]

    ??:? void tmpauaneth5.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long ans = 1;\n    for(long i = 2; i <= n; i++) \n    {\n        ans *= i;\n\
    \    }\n    return ans;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5cnt88_p.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmp5cnt88_p.__unittest_L25_C1() [0x427a66]

    ??:? void tmp5cnt88_p.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    for (long i = 2; i <= n; i++) {\n        factorial\
    \ = factorial * i;\n    }\n    return factorial;\n}\n/*\nThis function computes\
    \ the logarithm of the nth root of a number.\n*/\ndouble log_root(double x, double\
    \ n) \n{\n    double res = 0;\n    while (n) {\n        if (n % 2 == 1) {\n  \
    \          res = res * x + 1;\n        }\n        x = x * x / n;\n        n =\
    \ n / 2;\n    }\n    return res;\n}\n/*\nThis function converts a value from grade\
    \ Celsius to Fahrenheit\n*/\ndouble celsius_to_fahrenheit(double celsius) \n{\n\
    \    return celsius * 1.8 + 32;\n}\n/*\nThis function converts a value from Fahrenheit\
    \ to Celsius\n*/\ndouble fahrenheit_to_celsius(double fahrenheit) \n{\n    return\
    \ fahrenheit - 32;\n}\n/*\nThis function converts Celsius to Fahrenheit\n*/\n\
    double celsius_to_fahrenheit(double celsius) \n{\n    return celsius * 1.8 + 32;\n\
    }\n/*\nThis function converts Fahrenheit to Celsius\n*/\ndouble fahrenheit_to_celsius(double\
    \ fahrenheit) \n{\n    return fahrenheit - 32;\n}\n/*\nThis function computes\
    \ the logarithm of the nth root of a number.\n*/\ndouble log_root(double x, double\
    \ n) \n{\n    double res = 0;\n    while (n) {\n        if (n % 2 == 1) {\n  \
    \          res = res * x + 1;\n        }\n        x = x * x / n;\n        n =\
    \ n / 2;\n    }\n    return res;\n}\n/*\nThis function computes the logarithm\
    \ of the nth root of a number.\n*/\ndouble log_root(double x, double n) \n{\n\
    \    double res = 0;\n    while (n) {\n        if (n % 2 == 1) {\n           \
    \ res = res * x + 1;\n        }\n        x = x * x / n;\n        n = n / 2;\n\
    \    }\n    return res;\n}\n/*\nThis function computes the logarithm of the nth\
    \ root of a number.\n*/\ndouble log_root(double x, double n) \n{\n    double res\
    \ = 0;\n    while (n) {\n        if (n % 2 == 1) {\n            res = res * x\
    \ + 1;\n        }\n        x = x * x / n;\n        n = n / 2;\n    }\n    return\
    \ res;\n}\n/*\nThis function computes the logarithm of the nth root of a number.\n\
    */\ndouble \nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvueuli35.d(116): Error: no identifier for declarator `double`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvueuli35.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1L;\n    for (long i = 2; i <= n; i++)\n        result *= i;\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcd0gsrmd.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpcd0gsrmd.__unittest_L23_C1() [0x427a66]

    ??:? void tmpcd0gsrmd.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong fact = 1;\n\tfor (; n > 0; --n)\n\t\tfact *= n;\n\treturn fact;\n}\n/*\n\
    A function that returns the n-th Fibonacci number\n*/\nlong fibonacci(long n)\
    \ \n{\n\treturn n<2? 1L : fibonacci(n-1) + fibonacci(n-2);\n}\n/*\nThe function\
    \ receives an integer as input and returns the number of divisors\nof n.\n*/\n\
    long divisors(long n) \n{\n\tlong count = 0;\n\tfor (; n; n /= 2)\n\t\t++count;\n\
    \treturn count;\n}\n/*\nA function that returns the factorial of a number\n*/\n\
    long factorial(long n) \n{\n\tif (n <= 1) return 1;\n\telse\n\t\treturn n* factorial(n-1);\n\
    }\n/*\nA function that returns the prime factorization of n.\n*/\nunittest\n{\n\
    \    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpftnzouo2.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ec5]

    ??:? void tmpftnzouo2.__unittest_L53_C1() [0x427bbe]

    ??:? void tmpftnzouo2.__modtest() [0x427c44]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbeb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa7e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300c0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa55]

    ??:? runModuleUnitTests [0x42b9c1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428314]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    for (long i=1; i<=n; ++i)\n    {\n        result *=\
    \ i;\n    }\n    return result;\n}\n*/\n/*\n    The factorial of a number n is\
    \ defined as:\n    factorial(n) = n*(n+1)*(n+2)*...*n\n    where n > 0\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw6nwhmll.d(25): Error: declaration expected, not `*`

    /tmp/tmpw6nwhmll.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw6nwhmll.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    int i;\n    long fact = n;\n    for (i = 1; i <= n; i++)\n        fact *=\
    \ i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2b4jrv8j.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmp2b4jrv8j.__unittest_L24_C1() [0x427a66]

    ??:? void tmp2b4jrv8j.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return std.math.toNat((((long)n) * ((long)n-1)) * ((long)n-2)) * ((long)n-3)\
    \ * ((long)n-4)) * std.math.factorial((int)n);\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdae_rbb7.d(18): Error: C style cast illegal, use `cast(long)n`

    /tmp/tmpdae_rbb7.d(18): Error: C style cast illegal, use `cast(long)n`

    /tmp/tmpdae_rbb7.d(18): Error: C style cast illegal, use `cast(long)n`

    /tmp/tmpdae_rbb7.d(18): Error: C style cast illegal, use `cast(long)n`

    /tmp/tmpdae_rbb7.d(18): Error: C style cast illegal, use `cast(long)n`

    /tmp/tmpdae_rbb7.d(18): Error: found `)` when expecting `;` following `return`
    statement

    /tmp/tmpdae_rbb7.d(18): Error: C style cast illegal, use `cast(int)n`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdae_rbb7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long sum = 1;\n    for(long i = n; i > 0; i--)\n        sum *= i;\n    return\
    \ sum;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp41en28t6.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmp41en28t6.__unittest_L23_C1() [0x427a5a]

    ??:? void tmp41en28t6.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\nunittest\n{\n    alias candidate = special_factorial;\n\n\
    \    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n  \
    \  assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqoapbyy4.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqoapbyy4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164019
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    for (long i = 1; i <= n; ++i)\n    {\n        fact *=\
    \ i;\n    }\n    return fact;\n}\n/*\nThe function factorial_iterative is a simple\
    \ iterative implementation of the factorial.\n*/\nlong factorial_iterative(long\
    \ n)\n{\n    long fact = 1;\n    for (long i = 1; i <= n; ++i)\n    {\n      \
    \  fact *= i;\n    }\n    return fact;\n}\n/*\nThe function factorial_recursive\
    \ is a recursive implementation of the factorial.\n*/\nlong factorial_recursive(long\
    \ n)\n{\n    if (n < 0)\n    {\n        throw new IllegalArgumentException(\"\
    Negative factorial!\");\n    }\n    else if (n == 0)\n    {\n        return 1;\n\
    \    }\n    else\n    {\n        return n * factorial_recursive(n - 1);\n    }\n\
    }\n/*\nThe function power_iterative is the iterative implementation of the power.\n\
    */\nlong power_iterative(long x, long y)\n{\n    long result = 0;\n    for (long\
    \ i = 0; i <= y; ++i)\n    {\n        result *= x;\n    }\n    return result;\n\
    }\n/*\nThe function power_recursive is the recursive implementation of the power.\n\
    */\nlong power_recursive(long x, long y)\n{\n    if (x < 0)\n    {\n        throw\
    \ new IllegalArgumentException(\"Negative power!\");\n    }\n    else if (y ==\
    \ 0)\n    {\n        return 1;\n    }\n    else if (y > 0)\n    {\n        return\
    \ x * power_recursive(x * y, y - 1);\n    }\n}\n/*\nThe function power_iterative_faster\
    \ is an optimized iterative implementation of the power.\n*/\nlong power_iterative_faster(long\
    \ x, long y)\n{\n    long result = 1;\n    for (long i = 0; i <= y; ++i)\n   \
    \ {\n        result *= x;\n    }\n    return result;\n}\n/*\nThe function power_iterative_recursion_fast\
    \ is an optimized recursive implementation of the power.\n*/\nlong power_iterative_recursion_fast(long\
    \ x, long y)\n{\n    if (x < 0)\n    {\n        throw new IllegalArgumentException(\"\
    Negative power!\");\n    }\n    else if (y == 0)\n    {\n        return 1;\n \
    \   }\n    else if (y > 0)\n    {\n        return x * power_iterative_recursion_fast(x\
    \ * y, y - 1);\n    }\n}\n/*\nThe function pow_iterative_fast is an optimized\
    \ iterative implementation of the pow.\n*/\nlong pow_iterative_fast(long x, long\
    \ y)\n{\n    if (x < 0)\n    {\n        throw new IllegalArgumentException(\"\
    Negative power!\");\n    }\n    else if (y == 0)\n    {\n        return \nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqhhjoenn.d(127): Error: expression expected, not `unittest`

    /tmp/tmpqhhjoenn.d(128): Error: found `{` when expecting `;` following `return`
    statement

    /tmp/tmpqhhjoenn.d(136): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqhhjoenn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1L;\n    \n    for (long i = 2L; i <= n; i++) {\n        result\
    \ = result * (long) i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkltrdll4.d(21): Error: C style cast illegal, use `cast(long)i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkltrdll4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    \n    while (n > 0)\n    {\n        factorial *=\
    \ n--;\n    }\n    \n    return factorial;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0jb27yqf.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmp0jb27yqf.__unittest_L27_C1() [0x427a5a]

    ??:? void tmp0jb27yqf.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long sum = 1;\n    for (long i = 2; i <= n; ++i) {\n        sum *= i;\n \
    \   }\n    return sum;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7rmf3rtm.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmp7rmf3rtm.__unittest_L24_C1() [0x427a66]

    ??:? void tmp7rmf3rtm.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    while (n > 1) \n    { \n        factorial *= n;\
    \ \n        n--; \n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf_9irvva.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpf_9irvva.__unittest_L26_C1() [0x427a5a]

    ??:? void tmpf_9irvva.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    for(long i = 1; i <= n; i++) {\n        result *= i;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoe_7je4x.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmpoe_7je4x.__unittest_L24_C1() [0x427a62]

    ??:? void tmpoe_7je4x.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long ret = 1;\n    for (long i = 2; i <= n; i++) \n    {\n        ret = ret\
    \ * i;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8qyba82v.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmp8qyba82v.__unittest_L25_C1() [0x427a66]

    ??:? void tmp8qyba82v.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    for (; n > 0; n--) {\n        factorial *= n;\n\
    \    }\n    return factorial;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>\n\
    long brazilian_factorial(long n) {\n    long fact = 1;\n    long counter = 1;\n\
    \    while (n > 1) {\n        counter++;\n        n--;\n        fact = fact *\
    \ counter;\n    }\n    return fact;\n}\n</code>\n<|/ a tags=factorial,c++,algorithm\
    \ |>\n<| c |>\nWhile this code snippet may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a tags=factorial,c++,algorithm |>\n<code>\n#include\
    \ <iostream>\nusing namespace std;\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptp7hsptt.d(24): Error: declaration expected, not `<`

    /tmp/tmptp7hsptt.d(31): Error: declaration expected, not `while`

    /tmp/tmptp7hsptt.d(33): Error: no identifier for declarator `n`

    /tmp/tmptp7hsptt.d(33): Error: declaration expected, not `--`

    /tmp/tmptp7hsptt.d(34): Error: no identifier for declarator `fact`

    /tmp/tmptp7hsptt.d(34): Error: declaration expected, not `=`

    /tmp/tmptp7hsptt.d(35): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptp7hsptt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    while ( n > 0 ) {\n        fact *= n;\n        n--;\n\
    \    }\n    return fact;\n}\n/*\n    The Brazilian factorial is defined as:\n\
    \        brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n        where\
    \ n > 0\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpasfs1we6.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpasfs1we6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong result;\n\t\n\tif (n == 0) return 1;\n\t\n\tresult = factorial(n);\n\t\n\
    \treturn result * (n-1) * special_factorial(n-1);\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd0qt8ssn.d(22): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd0qt8ssn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    \n    for(long i = 2; i <= n; i++) \n    {\n   \
    \     factorial *= i;\n    }\n    \n    return factorial;\n}\n/*\nThe Sieve of\
    \ Eratosthenes algorithm is defined as:\n    \n    eratosthenes(n) = sieve of\
    \ eratosthenes for n numbers\n    where n = the smallest integer greater than\
    \ or equal to the number\n    \n    For example:\n    >>> eratosthenes(3)\n  \
    \  [2, 3]\n    \n    The function will receive an integer as input and should\
    \ return the list\n    of the prime numbers which are less than or equal to this\
    \ integer.\n    \n*/\nunittest\n{\n    alias candidate = special_factorial;\n\n\
    \    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n  \
    \  assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmfokmjgg.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpmfokmjgg.__unittest_L41_C1() [0x427a66]

    ??:? void tmpmfokmjgg.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long ans = 1;\n    while (n > 1) {\n        ans *= n;\n        n--;\n   \
    \ }\n    return ans;\n}\n/*\nThe function will receive an integer as input and\
    \ should return the Brazilian\nfactorial of this integer.\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6adm3jgg.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6adm3jgg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    for (long i = 1; i <= n; i++) \n        result *= i;\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp64td3lar.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmp64td3lar.__unittest_L23_C1() [0x427a62]

    ??:? void tmp64td3lar.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tif (n >= 2L)\n\t\treturn brazilian_factorial(n);\n\treturn 1L;\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0hsmsa1c.d(19): Error: undefined identifier `brazilian_factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0hsmsa1c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    long i;\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf1trbh73.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf1trbh73.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return (n == 0)? 1L : (1L * (n - 1)* special_factorial(n-1L));\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpz4xfwf6y.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpz4xfwf6y.__unittest_L20_C1() [0x427a66]

    ??:? void tmpz4xfwf6y.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    if (n != 0) {\n        fact = n * special_factorial(n\
    \ - 1);\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnxuoavhs.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpnxuoavhs.__unittest_L24_C1() [0x427a6a]

    ??:? void tmpnxuoavhs.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \t/*\n\t * factorial calculates x! and returns x\n\t * but we also need to include\
    \ n!\n\t */\n\tlong result = 0;\n\tlong fact = n;\n\t\n\tfor(long i = 1;i <= n;\
    \ i++)\n\t{\n\t\tfact = fact * i;\n\t\tresult = result + fact;\n\t}\n\treturn\
    \ result;\n}\n/*\n * Function definitions for Mathematica\n */\n/*\n * Mathematica\
    \ definitions\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Mathematica\n */\n/*\n * Function definitions for Fortran\n\
    \ */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function definitions\
    \ for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n\
    /*\n * Function definitions for Fortran\n */\n/*\n * Function definitions for\
    \ Fortran\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n\
    /*\n * Function definitions for Fortran\n */\n/*\n * Function definitions for\
    \ Fortran\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n\
    /*\n * Function definitions for Fortran\n */\n/*\n * Function definitions for\
    \ Fortran\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n\
    /*\n * Function definitions for Fortran\n */\n/*\n * Function definitions for\
    \ Fortran\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n\
    /*\n * Function definitions for Fortran\n */\n/*\n * Function definitions for\
    \ Fortran\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n\
    /*\n * Function definitions for Fortran\n */\n/*\n * Function definitions for\
    \ Fortran\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Fortran\n */\n/*\n * Function definitions for Fortran\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpchh6gnge.d(149): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpchh6gnge.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tlong result = 1;\n\twhile(n>0){\n\t\tresult = result * n;\n\t\tn--;\n\t}\n\t\
    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n \
    \   assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n   \
    \ assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuymr58ec.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpuymr58ec.__unittest_L25_C1() [0x427a5a]

    ??:? void tmpuymr58ec.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    return factorial(n) * factorial(n-1);\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc2xhp9t8.d(18): Error: undefined identifier `factorial`

    /tmp/tmpc2xhp9t8.d(18): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc2xhp9t8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    long temp;\n    for (long i = 2; i <= n; i++) {\n \
    \       temp = result * i;\n        result = temp;\n    }\n    return result;\n\
    }\n/*\n    The function returns the binomial coefficient.\n    \n    It is defined\
    \ as:\n        binomial_coefficient(n,k) = n! / (k! * (n - k)!)\n    \n    For\
    \ example:\n    >>> binomial_coefficient(4L,2L)\n    12L\n*/\nlong binomial_coefficient(long\
    \ n, long k) \n{\n    return factorial(n) / (factorial(k) * factorial(n - k));\n\
    }\n/*\n    The function returns the binomial coefficient with the precision of\
    \ 64 bit.\n    \n    It is defined as:\n        binomial_coefficient_64(n,k) =\
    \ n! / (k! * (n - k)!)\n    \n    For example:\n    >>> binomial_coefficient_64(4L,2L)\n\
    \    12L\n*/\nlong binomial_coefficient_64(long n, long k) \n{\n    return factorial_64(n)\
    \ / (factorial_64(k) * factorial_64(n - k));\n}\n/*\n    The function returns\
    \ the binomial coefficient in float format.\n    \n    It is defined as:\n   \
    \     binomial_coefficient(float,float)\n    \n    For example:\n    >>> binomial_coefficient(float('inf'),float('inf'))\n\
    \    0.0\n*/\ndouble binomial_coefficient(double n, double k) \n{\n    return\
    \ factorial(n) / (factorial(k) * factorial(n - k));\n}\n/*\n    The function returns\
    \ the binomial coefficient in float format in 64 bit.\n    \n    It is defined\
    \ as:\n        binomial_coefficient_64(float,float)\n    \n    For example:\n\
    \    >>> binomial_coefficient_64(float('inf'),float('inf'))\n    0.0\n*/\ndouble\
    \ binomial_coefficient_64(double n, double k) \n{\n    return factorial_64(n)\
    \ / (factorial_64(k) * factorial_64(n - k));\n}\n/*\n    The function returns\
    \ the factorial of the integer.\n    \n    It is defined as:\n        factorial(n)\
    \ = n!\n    \n    For example:\n    >>> factorial(4L)\n    24L\n*/\nlong factorial(long\
    \ n) \n{\n    long result = 1;\n    long temp;\n    for (long i = 2; i <= n; i++)\
    \ {\n        temp = result * i;\n        result = temp;\n    }\n    return result;\n\
    }\n/*\n    The function returns the factorial of the float format of the integer.\n\
    \    \n    It is defined as:\n        factorial(n) = n!\n    \n    For example:\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd94mx28z.d(102): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd94mx28z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    for (long i = 1; i <=n; i *= n)\n        fact = fact\
    \ * i;\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsdc0d_y_.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmpsdc0d_y_.__unittest_L23_C1() [0x427a6e]

    ??:? void tmpsdc0d_y_.__modtest() [0x427af4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \tif(n == 0)\n\t\treturn 1;\n\tlong res = 1;\n\twhile(n-- > 0) res *= (n+1);\n\
    \treturn res;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n  \
    \  assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L)\
    \ == 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoyvbsloh.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d75]

    ??:? void tmpoyvbsloh.__unittest_L24_C1() [0x427a6e]

    ??:? void tmpoyvbsloh.__modtest() [0x427af4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba9b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a92e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fac1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff70]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa4d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a905]

    ??:? runModuleUnitTests [0x42b871]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281c4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    while(n > 0)\n    {\n        fact = fact * n;\n     \
    \   n--;\n    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpljlyquk7.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmpljlyquk7.__unittest_L26_C1() [0x427a5a]

    ??:? void tmpljlyquk7.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    \n    for (long i=2; i<=n; ++i) {\n        result *=\
    \ i;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3on2e6e4.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmp3on2e6e4.__unittest_L26_C1() [0x427a66]

    ??:? void tmp3on2e6e4.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    for(int i=1;i<=n;i++)\n    {\n        factorial\
    \ *= i;\n    }\n    return factorial;\n}\n/*\nA function named factorial is used\
    \ for computing factorials.\nThis function takes one argument, which is a number.\
    \ \nIt should return the factorial of that number.\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz1e8dg5e.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz1e8dg5e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1L;\n    while (n > 1L) {\n        factorial *= n--;\n \
    \   }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7guku5yl.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d5d]

    ??:? void tmp7guku5yl.__unittest_L24_C1() [0x427a5a]

    ??:? void tmp7guku5yl.__modtest() [0x427ae0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a916]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faa9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff58]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8ed]

    ??:? runModuleUnitTests [0x42b859]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long result = 1;\n    for(long i = 1; i <= n; ++i)\n    {\n        result\
    \ *= i;\n    }\n    return result;\n}\n/*\nThe Brazilian Factorial of a number\
    \ is the number multiplied by itself, n times\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6jud4cus.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6jud4cus.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    long fact = 1;\nfor(long i = 1; i <= n; i++)\nfact*=(long long )i;\nreturn fact;\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptftijjuc.d(20): Error: found `long` when expecting `.` following
    long

    /tmp/tmptftijjuc.d(20): Error: found `)` when expecting identifier following `long`.

    /tmp/tmptftijjuc.d(20): Error: found `i` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptftijjuc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164021
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fac = 1L;\n    for (int i = 1; i <=n; i++) {\n        fac *= i;\n  \
    \  }\n    return fac;\n}\n/*\nThis function should return True if the number n\
    \ is odd and False otherwise.\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvit1oqwt.d(24): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvit1oqwt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long f = 1;\n    long p;\n    for (p = 1; p <= n; p++)\n        f *= p;\n\
    \    return f;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\n \
    \   assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n   \
    \ assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0dhx5syo.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmp0dhx5syo.__unittest_L24_C1() [0x427a6a]

    ??:? void tmp0dhx5syo.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result\
    \ = result * i;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpng44__oq.d(18): Error: use `long` for a 64 bit integer instead
    of `long long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpng44__oq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    long i;\n    for(i = 0; i < n; i++){\n        factorial\
    \ *= i;\n    }\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcov3eueh.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpcov3eueh.__unittest_L25_C1() [0x427a6a]

    ??:? void tmpcov3eueh.__modtest() [0x427af0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    for (long i = 1L; i <= n; i++) {\n        fact *= i;\n\
    \    }\n    return fact;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9fklgi_d.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d65]

    ??:? void tmp9fklgi_d.__unittest_L24_C1() [0x427a62]

    ??:? void tmp9fklgi_d.__modtest() [0x427ae8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a91e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff60]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8f5]

    ??:? runModuleUnitTests [0x42b861]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1L;\n    for(long i = 2L; i <= n; i++)\n        factorial\
    \ *= i;\n    return factorial;\n}\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyc9_f9po.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427d6d]

    ??:? void tmpyc9_f9po.__unittest_L23_C1() [0x427a66]

    ??:? void tmpyc9_f9po.__modtest() [0x427aec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42ba93]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a926]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fab9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ff68]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa45]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a8fd]

    ??:? runModuleUnitTests [0x42b869]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281bc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long fact = 1;\n    long fact2;\nunittest\n{\n    alias candidate = special_factorial;\n\
    \n    assert(candidate(4L) == 288L);\n    assert(candidate(5L) == 34560L);\n \
    \   assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L) == 1L);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsx5lfb5x.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsx5lfb5x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    if(n<0)\n    {\n        throwException(new RangeException(\"n should be positive\"\
    ));\n        return 0;\n    }\n    \n    long factor = 1L;\n    for(int i = 1L;\
    \ i<=n; i++)\n    {\n        factor *= i;\n    }\n    return factor;\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptqilen31.d(20): Error: undefined identifier `throwException`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptqilen31.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long f = factorial(n);\n    \n    while(f > 1L) {\n        f = f * (n-1);\n\
    \        \n        if (f > 1L) {\n            f = f * (n-2);\n            \n \
    \           if (f > 1L) {\n                f = f * (n-3);\n                \n\
    \                if (f > 1L) {\n                    f = f * (n-4); \n        \
    \        }\n            }\n        }\n    }\n    \n    return f;\n}\nunittest\n\
    {\n    alias candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n\
    \    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
    \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaao8zwyh.d(18): Error: undefined identifier `factorial`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaao8zwyh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \t\n\tlong f = 1;\n\tlong i;\n\t\n\tif (n==1)\n\t{\n\t\treturn 1;\n\t}\n\tif (n>0)\n\
    \t{\n\t\tfor (i=1; i<=n; i++)\n\t\t{\n\t\t\tf = f * i;\n\t\t}\n\t}\n\treturn f;\n\
    }\n/*\nThe Brazilian nCr is defined as:\n    nCr(n, r) = n! / r! (n-r)!\n    where\
    \ n and r are natural numbers.\n*/\nlong brazilian_ratio_factorial(long n, long\
    \ r)\n{\n\tlong f = special_factorial(n);\n\t\n\treturn f/special_factorial(r);\n\
    }\nunittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf528el_x.d(50): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dfd]

    ??:? void tmpf528el_x.__unittest_L46_C1() [0x427af6]

    ??:? void tmpf528el_x.__modtest() [0x427b7c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fad5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a98d]

    ??:? runModuleUnitTests [0x42b8f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42824c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long ret = 1;\n    for (long i = 1; i <= n; i++)\n    {\n        ret *= i;\n\
    \    }\n    return ret;\n}\n/*\nThis function implements the Fibonacci numbers\
    \ using the recursive formula:\n    fibonacci(n) = fibonacci(n-1) + fibonacci(n-2)\n\
    unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
    \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) ==\
    \ 125411328000L);\n    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcjg2dpph.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcjg2dpph.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164022
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is\
    \ defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n\
    \    where n > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\
    \n    The function will receive an integer as input and should return the special\n\
    \    factorial of this integer.\n    \n*/\nlong special_factorial(long n) \n{\n\
    \    long factorial = 1;\n    long counter = n;\n    while (counter > 0) \n  \
    \  {\n        factorial *= counter;\n        counter--;\n    }\n    return factorial;\n\
    }\n/*\nThe Roman factorial is defined as:\n    roman_factorial(n) = n! / v! *\
    \ (n-v)! * ... * (n-1)! * v!\n    where n >= 0 and v > n\nunittest\n{\n    alias\
    \ candidate = special_factorial;\n\n    assert(candidate(4L) == 288L);\n    assert(candidate(5L)\
    \ == 34560L);\n    assert(candidate(7L) == 125411328000L);\n    assert(candidate(1L)\
    \ == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn7ebl8s6.d(27): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn7ebl8s6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164022
