name: HumanEval_88_sort_array
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given an array of non-negative\
  \ integers, return a cod of the given array after sorting,\n    you will sort the\
  \ given array in ascending order if the sum( first index value, last index value)\
  \ is odd,\n    or sort it in descending order if the sum( first index value, last\
  \ index value) is even.\n\n    Note:\n    * don't change the given array.\n\n  \
  \  Examples:\n    >>> sort_array([])\n    []\n    >>> sort_array([5L])\n    [5L]\n\
  \    >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L])\n    [0L, 1L, 2L, 3L, 4L, 5L]\n  \
  \  >>> sort_array([2L, 4L, 3L, 0L, 1L, 5L, 6L])\n    [6L, 5L, 4L, 3L, 2L, 1L, 0L]\n\
  \    \n*/\nlong[] sort_array(long[] array) \n"
tests: "unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([])\
  \ == []);\n    assert(candidate([5L]) == [5L]);\n    assert(candidate([2L, 4L, 3L,\
  \ 0L, 1L, 5L]) == [0L, 1L, 2L, 3L, 4L, 5L]);\n    assert(candidate([2L, 4L, 3L,\
  \ 0L, 1L, 5L, 6L]) == [6L, 5L, 4L, 3L, 2L, 1L, 0L]);\n    assert(candidate([2L,\
  \ 1L]) == [1L, 2L]);\n    assert(candidate([15L, 42L, 87L, 32L, 11L, 0L]) == [0L,\
  \ 11L, 15L, 32L, 42L, 87L]);\n    assert(candidate([21L, 14L, 23L, 11L]) == [23L,\
  \ 21L, 14L, 11L]);\n}\nvoid main(){}"
completions: ["{\n    if(array.length==0)\n        return array;\n    long[] result\
    \ = new long[array.length];\n    long sum;\n    for(int i=0; i<array.length; i++)\n\
    \    {\n        sum = 0;\n        for(int j=i; j<array.length; j++)\n        \
    \    sum+=array[j];\n        if(sum%2==1)\n            for(int j=i; j<array.length;\
    \ j++)\n                result[j]=array[j];\n        else\n            for(int\
    \ j=i; j<array.length; j++)\n                result[j]=array[array.length-j-1];\n\
    \    }\n    return result;\n}", "{\n    long sum = 0;\n    long long sum2 = 0;\n\
    \    long sum3 = 0;\n    long sum4 = 0;\n    long sum5 = 0;\n    long sum6 = 0;\n\
    \    long sum7 = 0;\n    long sum8 = 0;\n    int temp = 0;\n    int temp2 = 0;\n\
    \    int temp3 = 0;\n    int temp4 = 0;\n    int temp5 = 0;\n    int temp6 = 0;\n\
    \    int temp7 = 0;\n    int temp8 = 0;\n    int temp9 = 0;\n    int temp10 =\
    \ 0;\n    int temp11 = 0;\n    int temp12 = 0;\n    int temp13 = 0;\n    int temp14\
    \ = 0;\n    int temp15 = 0;\n    int temp16 = 0;\n    int temp17 = 0;\n    int\
    \ temp18 = 0;\n    int temp19 = 0;\n    int temp20 = 0;\n    int temp21 = 0;\n\
    \    int temp22 = 0;\n    int temp23 = 0;\n    int temp24 = 0;\n    int temp25\
    \ = 0;\n    int temp26 = 0;\n    int temp27 = 0;\n    int temp28 = 0;\n    int\
    \ temp29 = 0;\n    int temp30 = 0;\n    int temp31 = 0;\n    int temp32 = 0;\n\
    \    int temp33 = 0;\n    int temp34 = 0;\n    int temp35 = 0;\n    int temp36\
    \ = 0;\n    int temp37 = 0;\n    int temp38 = 0;\n    int temp39 = 0;\n    int\
    \ temp40 = 0;\n    int temp41 = 0;\n    int temp42 = 0;\n    int temp43 = 0;\n\
    \    int temp44 = 0;\n    int temp45 = 0;\n    int temp46 = 0;\n    int temp47\
    \ = 0;\n    int temp48 = 0;\n    int temp49 = 0;\n    int temp50 = 0;\n    int\
    \ temp51 = 0;\n    int temp52 = 0;\n    int temp53 = 0;\n    int temp54 = 0;\n\
    \    int temp55 = 0;\n    int temp56 = 0;\n    int temp57 = 0;\n    int temp58\
    \ = 0;\n    int temp59 = 0;\n    int temp60 = 0;\n    int temp61 = 0;\n    int\
    \ temp62 = 0;\n    int temp63 = 0;\n    int temp64 = 0;\n    int temp65 = 0;\n\
    \    int temp66 = 0;\n    int temp67 = 0;\n    int temp68 = 0;\n    int temp69\
    \ = 0;\n    int temp70 = 0;\n    int temp71 = 0;\n    int temp72 = 0;\n    int\
    \ temp73 = 0;\n    int temp74 = 0;\n    int temp75 = 0;\n    int temp76 = 0;\n\
    \    int temp77 = 0;\n    int temp78 = 0;\n    int temp79 = 0;\n    int temp80\
    \ = 0;\n    int temp81 = 0;\n    int temp82 = 0;\n    int temp83 = 0;\n    int\
    \ temp84 = 0;\n    int temp85 = 0;\n    int temp86 = 0;\n    int temp87 = 0;\n\
    \    int temp88 = 0;\n    int temp89 = 0;\n    int temp90 = 0;\n    int temp91\
    \ = 0;\n    int temp92 = 0;\n    int temp93 = 0;\n    int temp94 = 0;\n    int ",
  "{\n    // write your code here\n    if (array.Length == 0)\n        return array;\n\
    \    long sum = 0;\n    long[] result = new long[array.Length];\n    for (int\
    \ i = 0; i < array.Length; i++)\n    {\n        sum += array[i];\n        if (sum\
    \ % 2 == 1)\n        {\n            int j = i;\n            while (j < array.Length)\n\
    \            {\n                sum += array[j];\n                if (sum % 2\
    \ == 1)\n                {\n                    result[i] = array[j];\n      \
    \              result[j] = array[i];\n                    i++;\n             \
    \       j--;\n                    sum -= array[i];\n                }\n      \
    \          else\n                    break;\n            }\n        }\n      \
    \  else\n            result[i] = array[i];\n    }\n    long[] ret = new long[array.Length];\n\
    \    for (int i = 0; i < ret.Length; i++)\n        ret[i] = result[i];\n    return\
    \ ret;\n}", "{\n    int n = array.length;\n    if (n <= 1) \n        return array;\n\
    \    long last_index = n;\n    for (int i = 1; i < n; i++) {\n        int cur_sum\
    \ = std.math.add(array[i], array[last_index]);\n        if (cur_sum % 2 == 1)\
    \ {\n            std.typecons.reverseInPlace(array, last_index, i);\n        \
    \    return array;\n        }\n        last_index = i;\n    }\n    std.typecons.reverseInPlace(array,\
    \ last_index, n);\n    return array;\n}\n</code>\n<|/ a tags=java dscore=1 |>\n\
    <| a |>\n<code>\n/**\n * Definition for singly-linked list.\n * struct ListNode\
    \ {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) : val(x),\
    \ next(NULL) {}\n * };\n */\nclass Solution {\n    public ListNode sort(ListNode\
    \ head) {\n        if (head == null) return head;", "{\n    long sum=0;\n    long\
    \ n=0;\n    for(int i=0; i< array.length; i++)\n    {\n        sum+=array[i];\n\
    \        n++;\n        if(n%2==0)\n        {\n            long temp = array[i];\n\
    \            array[i] = array[n-1];\n            array[n-1] = temp;\n        \
    \    sum-=array[i];\n            n--;\n        }\n    }\n    return array;\n}",
  "{\n    long[] output = new long[array.length];\n    long sum = 0;\n    for (int\
    \ i = 0; i < array.length; i++){\n        sum += array[i];\n    }\n    \n    if(sum%2\
    \ ==0){\n        for(int i = 0; i < array.length; i++){\n            output[i]\
    \ = array[i];\n        }\n        Arrays.sort(output);\n    }else{\n        Arrays.sort(output);\n\
    \        Arrays.sort(output,1,array.length);\n    }\n    return output;\n}\n</code>\n\
    <|/ a tags=algorithm,sorting dscore=2 |>\n<| c |>\nThe above answer has a bug\
    \ in it. Suppose the length of the array is even and sum is even. Then the sum\
    \ will be the original array length after the sort is done.\n<|/ c |>\n<| c |>\n\
    Yes, I forgot to account for the even case. I've edited the answer to account\
    \ for this.\n<|/ c |>\n<| a dscore=2 tags=algorithm,sorting |>\n<code>\npublic\
    \ static void sort(int[] nums) {\n    List<Integer> list = new ArrayList<Integer>(Arrays.asList(nums));\n\
    \    Collections.sort(list);\n    for (int i = 0; i < list.length; i++) {\n  \
    \      nums[i] = list.get(i);\n    }\n}\n</code>\n<|/ a |>\n<| a |>\nYou can use\
    \ Arrays.sort() to do this.\n<code>\nimport java.util.Arrays;", "{\n    /*\n \
    \       Implement a sort algorithm here\n    */\n    long[] result = new long[array.length];\n\
    \    long sum = 0;\n    for(int i=0; i < array.length; i++)\n    {\n        sum+=array[i];\n\
    \    }\n    if(sum%2 == 1)\n    {\n        std.arraycopy(array, 0,result, 0, array.length);\n\
    \        std.sort(result, 0, array.length);\n    }\n    else\n    {\n        std.arraycopy(array,\
    \ 0,result, 0, array.length);\n        std.sort(result, 0, array.length, Comparer.descending(array[0]));\n\
    \    }\n    return result;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nHere's a more\
    \ efficient way to solve this problem.\nThe code below takes O(n log n) time to\
    \ sort the array.\n<code>\npublic static int[] sortArray(int[] arr) {\n    int[]\
    \ sortedArray = Arrays.copyOf(arr, arr.length);\n    int sum = 0;\n    \n    for\
    \ (int i = 0; i < arr.length; i++) {\n        sum += arr[i];\n    }", "{\n   \
    \ long sum = 0;\n    long n = array.length;", "{\n    if( array.lenght < 1 )\n\
    \        return array;\n    long[] result = new long[array.lenght];\n    long\
    \ cur = array[0];\n    long last = array[array.lenght - 1];\n    \n    if( cur\
    \ % 2 == 0 )\n    {\n        sort_array(array.subarray(1, array.lenght - 1), result);\n\
    \        sort_array(array.subarray(0, array.lenght - 1), result);\n    }\n   \
    \ else\n    {\n        sort_array(array.subarray(1, array.lenght - 1), result);\n\
    \        sort_array(array.subarray(array.lenght - 2, array.lenght), result);\n\
    \    }\n    \n    for( int i = 0; i < result.lenght; i++ )\n        result[i]\
    \ = cur;\n    \n    return result;\n}", "{\n    int len = array.length;\n    \n\
    \    if ( len < 2)\n        return array;\n    \n    long sum = 0;\n    for (int\
    \ i = 0; i < len; i++)\n    {\n        sum += array[i];\n    }\n    \n    // for\
    \ odd sum\n    if ( sum % 2 == 1)\n    {\n        for (int i = 0; i < len; i++)\n\
    \        {\n            int j;\n            \n            for (j = i; j < len;\
    \ j++)\n            {\n                if ( array[j] < array[i])\n           \
    \     {\n                    break;\n                }\n                \n   \
    \             if ( j == len - 1)\n                    break;\n            }\n\
    \            \n            if ( j < len - 1)\n            {\n                long[]\
    \ temp = array;\n                array = new long[len];\n                for (int\
    \ k = 0; k < j; k++)\n                    array[k] = temp[k];\n            }\n\
    \        }\n        \n        for (int i = len - 1; i >= 0; i--)\n        {\n\
    \            int j;\n            \n            for (j = len - 1; j >= i; j--)\n\
    \            {\n                if ( array[j] > array[i])\n                {\n\
    \                    break;\n                }\n                \n           \
    \     if ( j == 0)\n                    break;\n            }\n            \n\
    \            if ( j >= i)\n            {\n                long[] temp = array;\n\
    \                array = new long[len];\n                for (int k = 0; k < i;\
    \ k++)\n                    array[k] = temp[k];\n            }\n        }\n  \
    \  }\n    \n    // for even sum\n    else\n    {\n        for (int i = 0; i <\
    \ len; i++)\n        {\n            int j;\n            \n            for (j =\
    \ i; j < len; j++)\n            {\n                if ( array[j] > array[i])\n\
    \                {\n                    break;\n                }\n          \
    \      \n                if ( j == len - 1)\n                    break;\n    \
    \        }\n            \n            if ( j < len - 1)\n            {\n     \
    \           long[] temp = array;\n                array = new long[len];\n   \
    \             for (int k = 0; k < j; k++)\n                    array[k] = temp[k];\n\
    \            }\n        }\n        \n        for (int i = len - 1; i >= 0; i--)\n\
    \        {\n            int j;\n            \n            for (j = len - 1; j\
    \ >= i; j--)\n            {\n                if ( array[j] < array[i])\n     \
    \           {\n                    break;\n                }\n               \
    \ \n                if ( j == 0)\n                    break;\n            }\n\
    \            \n            if ( j >= i)\n            {\n                long[]\
    \ temp = array;\n                array = new long[len];\n                for (int\
    \ k = 0; k < i; k++)\n                    array[k] = temp[k];\n            }\n\
    \        }\n    }\n    \n    return array;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>",
  "{\n    int len = array.length;\n    int i, sum = 0;\n    long[] res = new long[len];\n\
    \    long temp = 0;\n    for (i = 0; i < len; i++)\n    {\n        temp = array[i];\n\
    \        sum += temp;\n    }\n    \n    if (sum % 2 == 1)\n    {\n        for\
    \ (i = 0; i < len - 1; i++)\n        {\n            if (array[i] < array[len -\
    \ 1])\n            {\n                long temp1 = array[i];\n               \
    \ long temp2 = array[len - 1];\n                long temp3;\n                temp\
    \ = temp1;\n                array[i] = temp2;\n                array[len - 1]\
    \ = temp3;\n            }\n        }\n    }\n    else\n    {\n        for (i =\
    \ 0; i < len - 1; i++)\n        {\n            if (array[i] > array[len - 1])\n\
    \            {\n                long temp1 = array[i];\n                long temp2\
    \ = array[len - 1];\n                long temp3;\n                temp = temp1;\n\
    \                array[i] = temp2;\n                array[len - 1] = temp3;\n\
    \            }\n        }\n    }\n    \n    for (i = 0; i < len; i++)\n    {\n\
    \        res[i] = array[i];\n    }\n    return res;\n}", "{\n    if (array.length\
    \ <= 0) \n        return array;\n    long first = 0;\n    long last = array.length-1;\n\
    \    long total = 0;\n    bool odd = (array[first]%2!=0);\n    do {\n        total\
    \ = first + last;\n        if (total%2==0) {\n            if (odd)\n         \
    \       last--;\n            else\n                first++;\n        }\n     \
    \   else {\n            if (odd)\n                first++;\n            else\n\
    \                last--;\n        }\n        odd = (array[last]%2!=0);\n    }\
    \ while (first < last);\n    return array;\n}\n</code>\n<|/ a tags=c++,sorting,arrays\
    \ dscore=0 |>\n<| c |>\nWhile this code may solve the question, [including an\
    \ explanation](//meta.stackexchange.com/q/114762) of how and why this solves the\
    \ problem would really help to improve the quality of your post, and probably\
    \ result in more up-votes. Remember that you are answering the question for readers\
    \ in the future, not just the person asking now. Please [edit] your answer to\
    \ add explanations and give an indication of what limitations and assumptions\
    \ apply.\n<|/ c |>\n<| c |>\nThe explanation is now in the answer.\n<|/ c |>\n\
    <| c |>\nAh, thank you! I didn't realize that my professor had the code explained\
    \ to me in a different way. I was confused by the lack of explanation given in\
    \ the book I was using.\n<|/ c |>\n<| c |>\nThank you, for pointing that out -\
    \ I added some explanation that I think makes it more clear to people that way\
    \ :)\n<|/ c |>\n<| c |>\nNice code, but for large arrays it will be much slower.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;\nimport java.io.*;\nimport\
    \ java.lang.*;\nimport java.math.*;\nimport java.util.regex.*;", "{\n    int i;\n\
    \    long sum=0;\n    for (i=1; i<array.length; i++) \n    {\n        sum+=array[i-1];\n\
    \        sum+=array[i];\n        array[i]=sum;\n    }\n    \n    long min = -array[0];\n\
    \    for (i=1; i<array.length; i++) \n    {\n        if (array[i] < min) \n  \
    \          min = array[i];\n    }\n    \n    return array.clone();\n}\n</code>\n\
    <|/ a tags=arrays,algorithm,sorting,java |>\n<| a tags=arrays,algorithm,sorting,java\
    \ dscore=0 |>\nTo find minimum element in array use below code:\n<code>", "{\n\
    \    long[] result = array;\n    int sum = 0;\n    for(int i = 1; i < result.length;\
    \ i++){\n        sum += result[i];\n        if(sum == 0){\n            throw new\
    \ RuntimeException(\"Error: sum equals zero\");\n        }\n    }\n    long min\
    \ = result[0];\n    long max = result[0];\n    for(int i = 0; i < result.length;\
    \ i++){\n        sum += result[i];\n        if(sum % 2 == 1){\n            max\
    \ = result[i];\n        }else{\n            min = result[i];\n        }\n    }\n\
    \    \n    Arrays.sort(result);\n    \n    ArrayList list = new ArrayList(Arrays.asList(result));\n\
    \    for(int i = result.length-1; i >= 0; i--){\n        if(list.get(i) < min){\n\
    \            int index = 0;\n            for(int j = i; j < result.length; j++){\n\
    \                if(list.get(j) < min){\n                    index = j;\n    \
    \            }\n            }\n            \n            ArrayList temp = new\
    \ ArrayList(Arrays.asList(result, index + 1, i + 1));\n            temp.remove(i);\n\
    \            temp.add(i, min);\n            result = temp.toArray(result);\n \
    \           return result;\n        }\n        \n        if(list.get(i) > max){\n\
    \            int index = 0;\n            for(int j = i; j < result.length; j++){\n\
    \                if(list.get(j) > max){\n                    index = j;\n    \
    \            }\n            }\n            \n            ArrayList temp = new\
    \ ArrayList(Arrays.asList(result, index + 1, i + 1));\n            temp.remove(i);\n\
    \            temp.add(i, max);\n            result = temp.toArray(result);\n \
    \           return result;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=java,arrays dscore=2 |>\n<| a tags=java,arrays |>\n<code>\npublic int[]\
    \ sortArray(int[] array){\n    int[] sortedArray = new int[array.length];\n  \
    \  int sum = 0;\n    for(int i = 1; i < array.length; i++){\n        sum = sum\
    \ + array[i];\n        if(sum % 2 == 0){\n            sortedArray[i] = array[i];\n\
    \        }else{\n            sortedArray[i] = array[i - 1];\n        }\n    }\n\
    \    return sortedArray;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhy would you\
    \ use `int` arrays when you can do `int[]`?\n<|/ c |>\n<| c |>\nbecause OP wanted\
    \ an array\n<|/ c |>\n<| a dscore=2 |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\
    import java.util.Scanner;", "{\n    long sum = 0;\n    int index = 0;\n    long\
    \ max = array[0];\n    for(long i:array){\n        sum += i;\n        if(sum >\
    \ max)\n            max = sum;\n    }", "{\n    long sum = 0;\n    long[] sortedArr\
    \ = new long[array.length];\n    for(int i=0;i<array.length;i++){\n        sum\
    \ += array[i];\n        if(sum%2==1)\n            sortedArr[i] = array[i];\n \
    \       else\n            sortedArr[i] = array[array.length-1-i];\n    }\n   \
    \ return sortedArr;\n}\n</code>\n<|/ a dscore=0 tags=java,algorithm |>\n<| c |>\n\
    Your method does not return `[0 1 2 3 4 5]` as it should, because it returns `[4\
    \ 3 2 1 0 5]`\n<|/ c |>\n<| a dscore=0 |>\nHere is my implementation in Java,\
    \ where I added a special case for the last number in the array.\n<code>\npublic\
    \ static int[] sortArray(int[] a) {\n    final int[] res = new int[a.length];\n\
    \    int count = 0;\n    int i = 1;\n    int sum = 0;\n    for (int j = 1; j <\
    \ a.length; j++) {\n        if (a[j] > 0) {\n            sum -= a[j];\n      \
    \      sum -= a[j - 1];\n            res[count++] = a[j];\n            res[count++]\
    \ = a[j - 1];\n            if (j != a.length - 1) {\n                a[j] = 0;\n\
    \                a[j - 1] = 0;\n            }\n        } else {\n            a[j]\
    \ = 0;\n            a[j - 1] = 0;\n        }\n    }\n    if (count > 0) {\n  \
    \      res[count] = sum;\n    }\n    return res;\n}\n</code>\n<|/ a tags=java,algorithm\
    \ |>\n<| a tags=java,algorithm |>\nThis is my solution which uses ArrayList instead\
    \ of array and also has O(n) complexity.\n<code>\npublic class SortingCod {",
  "{\n    long[] sortedArray = new long[array.length];\n    int sum = 0;\n    for(int\
    \ i = 1; i < array.length; i++)\n    {\n        sum += array[i];\n        sortedArray[i\
    \ - 1]  = array[i];\n    }\n    for(int i = 1; i < array.length; i++)\n    {\n\
    \        long value = array[i];\n        if(sum % 2 == 1)\n        {\n       \
    \     sum -= value;\n            sortedArray[i - 1]  = value;\n        }\n   \
    \     else\n        {\n            sum += value;\n            sortedArray[i -\
    \ 1]  = value;\n        }\n    }\n    return sortedArray;\n}\n</code>\n<|/ a |>\n\
    <| a |>\n<code>", "{\n    long sum=0;\n    long max=-1000000000L;\n    long min=1000000000L;\n\
    \    long sum2=0;\n    long sum3=0;\n    for(int i=0;i<array.length;i++)\n   \
    \ {\n        sum+=array[i];\n        sum2+=array[i]*array[i];\n        sum3+=array[i]*array[i];\n\
    \        max=Math.max(max,sum);\n        min=Math.min(min,sum);\n    }\n    if(sum%2==0)\n\
    \    {\n        for(int i=0;i<array.length;i++)\n        {\n            if((array[i]-sum)<min)\n\
    \            {\n                long temp=array[i];\n                array[i]=array[sum3-sum+i];\n\
    \                array[sum3-sum+i]=temp;\n            }\n        }\n    }\n  \
    \  else\n    {\n        for(int i=0;i<array.length;i++)\n        {\n         \
    \   if((array[i]-sum)>max)\n            {\n                long temp=array[i];\n\
    \                array[i]=array[sum2-sum+i];\n                array[sum2-sum+i]=temp;\n\
    \            }\n        }\n    }\n    return array;\n}\n</code>\n<|/ a tags=algorithm,sorting,arrays,big-o,c#\
    \ |>\n<| c |>\nAwesome answer!  I'm just curious, what's the use of the two `for`\
    \ loops, to sort the array?  Why not just run a nested `for` loop that does all\
    \ three?  I'm assuming that's what the OP wanted?  This way the algorithm would\
    \ still work even if the array was of different sizes (since it checks every element\
    \ once), which would improve performance.\n<|/ c |>\n<| c |>\nI believe this is\
    \ O(n^2) algorithm (nested loop). Sorting algorithm which I posted is more effective\
    \ than this one. Check out [this](http://www.geeksforgeeks.org/sort-array-java/)\
    \ sorting algorithm\n<|/ c |>\n<| c |>\nThanks for the comment, I've just edited\
    \ my answer with working C# code.\n<|/ c |>\n<| c |>\n: It's O(N^2). Sorting the\
    \ entire array doesn't just take N steps, it takes N x N steps. Sorting the first\
    \ and last elements in the array takes 1 step each. Sorting the last and first\
    \ elements in the array takes 1 x N steps each. So O(N^2).\n<|/ c |>\n<| c |>\n\
    Yes, you are right, I should have mentioned that sorting algorithm is more effective\
    \ than this one since it takes less steps. ", "{\n  long[] res = new long[array.length];\n\
    \  long sum = 0;", "{\n    int sum = 0;\n    for (long x : array) {\n        sum\
    \ += x;\n    }\n    if (sum % 2 == 1) {\n        long[] result = new long[array.length];\n\
    \        Arrays.sort(array, (a, b) -> a - b);\n        for (long x : array) {\n\
    \            result[x] = x;\n        }\n        return result;\n    }\n    else\
    \ {\n        long[] result = new long[array.length];\n        Arrays.sort(array,\
    \ (a, b) -> b - a);\n        for (long x : array) {\n            result[x] = x;\n\
    \        }\n        return result;\n    }\n}\n</code>\n<|/ a |>\n<| c |>\nI see\
    \ this as a pretty good solution, thanks!\n<|/ c |>\n<| c |>\nI appreciate your\
    \ solution, it's definitely worth mentioning that this approach requires Java\
    \ 8.\n<|/ c |>\n<| a |>\nThis problem is fairly simple to solve, although I do\
    \ recommend using other people's solutions since they're much more efficient and\
    \ are much simpler to read. \nBasically you want to sort an array such that if\
    \ two numbers in the array are even, the smaller number will come first. If two\
    \ numbers are odd, the larger number will come first. \nIn your example, the array\
    \ looks like this:\n<code>\n[5, 1, 3, 2]\n</code>\nLet's sort it like this:\n\
    <code>\n[2, 3, 1, 5]\n</code>\nThis is because the sum of the first two elements\
    \ is even, and so the smaller number will come first:\n<code>\n2 + 3 = 5\n</code>\n\
    The sum of the next two elements is odd, and so the larger number will come first:\n\
    <code>\n2 + 4 = 6\n</code>\nThe sum of all the elements is even, and so the smaller\
    \ number will come first:\n<code>\n5 + 6 = 10\n</code>\nWe can implement this\
    \ in O(n) by going through each element of the array, and keeping track of the\
    \ largest and smallest element seen. Then, when we've finished going through each\
    \ element, we'll compare the elements and swap them in the array.\n<code>\npublic\
    \ static void sortEvenOdd(int[] nums) {\n    int largest = Integer.MIN_VALUE;\n\
    \    int smallest = Integer.MAX_VALUE;", "{\n    long[] sorted = new long[array.length];\n\
    \    for (int i = 0; i < array.length; i++)\n        sorted[i] = array[i];", "{\n\
    \  int len = array.length;\n  long[] result = new long[len];\n  int i = 0, j =\
    \ 0;\n  int sum = 0;\n  int oddSum = 0;", "{\n    if (array.length == 0)\n   \
    \     return array;\n    int sum = 0;\n    long temp;\n    for (int i = 0; i <\
    \ array.length; i++) \n    {\n        sum += array[i];\n    }\n    if (sum % 2\
    \ == 1)\n        return array;\n    for (int i = 0; i < array.length; i++) \n\
    \    {\n        temp = array[i];\n        for (int j = i; j < array.length; j++)\
    \ \n        {\n            if (array[j] > temp)\n            {\n             \
    \   long temp1 = array[j];\n                array[j] = temp;\n               \
    \ array[i] = temp1;\n            }\n        }\n    }\n    return array;\n}", "{\n\
    \    // Your code here\n    \n    long[] arr = new long[array.length];\n    Arrays.sort(arr,\
    \ (int i, int j) -> {\n        if(i+j > array.length-1) \n            return 0;\n\
    \        \n        long sum = getSum(array, i, j);\n        if(sum % 2 == 0){\n\
    \            return 1;\n        }else{\n            return -1;\n        }\n  \
    \  });", "{\n    long[] result = new long[array.length];\n    int flag = 0;\n\
    \    int n = array.length;\n    int i;\n    long sum = 0;\n    for(int index =\
    \ 0; index < n; index++)\n    {\n        sum += array[index];\n        if(sum\
    \ % 2 != 0)\n            flag = 1;\n    }\n    if(flag == 0)\n    {\n        for(int\
    \ index = 0; index < n; index++)\n        {\n            sum += array[index];\n\
    \            result[index] = sum;\n        }\n        Arrays.sort(result);\n \
    \   }\n    else\n    {\n        for(int index = 0; index < n; index++)\n     \
    \   {\n            sum -= array[index];\n            result[index] = sum;\n  \
    \      }\n        Arrays.sort(result);\n    }\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis is a great solution, but I suspect that sorting is O(n\
    \ log n), which is more than O(n).\n<|/ c |>\n<| c |>\nYes, you are right, this\
    \ is O(n log n), I am sorry for my mistake.\n<|/ c |>\n<| c |>\nIt's O(n), but\
    \ it's not O(n log n).  Sure, it takes n comparisons, but it's O(n) because it\
    \ takes n comparisons to sort the first array (which could be done in O(n log\
    \ n) time), and n comparisons to sort the second array (which could be done in\
    \ O(n) time).  It's O(n) because of the time it takes to sort the second array.\
    \  It's not O(n log n) because it takes an O(n) time to sort the first array.\n\
    <|/ c |>\n<| c |>\nThis is definitely a great solution and I appreciate the effort\
    \ put into it. I accepted it, but I don't have enough reputation points to give\
    \ you the bounty. Thanks.\n<|/ c |>\n<| a tags=algorithm,sorting,arrays dscore=1\
    \ |>\nThis should be very efficient in O(n log(n)) time:\n<code>\nfunction sortAndCount(inputArray)\
    \ {\n    var count = 0; // current number of duplicates\n    var result = new\
    \ Array(); // array of indices in inputArray that have duplicates\n    var lookupArray\
    \ = new Array(); // array of indices of duplicates in inputArray\n    var tempArray\
    \ = new Array(); // temporary array to hold values\n    for (var i=0; i<inputArray.length;\
    \ i++) lookupArray[i] = i; // add each index to the lookup array\n    while (lookupArray.length)\
    \ { // while there are unmatched elements\n        var currentIndex = lookupArray[lookupArray.length\
    \ - 1]; // get the last unmatched index\n        var currentValue = inputArray[currentIndex];\
    \ // get the value ", "{\n    int n = array.Length;\n    var result = new long[n];\n\
    \    long[] index = new long[n];\n    long sum = 0;\n    long[] temp = new long[n];\n\
    \    for(int i = 0; i < n; i++) \n    {\n        index[i] = i;\n    }\n    for(int\
    \ i = 0; i < n; i++) \n    {\n        temp = array;\n        temp.Swap(i, 0);\n\
    \        if(temp.Sum() > sum) \n        {\n            sum = temp.Sum();\n   \
    \         for(int j = 0; j < n; j++) \n            {\n                if(temp[j]\
    \ > temp[j+1])\n                    temp.Swap(j, j+1);\n            }\n      \
    \      temp = array;\n            temp.Swap(0, i);\n        }\n    }\n    int\
    \ count = 0;\n    for(int i = 0; i < n; i++) \n    {\n        if (index[i] > i)\
    \ \n        {\n            temp = array;\n            temp.Swap(i, index[i]);\n\
    \            temp.Square();\n            temp.Add(temp[i]);\n            temp.Add(sum);\n\
    \            result[count] = temp.Sum();\n            count++;\n        }\n  \
    \  }\n    return result;\n}\n</code>\n<|/ a dscore=2 tags=sorting,c#,arrays,algorithm\
    \ |>\n<| c |>\nthank you for the reply, I really appreciate it but I can't understand\
    \ how it works. Could you explain me please?\n<|/ c |>\n<| c |>\nThe idea is similar\
    \ to bubble sort, first sort the array with ascending order and then sort it again\
    \ with descending order. After that, the final result will be the original array\
    \ with the odd and even element swapped. Since the original array is sorted initially,\
    \ the result array will also be sorted.\n<|/ c |>\n<| c |>\nI wrote a C# implementation,\
    \ which I posted on my blog: http://blog.mariusschulz.com/2018/08/28/sorting-an-array-using-a-swap-sort/\n\
    <|/ c |>\n<| c |>\nThanks for sharing your code. Can you please explain me the\
    \ complexity and running time?\n<|/ c |>\n<| c |>\nI added a code comment explaining\
    \ the code. Hope it helps.\n<|/ c |>\n<| a |>\nIt seems you need a sorting function\
    \ which will sort your array in ascending order or descending order, you can use\
    \ below function for that.\n<code>\nusing System;", "{\n    long[] arr = array;\n\
    \    int sum = 0;\n    long sum1 = 0;\n    long sum2 = 0;\n    for(int i = 0;\
    \ i < arr.length; i++) {\n        sum = sum + arr[i];\n    }\n    for(int i =\
    \ 0; i < arr.length; i++) {\n        sum1 = sum1 + arr[i];\n    }\n    for(int\
    \ i = 0; i < arr.length; i++) {\n        sum2 = sum2 + arr[i];\n    }\n    if(sum%2\
    \ != 0) {\n        for(int i = 0; i < arr.length; i++) {\n            arr[i] =\
    \ arr[i] * -1;\n        }\n        sort_array(arr);\n    } else {\n        for(int\
    \ i = 0; i < arr.length; i++) {\n            arr[i] = arr[i] * -1;\n        }\n\
    \        sort_array(arr);\n    }\n    for(int i = 0; i < arr.length; i++) {\n\
    \        arr[i] = arr[i] + sum2;\n    }\n    for(int i = 0; i < arr.length; i++)\
    \ {\n        arr[i] = arr[i] + sum1;\n    }\n    return arr;\n}\n</code>\n<|/\
    \ a tags=sorting,java dscore=1 |>\n<| c |>\nIt's not a homework\n<|/ c |>\n<|\
    \ a |>\nI believe it would be much easier if your data was represented by objects\
    \ instead of primitive types. But since you are restricted to primitives, I would\
    \ write my own sort function. It would basically look like this:\n<code>", "{\n\
    \    int i;\n    int j = 0;\n    long sum;\n    \n    sum = 0;\n    \n    for\
    \ (i = 0; i < array.length; i++){\n        sum += array[i];\n    }\n    \n   \
    \ if (sum % 2 == 0) {\n        std.sort(array, 0, array.length);\n    } else {\n\
    \        std.sort(array, array.length, array.length - 1);\n    }\n    \n    long\
    \ sum2 = 0;\n    for (i = 0; i < array.length; i++) {\n        sum2 += array[i];\n\
    \    }", "{\n    long long sum = 0, i = 0;\n    int n = array.length;\n    long[]\
    \ result=new long[n];\n    while (i < n) {\n        sum += array[i]; // Sum up\
    \ all the elements.\n        i++; // Keep moving forward through the array until\
    \ we reach the end.\n    }", "{\n    if (array.length > 0)\n    {\n        int\
    \ sum = 0;\n        long sum1 = 0;\n        long sum2 = 0;", "{\n    // write\
    \ your code here\n    long start = 0;\n    long end = array.size() - 1;\n    long\
    \ middle = start + (end-start)/2;\n    long sum = 0;\n    boolean odd;\n    while(end\
    \ > start)\n    {\n        sum = array[middle] + array[end];\n        odd = (sum%2\
    \ != 0);\n        if(odd)\n        {\n            end = end - 1;\n        }\n\
    \        else\n        {\n            start = start + 1;\n        }\n        middle\
    \ = start + (end-start)/2;\n    }\n    return array;\n}\n</code>\n<|/ a tags=sorting,arrays,c++\
    \ dscore=1 |>\n<| c |>\n`array` should be passed as a const reference to avoid\
    \ unnecessary copy.\n<|/ c |>\n<| c |>\nAlso since you are using C++, use std::sort\
    \ with a custom compare functor.\n<|/ c |>\n<| c |>\nthanks for your reply. Sorry\
    \ for late reply. I am not using STD library because I am not getting a chance\
    \ to learn it yet. Just for practice, could you please edit your answer to include\
    \ the above 2 points. I would really appreciate it.\n<|/ c |>\n<| c |>\nI didn't\
    \ want to confuse you with more stuff, but you asked the question about sorting\
    \ with C++, that's what i meant by \"use std::sort with a custom compare functor\"\
    . [Here](http://en.cppreference.com/w/cpp/algorithm/sort) you can find how to\
    \ write a compare functor for std::sort. It's very similar to the above code,\
    \ just replace `std::minmax_element` with `std::sort`.\n<|/ c |>\n<| a dscore=1\
    \ |>\nI would not suggest using bubble sort for this particular case. A simple\
    \ way to do it would just be to use partitioning in an iterative fashion starting\
    \ from the front. You would iterate through your array until you find the largest\
    \ element in your array, then start your loop at that index and run through the\
    \ remaining elements incrementing the index and swapping if needed.\n<code>",
  "{\n    long total=0;\n    Arrays.sort(array);\n    for(int i=0; i<array.length;\
    \ i++)\n    {\n        long num = array[i];\n        total += num;\n    }\n  \
    \  return array;\n}", "{\n\tint[] a = new int[array.length];\n\tfor(int i = 0;\
    \ i < a.length; i++)\n\t\ta[i] = i;", "{\n    long[] result = new long[array.length];\n\
    \    int len = array.length;\n    long sum = 0;\n    int n = 0, m = 0;\n    int\
    \ i = 1;\n    long temp = 0;", "{\n    long[] result=new long[array.length];\n\
    \    int i=0;\n    int j=result.length-1;\n    long sum=0;\n    \n    for (;i<array.length;++i)\n\
    \    {\n        sum+=array[i];\n        if (sum%2==1)\n        {\n           \
    \ result[j++]=array[i];\n        }\n        else\n        {\n            result[j--]=array[i];\n\
    \        }\n    }\n    return result;\n}", "{\n\tint sum = 0;\n\tlong[] new_array\
    \ = new long[array.length];\n\tfor(int i = 1; i < array.length; i++)\n\t\tsum\
    \ += array[i];\n\t\n\t\n\tif(sum % 2 == 1)\n\t{\n\t\tfor(int i = 1; i < array.length;\
    \ i++)\n\t\t\tnew_array[i - 1] = array[i];\n\t\tArrays.sort(new_array);\n\t}\n\
    \telse\n\t{\n\t\tfor(int i = array.length - 1; i > 0; i--)\n\t\t\tnew_array[i\
    \ - 1] = array[i];\n\t\tArrays.sort(new_array);\n\t}\n\treturn new_array;\n}",
  "{\n    int n = array.length;\n    long[] ans = new long[n];\n    for (int i = 0;\
    \ i < n; i++) {\n        long sum = 0;\n        long firstIndex = array[i];\n\
    \        for (int j = 0; j < i; j++) {\n            sum += array[j];\n       \
    \ }\n        if (sum % 2 == 0) {\n            ans[i] = firstIndex;\n        }\n\
    \        else {\n            ans[i] = array[n - 1 - i];\n        }\n    }\n  \
    \  return ans;\n}", "{\n    int n1 = array.length;\n    long sum = 0;\n    long[]\
    \ result = new long[n1];\n    \n    int j = 0;\n    for (int i = 0; i < n1; i++)\
    \ \n    {\n        if (j == 0) \n        {\n            result[i] = array[i];\n\
    \            continue;\n        }\n        sum += array[i];\n        result[i]\
    \ = array[j];\n        j++;\n    }\n    int n = j;\n    if (sum % 2 != 0) \n \
    \   {\n        Collections.reverse(result);\n        sum = 0;\n        j = n -\
    \ 1;\n        for (int i = 0; i < j; i++) \n        {\n            sum += result[i];\n\
    \            result[i] = array[i];\n            array[i] = sum;\n        }\n \
    \   }\n    return result;\n}\n</code>\n<|/ a dscore=1 tags=java,arrays |>\n<|\
    \ a |>\nHere is my solution, i think its very clear and very simple.\n<code>\n\
    import java.util.*;", "{\n    int sum = 0;\n    for (int i = 0; i < array.length;\
    \ i++) {\n        sum += array[i];\n    }\n    if (sum % 2 == 1) {\n        long[]\
    \ arraySorted = new long[array.length];\n        int k = 0;\n        for (int\
    \ i = 0; i < array.length; i++) {\n            int index = 0;\n            while\
    \ (k < i) {\n                index += array[k];\n                k++;\n      \
    \      }\n            arraySorted[index++] = array[i];\n        }\n        return\
    \ arraySorted;\n    }\n    else {\n        long[] arraySorted = new long[array.length];\n\
    \        int k = 0;\n        for (int i = array.length - 1; i >= 0; i--) {\n \
    \           int index = 0;\n            while (k < i) {\n                index\
    \ += array[k];\n                k++;\n            }\n            arraySorted[index++]\
    \ = array[i];\n        }\n        return arraySorted;\n    }\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nNice and concise answer. Your code is not \"stable\" though,\
    \ i.e. if there are duplicate values that would otherwise be \"sorted\" together,\
    \ this algorithm would return them in any order that they appear in. [Example](http://coliru.stacked-crooked.com/a/ec99eabf45f271bc)\n\
    <|/ c |>\n<| c |>\nThat is true, I wanted to give the OP the best chance to understand\
    \ the idea behind it.\n<|/ c |>\n<| a |>\nYou want a stable sort algorithm. This\
    \ means the sort must be stable when there is a sequence of equal values. So the\
    \ sort is stable if the values are sorted by their first index. \nYou can implement\
    \ this by writing a Comparator that compares by index, then using Collections.sort\
    \ to sort the array. The comparator must also take into account that the elements\
    \ are equal if they have the same index. So the comparator should compare the\
    \ element by index, if they are equal, compare their first index. Otherwise compare\
    \ their last index. In the end, you have a stable sort where the sorting is stable\
    \ if and only if the elements have the same first index or the same last index.\
    \ This can be implemented as follows:\n<code>\npublic static <T> void stableSort(List<T>\
    \ list, Comparator<? super T> c)\n{\n    int i = 0;\n    int j = list.size() -\
    \ 1;\n    while (i < j)\n    {\n        while (i < j && c.compare(list.get(i),\
    \ list.get(j)) < 0)\n        {\n            j--;\n        }\n        if (i < j)\n\
    \        {\n            int tmp = list.get(i);\n            list.set(i, list.get(j));\n\
    \            list.set(j, tmp);\n        }\n        i++;\n        j--;\n    }\n\
    }\n</code>\nThe ", "{\n    int len = array.length;\n    int sum = 0;\n    for(int\
    \ i = 0; i < len; i++) \n    {\n        sum += array[i];\n    }\n    if (sum %\
    \ 2 == 1)\n    {\n        int n = len / 2;\n        long aux = array[0];\n   \
    \     array[0] = 0;\n        for(int i = 1; i < n; i++) \n        {\n        \
    \    array[i] = array[i - 1];\n        }\n        array[n - 1] = aux;\n      \
    \  array.sort(long.greaterThan());\n        return array;\n    }\n    else \n\
    \    {\n        int n = len / 2;\n        long aux = array[0];\n        array[0]\
    \ = 0;\n        for(int i = 1; i < n; i++) \n        {\n            array[i] =\
    \ array[i - 1];\n        }\n        array[n - 1] = aux;\n        array.sort(long.lessThan());\n\
    \        return array;\n    }\n}\n</code>\n<|/ a tags=java,sorting |>\n<| c |>\n\
    Nice one. Works fine. Thanks.\n<|/ c |>\n<| c |>\nYou used `sort` method which\
    \ sorts array in ascending order but you want to sort in descending order. How\
    \ did you manage to make it work?\n<|/ c |>\n<| a dscore=4 tags=java,sorting |>\n\
    Just in case anyone is looking for how to sort in descending order using Java\
    \ 8 streams, here is my solution:\n<code>\nlong[] array;\nArrays.sort(array, Comparator.reverseOrder());\n\
    </code>\n<|/ a |>\n<| c |>\nBut what if I want to sort array in descending order?\n\
    <|/ c |>\n<| c |>\nAwesome! Thanks!\n<|/ c |>\n<| c |>\nThis does not sort in\
    \ descending order, the sorting order is ascending order. Check [this](https://stackoverflow.com/a/53979755/5053404)\
    \ out.\n<|/ c |>\n<| a dscore=4 |>\nAs of Java 8 the recommended way to sort a\
    \ collection is to use lambda:\n<code>\nArrays.sort(array, Comparator.naturalOrder());\n\
    </code>\nNatural ordering is a lexicographic ordering based on comparing Unicode\
    \ code points (character codes), using a \"stronger\" comparison scheme than the\
    \ default ordering based on ASCII code points.\n<|/ a tags=java,sorting |>\n<|\
    \ c |>\nThis solution is not appropriate if you have an array of strings you want\
    \ to sort based on their length\n<|/ c |>\n<| a dscore=3 |>\nJust a quick addition\
    \ to what others have pointed out.\nIf you want to sort in descending order you\
    \ can just reverse the order ", "{\n    if (array == null || array.length == 0)\
    \ \n        return array;", "{\n    long[] ret = new long[array.length];\n   \
    \ Arrays.sort(array);\n    ret[0] = array[0];\n    ret[array.length-1] = array[array.length-1];\n\
    \    long sum = 0;\n    for (int i = 1; i < array.length; i++)\n    {\n      \
    \  sum += array[i]; \n        if (sum % 2 == 0)\n        {\n            ret[i]\
    \ = array[i];\n            ret[i-1] = array[array.length-1-i]; \n            sum\
    \ = sum/2; \n        }\n        else\n        {\n            ret[i] = array[array.length-1-i];\n\
    \            ret[i-1] = array[i];\n            sum = sum/2; \n        }\n    }\n\
    \    return ret;\n}", "{\n    return sort_array(array, (a, b) => b.longValue()\
    \ - a.longValue());\n}", "{\n    var i = 0;\n    var j = 0;\n    var mid = 0;\n\
    \    var sum = 0;\n    while (j < array.length) \n    {\n        mid = i;\n  \
    \      j = i + 1;\n        while (j < array.length) \n        {\n            sum\
    \ = array[mid] + array[j];\n            array[mid] = array[j];\n            array[j]\
    \ = sum;\n            mid = j + 1;\n        }\n        i = mid;\n    }\n    return\
    \ array;\n}", "{\n    // write your code in C# here\n    int sum = 0;\n    for(int\
    \ i = 0; i < array.Length; i++)\n    {\n        sum += array[i];\n    }\n    int\
    \ sumOfFirst = (sum % 2 == 0) ? sum / 2 : (sum - 1);\n    int sumOfLast = (sum\
    \ % 2 == 0) ? sum / 2 : (sum + 1);\n    \n    int firstIndex = 0;\n    int lastIndex\
    \ = 0;\n    int minIndex = 0;\n    while(firstIndex < array.Length && lastIndex\
    \ < array.Length)\n    {\n        if(array[firstIndex] < array[lastIndex])\n \
    \       {\n            swap(array, firstIndex, lastIndex);\n            firstIndex++;\n\
    \        }\n        else\n        {\n            swap(array, lastIndex, firstIndex);\n\
    \            lastIndex++;\n        }\n    }\n    \n    while(firstIndex < array.Length)\n\
    \    {\n        swap(array, firstIndex, array.Length);\n        firstIndex++;\n\
    \    }\n    while(lastIndex < array.Length)\n    {\n        swap(array, array.Length,\
    \ lastIndex);\n        lastIndex++;\n    }\n    \n    for(int i = 0; i < array.Length;\
    \ i++)\n    {\n        array[i] = array[minIndex];\n    }\n    \n    return array;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nthanks for your answer, but I don't want to copy\
    \ the array. and I want to return the array sorted. thanks\n<|/ c |>\n<| c |>\n\
    I changed my answer, so you can copy the array without using the System.arraycopy\
    \ function.\n<|/ c |>\n<| a |>\nHere is another solution\n<code>\npublic static\
    \ int[] sort(int[] num) {\n    if (num.length < 2) return num;\n    int n = num.length,\
    \ i, j, temp;\n    int[] res = new int[n];\n    int[] min = new int[n];\n    \n\
    \    // Find min and max\n    for (i = 0; i < n; i++) min[i] = num[i], res[i]\
    \ = num[i];\n    for (i = 1; i < n; i++) {\n        temp = num[i];\n        for\
    \ (j = 0; j < n - i; j++) {\n            if (num[j] < min[j]) min[j] = temp;\n\
    \            if (num[j] > temp) temp = num[j];\n        }\n        for (j = 0;\
    \ j < i - j; j++) min[i - j + 1] = num[j];\n        \n        res[i - j + 1] =\
    \ temp;\n    }\n    return res;\n}\n</code>\n<|/ a dscore=1 tags=sorting,algorithm,java\
    \ |>\n<| a dscore=0 tags=sorting,algorithm,java |>\nHere is my solution:\n<code>\n\
    public static int[] sort(int[] nums) {\n    int n = nums.length;\n    int[] res\
    \ = new int[n];\n    int ", "{\n    long sum = 0;\n    for(int i = 0; i < array.length;\
    \ i++){\n        sum += array[i];\n    }\n    long[] result = new long[array.length];\n\
    \    boolean isAsc = true;\n    int indexAsc = 0;\n    int indexDesc = 0;\n  \
    \  for(int i = 0; i < array.length; i++){\n        if(sum % 2 != 0){\n       \
    \     isAsc = false;\n        }\n        sum += array[i];\n        if(isAsc){\n\
    \            result[indexAsc++] = array[i];\n        }else{\n            result[indexDesc++]\
    \ = array[i];\n        }\n    }\n    return result;\n}", "{\n\tlong sum = std.math.reduceRight((x,y)=>x+y)(array);\n\
    \tint res = array.sum();\n\tif (res == 0)\n\t\treturn array;\n\tint len = array.len;\n\
    \tif (sum % 2 == 1)\n\t\treturn array.sort();\n\telse if (sum % 2 == 0)\n\t\t\
    return array.sort((a,b)=>b-a);\n}\n/*", "{\n    if(array == null || array.length\
    \ < 2)\n        return array;\n    int even = array.length % 2;\n    long sum\
    \ = array[0];\n    for (int i = 1; i < array.length; ++i) \n    {\n        long\
    \ value = array[i];\n        if(even ? sum + value < sum : sum + value > sum)\n\
    \        {\n            sum = value;\n        }\n        else\n        {\n   \
    \         int swap = -1;\n            for(int j = 1; j < i; ++j)\n           \
    \ {\n                if(even ? sum + array[j] < sum : sum + array[j] > sum)\n\
    \                {\n                    swap = j;\n                    sum = array[j];\n\
    \                }\n            }\n            if(swap == -1)\n            {\n\
    \                swap = i;\n                sum = 0;\n            }\n        \
    \    int temp = array[swap];\n            array[swap] = array[i];\n          \
    \  array[i] = temp;\n        }\n    }\n    return array;\n}", "{\n    int len\
    \ = array.length;\n    if (len < 2)\n        return array;\n    long[] ret = new\
    \ long[len];\n    \n    int aSum = 0;\n    for (int i = 1; i < len; ++i)\n   \
    \     aSum += array[i];\n    \n    for (int i = 1; i < len; ++i)\n    {\n    \
    \    int temp = array[i];\n        int j;\n        bool isAscending = true;\n\
    \        for (j = i; j > 0; --j)\n        {\n            if (temp > array[j])\n\
    \            {\n                isAscending = false;\n                break;\n\
    \            }\n        }\n        if (isAscending)\n            ++ret[j];\n \
    \       else\n            ret[j] = ret[j-1];\n    }\n    \n    return ret;\n}",
  "{\n    long[] answer = array;\n    int len = (int)(array.length/2);\n    int sum\
    \ = 0;\n    for(int i = 0; i < array.length; i++)\n    {\n        sum += array[i];\n\
    \    }", "{\n    std.sort(array);\n    int sum = 0;\n    for(int i = 0; i < array.length;\
    \ i++){\n        sum += array[i];\n        if(i == 0 || sum%2 != 0)\n        \
    \    std.reverse(array);\n    }\n    return array;\n}\n</code>\n<|/ a tags=c++,arrays\
    \ |>\n<| c |>\nThanks for your answer, but this solution seems to be inefficient,\
    \ and since my professor said that `for` loops aren't allowed to use when dealing\
    \ with arrays he didn't really care about it :)\n<|/ c |>\n<| c |>\nWell, if you\
    \ really want to optimize this solution you need to know your array size, right?\
    \ How many elements do you have?\n<|/ c |>\n<| c |>\n: My point is that this is\
    \ one of the cases where using a for-loop is appropriate. Although you could write\
    \ a function that uses a loop in order to do the job, this function is only called\
    \ once in any case, so there's no need to optimize it.\n<|/ c |>\n<| c |>\n: If\
    \ you have many elements and you have an intel processor then you might be able\
    \ to get away with using a `std::vector`.\n<|/ c |>\n<| c |>\n: I see that you're\
    \ not allowed to use `std::sort`, but that does not mean that you cannot use a\
    \ `for` loop. Just replace `std::sort` with your own implementation.\n<|/ c |>\n\
    <| a dscore=0 |>\nHere is a solution without using any for-loop.\n<code>\n#include\
    \ <stdio.h>", "{\n    long sum_of_first_and_last = array[0];\n    long sum_of_first\
    \ = array[0];\n    long sum_of_last = array[0];\n    for(int i=1; i<array.length;\
    \ i++) \n    {\n        sum_of_first += array[i];\n        sum_of_last += array[array.length-1-i];\n\
    \    }\n    \n    if(sum_of_first_and_last % 2 == 1) \n    {\n        return array.sort((a,b)\
    \ => b - a); \n    }\n    \n    return array.sort((a,b) => a - b); \n}\n</code>\n\
    <|/ a dscore=0 tags=algorithm,sorting,arrays |>\n<| a dscore=0 |>\n<code>\nclass\
    \ Solution {\n    public static int[] sortArray(int[] arr) {\n        int sumOfFirstElement\
    \ = 0;\n        int sumOfLastElement = 0;\n        \n        for (int i = 0; i\
    \ < arr.length; i++) {\n            sumOfFirstElement += arr[i];\n           \
    \ sumOfLastElement += arr[arr.length-1-i];\n        }\n        \n        if (sumOfFirstElement\
    \ % 2 == 1) {\n            int[] newArray = arr.clone();\n            newArray.sort((a,b)\
    \ -> b-a);\n            return newArray;\n        } else if (sumOfLastElement\
    \ % 2 == 0) {\n            int[] newArray = arr.clone();\n            newArray.sort((a,b)\
    \ -> a-b);\n            return newArray;\n        }\n        return arr;\n   \
    \ }\n}\n</code>\n<|/ a tags=algorithm,sorting,arrays |>\n<| a tags=algorithm,sorting,arrays\
    \ |>\n<code>\n function sortArrayBySubIndex(value) {\n        let result = []\n\
    \        for(let item of value) {\n            for(let j=0; j<value.length; j++)\
    \ {\n                if (j > 0) {\n                    if (item[j] - value[j-1]\
    \ > 0) {\n                        result.push(item[j])\n                     \
    \   break\n                    }\n                }\n            }\n        }\n\
    \        for(let j=0; j<value.length; j++) {\n            if (j > 0) {\n     \
    \           if (value[j] - value[j-1] < 0) {\n                    result.push(value[j])\n\
    \                    break\n                }\n            }\n        }\n    \
    \    return result\n    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nA little explanation\
    \ would go a long way here! :)\n<|/ c |>\n<| a dscore=0 |>\n<code>\nconst array\
    \ = [5, 2, 7, 4, 3, 1, 6, 4];\nconsole.log(sortArray(array));", "{\n    long result[]\
    \ = new long[array.length];\n    int sum = 0;\n    int odd = 1;\n    int even\
    \ = 0;\n    for (int i = 0; i < array.length; i++)\n    {\n        sum += array[i];\n\
    \        if (sum%2 == 0)\n            even++;\n        else\n            odd++;\n\
    \    }\n    if (odd%2 == 0)\n    {\n        bool isAscending = true;\n       \
    \ for(int i = 0; i < array.length; i++)\n        {\n            sum += array[i];\n\
    \            if (sum%2 == 0)\n            {\n                isAscending = false;\n\
    \            }\n        }\n        if (isAscending)\n        {\n            long\
    \ temp = 0;\n            for (int i = 0; i < array.length; i++)\n            {\n\
    \                sum += array[i];\n                if (sum%2 == 0)\n         \
    \       {\n                    temp = array[i];\n                    break;\n\
    \                }\n            }\n            for (int i = 0; i < array.length;\
    \ i++)\n            {\n                sum += array[i];\n                if (sum%2\
    \ != 0)\n                {\n                    result[i] = temp;\n          \
    \          break;\n                }\n            }\n        }\n        else\n\
    \        {\n            long temp = 0;\n            for (int i = 0; i < array.length;\
    \ i++)\n            {\n                sum += array[i];\n                if (sum%2\
    \ == 0)\n                {\n                    temp = array[i];\n           \
    \         break;\n                }\n            }\n            for (int i = array.length-1;\
    \ i >= 0; i--)\n            {\n                sum += array[i];\n            \
    \    if (sum%2 != 0)\n                {\n                    result[i] = temp;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    else\n    {\n        bool isAscending = true;\n        for(int i = 0;\
    \ i < array.length; i++)\n        {\n            sum += array[i];\n          \
    \  if (sum%2 != 0)\n            {\n                isAscending = false;\n    \
    \        }\n        }\n        if (isAscending)\n        {\n            long temp\
    \ = 0;\n            for (int i = 0; i < array.length; i++)\n            {\n  \
    \              sum += array[i];\n                if (sum%2 != 0)\n           \
    \     {\n                    temp = array[i];\n                    break;\n  \
    \              }\n            }\n            for (int i = 0; i < array.length;\
    \ i++)\n            {\n                sum += array[i];\n                if (sum%2\
    \ == 0)\n                {\n                    result[i] = temp;\n          \
    \          break;\n                }\n            }\n        }\n        else\n\
    \        {\n            long temp = 0;\n            for (int i = 0; i < array.length;\
    \ i++)\n            {\n                sum += array[i];\n                if (sum%2\
    \ == 0)\n                {\n                    temp = array[i];\n           \
    \         break;\n                }\n            }\n            for (int i = array.length-1;\
    \ i >= 0; i--)\n            {\n                sum += array[i];\n            \
    \    if (sum%2 != 0)\n                {\n                    result[i] = temp;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return result;\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=java,", "{\n\
    \    if( array.Length == 0 )\n        return array;", "{\n    int start = 0;\n\
    \    int end = array.size() - 1;\n    int sum = 0;\n    \n    while (start < end)\n\
    \    {\n        sum += array[start];\n        start++;\n        while (sum > 0\
    \ && array[start] <= array[end])\n        {\n            sum -= array[start];\n\
    \            start++;\n        }\n        \n        sum += array[end];\n     \
    \   end--;\n        while (sum < 0 && array[end] > array[start])\n        {\n\
    \            sum += array[end];\n            end--;\n        }\n        \n   \
    \     if (sum < 0)\n        {\n            int tmp = array[end];\n           \
    \ array[end] = array[start];\n            array[start] = tmp;\n        }\n   \
    \     \n    }\n    \n    return array;\n}\n\"\"\"\n)", "{\n    int n = array.Length;\n\
    \    long[] result = new long[n];\n    long sum = 0;\n    for (int i = 0; i <\
    \ n; i++) {\n        sum += array[i];\n        result[i] = array[i];\n    }\n\
    \    if (sum % 2 == 1) {\n        Array.Sort(result);\n    } else {\n        Array.Sort(result,\
    \ n - 1);\n    }\n    return result;\n}\n</code>\n<|/ a tags=sorting,arrays,c#\
    \ |>\n<| c |>\nFor big arrays this is probably faster than sorting, but it's definitely\
    \ not optimal for small arrays. I'd expect it to take about the same amount of\
    \ space in memory.\n<|/ c |>\n<| c |>\nThe `Array.Sort` method is a native method,\
    \ not a C# method. Native methods cannot do bounds checking. I don't think any\
    \ optimization of the sort algorithm is possible, unless it knows all the possible\
    \ values of all the elements in the array. If it knows that, then it's able to\
    \ do fast binary searches and do better than a straight linear sort.\n<|/ c |>\n\
    <| c |>\nI believe the array length could be optimized to run faster on smaller\
    \ arrays. Also, if you are going to use a for loop, you might as well use the\
    \ `Array.Sort` method.\n<|/ c |>\n<| a |>\nI know I am late to this game, but\
    \ I would like to offer another solution. This solution uses an algorithm called\
    \ Quick Sort which guarantees that the partition will be in ascending order.\n\
    <code>\nclass Program\n{\n    static void Main(string[] args)\n    {\n       \
    \ int[] array = new int[] { 1L, 3L, 2L, 4L, 5L, 6L, 7L, 9L };\n        Console.WriteLine(ArrayToString(array));\n\
    \        Console.WriteLine();\n        array = QuickSort(array);\n        Console.WriteLine(ArrayToString(array));\n\
    \        Console.ReadKey();\n    }", "{\n    Arrays.sort(array);\n    int firstIndex\
    \ = 0;\n    int lastIndex  = array.length - 1;\n    long sum = 0;\n    while (firstIndex\
    \ < lastIndex)\n    {\n        sum = array[firstIndex] + array[lastIndex];\n \
    \       if (sum % 2 == 0)\n        {\n            array[firstIndex] = array[lastIndex];\n\
    \            array[lastIndex] = array[firstIndex];\n            firstIndex++;\n\
    \            lastIndex--;\n        }\n        else if (sum % 2 != 0)\n       \
    \ {\n            array[firstIndex] = array[lastIndex];\n            array[lastIndex]\
    \ = array[firstIndex];\n            firstIndex++;\n            lastIndex--;\n\
    \        }\n    }\n    return array;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\n\
    I implemented a c++ solution with two loops.\n<code>\nlong sort_array(std::vector<long>\
    \ nums) {\n    int len = nums.size();\n    if (len <= 0) return 0;\n    if (len\
    \ == 1) {\n        return nums[0];\n    }\n    \n    long total = 0;\n    for\
    \ (long &n : nums) {\n        total += n;\n    }\n    \n    for (int i = 0; i\
    \ < len - 1; ++i) {\n        long left = nums[i];\n        long right = nums[i\
    \ + 1];\n        long sum = left + right;\n        if (sum % 2 == 0) {\n     \
    \       nums[i] = right;\n            nums[i + 1] = left;\n        }\n    }\n\
    \    \n    long sum = 0;\n    for (long &n : nums) {\n        sum += n;\n    }\n\
    \    \n    if (sum % 2 == 1) {\n        nums[0] = nums[len - 1];\n        nums[len\
    \ - 1] = 0;\n    }\n    \n    return total;\n}", "{\n    //write your code here\n\
    \    long sum = 0;\n    int i = 0;\n    while (i < array.length)\n    {\n    \
    \    sum += array[i];\n        i++;\n    }\n    \n    if (sum % 2 == 1)\n    {\n\
    \        std.sort(array, 0, array.length);\n        std.reverse(array, 0);\n \
    \   }\n    \n    return array;\n}\n</code>\n<|/ a dscore=1 tags=sorting,arrays,c#,algorithm\
    \ |>\n<| c |>\nThis doesn't work, since you always have to add an extra `0` at\
    \ the beginning: `sort_array(new long[] {4L, 2L, 3L, 1L})` gives `new long[] {1L,\
    \ 2L, 3L, 4L}` and not `new long[] {1L, 2L, 3L, 4L, 0L}`.\n<|/ c |>\n<| c |>\n\
    Thanks. I've edited my answer. My original code missed it too.\n<|/ c |>\n<| c\
    \ |>\nYou don't need the `if` statement at all. `sum % 2 == 1` will always be\
    \ true.\n<|/ c |>\n<| c |>\nNo, it doesn't work. Try `sort_array(new long[] {3L,\
    \ 4L, 1L})`. The `sort` will put `0` at the end of the array.\n<|/ c |>\n<| a\
    \ dscore=0 tags=sorting,arrays,c#,algorithm |>\n<code>\npublic static void sort_array(long[]\
    \ array, int size)\n{\n    if (size == 1) return;", "{\n    if (array == null\
    \ || array.length == 0)\n        return array;\n    long[] a = new long[array.length];\n\
    \    Arrays.sort(array);\n    long sum = 0;\n    for (int i = 0; i < array.length;\
    \ i++) \n    {\n        a[i] = array[i];\n        sum += a[i];\n    }\n    Arrays.sort(a);\n\
    \    \n    if (sum % 2 == 1) // even\n        Arrays.reverse(a);\n    return a;\n\
    }\n</code>\n<|/ a dscore=0 tags=java |>\n<| c |>\nThis is a perfect solution but\
    \ I don't believe that it works because it will not sort the array in descending\
    \ order if the sum remains even. You will also have to change `if (sum % 2 ==\
    \ 0)` to `if (sum % 2 == 1)`.\n<|/ c |>\n<| c |>\nNope, it does not work! It works\
    \ if the array remains even. Sorry for the confusion. I updated the code.\n<|/\
    \ c |>\n<| c |>\nThis is not working as expected, for example `array = [2,4,3,0,5,6]`\
    \ this will return `[6,5,4,3,2,1]` which is wrong.\n<|/ c |>\n<| c |>\nThis solution\
    \ is correct for the example you provided. In the second example I gave (array=[2L,4L,3L,0L,1L,5L,6L]),\
    \ this is how the output should look:\n`array=[6L,5L,4L,3L,2L,1L,0L]`\n<|/ c |>\n\
    <| a |>\nI have found this solution for your problem.\n<code>\npublic class SortArray\
    \ {\n    \n    public static void main(String[] args) {\n        int[] arr = {5L,\
    \ 2L, 4L, 3L, 0L, 1L, 5L};\n        \n        int[] arr2 = new int[arr.length];\n\
    \        \n        // sort arr in ascending order if the sum is odd\n        sort(arr,\
    \ 0, arr.length - 1);\n        \n        System.out.println(\"Ascending order:\
    \ \");\n        printArray(arr2);\n        \n        // sort arr in descending\
    \ order if the sum is even\n        sort(arr, arr.length - 1, arr.length);\n \
    \       \n        System.out.println(\"Descending order: \");\n        printArray(arr2);\n\
    \    }\n    \n    public static void sort(int[] arr, int start, int end) {\n \
    \       int sum = 0;\n        \n        for (int i = start; i <= end; i++) {\n\
    \            sum += arr[i];\n        }\n        \n        if (sum % 2 != 0) {\n\
    \            int temp = arr[start];\n            arr[start] = arr[end];\n    \
    \        arr[end] = temp;\n            \n            sort(arr, start, end - 1);\n\
    \        } else {", "{\n    if(array.lenght==0)\n        return array;\n    long[]\
    \ ret = new long[array.lenght];\n    int sum=0;\n    for(int i=0;i<array.lenght;i++){\n\
    \        sum+=array[i];\n        ret[i]=array[i];\n    }\n    if(sum%2==1)\n \
    \       ret = reverseLongArray(ret);\n    return ret;\n}", "{\n    int n = array.length;\n\
    \    if (n==0)\n        return array;\n    long sum = array[0];\n    if (sum %\
    \ 2==1)\n        array.sort((i1, i2) -> Long.compare(array[i1], array[i2]));\n\
    \    else\n        array.sort((i1, i2) -> Long.compare(array[i1], array[i2]));\n\
    \    return array;\n}", "{\n    int mid = array.length / 2;\n    long sum = 0;\n\
    \    for (int i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n\
    \    if (sum % 2 != 0) {\n        long max = array[mid];\n        int i = mid;\n\
    \        while (i < array.length) {\n            max = array[i];\n           \
    \ i++;\n        }\n        long min = array[0];\n        int j = mid;\n      \
    \  while (j >= 0) {\n            min = array[j];\n            j--;\n        }\n\
    \        long result[] = new long[array.length];\n        for (int i = 0; i <\
    \ array.length; i++) {\n            if (sum > max - min) {\n                result[i]\
    \ = max - min;\n            } else {\n                result[i] = min - max;\n\
    \            }\n        }\n        return result;\n    } else {\n        long\
    \ max = array[mid];\n        int i = mid + 1;\n        while (i < array.length)\
    \ {\n            max = array[i];\n            i++;\n        }\n        long min\
    \ = array[0];\n        int j = mid;\n        while (j >= 0) {\n            min\
    \ = array[j];\n            j--;\n        }\n        long result[] = new long[array.length];\n\
    \        for (int i = 0; i < array.length; i++) {\n            if (sum > max -\
    \ min) {\n                result[i] = min - max;\n            } else {\n     \
    \           result[i] = max - min;\n            }\n        }\n        return result;\n\
    \    }\n}", "{\n    int i = 0, j = 0, n = array.length;", "{\n    if (array.length\
    \ < 2)\n        return array;\n    int start = 0;\n    int end = array.length-1;\n\
    \    if (array[end] % 2 == 1) end = end - 1;\n    long sum = 0;\n    while (start\
    \ < end)\n    {\n        sum += array[start];\n        long tmp = array[start];\n\
    \        array[start] = array[end];\n        array[end] = tmp;\n        start\
    \ ++;\n        end --;\n        if (sum % 2 == 1)\n        {\n            long\
    \ tmpsum = array[start];\n            array[start] = array[end];\n           \
    \ array[end] = tmpsum;\n            start ++;\n            end --;\n        }\n\
    \    }\n    return array;\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=java,sorting,arrays\
    \ |>\nYou can use java.util.Arrays.sort() to sort the array in ascending order.\
    \ You can find the details in here. \n<code>\nArrays.sort(array);\n</code>\nIf\
    \ you wish to sort the array in descending order you will need to implement your\
    \ own sorting algorithm (as per your requirements).\n<|/ a |>\n<| c |>\nOP wants\
    \ to sort only even numbers :)\n<|/ c |>\n<| c |>\nAh ok sorry. Didn't read the\
    \ question properly\n<|/ c |>\n<| a tags=java,sorting,arrays dscore=0 |>\nTry\
    \ this one:\n<code>\npublic static void sort(long[] arr) {\n    long sum = 0;\n\
    \    for (int i = 0; i < arr.length; i++) {\n        sum += arr[i];\n    }\n \
    \   if (sum % 2 == 0) {\n        sort(arr, arr.length / 2);\n    } else {\n  \
    \      sort(arr, arr.length / 2 + 1);\n    }\n}", "{\n    if(array.length == 0)\
    \ {\n        return array;\n    }\n    long sum_first = (array[0] == 0 ? array.length\
    \ : array[0]);\n    long sum_last = (array[array.length-1] == 0 ? array.length\
    \ : array[array.length-1]);\n    long[] copy = copy(array);\n    int sum_odd_first\
    \ = sum_first % 2;\n    int sum_even_first = sum_first == 0? sum_odd_first : 1\
    \ - sum_odd_first;\n    int sum_odd_last = sum_last % 2;\n    int sum_even_last\
    \ = sum_last == 0? sum_odd_last : 1 - sum_odd_last;\n    if(sum_odd_first == sum_even_first){\n\
    \        return copy;\n    }\n    else if(sum_odd_last == sum_even_last){\n  \
    \      return sort_array(copy);\n    }\n    if(sum_odd_first == 1){\n        if(sum_odd_last\
    \ == 1){\n            copy[0] = sum_first + sum_last;\n            return sort_array(copy);\n\
    \        }\n        else if(sum_odd_last == 0){\n            copy[array.length-1]\
    \ = sum_first + sum_last;\n            array[0] = sum_first + sum_last;\n    \
    \        copy[array.length-1] = sum_first + sum_last;\n            return sort_array(copy);\n\
    \        }\n        else if(sum_odd_last == -1){\n            copy[array.length-1]\
    \ = sum_first + sum_last;\n            array[0] = sum_first + sum_last;\n    \
    \        copy[array.length-1] = sum_first + sum_last;\n            copy[0] = sum_first\
    \ + sum_last;\n            array[0] = sum_first + sum_last;\n            return\
    \ sort_array(copy);\n        }\n    }\n    else if(sum_odd_last == 1){\n     \
    \   if(sum_odd_first == 1){\n            copy[array.length-1] = sum_first + sum_last;\n\
    \            copy[0] = sum_first + sum_last;\n            return sort_array(copy);\n\
    \        }\n        else if(sum_odd_first == 0){\n            copy[0] = sum_first\
    \ + sum_last;\n            copy[array.length-1] = sum_first + sum_last;\n    \
    \        return sort_array(copy);\n        }\n        else if(sum_odd_first ==\
    \ -1){\n            copy[array.length-1] = sum_first + sum_last;\n           \
    \ copy[array.length-1] = sum_first + sum_last;\n            return sort_array(copy);\n\
    \        }\n    }\n    \n    \n    int mid = array.length/2;\n    if(sum_odd_first\
    \ == 0){\n        mid = array.length - 1;\n    }\n    else if(sum_odd_last ==\
    \ 0){\n        mid = 0;", "{\n    int sum = 0;\n    for(int i = 0; i < array.length;\
    \ i++)\n    {\n        sum += array[i];\n    }", "{\n    if (array.Length == 0)\n\
    \        return array;\n    var sum = 0;\n    var max = 0;\n    foreach (var item\
    \ in array)\n    {\n        sum += item;\n        if (sum > max)\n           \
    \ max = sum;\n    }", "{\n    int sum = 0;\n    int n = array.length;\n    int\
    \ mid, i, j, swap, flag = 0;\n    int firstIndex = 0, lastIndex = n - 1;", "{\n\
    \    if (array == null || array.length < 1) return array;\n    long sum = 0;\n\
    \    long maxValue = array[0];\n    for (int i = 0; i < array.length; i++) {\n\
    \        sum += array[i];\n    }\n    long curSum = 0;\n    long count = 0;\n\
    \    for (int i = 0; i < array.length; i++) {\n        curSum += array[i];\n \
    \       long nextSum = curSum;\n        nextSum -= maxValue;\n        if (nextSum\
    \ < 0) {\n            nextSum = 0;\n            count++;\n        }\n        if\
    \ (nextSum == 0 && count == array.length) {\n            if (maxValue < array[i])\
    \ {\n                maxValue = array[i];\n            }\n        }\n    }\n \
    \   int num = 0;\n    if (maxValue != 0) {\n        while (maxValue != 0) {\n\
    \            array.remove(maxValue);\n            num++;\n        }\n    }\n \
    \   if (num > 0) {\n        if (sum % 2 != 0) {\n            array = sort_array(array);\n\
    \        } else {\n            array = sort_array(array, true);\n        }\n \
    \   }\n    return array;\n}", "{\n    if(array.Length == 0)\n        return array;",
  "{\n    long[] result = array;\n    long max_sum = sumOfFirstAndLast(array);\n \
    \   long temp;\n    if(max_sum %2 == 1)\n    {\n        for(int i = 1; i < result.length;\
    \ i++)\n        {\n            temp = sumOfFirstAndLast(array);\n            if(temp\
    \ > max_sum)\n            {\n                max_sum = temp;\n               \
    \ result = array;\n            }\n            else\n            {\n          \
    \      max_sum -= result[i - 1];\n                result[i - 1] = temp;\n    \
    \        }\n        }\n    }\n    else\n    {\n        for(int i = result.length\
    \ - 1; i >= 0; i--)\n        {\n            temp = sumOfFirstAndLast(array);\n\
    \            if(temp > max_sum)\n            {\n                max_sum = temp;\n\
    \                result = array;\n            }\n            else\n          \
    \  {\n                max_sum -= result[i + 1];\n                result[i + 1]\
    \ = temp;\n            }\n        }\n    }\n    return result;\n}\n</code>\n<|/\
    \ a dscore=0 tags=algorithm,arrays,sorting,java |>\n<| a dscore=0 |>\n<code>\n\
    /**\n * Returns true if and only if the sum of the first and last numbers\n *\
    \ of the array is even.\n *\n * arr an array of non-negative integers\n * true\
    \ if the sum of the first and last numbers of the array is even\n */\npublic static\
    \ boolean sumOfEvenSum(int[] arr) {\n    int sum = 0;", "{\n    if (array.length\
    \ == 0) {\n        return array;\n    }\n    // Sort each sub array in ascending\
    \ order\n    for (int i = 1; i < array.length; i++) {\n        long first = array[i];\n\
    \        long last = array[i - 1];\n        // If sum is odd, then reverse the\
    \ array \n        if (first + last != 0) {\n            long temp = first;\n \
    \           first = last;\n            last = temp;\n        }\n        // Sort\
    \ this sub array\n        long temp;\n        for (temp = first; temp <= last;\
    \ temp++) {\n            int j;\n            for (j = 0; j < i; j++)\n       \
    \         if (array[j] > temp) {\n                    long a = array[j];\n   \
    \                 array[j] = temp;\n                    temp = a;\n          \
    \      }\n        }\n    }\n    return array;\n}\n</code>\n<|/ a tags=sorting,c#\
    \ dscore=2 |>\n<| a |>\n<code>\npublic static void ArraySort (Array arr)\n{\n\
    \    Array.Sort(arr);", "{\n    long[] ret = new long[array.length];\n    int\
    \ sum = 0;\n    for (int i = 0; i < ret.length; i++)\n    {\n        sum += array[i];\n\
    \        if (sum % 2 == 0)\n            ret[i] = array[i];\n        else\n   \
    \         ret[i] = array[ret.length - i - 1];\n    }\n    return ret;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nOne can use dynamic programming to reduce\
    \ the complexity of merge sort on large arrays.\nMerge sort is O(nlogn), since\
    \ we need to split and sort each part and each part is O(logn). The overall complexity\
    \ is O(nlogn).\n<code>", "{\n    int sum = 0;\n    for(int i = 0; i < array.length;\
    \ i++){\n        sum = sum + array[i];\n    }\n    int sum2 = sum % 2 == 0 ? sum\
    \ : sum - 1;\n    long[] res = new long[array.length];\n    for(int i = 0; i <\
    \ array.length; i++){\n        res[array.length - 1 - i] = (array[i] % 2 == 0\
    \ ? array[i] - 1 : array[i]);\n    }\n    Arrays.sort(res);\n    if(sum2 == sum)\n\
    \        return res;\n    else\n    {\n        Arrays.sort(res, (x, y) -> x -\
    \ y);\n        return res;\n    }\n}\n</code>\n<|/ a tags=arrays,sorting |>\n\
    <| a dscore=0 |>\nThis solution is in Python.  I have not tested it thoroughly\
    \ nor have I optimized it.  But it should work.\n<code>\ndef sort_array(array):\n\
    \    if len(array) > 1:\n        sum_arr = [sum(array[:i + 1]) for i in range(len(array))]\n\
    \        if (sum_arr[len(sum_arr) - 1] % 2) == 0:\n            sum_arr.pop()\n\
    \        else:\n            sum_arr = [-x for x in sum_arr]\n    else:\n     \
    \   sum_arr = []", "{\n    long sumOfFirstIndexElements = 0;\n    long sumOfLastIndexElements\
    \ = array[array.length-1];\n    \n    if(sumOfFirstIndexElements & 1L) \n    {\n\
    \        //sumOfFirstIndexElements is odd, sort it in descending order\n     \
    \   for(int i = 0; i < array.length-1; i++) \n        {\n            long temp\
    \ = array[i];\n            array[i] = array[array.length-1-i]; \n            array[array.length-1-i]\
    \ = temp; \n        }\n    } \n    else \n    {\n        //sumOfFirstIndexElements\
    \ is even, sort it in ascending order\n        for(int i = 0; i < array.length-1;\
    \ i++) \n        {\n            long temp = array[i];\n            array[i] =\
    \ array[i-1]; \n            array[i-1] = temp; \n        }\n    }\n    \n    for(int\
    \ i = 0; i < array.length; i++) \n    {\n        sumOfFirstIndexElements += array[i];\n\
    \        sumOfLastIndexElements += array[array.length-1-i];\n    }\n    \n   \
    \ long sumOfFirstIndexElementsReversed = sumOfFirstIndexElements;\n    sumOfFirstIndexElements\
    \ = sumOfFirstIndexElementsReversed << 1;\n    sumOfFirstIndexElements += sumOfLastIndexElements;\n\
    \    \n    int firstIndex = 0;\n    int lastIndex = array.length - 1;\n    int\
    \ midIndex = -1;\n    while(firstIndex < lastIndex)\n    {\n        midIndex =\
    \ (firstIndex + lastIndex) / 2;\n        if(sumOfFirstIndexElements == array[midIndex])\n\
    \        {\n            firstIndex = midIndex + 1;\n        }\n        else \n\
    \        {\n            lastIndex = midIndex - 1;\n        }\n    }\n    \n  \
    \  return array;\n}\n</code>\n<|/ a |>\n<| a dscore=1 |>\nI like all the solutions\
    \ that uses recursion, but I think it would be better to use a for-loop for better\
    \ legibility:\n<code>\npublic int[] sort_array(int[] arr) {\n    long sumOfFirstIndexElements\
    \ = 0;\n    long sumOfLastIndexElements = arr[arr.length - 1];\n    for (int i\
    \ = 0; i < arr.length; i++) {\n        sumOfFirstIndexElements += arr[i];\n  \
    \      sumOfLastIndexElements += arr[arr.length - 1 - i];\n    }", "{\n    int\
    \ n = array.length, sum = 0;\n    for(int i = 0; i < n; ++i)\n        sum += array[i];\n\
    \    if(sum % 2 == 0) return array;\n    else return sort_array(array, true);\n\
    }\n</code>\n<|/ a tags=arrays,sorting,java |>\n<| a dscore=0 |>\n<code>\nimport\
    \ java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;",
  "{\n    long sum = 0;\n    for(long i : array)\n        sum += i;\n    int odd =\
    \ sum % 2 == 1;\n    if(odd)\n        std.arraysort(array, (a, b) -> a > b ? 1\
    \ : -1);\n    else\n        std.arraysort(array, (a, b) -> a < b ? 1 : -1);\n\
    \    return array;\n}", "{\n    long sum = 0;\n    int size = array.size();\n\
    \    long[] result = new long[size];\n    for(int i=0; i<size; i++)\n    {\n \
    \       sum = sum + array[i];\n        result[i] = array[i];\n    }\n    if (sum\
    \ % 2 == 1) // even sum\n    {\n        for(int i=size-1; i>=0; i--)\n       \
    \ {\n            for(int j=i-1; j>=0; j--)\n            {\n                if\
    \ (result[j] > result[j+1])\n                {\n                    long tmp =\
    \ result[j];\n                    result[j] = result[j+1];\n                 \
    \   result[j+1] = tmp;\n                }\n            }\n        }\n    } //\
    \ odd sum\n    else // even sum\n    {\n        for(int i=size-1; i>=0; i--)\n\
    \        {\n            for(int j=i-1; j>=0; j--)\n            {\n           \
    \     if (result[j] < result[j+1])\n                {\n                    long\
    \ tmp = result[j];\n                    result[j] = result[j+1];\n           \
    \         result[j+1] = tmp;\n                }\n            }\n        }\n  \
    \  }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=arrays,java\
    \ dscore=0 |>\nHere is a solution that uses two separate arrays, one holding the\
    \ elements you are summing and the other holding the remainder from the division.\
    \ After all elements are added they are sorted and divided by the dividend. If\
    \ all elements are equal the dividend is divided by 2 and the cycle restarts.\n\
    <code>\npublic int[] sort(int[] arr) {", "{\n    long[] result = new long[array.length];\n\
    \    int i, j;\n    long sum;\n    int sortOrder;\n    for(j = 0; j < array.length;\
    \ j++)\n    {\n        sum = 0;\n        for(i = 0; i < j; i++)\n        {\n \
    \           sum += array[i];\n        }\n        sortOrder = sum % 2 == 1 ? (sum\
    \ > 0 ? 1 : -1) : 0;\n        if(sortOrder == -1)\n        {\n            Arrays.sort(array,\
    \ j, array.length - j);\n            for(long k = j; k > 0; k--)\n           \
    \ {\n                result[k] = array[k - 1];\n            }\n            return\
    \ result;\n        }\n        else\n        {\n            Arrays.sort(array,\
    \ j, array.length - j);\n            for(long k = j; k > 0; k--)\n           \
    \ {\n                result[k] = array[array.length - k - 1];\n            }\n\
    \            return result;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI appreciate that this answer is from your \"OCD\" school,\
    \ but please don't use \"OCD\" when answering Stack Overflow questions.  Your\
    \ \"OCD\" comment is inappropriate to the SO community.\n<|/ c |>\n<| c |>\nAnd\
    \ \"OCD\" is an opinion, not an insult.  We both have different opinions on how\
    \ to write code.  That's why I didn't even know what OCD is until I saw this answer\
    \ here.\n<|/ c |>\n<| c |>\nThanks Sir, It was an accident of OCD in my previous\
    \ answer, but now I updated my answer with a better solution.\n<|/ c |>\n<| a\
    \ |>\nOkay, so after I got some help from my friends I did this and got this:\n\
    <code>", "{\n    long[] result = new long[array.length];\n    long[] newArray\
    \ = array.clone();\n    Arrays.sort(newArray, (int a, int b) -> (a > b) ? 1 :\
    \ ((a < b) ? -1 : 0));\n    int evenSum = 0;\n    for (int i = 0; i < newArray.length;\
    \ i++) {\n        result[i] = newArray[i];\n        evenSum += result[i];\n  \
    \  }\n    if (evenSum % 2 == 0) {\n        Arrays.sort(result, (int[] x, int[]\
    \ y) -> IntStream.range(0, Math.min(x.length, y.length))\n                .sorted((a,\
    \ b) -> x[a].compareTo(y[b]))\n                .toArray());\n    } else {\n  \
    \      Arrays.sort(result, (int[] x, int[] y) -> IntStream.range(0, Math.min(x.length,\
    \ y.length))\n                .sorted((a, b) -> y[b].compareTo(x[a]))\n      \
    \          .toArray());\n    }\n    return result;\n}\n</code>\n<|/ a tags=algorithm,sorting,java,arrays\
    \ dscore=2 |>\n<| c |>\nThis is not the sorting. It just checks if it is even.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "{\n    long[] result = array.clone();\n\
    \    int len = array.length, minIndex, maxIndex;\n    long sum;\n    long sumLast\
    \ = array[0];\n    for (int i = 0; i < len; i++) {\n        sum += array[i];\n\
    \        if (sum % 2 == 0) {\n            sumLast = sum;\n        } else {\n \
    \           sum -= sumLast;\n        }\n        minIndex = i;\n        for (int\
    \ j = i; j < len; j++) {\n            if (sum < sumLast) {\n                break;\n\
    \            } else {\n                sum -= array[j];\n                maxIndex\
    \ = j;\n            }\n        }\n        if (maxIndex == i) {\n            sumLast\
    \ += array[maxIndex];\n        } else {\n            long tempSum = sumLast +\
    \ array[maxIndex];\n            sumLast += array[minIndex];\n            array[minIndex]\
    \ = tempSum;\n        }\n        long tempSum = sum + array[minIndex];\n     \
    \   sum = tempSum;\n    }\n    for (int i = 0; i < len; i++) {\n        result[i]\
    \ = array[i];\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 tags=arrays,java\
    \ |>\n<| a dscore=0 tags=arrays,java |>\nThis solution does not require the creation\
    \ of any extra arrays, does not require the knowledge of the maximum value of\
    \ the array, and is O(n) instead of O(n^2).\n<code>\nprivate static int[] sortArray(int[]\
    \ array){\n    if(array.length == 0) return array;\n    Arrays.sort(array);\n\
    \    int min = Integer.MAX_VALUE;\n    int max = Integer.MIN_VALUE;\n    int minIndex\
    \ = -1;\n    int maxIndex = -1;\n    for(int i = 0; i < array.length; i++){\n\
    \        min = Math.min(array[i], min);\n        max = Math.max(array[i], max);\n\
    \        int minIndexInArray = i;\n        for(int j = i + 1; j < array.length;\
    \ j++){\n            if(array[j] < array[j - 1]){\n                break;\n  \
    \          }\n        }\n        int index = j - 1;\n        if(array[index] <\
    \ array[index - 1])\n            minIndexInArray = index;\n        if(array[index]\
    \ > array[index - 1])\n            maxIndexInArray = index;\n        if(array[index]\
    \ == array[index - 1])\n            continue;\n        int temp = array[index];\n\
    \        array[index] = array[index - 1];\n        array[index - 1] = temp;\n\
    \    }\n    return array;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n//\
    \ Sorting a given array in ascending order if the sum( first index value, last\
    \ index value) is odd or in descending order if the sum( first index value, last\
    \ index value) is even", "{\n    long[] result;\n    int count = 0;\n    int oddSum\
    \ = 0;\n    int evenSum = 0;", "{\n    if(array.length <= 1) return array;\n \
    \   \n    int sum = (int)(array[0] + array[array.length - 1]);\n    \n    if(sum%2\
    \ == 0){\n        long[] temp = new long[array.length];\n        for(int i = 0;\
    \ i < array.length; i++){\n            temp[i] = array[i];\n        }\n      \
    \  \n        Arrays.sort(temp);\n        \n        return temp;\n    }else{\n\
    \        long[] temp = new long[array.length];\n        for(int i = 0; i < array.length;\
    \ i++){\n            temp[i] = array[i];\n        }\n        \n        Arrays.sort(temp,\
    \ new longComparator());\n        \n        return temp;\n    }\n}", "{\n    int\
    \ sum = 0;\n    int odd_sum = 0;\n    int[] temp = new int[array.length];\n  \
    \  for (int i = 0; i < array.length; i++) \n    {\n        temp[i] = array[i];\n\
    \    }\n    for (int i = 0; i < temp.length; i++) \n    {\n        sum += temp[i];\n\
    \        if (sum % 2 != 0) \n        {\n            odd_sum += temp[i];\n    \
    \    }\n    }\n    int[] result = new int[temp.length];\n    for (int i = 0; i\
    \ < temp.length; i++) \n    {\n        result[i] = temp[odd_sum - temp[i]];\n\
    \        odd_sum += temp[i];\n    }\n    return result;\n}", "{\n    long sum;\n\
    \    long temp;\n    int flag = 1;\n    \n    for (int i = 0; i < array.Length;\
    \ i++){\n        flag = sum;\n        sum = 0;\n        \n        for (int j =\
    \ i; j < array.Length; j++){\n            sum += array[j];\n        }\n      \
    \  if (sum % 2 == 0) {\n            if (sum < array[i]) {\n                temp\
    \ = array[i];\n                array[i] = array[sum];\n                array[sum]\
    \ = temp;\n            }\n        } else if (flag == 1 && sum > array[i]) {\n\
    \            temp = array[i];\n            array[i] = array[sum];\n          \
    \  array[sum] = temp;\n        }\n    }\n    return array;\n}\n</code>\n<|/ a\
    \ tags=sorting,algorithm,c# |>\n<| a dscore=0 tags=sorting,algorithm,c# |>\nI\
    \ wrote this in python:\n<code>\ndef cod_sort(arr):\n    sum = 0\n    flag = True\n\
    \    while flag:\n        flag = False\n        for i in range(len(arr)):\n  \
    \          sum += arr[i]\n            if sum % 2:\n                arr[i], arr[sum]\
    \ = arr[sum], arr[i]\n                flag = True\n                break\n   \
    \ return arr\n</code>\n<|/ a |>\n<| a tags=sorting,algorithm,c# dscore=0 |>\n\
    You can try this:\n<code>", "{\n    int sum = 0;\n    long[] copy = new long[array.length];\n\
    \    for (int i = 0; i < array.length; i++) \n    {\n        copy[i] = array[i];\n\
    \        sum += copy[i];\n    }\n    if (sum & 1L) \n    {\n        copy.sort(reverseOrder());\n\
    \    }\n    else \n    {\n        copy.sort();\n    }\n    return copy;\n}", "{\n\
    \    int left = 0;\n    int right = array.length - 1;", "{\n    int i, j, sum_even\
    \ = 0, sum_odd = 0;\n    long[] new_array = new long[array.Length];\n    long[]\
    \ result_array = new long[array.Length];\n    \n    for(i = 0; i < (array.Length-1);\
    \ i++)\n    {\n        sum_even += array[i];\n    }\n    \n    for(j = 0; j <\
    \ (array.Length-1); j++)\n    {\n        sum_odd += array[j];\n    }\n    \n \
    \   long temp_odd;\n    long temp_even;\n    long temp_sum;\n    \n    for(i =\
    \ 0; i < (array.Length-1); i++)\n    {\n        temp_odd = array[i];\n       \
    \ temp_even = array[i+1];\n        temp_sum = temp_odd + temp_even;\n        if(temp_sum\
    \ % 2 == 0)\n        {\n            temp_odd = temp_sum - temp_even;\n       \
    \ }\n        else\n        {\n            temp_odd = temp_sum + temp_even;\n \
    \       }\n        new_array[i] = temp_odd;\n        new_array[i+1] = temp_even;\n\
    \    }\n    \n    for(i = 0; i < (array.Length-1); i++)\n    {\n        temp_odd\
    \ = new_array[i];\n        temp_even = new_array[i+1];\n        temp_sum = temp_odd\
    \ + temp_even;\n        if(temp_sum % 2 == 0)\n        {\n            temp_odd\
    \ = temp_sum - temp_even;\n        }\n        else\n        {\n            temp_odd\
    \ = temp_sum + temp_even;\n        }\n        result_array[i] = temp_odd;\n  \
    \      result_array[i+1] = temp_even;\n    }\n    return result_array;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nHere's a generic solution.\n<code>\npublic class Sort<T>\
    \ {\n    private T[] arr;\n    private int left, right;\n    private int sum;",
  "{\n    if(array.length <= 0) return array;\n    long[] result = new long[array.length];\n\
    \    long[] sorted = new long[array.length];\n    int start = 0;\n    int end\
    \ = 0;\n    int middle = 0;\n    int middle2 = array.length / 2;\n    long sum\
    \ = 0;\n    int flag = 0;", "{\n    long sum = 0;\n    for (int i = 0; i < array.length;\
    \ i++)\n        sum += array[i];\n    int sumEven = sum % 2 == 0 ? 1 : 0;\n  \
    \  int sumOdd = sum / 2;\n    int evenPosition = 0;\n    int oddPosition = 0;\n\
    \    \n    for(int i=0; i<array.length; i++)\n    {\n        if(array[i] % 2 ==\
    \ 0)\n        {\n            evenPosition++;\n            array[array[i]] = array[array[i]]\
    \ - evenPosition;\n        }\n        else\n        {\n            oddPosition++;\n\
    \            array[array[i]] = array[array[i]] - oddPosition;\n        }\n   \
    \ }\n    \n    long[] result = new long[array.length];\n    for(int i=0; i<array.length;\
    \ i++)\n    {\n        if(array[i] % 2 == 0)\n            result[i] = array[i];\n\
    \        else\n        {\n            result[i] = array[i] - array[i] % 2;\n \
    \           result[i] *= -1;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI haven't tested it, but this doesn't seem to work,\
    \ could you please explain more how you got to the correct result? Because the\
    \ problem is somehow subtle. Also what is the point of doing this? Because this\
    \ seems to be a very inefficient way of doing it.\n<|/ c |>\n<| a tags=sorting,arrays\
    \ dscore=0 |>\n<code>\npackage com.company;", "{\n    if (array.length == 0) return\
    \ array;", "{\n    int n = (int)array.length, i = 0, j = 0;\n    int sum = 0;\n\
    \    long[] res = new long[n];\n    long[] temp = new long[n];\n    while(i <\
    \ n){\n        sum = 0;\n        for(j = 0; j < n; j++){\n            if(j !=\
    \ i)\n                sum += array[j];\n        }\n        if(sum%2 == 1)\n  \
    \          temp[i] = array[i];\n        else{\n            temp[i] = array[n -\
    \ 1];\n            --n;\n        }\n        i++;\n    }\n    while(j < n){\n \
    \       temp[j] = array[j++];\n    }\n    for(i = 0; i < n; i++){\n        res[i]\
    \ = temp[i];\n    }\n    return res;\n}", "{\n    int sum = 0, i = 0, n = array.length;\n\
    \    long[] ret = new long[n];\n    \n    while(i < n){\n        sum = 0;\n  \
    \      \n        for(int j = 0; j < i; ++j){\n            sum += array[j];\n \
    \       }\n        \n        if(sum % 2 == 0){\n            for(int j = 0; j <\
    \ i; ++j){\n                ret[i++] = array[j];\n            }\n        }else{\n\
    \            for(int j = 0; j < i; ++j){\n                ret[i--] = array[j];\n\
    \            }\n        }\n    }\n    \n    return ret;\n}", "{\n    if(array.length\
    \ == 0)\n        return array;", "{\n    return std.sort(array);\n}", "{\n  int\
    \ sum = 0;\n  for(int i = 0; i < array.length; i++) sum += array[i];\n  if(sum\
    \ % 2 == 1)\n  {\n    array = array.sort().reverse();\n  }\n  return array;\n\
    }\n</code>\n<|/ a tags=arrays,sorting,java |>\n<| a tags=arrays,sorting,java |>\n\
    This is an optimized version to sort the array based on condition asked in Question.\n\
    <code>\nimport java.util.Arrays;", "{\n    long sum = 0;\n    long sumLast = 0;\n\
    \    int isEven = 0;\n    int n = 0;\n    for (int i = 0; i < array.length; i++)\n\
    \    {\n        sum += array[i];\n        sumLast += array[i];\n        if (sumLast\
    \ % 2 == 0)\n        {\n            isEven = 1;\n        }\n    }\n    long[]\
    \ temp = new long[array.length];\n    for (int i = 0; i < array.length; i++)\n\
    \    {\n        if (isEven == 0)\n        {\n            temp[n] = array[i];\n\
    \            n++;\n        }\n        else\n        {\n            temp[n] = array[array.length\
    \ - i - 1];\n            n++;\n        }\n        sumLast += temp[n];\n      \
    \  isEven = sumLast % 2 == 0;\n    }\n    return temp;\n}\n</code>\n<|/ a |>\n\
    <| c |>\ni think u did not understand what i was asking for.\n<|/ c |>\n<| c |>\n\
    I did not understand what you said. Can you give an example?\n<|/ c |>\n<| c |>\n\
    sorry my bad :) just updated my question. i hope you understand now.\n<|/ c |>\n\
    <| c |>\nCheck this updated answer. I've updated it a little bit to fix some bugs\
    \ and make it look more legible.\n<|/ c |>\n<| a tags=algorithm,java,sorting dscore=0\
    \ |>\n<code>\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\n\
    import java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;",
  "{\n    int len = array.length;\n    if (len == 0)\n        return array;\n    int\
    \ minIndex = len - 1;\n    int maxIndex = len - 2;\n    long[] results = new long[len];\n\
    \    // Ascending order\n    int sum = 0;\n    for(int i = 0; i < len; i++)\n\
    \    {\n        sum += array[i];\n        if (sum % 2 == 1)\n            sum--;\n\
    \        if (sum % 2 == 0)\n            results[i] = array[i];\n    }\n    //\
    \ Descending order\n    sum = 0;\n    for(int i = len - 1; i >= 0; i--)\n    {\n\
    \        sum += array[i];\n        if (sum % 2 == 0)\n            sum++;\n   \
    \     if (sum % 2 == 1)\n            results[i] = array[i];\n    }\n    return\
    \ results;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nHi Jack, how do you print\
    \ out the results of the sorting method? I tried printing out the results at the\
    \ end of my main method but it doesn't work. Thanks\n<|/ c |>\n<| a |>\nMy guess\
    \ is that it is something related to the array index not being incremented after\
    \ the swap operation. It should work fine as long as the array is sorted properly.\n\
    <|/ a dscore=0 tags=arrays,sorting,java |>\n<| c |>\nThanks for your help! I added\
    \ the code you suggested but it still gives me the same error.\n<|/ c |>\n<| c\
    \ |>\nThe problem is in the main method because of the printing out part.\n<|/\
    \ c |>\n<| c |>\nDid you copy the code as it is or did you try to adapt it?\n\
    <|/ c |>\n<| a tags=arrays,sorting,java dscore=0 |>\nThe problem is here:\n<code>\n\
    \    for(int i = len - 1; i >= 0; i--)\n    {\n        sum += array[i];\n    \
    \    if (sum % 2 == 0)\n            sum++;\n        if (sum % 2 == 1)\n      \
    \      results[i] = array[i];\n    }\n</code>\nYou are iterating from len-1 to\
    \ 0, but then you compare with len. Change it to:\n<code>\n    for(int i = len\
    \ - 1; i >= 0; i--)\n    {\n        sum += array[i];\n        if (sum % 2 == 0)\n\
    \            sum++;\n        if (sum % 2 == 1)\n            results[i - 1]=array[i];\n\
    \    }\n</code>\nand it will work.\n<|/ a |>\n<| a tags=arrays,sorting,java dscore=0\
    \ |>\nThis is my code of bubble sort for descending order. It works pretty well\
    \ for me.\n<code>\npublic class BubbleSortDescending {", "{\n    long[] new_array\
    \ = new long[array.length];", "{\n    if(array.Length > 0)\n    {\n        long\
    \ sumFirst = array.First();\n        long sumLast = array.Last();", "{\n    long\
    \ sum;\n    long lastValue = array.Length;", "{\n  long sum;\n  if(array.length==0)\
    \ return array;\n  sum=0;\n  for(int i=0;i<array.length;i++)\n  {\n    sum+=array[i];\n\
    \  }\n  if(sum%2==1) return array.sorted;\n  return array.sorted(0, array.length-1);\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=arrays,sorting,java |>\n<code>\n    public\
    \ class SortArray {\n        public static void main(String[] args){\n       \
    \     int[] ar = new int[]{2,4,6,8,3,5,7};\n            int n = ar.length;\n \
    \           int m = (int)((n + 1)/2) - 1;\n            int x = n-1;\n        \
    \    int y;\n            while(x>=1){\n                y=n-m;\n              \
    \  if(ar[x]+ar[y]>ar[x+1]) y=y+1;\n                if(ar[x]+ar[y]<ar[x-1]) y=y-1;\n\
    \                int temp =ar[x];\n                ar[x]= ar[y];\n           \
    \     ar[y]=temp;\n                x-=1;\n                y-=1;\n            \
    \    m--;\n            }\n            for(int i=0;i<n;i++){\n                System.out.print(ar[i]+\"\
    \ \");\n            }\n        }\n    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nHere is my solution: \n<code>\npublic class SortArray {\n    public static\
    \ int[] sortArray(int[] arr) {\n        int temp = 0;\n        int swap = 0;\n\
    \        int n = arr.length;", "{\n    if (array == null)\n        return null;",
  "{\n    if(array.length<2){\n        return array;\n    }\n    long[] sorted=new\
    \ long[array.length];\n    for(int i=0;i<array.length;i++){\n        if(array[i]<0){\n\
    \            throw new RuntimeException(\"You cannot sort the array if its value\
    \ is negative!\");\n        }\n        sorted[i]=array[i];\n    }\n    Arrays.sort(sorted);\n\
    \    int sum=0;\n    for(int i=0;i<sorted.length;i++){\n        sum+=sorted[i];\n\
    \    }\n    if(sum%2==1){\n        Arrays.sort(sorted);\n    }\n    return sorted;\n\
    }\n/*", "{\n    if (array.empty()) return array;\n    \n    long[] ans = array;\n\
    \    int len = array.size();\n    int sum = 0;\n    for (long i : ans)\n     \
    \   sum += i;\n    \n    if (sum % 2 == 1)\n        ans.sort((a,b) => b - a);\n\
    \    else\n        ans.sort((a,b) => a - b);\n    return ans;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=arrays,algorithm,sorting,python |>\n<code>\ndef sort_array(arr):\n\
    \    return sorted(arr, reverse=True) if sum(arr) % 2 == 0 else sorted(arr, reverse=False)\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=arrays,algorithm,sorting,python\
    \ |>\nHere's another way that does a linear pass over the array and doesn't require\
    \ storing the array in memory.\n<code>\ndef sort_array(arr):\n    arr = arr.copy()\n\
    \    arr.sort()\n    odd = 1\n    for i in range(len(arr)):\n        odd = (odd\
    \ + 1) % 2\n        if odd==1:\n            arr[i], arr[arr.index(i)] = arr[arr.index(i)],\
    \ arr[i]\n    return arr", "{\n    if(array.length == 0)\n        return array;\n\
    \    int first = array[0];\n    int last = array[0];\n    for(int i = 1; i < array.length;\
    \ i++)\n    {\n        if(array[i] > last)\n            last = array[i];\n   \
    \     if(array[i] < first)\n            first = array[i];\n    }\n    int sumFirst\
    \ = (first + last) / 2;\n    if(sumFirst % 2 == 1)\n    {\n        Arrays.sort(array);\n\
    \    }\n    else\n    {\n        Arrays.sort(array, array.size()-1, 1, -1);\n\
    \    }\n    return array;\n}\n</code>\n<|/ a |>\n<| a |>\nIf you want a solution\
    \ in Scala, you can use recursion:\n<code>\ndef sortedSum(a: Array[Int]): Int\
    \ = {\n  def sum(a: Array[Int], acc: Int): Int = {\n    if (a.isEmpty) acc\n \
    \   else {\n      val x = a.head\n      val y = a.last\n      val newAcc = x +\
    \ y + acc\n      sum(tail(a), newAcc)\n    }\n  }", "{\n    var sum = 0;\n   \
    \ for(int i = 0; i < array.Length; ++i)\n    {\n        sum += array[i];\n   \
    \ }\n    if(sum % 2 == 0)\n    {\n        int[] arr = new int[array.Length];\n\
    \        int counter = 0;\n        for(int i = 0; i < array.Length; ++i)\n   \
    \     {\n            arr[counter++] = array[i];\n        }\n        Array.Sort(arr);\n\
    \        long[] res = new long[arr.Length];\n        for(int i = 0; i < res.Length;\
    \ ++i)\n        {\n            res[i] = arr[counter-i-1];\n        }\n       \
    \ return res;\n    }\n    else\n    {\n        int[] arr = new int[array.Length];\n\
    \        int counter = array.Length-1;\n        for(int i = 0; i < array.Length;\
    \ ++i)\n        {\n            arr[counter] = array[i];\n            --counter;\n\
    \        }\n        Array.Sort(arr);\n        long[] res = new long[arr.Length];\n\
    \        for(int i = 0; i < res.Length; ++i)\n        {\n            res[i] =\
    \ arr[counter-i];\n        }\n        return res;\n    }\n}\n</code>\n<|/ a |>\n\
    <| c |>\nYour approach is wrong on all counts. The given array is supposed to\
    \ be sorted in ascending order if the sum of the first and last elements is odd,\
    \ otherwise in descending order. Your code will do that if your sum is even.\n\
    <|/ c |>\n<| c |>\n- I haven't done any C# in a while, and didn't look carefully\
    \ at the code when looking at the question. Thanks for the comment, I'll update\
    \ the answer.\n<|/ c |>\n<| a tags=c#,algorithm dscore=2 |>\nI wanted to post\
    \ a solution using an array, and I decided to go for a LINQ solution. It would\
    \ take too much time to convert this into a loop. Also I wanted to keep it simple\
    \ so I didn't use any unnecessary complexity.\nThe code should be self explanatory,\
    \ I used some LINQ extensions to make it shorter.\n<code>\nusing System;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;", "{\n    long[] result = new\
    \ long[array.Length];\n    int evenSum = 0;\n    int oddSum = 0;\n    long lastValue\
    \ = array[array.Length-1];\n    long firstValue = array[0];\n    for(int i = 0;\
    \ i < array.Length; ++i)\n    {\n        long currentValue = array[i];\n     \
    \   if(currentValue < firstValue)\n        {\n            throw new Exception(\"\
    The given array should be sorted in ascending order if sum of the first and the\
    \ last elements is odd, or sorted in descending order if sum of the first and\
    \ the last elements is even\");\n        }\n        else if(currentValue == firstValue)\n\
    \        {\n            result[i] = currentValue;\n        }\n        else if(currentValue\
    \ > lastValue)\n        {\n            result[i] = currentValue;\n        }\n\
    \        else if(currentValue == lastValue)\n        {\n            if(currentValue\
    \ % 2 == 0)\n            {\n                oddSum = currentValue - firstValue\
    \ + lastValue;\n                evenSum = (oddSum - 1) % 2; // oddSum - 1 should\
    \ be even so that oddSum % 2 == 0\n            }\n            else\n         \
    \   {\n                evenSum = currentValue - firstValue + lastValue;\n    \
    \            oddSum = (evenSum - 1) % 2;\n            }\n            if(oddSum\
    \ % 2 == 1) // oddSum % 2 == 0 means evenSum == 0 or evenSum == 1\n          \
    \  {\n                result[i] = firstValue;\n                firstValue = lastValue;\n\
    \                lastValue = 0;\n            }\n            else\n           \
    \ {\n                result[i] = lastValue;\n                firstValue = lastValue;\n\
    \                lastValue = 0;\n            }\n        }\n        else\n    \
    \    {\n            result[i] = currentValue;\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis works well but what about performance\
    \ issues? I mean for larger arrays, what will be the best solution?\n<|/ c |>\n\
    <| c |>\nI'm afraid it is impossible to do better than O(n).\n<|/ c |>\n<| c |>\n\
    I think it's better to create an array of size equal to size of array, and sort\
    \ it. Then, the sorted array will be easy to retrieve from the original array.\
    \ \nAlso you should use some form of binary search instead of linear search. \n\
    But if you can't do this, then I think it is impossible to achieve better than\
    \ O(n).\n<|/ c |>\n<| a tags=arrays,algorithm,c#,java |>\n<code>\nusing System;\n\
    using System.Collections.Generic;", "{\n    return std.arraySort(array, \n   \
    \     (a, b) => \n        { \n            if( a > b ) return 1L; \n          \
    \  if( a < b ) return -1L;\n            return 0;\n        }\n    );\n}", "{\n\
    \    long[] arr2 = array;", "{\n    int len = array.length;\n    if (len < 2)\n\
    \        return array;\n    long[] ret = new long[len];\n    int sum = 0;\n  \
    \  for (int i = 0; i < len; i++) {\n        sum += array[i];\n        ret[i] =\
    \ array[i];\n    }\n    sorting_descending sorting = sort_descending;\n    if\
    \ (sum % 2 != 0) {\n        sorting = sort_ascending;\n        Arrays.sort(ret,\
    \ sorting);\n    }\n    return ret;\n}\n</code>\n<|/ a dscore=2 tags=algorithm,java\
    \ |>\n<| a dscore=1 |>\nThis solution has O(n) time complexity and O(1) space\
    \ complexity\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.List;", "{\n    // write your code here\n    long[] res=new long[array.length];\n\
    \    if(array.length==0)\n        return array;\n    Arrays.sort(array);\n   \
    \ long sum=array[0]+array[array.length-1];\n    int odd=sum%2;\n    if(odd)\n\
    \    {\n        for(int i=0;i<array.length-1;i++)\n        {\n            res[i]=array[i];\n\
    \        }\n        res[array.length-1]=array[array.length-1];\n        return\
    \ res;\n    }\n    else\n    {\n        for(int i=0;i<array.length-1;i++)\n  \
    \      {\n            res[i]=array[array.length-1-i];\n        }\n        res[0]=array[0];\n\
    \        res[array.length-1]=array[array.length-1];\n        return res;\n   \
    \ }\n}", "{\n    int[] arrLen = new int[array.length];\n    long sum = 0;\n  \
    \  int flag = 0;\n    for (int i = 0; i < array.length; i++){\n        arrLen[i]\
    \ = array.length;\n    }\n    for (int i = 0; i < array.length; i++){\n      \
    \  for (int j = i+1; j < array.length; j++) {\n            if (sum + array[i]\
    \ < array[j]) {\n                arrLen[i] = array.length;\n                sum\
    \ = 0;\n                flag = 0;\n            }\n            if (sum + array[i]\
    \ > array[j]) {\n                arrLen[j] = array.length;\n                sum\
    \ = array[j];\n                flag = 1;\n            }\n        }\n    }\n  \
    \  long[] res = new long[arrLen[0]];\n    long max = 0;\n    int i = 0;\n    for\
    \ (int j = 0; j < arrLen.length; j++){\n        res[i] = array[j];\n        max\
    \ = sum;\n        sum += arrLen[j];\n        for (int k = 0; k < array.length;\
    \ k++){\n            if (k == j) continue;\n            long cur = array[k];\n\
    \            if (cur > max){\n                max = cur;\n            }\n    \
    \    }\n        res[i] = max;\n        sum -= max;\n        max = sum;\n     \
    \   i++;\n    }\n    return res;\n}\n/*", "{\n    if(array.Length == 0) return\
    \ array;\n    var ans = array.ToArray();\n    Array.Sort(ans);\n    if(ans.Length\
    \ % 2 == 1)\n    {\n        Array.Sort(ans, 0, ans.Length - 1);\n    }\n    return\
    \ ans;\n}", "{\n    int sum = 0;\n    for(int i = 0; i < array.length; i++) \n\
    \    {\n        sum += array[i];\n    }\n    long[] result = new long[array.length];\n\
    \    int len = result.length;\n    if(sum % 2 == 1)\n    {\n        Arrays.sort(result);\n\
    \    }\n    else\n    {\n        Arrays.sort(result, (a,b) -> (long)a - b);\n\
    \    }\n    for(int i = 0; i < len; i++)\n    {\n        result[i] = array[i]\
    \ - result[i-1];\n    }\n    return result;\n}\n</code>\n<|/ a tags=c#,sorting,algorithm\
    \ |>\n<| a |>\n<code>\nclass Program\n{\n    static void Main(string[] args)\n\
    \    {\n        long[] input = new[] {0L, 1L, 2L, 3L, 4L, 5L};\n        long[]\
    \ output = input.OrderBy(i => i - input.First()).ToArray();\n    }\n}\n</code>\n\
    <|/ a tags=c#,sorting,algorithm dscore=4 |>\n<| a dscore=4 |>\n<code>\npublic\
    \ static void sort(long[] inputArray)\n{\n    int n = inputArray.Length;\n   \
    \ long[] outputArray = new long[n];\n    for (int i = 0; i < n; i++)\n    {\n\
    \        outputArray[i] = inputArray[n % 2 == 0 ? n - 1 - i : i];\n    }\n}\n\
    </code>\n<|/ a tags=c#,sorting,algorithm |>\n<| c |>\nThanks for the answer. I\
    \ had a question about it. Can you please explain me the conditions in if statement.\
    \ It looks like you assigned 'i' to the value of 'i-1' so that when 'i' is odd,\
    \ you reverse the array, else you simply reverse the order of the elements. Is\
    \ it correct?\n<|/ c |>\n<| a dscore=3 tags=c#,sorting,algorithm |>\n<code>\n\
    public static int[] SortArray(long [] arr)\n{\n    int length = arr.Length;\n\
    \    int[] temp = new int[length];\n    int tempInt;", "{\n    long sum;\n   \
    \ long temp;\n    int len = array.length;\n    long[] sort_array = new long[len];\n\
    \    for(int i=0; i<len; i++)\n    {\n        sum = array[i];\n        for(int\
    \ j=i+1; j<len; j++)\n        {\n            if(sum <= array[j])\n           \
    \ {\n                temp = array[i];\n                array[i] = array[j];\n\
    \                array[j] = temp;\n            }\n            sum += array[j];\n\
    \        }\n    }\n    for(int i=0; i<len; i++)\n    {\n        sort_array[i]\
    \ = array[i];\n    }\n    return sort_array;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    `std::sort` is O(n log n) algorithm. It will not work here.\n<|/ c |>\n<| c |>\n\
    : It will work, you just need to pass it the right comparator function. `std::sort`\
    \ will pass that function to the `std::vector` comparison function and that comparator\
    \ function will do the sorting as you wish.\n<|/ c |>\n<| c |>\n: Yes, but it\
    \ will not work in this case (when all numbers are less than 100). In that case\
    \ it will use default `std::less<T>` where `std::less` is defined to use `std::greater`.\
    \ Even if the OP did not explicitly state that restriction, I think it is good\
    \ practice to state it for completeness.\n<|/ c |>\n<| c |>\n: That is correct,\
    \ my mistake. However, the question asks for O(n) sorting algorithm. Not sure\
    \ why that is a requirement though. Perhaps because of the O(n) requirement on\
    \ input length.\n<|/ c |>\n<| c |>\n: Your answer actually works in O(n) time,\
    \ it just needs some more tweaks because OP is sorting an array of ints and you\
    \ want to sort it in descending order. Your answer will fail if input contains\
    \ numbers that are `>= 100`.\n<|/ c |>\n<| a |>\nIt depends on the type of your\
    \ input. Since you said your input is array of int (i think), i think you want\
    \ to sort the input array in descending order. Here's the way you can do this:\n\
    <code>\npublic static int[] descendingArray(int[] array) {\n    int[] res = new\
    \ int[array.length];\n    for (int i = array.length - 1; i >= 0; i--) {\n    \
    \    res[i] = array[i];\n    }\n    return res;\n}\n</code>\nThe above method\
    \ will return the array with elements in the descending order. Now, you can use\
    \ this method to sort your input array. The only difference is that you must call\
    \ this method from your main function.\n<|/ a dscore=2 tags=c", "{\n    int n\
    \ = array.length;\n    long[] result = new long[n];", "{\n    //O(n) time & O(1)\
    \ space\n    int start = 0;\n    int end = array.length-1;\n    int sum = 0;\n\
    \    while(start<end) {\n        sum += array[start];\n        while(sum>0) {\n\
    \            //if even\n            if(sum%2==0) \n                sum -= array[end];\n\
    \            //if odd\n            else {\n                sum -= array[start];\n\
    \                end --;\n            }\n        }\n        start ++;\n      \
    \  end --;\n    }\n    return array;\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=1\
    \ |>\n<code>\n public static void main(String [] args){\n    Scanner s = new Scanner(System.in);\n\
    \    long [] arr = new long[100];\n    System.out.println(\"Enter the numbers\
    \ : \");\n    for(int i=0; i<arr.length; i++){\n        arr[i] = s.nextLong();\n\
    \    }\n    System.out.println(\"SORTED ARRAY : \");\n    sort(arr);\n    for(int\
    \ i=0; i<arr.length; i++){\n        System.out.print(arr[i] + \" \");\n    }\n\
    \ }\n \n \n \n public static void sort(long [] arr){\n    int start = 0;\n   \
    \ int end = arr.length-1;\n    int sum = 0;\n    while(start<end){\n        sum\
    \ += arr[start];\n        while(sum>0){\n            //if even\n            if(sum%2==0){\n\
    \                sum -= arr[end];\n                end--;\n            }\n   \
    \         //if odd\n            else {\n                sum -= arr[start];\n \
    \               start++;\n            }\n        }\n        start++;\n       \
    \ end--;\n    }\n    \n }\n</code>\n<|/ a tags=arrays,java,sorting |>\n<| c |>\n\
    Thanks, this is exactly the solution that I needed.\n<|/ c |>\n<| a tags=arrays,java,sorting\
    \ dscore=1 |>\n<code>\nimport java.util.Arrays;\npublic class SortArray {\npublic\
    \ static void main(String[] args) {\n    long [] arr = new long[100];\n    System.out.println(\"\
    Enter the numbers : \");\n    for(int i=0; i<arr.length; i++){\n        arr[i]\
    \ = s.nextLong();\n    }\n    System.out.println(\"SORTED ARRAY : \");\n    sort(arr);\n\
    \    for(int i=0; i<arr.length; i++){\n        System.out.print(arr[i] + \" \"\
    );\n    }\n}\npublic static void sort(long [] arr){\n    int start = 0;\n    int\
    \ end = arr.length-1;\n    int sum = 0;\n    while(start<end){\n        sum +=\
    \ arr[start];\n        while(sum>0){\n            //if even\n            if(sum%2==0){\n\
    \                sum", "{\n    if (array.length <= 1) \n        return array;\n\
    \    long[] result = array.clone();\n    int len = result.length;\n    int sum\
    \ = 0;\n    for (int i = 0; i < len; i++)\n    {\n        sum += result[i];\n\
    \    }\n    if (sum % 2 == 1)\n    {\n        std.sort(result, 0, result.length\
    \ - 1);\n    }\n    else\n    {\n        std.sort(result, 0, result.length - 1);\n\
    \        std.reverse(result, 0, result.length - 1);\n    }\n    return result;\n\
    }", "{\n    long[] a = array;\n    for (int i = 1; i < a.length; i++) {\n    \
    \    long total = a[i] + a[i-1];\n        if (total % 2 == 1) {\n            long\
    \ temp = a[i];\n            a[i] = a[i-1];\n            a[i-1] = temp;\n     \
    \   }\n    }\n    return a;\n}", "{\n    int i = 0, j = 0;\n    long sum = 0;\n\
    \    int len = array.length;\n    long[] result = new long[len];\n    while (i\
    \ < len) {\n        sum = sum + array[i];\n        if (sum % 2 == 1) \n      \
    \  {\n            result[j++] = array[i];\n        }\n        i++;\n    }\n  \
    \  while (j < result.length)\n    {\n        result[j++] = array[0];\n    }\n\
    \    return result;\n}\n</code>\n<|/ a tags=python,algorithm,sorting |>\n<| a\
    \ |>\nThis problem can be solved using recursion.\nFor simplicity assume that\
    \ the array is of length n.\n<code>\ndef sorting_function(arr, n):\n    if n==0:\n\
    \       return []\n   else:\n     left_part = sorting_function(arr, n-1)\n   \
    \  right_part = sorting_function(arr, n)\n     return right_part+left_part\n</code>\n\
    The above solution works if arr = [1,2,3,4,5,6,7,8,9] and n = 9 because when n\
    \ = 0 the list returned from recursion will be empty list.\n<|/ a tags=python,algorithm,sorting\
    \ dscore=0 |>\n<| c |>\nThis assumes that the list is already sorted, which may\
    \ not be the case.\n<|/ c |>\n<| a tags=python,algorithm,sorting |>\n<code>\n\
    def sort_array(arr):\n    count = 0\n    \n    while count < len(arr):\n     \
    \   if arr[count] <= arr[len(arr) - 1]:\n            count += 1\n        else:\n\
    \            count = 0\n            \n        if arr[count] >= arr[len(arr) -\
    \ 1]:\n            arr.remove(arr[count])\n            count += 1\n          \
    \  \n    \n    arr.sort()\n    return arr\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    Hi Naresh, welcome to Stack Overflow! Can you please edit your answer to explain\
    \ what this code is doing in detail?\n<|/ c |>\n<| c |>\ndef sort_array(arr):\n\
    \    count = 0\n    \n    while count < len(arr):\n        if arr[count] <= arr[len(arr)\
    \ - 1]:\n            count += 1\n        else:\n            count = 0\n      \
    \      \n        if arr[count] >= arr[len(arr) - 1]:\n            arr.remove(arr[count])\n\
    \            count += 1\n            \n    \n    arr.sort()\n    return arr\n\
    <|/ c |>\n<| c |>\nHi Rushi, please edit your answer to explain what this code\
    \ does in detail. An explanation of the code would also be very useful to anyone\
    \ wanting to learn how to code themselves.\n<|/ c |>\n<| c |>\nPlease ", "{\n\
    \    long sum = 0;\n    long temp_sum = 0;\n    for (int i = 0; i < array.length;\
    \ i++) \n    {\n        sum = sum + array[i];\n    }\n    sum = (sum % 2) ? (sum\
    \ - 1) : (sum + 1);\n    int start = 0;\n    int end = array.length;\n    while\
    \ (start < end)\n    {\n        while (start < end && array[start] < 0) \n   \
    \     {\n            start++;\n        }\n        while (start < end && array[end]\
    \ > 0) \n        {\n            end--;\n        }\n        if (start >= end) \n\
    \        {\n            break;\n        }\n        temp_sum = array[start];\n\
    \        array[start] = array[end];\n        array[end] = temp_sum;\n        start++;\n\
    \        end--;\n    }\n    return array;\n}\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nI don't get how your answer relates to the question. Could you elaborate\
    \ a bit on what your code does, how does it answer the question and how it is\
    \ different from other already posted answers.\n<|/ c |>\n<| a |>\nIn Python you\
    \ can do this:\n<code>\ndef sort(array):\n    sorted_arr = [array[0]]\n    for\
    \ x in array[1:]:\n        sum_of_elements = sum(sorted_arr) + x\n        if sum_of_elements\
    \ % 2 == 1:\n            sum_of_elements = sum_of_elements - 1\n        sorted_arr.append(x)\n\
    \        sorted_arr.append(sum_of_elements)\n    return sorted_arr\n</code>\n\
    <|/ a dscore=0 tags=algorithm,sorting |>\n<| c |>\nWhat is the purpose of sorting\
    \ the array twice?\n<|/ c |>\n<| c |>\nIt was just a way to implement the sorting\
    \ algorithm on paper :).\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic static void\
    \ sort(int[] arr) {\n    List<Integer> list = new ArrayList<Integer>();\n    for\
    \ (int i = 0; i < arr.length; i++) {\n        list.add(i);\n    }\n    for (int\
    \ i = 0; i < arr.length; i++) {\n        for (int j = i; j < arr.length; j++)\
    \ {\n            if (arr[i] > arr[j]) {\n                list.set(i, list.get(j));\n\
    \                list.set(j, arr[i]);\n                arr[i] = list.get(i);\n\
    \            }\n        }\n    }\n}\n</code>\n<|/ a tags=algorithm,sorting |>\n\
    <| a dscore=0 |>\n<code>\npublic int sortArray(int[] arr, int size) {\n    int\
    \ maxSum = 0;\n    int maxIndex = 0;\n    for(int i = 0; i < size; i++) {\n  \
    \      maxSum = maxSum + arr[i];\n        if(maxSum % 2 == 1)\n            maxSum\
    \ = maxSum - 1;\n    }\n    \n    for(int i", "{\n    if (array.length < 2) \n\
    \        return array;\n    long[] a = array;\n    long[] b = new long[a.length];\n\
    \    int n = a.length;\n    sort(a, n);\n    sort(b, n);\n    return merge(sort_array(b),\
    \ sort_array(a));\n}", "{\n\tif (array.Length == 0)\n\t\treturn array;\n\tlong[]\
    \ a = array.Clone() as long[];\n\tlong s = a[0] + a[a-1];\n\tint first = 0;\n\t\
    int last = 0;\n\tbool oddSum = false;\n\twhile (first < a.Length - 1) {\n\t\t\
    if (a[first] + a[last] == s) {\n\t\t\ta[first] = a[first] + a[last];\n\t\t\ta[last]\
    \ = a[first];\n\t\t\tfirst++;\n\t\t\tlast++;\n\t\t}\n\t\telse {\n\t\t\tif (oddSum)\
    \ {\n\t\t\t\ta[first] = a[first] + a[last];\n\t\t\t\ta[last] = a[first];\n\t\t\
    \t\tfirst++;\n\t\t\t\tlast++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta[last] = a[first]\
    \ + a[last];\n\t\t\t\ta[first] = a[last];\n\t\t\t\tfirst++;\n\t\t\t\tlast++;\n\
    \t\t\t}\n\t\t\toddSum = !oddSum;\n\t\t}\n\t}\n\treturn a;\n}\n/*\n    \n    Given\
    \ an array of non-negative integers, return a cod of the given array after sorting,\n\
    \    you will sort the given array in ascending order if the sum( first index\
    \ value, last index value) is odd,\n    or sort it in descending order if the\
    \ sum( first index value, last index value) is even.", "{\n    return sort_array(array,\
    \ std.array.length(array));\n}", "{\n    int n = array.length;\n    if(n < 2)\
    \ return array;\n    long[] result = new long[n];\n    int resultSize = 0;\n \
    \   long temp;\n    for(int i = 0; i < n; i++){\n        temp = array[i];\n  \
    \      for(int j = i; j < n; j++){\n            if(array[j] < temp){\n       \
    \         result[resultSize] = array[j];\n                resultSize++;\n    \
    \            array[j] = array[j];\n            }\n        }\n        result[resultSize]\
    \ = temp;\n        resultSize++;\n    }\n    for(int i = 0; i < resultSize; i++){\n\
    \        array[i] = result[i];\n    }\n    return result;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\n<code>\nimport java.util.Arrays;", "{\n    if(array.length ==\
    \ 0) \n        return array;\n    int sum = 0;\n    for(int i = 0; i < array.length;\
    \ i++) \n        sum += array[i];\n    if(sum % 2 == 0) \n    {\n        long[]\
    \ reversed = new long[array.length];\n        for(int i = 0; i < array.length;\
    \ i++) \n            reversed[array.length - i - 1] = array[i];\n        array\
    \ = reversed;\n    }\n    std.typecons.LongArray longArray = std.typecons.LongArray.make(array);\n\
    \    longArray.sort(comparingLong());\n    return longArray.toArray();\n}\n/*",
  "{\n    int size = array.length, i = 0, j = 0;\n    long sum = 0;", "{\n  int len\
    \ = array.length, mid, sum, temp;\n  long[] cod = new long[len];", "{\n    long[]\
    \ result = new long[array.length];\n    int n = array.length;\n    for (int i\
    \ = 1; i < n; i++) {\n        int min_idx = i;\n        for (int j = i + 1; j\
    \ < n; j++) {\n            if (array[min_idx] + array[j] < array[min_idx] + array[j])\
    \ {\n                min_idx = j;\n            }\n        }\n        result[i\
    \ - 1] = array[min_idx];\n        array[min_idx] = array[i];\n    }\n    return\
    \ std.sort(result);\n}\n/*", "{\n    int i = 0, j = 0, k = 0;\n    int first =\
    \ 0, last = array.length -1;\n    long sum = 0;\n    long sum2 = 0;\n    \n  \
    \  while (i < first && j<last) {\n        sum2 = array[i];\n        sum += array[i];\n\
    \        array[i] = array[j];\n        array[j] = sum2;\n        ++i;\n      \
    \  ++j;\n    }\n    // first array is sorted\n    // second array is unsorted\n\
    \    // now sort it\n    sum2 = 0;\n    sum = 0;\n    while (j < last) {\n   \
    \     sum2 = array[j];\n        sum += array[j];\n        array[j] = sum2;\n \
    \       ++j;\n    }\n    return array;\n}", "{\n  int sum = 0;\n  for (int i =\
    \ 0; i < array.length; ++i) \n  {\n    sum += array[i]; \n  } \n  if (sum % 2\
    \ == 1L) \n  {\n    std.sort(array, std.std.reverseOrder()); \n  } \n  else \n\
    \  {\n    std.sort(array); \n  } \n  return array; \n}", "{\n    var sum = 0;\n\
    \    for (int i = 0; i < array.length; i++){\n        sum += array[i];\n    }\n\
    \    if (sum % 2 == 0)\n    {\n        array = array.sort((a,b)=>a-b);\n     \
    \   return array;\n    }\n    else\n    {\n        array = array.sort((a,b)=>b-a);\n\
    \        return array;\n    }\n}", "{\n    long sum = array[0], max_sum = 0;\n\
    \    int i = 0;\n    \n    while (i < array.lenght)\n    {\n        long value\
    \ = array[i];\n        max_sum = value;\n        \n        while (i < array.lenght\
    \ && array[i] < max_sum)\n        {\n            max_sum = array[i];\n       \
    \     i++;\n        }\n        \n        int swap = i - 1;\n        long temp;\n\
    \        \n        if (max_sum % 2 == 0)\n        {\n            temp = array[swap];\n\
    \            array[swap] = max_sum;\n            array[i - 1] = max_sum;\n   \
    \         \n            i = swap + 1;\n            \n            if (swap == array.lenght\
    \ - 1)\n            {\n                swap = 0;\n            }\n        }\n \
    \       else\n        {\n            temp = array[swap];\n            array[swap]\
    \ = max_sum;\n            array[i - 1] = max_sum;\n            \n            i\
    \ = swap;\n            \n            if (swap == array.lenght - 1)\n         \
    \   {\n                swap = 0;\n            }\n        }\n    }\n    return\
    \ array;\n}\n</code>\n<|/ a tags=java,arrays |>\n<| a dscore=1 |>\n<code>\npublic\
    \ class Solution {", "{\n    int n = array.length;\n    int sum = 0;\n    for(int\
    \ i = 0; i < n; i++){\n        sum = array[i] + sum;\n    }\n    if(sum %2 ==\
    \ 1){\n        std.arraycopy(array, 0, array, 1, n);\n        std.sort(array,\
    \ n);\n        return array;\n    }\n    long[] array2 = new long[n];\n    int\
    \ k = 0;\n    int l = 0;\n    int mid = 0;\n    for(int i = 0; i < n; i++){\n\
    \        sum = array[i] + sum;\n        if(sum % 2 == 0){\n            array2[k]\
    \ = array[i];\n            k++;\n        }else{\n            mid = sum/2;\n  \
    \          if(array[mid] <= array[i+1]){\n                array2[k] = array[mid];\n\
    \                k++;\n            }else{\n                array2[k] = array[i+1];\n\
    \                k++;\n                l += 1;\n            }\n        }\n   \
    \ }\n    array2[k] = array[array.length-1];\n    std.arraycopy(array, 0, array2,\
    \ 0, k);\n    std.sort(array2, k);\n    std.arraycopy(array2, 0, array, l, array.length-1);\n\
    \    return array;\n}\n</code>\n<|/ a tags=sorting,c++,algorithm dscore=1 |>\n\
    <| c |>\nWhy not just use a merge sort then?\n<|/ c |>\n<| a tags=sorting,c++,algorithm\
    \ |>\n<code>\n#include<iostream>\n#include<math.h>\nusing namespace std;", "{\n\
    \    var sorted = new long[array.length];\n    \n    int sum = 0;\n    for (int\
    \ i = 0; i < array.length; i++) {\n        sorted[i] = array[i];\n        sum\
    \ += array[i];\n    }\n    \n    if (sum % 2 == 0) // even\n    {\n        Arrays.sort(sorted);\n\
    \    }\n    else // odd\n    {\n        Arrays.sort(sorted, 0, sorted.length -\
    \ 1);\n    }\n    return sorted;\n}\n</code>\n<|/ a tags=java,algorithm,sorting,arrays\
    \ dscore=2 |>\n<| a tags=java,algorithm,sorting,arrays |>\nHere is an answer using\
    \ Collections.sort() as a starting point. It assumes that the first item in the\
    \ array is to be sorted to the end, and the other elements are to be sorted in\
    \ ascending order according to their first and last values:\n<code>\nimport java.util.Arrays;\n\
    import java.util.Collections;", "{\n    long sum = 0;\n    long sum2 = 0;\n  \
    \  long res = 0;\n    long[] result = new long[array.length];", "{\n    Arrays.sort(array);\n\
    \    long[] result = new long[array.size()];\n    long sum = 0;\n    for (int\
    \ i = 0; i < array.size(); ++i) {\n        sum += array[i];\n        result[i]\
    \ = sum;\n    }\n    return Arrays.asList(result);\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=algorithm,arrays,sorting |>\nI made my own solution in Python.\
    \ Hope it helps someone:\n<code>\ndef sortArray(A):\n    A.sort()\n    if len(A)\
    \ < 3:\n        return A\n    s = 0\n    last = 0\n    for i in range(len(A)):\n\
    \        if i == 0:\n            s += A[i]\n        else:\n            s += A[i]-A[i-1]\n\
    \        last = i\n        if s % 2 == 1:\n            A[i], A[last] = A[last],\
    \ A[i]\n    return A\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhat if all elements\
    \ are same. Ex:- [1, 2, 3, 3, 3, 3, 3]. Output: [1, 2, 3, 3, 3, 3, 3]\n<|/ c |>\n\
    <| a tags=algorithm,arrays,sorting |>\n<code>\n    static void sortArray(int[]\
    \ arr, int left, int right) {\n    int pivot = arr[left]; // select the pivot\
    \ as first element\n    int i = left; // left index\n    int j = right; // right\
    \ index\n    int temp = 0; // swap variable to store temporary value", "{\n  long[]\
    \ result = new long[array.length];\n  long sum;\n  for(long i = 0; i < array.length;\
    \ i++) {\n    sum = (array[i]+array[i+1]) % 2;\n    if(sum==0) {\n      result[i]\
    \ = array[i];\n      result[i+1] = array[i+1];\n    }\n    else {\n      result[i]\
    \ = array[i+1];\n      result[i+1] = array[i];\n    }\n  }\n  return result;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis will not work. Your function will throw an\
    \ exception when you pass the array `[7, 8, 9]`, because `array[i+1]` will try\
    \ to access an index that doesn't exist.\n<|/ c |>\n<| c |>\nI did a test and\
    \ found that it did work. The problem was I had a typo in the code, I edited it.\n\
    <|/ c |>\n<| c |>\nIt will work provided you also fix the typo in the `sort_array()`\
    \ function and remove the `break` statements.\n<|/ c |>\n<| c |>\nYou're right,\
    \ I fixed it and it works now, thanks for your comment!\n<|/ c |>\n<| a dscore=0\
    \ |>\nYou can use std.sort and std.array.get. I've included a snippet from my\
    \ own program to show how it works:\n<code>\nimport std.stdio;\nimport std.array;\n\
    import std.array;\nimport std.algorithm;\nimport std.sort;\nimport std.array;\n\
    import std.algorithm;", "{\n    int len = array.length, i = 0, j = 0;\n    if\
    \ (len < 2)\n        return array;", "{\n\tif (array == null || array.length ==\
    \ 0) {\n\t\treturn array;\n\t}\n\tlong[] resultArray = new long[array.length];\n\
    \tlong sum = 0;\n\tfor (int i = 0; i < array.length; i++) {\n\t\tsum += array[i];\n\
    \t}\n\tif (sum % 2 == 1) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\
    \tresultArray[i] = array[i];\n\t\t}\n\t\tstd.Arrays.sort(resultArray);\n\t} else\
    \ {\n\t\tfor (int i = array.length - 1; i >= 0; i--) {\n\t\t\tresultArray[i] =\
    \ array[i];\n\t\t}\n\t\tstd.Arrays.sort(resultArray, (a, b) -> b - a);\n\t}\n\t\
    return resultArray;\n}\n/*", "{\n    long[] result = new long[array.length];\n\
    \    int n = array.length;\n    if (n == 0) {\n        return array;\n    }\n\
    \    long[] first = new long[n];\n    long[] last = new long[n];\n    for (int\
    \ i = 0; i < n; i++) {\n        first[i] = array[i];\n        last[i] = array[n\
    \ - i - 1];\n    }", "{\n    long[] a = array;\n    long sum = std.sum(a);\n \
    \   long[] result = new long[a.length];\n    for (int i = 0; i < a.length; i++)\n\
    \    {\n        int index = i + 1;\n        int sum2 = sum % 2;\n        if (sum2\
    \ == 0)\n        {\n            result[i] = a[i];\n            continue;\n   \
    \     }\n        int index = i;\n        while (sum2 != 0)\n        {\n      \
    \      result[i] = a[index];\n            index++;\n            sum2 = sum % 2;\n\
    \            sum -= a[index];\n        }\n        result[i] = a[index];\n    }\n\
    \    return result;\n}\n</code>\n<|/ a tags=sorting,java,arrays |>\n<| a |>\n\
    Here is a solution in java based on code by Jason Tatman:\n<code>\n    public\
    \ class MergeSorter {", "{\n  int i = 0, j = 0, k = 0;\n  long[] output = new\
    \ long[array.length];\n  while (i < array.length && j < array.length) {\n    if\
    \ (array[i] < array[j]) {\n      output[k++] = array[i++];\n    } else {\n   \
    \   output[k++] = array[j++];\n    }\n  }", "{\n    var len = array.length;\n\
    \    var sum = 0;\n    \n    for(int i = 0; i < len; i++)\n        sum += array[i];\n\
    \    \n    var odd = sum & 0x1L; // get the first bit of sum\n    \n    long[]\
    \ result = new long[len];\n    \n    // sort from 0 to len - 1\n    for(int i\
    \ = 0; i < len; i++)\n    {\n        result[i] = array[i];\n    }\n    \n    //\
    \ if the sum is odd, reverse the array\n    if(odd == 1)\n    {\n        for(int\
    \ i = len - 1; i >= 0; i--)\n        {\n            result[i] = array[i];\n  \
    \      }\n    }\n    \n    return result;\n}\n</code>\n<|/ a tags=arrays,sorting,java\
    \ |>\n<| a dscore=1 |>\nThe best way would be to use the Collections class, specifically\
    \ the sort() method. As long as you implement the Comparable interface in some\
    \ way, you can then simply call the sort() method. \nYou simply have to define\
    \ your class, which can simply be an extension of the Comparable interface. \n\
    The sort() method will then call your custom compare() method which is simply\
    \ used to compare two items in the list.\n<|/ a tags=arrays,sorting,java |>\n\
    <| a |>\n<code>\n// this assumes that the values are non-negative\nprivate static\
    \ List<Integer> sort(int[] values) {\n    List<Integer> result = new ArrayList<Integer>();\n\
    \    int sum = 0;\n    int index = 0;\n    while (index < values.length) {\n \
    \       sum = sum + values[index];\n        result.add(sum);\n        index++;\n\
    \    }\n    Collections.sort(result);\n    List<Integer> finalResult = new ArrayList<Integer>();\n\
    \    int sumAfter;\n    int sumBefore;\n    for (int value : result) {\n     \
    \   sumAfter = sum;\n        sumBefore = sum;\n        sum -= value;\n       \
    \ while (index < values.length) {\n            sum -= values[index];\n       \
    \     index = index >= values.length ? 0 : index + 1;\n        }\n        sum\
    \ -= sumBefore;\n        if (sumAfter != sum) {\n            finalResult.add(sum);\n\
    \        }\n    }\n    return finalResult;\n}\n</code>\n<|/ a dscore=1 tags=arrays,sorting,java\
    \ |>\n<| c |>\nThis doesn't work for negative numbers. E.g. `Arrays.asList(5,-4,-5,2,7,-5,0,-5)`\
    \ returns `[5, 5, 0, -4, -5, -5, -2, 7]`, although it should've returned `[-5,\
    \ -4, -5, -2, 7]`.\n<|/ c |>\n<| c |>\nThe question asked for odd, not even numbers.\n\
    <|/ c |>\n<| ", "{\n    long[] result = new long[array.length];\n    Arrays.sort(array);\n\
    \    int n = array.length;\n    int sum = 0;\n    int i;\n    for(i=0;i<n;i++)\n\
    \    {\n        sum = sum + array[i];\n        if( sum%2 == 0)\n        {\n  \
    \          result[n-i-1] = array[n-i];\n        }\n        else\n        {\n \
    \           result[n-i-1] = array[array.length-1 - i];\n        }\n    }\n   \
    \ return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this code may\
    \ solve the question, [including an explanation](//meta.stackexchange.com/q/114762)\
    \ of how and why this solves the problem would really help to improve the quality\
    \ of your post, and probably result in more up-votes. Remember that you are answering\
    \ the question for readers in the future, not just the person asking now. Please\
    \ [edit] your answer to add explanations and give an indication of what limitations\
    \ and assumptions apply.\n<|/ c |>\n<| a |>\n<code>\npublic long[] sortBySum(long[]\
    \ nums){", "{\n    int i;\n    int mid=array.length/2;\n    long[] array1=array;\n\
    \    long arrsum=0;\n    for (i=0; i<mid; ++i) \n    {\n        arrsum=arrsum+array1[i];\n\
    \    }\n    long sum;\n    if (arrsum%2==1) // if the sum is odd, sort in ascending\
    \ order\n    {\n        sum=1;\n        for (i=mid; i<array.length; ++i) \n  \
    \      {\n            array1[i]=array1[i-mid];\n        }\n        array1[array.length-1]=sum;\n\
    \    }\n    else // if the sum is even, sort in descending order\n    {\n    \
    \    sum=-1;\n        for (i=mid; i>=0; --i) \n        {\n            array1[i]=array1[i-mid];\n\
    \        }\n        array1[0]=sum;\n    }\n    return array1;\n}\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=algorithm,sorting,quicksort dscore=0 |>\n<code>\nimport\
    \ java.util.*;", "{\n    int sum = 0;\n    \n    for(int i = 0; i < array.length;\
    \ ++i){\n        sum += array[i];\n    }\n    \n    if(sum % 2 == 1)\n    {\n\
    \        long temp = array[0];\n        array[0] = array[array.length - 1];\n\
    \        array[array.length - 1] = temp;\n        \n        for(int i = 0; i <\
    \ array.length - 1; ++i)\n        {\n            int j = array[i + 1];\n     \
    \       int k = array[i];\n            array[i] = k;\n            array[i + 1]\
    \ = j;\n        }\n    }\n    else\n    {\n        long temp = array[0];\n   \
    \     array[0] = array[array.length - 1];\n        array[array.length - 1] = temp;\n\
    \        \n        for(int i = array.length - 1; i >= 0; --i)\n        {\n   \
    \         int j = array[i];\n            int k = array[i + 1];\n            array[i]\
    \ = k;\n            array[i + 1] = j;\n        }\n    }\n    \n    long temp =\
    \ 0;\n    for(int i = 0; i < array.length; ++i){\n        temp += array[i];\n\
    \    }\n    \n    return array;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,arrays\
    \ |>\nPython version as requested :\n<code>\na=[2,4,3,0,1,2,5]\n</code>\nFunction\
    \ to sort array :\n<code>\ndef sort(a):\n    a.sort(reverse=True)\n    while sum(a)\
    \ > 5:\n        a.remove(a[-1])\n        a.sort()\n    return a", "{\n    if (array\
    \ == null || array.length == 0) \n    {\n        return array;\n    }\n    long[]\
    \ result = array;\n    int sum = (int) std.reduce(array, (a, b) -> a + b, 0L,\
    \ (a, b) -> a + b);\n    int index = 0;\n    while (index < array.length) \n \
    \   {\n        if (std.math.isEven(sum - array[index] + index)) \n        {\n\
    \            result[index] = array[index + 1];\n            index++;\n       \
    \ } \n        else if (std.math.isOdd(sum - array[index] + index)) \n        {\n\
    \            result[index] = array[index - 1];\n            index++;\n       \
    \ } \n        else \n        {\n            throw new IllegalArgumentException(\"\
    The given array is too short!\");\n        }\n    }\n    std.sort(result);\n \
    \   return result;\n}\n</code>\n<|/ a tags=sorting,java,arrays |>\n<| c |>\nThe\
    \ `sum` variable is redundant.  You can simply check that the `array.length` is\
    \ even.\n<|/ c |>\n<| c |>\n, Yes, you're right. I just forgot to remove it because\
    \ of the extra code in the `while` loop. I just updated the code.\n<|/ c |>\n\
    <| c |>\nThis solution does not work when array is null or empty.\n<|/ c |>\n\
    <| a dscore=4 |>\nYou can sort the array in O(n) time by doing a single pass on\
    \ the array and then doing two separate passes (one for odd-numbered elements\
    \ and one for even-numbered elements).  This is what you are doing currently,\
    \ but with two passes instead of just one.  Then you just need to sort these two\
    \ arrays individually in O(n) time.\n<|/ a tags=sorting,java,arrays |>\n<| a |>\n\
    Sort the array by putting even elements in first half and odd elements in second\
    \ half:\n<code>\nfor (int i = 0; i < array.length; i++)\n{\n  if (array[i] % 2\
    \ == 0)\n  {\n    Arrays.copyOfRange(array, 0, i);\n    Arrays.copyOfRange(array,\
    \ i, array.length);\n  }\n  else\n  {\n    Arrays.copyOfRange(array, i, array.length);\n\
    \    Arrays.copyOfRange(array, 0, i);\n  }\n}\n</code>\n<|/ a tags=sorting,java,arrays\
    \ dscore=4 |>\n<| a dscore=4 tags=sorting,java,arrays |>\n<code>\nstatic void\
    \ sort(int[] array){", "{\n    if ( array == null || array.length < 2 )\n    {\n\
    \        return array;\n    }", "{\n    if(array.Length<2)\n        return array;\n\
    \    \n    long[] sorted = new long[array.Length];\n    \n    Array.Sort(array,\
    \ 0, array.Length-1);\n    \n    if(array[0]%2==1)\n    {\n        Array.Sort(array,\
    \ 0, array.Length-1);\n        Array.Sort(sorted, 0, array.Length-1);\n    }\n\
    \    else\n    {\n        Array.Sort(array, 0, array.Length-1);\n        Array.Sort(sorted,\
    \ 0, array.Length-1);\n        Array.Sort(sorted, 0, array.Length-1);\n    }\n\
    \    \n    return sorted;\n}\n</code>\n<|/ a tags=sorting,arrays,c#,algorithm\
    \ dscore=1 |>\n<| a tags=sorting,arrays,c#,algorithm |>\nIf you're not allowed\
    \ to use LINQ, then here is a simple recursive solution:\n<code>\npublic static\
    \ void SortArrayDescending(int[] array)\n{\n    SortArrayDescendingImpl(array,\
    \ 0);\n}", "{\n    if(array.length==0) \n        return array;", "{\n  long sum\
    \ = 0;\n  for (int i = 0; i < array.length; i++) {\n    sum = array[i] + sum;\n\
    \  }\n  \n  if (sum%2 == 1) {\n    return array.sort((a, b) => a - b);\n  }\n\
    \  \n  return array.sort((a, b) => b - a);\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,c#,sorting\
    \ |>\nHere is my Java implementation (no sorting algorithms used). It is fairly\
    \ basic, only a loop over the input array is used. Not too bad for large arrays.\n\
    <code>\npublic static <T> List<T> sort(List<T> list) {\n    int sum = 0;\n   \
    \ for (int i = 0; i < list.size(); i++) {\n        sum += list.get(i);\n    }\n\
    \    int n = list.size();\n    for (int i = 0; i < list.size(); i++) {\n     \
    \   int tmp = list.get(i);\n        list.set(i, n - sum - tmp);\n    }\n    return\
    \ list;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=algorithm,c#,sorting\
    \ |>\nThis is my java implementation for array Sorting. I have created three different\
    \ methods for sorting.\n<code>\nimport java.util.Arrays;", "{\n    long[] result\
    \ = new long[array.length];", "{\n    // Write your code in here.\n    int sum;\n\
    \    int lastIndex = array.size() - 1;\n    int mid;\n    int firstIndex;", "{\n\
    \    long[] result = new long[array.length];\n    long[] a = new long[array.length];\n\
    \    int i = 0, j = 0, k = 0;", "{\n    long[] result = new long[array.length];\n\
    \    int n = array.length;\n    long[] arr1 = new long[array.length];\n    long\
    \ sum = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        arr1[i] = array[i];\n\
    \    }", "{\n    int n = array.length;\n    long[] result = new long[n];\n   \
    \ // sort first\n    int i, j, k;\n    for (i = 0, j = 1; i < n - 1; i++) {\n\
    \        if (array[i] > array[j]) {\n            k = array[i];\n            array[i]\
    \ = array[j];\n            array[j] = k;\n        }\n    }\n    // do sum on odd\
    \ sum\n    for (i = 0; i < n; i++) {\n        k = result[i];\n        result[i]\
    \ = result[n-1];\n        result[n-1] = k;\n    }\n    // if odd sum, sort result\
    \ array\n    int odd_sum = result[0];\n    for (i = 0; i < n; i++) {\n       \
    \ k = result[i];\n        if (odd_sum % 2 == 1)\n            k = -k;\n       \
    \ result[i] = k;\n        odd_sum += k;\n    }\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| a |>\nMy solution (Java 7):\n<code>\npublic int[] sortArray(int[]\
    \ arr) {\n    int n = arr.length;\n    int sum = 0;\n    int[] res = new int[n];",
  "{\n    long[] result = array;\n    long sum = 0;\n    for(long val : result) \n\
    \    {\n        sum += val;\n    }\n    if((sum % 2) == 1) \n    {\n        result\
    \ = new long[result.length];\n        for(long val : result) \n        {\n   \
    \         sum += val;\n            result[result.length - 1 - i] = val;\n    \
    \    }\n        for(long val : result) \n        {\n            sum += val;\n\
    \            result[result.length - 1 - i] = (long) (sum - val);\n        }\n\
    \    }\n    else\n    {\n        result = new long[result.length];\n        for(long\
    \ i = result.length - 1; i >= 0; i--) \n        {\n            sum += result[i];\n\
    \            result[i] = sum - result[i];\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a |>\n<| a |>\n<code>\npublic static int[] sort(int[] arr){\n\
    \        long total= Arrays.stream(arr).sum();\n        List<Integer> list = Arrays.stream(arr).sorted().boxed().collect(Collectors.toList());\n\
    \        if(total%2 == 0){\n            list = list.reverse();\n        }\n  \
    \      int[] result = new int[list.size()];\n        for(int i=0; i<list.size();\
    \ i++){\n            result[i] = list.get(i);\n        }\n        return result;\n\
    \    }\n</code>\n<|/ a dscore=0 tags=algorithm,sorting,java |>\n<| c |>\nPlease\
    \ explain your code\n<|/ c |>\n<| c |>\n`total = Arrays.stream(arr).sum();` gives\
    \ me `0`, even though the array contains `int`s.\n<|/ c |>\n<| c |>\n`total =\
    \ Arrays.stream(arr).sum();` gives a `long` even though the array contains `int`s.\n\
    <|/ c |>\n<| a |>\nMy solution (not so fancy but easy to understand):\n<code>\n\
    public int[] sort(int[] arr) {\n    int[] result = new int[arr.length];\n    Arrays.sort(arr);\n\
    \    int lastSum = 0, sum = 0;\n    for (int i = 1; i < arr.length; i++) {\n \
    \       sum = arr[i];\n        if (sum > 0) {\n            result[i-1] = sum;\n\
    \            lastSum = sum;\n        }\n    }\n    int lastSum = 0;\n    int i\
    \ = 0;\n    while (lastSum < sum) {\n        result[i++] = lastSum;\n        lastSum\
    \ = lastSum + arr[i];\n    }\n    return result;\n}\n</code>\n<|/ a tags=algorithm,sorting,java\
    \ dscore=0 |>\n<| c |>\nWhy do you think it's not a good solution? It's the only\
    \ one that worked ", "{\n    long[] result = array.clone();\n    long[] result_copy\
    \ = new long[result.length];\n    long sum = 0;", "{\n    if(array.Length<1) return\
    \ array;\n    long[] sorted = new long[array.Length];\n    long sum = 0;\n   \
    \ for(int i = 0; i < array.Length; i++) {\n        sum += array[i];\n        if(sum\
    \ > array.Length) return null;\n        sorted[sorted.Length-1-i] = array[i];\n\
    \    }\n    if(sum % 2 == 1) sorted = sort_array_asc(sorted);\n    else sorted\
    \ = sort_array_desc(sorted);\n    return sorted;\n}\n/*\n    Given an array of\
    \ non-negative integers, return a cod of the given array after sorting,\n    you\
    \ will sort the given array in ascending order if the sum( first index value,\
    \ last index value) is odd,\n    or sort it in descending order if the sum( first\
    \ index value, last index value) is even.", "{\n    if( array.Length <= 0 )\n\
    \        return array;\n    long sum = 0;\n    for(int i = 0; i < array.Length;\
    \ i++)\n    {\n        sum += array[i];\n    }", "{\n    int sum;\n    int sumEven;\n\
    \    int sumOdd;\n    int i;\n    long[] arr = new long[array.length];\n    long[]\
    \ sorted = new long[array.length];\n    sumEven = sumOdd = sum = 0;\n    \n  \
    \  // if sum is even, then sort in ascending order\n    if (sumEven == sum)\n\
    \    {\n        for(int i=0; i<array.length; i++)\n        {\n            sumEven+=array[i];\n\
    \            sum += array[i];\n            \n            if(sumEven%2 == 0) //\
    \ odd sum\n            {\n                sorted[i] = array[i];\n            \
    \    sumEven-=array[i];\n            }\n            else\n            {\n    \
    \            sorted[i] = array[i];\n                sumEven+=array[i];\n     \
    \       }\n        }\n    }\n    else // if sum is odd, then sort in descending\
    \ order\n    {\n        for(int i=0; i<array.length; i++)\n        {\n       \
    \     sumOdd+=array[i];\n            sum += array[i];\n            \n        \
    \    if(sumOdd%2 == 0) // odd sum\n            {\n                sorted[array.length-1-i]\
    \ = array[i];\n                sumOdd-=array[i];\n            }\n            else\n\
    \            {\n                sorted[array.length-1-i] = array[i];\n       \
    \         sumOdd+=array[i];\n            }\n        }\n    }\n    return sorted;\n\
    }\n</code>\n<|/ a |>\n<| a |>\nHere is a simple and efficient solution:\n<code>\n\
    public static int[] sortInAscOrder(int[] arr) {\n    int len = arr.length;\n \
    \   int sum = 0;\n    int temp = 0;\n    int[] res = new int[len];", "{\n  long[]\
    \ newArray = new long[array.Length];\n  long[] oldArray = array;\n  long sum,\
    \ index;\n  \n  // sort even\n  if(array.Length % 2 == 0)\n  {\n    for(int i\
    \ = 0; i < (array.Length - 1); i++)\n    {\n      index = oldArray[i] + oldArray[i\
    \ + 1];\n      if(index % 2 == 0)\n      {\n        newArray[i] = oldArray[i];\n\
    \        newArray[i + 1] = oldArray[i + 1];\n      }\n    }\n  }\n  else\n  {\n\
    \    for(int i = 0; i < (array.Length - 1); i++)\n    {\n      index = oldArray[i]\
    \ + oldArray[i + 1];\n      if(index % 2 == 1)\n      {\n        newArray[i] =\
    \ oldArray[i];\n        newArray[i + 1] = oldArray[i + 1];\n      }\n    }\n \
    \ }\n  \n  return newArray;\n}\n</code>\n<|/ a tags=sorting,arrays,c# |>\n<| c\
    \ |>\nThis code is very slow for large arrays. Can you suggest a faster one?\n\
    <|/ c |>\n<| c |>\nThe performance of this code is dependent on how efficient\
    \ your processor is - it does require a total of O(n*log(log(n))) time, where\
    \ n is the number of elements in the array. ", "{\n    int sum = 0;\n    int j;\n\
    \    for (int i = 0; i < array.length; i++) \n    {\n        sum += array[i];\n\
    \    }\n    if (sum % 2 == 0)\n    {\n        Arrays.sort(array);\n    }\n   \
    \ else\n    {\n        Arrays.sort(array, array.length - 1, array.length - 1);\n\
    \    }\n    return array;\n}", "{\n    int i, j, k, sum = 0;\n    long[] a = new\
    \ long[array.length];\n    for( i = 1; i < array.length; i++ ) {\n        a[i]\
    \ = array[i - 1];\n    }", "{\n    long[] result = new long[array.length];", "{\n\
    \  int sum = 0;\n  long[] a = array;\n  for(int i = 0; i < a.length; i++){\n \
    \   sum += a[i];\n  }\n  if(sum%2 == 0){\n    Arrays.sort(a);\n  }\n  else{\n\
    \    Arrays.sort(a, (a < b) -> {return -1; });\n  }\n  return a;\n}\n</code>\n\
    <|/ a |>\n<| a |>\n<code>\nimport std.array;", "{\n    \n    Arrays.sort(array);\n\
    \    long sum = 0;\n    for(int i = 0; i < array.length; i++)\n    {\n       \
    \ sum = sum + array[i];\n        \n        if(sum % 2 == 1)\n            Arrays.swap(array,\
    \ i, (array.length-1)-i);\n        else\n            Arrays.swap(array, i, (array.length-1)-(i+1));\n\
    \        \n    }\n    return array;\n}", "{\n    long sum = 0;\n    long result\
    \ = 0;\n    int index = 0;\n    for(int i = 0; i< array.length; i++)\n    {\n\
    \        sum += array[i];\n        if(sum < 0) \n        {\n            result\
    \ += sum;\n        }\n        else if (sum > 0)\n        {\n            result\
    \ -= sum;\n        }\n        index++;\n    }", "{\n    long sum = 0;\n    int\
    \ len = array.length;\n    for (int i=0; i<len; i++) {\n        sum += array[i];\n\
    \    }\n    if (sum % 2 != 0) {\n        std.sort(array, std.descending(function(long\
    \ a, long b){return a-b;}) );\n    } else {\n        std.sort(array, std.ascending(function(long\
    \ a, long b){return a-b;}) );\n    }\n    return array;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI guess you meant `std.sort(array, std.ascending(function(long\
    \ a, long b){return a-b;}) );` - as your current version sorts descending (which\
    \ is also wrong).\n<|/ c |>\n<| c |>\nYou are right, I was thinking about ascending,\
    \ not descending. But now I'm confused what the OP really wants because they said\
    \ in their question that they want to sort the array, not the indexes.\n<|/ c\
    \ |>\n<| a tags=c#,arrays,sorting,indexing |>\nYou can do it in one line by using\
    \ a Dictionary and adding up the numbers then sorting it by the sum\n<code>\n\
    List<int> numbers = new List<int>(){5,4,3,2,1,0};\nDictionary<int, int> SortedNumbers\
    \ = new Dictionary<int, int>();\nfor (int i = 0; i <= numbers.Count - 1; i++)\
    \ {\n    if (SortedNumbers.ContainsKey(numbers[i]))\n        SortedNumbers[numbers[i]]\
    \ += numbers[i];\n    else\n        SortedNumbers[numbers[i]] = numbers[i];\n\
    }\nSortedNumbers = SortedNumbers.OrderByDescending(a => a.Value).ToList();\n</code>\n\
    And you can then print it out like this\n<code>\nfor (int i = 0; i < SortedNumbers.Count;\
    \ i++)\n{\n    if (i % 2 == 0)\n    {\n        Console.Write(SortedNumbers[i].Key\
    \ + \" \");\n    }\n    else\n    {\n        Console.Write(SortedNumbers[i].Value\
    \ + \" \");\n    }\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe OP said they need\
    \ to sort the array, not the sorted indexes.\n<|/ c |>\n<| c |>\nThis solution\
    \ sorts the array, and the indexes, I thought they meant the indexes.\n<|/ c |>\n\
    <| a tags=c#,arrays,sorting,indexing |>\nMy solution will return the array, but\
    \ sort it in a descending order if even number sum is odd and ascending if odd\
    \ number sum is even.\n<code>\nusing System;\nusing System.Collections.Generic;",
  "{\n    int sum = 0;\n    for (int i : array)\n    {\n        sum += i;\n    }\n\
    \    if (sum % 2 == 0)\n    {\n        Arrays.sort(array);\n    }\n    else\n\
    \    {\n        Arrays.sort(array, (a, b) -> \n        {\n            long left\
    \ = a;\n            long right = b;\n            return right - left;\n      \
    \  });\n    }\n    return array;\n}\n</code>\n<|/ a dscore=0 tags=arrays,sorting,java\
    \ |>\n<| a tags=arrays,sorting,java |>\nHere is the python implementation of the\
    \ solution provided by Ashwin Odedra:\n<code>\ndef sort_array(arr):\n    n = len(arr)\n\
    \    m = n-1\n    sum = 0", "{\n    long[] result = array;", "{\n    int len =\
    \ array.Length;", "{\n    long[] result = new long[array.length];\n    int sum\
    \ = 0;\n    for (int i = 0; i < array.length; i++){\n        if (i % 2 == 1){\n\
    \            sum += array[i];\n        }\n        if (i % 2 == 0){\n         \
    \   sum -= array[i];\n        }\n        result[i] = sum;\n    }\n    return sort_array(result,\
    \ 0, array.length - 1, true);\n}\n/*", "{\n    if (array == null || array.length\
    \ == 0) \n    {\n        return array;\n    }", "{\n    int n = array.length;\n\
    \    long[] res = new long[n];\n    int sum = 0;\n    for(int i = 0; i < n; i++){\n\
    \        res[i] = array[i];\n        sum += res[i];\n    }\n    \n    if(sum %\
    \ 2 == 0){\n        Arrays.sort(res);\n    }\n    else{\n        Arrays.sort(res);\n\
    \        for(int i = 0; i < n; i++){\n            res[i] = res[i] - sum;\n   \
    \     }\n    }\n    return res;\n}", "{\n    long[] ans;\n    int sum = 0;\n \
    \   for (int i = 0; i < array.length; i++) \n    {\n        sum += array[i];\n\
    \    }\n    sum = (sum % 2 == 1) ? sum - 1 : sum + 2;", "{\n    long[] result\
    \ = array;\n    long sum = 0;\n    int len = array.length;\n    long[] tmp;\n\
    \    \n    for (int i = 0; i < len; i++)\n    {\n        sum += array[i];\n  \
    \  }\n    \n    if (sum % 2 == 1)\n    {\n        Arrays.sort(result);\n    }\n\
    \    else\n    {\n        Arrays.sort(result, (a, b) -> b.compareTo(a));\n   \
    \ }\n    \n    return result;\n}\n</code>\n<|/ a tags=arrays,algorithm,sorting,java\
    \ |>\n<| c |>\nThank you for your answer. This would be an accepted answer if\
    \ it had some explanation.\n<|/ c |>\n<| a |>\n<code>\npublic static void main(String[]\
    \ args) {\n    int A[] = {3,5,1,2};\n    int n = A.length;\n    for(int i=0;i<n-1;i++){\n\
    \        for(int j=i+1;j<n;j++){\n            if(A[i]+A[j]>n-1)\n            \
    \    break;\n            if(A[i]+A[j]==n-1){\n                swap(A[i],A[j]);\n\
    \                j--;\n            }\n        }\n    }\n    System.out.println(A);\n\
    }\nstatic void swap(int x, int y){\n    int temp = x;\n    x = y;\n    y = temp;\n\
    }\n</code>\n<|/ a tags=arrays,algorithm,sorting,java dscore=1 |>\n<| c |>\nWhile\
    \ this code may answer the question, providing additional context regarding how\
    \ and/or why it solves the problem would improve the answer's long-term value.\n\
    <|/ c |>\n<| a tags=arrays,algorithm,sorting,java |>\n<code>\nimport java.util.Arrays;\n\
    import java.util.Comparator;", "{\n    long sum = 0, sum1 = 0, mid = 0, index\
    \ = 0;\n    while (index < array.Length) \n    {\n        sum += array[index];\n\
    \        index++;\n    }", "{\n\tint i = 0;\n\tint j = 0;\n\tint sum = 0;\n\t\n\
    \tlong sum2 = array[0];\n\t\n\tfor(int j = 1; j < array.length; j++)\n\t{\n\t\t\
    sum = sum + array[j];\n\t\t\n\t\tif(sum%2 == 0)\n\t\t{\n\t\t\tsum2 = sum2;\n\t\
    \t\t\n\t\t\tint index = i;\n\t\t\t\n\t\t\twhile(index < j)\n\t\t\t{\n\t\t\t\t\
    array[index] = array[index - 1];\n\t\t\t\t\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\t\n\
    \t\t\tarray[index] = sum2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum2 = sum2;\n\t\t\t\
    \n\t\t\tint index = j;\n\t\t\t\n\t\t\twhile(index > i)\n\t\t\t{\n\t\t\t\tarray[index]\
    \ = array[index + 1];\n\t\t\t\t\n\t\t\t\tindex--;\n\t\t\t}\n\t\t\t\n\t\t\tarray[index]\
    \ = sum2;\n\t\t}\n\t}\n\t\n\treturn array;\n}", "{\n    if(array.length < 1) return\
    \ array;", "{\n    int i = 0, j = 0, n = array.Length;\n    long[] res = new long[n];\n\
    \    long[] aux = new long[2];\n    aux = array;\n    while (i < n)\n    {\n \
    \       while (j >= 0 && aux[j] >= aux[i])\n        {\n            res[i++] =\
    \ aux[j++];\n        }\n        while (j < n && aux[j] <= aux[i])\n        {\n\
    \            res[i++] = aux[j++];\n        }\n    }\n    return res;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nthanks, I will try it\n<|/ c |>\n<| c |>\n`if (j >= 0 && (aux[j]\
    \ >= aux[i] || aux[j] == aux[i]))` is unnecessary - since you already tested `j\
    \ >= 0` earlier, it is guaranteed that `aux[j] >= aux[i]` will always be true\
    \ for the same `j`\n<|/ c |>\n<| c |>\nI tested it and you're right, the extra\
    \ test is not necessary, I was actually trying to figure out what was happening\
    \ there but it seems it works either way\n<|/ c |>\n<| a |>\n<code>\n    public\
    \ class Sorting\n{\n    public static void main(String[] args)\n    {\n      \
    \  // TODO Auto-generated method stub\n        long[] arr = new long[]{2L, 5L,\
    \ 4L, 3L, 6L, 1L, 0L};\n        long[] sortedArr = sort_array(arr);\n        for(long\
    \ e : sortedArr)\n        {\n            System.out.println(e);\n        }\n \
    \   }", "{\n    long sum;\n    sum = 0;\n    for(int i = 0; i < array.length;\
    \ i++)\n        sum += array[i];\n    long min = array[0];\n    long max = array[0];\n\
    \    for(int i = 0; i < array.length; i++)\n    {\n        sum += array[i];\n\
    \        if(sum % 2 == 1)\n        {\n            if(min > array[i])\n       \
    \     {\n                min = array[i];\n            }\n            else if(max\
    \ < array[i])\n            {\n                max = array[i];\n            }\n\
    \        }\n        else\n        {\n            if(min > array[i])\n        \
    \    {\n                min = array[i];\n            }\n            if(max < array[i])\n\
    \            {\n                max = array[i];\n            }\n        }\n  \
    \  }\n    long[] resultArr = new long[array.length];\n    int startIndex = 0;\n\
    \    int endIndex = 0;\n    if(sum % 2 == 1)\n    {\n        endIndex = array.length\
    \ - 1;\n    }\n    else\n    {\n        startIndex = 1;\n        endIndex = array.length\
    \ - 1;\n    }\n    int counter = 0;\n    for(int i = startIndex; i <= endIndex;\
    \ i++)\n    {\n        resultArr[counter] = array[i];\n        counter++;\n  \
    \  }\n    sort(resultArr);\n    return resultArr;\n}", "{\n\tlong result = 1L;\n\
    \tlong[] array2 = array;\n\tlong[] array3;\n\tlong sumFirst = array2[0];\n\tlong\
    \ sumLast = array2[array2.length-1];\n\tlong sumLast1 = sumLast - 1L;\n\tlong\
    \ sumFirst1 = sumFirst - 1L;\n\tlong sumFirst3 = sumFirst1 - 3L;\n\tlong sumLast3\
    \ = sumLast1 + 3L;\n\t\n\tif(sumFirst%2 == 0L){\n\t\tarray3 = new long[array2.length];\n\
    \t\t\n\t\tfor(int i = 0; i < array2.length; i++){\n\t\t\tarray3[i] = array2[i];\n\
    \t\t\t\n\t\t\tif(sumFirst == array3[i]+sumLast1){\n\t\t\t\tarray3[i] = sumFirst3;\n\
    \t\t\t}else if(sumFirst == array3[i]+sumLast3){\n\t\t\t\tarray3[i] = sumLast3;\n\
    \t\t\t}\n\t\t\t\n\t\t\tsumFirst = array3[i] + 1;\n\t\t\tsumLast = array3[i] +\
    \ 2;\n\t\t\t\n\t\t\tsumFirst1 = sumFirst - 1L;\n\t\t\tsumLast1 = sumLast + 1L;\n\
    \t\t\tsumFirst3 = sumFirst1 - 3L;\n\t\t\tsumLast3 = sumLast1 + 3L;\n\t\t\t\n\t\
    \t}\n\t\t\n\t\tfor(int i = 0; i < array2.length; i++){\n\t\t\tarray2[i] = array3[i];\n\
    \t\t}\n\t\t\n\t}else{\n\t\tarray3 = new long[array2.length];\n\t\t\n\t\tfor(int\
    \ i = 0; i < array2.length; i++){\n\t\t\tarray3[i] = array2[i];\n\t\t\t\n\t\t\t\
    if(sumLast == array3[i]+sumFirst1){\n\t\t\t\tarray3[i] = sumLast3;\n\t\t\t}else\
    \ if(sumLast == array3[i]+sumFirst3){\n\t\t\t\tarray3[i] = sumFirst3;\n\t\t\t\
    }\n\t\t\t\n\t\t\tsumLast = array3[i] + 2;\n\t\t\tsumFirst = array3[i] + 1;\n\t\
    \t\t\n\t\t\tsumFirst1 = sumFirst + 1L;\n\t\t\tsumLast1 = sumLast - 1L;\n\t\t\t\
    sumFirst3 = sumFirst1 + 3L;\n\t\t\tsumLast3 = sumLast1 - 3L;\n\t\t\t\n\t\t}\n\t\
    \t\n\t\tfor(int i = 0; i < array2.length; i++){\n\t\t\tarray2[i] = array3[i];\n\
    \t\t}\n\t\t\n\t}\n\t\n\treturn array2;\n}", "{\n    int i;\n    int sum = 0;\n\
    \    \n    for (i = 0; i < array.length; i++) \n    {\n        sum += array[i];\
    \ \n    }\n    \n    long[] code = new long[array.length]; \n    \n    if (sum\
    \ % 2 == 1) \n    {\n        //descending\n        for (int j = 0; j < array.length;\
    \ j++) \n        {\n            code[j] = array[j];\n        }\n        Arrays.sort(code);\n\
    \        for (int j = 0; j < array.length; j++) \n        {\n            array[j]\
    \ = code[j]; \n        }\n    }\n    else \n    {\n        //ascending\n     \
    \   for (int j = 0; j < array.length; j++) \n        {\n            code[j] =\
    \ array[j];\n        }\n        Arrays.sort(code, (a, b) -> a - b);\n        for\
    \ (int j = 0; j < array.length; j++) \n        {\n            array[j] = code[j];\
    \ \n        }\n    }\n    return array; \n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ dscore=0 |>\n<code>\n/**\n * Sort a integer array in ascending or descending\
    \ order\n *\n * arr   Array of integers.\n * asc   true for Ascending, false for\
    \ descending\n * Array of integers sorted ascending or descending\n */\npublic\
    \ static int[] sort(int[] arr, int asc) {\n    int n = arr.length;\n    int[]\
    \ ret = new int[n];\n    int i, j;\n    boolean swap = true;\n    while (swap)\
    \ {\n        swap = false;\n        for (i = 0; i < n - 1; i++) {\n          \
    \  for (j = i; j < (n - 1); j++) {\n                if (arr[i] < arr[j]) {\n \
    \                   swap(arr, i, j);\n                    break;\n           \
    \     }\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n\
    \        ret[i] = arr[i];\n    }\n    return ret;\n}", "{\n    if (array.length\
    \ <= 1)\n        return array;\n    int len = array.length;\n    long[] ans =\
    \ new long[len];\n    long sum = 0;\n    long minv = array[0];\n    long maxv\
    \ = array[0];\n    long temp = 0;\n    int i;\n    for (i = 0; i < len; i++)\n\
    \    {\n        sum += array[i];\n        if (sum % 2 == 0)\n            ans[i]\
    \ = array[i];\n        else\n        {\n            if (sum % 2 != 0)\n      \
    \          ans[i] = -array[i];\n            else\n                ans[i] = array[i];\n\
    \        }\n        if (sum < minv)\n        {\n            minv = sum;\n    \
    \        temp = array[i];\n        }\n        if (sum > maxv)\n        {\n   \
    \         maxv = sum;\n            temp = array[i];\n        }\n    }\n    if\
    \ (sum % 2 == 0)\n        ans[i] = temp;\n    else\n        ans[i] = -temp;\n\
    \    if (minv > maxv)\n        std.sort(ans);\n    else\n        std.sort(ans,\
    \ 0, len-1);\n    return ans;\n}", "{\n    long[] result = array;", "{\n    long\
    \ sum = 0;\n    for(int i = 0; i< array.length; i++){\n        sum += array[i];\
    \ \n    }", "{\n    var ans=new long[array.length];\n    var sum=0;\n    for(int\
    \ i=0;i<array.length;i++){\n        sum+=array[i]*array[i];\n        ans[i]=array[i];\n\
    \    }\n    \n    if(sum%2==1){\n        for(int i=0;i<array.length;i++){\n  \
    \          for(int j=i+1;j<array.length;j++){\n                if(ans[i]<ans[j]){\n\
    \                    swap(ans,i,j);\n                }\n            }\n      \
    \  }\n    }else{\n        for(int i=0;i<array.length;i++){\n            for(int\
    \ j=i+1;j<array.length;j++){\n                if(ans[i]>ans[j]){\n           \
    \         swap(ans,i,j);\n                }\n            }\n        }\n    }\n\
    \    return ans;\n}\n/*", "{\n    int n = array.length;\n    long[] temp = new\
    \ long[n];\n    Arrays.sort(array);\n    long sum = 0;\n    for (int i = 0; i\
    \ < n; i++) \n    {\n        sum += array[i];\n        if (sum % 2 == 1) \n  \
    \      {\n            temp[n - 1 - i] = array[i];\n        }\n        else \n\
    \        {\n            temp[n - 1 - i] = array[n-i-1];\n        }\n    }\n  \
    \  return temp;\n}", "{\n    if (array == null || array.length <= 1) \n    {\n\
    \        return array;\n    }\n    long[] sorted = new long[array.length];\n \
    \   int mid = 0;\n    long sum = 0;\n    for (int i = 0; i < array.length; i++)\n\
    \    {\n        sum += array[i];\n        sorted[i] = sum;\n    }\n    Arrays.sort(sorted);\n\
    \    int count = 0;\n    int odd = 1;\n    int even = 0;\n    long curr = sum;\n\
    \    for (int i = 0; i < sorted.length; i++)\n    {\n        if (array[i] < curr)\n\
    \        {\n            curr -= array[count];\n            odd = odd + array[i];\n\
    \            count++;\n        }\n        else\n        {\n            curr +=\
    \ array[count];\n            even = even + array[i];\n            count++;\n \
    \       }\n    }\n    if (odd > even)\n    {\n        Arrays.sort(sorted, 0, sorted.length\
    \ - 1);\n    }\n    return sorted;\n}\n</code>\n<|/ a |>\n<| c |>\nI used this\
    \ and it works fine for most cases, except it won't work for an array like this\
    \ [2, 3, 1, 4, 0, 5] because it will get sorted into the wrong order [1,0,2,3,4,5]\
    \ or [2,3,1,4,0,5] or [1,2,3,4,0,5] or [1,3,2,4,0,5] etc. Thanks for the solution\
    \ though, I'm sure it will come in handy for other coders.\n<|/ c |>\n<| c |>\n\
    , if you see the example above and run this code, it will give the correct sorted\
    \ array. I believe you didn\u2019t run this code. Try this code and let me know\
    \ if you\u2019re seeing a different result.\n<|/ c |>\n<| c |>\nYou didn\u2019\
    t even run my code. That\u2019s why I posted it as an answer. Anyways thanks for\
    \ your help.\n<|/ c |>\n<| c |>\n, I ran the code before posting it, and it gave\
    \ the correct sorted array. Are you seeing a different result?\n<|/ c |>\n<| c\
    \ |>\nI ran your code, and it gave me the wrong result with your input array.\
    \ Your code sorted the array like this: [0, 2, 3, 4, 1, 5]. It should have been\
    \ [0, 1, 2, 3, 4, 5]. I don't know why you got it like that. I only got it like\
    \ that when I ran your code. Sorry, but your solution is the only way I found\
    \ to do it.\n<|/ c |>\n<| a dscore=3 |>\n<code>", "{\n    int N = array.length;\n\
    \    long sum = 0;\n    for (int i=0; i<N; i++) {\n        sum += array[i];\n\
    \    }\n    long[] result = new long[N];\n    for (int i=0; i<N; i++) {\n    \
    \    if (sum%2 == 1) {\n            int index = 2*i-1;\n            long temp\
    \ = result[index];\n            result[index] = result[i];\n            result[i]\
    \ = temp;\n        }\n    }\n    return result;\n}", "{\n    int n = array.length;\n\
    \    long[] ret = new long[n];", "{\n    if(array == null || array.length == 0)\n\
    \        throw new IllegalArgumentException(\"array is null\");\n        \n  \
    \  long[] result = new long[array.length];\n    int count = 0;\n    int oddSum\
    \ = 0;\n    int evenSum = 0;\n    long sum = 0;\n    long temp;\n    long sumEven\
    \ = 0;\n    long sumOdd = 0;\n    int i = 0;\n    int j = 0;\n    for(; i < array.length;\
    \ i++) \n    {\n        temp = array[i];\n        if(temp > 0)\n        {\n  \
    \          count++;\n            sum += temp;\n        }\n        else \n    \
    \    {\n            if(oddSum > evenSum) \n            {\n                for(;\
    \ j < i; j++) \n                {\n                    if(array[j] > 0)\n    \
    \                {\n                        count++;\n                       \
    \ sum += array[j];\n                        array[j] = temp;\n               \
    \     }\n                }\n            }\n            else \n            {\n\
    \                for(; j < i; j++) \n                {\n                    if(array[j]\
    \ > 0)\n                    {\n                        count++;\n            \
    \            sum -= array[j];\n                        array[j] = temp;\n    \
    \                }\n                }\n            }\n            \n         \
    \   oddSum -= temp;\n            evenSum += temp;\n        }\n    }\n    \n  \
    \  if(oddSum > evenSum) \n    {\n        for(; i < array.length; i++) \n     \
    \   {\n            sum += array[i];\n        }\n    }\n    else \n    {\n    \
    \    for(; i < array.length; i++) \n        {\n            sum -= array[i];\n\
    \        }\n    }\n    \n    for(int k = i; k < (array.length); k++) \n    {\n\
    \        if(array[k] > 0)\n        {\n            result[k] = array[k];\n    \
    \    }\n        else \n        {\n            result[k] = -array[k];\n       \
    \ }\n    }\n    \n    for(; i < array.length; i++) \n    {\n        if(array[i]\
    \ > 0)\n        {\n            result[i] = array[i];\n        }\n        else\
    \ \n        {\n            result[i] = -array[i];\n        }\n    }\n    \n  \
    \  return result;\n}\n</code>\n<|/ a |>\n<| c |>\nI dont know why this answer\
    \ got down voted, its simple and clear.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n\
    public static int[] sortDescendingOrder(int[] arr)\n{\n    if(arr == null || arr.length\
    \ == 0)\n        return null;", "{\n    if( array.Length == 0 )\n        return\
    \ array;\n    \n    long sum = 0;\n    long temp;\n    \n    // sort array in\
    \ ascending order if the sum is odd\n    for( int i=0; i<array.Length; i++ )\n\
    \    {\n        temp = array[i];\n        sum += temp;\n        if( sum%2 == 1\
    \ )\n            std.swap( array, i, array.Length-1 );\n    }\n    \n    // sort\
    \ array in descending order if the sum is even\n    sum = 0;\n    for( int i=0;\
    \ i<array.Length; i++ )\n    {\n        temp = array[i];\n        sum += temp;\n\
    \        if( sum%2 == 0 )\n            std.swap( array, i, array.Length-1 );\n\
    \    }\n    \n    return array;\n}\n</code>\n<|/ a tags=c#,arrays dscore=1 |>\n\
    <| a dscore=0 tags=c#,arrays |>\nThis code works great. Just tested with small\
    \ arrays and it worked great. Just in case somebody needs it in future, here is\
    \ the code:\n<code>\n    public static int[] SortArray(int[] array)\n    {\n \
    \       var len = array.Length;\n        int[] newArray = new int[len];\n    \
    \    var sum = 0;\n        var odd = true;\n        for (var i = 0; i < len; i++)\n\
    \        {\n            sum += array[i];\n            if (sum % 2 == 1)\n    \
    \        {\n                newArray[len - i - 1] += array[i];\n             \
    \   odd = false;\n            }\n            else\n            {\n           \
    \     newArray[len - i - 1] += array[i];\n                odd = true;\n      \
    \      }\n        }\n        if (odd)\n            newArray[0] = newArray[len\
    \ - 1];", "{\n    long[] result = array.clone();\n    int sum = std.reduce(array);\n\
    \    if (sum%2 == 1)\n        std.sort(result, 0, array.length - 1);\n    else\n\
    \        std.sort(result, 0, array.length - 1, std.desc);\n    return result;\n\
    }", "{\n    long sum = 0;\n    for (int i = 0; i < array.length; i++) \n    {\n\
    \        sum = sum + array[i];\n    }\n    long[] sort_array = new long[array.length];\n\
    \    int flag = sum % 2 == 0 ? -1 : 1;\n    if (flag == -1)\n    {\n        for\
    \ (int i = 0; i < array.length; i++) \n        {\n            sort_array[i] =\
    \ array[i];\n        }\n        Arrays.sort(sort_array);\n        for (int i =\
    \ 0; i < array.length; i++) \n        {\n            array[i] = sort_array[i];\n\
    \        }\n    }\n    else\n    {\n        Arrays.sort(array);\n        for (int\
    \ i = 0; i < array.length; i++) \n        {\n            sort_array[i] = array[i];\n\
    \        }\n        Arrays.sort(sort_array);\n        for (int i = 0; i < array.length;\
    \ i++) \n        {\n            array[i] = sort_array[i];\n        }\n    }\n\
    \    return array;\n}\n</code>\n<|/ a dscore=1 tags=sorting,arrays,algorithm,java\
    \ |>\n<| a |>\nI ran into this problem when I was trying to solve this problem:\n\
    https://www.hackerrank.com/challenges/sorting-array/problem\nThe solution I found\
    \ was very elegant, but I was still getting some errors when I submitted my code.\
    \ The problem was that the input array needed to be of type Integer and not long.\
    \ \nI got it to work with the following code:\n<code>\npublic static void main(String[]\
    \ args) {\n    Scanner scanner = new Scanner(System.in);\n    long n = scanner.nextLong();\n\
    \    int count = 0;\n    Integer arr[] = new Integer[n];\n    for (int i = 0;\
    \ i < n; i++) {\n        arr[i] = scanner.nextInt();\n    }\n    arr = sort(arr);\n\
    \    for (int i = 0; i < n; i++) {\n        System.out.print(arr[i] + \" \");\n\
    \    }\n    System.out.println();\n}", "{\n    if ( array == null ) return array;",
  "{\n    // write your code here\n    int length = array.length;\n    int sum = 0;\n\
    \    for (int i = 0; i < length; i++){\n        sum += array[i];\n    }\n    if\
    \ (sum % 2 == 1){\n        std.sort(array, 0, length-1);\n    }else{\n       \
    \ std.sort(array, 1, length-1);\n    }\n    return array;\n}\n</code>\n<|/ a |>\n\
    <| a tags=sorting,arrays,algorithm |>\nThis would be O(n) time.\nYou go through\
    \ the array, keep two indexes - one for checking if sum value is odd or even and\
    \ another for keeping two indexes to check min and max value. \n<code>"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
