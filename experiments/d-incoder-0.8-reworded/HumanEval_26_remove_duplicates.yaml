name: HumanEval_26_remove_duplicates
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n From an array of integers, remove\
  \ all elements that occur more than once.\n    Keep order of elements left the same\
  \ as in the input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n    [1L, 3L,\
  \ 4L]\n    \n*/\nlong[] remove_duplicates(long[] numbers) \n"
tests: "unittest\n{\n    alias candidate = remove_duplicates;\n\n    assert(candidate([])\
  \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([1L,\
  \ 2L, 3L, 2L, 4L, 3L, 5L]) == [1L, 4L, 5L]);\n}\nvoid main(){}"
completions: ["{\n    long hash = 0;\n    long[] result = new long[numbers.length];\n\
    \    int current = 0;", "{\n    long[] result = new long[numbers.length];", "{\n\
    \    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        int index = 0;\n        while (index < numbers.length)\n\
    \        {\n            if (numbers[index] == numbers[i])\n            {\n   \
    \             index++;\n                continue;\n            }\n           \
    \ result[i] = numbers[i];\n            index++;\n        }\n    }\n    return\
    \ result;\n}\n/*\n From an array of integers, remove all elements that occur more\
    \ than once.\n    Keep order of elements left the same as in the input.\n    >>>\
    \ remove_duplicates([1L, 2L, 3L, 2L, 4L, 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n\
    \    \n*/", "{\n  long[] result = new long[numbers.length];\n  int i = 0, j;\n\
    \  for( ; i < numbers.length; i++) \n  {\n    for(j = i+1; j < numbers.length;\
    \ j++)\n    {\n      if(numbers[j] == numbers[i])\n      {\n        numbers[j]\
    \ = -1L;\n        numbers[i] = numbers[j];\n      }\n    }\n  }\n  return numbers;\n\
    }\n</code>\n<|/ a tags=arrays,functional-programming,java dscore=2 |>\n<| a dscore=1\
    \ |>\n<code>\nimport java.util.Arrays;", "{\n    return toList(numbers).filter(x\
    \ => !contains(numbers, x)).to_array();\n}\n/**\n From an array of ints, remove\
    \ all elements that occur more than once.\n    Keep order of elements left the\
    \ same as in the input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n   \
    \ [1L, 3L, 4L]\n    \n*/", "{\n\tint count = 0;\n\tlong[] answer = new long[numbers.length];\n\
    \tfor(int i = 0; i < numbers.length; i++)\n\t{\n\t\tif (count == 0)\n\t\t\tanswer[i]\
    \ = numbers[i];\n\t\telse if (numbers[i] == answer[count-1])\n\t\t\tcount++;\n\
    \t\telse\n\t\t\tanswer[i] = answer[count-1];\n\t}\n\treturn answer;\n}\n// End\
    \ of duplicates.\n*/\n/*\n From an array of strings, remove all elements that\
    \ occur more than once.\n    Keep order of elements left the same as in the input.\n\
    \    >>> remove_duplicates([\"a\", \"b\", \"c\", \"c\", \"a\", \"b\"])\n    [\"\
    a\", \"b\", \"c\"]\n    \n*/\nstring[] remove_duplicates(string[] words) \n{\n\
    \tint count = 0;\n\tstring[] answer = new string[words.length];\n\tfor(int i =\
    \ 0; i < words.length; i++)\n\t{\n\t\tif (count == 0)\n\t\t\tanswer[i] = words[i];\n\
    \t\telse if (words[i] == answer[count-1])\n\t\t\tcount++;\n\t\telse\n\t\t\tanswer[i]\
    \ = answer[count-1];\n\t}\n\treturn answer;\n}\n// End of duplicates.\n*/\n/*\n\
    \ From an array of doubles, remove all elements that occur more than once.\n \
    \   Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1.1,\
    \ 2.2, 3.3, 2.2, 4.4])\n    [1.1, 3.3, 4.4]\n    \n*/\ndouble[] remove_duplicates(double[]\
    \ numbers) \n{\n\tint count = 0;\n\tdouble[] answer = new double[numbers.length];\n\
    \tfor(int i = 0; i < numbers.length; i++)\n\t{\n\t\tif (count == 0)\n\t\t\tanswer[i]\
    \ = numbers[i];\n\t\telse if (numbers[i] == answer[count-1])\n\t\t\tcount++;\n\
    \t\telse\n\t\t\tanswer[i] = answer[count-1];\n\t}\n\treturn answer;\n}\n// End\
    \ of duplicates.\n*/\n/*\n From an array of doubles, remove all elements that\
    \ occur more than once.\n    Keep order of elements left the same as in the input.\n\
    \    >>> remove_duplicates([1.1, 2.2, 3.3, 2.2, 4.4])\n    [1.1, 3.3, 4.4]\n \
    \   \n*/", "{\n  int n = 0;\n  for(long number : numbers) \n  {\n    if(numbers[n++]\
    \ == number)\n      continue;\n    numbers[n++] = number;\n  }\n  return numbers;\n\
    }\n/*\n From an array of integers, remove all elements that occur more than once.\n\
    \    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/", "{\n    int length = numbers.length;\n\
    \    long[] noDupes = new long[length];\n    int count = 0;", "{\n    long ret\
    \ = 0;\n    foreach(i, numbers) {\n        ret |= i;\n    }\n    long retAll =\
    \ 0;\n    foreach(i, numbers) {\n        retAll |= i;\n    }\n    \n    if(ret\
    \ != retAll) {\n        throw new RuntimeException(\"remove_duplicates: Input\
    \ array elements not sorted\");\n    }", "{\n    int[] indexes = create_sorted_array(numbers);\n\
    \    int size = indexes.size();\n    long[] result = new long[size - 1];\n   \
    \ int j = 0;\n    for (int i = 0; i < size; i++)\n    {\n        long current\
    \ = numbers[i];\n        long next = numbers[j];\n        if (current == next)\n\
    \        {\n            result[j++] = current;\n        }\n        else if (indexes.get_element_at(i)\
    \ < j) \n        {\n            result[j++] = current;\n        }\n    }\n   \
    \ return result;\n}", "{\n\tlong[] newnumbers = new long[numbers.length];\n\t\
    for (int i = 0; i < numbers.length; i++) \n\t{\n\t\tint j = i;\n\t\tfor (int k\
    \ = i; k < numbers.length; k++) \n\t\t{\n\t\t\tif (numbers[j] == numbers[k]) \n\
    \t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tif (j - i > 1) \n\t\t\tnewnumbers[i] =\
    \ (long)((double)numbers[i] - (double)numbers[j]);\n\t}\n\treturn newnumbers;\n\
    }\n</code>\n<|/ a tags=list,sorting,c#,duplicates |>\n<| a |>\nI did some tests\
    \ using both sorts and then I realized that if you sort the array and then sort\
    \ it again it will do the same thing as sorting it once with the algorithm above.\
    \ So now I realized that you can get the same result without using any sorting.\
    \ \nHere's my code:\n<code>\nusing System;\nusing System.Collections.Generic;",
  "{\n    long uniques = 0;\n    long[] uniques_arr = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        boolean found = false;\n\
    \        for (int j = 0; j < uniques_arr.length; j++) {\n            if (numbers[i]\
    \ == uniques_arr[j]) {\n                found = true;\n                break;\n\
    \            }\n        }\n        if (!found) {\n            uniques_arr[uniques++]\
    \ = numbers[i];\n        }\n    }\n    long[] result = new long[uniques];\n  \
    \  for (int i = 0; i < uniques; i++) {\n        result[i] = uniques_arr[i];\n\
    \    }\n    return result;\n}", "{\n    int i = 0;\n    long[] answer = new long[numbers.length];\n\
    \    for(int k = 0; k < numbers.length; k++)\n    {\n        for(int j = 0; (j\
    \ < answer.length) && (numbers[k] == answer[j]); j++)\n        {\n        }\n\
    \        if(j < answer.length)\n        {\n            answer[j] = numbers[k];\n\
    \        }\n        \n    }\n    return answer;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nI'm surprised you wrote this in C++, since it is clearly using unsafe\
    \ constructs. I highly doubt that this will compile as C++ - at least not in MSVC.\n\
    <|/ c |>\n<| c |>\nI used this code to solve my problem, but my code is too long,\
    \ so I decided to write a short program to test it first.\n<|/ c |>\n<| c |>\n\
    If you're going to do that, then you're better off by rewriting it in standard\
    \ C (or any other language that supports proper containers, like Python, Lua,\
    \ Ruby, Erlang, etc...)\n<|/ c |>\n<| c |>\nNo, I wrote it in C++, since I wrote\
    \ it in C++ and I know this language well. Maybe I will rewrite it in Python,\
    \ Lua, Ruby, etc., but my program is just too long to post it here.\n<|/ c |>\n\
    <| c |>\n: It's certainly valid C++, albeit very uncommon and poor C++. Although\
    \ it looks like some kind of competition, it's definitely not a competitive C++\
    \ code. Your use of C-style casts makes me wonder what made you think this was\
    \ C++.\n<|/ c |>\n<| a |>\nThis is my code in Java, I hope this helps you.\n<code>\n\
    import java.io.*;\nimport java.util.*;\nimport static java.lang.Integer.parseInt;",
  "{\n    int i, j, k, m;\n    long[] result = new long[numbers.length];\n    for\
    \ (i=0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n    }\n \
    \   for (j=1; j < numbers.length; j++) {\n        if (numbers[j-1] == numbers[j])\
    \ {\n            continue;\n        }\n        for (k=0; k < j; k++) {\n     \
    \       if (numbers[k] == numbers[j]) {\n                numbers[k] = numbers[j];\n\
    \            }\n        }\n    }\n    for (m=0; m < result.length; m++) {\n  \
    \      if (result[m] == numbers[m]) {\n            for (k=m; k < numbers.length;\
    \ k++) {\n                if (result[m] != numbers[k]) {\n                   \
    \ numbers[k] = numbers[m];\n                    m = k;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\n/*\n\
    \    Get all possible unique combinations of n elements out of m elements.\n \
    \   \n    Example :\n    >>> all_possible_combinations([1, 2, 3, 4, 5], 3)\n \
    \   [[1, 2], [3, 4], [5]]\n    \n    Example :\n    >>> all_possible_combinations([1,\
    \ 2, 3, 4, 5], 4)\n    [[1, 2, 3], [4], [5]]\n    \n    Example :\n    >>> all_possible_combinations([1,\
    \ 2, 3, 4, 5], 5)\n    [[1, 2, 3, 4, 5]]\n    \n    Example :\n    >>> all_possible_combinations([1,\
    \ 2, 3, 4], 4)\n    [[1, 2], [3, 4]]\n    \n    Example :\n    >>> all_possible_combinations([1,\
    \ 2, 3, 4], 3)\n    [[1, 2, 3, 4]]\n    \n    Example :\n    >>> all_possible_combinations([1,\
    \ 2, 3, 4], 2)\n    [[1, 2], [3], [4]]\n    \n*/\nlong[] all_possible_combinations(long[]\
    \ numbers, int n) \n{\n    if (n == 1) {\n        return new long[] { numbers\
    \ };\n    }\n    long[] result = new long[n];\n    int[] indexes = new int[n];\n\
    \    indexes[0] = 0;\n    for (int i=1; i < n; i++) {\n        int j = 0;\n  \
    \      while (j < i) {\n            indexes[i] = j;\n            result[i] = numbers[indexes[i]];\
    \ \n            j++;\n        }\n    }\n    return result;\n}\n/*\n    Get all\
    \ possible unique combinations of m elements out of n elements.\n    \n    Example\
    \ :\n    >>> all_possible_combinations([1, 2, 3, 4, 5], 3)\n    [[1, 2], [3, 4],\
    \ [5]]\n    \n    Example :\n    >>> all_possible_combinations([1, 2, 3, 4, 5],\
    \ 4)\n    [[1, 2, 3], [4], [5]]\n    \n    Example :\n    >>> all_possible_combinations([1,\
    \ 2, 3, 4, 5], 5)\n    [[1, 2, 3, 4, 5]]\n    \n    Example :\n    >>> all_possible_combinations([1,\
    \ 2, 3, 4], 4)\n    ", "{\n\tlong[] newnumbers = new long[numbers.length];\n\t\
    int i = 0, j = 0;\n\tint jmax = numbers.length-1;\n\twhile (j < jmax) {\n\t\t\
    if (numbers[j] == numbers[j+1]) j++;\n\t\telse newnumbers[j] = numbers[j];\n\t\
    \tj++;\n\t}\n\treturn newnumbers;\n}", "{\n    long[] dupes;\n    int i = 0;\n\
    \    int j = 0;\n    dupes = new long[numbers.length];", "{\n    long hashSet[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++) \n        hashSet[i] = numbers[i];\n\
    \    long[] output = new long[numbers.length];\n    int pos = 0;\n    for (int\
    \ i = 0; i < numbers.length; i++) \n    {\n        if (hashSet[i] != numbers[i])\
    \ \n        {\n            output[pos] = numbers[i];\n            hashSet[i] =\
    \ numbers[i];\n            pos++;\n        }\n    }\n    return output;\n}\n</code>\n\
    <|/ a dscore=1 tags=java |>\n<| c |>\nWhat about `remove_duplicates(new long[]{2L,\
    \ 1L, 1L, 1L})`? What about the list containing only duplicate elements? Or any\
    \ list containing duplicates of duplicates? Think about all possible edge cases.\
    \ And please read [How do I write a good answer](https://stackoverflow.com/help/how-to-answer)\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\npublic class RemoveDuplicates {", "{\n   \
    \ int index = 0;\n    long[] nums_out = std.array.create(numbers.length, 0);\n\
    \    for(int i = 0; i < numbers.length; ++i)\n    {\n        if (nums_out[index]\
    \ != numbers[i])\n        {\n            nums_out[index++] = numbers[i];\n   \
    \     }\n    }\n    return nums_out;\n}\n/*\n From an array of integers, remove\
    \ all elements that occur more than once.\n    Keep order of elements left the\
    \ same as in the input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n   \
    \ [1L, 3L, 4L]\n    \n*/\ndouble[] remove_duplicates(double[] numbers) \n{\n \
    \   int index = 0;\n    double[] nums_out = std.array.create(numbers.length, 0);\n\
    \    for(int i = 0; i < numbers.length; ++i)\n    {\n        if (nums_out[index]\
    \ != numbers[i])\n        {\n            nums_out[index++] = numbers[i];\n   \
    \     }\n    }\n    return nums_out;\n}\n/*\n From an array of integers, remove\
    \ all elements that occur more than once.\n    Keep order of elements left the\
    \ same as in the input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n   \
    \ [1L, 3L, 4L]\n    \n*/\nfloat[] remove_duplicates(float[] numbers) \n{\n   \
    \ int index = 0;\n    float[] nums_out = std.array.create(numbers.length, 0);\n\
    \    for(int i = 0; i < numbers.length; ++i)\n    {\n        if (nums_out[index]\
    \ != numbers[i])\n        {\n            nums_out[index++] = numbers[i];\n   \
    \     }\n    }\n    return nums_out;\n}\n/*\n From an array of strings, remove\
    \ all elements that occur more than once.\n    Keep order of elements left the\
    \ same as in the input.\n    >>> remove_duplicates([\"a\", \"b\", \"b\", \"c\"\
    ])\n    [\"a\", \"b\", \"c\"]\n    \n*/\nstring[] remove_duplicates(string[] numbers)\
    \ \n{\n    int index = 0;\n    string[] nums_out = std.array.create(numbers.length,\
    \ \"\");\n    for(int i = 0; i < numbers.length; ++i)\n    {\n        if (nums_out[index]\
    \ != numbers[i])\n        {\n            nums_out[index++] = numbers[i];\n   \
    \     }\n    }\n    return nums_out;\n}\n/*\n From an array of characters, remove\
    \ all elements that occur more than once.\n    Keep order of elements left the\
    \ same as in the input.\n    >>> remove_duplicates([\"a\", 'b', 'b', 'c', 'b'])\n\
    \    ['a', 'b', 'c', 'b']\n    \n*/\nchar[] remove_duplicates(char[] numbers)\
    \ \n{\n    int index = 0;\n    char[] nums_out = std.array.create(numbers.length,\
    \ 0);\n    for(int ", "{\n    long[] ans = new long[numbers.length];\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        int count = 0;\n      \
    \  for (int j = 0; j < numbers.length; j++)\n        {\n            if (numbers[i]\
    \ == numbers[j])\n            {\n                count++;\n            }\n   \
    \     }\n        ans[i] = numbers[i];\n        if (count > 1)\n        {\n   \
    \         ans[i] = numbers[i];\n        }\n    }\n    return ans;\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis is probably the best answer out there for most\
    \ questions tagged with `C#`.\n<|/ c |>\n<| c |>\nVery clean solution. Thanks.\n\
    <|/ c |>\n<| c |>\nIf you're writing a library, you might want to throw exceptions\
    \ instead of returning null.\n<|/ c |>\n<| a tags=arrays,c# |>\nHere's another\
    \ solution which is probably more efficient that others.\n<code>\nvar uniques\
    \ = new HashSet<string>();\nfor (var i = 0; i < numbers.Length; ++i)\n{\n  if\
    \ (uniques.Add(numbers[i]))\n  {\n    numbers.RemoveAt(i);\n    i--;\n  }\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nWhat if the order of the array is randomized?\
    \ You will get a different order than you expect\n<|/ c |>\n<| c |>\nThat's not\
    \ the purpose of the question. OP was asking how to remove duplicates, not how\
    \ to keep the order.\n<|/ c |>\n<| a dscore=2 tags=arrays,c# |>\n<code>\nusing\
    \ System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;",
  "{\n    long[] result;\n    long temp;\n    result = new long[numbers.length];\n\
    \    for (int i = 0; i<numbers.length; ++i) {\n        for (int j = i+1; j<numbers.length;\
    \ ++j) {\n            if (numbers[i] == numbers[j]) {\n                continue;\n\
    \            }\n            temp = numbers[i];\n            numbers[i] = numbers[j];\n\
    \            numbers[j] = temp;\n        }\n    }\n    result = Arrays.copyOf(numbers,\
    \ numbers.length);\n    Arrays.sort(result);\n    return result;\n}", "{\n\tif\
    \ (numbers == null || numbers.length == 0)\n\t\treturn new long[0];\n\tlong[]\
    \ temp = new long[numbers.length];\n\t\n\tfor (int i = 0; i < numbers.length;\
    \ i++){\n\t\tlong val = numbers[i];\n\t\tint index = 0;\n\t\twhile (index < temp.length\
    \ && temp[index] == val)\n\t\t\tindex++;\n\t\tif (index < temp.length){\n\t\t\t\
    temp[index] = val;\n\t\t}\n\t}\n\treturn temp;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    int n = numbers.length;\n    int i = 0;\n    int\
    \ j = 0;", "{\n   long last = numbers[0];\n   long[] results = new long[numbers.length\
    \ - 1];\n   for (int i = 1; i < numbers.length; ++i)\n   {\n      if (numbers[i]\
    \ != last)\n         last = numbers[i];\n      else\n         results[i - 1] =\
    \ numbers[i];\n   }\n   return results;\n}\n/*\n From an array of integers, remove\
    \ all elements that occur more than once.\n    Keep order of elements left the\
    \ same as in the input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n   \
    \ [1L, 3L, 4L]\n    \n*/\nulong[] remove_duplicates(ulong[] numbers) \n{\n   ulong\
    \ last = numbers[0];\n   ulong[] results = new ulong[numbers.length - 1];\n  \
    \ for (int i = 1; i < numbers.length; ++i)\n   {\n      if (numbers[i] != last)\n\
    \         last = numbers[i];\n      else\n         results[i - 1] = numbers[i];\n\
    \   }\n   return results;\n}\n/*\n From an array of integers, remove all elements\
    \ that occur more than once.\n    Keep order of elements left the same as in the\
    \ input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n\
    \    \n*/", "{\n  int i,j,count=0;\n  long[] results = new long[numbers.length];",
  "{\n    if (numbers == null) throw new ArgumentNullException(\"numbers\", \"numbers\
    \ is null\");\n    int size = numbers.length;\n    if (size == 0) return new long[0];\n\
    \    if (size == 1) return new long[]{numbers[0]};\n    // sort numbers descending\n\
    \    Arrays.sort(numbers, long.TYPE.reverseOrder());\n    long[] dups = new long[size];\n\
    \    // walk through all numbers, counting duplicates\n    long lastNumber = numbers[0];\n\
    \    for (int i = 1; i < size; i++) {\n        if (numbers[i] == lastNumber) {\n\
    \            dups[i]++;\n        } else {\n            lastNumber = numbers[i];\n\
    \            dups[i] = 1;\n        }\n    }\n    // remove all numbers that appear\
    \ more than\n    // once by only keeping the first occurrence\n    for (int i\
    \ = 0; i < size; i++) {\n        if (dups[i] > 1)\n            numbers[i] = dups[0];\
    \ // keep first occurrence\n        else\n            numbers[i] = 0;\n    }\n\
    \    return numbers;\n}\n/*\n From an array of doubles, remove all elements that\
    \ occur more than once.\n    Keep order of elements left the same as in the input.\n\
    \    >>> remove_duplicates([1.1, 2.2, 3.3, 2.2, 4.4])\n    [1.1, 3.3, 4.4]\n \
    \   \n*/\ndouble[] remove_duplicates(double[] numbers) \n{\n    if (numbers ==\
    \ null) throw new ArgumentNullException(\"numbers\", \"numbers is null\");\n \
    \   int size = numbers.length;\n    if (size == 0) return new double[0];\n   \
    \ if (size == 1) return new double[]{numbers[0]};\n    // sort numbers descending\n\
    \    Arrays.sort(numbers, double.TYPE.reverseOrder());\n    double[] dups = new\
    \ double[size];\n    // walk through all numbers, counting duplicates\n    double\
    \ lastNumber = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i]\
    \ == lastNumber) {\n            dups[i]++;\n        } else {\n            lastNumber\
    \ = numbers[i];\n            dups[i] = 1;\n        }\n    }\n    // remove all\
    \ numbers that appear more than\n    // once by only keeping the first occurrence\n\
    \    for (int i = 0; i < size; i++) {\n        if (dups[i] > 1)\n            numbers[i]\
    \ = dups[0]; // keep first occurrence\n        else\n            numbers[i] =\
    \ 0;\n    }\n    return numbers;\n}\n/*\n From an array of objects, remove all\
    \ elements that occur more than once.\n    Keep order of elements left the same\
    \ as in the input.\n    >>> remove_duplicates([new A(), new A(), new A(), new\
    \ B(), new B(), new B()])\n    [new A(), new B()]\n    \n*/\nA[] remove_duplicates(A[]\
    \ objects) \n{\n    if (objects == null) throw new ArgumentNullException(\"objects\"\
    , \"objects is null\");\n    int size = objects.length;\n    if (", "{\n    long\
    \ temp=0;\n    long results[];\n    int count=0;\n    int i;", "{\n    int i =\
    \ 0;\n    int j = 0;\n    int n = numbers.length - 1;\n    long[] newArray = new\
    \ long[n];", "{\n    long result[] = numbers;\n    int[] seen = new int[32];\n\
    \    for( int i=1; i<numbers.length; i++ )\n    {\n        if( seen[numbers[i]]\
    \ != i )\n            result[i] = numbers[i];\n        seen[numbers[i]] = i;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe code is\
    \ good, but it doesn't remove the duplicated numbers.\n<|/ c |>\n<| a tags=language-agnostic,algorithm,arrays\
    \ |>\nYou can do this by creating an array of sets of numbers. In the example\
    \ below, I will use a map to store the numbers, so that I can easily check if\
    \ a number has already been seen:\n<code>\nlet input = [3, 7, 9, 7, 9, 10, 5,\
    \ 6, 6, 6, 7, 6, 7, 10, 7];\nlet sets: Map[int, Set[int]] = Map();\nfor num in\
    \ input {\n    // add num to the set for that key\n    if !sets.contains(num)\
    \ {\n        sets[num] = Set(num);\n    } else {\n        let set = sets[num];\n\
    \        // if num has already been seen, remove the number\n        // from the\
    \ set so it is only seen once\n        if set.contains(num) {\n            set.remove(num);\n\
    \        } else {\n            // otherwise, add the number to the set so that\
    \ we see\n            // it a second time\n            set.add(num);\n       \
    \ }\n    }\n}\n// set contains all unique numbers now\nfor num in sets.keySet()\
    \ {\n    // get the set of numbers corresponding to num\n    let set = sets[num];\n\
    \    // print the numbers in the set\n    println(set);\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\
    import java.util.List;\nimport java.util.HashSet;", "{\n    long[] res = new long[numbers.length];\n\
    \    long last;\n    for (int i = 0; i < numbers.length; i++) {\n        last\
    \ = res[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n        \
    \    if (numbers[i] != numbers[j] && numbers[i] > last)\n                res[++i]\
    \ = numbers[j];\n        }\n    }\n    return res;\n}\n</code>\nThis assumes that\
    \ your array is sorted and non-decreasing. You can use this with remove_duplicates(numbers,\
    \ 0, numbers.length - 1) to remove all duplicates from the array, starting at\
    \ the first duplicate and up to the last duplicate (starting at index 1, to remove\
    \ the duplicate at index 0).\n<|/ a |>\n<| a tags=java |>\nUsing streams:\n<code>\n\
    public static <T> Set<T> remove(Set<T> set, Comparator<T> c) {\n    return set.stream()\n\
    \        .distinct()\n        .sorted(c)\n        .collect(Collectors.toCollection(LinkedHashSet::new));\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis should be the accepted answer, as\
    \ it does not require external libraries. Although I would have used a `Set` instead\
    \ of the `LinkedHashSet` to preserve the original order of `set` elements.\n<|/\
    \ c |>\n<| c |>\nThis is great! For people wanting to use generics and lambda\
    \ expressions, add `<T extends Comparable<T>>` to the generic type parameters,\
    \ and use `sorted(Comparator.<T>comparingInt(T o) -> o.compareTo(o))` instead.\n\
    <|/ c |>\n<| a tags=java dscore=4 |>\nHere is another way to do it in Java 8 and\
    \ above:\n<code>\npublic static <T> Set<T> remove(Set<T> set, Comparator<T> c)\
    \ {\n    Set<T> set2 = new HashSet<>();\n    for (T t : set) {\n        if (set2.contains(t))\
    \ {\n            set2.remove(t);\n        } else {\n            set2.add(t);\n\
    \        }\n    }\n    return set2;\n}\n</code>\n<|/ a |>\n<| c |>\nThis won't\
    \ work properly if any element has duplicates. Try removing from set `[1,1,2,3,3]`\
    \ will return `[2]` instead of `[1, 3]`.\n<|/ c |>\n<| a |>\nYou can use HashSet\
    \ to remove duplicated elements.\n<code>\n    Set<Integer> set = new HashSet<>();\n\
    \    set.addAll(Arrays.asList(new Integer[]{1,2,2,2}));\n    System.out.println(set);\
    \ // [2,2]\n</code>\n<|/ a dscore=4 tags=java |>\n<| c |>\nA `Set` is not a collection\
    \ though, which is what the OP asked for", "{\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i];\n\
    \    \n    for (int i = 0; i < numbers.length; i++)\n    {\n        int cnt =\
    \ 0;\n        for (int j = 0; j < numbers.length; j++)\n            if (result[j]\
    \ == numbers[i])\n                cnt++;\n        \n        if (cnt > 1)\n   \
    \     {\n            for(int j = 0; j < numbers.length; j++)\n               \
    \ numbers[j] = numbers[j] + cnt;\n        }\n    }\n    \n    return numbers;\n\
    }\n/*\n From an array of integers, remove all elements that occur more than once.\n\
    \    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/", "{\n    long[] result = new long[numbers.length];\n\
    \    Arrays.sort(numbers);\n    long unique = numbers[0];\n    \n    for (int\
    \ i = 1; i < numbers.length; i++)\n    {\n        if (numbers[i] != unique)\n\
    \        {\n            unique = numbers[i];\n        }\n        else\n      \
    \  {\n            i++;\n        }\n    }\n    \n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] != unique)\n        {\n            result[i\
    \ - numbers.length + 1] = numbers[i];\n        }\n    }\n    \n    return result;\n\
    }\n</code>\n<|/ a tags=c#,unity3d |>\n<| a |>\nYou can use the linq for that.\n\
    <code>", "{\n    long[] result = new long[numbers.length];\n    for(int i = 0;\
    \ i < numbers.length; ++i)\n        result[numbers[i]] = numbers[i];\n    for(int\
    \ i = 0; i < numbers.length; ++i)\n        if(result[i] != numbers[i]) \n    \
    \        result[i] = numbers[i];\n    return result;\n}\n</code>\n<|/ a tags=arrays,sorting,c#\
    \ |>\n<| a tags=arrays,sorting,c# |>\n<code>\nvar a = new [] { 1, 2, 3, 4, 1,\
    \ 2, 5, 6 }; // 1\nvar result = a.OrderByDescending(x => x).Distinct().ToArray();\
    \  // 2\n</code>\n<|/ a dscore=4 |>\n<| c |>\nNice! Do you have a link that explains\
    \ the different ways of using LINQ? (I searched but couldn't find anything)\n\
    <|/ c |>\n<| c |>\nLINQ uses deferred execution. Everything is evaluated and put\
    \ in the IEnumerable class (Lists, Arrays, etc) and everything is done at the\
    \ point of execution. LINQ is like writing for loops with variables. There are\
    \ several methods (OrderBy, GroupBy, Where) that are used to transform data based\
    \ on a key and a value (sorting, grouping, filtering). LINQ basically just uses\
    \ those methods and applies them to the IEnumerable (aka the array). The methods\
    \ return IEnumerable so you can chain them together (Where(...).OrderByDescending(...).Distinct()).\
    \ See more here: http://msdn.microsoft.com/en-us/library/bb397926.aspx\n<|/ c\
    \ |>\n<| c |>\nThanks a lot. Very helpful.\n<|/ c |>\n<| c |>\n: Thanks for posting\
    \ the link.  That's helpful.\n<|/ c |>\n<| a tags=arrays,sorting,c# |>\n<code>\n\
    public static class ArrayHelper\n{\n  public static int[] Sort(this int[] array)\n\
    \  {\n     Array.Sort(array);\n     return array;\n  }", "{\n    if (numbers ==\
    \ null || numbers.length == 0)\n        return numbers;\n    \n    long uniques[numbers.length];\n\
    \    int index = 0;\n    \n    for (long num : numbers) {\n        // This element\
    \ isn't in the unique array\n        if (index < uniques.length && num == uniques[index])\
    \ {\n            continue;\n        }\n        \n        uniques[index++] = num;\n\
    \    }\n    \n    long[] res = new long[uniques.length];\n    \n    for (int i\
    \ = 0; i < uniques.length; ++i)\n        res[i] = uniques[i];\n    \n    return\
    \ res;\n}", "{\n  int n = numbers.length;\n  int i = 0;\n  long[] a = new long[n];\n\
    \  while (i < n) \n  {\n    if (!numbers[i]) \n    {\n      a[i] = numbers[i];\
    \ \n      i++; \n    } \n    else\n    {\n      if (numbers[i] != a[i])\n    \
    \  {\n        a[++i] = numbers[i];\n      }\n    }\n  }\n  return a;\n}", "{\n\
    \    long[] uniqueValues = new long[numbers.length];\n    int j = 0;\n    for\
    \ (int i = 0; i < numbers.length; i++) \n    {\n        if (!numbers[j].isMember(numbers[i]))\n\
    \        {\n            uniqueValues[j] = numbers[i];\n            j++;\n    \
    \    }\n    }\n    uniqueValues = uniqueValues.slice(0, j);\n    return uniqueValues;\n\
    }\n</code>\n<|/ a tags=java,arraylist |>\n<| a |>\nA variation of's answer that\
    \ uses Java 8 streams:\n<code>\nArrays.stream(numbers).distinct().toArray();\n\
    </code>\n<|/ a tags=java,arraylist dscore=1 |>\n<| c |>\nThat `toArray` call can\
    \ be replaced by `unique()`\n<|/ c |>\n<| a |>\nJust another solution, using Arrays.stream().distinct():\n\
    <code>\nimport java.util.Arrays;", "{\n\tint i;\n\tint j;\n\tlong[] newNumbers\
    \ = new long[numbers.length];\n\t\n\tfor(i = 0;i < newNumbers.length; ++i)\n\t\
    {\n\t\tlong value = numbers[i];\n\t\tfor(j = 0;j < i; ++j)\n\t\t{\n\t\t\tlong\
    \ compare = numbers[j];\n\t\t\tif(value == compare)\n\t\t\t\tcontinue;\n\t\t\t\
    \n\t\t\tlong next = newNumbers[j];\n\t\t\tif(compare > value)\n\t\t\t\tnewNumbers[j]\
    \ = value;\n\t\t\telse\n\t\t\t\tnewNumbers[j] = compare;\n\t\t}\n\t}\n\t\n\treturn\
    \ newNumbers;\n}", "{\n  int[,] map = new int[numbers.length, numbers.Length];\n\
    \  long curr = 1;\n  for (int i = 0; i < map.Length; i++)\n    map[i, 0] = numbers[i];\n\
    \  for (int i = numbers.length - 1; i >= 0; i--)\n    if (map[i, 0] != curr)\n\
    \      numbers[i] = map[i, 0];\n    else\n      curr++;\n  return numbers;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nThanks Jake. I'm going to test it later but I'm pretty\
    \ sure it will work so I'll mark it as the answer.\n<|/ c |>\n<| c |>\nJake, that\
    \ algorithm is O(n^2) complexity and will take about twice as long on a 32-bit\
    \ machine\n<|/ c |>\n<| a tags=performance,c#,algorithm,duplicates |>\nThis code\
    \ will work with very large collections and is very fast.\n<code>\nvar list =\
    \ new List<int> { 1, 2, 3, 2, 3, 5, 6, 7, 3, 9, 1, 2 };\nvar result = list.GroupBy(x\
    \ => x)\n                .Select(g => g.Count() == 1)\n                .Where(x\
    \ => x)\n                .Select(x => g.Key);\n</code>\n<|/ a dscore=4 |>\n<|\
    \ c |>\nIt would probably be better to use .Count() == 1 instead of .Any(x =>\
    \ x == 1) though.\n<|/ c |>\n<| c |>\n- you're right about that.  It actually\
    \ makes the code more readable and simpler to read.  Thanks for the suggestion\
    \ and I updated the post.\n<|/ c |>\n<| c |>\n- I took your suggestion to fix\
    \ the code above.  I also added code to show how you can get the original collection\
    \ back if you need it.\n<|/ c |>\n<| c |>\nHow about this: var result = list.GroupBy(x\
    \ => x)\n                .Where(g => g.Count() == 1)\n                .Select(g\
    \ => g.Key);\n<|/ c |>\n<| c |>\n- I like this better.  I updated the post.  Thanks\
    \ for your suggestion.\n<|/ c |>\n<| a |>\nThis is an improved version of Jason's\
    \ answer.\nThis version works even on very large collections (not just the one\
    \ I tested with - though I highly doubt it will work for large collections anyway).\n\
    It also does a pretty good job of avoiding boxing and unboxing.\nIt also uses\
    \ IEqualityComparer<T> instead of EqualityComparer<T>.\n<code>\nstatic IEnumerable<T>\
    \ RemoveDupes<T>(this IEnumer", "{\n    long[] answer = numbers;\n    for(int\
    \ i = 0; i < numbers.length - 1; i++)\n    {\n        if(numbers[i] != numbers[i\
    \ + 1])\n        {\n            answer = copy(numbers, i, i - 1);\n        }\n\
    \    }\n    return answer;\n}\n/*\n An implementation of the Fibonacci sequence\
    \ \n    i.e. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...\n    \n >>> fibs(10)\n\
    \    [1, 1, 2, 3, 5, 8, 13, 21, 28, 56, 88, 144, ...]\n \n*/\nlong[] fibs(int\
    \ num)\n{\n    long[] fibs_arr = new long[num + 1];\n    fibs_arr[0] = fibs_arr[1]\
    \ = 0;\n    for(int i = 2; i <= num; i++)\n        fibs_arr[i] = fibs_arr[i-1]\
    \ + fibs_arr[i-2];\n    return fibs_arr;\n}\n/*\n A generalized version of fibonacci\
    \ that can be used for any length\n    i.e. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55,\
    \ 89, 144, ...\n    \n >>> fib_gen(10)\n    [1, 1, 2, 3, 5, 8, 13, 21, 28, 56,\
    \ 88, 144, ...]\n \n*/\nlong[] fib_gen(int num)\n{\n    long[] fib_gen_arr = new\
    \ long[num];\n    fibs_gen(num, fib_gen_arr, 0, 1);\n    return fib_gen_arr;\n\
    }\n/*\n A generalized version of fibonacci that can be used for any length\n \
    \   i.e. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...\n    \n >>> fib_gen(10)\n\
    \    [1, 1, 2, 3, 5, 8, 13, 21, 28, 56, 88, 144, ...]\n \n*/\nlong[] fibs_gen(int\
    \ num, long[] fib_gen_arr, long a, long b)\n{\n    long last = a;\n    for(int\
    \ i = 2; i <= num; i++)\n    {\n        long temp = a;\n        a = b;\n     \
    \   b = temp + b;\n        fib_gen_arr[i] = a;\n    }\n    return fib_gen_arr;\n\
    }\n/*\n A generalized version of fibonacci that can be used for any length\n \
    \   i.e. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...\n    \n >>> fib_gen(10)\n\
    \    [1, 1, 2, 3, 5, 8, 13, 21, 28, 56, 88, 144, ...]\n \n*/\nlong[] fibs_gen(int\
    \ num, long[] fib_gen_arr, long a, long b)\n{\n    long last = a;\n    for(int\
    \ i = 2; i <= num; i++)", "{\n    var newNumbers = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i]\
    \ == null) \n        {\n            newNumbers[i] = null;\n        }\n       \
    \ else if (newNumbers[i] == null) \n        {\n            newNumbers[i] = numbers[i];\n\
    \        }\n        else \n        {\n            var counter = 0;\n         \
    \   for (int j = i + 1; j < newNumbers.length; j++) \n            {\n        \
    \        if (numbers[j] == newNumbers[i]) \n                {\n              \
    \      counter++;\n                }\n            }\n            if (counter >\
    \ 1) \n            {\n                newNumbers[i] = numbers[i];\n          \
    \  }\n        }\n    }\n    return newNumbers;\n}\n</code>\n<|/ a tags=duplicates,arrays,c#\
    \ |>\n<| a tags=duplicates,arrays,c# dscore=1 |>\nYou can do this with LINQ's\
    \ GroupBy function. To get distinct items, you need to group them by some criteria,\
    \ and then select their items:\n<code>", "{\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        long num = 0;\n\
    \        for (int j = 0; j < numbers.length; j++)\n        {\n            if (i\
    \ == j)\n                continue;\n            num ^= numbers[j];\n        }\n\
    \        result[i] = num;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    int index = 0;\n    for(int i=0; i < numbers.length;\
    \ i++)\n    {\n        bool isInResult = false;\n        for(int j=0; j < i; j++)\n\
    \        {\n            if(numbers[i] == numbers[j])\n            {\n        \
    \        isInResult = true;\n                break;\n            }\n        }\n\
    \        if(!isInResult)\n        {\n            result[index++] = numbers[i];\n\
    \        }\n    }\n    return result;\n}\n/*\n From an array, remove all elements\
    \ that occur more than once and keep the order of elements left the same.\n  \
    \  Remove duplicate elements only if it is next to each other (no gaps or overlaps).\n\
    \    >>> remove_duplicates([1L, 2L, 3L, 3L, 4L])\n    [1L, 2L, 3L, 4L]\n    \n\
    */\nlong[] remove_duplicates(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    int index = 0;\n    for(int i=0; i < numbers.length; i++)\n    {\n      \
    \  bool isInResult = false;\n        for(int j=0; j < i; j++)\n        {\n   \
    \         if(numbers[i] == numbers[j])\n            {\n                isInResult\
    \ = true;\n                break;\n            }\n        }\n        if(!isInResult)\n\
    \        {\n            result[index++] = numbers[i];\n        }\n    }\n    return\
    \ result;\n}\n/*\n From an array, remove all elements that occur more than once\
    \ and keep the order of elements left the same.\n    Remove duplicate elements\
    \ only if it is next to each other (no gaps or overlaps).\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 3L, 4L])\n    [1L, 2L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    int index =\
    \ 0;\n    for(int i=0; i < numbers.length; i++)\n    {\n        bool isInResult\
    \ = false;\n        for(int j=0; j < i; j++)\n        {\n            if(numbers[i]\
    \ == numbers[j])\n            {\n                isInResult = true;\n        \
    \        break;\n            }\n        }\n        if(!isInResult)\n        {\n\
    \            result[index++] = numbers[i];\n        }\n    }\n    return result;\n\
    }\n/*\n From an array, remove all elements that occur more than once and keep\
    \ the order of elements left the same.\n    Remove duplicate elements only if\
    \ it is next to each other (no gaps or overlaps).\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 3L, 4L])\n    [1L, 2L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates(long[]\
    \ numbers) \n{\n", "{\n  int n = numbers.length;\n  long[] result = new long[n];\n\
    \  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < i; j++) {\n      if\
    \ (numbers[i] == numbers[j]) {\n        numbers.splice(j, 1);\n      }\n    }\n\
    \    result[i] = numbers[i];\n  }\n  return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    int count = 1;\n    for (int i=0; i<numbers.length;\
    \ i++)\n    {\n        int number = numbers[i];\n        for (int j=i+1; j<numbers.length;\
    \ j++)\n        {\n            if (numbers[j] == number)\n            {\n    \
    \            count++;\n            }\n        }\n        if (count > 1)\n    \
    \    {\n            result[i] = number;\n            count = 1;\n        }\n \
    \   }\n    return result;\n}\n</code>\n<|/ a tags=arrays,java dscore=0 |>\n<|\
    \ a tags=arrays,java |>\nI have developed my own algorithm to solve this problem.\
    \ Hopefully it helps someone. \n<code>\npublic static void main(String args[])\
    \ {\n    long arr[] = {1, 2, 1, 2, 1, 2};\n    arr = removeDuplicates(arr);\n\
    \    System.out.println(Arrays.toString(arr));\n}", "{\n    long[] newArray =\
    \ new long[numbers.length];\n    int j = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++) \n    {\n        if(numbers[j] != numbers[i])\n        {\n            newArray[j]\
    \ = numbers[i];\n            j = j + 1;\n        }\n    }\n    return newArray;\n\
    }", "{\n    int count = 0;\n    List<long> result = new List<long>(numbers.Length);\n\
    \    foreach(long element in numbers)\n    {\n        if(count++ < numbers.Length)\n\
    \        {\n            result.add(element);\n        }\n    }\n    return result;\n\
    }", "{\n    long[] copy = new long[numbers.length];\n    int i, j;\n    for(i\
    \ =0; i < numbers.length; i++) \n    {\n        copy[i] = numbers[i];\n      \
    \  for(j = i; j < numbers.length; j++) \n        {\n            if(numbers[j]\
    \ == copy[i]) \n            {\n                numbers[j] = numbers[j+1];\n  \
    \              numbers[j+1] = copy[i];\n            }\n        }\n    }\n    return\
    \ copy;\n}", "{\n    bool seen[numbers.size()]; \n    long result[] = new long[numbers.size()];\
    \ \n    for(int i = 0; i < numbers.size(); i++) { \n        if(!seen[i]) {\n \
    \           seen[i] = true;\n            result[i] = numbers[i]; \n        }\n\
    \    } \n    return result; \n}", "{\n    long[] result = new long[numbers.length];\n\
    \    Stack<long> numbersWithoutDuplicates = new Stack<long>();", "{\n\tif (numbers.length\
    \ == 0)\n\t\treturn numbers;\n\tif (numbers.length == 1)\n\t{\n\t\treturn numbers.clone();\n\
    \t}\n\tlong lastNumber;\n\tlong[] newNumbers = new long[numbers.length];\n\tlong\
    \ temp;\n\tfor (int i = 0; i < numbers.length; i++)\n\t{\n\t\tlast = numbers[i];\n\
    \t\tfor (int j = i; j < numbers.length; j++)\n\t\t{\n\t\t\tif (numbers[j] != last)\n\
    \t\t\t{\n\t\t\t\ttemp = lastNumber;\n\t\t\t\tlastNumber = last;\n\t\t\t\tlast\
    \ = numbers[j];\n\t\t\t\tnumbers[j] = temp;\n\t\t\t}\n\t\t}\n\t\tif (newNumbers[i]\
    \ == lastNumber)\n\t\t{\n\t\t\tnewNumbers[i] = lastNumber;\n\t\t}\n\t}\n\treturn\
    \ newNumbers;\n}\n//**********************************************************************************************************\n\
    /*\n From an array of integers, remove all elements that occur more than once.\n\
    \    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/", "{\n    int n = numbers.length;\n\
    \    int count = 1;\n    long[] result = new long[n];\n    for (int i = 0; i <\
    \ n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (numbers[i]\
    \ != numbers[j]) {\n                if (count < 2)\n                    result[i]\
    \ = numbers[i];\n                else {\n                    count--;\n      \
    \              result[i] = numbers[j];\n                }\n            }\n   \
    \     }\n    }\n    return result;\n}\n</code>\n<|/ a tags=java |>\n<| a dscore=0\
    \ |>\nMy solution just uses a nested loop:\n<code>\npublic static void main(String[]\
    \ args) {\n    int[] arr = {1, 2, 3, 4, 2, 4};\n    int arrLen = arr.length;\n\
    \    int[] results = new int[arrLen - 1];\n    int resultCount = 0;\n    for (int\
    \ i = 1; i < arrLen; i++) {\n        int currentResult = arr[i];\n        for\
    \ (int j = 0; j < i; j++) {\n            if (currentResult == arr[j]) {\n    \
    \            results[resultCount] = currentResult;\n                resultCount++;\n\
    \                break;\n            }\n        }\n    }\n    for (int i = resultCount;\
    \ i < arrLen; i++) {\n        results[resultCount - 1] = arr[i];\n    }\n    System.out.println(Arrays.toString(results));\n\
    }\n</code>\n<|/ a tags=java |>\n<| a dscore=0 |>\nUsing Java Stream API\n<code>",
  "{\n  int n = numbers.length;\n  if (n == 0) {\n    return numbers;\n  }\n  long[]\
    \ results = new long[n];\n  for (int i = 0; i < n; i++) {\n    long v = numbers[i];\n\
    \    if (results.find(v) != results.end()) {\n      continue;\n    }\n    results[i]\
    \ = v;\n  }\n  return results;\n}\n/*\n From an array of integers, remove all\
    \ elements that occur more than once.\n    Keep order of elements left the same\
    \ as in the input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n    [1L,\
    \ 3L, 4L]\n    \n*/\nlong[] remove_duplicates(TArray<long> numbers) \n{\n  int\
    \ n = numbers.size;\n  if (n == 0) {\n    return numbers.data;\n  }\n  long[]\
    \ results = new long[n];\n  for (int i = 0; i < n; i++) {\n    long v = numbers[i];\n\
    \    if (results.find(v) != results.end()) {\n      continue;\n    }\n    results[i]\
    \ = v;\n  }\n  return results;\n}\n/*\n From an array of strings, remove all elements\
    \ that occur more than once.\n    Keep order of elements left the same as in the\
    \ input.\n    >>> remove_duplicates([\"a\", \"b\", \"c\", \"a\", \"b\"])\n   \
    \ [\"a\", \"b\", \"c\"]\n    \n*/\nstring[] remove_duplicates(string[] strs) \n\
    {\n  int n = strs.length;\n  if (n == 0) {\n    return strs;\n  }\n  string[]\
    \ results = new string[n];\n  for (int i = 0; i < n; i++) {\n    string v = strs[i];\n\
    \    if (results.find(v) != results.end()) {\n      continue;\n    }\n    results[i]\
    \ = v;\n  }\n  return results;\n}\n/*\n From an array of strings, remove all elements\
    \ that occur more than once.\n    Keep order of elements left the same as in the\
    \ input.\n    >>> remove_duplicates([\"a\", \"b\", \"c\", \"a\", \"b\"])\n   \
    \ [\"a\", \"b\", \"c\"]\n    \n*/\nTArray<string> remove_duplicates(TArray<string>\
    \ strs) \n{\n  int n = strs.size;\n  if (n == 0) {\n    return strs.data;\n  }\n\
    \  string[] results = new string[n];\n  for (int i = 0; i < n; i++) {\n    string\
    \ v = strs[i];\n    if (results.find(v) != results.end()) {\n      continue;\n\
    \    }\n    results[i] = v;\n  }\n  return results;\n}", "{\n    // your code\
    \ here\n    long result = 0;\n    for(int i = 0; i < numbers.length; i++)\n  \
    \  {\n        int count = 0;\n        for(int j = 0; j < numbers.length; j++)\n\
    \        {\n            if(numbers[i] == numbers[j])\n            {\n        \
    \        count++;\n            }\n        }\n        if(count > 1)\n        {\n\
    \            result++;\n        }\n    }\n    int[] newArray = new int[result];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        int count = 0;\n\
    \        for(int j = 0; j < numbers.length; j++)\n        {\n            if(numbers[i]\
    \ == numbers[j])\n            {\n                count++;\n            }\n   \
    \     }\n        if(count > 1)\n        {\n            newArray[i] = numbers[i];\n\
    \        }\n    }\n    return newArray;\n}\n</code>\n<|/ a dscore=0 tags=java,arrays,sorting,algorithm\
    \ |>\n<| c |>\nThis would be a better answer if you explained how the code you\
    \ provided answers the question.\n<|/ c |>\n<| a dscore=0 |>\nThis can be solved\
    \ in O(n) time, where n is the number of elements in the input array:\n<code>\n\
    private static int[] removeDuplicates(int[] arr) {\n    int[] copy = new int[arr.length];\n\
    \    for (int i = 0; i < arr.length; i++) {\n        int count = 0;\n        for\
    \ (int j = 0; j < copy.length; j++) {\n            if (arr[i] == copy[j]) {\n\
    \                count++;\n                break;\n            }\n        }\n\
    \        if (count > 1) {\n            copy[i] = arr[i];\n        }\n    }\n \
    \   return copy;\n}\n</code>\n<|/ a tags=java,arrays,sorting,algorithm |>\n<|\
    \ a tags=java,arrays,sorting,algorithm |>\n<code>\npublic class Solution {", "{\n\
    \tlong[] duplicates = new long[numbers.length];\n\tlong index = 0;\n\tfor (int\
    \ i = 0; i < numbers.length; i++) {\n\t\tif (duplicates[i] == numbers[i]) {\n\t\
    \t\tcontinue;\n\t\t}\n\t\tduplicates[index++] = numbers[i];\n\t}\n\treturn duplicates;\n\
    }\n/**\n Combine the given list of elements into a single long integer. \n The\
    \ resulting integer is obtained by summing all the elements and \n removing duplicate\
    \ values. Note that order of the elements in the array \n is preserved if possible,\
    \ otherwise the elements are returned in their \n original order.\n \n @see remove_duplicates\n\
    */\nlong combine_list_elements(long[] numbers) \n{\n\treturn numbers[numbers.length\
    \ - 1];\n}", "{\n    long[] nums_sorted = sort(numbers);\n    long[] unique =\
    \ new long[numbers.length];\n    long last_num = nums_sorted[numbers.length-1];\n\
    \    \n    for (int i = 0; i < numbers.length; i++)\n    {\n        if (nums_sorted[i]\
    \ == last_num)\n            unique[i] = nums_sorted[i];\n        else\n      \
    \      unique[i] = nums_sorted[i-1];\n    }\n    return unique;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=2 tags=arrays,data-structures,duplicates,sorting,algorithm\
    \ |>\nHere's my Java implementation:\n<code>\npublic static <T> void removeDuplicates(T[]\
    \ array) {\n    int lastIndex = array.length - 1;\n    for (int i = 0; i < lastIndex;\
    \ i++)\n        if (array[i] == array[lastIndex])\n            array[i] = null;\n\
    \            else if (array[i] != null)\n            array[i+1] = array[i];\n\
    }\n</code>\n<|/ a |>\n<| c |>\nHow would you do that in Java?\n<|/ c |>\n<| a\
    \ |>\nI recently had to do something similar and I implemented it like this:\n\
    <code>", "{\n    long temp;\n    long[] duplicates_removed = new long[numbers.length];\n\
    \    for(int i=0;i<numbers.length;i++) {\n        temp = numbers[i];\n       \
    \ duplicates_removed[i] = temp;\n    }\n    for(int i=0;i<numbers.length;i++)\
    \ {\n        for(int j=i+1;j<numbers.length;j++) {\n            if(numbers[i]\
    \ == numbers[j]) {\n                duplicates_removed[i] = duplicates_removed[j];\n\
    \            }\n        }\n    }\n    return duplicates_removed;\n}\n</code>\n\
    <|/ a tags=c++,arrays,algorithm,duplicates |>\n<| c |>\nThe question was tagged\
    \ with `algorithm`, not `performance`.\n<|/ c |>\n<| c |>\nThe question is tagged\
    \ C++ though.\n<|/ c |>\n<| a dscore=3 tags=c++,arrays,algorithm,duplicates |>\n\
    Here's a solution in python\n<code>\ndef removeDups(l):\n    seen = set()\n  \
    \  for i in l:\n        if i not in seen:\n            yield i\n            seen.add(i)",
  "{\n    long last = numbers[0];\n    long removed = numbers[0];", "{\n    long[]\
    \ result = new long[numbers.length];\n    int i;\n    \n    for (int i = 0; i\
    \ < numbers.length; i++)\n    {\n        long previous = result[i];\n        for\
    \ (int j = i + 1; j < numbers.length; j++)\n        {\n            if (numbers[i]\
    \ == numbers[j])\n            {\n                previous++;\n            }\n\
    \        }\n        result[i] = previous;\n    }\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI think you meant `if (numbers[i] == numbers[j])`\n<|/ c |>\n\
    <| a dscore=2 tags=duplicates,arrays,java |>\n<code>", "{\n    long[] rv = new\
    \ long[numbers.length];\n    for(int i = 0; i < rv.length; i++) rv[i] = numbers[i];\n\
    \    HashSet<long> seen = new HashSet<long>();\n    for(int i = 0; i < rv.length;\
    \ i++) \n    {\n        long current = rv[i];\n        if(seen.contains(current))\
    \ continue;\n        seen.add(current);\n        rv[i] = current;\n    }\n   \
    \ return rv;\n}\n</code>\n<|/ a tags=c# |>\n<| c |>\nI think it should be `numbers[i].ToString()`\
    \ because in some cases it will cause IndexOutOfRange Exception in `long current\
    \ = numbers[i];`.\n<|/ c |>\n<| c |>\n, that's exactly my thought.\n<|/ c |>\n\
    <| c |>\n, `numbers[i].ToString()` is correct in cases where `numbers` is a `string[]`.\
    \  Since OP mentions that `numbers` is a long array, this answer is correct.\n\
    <|/ c |>\n<| a dscore=3 tags=c# |>\nThe simplest answer would be:\n<code>\nvar\
    \ result = numbers.GroupBy(n => n).Where(g => g.Count() > 1).Select(g => g.Key);\n\
    </code>\n<|/ a |>\n<| a |>\nThis should do it...\n<code>\nvar numbers = new List<int>()\
    \ { 1, 2, 3, 2, 4 };\nvar result = numbers.GroupBy(n => n).Where(g => g.Count()\
    \ > 1).Select(g => g.Key);\n</code>\n<|/ a dscore=2 tags=c# |>\n<| a tags=c# |>\n\
    <code>\nvar numbers = new[] { 1, 2, 3, 2, 4 };\nvar result = numbers.GroupBy(n\
    \ => n).Where(g => g.Count() > 1).Select(g => g.Key);\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nWhile this code snippet may solve the question, [including an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| a tags=c# |>\n<code>\nvar numbers\
    \ = new int[] { 1, 2, 3, 2, 4 };", "{\n    long[] result = new long[numbers.length];\n\
    \    int j = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n       \
    \ for (int k = j + 1; k < result.length; k++)\n        {\n            if (numbers[i]\
    \ == result[k])\n            {\n                j++;\n                continue;\n\
    \            }\n            else\n            {\n                result[j] = numbers[i];\n\
    \                j++;\n            }\n            break;\n        }\n    }\n \
    \   return result.subarray(0, j);\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=java,sorting,algorithm\
    \ |>\nJava 8 way:\n<code>\nprivate static int[] removeDuplicates(int[] arr) {\n\
    \    Set<Integer> set = new HashSet<>();\n    List<Integer> result = new ArrayList<>();\n\
    \    for(int i : arr) {\n        if(set.contains(i)) {\n            continue;\n\
    \        }\n        set.add(i);\n        result.add(i);\n    }\n    return result.toArray(new\
    \ int[result.size()]);\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis answer has\
    \ a better readability than mine. +1\n<|/ c |>\n<| a dscore=1 |>\nJava 8 way using\
    \ Streams\n<code>", "{\n  long[] result = new long[numbers.length];\n  for(long\
    \ i : numbers)\n    result[result.length-i-1] = i;\n  return result;\n}\n/*\n\
    \ From an array of integers, remove all elements that occur more than once.\n\
    \    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nulong[] remove_duplicates(ulong[]\
    \ numbers) \n{\n  ulong[] result = new ulong[numbers.length];\n  for(ulong i :\
    \ numbers)\n    result[result.length-i-1] = i;\n  return result;\n}\n/*\n From\
    \ an array of integers, remove all elements that occur more than once.\n    Keep\
    \ order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/", "{\n    int N=numbers.length;\n\
    \    long[] res=new long[N];\n    \n    for (int i=0; i < N; ++i) {\n        for\
    \ (int j=i+1; j < N; ++j) {\n            if (numbers[i] != numbers[j]) {\n   \
    \             res[j]=numbers[j];\n                break;\n            }\n    \
    \    }\n    }\n    return res;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long last = result[0];\n    for (int i = 0; i < numbers.length; i++) {\n\
    \        if (numbers[i] != last) {\n            result[result.length-1] = numbers[i];\n\
    \            last = numbers[i];\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 tags=arrays,c#,linq |>\n<| a dscore=0 |>\nThe \"answer\" from is\
    \ very good, but just for my own information I wanted to share my solution. This\
    \ is a bit more efficient than's and I think it's easier to read as well:\n<code>",
  "{\n    long count = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n \
    \       for (int j = i + 1; j < numbers.length; j++)\n        {\n            if\
    \ (numbers[i] == numbers[j])\n            {\n                count++;\n      \
    \          numbers.splice(i, 1);\n                i -= 1;\n            }\n   \
    \     }\n    }\n    return numbers;\n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\n\
    This is a C# solution for you:\n<code>\nprivate int[] RemoveDuplicates(int[] source)\n\
    {\n    return Enumerable.Range(0, source.Length)\n        .Where(x => !source.Skip(x).Any())\n\
    \        .ToArray();\n}\n</code>\n<|/ a tags=arrays,algorithm,c# |>\n<| c |>\n\
    I like how you used the fact that range returns an IEnumerable for this. +1\n\
    <|/ c |>\n<| a tags=arrays,algorithm,c# dscore=1 |>\nTry this one:\n<code>\nusing\
    \ System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;",
  "{\n    var result = new long[numbers.length];\n    var seen = new long[numbers.length];\n\
    \    var j = 0;\n    for (var i = 0, n = numbers.length; i < n; i++)\n    {\n\
    \        if (seen[i]++)\n        {\n            result[j] = numbers[i];\n    \
    \        j++;\n        }\n    }\n    return result;\n}\n/*\n From an array of\
    \ integers, remove all elements that occur more than once.\n    Keep order of\
    \ elements left the same as in the input.\n    >>> remove_duplicates([1L, 2L,\
    \ 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates_d(long[]\
    \ numbers) \n{\n    var result = new long[numbers.length];\n    var seen = new\
    \ long[numbers.length];\n    var j = 0;\n    for (var i = 0; i < numbers.length;\
    \ i++)\n    {\n        if (seen[numbers[i]]++)\n        {\n            result[j]\
    \ = numbers[i];\n            j++;\n        }\n    }\n    return result;\n}\n/*\n\
    \ From an array of integers, remove all elements that occur more than once.\n\
    \    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates1(long[]\
    \ numbers) \n{\n    var result = new long[numbers.length];\n    var seen = new\
    \ long[numbers.length];\n    var j = 0;\n    for (var i = 0; i < numbers.length;\
    \ i++)\n    {\n        if (seen[numbers[i]]++)\n        {\n            result[j]\
    \ = numbers[i];\n            j++;\n        }\n        else\n        {\n      \
    \      seen[numbers[i]] = 1;\n        }\n    }\n    return result;\n}\n/*\n From\
    \ an array of integers, remove all elements that occur more than once.\n    Keep\
    \ order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates2(long[]\
    \ numbers) \n{\n    var result = new long[numbers.length];\n    var seen = new\
    \ long[numbers.length];\n    var j = 0;\n    for (var i = 0; i < numbers.length;\
    \ i++)\n    {\n        if (!seen[numbers[i]]++)\n        {\n            result[j]\
    \ = numbers[i];\n            j++;\n        }\n    }\n    return result;\n}\n/*\n\
    \ From an array of integers, remove all elements that occur more than once.\n\
    \    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates3(long[]\
    \ numbers) \n{\n    var result = new long", "{\n    long hash = 0, unique = 0;\n\
    \    long[] result = new long[numbers.length];\n    int i = 0;\n    foreach(long\
    \ number in numbers) {\n        if (number == hash) {\n            hash++;\n \
    \       } else {\n            result[i++] = number;\n            hash = number;\n\
    \        }\n    }\n    return std.array.sortInPlaceByValue(result);\n}", "{\n\
    \  List list = new List();\n  for (int i = 0; i < numbers.length; i++)\n  {\n\
    \    if (list.contains(numbers[i]))\n      list.remove(numbers[i]);\n    else\n\
    \      list.add(numbers[i]);\n  }\n  return list.toArray();\n}\n/*\n From an array\
    \ of integers, remove all elements that occur more than once.\n    Keep order\
    \ of elements left the same as in the input.\n    >>> remove_duplicates([1L, 2L,\
    \ 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/", "{\n    List<long> result = new List<long>();",
  "{\n    long[] result = new long[numbers.length];\n    \n    int i = 0;\n    for(int\
    \ j=0; j<numbers.length; j++)\n    {\n        if (numbers[i] != numbers[j])\n\
    \        {\n            result[i++] = numbers[j];\n        }\n    }\n    \n  \
    \  return result;\n}", "{\n    long[] result = new long[numbers.length];\n   \
    \ int index = 0;\n    for (int i = 0; i < numbers.length; i++) \n    {\n     \
    \   if (numbers[i] <= 0)\n            result[index++] = numbers[i];\n        else\n\
    \            result[index++] = numbers[i]; \n    }\n    return result;\n}\n/*\n\
    \ From an array of integers, remove all elements that occur more than once.\n\
    \    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/", "{\n    long[] result = new long[numbers.length];\n\
    \    int pos = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  bool hasValue = false; // if we find an element, set the flag\n        for(int\
    \ j = 0; j < pos; j++)\n        {\n            if(numbers[i] == result[j])\n \
    \           {\n                hasValue = true;\n                break;\n    \
    \        }\n        }\n        if(!hasValue)\n        {\n            result[pos++]\
    \ = numbers[i];\n        }\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    \n    for (int i = 0; i < numbers.length; ++i)\
    \ {\n        long value = numbers[i];\n        for (int j = 0; j < i; ++j) {\n\
    \            if (value == numbers[j]) {\n                j++;\n              \
    \  break;\n            }\n        }\n        if (j >= i) {\n            result[i]\
    \ = value;\n        }\n    }\n    \n    return result;\n}\n</code>\n<|/ a |>\n\
    <| a tags=c# |>\nMy version :\n<code>\nvar result = numbers.GroupBy(x => x).Where(x\
    \ => x.Count() > 1).Select(x => x.Key);\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ tags=c# |>\nThis solution is for those who want to use LINQ and are unfamiliar\
    \ with loops.\n<code>\nList<int> numbers = new List<int>();\nnumbers.Add(1);\n\
    numbers.Add(2);\nnumbers.Add(3);\nnumbers.Add(2);\nnumbers.Add(4);\nnumbers.Add(5);\n\
    numbers.Add(5);\nnumbers.Add(5);\nnumbers.Add(5);", "{\n    long[] ans = new long[numbers.length];\n\
    \    long temp;\n    for (int i = 0; i < numbers.length; i++)\n    {\n       \
    \ temp = numbers[i];\n        int j;\n        for (j = i; j < numbers.length;\
    \ j++)\n        {\n            if (numbers[j] == temp)\n                break;\n\
    \        }\n        if (j == numbers.length)\n        {\n            ans[i] =\
    \ temp;\n        }\n        else\n        {\n            for (j = i; j < j; j++)\n\
    \            {\n                ans[j] = numbers[j];\n            }\n        }\n\
    \    }\n    return ans;\n}\n</code>\n<|/ a tags=hashmap,java,hashset,arrays |>\n\
    <| a |>\nThis code will remove all duplicates and return the sorted array. As\
    \ you can see I used Set instead of HashMap. This is the code:\n<code>\npublic\
    \ int[] removeDuplicates(int[] arr) {\n    Set<Integer> set = new LinkedHashSet<>();\n\
    \    for (int element : arr) {\n        if (!set.contains(element)) {\n      \
    \      set.add(element);\n        }\n    }\n    int[] result = new int[set.size()];\n\
    \    int i = 0;\n    for (Integer element : set) {\n        result[i++] = element;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=hashmap,java,hashset,arrays\
    \ dscore=0 |>\n<| c |>\nThis code returns sorted array but it does not remove\
    \ duplicates.\n<|/ c |>\n<| c |>\nYes, he can just remove duplicates and return\
    \ sorted array or he can remove duplicates and return sorted array. He just have\
    \ to change `set` to `LinkedHashSet` and return array `result`.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nA little bit more efficient than others posted here.\n<code>\n\
    public int[] removeDuplicates(int[] arr) {\n    Set<Integer> set = new LinkedHashSet<>();\n\
    \    for (int element : arr) {\n        if (!set.contains(element)) {\n      \
    \      set.add(element);\n        }\n    }\n    int[] result = new int[set.size()];\n\
    \    int i = 0;\n    for (Integer element : set) {\n        result[i++] = element;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=hashmap,java,hashset,arrays\
    \ |>\n<| a |>\n<code>\nimport java.util.*;\npublic class RemoveDup{\n    public\
    \ static void main(String []args){\n        removeDuplicates(new int[]{12,4,5,5,6,8,5,7,9,10,11,13});\n\
    \    }\n    public static void removeDuplicates(int[] arr){\n        Set<Integer>\
    \ set = new Linked", "{\n  int iMax = numbers.length - 1;\n  int iLast = iMax;",
  "{\n    long[] result = new long[numbers.length];\n    std.sort(numbers);\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        bool found = false;\n      \
    \  for(int j = 0; j < result.length; j++)\n        {\n            if(result[j]\
    \ == numbers[i])\n            {\n                found = true;\n             \
    \   break;\n            }\n        }\n        if(!found)\n        {\n        \
    \    result[result.length] = numbers[i];\n        }\n    }\n    return result;\n\
    }", "{\n    if(numbers.length==0)\n        return numbers;\n    \n    long[] result\
    \ = new long[numbers.length];\n    \n    long curr = numbers[0];\n    for(int\
    \ i = 1; i < numbers.length; i++){\n        if(curr == numbers[i])\n         \
    \   continue;\n        \n        result[result.length-1] = curr;\n        curr\
    \ = numbers[i];\n    }\n    \n    result[result.length-1] = curr;\n    return\
    \ result;\n}\n/*\n From an array of strings, remove all elements that occur more\
    \ than once.\n    Keep order of elements left the same as in the input.\n    >>>\
    \ remove_duplicates([\"aaa\",\"bbb\",\"ccc\",\"aaa\",\"bbb\"])\n    [\"aaa\",\"\
    ccc\"]\n    \n*/\nstring[] remove_duplicates(string[] strings) \n{\n    if(strings.length==0)\n\
    \        return strings;\n    \n    string[] result = new string[strings.length];\n\
    \    \n    string curr = strings[0];\n    for(int i = 1; i < strings.length; i++){\n\
    \        if(curr == strings[i])\n            continue;\n        \n        result[result.length-1]\
    \ = curr;\n        curr = strings[i];\n    }\n    \n    result[result.length-1]\
    \ = curr;\n    return result;\n}\n/*\n From a list with integers, remove all elements\
    \ that occur more than once.\n    Keep order of elements left the same as in the\
    \ input.\n    >>> remove_duplicates([ 1, 2, 3, 2, 2, 4 ])\n    [1, 2, 3, 4]\n\
    \    \n*/", "{\n    long[] result = new long[numbers.length];", "{\n    int n\
    \ = numbers.length;\n    long[] result = new long[n];\n    for (int i = 0; i <\
    \ n; ++i) \n    {\n        // Use binary search to find index of first duplicate.\n\
    \        int j = binarySearch(0, n - 1, numbers[i]); // If no duplicates, `j`\
    \ will be `n - 1`.\n        // Remove duplicates and store in result.\n      \
    \  int k = j;\n        \n        while ((j + 1 < n) && (numbers[j] == numbers[j\
    \ + 1])) \n        {\n            ++j;\n        }\n        result[k] = numbers[j];\n\
    \    }\n    \n    return result;\n}", "{\n    if(numbers.length < 2)\n       \
    \ return numbers;\n    long first = numbers[0];\n    long[] result = new long[numbers.length-1];\n\
    \    for(int i = 1; i < numbers.length; i++)\n    {\n        long num = numbers[i];\n\
    \        if(num == first)\n        {\n            continue;\n        }\n     \
    \   else if(num < first)\n        {\n            result[i-1] = num;\n        }\n\
    \        else\n        {\n            result[result.length-1] = num;\n       \
    \ }\n        first = num;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>\nprivate List<Integer> removeDuplicates(List<Integer>\
    \ numbers)\n{\n    List<Integer> result = new ArrayList<Integer>();", "{\n   \
    \ long[] result = numbers;\n    Arrays.sort(numbers);\n    for(int i = numbers.length-1;\
    \ i > 0; i--)\n    {\n        if(numbers[i-1] == numbers[i])\n        {\n    \
    \        numbers.splice(i, 1);\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=algorithm,c++ |>\n<| a dscore=2 |>\nThis code is not written in \"\
    pure\" C++ but is written in Python (not recommended for production use).\n<code>\n\
    #!/usr/bin/python\n# Removes duplicates from list\n# O(n) solution using hashtable\n\
    def remove_duplicates(l):\n    h = {}\n    for e in l:\n        h.setdefault(e,\
    \ []).append(e)\n    return [e for e in l if e not in h[e]]\n</code>\n<|/ a tags=algorithm,c++\
    \ |>\n<| c |>\nThis is the best solution for me.\n<|/ c |>\n<| a |>\nI see two\
    \ answers posted. \nThe first one is good and simple, just one line.\n<code>\n\
    #include <iostream>\n#include <vector>\nusing namespace std;", "{\n  int i;\n\
    \  long count = 0;\n  long[] copy = new long[numbers.length];\n  for (i = 0; i\
    \ < numbers.length; ++i) \n  {\n    long value = numbers[i];\n    if (count <\
    \ value) \n    {\n      copy[count] = value;\n      count++;\n    }\n  }\n  return\
    \ copy;\n}", "{\n  int numElements = numbers.length;\n  long[] result = new long[numElements];\n\
    \  long lastNumber = numbers[0];\n  for (int i = 1; i < numElements; i++) {\n\
    \    if (numbers[i] != lastNumber) {\n      result[i - 1] = lastNumber;\n    }\n\
    \    lastNumber = numbers[i];\n  }\n  return result;\n}", "{\n    // Write your\
    \ code here\n    var counts = new int[numbers.length];\n    for(var i=0;i<numbers.length;++i)\n\
    \        counts[numbers[i]]++;\n    var result = new long[counts.length];\n  \
    \  for(int i=0;i<result.length;++i)\n    {\n        if(counts[i] <= 1)\n     \
    \       result[i] = numbers[i];\n        else\n            result[i] = numbers[i]\
    \ - 1;\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| a tags=sorting,java,arrays\
    \ dscore=0 |>\nYou can do that in linear time. \nYou have to traverse the array\
    \ once. and keep track of the numbers that have been repeated earlier. \nTo keep\
    \ track of repeated numbers, you can use a HashMap to store numbers as keys and\
    \ the time when they were repeated as value.\nThe time can be updated every time\
    \ you find a number that has been repeated earlier\n<code>\n  public static void\
    \ main(String[] args) {\n    int[] array = {7, 7, 1, 7, 1, 7, 7, 1, 7, 1};\n \
    \   HashMap<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i <\
    \ array.length; ++i) {\n      if (map.containsKey(array[i])) {\n        map.put(array[i],\
    \ map.get(array[i]) + 1);\n      } else {\n        map.put(array[i], 1);\n   \
    \   }\n    }\n    int[] result = new int[map.size()];\n    for (int i = 0; i <\
    \ array.length; ++i) {\n      if (map.containsKey(array[i])) {\n        result[i]\
    \ = array[i] - map.get(array[i]);\n      } else {\n        result[i] = array[i];\n\
    \      }\n    }\n  }\n</code>\n<|/ a |>\n<| a tags=sorting,java,arrays dscore=0\
    \ |>\nMy approach for this problem is create a Map that maps each item to how\
    \ many times the item appear in the array. Then, you can loop through the array\
    \ and subtract the amount that appears in map from each item. Finally, you can\
    \ return the new array.\n<code>", "{\n\tlong[] newNumbers = new long[numbers.length];",
  "{\n\tlong[] new_numbers = new long[numbers.length];\n\tfor (int i = 0; i <  new_numbers.length;\
    \ i++)\n\t{\n\t\tlong val = numbers[i];\n\t\tfor (int j = i+1; j < new_numbers.length;\
    \ j++)\n\t\t\tif (val == new_numbers[j])\n\t\t\t{\n\t\t\t\tnew_numbers[j] = numbers[j];\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn new_numbers;\n}\n/*\n This function takes\
    \ in an array of floats and returns a new array with the average\n of the float\
    \ values in the array.\n \n >>> avg([1.0,2.0,3.0,3.0])\n 2.0\n \n*/\ndouble avg(float[]\
    \ numbers) \n{\n\tdouble sum = 0;\n\tfor (int i =0; i < numbers.length; i++)\n\
    \t{\n\t\tsum = sum + numbers[i];\n\t}\n\treturn sum / numbers.length;\n}\n/*\n\
    \ This function takes in an array of floats and returns a new array with the median\n\
    \ of the float values in the array.\n \n >>> median([1.0,2.0,3.0,3.0])\n 3.0\n\
    \ \n*/\nfloat median(float[] numbers) \n{\n\tlong middle = numbers.length / 2;\n\
    \t\n\tif (numbers.length % 2 == 0)\n\t{\n\t\treturn (numbers[middle - 1] + numbers[middle])\
    \ / 2;\n\t}\n\telse\n\t{\n\t\treturn numbers[middle];\n\t}\n}\n/*\n This function\
    \ takes in an array of integers and returns a new array with the mode\n of the\
    \ integer values in the array.\n \n >>> mode([1,3,3,5,7,7])\n [3, 5]\n \n*/",
  "{\n    int num = 0;\n    int i = 0;\n    long current;\n    \n    // keep track\
    \ of the number of occurrences of each number\n    HashSet<long> occurrences =\
    \ new HashSet<long>();\n    \n    while(i < numbers.length)\n    {\n        if(occurrences.contains(numbers[i]))\n\
    \        {\n            occurrences.remove(numbers[i]);\n        }\n        else\n\
    \        {\n            occurrences.add(numbers[i]);\n            numbers[i] =\
    \ num++;\n            i++;\n        }\n    }\n    \n    long[] result = new long[numbers.length];\n\
    \    \n    // fill in the remaining numbers\n    int j = 0;\n    for(long i :\
    \ occurrences)\n    {\n        result[j] = i;\n        j++;\n    }\n    \n   \
    \ return result;\n}\n/*\n From an array of integers, remove all elements that\
    \ occur more than once.\n    Keep order of elements left the same as in the input.\n\
    \    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/",
  "{\n  \n    // Create array to hold our results\n    long[] newArray = new long[numbers.length];\n\
    \    \n    // Create an array to hold the number of each element in the list\n\
    \    int[] count = new int[numbers.Length];\n    \n    // Start by populating\
    \ the array\n    for (int i = 0; i < numbers.Length; i++) {\n        count[numbers[i]]++;\n\
    \        newArray[i] = numbers[i];\n    }\n    \n    // Now go through the array\
    \ again and remove any duplicates\n    for (int i = 0; i < numbers.Length; i++)\
    \ {\n        // If the count of this number in the list is greater than 1, \n\
    \        // remove it\n        if (count[numbers[i]]>1) \n            count[numbers[i]]--;\n\
    \    }\n    \n    // Now go through the array again and populate it with the results\n\
    \    for (int i = 0; i < numbers.Length; i++) {\n        newArray[count[numbers[i]]]\
    \ = numbers[i];\n    }\n    \n    return newArray;\n}\n/* \n From an array of\
    \ floats, remove all elements that occur more than once.\n    Keep order of elements\
    \ left the same as in the input.\n    >>> remove_duplicates([1.1, 2.1, 3.1, 2.1,\
    \ 4.1])\n    [1.1, 3.1, 4.1]\n    \n*/\ndouble[] remove_duplicates(double[] numbers)\
    \ \n{\n  \n    // Create array to hold our results\n    double[] newArray = new\
    \ double[numbers.length];\n    \n    // Create an array to hold the number of\
    \ each element in the list\n    int[] count = new int[numbers.Length];\n    \n\
    \    // Start by populating the array\n    for (int i = 0; i < numbers.Length;\
    \ i++) {\n        count[numbers[i]]++;\n        newArray[i] = numbers[i];\n  \
    \  }\n    \n    // Now go through the array again and remove any duplicates\n\
    \    for (int i = 0; i < numbers.Length; i++) {\n        // If the count of this\
    \ number in the list is greater than 1, \n        // remove it\n        if (count[numbers[i]]>1)\
    \ \n            count[numbers[i]]--;\n    }\n    \n    // Now go through the array\
    \ again and populate it with the results\n    for (int i = 0; i < numbers.Length;\
    \ i++) {\n        newArray[count[numbers[i]]] = numbers[i];\n    }\n    \n   \
    \ return newArray;\n}\n/* \n From an array of doubles, remove all elements that\
    \ occur more than once.\n    Keep order of elements left the same as in the input.\n\
    \    >>> remove_duplicates([1.1, 2.1, 3.1, 2.1, 4.1])\n    [1.1, 3.1, 4.1]\n \
    \   \n*/\nfloat[] remove_duplicates(float[] numbers) \n{\n  \n    // Create array\
    \ to hold our results\n    float[] newArray = new float[numbers.length];\n   \
    \ \n    // Create an array to hold the number of each element in the list\n  \
    \  ", "{\n  int[] count = new int[numbers.length];\n  for (int i=0; i<numbers.length;\
    \ i++)\n    count[numbers[i]]++;\n  long[] result = new long[numbers.length];\n\
    \  for (int i=0; i<numbers.length; i++)\n  {\n    if (count[numbers[i]]==1)\n\
    \      result[i] = numbers[i];\n    else \n      count[numbers[i]]--;\n  }\n \
    \ return result;\n}\n</code>\n<|/ a |>\n<| c |>\nWhat is `remove_duplicates`?\n\
    <|/ c |>\n<| c |>\nIt's a function that does exactly what remove_duplicates does;\
    \ it removes duplicates from a long list.\n<|/ c |>\n<| c |>\nSorry, I'm a bit\
    \ confused: how does it remove duplicates? The final result does not seem to match\
    \ the input. Should it be `return new long[numbers.length];` instead?\n<|/ c |>\n\
    <| c |>\nThe OP asked for **the most efficient way of removing duplicates from\
    \ a long list**. You have no idea how large a long list this is. My answer gives\
    \ the most efficient way for a list of size n. In that context, `remove_duplicates`\
    \ is just a `long[] result = new long[n];`\n<|/ c |>\n<| c |>\nI see. But how\
    \ does this approach work when we want to remove more than just duplicate integers?\
    \ For example: remove_duplicates([123, 456, 123]). Would you just add another\
    \ for-loop? It seems redundant.\n<|/ c |>\n<| a tags=algorithm |>\n<code>\npublic\
    \ int maxNoOfRepetition(long arr[]){\n    long maxRepetition = 0;\n    int maxNoOfRepetition\
    \ = 0;\n    long temp = 0;\n    boolean flag = true;\n    \n    for(int i : arr)\
    \ {\n        if(temp.equals(i)) {\n            flag = false;\n        } else {\n\
    \            flag = true;\n        }\n        if(flag == true) {\n           \
    \ temp = i;\n            if(maxRepetition < i - 1) {\n                maxRepetition\
    \ = i - 1;\n                maxNoOfRepetition = 1;\n            }\n        } else\
    \ {\n            if(maxRepetition > i - 1) {\n                maxRepetition =\
    \ i - 1;\n                maxNoOfRepetition++;\n            }\n        }\n   \
    \ }\n    \n    return maxNoOfRepetition;\n}\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\n`if(temp.equals(i))` will never be true. That's why it's always true.\n\
    <|/ c |>\n<| c |>\nCan you explain what you are ", "{\n    long[] result = new\
    \ long[numbers.length];\n    int i = 0;\n    while (i < numbers.length) \n   \
    \ {\n        long n = numbers[i];\n        while (i < numbers.length && numbers[i]\
    \ == n) \n        {\n            result[i] = numbers[i++];\n        }\n      \
    \  if (i == numbers.length) \n        {\n            result[i] = n;\n        }\n\
    \    }\n    return result;\n}", "{\n\tint n = numbers.length;\n\tlong[] result\
    \ = new long[n];\n\tlong[] used = new long[n];\n\tfor (int i = 0; i < n; i++)\n\
    \t\tused[i] = 0;", "{\n    int count = 0;\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        long number = numbers[i];\n\
    \        while (i < numbers.length && numbers[i] == number) {\n            result[count++]\
    \ = number;\n            i++;\n        }\n    }\n    return result;\n}\n/*\n From\
    \ an array of integers, remove all elements that occur more than once.\n    Keep\
    \ order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/", "{\n\tlong[] nums = numbers;\n\
    \    long[] result = new long[nums.length];\n    for (int i = 0; i < nums.length;\
    \ i++)\n    {\n        for (int j = i + 1; j < nums.length; j++)\n        {\n\
    \            if (nums[i] == nums[j])\n            {\n                result.push(nums[i]);\n\
    \                nums.remove(j);\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n  long[] noDupes = numbers;\n  int dupeCount = 0;\n  for (int\
    \ i = 0; i < noDupes.length; ++i) {\n    int count = 0;\n    for (int j = 0; j\
    \ < noDupes.length; ++j) {\n      if (i != j && noDupes[i] == noDupes[j]) {\n\
    \        count++;\n      }\n    }\n    if (count > 1) {\n      noDupes[dupeCount++]\
    \ = noDupes[i];\n    }\n  }\n  return noDupes;\n}\n</code>\nThe array is passed\
    \ by reference, so the original array is not modified.\nIf efficiency matters,\
    \ it would be possible to replace that inner loop with a set or hash table, but\
    \ that would not be a significant improvement.\n<|/ a dscore=2 |>\n<| c |>\nI'm\
    \ sorry, I should have specified that I needed to retain the order of the integers.\
    \ Please see the updated question.\n<|/ c |>\n<| c |>\n: If you need to maintain\
    \ the order of the elements, use a `SortedList`, not a `List`.\n<|/ c |>\n<| c\
    \ |>\nA `Set` will remove any duplicates within the input - if that's what the\
    \ OP wants, this is probably the better solution.\n<|/ c |>\n<| c |>\n: My solution\
    \ is based on the assumption that the duplicates must be kept, but yes, a `Set`\
    \ might be a better solution if the duplicates must be removed.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nYour example array contains two pairs of duplicates, so it's\
    \ not a good fit.\n<|/ a tags=c#,list,arrays |>\n<| c |>\nI made a mistake in\
    \ the example. I will edit the question.\n<|/ c |>\n<| a tags=c#,list,arrays |>\n\
    If you know the size of the array, you can use LINQ:\n<code>\npublic static int[]\
    \ remove_duplicates(int[] numbers) {\n  return numbers.GroupBy(n => n).SelectMany(g\
    \ => g.Skip(g.Count() - 1)).ToArray();\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    I believe this will preserve the original order of the elements - is that what\
    \ you want?\n<|/ c |>\n<| c |>\nNo, this will remove all duplicates, not just\
    \ the first.\n<|/ c |>\n<| a dscore=1 |>\nYou could use LINQ:\n<code>", "{\n \
    \ int n = numbers.length;\n  if (n < 1)\n    return null;", "{\n    int i, j,\
    \ k;\n    long[] result;\n    result = new long[numbers.length];\n    j = 0;\n\
    \    k = 0;\n    \n    for (i = 0; i < numbers.length; i++)\n    {\n        while\
    \ (j < numbers.length && numbers[j] == numbers[i])\n        {\n            j++;\n\
    \        }\n        \n        if (j != k)\n        {\n            result[k] =\
    \ numbers[j];\n            k++;\n        }\n    }\n    \n    return result;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis doesn't produce the correct results for input\
    \ [1L,3L,3L]. Try with [1L,3L,3L,4L]. The output should be [1L,3L,4L] but the\
    \ method outputs [1,3,3].\n<|/ c |>\n<| a dscore=3 tags=c#,arrays |>\nI realize\
    \ that this is an old thread, but for anyone finding this later, here is a LINQ\
    \ solution:\n<code>", "{\n    long[] result = new long[numbers.length];\n    long\
    \ unique = 1;\n    for(int i = 0; i < numbers.length; i++) \n    {\n        if(numbers[i]\
    \ < unique)\n        {\n            unique = numbers[i];\n        }\n    }\n \
    \   int idx = -1;\n    for(int i = 0; i < numbers.length; i++)\n    {\n      \
    \  if(numbers[i] == unique)\n        {\n            if(idx < 0)\n            {\n\
    \                idx = i;\n            }\n        }\n        else\n        {\n\
    \            result[idx] = numbers[i];\n            idx--;\n        }\n    }\n\
    \    return std.array.create(result, idx);\n}\n/*\n    From an array of integers,\
    \ remove all elements that occur more than once.\n    Keep order of elements left\
    \ the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 4])\n    [1,\
    \ 2, 3, 4]\n    \n*/\ndouble[] remove_duplicates(double[] numbers) \n{\n    double[]\
    \ result = new double[numbers.length];\n    double unique = 1;\n    for(int i\
    \ = 0; i < numbers.length; i++) \n    {\n        if(numbers[i] < unique)\n   \
    \     {\n            unique = numbers[i];\n        }\n    }\n    int idx = -1;\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] ==\
    \ unique)\n        {\n            if(idx < 0)\n            {\n               \
    \ idx = i;\n            }\n        }\n        else\n        {\n            result[idx]\
    \ = numbers[i];\n            idx--;\n        }\n    }\n    return std.array.create(result,\
    \ idx);\n}\n/*\n    From an array of integers, remove all elements that occur\
    \ more than once.\n    Keep order of elements left the same as in the input.\n\
    \    >>> remove_duplicates([1, 2, 3, 4, 1])\n    [1, 2, 3, 4]\n    \n*/\nlong[]\
    \ remove_duplicates(bool[] numbers)\n{\n    long[] result = new long[numbers.length];\n\
    \    long unique = 1;\n    for(int i = 0; i < numbers.length; i++) \n    {\n \
    \       if(numbers[i] < unique)\n        {\n            unique = numbers[i];\n\
    \        }\n    }\n    int idx = -1;\n    for(int i = 0; i < numbers.length; i++)\n\
    \    {\n        if(numbers[i] == unique)\n        {\n            if(idx < 0)\n\
    \            {\n                idx = i;\n            }\n        }\n        else\n\
    \        {\n            result[idx] = numbers[i];\n            idx--;\n      \
    \  }\n    }\n    return std.array.create(result, idx);\n}", "{\n    HashSet<long>\
    \ set = new HashSet<long>();\n    for(int i = 0; i < numbers.length; i++){\n \
    \       set.add((long)numbers[i]);\n    }\n    return set.stream().mapToLong(a\
    \ -> a).toArray();\n}", "{\n  if (numbers.length == 0)\n    return numbers;\n\
    \  long[] dups = new long[numbers.length];\n  int i;\n  dups[0] = numbers[0];\n\
    \  for (i = 1; i < numbers.length; i++) {\n    if (numbers[i] != numbers[i - 1])\
    \ {\n      dups[i] = numbers[i];\n    }\n  }\n  return dups;\n}", "{\n    long\
    \ currentVal, lastVal, tempVal;\n    int i;\n    \n    long newNumbers[numbers.length];",
  "{\n  long result = numbers.clone();\n  for(int i = 0; i < numbers.size(); i++)\
    \ {\n    int count = 0;\n    for(int j = 0; j < numbers.size(); j++) {\n     \
    \ if(numbers[j] == numbers[i]) {\n        count++;\n      }\n    }\n    if(count\
    \ > 1) {\n      for(int k = 0; k < numbers.size(); k++) {\n        if(numbers[k]\
    \ == numbers[i]) {\n          numbers.removeAt(i);\n          break;\n       \
    \ }\n      }\n    }\n  }\n  return result;\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a |>\n<code>\npublic int removeDuplicates(int[] arr) {\n    HashSet<Integer>\
    \ hs = new HashSet<>();\n    for(int i = 0; i < arr.length; i++){\n        if(!hs.contains(arr[i])){\n\
    \            hs.add(arr[i]);\n        }\n    }\n    return hs.size();\n}\n</code>\n\
    <|/ a tags=arrays,java dscore=1 |>\n<| c |>\nWelcome to Stack Overflow! Please\
    \ don't answer just with source code. Try to provide a nice description about\
    \ how your solution works. See: [How do I write a good answer?](https://stackoverflow.com/help/how-to-answer).\
    \ Thanks\n<|/ c |>\n<| a |>\n<code>\nimport java.util.ArrayList;\nimport java.util.HashSet;\n\
    import java.util.List;\npublic class RemoveDuplicates {", "{\n    if(numbers.length\
    \ < 2)\n        return numbers;\n    long last_val = numbers[0];\n    long[] results\
    \ = new long[numbers.length-1];\n    for(int i = 0; i < numbers.length; i++){\n\
    \        long val = numbers[i];\n        if(val != last_val)\n            results[results.length-1]\
    \ = last_val;\n        results[results.length-1] = val;\n        last_val = val;\n\
    \    }\n    return results;\n}\n</code>\n<|/ a |>\n<| c |>\nIt would be better\
    \ to use a LinkedList.  That way you're not duplicating the last number after\
    \ you remove the first duplicate.\n<|/ c |>\n<| c |>\n: I didn't think of that.\n\
    <|/ c |>\n<| c |>\n: And that's why I added the comment. :)\n<|/ c |>\n<| a dscore=2\
    \ |>\nThis is pretty much the algorithm I would go with.\n<code>\npublic static\
    \ int[] removeDups(int[] input) {\n    if (input == null || input.length <= 1)\
    \ {\n        return input;\n    }", "{\n    long[] result = new long[numbers.length];\n\
    \    for(int i=0; i<numbers.length; i++)\n    {\n        for(int j=i+1; j<numbers.length;\
    \ j++)\n        {\n            if(numbers[i] == numbers[j])\n            {\n \
    \               result.splice(i, 1);\n                result.splice(j, 1);\n \
    \               break;\n            }\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe OP is asking for a way to remove duplicates,\
    \ so your answer would be correct. However, this doesn't do what the OP is asking\
    \ for. If you have `[1L, 2L, 3L, 3L, 3L, 3L, 3L]`, your code will output `[1L,\
    \ 2L, 3L]`\n<|/ c |>\n<| a dscore=1 tags=filter,c#,linq,duplicates |>\nI wanted\
    \ to do something similar, and I used a linq query. \n<code>\nmyList.Where(o =>\
    \ myList.Count(a => a == o) > 1)\n</code>\n<|/ a |>\n<| a |>\nYou want Distinct:\n\
    <code>\nList<int> myList = new List<int>() { 1L, 2L, 3L, 3L, 3L, 3L, 3L };\nvar\
    \ distinct = myList.Distinct();\n</code>\nThe distinct list is then [1L, 2L, 3L,\
    \ 3L, 3L, 3L]\n<|/ a dscore=0 tags=filter,c#,linq,duplicates |>\n<| a tags=filter,c#,linq,duplicates\
    \ dscore=0 |>\nIf performance isn't a problem, this will be a lot easier to do\
    \ using HashSet:\n<code>\nvar result = new HashSet<int>();\nforeach (int item\
    \ in myList)\n{\n    if (result.Contains(item))\n        continue;", "{\n    if(numbers.length\
    \ < 2)\n        return numbers;\n    long last = 0;\n    for(int i = 0; i < numbers.length;\
    \ i++) \n    {\n        long current = numbers[i];\n        if(current != last)\n\
    \        {\n            last = current;\n            numbers[i] = last;\n    \
    \    }\n    }\n    return numbers;\n}\n/*\n From an array of integers, remove\
    \ all elements that occur more than once.\n    Keep order of elements left the\
    \ same as in the input.\n    From a vector of integers, remove all elements that\
    \ occur more than once.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L], [1L,\
    \ 3L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates(long[] numbers,\
    \ long[] vector) \n{\n    if(numbers.length < 2)\n        return vector;\n   \
    \ long last = 0;\n    for(int i = 0; i < numbers.length; i++) \n    {\n      \
    \  long current = numbers[i];\n        if(current != last)\n        {\n      \
    \      last = current;\n            numbers[i] = last;\n        }\n    }\n   \
    \ return numbers;\n}\n/*\n From an array of integers, remove all elements that\
    \ occur more than once.\n    Keep order of elements left the same as in the input.\n\
    \    From a vector of integers, remove all elements that occur more than once.\n\
    \    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L], [1L, 3L, 4L])\n    [1L, 3L, 4L]\n\
    \    \n*/\nlong[] remove_duplicates(long[] numbers, longVector[] vector) \n{\n\
    \    if(numbers.length < 2)\n        return vector;\n    long last = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++) \n    {\n        long current = numbers[i];\n\
    \        if(current != last)\n        {\n            last = current;\n       \
    \     numbers[i] = last;\n        }\n    }\n    return numbers;\n}\n/*\n From\
    \ an array of doubles, remove all elements that occur more than once.\n    Keep\
    \ order of elements left the same as in the input.\n    >>> remove_duplicates([3.14,\
    \ 4.14, 3.14, 3.14, 4.14])\n    [3.14, 4.14]\n    \n*/\ndouble[] remove_duplicates(double[]\
    \ numbers) \n{\n    if(numbers.length < 2)\n        return numbers;\n    double\
    \ last = 0.0;\n    for(int i = 0; i < numbers.length; i++) \n    {\n        double\
    \ current = numbers[i];\n        if(current != last)\n        {\n            last\
    \ = current;\n            numbers[i] = last;\n        }\n    }\n    return numbers;\n\
    }\n/*\n From an array of doubles, remove all elements that occur more than once.\n\
    \    ", "{\n\tlong unique = 0;\n\tlong[] result = new long[numbers.length];\n\t\
    for (int i = 0; i < numbers.length; i++)\n\t{\n\t\tfor (int j = 0; j < i; j++)\n\
    \t\t{\n\t\t\tif (numbers[i] == numbers[j])\n\t\t\t{\n\t\t\t\tnumbers[j] = numbers[i];\n\
    \t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < numbers.length; k++)\n\t\t{\n\t\t\tif\
    \ (numbers[i] == numbers[k])\n\t\t\t{\n\t\t\t\tnumbers[k] = numbers[i] + unique;\n\
    \t\t\t\tresult[i] = numbers[k];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tunique++;\n\
    \t}\n\treturn result;\n}\n/*\n From an array of integers, remove all elements\
    \ that occur more than once.\n    Keep order of elements left the same as in the\
    \ input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n\
    \    \n*/\nlong[] remove_duplicates(long[] numbers, bool asc) \n{\n\tlong unique\
    \ = 0;\n\tlong[] result = new long[numbers.length];\n\tfor (int i = 0; i < numbers.length;\
    \ i++)\n\t{\n\t\tfor (int j = 0; j < i; j++)\n\t\t{\n\t\t\tif (numbers[i] == numbers[j])\n\
    \t\t\t{\n\t\t\t\tnumbers[j] = numbers[i];\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0;\
    \ k < numbers.length; k++)\n\t\t{\n\t\t\tif (numbers[i] == numbers[k])\n\t\t\t\
    {\n\t\t\t\tnumbers[k] = numbers[i] + unique;\n\t\t\t\tresult[i] = numbers[k];\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tunique++;\n\t}\n\tif (asc) return result;\n\
    \treturn reverse_mergesort(numbers, asc);\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n\
    \    }\n    for (int i = 0; i < numbers.length; i++) {\n        for (int j = i\
    \ + 1; j < numbers.length; j++) {\n            if (numbers[i] == numbers[j]) {\n\
    \                result[j] = numbers[j];\n                for (int k = i; k <\
    \ j; k++) {\n                    numbers[k] = numbers[k + 1];\n              \
    \  }\n            }\n        }\n    }\n    return result;\n}", "{\n    int i,\
    \ j, k = 0;\n    long[] result = new long[numbers.length];\n    \n    for (i =\
    \ 0; i < numbers.length; i++ ) {\n        for (j = k; j < i; j++ ) {\n       \
    \     if (numbers[i] == numbers[j]) {\n                // this number is found\
    \ a second time\n                result[k++] = numbers[i];\n                break;\n\
    \            }\n        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThis is very helpful. Thank you.\n<|/ c |>\n<| c |>\nThis is a\
    \ great solution. It also works with arrays of strings. I was using it in a method\
    \ I called \"removeDuplicates\" that removes all duplicates from a list. The other\
    \ solution didnt work properly with the string array, which was the issue I was\
    \ having. Thanks again!\n<|/ c |>\n<| a |>\nI came up with a similar solution\
    \ using a hashmap, with slightly different logic, that might be useful sometimes.\n\
    <code>\npublic int[] removeDuplicates(int[] arr) {\n        Map<Integer, Integer>\
    \ map = new HashMap<>();\n        for(int i=0;i<arr.length;i++) {\n          \
    \  int currentValue = arr[i];\n            if(map.containsKey(currentValue)) {\n\
    \                map.put(currentValue, map.get(currentValue)+1);\n           \
    \ } else {\n                map.put(currentValue, 1);\n            }\n       \
    \ }", "{\n\tlong[] result = new long[numbers.length];\n\tint index = 0;\n\t\n\t\
    for(int i = 0; i < numbers.length; i++) {\n\t\tif(numbers[i] != numbers[index])\
    \ {\n\t\t\tresult[index] = numbers[i];\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\treturn\
    \ result;\n}", "{\n    var sorted: long[] = numbers.clone();\n    sorted.sort();\n\
    \    var result: long[] = [];\n    \n    for (var i = 0, last = sorted.length\
    \ - 1; i < last; ++i) \n    {\n        var value = sorted[i];\n        if (result.indexOf(value)\
    \ != -1) \n        {\n            sorted.splice(i, 1);\n            --i;\n   \
    \         --last;\n        }\n        else\n        {\n            result.push(value);\n\
    \        }\n    }\n    \n    return result;\n}\n</textarea>\n                \
    \    </div>\n                    <div class=\"modal-footer\">\n              \
    \          <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\"\
    >Close</button>\n                    </div>\n                </div>\n        \
    \    </div>\n        </div>\n    </div>\n    \n    \n    <!--*****************************************************************************************-->\n\
    \    <!--**********                  Search Results Modal View               \
    \      *******************************-->\n    <!--*****************************************************************************************-->\n\
    \    <div class=\"modal fade\" id=\"searchResults\" tabindex=\"-1\" role=\"dialog\"\
    \ aria-labelledby=\"myModalLabel\">\n        <div class=\"modal-dialog\" role=\"\
    document\">\n            <div class=\"modal-content\">\n                <div class=\"\
    modal-header\">\n                    <button type=\"button\" class=\"close\" data-dismiss=\"\
    modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>\n\
    \                    <h4 class=\"modal-title\" id=\"myModalLabel\">Search Results</h4>\n\
    \                </div>\n                <div class=\"modal-body\">\n        \
    \            <ul class=\"list-group\">\n                        <li class=\"list-group-item\
    \ active\">\n                            <div class=\"row\">\n               \
    \                 <div class=\"col-md-3\">\n                                 \
    \   <img class=\"thumbnail\" src=\"img/search_result.jpg\" />\n              \
    \                  </div>\n                                <div class=\"col-md-9\"\
    >\n                                    <h4><a href=\"http://www.codewars.com/users/jfarrars/\"\
    \ target=\"_blank\">Jonathan Frarrar</a></h4>\n                              \
    \      <small><span class=\"label label-success\">Achievement</span></small>\n\
    \                                    <p>He is a true master. He can do anything\
    \ he wants without fail and still be very smart.</p>\n                       \
    \             <ul class=\"list-inline\">\n                                   \
    \     <li>\n                                            <h2><a href=\"#\">Followers:</a></h2>\n\
    \                                            <small>0</small>\n              \
    \                          </li>\n                                        <li>\n\
    \                                            <h2><a href=\"#\">Following:</a></h2>\n\
    \                                            <small>0</small>\n              \
    \                          </li>\n                                    </ul>\n\
    \                                    <p>\n                                   \
    \     <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\"\
    >Close</button>\n                                    </p>\n                  \
    \              </div>\n                            </div>\n                  \
    \      </li>\n                    </ul>\n                </div>\n            </div>\n\
    \        </div>\n    </div>\n    \n    \n    <!--*****************************************************************************************-->\n\
    \    <!--**********                New Review Modal View                     *******************************-->\n\
    \    <!--*****************************************************************************************-->\n\
    \    <div class=\"modal fade\" id=\"newReview\" tabindex=\"-1\" role=\"dialog\"\
    \ aria-labelledby=\"myModalLabel\">\n        <div class=\"modal-dialog\" role=\"\
    document\">\n            <div class=\"modal-content\">\n                <div class=\"\
    modal-header\">\n                    <button type=\"button\" class=\"close\" data-",
  "{\n  long[] nums = new long[numbers.length];\n  int numCount = 0;\n  foreach(int\
    \ i : numbers) {\n    if(nums[numCount] == i) {\n      numCount++;\n    } else\
    \ {\n      nums[numCount] = i;\n      numCount++;\n    }\n  }\n  return nums;\n\
    }", "{\n    int n = numbers.length;\n    long[] numbers_copy = new long[n];\n\
    \    for (int i = 0; i < n; i++) {\n        int count = 0;\n        for (int j\
    \ = i; j < n; j++) {\n            if (numbers[j] == numbers[i]) {\n          \
    \      count++;\n            }\n        }\n        if (count > 1) {\n        \
    \    numbers_copy[i] = numbers[i];\n        }\n    }\n    return numbers_copy;\n\
    }", "{\n    long firstNumber = numbers[0];\n    int i = 1;\n    \n    while(i\
    \ < numbers.length)\n    {\n        long currentNumber = numbers[i];\n       \
    \ \n        if(currentNumber == firstNumber)\n        {\n            i++;\n  \
    \          continue;\n        }\n        \n        numbers[i] = firstNumber;\n\
    \        firstNumber = currentNumber;\n        i++;\n    }\n    \n    return numbers;\n\
    }\n/*\n From an array, remove all elements that occur more than once.\n    Keep\
    \ order of elements left the same as in the input.\n    \n    NOTE: This code\
    \ is faster than remove_duplicates, even though remove_duplicates\n    is faster\
    \ on small arrays and remove_duplicates was faster on large arrays.\n    \n  \
    \  On a 32 bit machine, remove_duplicates took about 2.5 seconds to execute on\
    \ an array of\n    32 integers. On a 64 bit machine, remove_duplicates took about\
    \ 1.6 seconds to execute on an\n    array of 64 integers. remove_duplicates was\
    \ only faster by a factor of about 43.\n*/\nlong[] remove_duplicates_fast(long[]\
    \ numbers)\n{\n    long firstNumber = numbers[0];\n    int i = 1;\n    \n    while(i\
    \ < numbers.length)\n    {\n        long currentNumber = numbers[i];\n       \
    \ \n        if(currentNumber == firstNumber)\n        {\n            i++;\n  \
    \          continue;\n        }\n        \n        numbers[i] = firstNumber;\n\
    \        firstNumber = currentNumber;\n        i++;\n    }\n    \n    return numbers;\n\
    }", "{\n  int i = 0;\n  long[] seen = new long[numbers.length];\n  \n  foreach(i;\
    \ i; i--) \n  {\n    if(numbers[i] > 0) \n    {\n      seen[numbers[i] - 1] =\
    \ numbers[i];\n    }\n  }\n  \n  return seen;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I like this approach but I'd add two things. First, I'd remove the dependency\
    \ on any external packages such as `std`.  Second, I'd change the return type\
    \ to `HashSet` rather than `long[]`.\n<|/ c |>\n<| a |>\nThis should be O(N^2)\
    \ where N is the size of the input. The idea is to take each element of the input,\
    \ compare it to the rest of them (except the one we're looking at), and store\
    \ any values that are the same in an array. Then return the first N elements in\
    \ that array.\n<code>\npublic static long[] removeDuplicates(long[] numbers) {\n\
    \    long[] temp = new long[numbers.length];\n    long[] result = new long[numbers.length];",
  "{\n    long count = 0;\n    for (int i = 0; i < numbers.length; i++)\n    {\n \
    \       if (numbers[i] == numbers[count]) count++;\n        else numbers[i] =\
    \ numbers[count];\n    }\n    numbers[numbers.length - 1] = count;\n    return\
    \ numbers;\n}\n</code>\n<|/ a tags=java |>\n<| a |>\nHere is the code i think\
    \ will work:\n<code>\npackage com.sample;", "{\n  int i, j;\n  long[] result =\
    \ new long[numbers.length];\n  \n  for (i=0; i < numbers.length; i+=1) \n  {\n\
    \    long current = numbers[i];\n    for (j=i+1; j < numbers.length; j++) \n \
    \   {\n      if (current == numbers[j]) \n      {\n        break;\n      }\n \
    \     else\n      {\n        result[j] = current;\n      }\n    }\n  }\n  return\
    \ result;\n}", "{\n    long result = numbers[0];\n    long[] result = numbers;\n\
    \    int i;\n    for(i = 0; i < numbers.length; i++){\n        if((numbers[i]\
    \ != numbers[i+1])){\n            result = std.array.concat(result, numbers[i]);\n\
    \        }\n    }\n    return result;\n}\n/*\n From an array of integers, remove\
    \ all elements that occur more than once.\n    Keep order of elements left the\
    \ same as in the input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n   \
    \ [1L, 3L, 4L]\n    \n*/", "{\n  std.long.sort(numbers);\n  int n = numbers.length,\
    \ i, j;\n  long[] unique = new long[n];\n  int count = 0;\n  for (i = 0; i < n;\
    \ ++i) {\n    if (numbers[i] != numbers[i - 1]) {\n      unique[count++] = numbers[i];\n\
    \    }\n  }\n  unique.length = count;\n  return unique;\n}\n/*\n From an array\
    \ of floats, remove all elements that occur more than once.\n    Keep order of\
    \ elements left the same as in the input.\n    >>> remove_duplicates([2.5f, 7.5f])\n\
    \    [2.5f, 7.5f]\n    \n*/\nfloat[] remove_duplicates(float[] numbers) \n{\n\
    \  std.float.sort(numbers);\n  int n = numbers.length, i, j;\n  float[] unique\
    \ = new float[n];\n  int count = 0;\n  for (i = 0; i < n; ++i) {\n    if (numbers[i]\
    \ != numbers[i - 1]) {\n      unique[count++] = numbers[i];\n    }\n  }\n  unique.length\
    \ = count;\n  return unique;\n}\n/*\n From an array of doubles, remove all elements\
    \ that occur more than once.\n    Keep order of elements left the same as in the\
    \ input.\n    >>> remove_duplicates([1.1, 2.5, 3.3])\n    [1.1, 2.5, 3.3]\n  \
    \  \n*/\ndouble[] remove_duplicates(double[] numbers) \n{\n  std.double.sort(numbers);\n\
    \  int n = numbers.length, i, j;\n  double[] unique = new double[n];\n  int count\
    \ = 0;\n  for (i = 0; i < n; ++i) {\n    if (numbers[i] != numbers[i - 1]) {\n\
    \      unique[count++] = numbers[i];\n    }\n  }\n  unique.length = count;\n \
    \ return unique;\n}\n/*\n From an array of strings, remove all elements that occur\
    \ more than once.\n    Keep order of elements left the same as in the input.\n\
    \    >>> remove_duplicates([\"a\", \"b\", \"c\", \"b\", \"d\"])\n    [\"a\", \"\
    b\", \"c\", \"d\"]\n    \n*/\nstring remove_duplicates(string[] strings) \n{\n\
    \  std.string.sort(strings);\n  int n = strings.length, i, j;\n  string[] unique\
    \ = new string[n];\n  int count = 0;\n  for (i = 0; i < n; ++i) {\n    if (strings[i]\
    \ != strings[i - 1]) {\n      unique[count++] = strings[i];\n    }\n  }\n  unique.length\
    \ = count;\n  return unique;\n}", "{\n\tlong[] result = new long[numbers.length];\n\
    \tint j = 0;\n\t\n\tfor(int i=0; i < numbers.length; i++)\n\t{\n\t\tif(numbers[i]\
    \ != numbers[j])\n\t\t{\n\t\t\tresult[j] = numbers[i];\n\t\t\tj++;\n\t\t}\n\t\
    }\n\treturn result;\n}", "{\n    long[] newNums = new long[numbers.length];\n\
    \    int[] counters = new int[numbers.length];\n    \n    for (int i = 0; i <\
    \ numbers.length; ++i)\n    {\n        if (counters[i] == 0)\n        {\n    \
    \        counters[i] = 1;\n            newNums[i] = numbers[i];\n        }\n \
    \       else\n        {\n            if (numbers[i] != newNums[i])\n         \
    \   {\n                counters[i] = 1;\n                newNums[i] = numbers[i];\n\
    \            }\n        }\n    }\n    return newNums;\n}\n</code>\n<|/ a tags=java,arrays,algorithm\
    \ |>\n<| a dscore=0 tags=java,arrays,algorithm |>\nThis question is tagged with\
    \ java, so here is an alternative solution in Java\n<code>", "{\n    // TODO:\n\
    \    long[] result = new long[numbers.length];\n    int count = 1;\n    for (int\
    \ i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] != numbers[i\
    \ - 1]) \n        {\n            result[count++] = numbers[i];\n        }\n  \
    \  }\n    return result;\n}\n</code>\n<|/ a |>\n<| a tags=c#,.net,collections\
    \ dscore=0 |>\nYou want to use LINQ and use the Distinct function.\n<|/ a |>\n\
    <| a |>\n<code>\npublic static class ArrayExtensions\n{\n    public static T[]\
    \ RemoveDuplicates<T>(this T[] source)\n    {\n        if (source == null) throw\
    \ new ArgumentNullException(\"source\");", "{\n    long[] res = null;\n    int\
    \ index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        int\
    \ count = 0;\n        int pos = -1;\n        for(int j = 0; j < numbers.length;\
    \ j++)\n        {\n            if(numbers[j] == numbers[i])\n            {\n \
    \               count++;\n                if(pos < 0)\n                    pos\
    \ = j;\n            }\n        }\n        if(count > 1)\n        {\n         \
    \   long x = numbers[pos];\n            while(numbers[index] != x)\n         \
    \   {\n                numbers[index] = numbers[index + 1];\n                index++;\n\
    \            }\n        }\n    }\n    while(index < numbers.length)\n    {\n \
    \       numbers[index] = numbers[index + 1];\n        index++;\n    }\n    if(res\
    \ == null)\n        res = numbers;\n    else\n        Arrays.fill(res, index,\
    \ numbers.length, numbers[0]);\n    return res;\n}\n</code>\nThe above code is\
    \ not optimized at all, but it is functional. It could probably be optimized a\
    \ lot more to make it more efficient, but it is more fun to write and maintain.\n\
    <|/ a dscore=3 |>\n<| a tags=c#,linq,arrays,c#-7.0 |>\nIf you want a function\
    \ that takes an array of integers and returns a new array without duplicate integers:\n\
    <code>\npublic static int[] RemoveDuplicates(int[] list)\n{\n    var distinctList\
    \ = list.Distinct().ToArray();\n    var distinctArray = new int[distinctList.Length];\n\
    \    distinctList.CopyTo(distinctArray, 0);", "{\n  int i = 0;\n  long prev =\
    \ 0;\n  while (i < numbers.length) \n  {\n    long current = numbers[i];\n   \
    \ if (current == prev)\n    {\n      numbers[i++] = current;\n      continue;\n\
    \    }\n    prev = current;\n  }\n  return numbers;\n}", "{\n  long[] ret = new\
    \ long[numbers.length];\n  Arrays.sort(numbers);\n  int prev = 0;\n  for(int i\
    \ = 0; i < numbers.length; i++)\n  {\n    if(prev == numbers[i])\n      continue;\n\
    \    ret[numbers.length - i - 1] = numbers[i];\n    prev = numbers[i];\n  }\n\
    \  return ret;\n}\n</code>\n<|/ a tags=arrays,c#,linq,functional-programming |>\n\
    <| a tags=arrays,c#,linq,functional-programming |>\n<code>", "{\n    long[] a\
    \ = new long[numbers.length];\n    int j = 0;\n    for (int i = 0; i < numbers.length;\
    \ i++) \n    {\n        if (a[i] != numbers[i]) \n        {\n            a[j]\
    \ = numbers[i];\n            j++;\n        }\n    }\n    return a;\n}\n/*\n From\
    \ an array of integers, remove all elements that occur more than once.\n    Keep\
    \ order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/", "{\n  long[] ret = new long[numbers.length];\n\
    \  \n  for (int i = 0; i < numbers.length; i++)\n  {\n    ret[i] = numbers[i];\n\
    \    for (int j = i; j < numbers.length; j++)\n      if (numbers[j] == numbers[i])\n\
    \        ret[j]++;\n  }\n  return ret;\n}\n</code>\n<|/ a tags=c# |>\n<| c |>\n\
    This code does work, but does not answer the question, which is \"how to remove\
    \ duplicates from a `long[]`\".\n<|/ c |>\n<| c |>\nAgreed, that's why I added\
    \ the comment on the question.\n<|/ c |>\n<| c |>\nNo, you didn't, you answered\
    \ the question by providing sample code, that didn't even compile with OP's code.\n\
    <|/ c |>\n<| c |>\nThe question isn't \"How to remove duplicates\" but \"How to\
    \ detect duplicates\". I think it's still a good answer though :)\n<|/ c |>\n\
    <| c |>\nThis code does NOT solve the problem of detecting duplicates! This code\
    \ will result in a duplicate-free `int[]`, but you still don't know which element\
    \ was repeated. Thus, `RemoveDuplicates` is no help for this problem\n<|/ c |>\n\
    <| a |>\nHere's my variation of the solution proposed in the comments. Apologies\
    \ for the horrible variable names.\n<code>\npublic static bool AreDuplicates<T>(this\
    \ T[] array, Func<T, T, bool> comparer)\n{\n    var distinct = new HashSet<T>();\n\
    \    bool distinctEnded = false;\n    foreach (var item in array)\n    {\n   \
    \     if (!distinct.Contains(item) && comparer.Invoke(item, item))\n        {\n\
    \            distinct.Add(item);\n            distinctEnded = true;\n        }\n\
    \    }", "{\n    var result = new long[numbers.length];\n    var hash = new int[numbers.Length];\n\
    \    foreach(var n in numbers)\n    {\n        if(hash[n] == 0)\n        {\n \
    \           result[hash[n]] = n;\n            hash[n]++;\n        }\n    }\n \
    \   return result;\n}\n</code>\n<|/ a tags=c#,arrays dscore=1 |>\n<| c |>\nThe\
    \ algorithm is correct but the code is horrible. You should at least explain the\
    \ algorithm and code with comments. Otherwise nobody will understand what you're\
    \ doing.\n<|/ c |>\n<| c |>\nThis code does not even compile. The `hash` array\
    \ is not an array, but a list. I also don't understand why you use `Enumerable.Range`\
    \ to loop through a list. In your `foreach` loop you are using `numbers`, but\
    \ that is a `long[]`, not a `List<long>`.\n<|/ c |>\n<| c |>\nI added comments\
    \ to the code with explanation.\n<|/ c |>\n<| a dscore=1 |>\nHere are my solutions.\n\
    First one with Linq Aggregate (for me, the most simple one).\n<code>\nlong[] numbers\
    \ = new long[] { 1, 2, 2, 2, 3 };\nvar result = numbers.Aggregate<long, long>((x,\
    \ y) => x == y ? x : x);\n</code>\nSecond one with Enumerable GroupBy:\n<code>\n\
    long[] numbers = new long[] { 1, 2, 2, 2, 3 };\nvar result = numbers.GroupBy(n\
    \ => n).Select(n => n.Key).ToArray();\n</code>\n<|/ a tags=c#,arrays |>\n<| c\
    \ |>\nIn fact your first solution does not compile, since you can't put a `long`\
    \ in an `int[]` initializer. At least not with the default settings.\n<|/ c |>\n\
    <| c |>\nI agree, my bad. Fixed it. Thanks!\n<|/ c |>\n<| c |>\nWhy should I use\
    \ `Aggregate` to calculate the sum? `GroupBy` does just the same - but in a different\
    \ way.\n<|/ c |>\n<| c |>\nYes, you are right. I didn't think about it. I changed\
    \ my solution to `GroupBy` now and it's more simple than `Aggregate`. Thanks!\n\
    <|/ c |>\n<| a tags=c#,arrays dscore=0 |>\nThe answer of Michael L. is good and\
    \ works well but unfortunately the time complexity is O(n^2). The best approach\
    \ is to iterate only through the array once but to build a new array (of size\
    \ n), where you put ", "{\n  long result = long.MinValue;\n  long lastValue =\
    \ long.MinValue;\n  foreach(long num in numbers)\n  {\n    if(num != lastValue\
    \ && num != result)\n    {\n      result = num;\n      lastValue = num;\n    }\n\
    \  }\n  return new long[] {result};\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=linq,distinct,arrays\
    \ |>\nHere's a solution that takes advantage of LINQ's DistinctBy implementation:\n\
    <code>\nprivate static int[] RemoveDuplicates(int[] arr)\n{\n    return arr.DistinctBy(x\
    \ => x).ToArray();\n}\n</code>\nThis is my favorite solution. It only has to iterate\
    \ through the array once per unique element. Since DistinctBy is implemented in\
    \ terms of Distinct (at least in .NET Core) it can avoid iterating through the\
    \ collection multiple times. \nThe benefit of this method is that it does not\
    \ rely on LINQ's implementation, and doesn't need to create an anonymous type.\n\
    <|/ a dscore=2 |>\n<| a tags=linq,distinct,arrays |>\nIn case you use .Net Core,\
    \ it will be much easier, because it's already implemented and can be done in\
    \ one line.\n<code>\nvar distinct = arr.Distinct(); //remove duplicates\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThat's a very nice feature, but unfortunately it does\
    \ remove all duplicates and is not an option if you have a lot of duplicate elements.\n\
    <|/ c |>\n<| a |>\nIf you prefer a solution that uses the Aggregate method, then\
    \ this should work:\n<code>", "{\n\tint size = numbers.length;\n\tlong[] newnumbers\
    \ = new long[size];\n\tint j = 0;\n\tfor (int i=0; i<numbers.length; i++)\n\t\
    {\n\t\tif (newnumbers[j] == numbers[i])\n\t\t\tnewnumbers[j] = -1;\n\t\telse\n\
    \t\t\tnewnumbers[j] = numbers[i];\n\t\tj++;\n\t}\n\treturn newnumbers;\n}", "{\n\
    \  long[] result = new long[numbers.length];\n  int k = 0;\n  long curr = numbers[0];\n\
    \  int n = numbers.length;\n  while (k < n) {\n    long n = numbers[k];\n    if\
    \ (n == curr) {\n      ++k;\n    } else if (n > curr) {\n      result[k] = curr;\n\
    \      curr = n;\n      ++k;\n    } else {\n      ++k;\n      result[k] = n;\n\
    \    }\n  }\n  result[k] = curr;\n  return result;\n}", "{\n    int count = 0;\n\
    \    long[] result = new long[numbers.length];\n    for (int i = 0; i<numbers.length;\
    \ i++) \n    {\n        if (numbers[i] != numbers[count]) \n        {\n      \
    \      result[count] = numbers[i];\n            count++;\n        }\n    }\n \
    \   return new long[count];\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,python,java\
    \ |>\nHere is my solution in Python :\n<code>\nnums = [1,2,2,3,4,4,4,5,6]\nn =\
    \ len(nums)\nfor i in range(0,n):\n  if nums[i] != nums[i+1]:\n    nums[i] = nums[i+1]\n\
    \  else:\n    nums.pop()\n</code>\nThe idea is to compare each consecutive element\
    \ in the array and if they are equal, then remove the first one.\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 tags=algorithm,python,java |>\nPythonic solution:\n<code>\n\
    numbers = [1,2,2,3,4,4,4,5,6]", "{\n    var results = new long[numbers.length];\n\
    \    var seen = new bool[numbers.length];\n    \n    // Sort the input array by\
    \ descending number\n    Arrays.sort(numbers, (a, b) => b - a);\n    \n    for\
    \ (int i = 0; i < numbers.length; ++i) {\n        if (seen[i]) {\n           \
    \ continue;\n        }\n        seen[i] = true;\n        results[i] = numbers[i];\n\
    \    }\n    return results;\n}", "{\n  int result = 0;\n  for (int i = 0; i <\
    \ numbers.length; i++)\n    if (numbers[result] != numbers[i])\n      result =\
    \ i;\n  if (result < numbers.length) \n    throw new RuntimeException(\"remove_duplicates:\
    \ array has duplicate entries\");\n  long[] result = new long[numbers.length];\n\
    \  for (int i = 0; i < numbers.length; i++)\n    result[i] = numbers[i];\n  return\
    \ result;\n}", "{\n    long count = 0;\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i]\
    \ != count) \n        {\n            result[count] = numbers[i];\n           \
    \ count++;\n        }\n    }\n    return Arrays.copyOfRange(result, 0, count);\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI don't think this works.  I think it\
    \ will remove the duplicates, but it will also mess up the order\n<|/ c |>\n<|\
    \ c |>\nIt doesn't mess up the order because the input is not sorted.\n<|/ c |>\n\
    <| c |>\nYes, that would be a problem if the input were sorted (which it isn't).\n\
    <|/ c |>\n<| c |>\nThis works great for small arrays, but takes too much time\
    \ for large arrays (my case with about 200k numbers). I think the reason is that,\
    \ as the size of the array increases, the time taken increases as well. I was\
    \ wondering if there is a way to improve the performance without sorting the array.\n\
    <|/ c |>\n<| c |>\nAs mentioned, this works for a sorted list.  If you don't want\
    \ to sort the list, simply reverse the result.  Also, you can eliminate the `count`\
    \ variable by using `numbers[i]` instead.\n<|/ c |>\n<| a |>\nIt sounds like you're\
    \ interested in finding runs of equal numbers in a sequence.  Here's a solution\
    \ in Clojure with a bit of Java interop so it should be pretty efficient if your\
    \ sequences are large.\n<code>\n(defn runs\n  \"Returns a sequence of all runs\
    \ in the given sequence whose values\n   are the same as the first value in the\
    \ sequence.\"\n  [s rs]\n  (loop [s s rs rs nil runs []]\n    (cond\n      (empty?\
    \ s) (reverse runs)\n      (= (first s) (first rs)) (recur (rest s) (rest rs)\
    \ nil runs)\n      (= (first rs) (first s)) (cons (first s) (cons (first rs) (cons\
    \ runs nil)))\n      (= (rest s) (rest rs)) (cons (first rs) (cons runs nil))\n\
    \      (= (rest rs) s) (cons (first rs) (cons runs nil))\n      (empty? rs) (cons\
    \ (first s) (cons runs nil))\n      (= (rest s) (rest rs)) (cons (first rs) (cons\
    \ runs nil))\n      (= (rest rs) s) (cons (first rs) (cons runs nil))\n      (",
  "{\n    long[] noDuplicates = new long[numbers.length];\n    for (int i = 0; i <\
    \ numbers.length; i++)\n    {\n        if (noDuplicates[numbers[i]] != null) continue;\n\
    \        noDuplicates[numbers[i]] = numbers[i];\n    }\n    return noDuplicates;\n\
    }\n'''", "{\n    long current = numbers[0];\n    long[] result = new long[numbers.length];\n\
    \    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] !=\
    \ current)\n            result[result.length] = numbers[i];\n        current =\
    \ numbers[i];\n    }\n    return result;\n}", "{\n\tvar ans = new long[numbers.length];\n\
    \tvar j = 0;\n\tvar i = 0;\n\twhile (i<numbers.length-1)\n\t{\n\t\tif (numbers[i]!=numbers[i+1])\n\
    \t\t\tans[j++] = numbers[i++];\n\t\telse\n\t\t\ti++;\n\t}\n\tans[j] = numbers[i++];\n\
    \treturn ans;\n}\n/*\n From an array of doubles, remove all elements that occur\
    \ more than once.\n    Keep order of elements left the same as in the input.\n\
    \    >>> remove_duplicates([1.2, 2.3, 3.4, 2.3, 4.5])\n    [1.2, 3.4, 4.5]\n \
    \   \n*/\ndouble[] remove_duplicates(double[] numbers) \n{\n\tvar ans = new double[numbers.length];\n\
    \tvar j = 0;\n\tvar i = 0;\n\twhile (i<numbers.length-1)\n\t{\n\t\tif (numbers[i]!=numbers[i+1])\n\
    \t\t\tans[j++] = numbers[i++];\n\t\telse\n\t\t\ti++;\n\t}\n\tans[j] = numbers[i++];\n\
    \treturn ans;\n}\n/*\n From an array of strings, remove all elements that occur\
    \ more than once.\n    Keep order of elements left the same as in the input.\n\
    \    >>> remove_duplicates([\"A\",\"B\",\"C\",\"B\",\"D\"])\n    [\"A\",\"B\"\
    ,\"C\",\"D\"]\n    \n*/\nstring[] remove_duplicates(string[] numbers) \n{\n\t\
    var ans = new string[numbers.length];\n\tvar j = 0;\n\tvar i = 0;\n\twhile (i<numbers.length-1)\n\
    \t{\n\t\tif (numbers[i]!=numbers[i+1])\n\t\t\tans[j++] = numbers[i++];\n\t\telse\n\
    \t\t\ti++;\n\t}\n\tans[j] = numbers[i++];\n\treturn ans;\n}", "{\n\tvar result:\
    \ long[] = numbers.dup;\n\tint i = 0;\n\twhile (i < result.length - 1) {\n\t\t\
    if (result[i] == result[i+1]) {\n\t\t\tresult.splice(i, 1);\n\t\t\ti--;\n\t\t\
    }\n\t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn result;\n}\n/* End of functions\
    \ */", "{\n    long[] result = new long[numbers.length];\n    long hash = 1;\n\
    \    \n    for (int i = 0; i < numbers.length; i++) {\n        \n        long\
    \ num = numbers[i];\n        long found = 1;\n        \n        while (num !=\
    \ hash) {\n            \n            hash *= 10L;\n            found *= hash;\n\
    \            hash += num;\n        }\n        \n        if (found > 1) result[i\
    \ - found] = num;\n    }\n    \n    return result;\n}", "{\n  var result = new\
    \ long[numbers.length];", "{\n    // TODO Auto-generated method stub\n    long[]\
    \ result = new long[numbers.length];\n    int idx = 0;\n    int current = 0;\n\
    \    while (idx < result.length && current < numbers.length) {\n        if (numbers[current]\
    \ == numbers[idx]) {\n            current++;\n        } else {\n            result[idx]\
    \ = numbers[current];\n            current++;\n        }\n        idx++;\n   \
    \ }\n    return Arrays.copyOf(result, idx);\n}", "{\n    long ret = 0;\n    long\
    \ i = 0;\n    bool last = false;\n    for (; i < numbers.length; ++i) {\n    \
    \    if (numbers[i] != ret)\n        {\n            last = true;\n           \
    \ ret = numbers[i];\n        }\n    }\n    if (last)\n    {\n        return numbers;\n\
    \    }\n    long[] res = new long[numbers.length-1];\n    int j = 0;\n    for\
    \ (int k = 0; k < numbers.length; ++k) {\n        if (numbers[k] != ret)\n   \
    \     {\n            res[j] = ret;\n            j++;\n        }\n    }\n    return\
    \ res;\n}\n</code>\n<|/ a |>\n<| a |>\nThis code is also working for me for removing\
    \ the duplicates from an ArrayList:\n<code>\nprivate void removeDups(ArrayList\
    \ < String > list) {\n    int count = 0;\n    for (int i = 0; i < list.size();\
    \ i++) {\n        for (int j = 0; j < list.size(); j++) {\n            if (list.get(i).equals(list.get(j)))\
    \ {\n                count++;\n            }\n        }\n        if (count < list.size()\
    \ / 2) {\n            list.remove(i);\n            i--;\n        }\n        count\
    \ = 1;\n    }\n}\n</code>\n<|/ a dscore=0 tags=arraylist,java |>\n<| a |>\n<code>\n\
    public class RemoveDuplicatesFromList {\n    \n    public static void main(String[]\
    \ args) {\n        \n        List<Integer> numbers = new ArrayList<>();\n    \
    \    numbers.add(1);\n        numbers.add(3);\n        numbers.add(2);\n     \
    \   numbers.add(1);\n        numbers.add(2);\n        numbers.add(3);\n      \
    \  numbers.add(3);\n        numbers.add(4);\n        \n        List<Integer> result\
    \ = RemoveDuplicatesFromList.getUnique(numbers);\n        \n        result.forEach(System.out::println);\n\
    \    }\n    \n    public static List<Integer> getUnique(List<Integer> list) {\n\
    \        List<Integer> result = new ArrayList<>();\n        \n        Set<Integer>\
    \ set = new HashSet<>();\n        \n        for(int i : list) {\n            if\
    \ (!set.contains(i)) {\n                result.add(i);\n                set.add(i);\n\
    \            }\n        }\n        \n        return result;\n    }\n}\n</code>\n\
    <|/ a tags=arraylist,java dscore=0 |>\n<| a dscore=0 |>\nA Java 8 way of doing\
    \ this. First filter the list to get the unique numbers. Then collect them and\
    \ convert them to the List. This solution creates a new list object rather than\
    \ modifying the original one as mentioned in the other answers.\n<code>\nList<Integer>\
    \ uniqueList = list.stream().distinct().collect(Collectors.toList());\n</code>\n\
    <|/ a tags=arraylist,java |>\n<| a tags=arraylist,java dscore=0 |>\n<code>\nList<",
  "{\n    long uniques[] = numbers;\n    for(long n: uniques) {\n        long count\
    \ = numbers.length;\n        for(int i = 0; i < count; ++i)\n            if(n\
    \ != numbers[i])\n                count--;\n        if(count > 1)\n          \
    \  uniques[count-1] = n;\n    }\n    return uniques;\n}", "{\n    long count =\
    \ countMap.value(numbers);\n    long[] result = new long[count];\n    for (int\
    \ i = 0; i < count; i++) {\n        result[i] = numbers[i];\n    }\n    return\
    \ result ;\n}\n/*\n From an array of integers, remove all elements that occur\
    \ more than once.\n    Keep order of elements left the same as in the input.\n\
    \    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/",
  "{\n    long[] noDups = new long[numbers.length];\n    int k = 0;\n    \n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        long temp = numbers[i];\n\
    \        int count = 0;\n        \n        for (int j = k; j < numbers.length;\
    \ j++)\n        {\n            if (numbers[j] == temp)\n            {\n      \
    \          count++;\n            }\n        }\n        \n        if (count > 1)\n\
    \        {\n            noDups[k] = temp;\n            k++;\n        }\n    }\n\
    \    \n    return noDups;\n}\n</code>\n<|/ a |>\n<| c |>\nYou should replace `if\
    \ (count > 1)` with `if (count != 1)` because `count` could be `0` - i.e. if `numbers[k]\
    \ == temp` it could be `count` could be `0` then `count++` could result in an\
    \ overflow.\n<|/ c |>\n<| a tags=java,algorithm |>\nHere's my C# translation of\
    \ your python snippet:\n<code>\npublic class RemoveDuplicates {\n    public static\
    \ long[] RemoveDuplicates(long[] numbers)\n    {\n        long counter = 0;\n\
    \        long[] noDups = new long[numbers.Length];", "{\n    long result[] = new\
    \ long[numbers.length];", "{\n    var result = new long[numbers.length];\n   \
    \ var index = 0;\n    for (long num : numbers) {\n        result[index++] = num;\n\
    \        if (num > 0) {\n            int[] count = new int[numbers.Length];\n\
    \            for (int i = 0; i < numbers.Length; i++)\n                count[i]\
    \ = 0;\n            for (int i = 0; i < numbers.Length; i++)\n               \
    \ count[numbers[i]] = 1;\n            for (int i = index - 1; i >= 0; i--) {\n\
    \                int count = 0;\n                long num = result[i];\n     \
    \           for (int j = 0; j < numbers.Length; j++) {\n                    if\
    \ (count[numbers[j]]) {\n                        count[numbers[j]]++;\n      \
    \                  break;\n                    }\n                    count[numbers[j]]\
    \ = 1;\n                }\n                if (count == numbers.Length) {\n  \
    \                  result[i] = num;\n                }\n            }\n      \
    \  }\n    }\n    return result.Take(index).ToArray();\n}\n</code>\n<|/ a |>\n\
    <| a tags=c#,arrays,duplicates |>\nYou can create Dictionary with unique elements\
    \ and after that iterate through dictionary and fill new array:\n<code>\n    \
    \    int[] arr1 = new int[] { 1, 2, 3 };\n        int[] arr2 = new int[] { 1,\
    \ 2, 4 };\n        Dictionary<int, int> dic = new Dictionary<int, int>();\n  \
    \      foreach (int i in arr1)\n        {\n            dic[i] = 1;\n        }\n\
    \        foreach (int i in arr2)\n        {\n            if (!dic.ContainsKey(i))\n\
    \            {\n                dic.Add(i, 1);\n            }\n        }\n   \
    \     int[] resultArray = new int[dic.Keys.Count];\n        for (int i = 0; i\
    \ < resultArray.Length; i++)\n        {\n            resultArray[i] = dic.Keys.ElementAt(i);\n\
    \        }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=c#,arrays,duplicates\
    \ |>\n<code>", "{\n    long[] result = new long[numbers.length];\n    \n    for\
    \ (long element : numbers) \n    {\n        long count=0;\n        for (long i\
    \ : numbers) {\n            if (i == element) {\n                count++;\n  \
    \          }\n        }\n        if (count > 1) {\n            result[resultIndex]\
    \ = element;\n            resultIndex++;\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=arrays,sorting,c++,performance dscore=1 |>\n<| a |>\n<code>\n\
    #include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include\
    \ <algorithm>\n#include <time.h>", "{\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 1; i < numbers.length; ++i) \n    {\n        if (numbers[i]\
    \ == numbers[i - 1]) \n        {\n            continue;\n        }\n        result[i\
    \ - 1] = numbers[i];\n    }\n    return result;\n}\n</code>\n<|/ a tags=java,arrays\
    \ dscore=3 |>\n<| c |>\nThis solution does not work if the numbers are in reverse\
    \ order in the array.\n<|/ c |>\n<| a dscore=3 tags=java,arrays |>\n<code>\npublic\
    \ static void removeDuplicates(int[] arr) {\n    Set<Integer> set = new HashSet<Integer>();\n\
    \    Set<Integer> setTemp = new HashSet<Integer>();\n    for (int i : arr) {\n\
    \        setTemp.add(i);\n    }\n    arr = new int[setTemp.size()];\n    for (int\
    \ i = 0; i < setTemp.size(); i++) {\n        arr[i] = setTemp.get(i);\n    }\n\
    }\n</code>\n<|/ a |>\n<| a dscore=2 tags=java,arrays |>\n<code>\nimport java.util.HashMap;\n\
    import java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;", "{\n\
    \tvar map = new Map<long, int>();\n\tfor (int i = 0; i < numbers.length; ++i)\
    \ {\n\t\tif (map.containsKey(numbers[i])) {\n\t\t\tmap[numbers[i]]++;\n\t\t} else\
    \ {\n\t\t\tmap.put(numbers[i], 1);\n\t\t}\n\t}\n\tlong[] result = new long[map.size()];\n\
    \tint j = 0;\n\tforeach (var item in map.keys) {\n\t\tresult[j++] = item;\n\t\
    }\n\treturn result;\n}", "{\n    int[] seen = new int[numbers.length];\n    int[]\
    \ count = new int[numbers.length];\n    long[] result = new long[numbers.length];\n\
    \    \n    for (int i = 0; i < numbers.length; i++)\n        count[numbers[i]]\
    \ ++;\n    \n    for (int i = 0; i < numbers.length; i++)\n        if (count[numbers[i]]\
    \ == 1)\n            result[seen[numbers[i]]] = numbers[i];\n            \n  \
    \      for (int j = 0; j < numbers.length; j++)\n            if (count[j] > 1)\n\
    \                seen[numbers[j]] = i;\n                \n    for (int i = 0;\
    \ i < numbers.length; i++)\n        count[numbers[i]] --;\n    \n    return result;\n\
    }\n/*\n From an array of integers, remove all elements that occur more than once.\n\
    \    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1,\
    \ 2, 3, 2, 2, 4])\n    [1, 2, 3, 4]\n    \n*/", "{\n  long[] result = new long[numbers.length];\n\
    \  int count = 0;\n  foreach(long n in numbers) {\n    foreach(int x in numbers)\
    \ {\n      if(x != n) {\n        long toRemove = x - n;\n        if(count < toRemove)\
    \ {\n          result[count++] = x;\n        } else {\n          result[count++]\
    \ = n;\n          break;\n        }\n      }\n    }\n  }\n  return result;\n}",
  "{\n  int n = 0;\n  foreach(int e in numbers) {\n    if (e == numbers[n]) n++;\n\
    \    else {\n      numbers[n] = e;\n      n++;\n    }\n  }\n  return numbers;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks, I used this and added a version\
    \ that doesn't use generics: `public static <T extends Comparable> List<T> remove_duplicates(List<T>\
    \ numbers) {\n  int n = 0;\n  for(T e : numbers) {\n    if (e.compareTo(numbers[n])\
    \ == 0) n++;\n    else {\n      numbers[n] = e;\n      n++;\n    }\n  }\n  return\
    \ numbers;\n}`\n<|/ c |>\n<| a dscore=1 |>\n<code>\npackage com.dreamers;", "{\n\
    \    long result = 0;\n    bool seen_number = false; \n    \n    foreach(long\
    \ n in numbers) {\n        if (!seen_number) {\n            result += n;\n   \
    \         seen_number = true;\n        }\n        \n        if (n==result) {\n\
    \            numbers.removeAt(numbers.indexOf(System.identityHashCode(n)));\n\
    \        }\n    }\n    \n    foreach(long n in numbers) {\n        if (!seen_number)\
    \ {\n            result += n;\n            seen_number = true;\n        }\n  \
    \  }\n    \n    return new long[] {result};\n}", "{\n    long result[] = new long[numbers.length];\n\
    \    int count[] = new int[numbers.length];\n    for (int i = 0; i < numbers.length;\
    \ ++i) {\n        count[numbers[i]] = 1;\n    }\n    int j = 0;\n    for (int\
    \ i = 0; i < numbers.length; ++i) {\n        long n = numbers[i];\n        while\
    \ (j < count[n] && n != numbers[j]) {\n            ++j;\n        }\n        result[i]\
    \ = n;\n        count[n] -= j;\n    }\n    return result;\n}", "{\n    long[]\
    \ nums1 = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++){\n\
    \        for (int j = i+1; j < numbers.length; j++){\n            if (numbers[i]\
    \ == numbers[j]){\n                nums1[i] = nums1[j];\n                numbers.remove(numbers[i]);\n\
    \                numbers.remove(numbers[j]);\n                i--;\n         \
    \       j--;\n            }\n        }\n    }\n    return numbers;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=2 |>\n<code>\npublic static final <T> void removeDuplicates(ArrayList<T>\
    \ array) {\n    int i = 0;\n    boolean found = false;\n    while (i < array.size()\
    \ && !found) {\n        found = array.get(i).equals(array.get(i + 1));\n     \
    \   i++;\n    }\n    if (!found) {\n        array.remove(i + 1);\n    }\n}\n</code>\n\
    <|/ a tags=java,collections |>\n<| c |>\nCould you please add some explanation\
    \ to your code?\n<|/ c |>\n<| a tags=java,collections dscore=2 |>\nThis method\
    \ is quite efficient. Here it goes:\n<code>\npublic static void removeDuplicates(ArrayList<Integer>\
    \ nums) {\n    int i = 0;\n    boolean found = false;\n    while (i < nums.size()\
    \ && !found) {\n        found = nums.get(i) == nums.get(i + 1);\n        i++;\n\
    \    }\n    if (!found) {\n        nums.remove(i + 1);\n    }\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't appear to work for duplicates that are next to each\
    \ other in the list\n<|/ c |>\n<| c |>\nIt works. Are you sure you passed the\
    \ right argument? It works fine for me. `nums` should be `Arrays.asList(1, 2,\
    \ 1, 2, 3)`\n<|/ c |>\n<| c |>\nOh, I see the problem now. You're removing elements\
    \ as you iterate through the list. Instead, iterate backwards. I'll edit my answer\
    \ to reflect that.\n<|/ c |>\n<| c |>\nNice use of `get(i)` and `remove(i)`\n\
    <|/ c |>\n<| c |>\nThis removes ALL duplicates, not just adjacent ones. This was\
    \ the only answer that correctly addressed the question.\n<|/ c |>\n<| a |>\n\
    <code>\npublic static void removeDuplicates(ArrayList<Integer> nums) {\n    int\
    \ i = 0;\n    boolean found = false;\n    while (i < nums.size() && !found) {\n\
    \        found = nums.get(i) == nums.get(i + 1);\n        i++;\n    }\n    if\
    \ (!found) {\n        nums.remove(i + 1);\n    }\n}\n</code>\n<|/ a tag", "{\n\
    \    int index = 0;\n    long[] result = new long[numbers.length];\n    int i;\n\
    \    for (i = 1; i < numbers.length; ++i) \n    {\n        if (numbers[i] != numbers[i-1])\
    \ \n        {\n            result[index] = numbers[i];\n            ++index;\n\
    \        }\n    }\n    result[index] = numbers[i];\n    return result;\n}\n/*\n\
    \ From an array of floats, remove all elements that occur more than once.\n  \
    \  Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1.0L,\
    \ 2.0L, 3.0L, 2.0L, 4.0L])\n    [1.0L, 3.0L, 4.0L]\n    \n*/\nfloat[] remove_duplicates(float[]\
    \ numbers) \n{\n    int index = 0;\n    float[] result = new float[numbers.length];\n\
    \    int i;\n    for (i = 1; i < numbers.length; ++i) \n    {\n        if (numbers[i]\
    \ != numbers[i-1]) \n        {\n            result[index] = numbers[i];\n    \
    \        ++index;\n        }\n    }\n    result[index] = numbers[i];\n    return\
    \ result;\n}\n/*\n From an array of strings, remove all elements that occur more\
    \ than once.\n    Keep order of elements left the same as in the input.\n    >>>\
    \ remove_duplicates([\"1\", \"2\", \"3\", \"2\", \"4\"])\n    [\"1\", \"3\", \"\
    4\"]\n    \n*/\nString[] remove_duplicates(String[] numbers) \n{\n    int index\
    \ = 0;\n    String[] result = new String[numbers.length];\n    int i;\n    for\
    \ (i = 1; i < numbers.length; ++i) \n    {\n        if (numbers[i] != numbers[i-1])\
    \ \n        {\n            result[index] = numbers[i];\n            ++index;\n\
    \        }\n    }\n    result[index] = numbers[i];\n    return result;\n}\n/*\n\
    \ From an array of doubles, remove all elements that occur more than once.\n \
    \   Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1.0L,\
    \ 2.0L, 3.0L, 2.0L, 4.0L])\n    [1.0L, 3.0L, 4.0L]\n    \n*/\ndouble[] remove_duplicates(double[]\
    \ numbers) \n{\n    int index = 0;\n    double[] result = new double[numbers.length];\n\
    \    int i;\n    for (i = 1; i < numbers.length; ++i) \n    {\n        if (numbers[i]\
    \ != numbers[i-1]) \n        {\n            result[index] = numbers[i];\n    \
    \        ++index;\n        }\n    }\n    result[index] = numbers[i];\n    return\
    \ result;\n}\n/*\n From an array of ints, remove all elements that occur more\
    \ than once.\n    Keep order of elements left the same as in the input.\n    >>>\
    \ remove_duplicates([1L, 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/", "{\n \
    \   if (numbers.length == 0)\n        return numbers;\n    long[] result = new\
    \ long[numbers.length];\n    int i, j, k = 0, n = numbers.length;\n    for (i\
    \ = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (numbers[j]\
    \ == numbers[i]) {\n                result[k++] = numbers[j];\n              \
    \  break;\n            }\n        }\n    }\n    return Long.arrayCopy(result,\
    \ 0, result, k, result.length - k);\n}\n</code>\n<|/ a tags=java dscore=5 |>\n\
    <| c |>\nThis method is significantly slower than the built-in `java.util.Arrays.sort`\
    \ for long arrays of size around 10M.\n<|/ c |>\n<| c |>\nI like this answer.\
    \ One correction is `Arrays.sort(numbers);` as `Arrays.sort()` requires `Number`\
    \ and not `long`\n<|/ c |>\n<| c |>\nThe method does have some performance overhead,\
    \ but for long arrays it should be negligible, even if it takes a longer time\
    \ to sort them. How are you testing this?\n<|/ c |>\n<| c |>\nI ran a test to\
    \ see how long it took to sort 10,000 long[] arrays. It was taking around a minute.\
    \ Thanks Piotr.\n<|/ c |>\n<| c |>\nFor Java 7 or later, use `Arrays.stream(longs).distinct().toArray(long[]::new)`.\n\
    <|/ c |>\n<| a dscore=5 |>\nI would suggest you to try a data structure which\
    \ can help you solve this problem.\nAn example would be a HashMap. HashMap works\
    \ with pairs(key-value pairs), which you can think of as 2 unique identifiers.\
    \ You can map each unique identifier to its value and it gives you the unique\
    \ identifiers. \nIf you insert 2 unique identifiers with the same value, the HashMap\
    \ will just replace the old value with new value but you still have the old identifier.\n\
    <|/ a tags=java |>\n<| c |>\nHashMap is a great data structure to use for such\
    \ a task, however it would still be better if the OP were to specify exactly what\
    \ type of data structure to use.\n<|/ c |>\n<| c |>\nA HashMap can only have one\
    \ value per key, and that value is a unique identifier.\n<|/ c |>\n<| c |>\nThat\
    \ was the point. The OP doesn't specify a data structure. It could be a HashMap\
    \ but could be any data structure.\n<|/ c |>\n<| c |>\n: It doesn't have to be\
    \ a HashMap. A LinkedHashMap will do, and be faster for a large number of entries.\n\
    <|/ ", "{\n    long unique = 0, duplicate = 0;\n    for (long num : numbers) {\n\
    \        if (num == unique)\n            duplicate++;\n        else\n        {\n\
    \            unique = num;\n            duplicate = 1;\n        }\n    }\n   \
    \ numbers = new long[numbers.length - duplicate];\n    long[] temp = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++) {\n        temp[i] = numbers[i];\n\
    \    }\n    int pos = 0;\n    for (int i = numbers.length - 1; i >= 0; i--) {\n\
    \        if (numbers[i] != temp[pos])\n        {\n            numbers[pos] = numbers[i];\n\
    \            pos++;\n        }\n    }\n    return numbers;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=arrays,duplicate-removal,algorithm dscore=0 |>\nIf you\
    \ have a large enough array (e.g. a million elements), then the fastest way to\
    \ remove duplicate elements is to sort the array and then remove the first element\
    \ for each subsequent element.\nTo sort a large array quickly, you only need to\
    \ swap the elements that come after the current element in the array. For example\
    \ if you have an array of length 100 such that you start out with:\n<code>\na0\
    \ a1 a2 a3 a4 a5 a6 a7 a8 a9 a10\n</code>\nYou could sort the array into an array\
    \ like this:\n<code>\na0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16\
    \ a17 a18 a19 a20\n</code>\nThen remove the first element from each subsequent\
    \ element:\n<code>\na0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16\
    \ a17 a18 a19 a20\na0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17\
    \ a18 a19 a20\na0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17 a18\
    \ a19 a20\na1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17 a18 a19\
    \ a20\na1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a", "{\n  int i = 0;\n \
    \ long[] result = new long[numbers.length];\n  long max = 1;\n  while ((i < numbers.length)\
    \ && (numbers[i] > max)) {\n    max *= numbers[i];\n    ++i;\n  }\n  int j = 0;\n\
    \  while (i < numbers.length) {\n    result[j++] = numbers[i];\n    if (numbers[i]\
    \ > max) {\n      max = numbers[i];\n    }\n    ++i;\n  }\n  return result;\n}",
  "{\n    var result = new long[numbers.length];\n    int index = 0;\n    for(int\
    \ i = 0; i < numbers.length; i++)\n    {\n        if(result[index] != numbers[i])\n\
    \        {\n            result[index] = numbers[i];\n            index++;\n  \
    \      }\n    }\n    return result;\n}", "{\n  long[] result = new long[numbers.length];\n\
    \  int j = 0;\n  for (int i = 0; i < numbers.length; ++i)\n  {\n    if (j < i\
    \ && numbers[i] > numbers[j])\n    {\n      result[i] = numbers[i];\n      ++j;\n\
    \    }\n  }\n  return result;\n}\n/*\n From an array of floats, remove all elements\
    \ that occur more than once.\n    Keep order of elements left the same as in the\
    \ input.\n    >>> remove_duplicates([1.0f, 2.0f, 3.0f, 2.0f, 4.0f])\n    [1.0f,\
    \ 3.0f, 4.0f]\n    \n*/\nfloat[] remove_duplicates(float[] numbers) \n{\n  Float[]\
    \ result = new Float[numbers.length];\n  for(int i=0; i<numbers.length; i++)\n\
    \  {\n    int j = 0;\n    float x = numbers[i];\n    for(int k=0; k<i; k++)\n\
    \    {\n      float y = numbers[k];\n      if(x == y)\n      {\n        j++;\n\
    \        break;\n      }\n    }\n    if(j < i)\n    {\n      result[i] = x;\n\
    \      ++j;\n    }\n  }\n  return result;\n}\n/*\n From an array of doubles, remove\
    \ all elements that occur more than once.\n    Keep order of elements left the\
    \ same as in the input.\n    >>> remove_duplicates([1.0d, 2.0d, 3.0d, 2.0d, 4.0d])\n\
    \    [1.0d, 3.0d, 4.0d]\n    \n*/\ndouble[] remove_duplicates(double[] numbers)\
    \ \n{\n  Double[] result = new Double[numbers.length];\n  for(int i=0; i<numbers.length;\
    \ i++)\n  {\n    int j = 0;\n    double x = numbers[i];\n    for(int k=0; k<i;\
    \ k++)\n    {\n      double y = numbers[k];\n      if(x == y)\n      {\n     \
    \   j++;\n        break;\n      }\n    }\n    if(j < i)\n    {\n      result[i]\
    \ = x;\n      ++j;\n    }\n  }\n  return result;\n}\n</code>\n<|/ a |>\n<| a tags=duplicate-removal,list,arrays,java\
    \ |>\n<code>\nimport java.util.Arrays;", "{\n    int size = numbers.length;\n\
    \    long[] result = new long[size];\n    int[] used = new int[size];\n    \n\
    \    for(int i = 0; i < size; ++i) {\n        int k = used[i];\n        if(numbers[i]\
    \ == numbers[k]) {\n            used[i] = ++used[k];\n        } else {\n     \
    \       used[i] = 1;\n            result[i - 1] = numbers[i];\n        }\n   \
    \ }\n    \n    return result;\n}\n</code>\n<|/ a |>\n<| a tags=python,arrays,duplicates\
    \ dscore=0 |>\n<code>\ndef remove_duplicates(input_array):\n    new_list = []\n\
    \    for num in input_array:\n        if num not in new_list:\n            new_list.append(num)\n\
    \    return new_list\n</code>\nThis code should do the trick. Of course, you can\
    \ also use list comprehension:\n<code>\ndef remove_duplicates(input_array):\n\
    \    return list(set([x for x in input_array if input_array.count(x) > 1]))\n\
    </code>\n<|/ a |>\n<| a tags=python,arrays,duplicates |>\n<code>\nimport numpy\
    \ as np", "{\n  long result[] = new long[numbers.length];\n  int i = 0;\n  for\
    \ (int j=0; j < numbers.length; ++j)\n  {\n    if (numbers[i] != numbers[j])\n\
    \    {\n      result[i] = numbers[j];\n      ++i;\n    }\n  }\n  return result;\n\
    }\n/*\n From an array of integers, remove all elements that occur more than once.\n\
    \    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates_v2(long[]\
    \ numbers) \n{\n  long result[] = new long[numbers.length];\n  int i = 0;\n  int\
    \ j = 0;\n  int k = 0;\n  for (int l = 0; l < numbers.length; ++l)\n  {\n    if\
    \ (numbers[i] != numbers[l])\n    {\n      result[k] = numbers[l];\n      ++i;\n\
    \      ++j;\n      ++k;\n    }\n  }\n  return result;\n}\n/*\n From an array of\
    \ integers, remove all elements that occur more than once.\n    Keep order of\
    \ elements left the same as in the input.\n    >>> remove_duplicates([1L, 2L,\
    \ 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates_v3(int numbers[],\
    \ int len, long value) \n{\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  long result[]\
    \ = new long[len];\n  for (int l = 0; l < len; ++l)\n  {\n    if (numbers[i] !=\
    \ value)\n    {\n      result[k] = numbers[l];\n      ++i;\n      ++j;\n     \
    \ ++k;\n    }\n  }\n  return result;\n}\n/*\n From an array of integers, remove\
    \ all elements that occur more than once.\n    Keep order of elements left the\
    \ same as in the input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n   \
    \ [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates_v3(long[] numbers) \n{\n  long\
    \ result[] = new long[numbers.length];\n  int i = 0;\n  int j = 0;\n  int k =\
    \ 0;\n  for (int l = 0; l < numbers.length; ++l)\n  {\n    if (numbers[i] != numbers[l])\n\
    \    {\n      result[k] = numbers[l];\n      ++i;\n      ++j;\n      ++k;\n  \
    \  }\n  }\n  return result;\n}\n/*\n From an array of integers, remove all elements\
    \ that occur more than once.\n    Keep order of elements ", "{\n    int i,\n \
    \       len = numbers.length;\n    long[] num = new long[len];\n    for(i = 0;\
    \ i < len; i++) \n        num[numbers[i]] = i;\n    long[] nums = new long[num.length];\n\
    \    for(i = 0; i < len; i++)\n        nums[nums[i]] = numbers[i];\n    return\
    \ nums;\n}", "{\n    long lastNum = 0;\n    long result = 0;\n    int numLen =\
    \ numbers.length;\n    for(int i = 0; i < numLen; i++) {\n        if (numbers[i]\
    \ != lastNum) {\n            lastNum = numbers[i];\n            result = result\
    \ + lastNum;\n        }\n    }\n    return new long[] {result,lastNum};\n}\n</code>\n\
    <|/ a |>\n<| a |>\nThis should do the trick:\n<code>\nList<Integer> myList = Arrays.asList(2,\
    \ 4, 6, 1, 2, 3, 5);\nmyList = myList.removeIf(i -> myList.indexOf(i) == myList.lastIndexOf(i)\
    \ + 1);\n</code>\n<|/ a tags=arrays,java,duplicates dscore=1 |>\n<| a tags=arrays,java,duplicates\
    \ dscore=1 |>\n<code>\npublic class Duplicate\n{\n  public static void main(String\
    \ args[])\n  {\n    int num[]={1,2,3,4,5,5,6,5,5,6,7,8};\n    System.out.println(remove_duplicates(num));\n\
    \  }\n  public static int[] remove_duplicates(int[] nums)\n  {\n    int[] sortedArray\
    \ = new int[nums.length];\n    Arrays.sort(nums);\n    for(int i=0;i<nums.length;i++)\n\
    \    {\n      int count=0;\n      for(int j=i+1;j<nums.length;j++)\n      {\n\
    \        if(nums[i]==nums[j])\n        {\n          count=count+1;\n        }\n\
    \      }\n      if(count>1)\n      {\n        sortedArray[i]=nums[i];\n      }\n\
    \    }\n    return sortedArray;\n  }\n}\n</code>\n<|/ a |>\n<| c |>\nWelcome to\
    \ Stack Overflow! While this code snippet may solve the question, [including an\
    \ explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| c |>\nSorry I was away.\n<|/ c |>\n<| a |>\nThe\
    \ solution in C#:\n<code>\npublic class RemoveDuplicates\n{\n    public static\
    \ int[] RemoveDuplicates(int[] nums)\n    {\n        int size = nums.Length;\n\
    \        var sorted = nums.OrderBy(x => x);\n        var set = new HashSet<int>(sorted);\n\
    \        int[] result = new int[size];", "{\n    long[] result = new long[numbers.length];\n\
    \    long[] temp = new long[numbers.length];\n    int index = 0;\n    for(long\
    \ n : numbers)\n    {\n        if(index == 0)\n        {\n            temp[index++]\
    \ = n;\n        }\n        else \n        {\n            long last = temp[index\
    \ - 1];\n            if(last == n)\n            {\n                temp[index++]\
    \ = n;\n            }\n            else\n            {\n                result[index++]\
    \ = n;\n            }\n        }\n    }\n    for(int i = index - 1; i >= 0; --i)\n\
    \    {\n        result[i] = temp[i];\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=math,arrays,java |>\n<| a tags=math,arrays,java |>\n<code>\n/**\n *\
    \ Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n\
    \ *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *    \
    \     next = null;\n *     }\n * }\n */\npublic class RemoveDuplicates2 {\n  \
    \  private ListNode head;", "{\n\tlong[] result = new long[numbers.length];\n\t\
    int i = 0, j = 0;\n\t\n\twhile (i < numbers.length) {\n\t\twhile (j < result.length\
    \ && numbers[i] != result[j]) {\n\t\t\tj++;\n\t\t}\n\t\tif (j == result.length)\
    \ \n\t\t\tbreak;\n\t\tresult[j] = numbers[i];\n\t\ti++;\n\t\tj = 0;\n\t}\n\tif\
    \ (i < numbers.length) \n\t\tSystem.arraycopy(numbers, i, result, j, numbers.length\
    \ - i);\n\treturn result;\n}", "{\n    Arrays.sort(numbers);\n    long[] result\
    \ = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++)\n\
    \    {\n        for (int j = 0; j < i; j++)\n        {\n            if (numbers[i]\
    \ == numbers[j])\n            {\n                result.length--;\n          \
    \      break;\n            }\n        }\n        result[i] = numbers[i];\n   \
    \ }\n    return result;\n}", "{\n\tlong[] ret = new long[numbers.length];\n\t\
    for (int i = 0; i < numbers.length; i++)\n\t\tfor (int j = 0; j < i; j++)\n\t\t\
    \tif (numbers[i] == numbers[j])\n\t\t\t\tbreak;\n\t\tif (j == i)\n\t\t\tret[i]\
    \ = numbers[i];\n\treturn ret;\n}", "{\n  int[] ids = new int[numbers.length];\n\
    \  for (int i = 0; i < numbers.length; i++) {\n    ids[i] = i;\n  }\n  Arrays.sort(ids);\n\
    \  long[] result = new long[ids.length];\n  int i = 0;\n  while (i < ids.length)\
    \ {\n    if (ids[i] != i) {\n      result[i] = numbers[ids[i]];\n      ids[i]\
    \ = ids[ids[i]];\n    } else {\n      ++i;\n    }\n  }\n  return result;\n}\n\
    </code>\n<|/ a dscore=1 tags=java,arrays,hashmap |>\n<| a dscore=1 |>\n<code>\n\
    public static long getMaxFrom(int[] arr) {\n    HashMap<Integer, Integer> map\
    \ = new HashMap<>();\n    for (int i = 0; i < arr.length; i++) {\n        int\
    \ val = arr[i];\n        Integer temp = map.get(val);\n        if (temp == null)\
    \ {\n            map.put(val, i);\n        }\n    }\n    Iterator it = map.entrySet().iterator();\n\
    \    while (it.hasNext()) {\n        Map.Entry pair = (Map.Entry)it.next();\n\
    \        int key = (Integer)pair.getKey();\n        int value = (Integer)pair.getValue();\n\
    \        arr[key] = value;\n        it.remove();\n    }\n    return arr[arr.length-1];\n\
    }\n</code>\n<|/ a tags=java,arrays,hashmap |>\n<| a dscore=1 |>\n<code>\n// Using\
    \ LinkedHashMap for O(n) time complexity\nimport java.util.*;", "{\n\tif (numbers.length\
    \ == 0)\n\t\treturn numbers;\n\tlong[] result = new long[numbers.length];\n\t\
    for (int i = 0; i < numbers.length; ++i)\n\t\tif (numbers[i] != numbers[i - 1])\
    \ {\n\t\t\tresult[i] = numbers[i];\n\t\t\t--i;\n\t\t}\n\treturn result;\n}", "{\n\
    \    return numbers == null ? null : removeDuplicates(numbers, 0, numbers.length\
    \ - 1);\n}\n/* From an array of integers, remove all elements that occur more\
    \ than once.\n Keep order of elements left the same as in the input.\n */\nlong[]\
    \ removeDuplicates(long[] numbers, int i, int j) \n{\n    if (i > j)\n       \
    \ return numbers;\n    long current = numbers[i];\n    int pos = i;\n    for (int\
    \ k = i + 1; k < j; k++) {\n        if (numbers[k] == current) {\n           \
    \ numbers[pos++] = numbers[k];\n        }\n    }\n    numbers = long.grow(numbers,\
    \ pos);\n    return numbers;\n}\n/* From an array of floats, remove all elements\
    \ that occur more than once.\n Keep order of elements left the same as in the\
    \ input.\n */\nfloat[] remove_duplicates(float[] numbers) \n{\n    return numbers\
    \ == null ? null : removeDuplicates(numbers, 0, numbers.length - 1);\n}\n/* From\
    \ an array of floats, remove all elements that occur more than once.\n Keep order\
    \ of elements left the same as in the input.\n */\nfloat[] removeDuplicates(float[]\
    \ numbers, int i, int j) \n{\n    if (i > j)\n        return numbers;\n    float\
    \ current = numbers[i];\n    int pos = i;\n    for (int k = i + 1; k < j; k++)\
    \ {\n        if (numbers[k] == current) {\n            numbers[pos++] = numbers[k];\n\
    \        }\n    }\n    numbers = float.grow(numbers, pos);\n    return numbers;\n\
    }\n/* From an array of doubles, remove all elements that occur more than once.\n\
    \ Keep order of elements left the same as in the input.\n */\ndouble[] remove_duplicates(double[]\
    \ numbers) \n{\n    return numbers == null ? null : removeDuplicates(numbers,\
    \ 0, numbers.length - 1);\n}\n/* From an array of doubles, remove all elements\
    \ that occur more than once.\n Keep order of elements left the same as in the\
    \ input.\n */\ndouble[] removeDuplicates(double[] numbers, int i, int j) \n{\n\
    \    if (i > j)\n        return numbers;\n    double current = numbers[i];\n \
    \   int pos = i;\n    for (int k = i + 1; k < j; k++) {\n        if (numbers[k]\
    \ == current) {\n            numbers[pos++] = numbers[k];\n        }\n    }\n\
    \    numbers = double.grow(numbers, pos);\n    return numbers;\n}\n/* From an\
    \ array of strings, remove all elements that occur more than once.\n Keep order\
    \ of elements left the same as in the input.\n */\nString[] remove_duplicates(String[]\
    \ strings) \n{\n    return strings == null ? null : removeDuplicates(strings,\
    \ 0, strings.length - 1);", "{\n    long[] result = new long[numbers.length];\n\
    \    Set<long> set = new HashSet<long>();\n    for (int i = 0; i < numbers.length;\
    \ i++) {\n        long value = numbers[i];\n        if (!set.contains(value))\
    \ {\n            set.add(value);\n            result[i] = value;\n        }\n\
    \    }\n    return result;\n}\n</code>\n<|/ a |>\n<| a |>\nThis is similar to\
    \ Sven's answer, but more generic:\n<code>\npublic <T> List<T> uniqueByKey(List<T>\
    \ source, final Function<T, K> keyExtractor, final BinaryOperator<T> valueExtractor)\
    \ {\n    List<T> results = new ArrayList<>();\n    Map<K, T> seen = new HashMap<>();\n\
    \    for (T element : source) {\n        K key = keyExtractor.apply(element);\n\
    \        if (seen.containsKey(key)) {\n            results.add(valueExtractor.apply(seen.get(key)));\n\
    \        }\n        else {\n            results.add(element);\n            seen.put(key,\
    \ element);\n        }\n    }\n    return results;\n}\n</code>\nUsage example:\n\
    <code>\nList<String> uniqueByKey(List<String> source, Function<String, String>\
    \ keyExtractor, Function<String, String> valueExtractor) {\n    return uniqueByKey(source,\
    \ keyExtractor, valueExtractor);\n}\n</code>\n<|/ a dscore=4 tags=java |>\n<|\
    \ c |>\nI would suggest using `Map<K, Set<V>>` instead of `Map<K, T>` so that\
    \ you have the added benefit of not loosing the order of the elements.\n<|/ c\
    \ |>\n<| c |>\nThis approach has the disadvantage that if you have two elements\
    \ with different values but the same key it will throw a ConcurrentModificationException\n\
    <|/ c |>\n<| c |>\nTo prevent this, use ConcurrentSkipListMap instead of HashMap\n\
    <|/ c |>\n<| a |>\nOne liner (no streams):\n<code>\nList<String> unique = new\
    \ ArrayList<>(myStringList.stream().distinct().collect(Collectors.toList()));\n\
    </code>\n<|/ a dscore=4 tags=java |>\n<| a tags=java |>\n<code>\npublic static\
    \ void main(String[] args) {\n        ArrayList<String> list = new ArrayList<String>();\n\
    \        list.add(\"a\");\n        list.add(\"b\");\n        list.add(\"c\");\n\
    \        list.add(\"a\");\n        list.add(\"a\");\n        list.add(\"d\");\n\
    \        list.add(\"a\");\n        list.add(\"b\");\n        Set<String> set =\
    \ new HashSet<String>(list);\n        list.clear();\n        list.addAll(set);\n\
    \        System.out.println(list);\n    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    The `", "{\n    int n=numbers.length;\n    long[] result = new long[n];\n    long[]\
    \ unique = new long[n];\n    for(int i=0; i<n; ++i)\n    {\n        bool found\
    \ = false;\n        for(int j=0; j<n; ++j)\n        {\n            if(numbers[i]==numbers[j])\n\
    \            {\n                found = true;\n                break;\n      \
    \      }\n        }\n        if(!found)\n        {\n            unique[i]=numbers[i];\n\
    \        }\n    }\n    for(int i=0; i<n; ++i)\n    {\n        found = false;\n\
    \        for(int j=0; j<n; ++j)\n        {\n            if(unique[i]==numbers[j])\n\
    \            {\n                found = true;\n                break;\n      \
    \      }\n        }\n        if(!found)\n        {\n            result[i]=unique[i];\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\nMy solution:\n<code>\nlet removeDuplicates<T>(arr: Array<T>): Array<T> {\n\
    \        let arrWithoutDuplicates = arr.reduce(\n            (arr: Array<T>, item:\
    \ T) => {\n                if(arr.indexOf(item) === -1) arr.push(item)\n     \
    \           return arr\n            },\n            []\n        )\n        return\
    \ arrWithoutDuplicates\n    }\n</code>\n<|/ a tags=javascript,arrays |>\n<| a\
    \ |>\nA simple implementation is using an object. We can use the indexOf method\
    \ to check if the item is already in the array.", "{\n    long[] result = new\
    \ long[numbers.length];", "{\n    long[] result = new long[numbers.length];\n\
    \    for (int i = 0; i < numbers.length; i++)\n        result[numbers[i]] = numbers[i];",
  "{\n\tvar len = numbers.length;\n\tvar results = new long[len];\n\tfor(var i=0;i<len;++i)\n\
    \t\tresults[numbers[i]] = numbers[i];\n\t\n\tlong[] out = new long[len];\n\tfor(var\
    \ i=0;i<len;++i)\n\t\tout[i] = results[numbers[i]];\n\t\n\treturn out;\n}\n/*\n\
    \ From an array of integers, remove all elements that occur more than once.\n\
    \    Keep order of elements left the same as in the input.\n    Use a std.map\
    \ to keep track of elements that have been removed.\n    >>> remove_duplicates([1L,\
    \ 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nlong[] remove_duplicates_map(long[]\
    \ numbers) \n{\n\tvar len = numbers.length;\n\tvar results = new std.map();\n\t\
    for(var i=0;i<len;++i)\n\t{\n\t\tvar el = numbers[i];\n\t\tif(!results.contains(el))\n\
    \t\t\tresults[el] = el;\n\t}\n\t\n\tlong[] out = new long[len];\n\tfor(var i=0;i<len;++i)\n\
    \t{\n\t\tvar el = numbers[i];\n\t\tif(results.contains(el))\n\t\t\tout[i] = results[el];\n\
    \t}\n\t\n\treturn out;\n}\n/*\n From an array of integers, remove all elements\
    \ that occur more than once.\n    Keep order of elements left the same as in the\
    \ input.\n    Use a std.array to keep track of elements that have been removed.\n\
    \    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\n\
    long[] remove_duplicates_array(long[] numbers) \n{\n\tvar len = numbers.length;\n\
    \tvar results = new std.array();\n\tfor(var i=0;i<len;++i)\n\t\tresults.push(numbers[i]);\n\
    \t\n\tlong[] out = new long[len];\n\tfor(var i=0;i<len;++i)\n\t{\n\t\tvar el =\
    \ numbers[i];\n\t\tif(std.array.get(results,el) != null)\n\t\t\tout[i] = std.array.get(results,el);\n\
    \t}\n\t\n\treturn out;\n}\n/*\n From an array of floats, remove all elements that\
    \ occur more than once.\n    Keep order of elements left the same as in the input.\n\
    \    Use a std.set to keep track of elements that have been removed.\n    >>>\
    \ remove_duplicates([1L, 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n    \n*/\nfloat[]\
    \ remove_duplicates_set(float[] numbers) \n{\n\tvar len = numbers.length;\n\t\
    var results = new std.set();", "{\n    long duplicates = 0;\n    int index = 0;\n\
    \    long[] answer = new long[numbers.length];\n    \n    for (long value : numbers)\
    \ {\n        while (index < numbers.length && numbers[index] == value) {\n   \
    \         index++;\n            duplicates++;\n        }\n        answer[index++]\
    \ = value;\n    }\n    return answer;\n}", "{\n    long[] newNumbers = new long[numbers.length];\n\
    \    int j = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(newNumbers[j]\
    \ != numbers[i])\n        {\n            newNumbers[j] = numbers[i];\n       \
    \     j++;\n        }\n    }\n    return newNumbers;\n}\n</code>\n<|/ a tags=java\
    \ |>\n<| c |>\nWhat a nice piece of code! I wish I could upvote it twice. I will\
    \ try it later on but if someone could just explain this code to me in simple\
    \ words I would be really happy.\n<|/ c |>\n<| c |>\nI thought that removing duplicates\
    \ is not that hard to do with java. Have you tried the code? I think it would\
    \ be easy to understand if you have some basic java knowledge.\n<|/ c |>\n<| c\
    \ |>\nI've tried it and it works great, thank you! Just one question: how would\
    \ I use this function to remove duplicates from an arraylist? Should I just convert\
    \ the arraylist to a regular array and then use the function as mentioned above?\n\
    <|/ c |>\n<| c |>\nI don't see any benefit of using an ArrayList instead of an\
    \ array. ArrayList has a method to remove duplicates. In addition you can use\
    \ ArrayList to keep the original index of an element and remove it from the array.\n\
    <|/ c |>\n<| c |>\nI am using the ArrayList because I want to be able to modify\
    \ a copy of an ArrayList after I remove duplicates.\n<|/ c |>\n<| a |>\nHere is\
    \ my answer to this question.\n<code>\nprivate static int[] unique(int[] numbers)\
    \ {\n    int uniqueCount = 0;\n    int[] unique = new int[numbers.length];\n \
    \   for (int i = 0; i < numbers.length; i++) {\n        int number = numbers[i];\n\
    \        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j]\
    \ == number) {\n                number = numbers[j];\n                break;\n\
    \            }\n        }\n        unique[uniqueCount++] = number;\n    }\n  \
    \  return unique;\n}\n</code>\n<|/ a tags=java dscore=1 |>\n<| a tags=java dscore=1\
    \ |>\nMy answer is similar to above, but here is a more elegant solution.\n<code>\n\
    private static int[] unique(int[] numbers) {\n    if (numbers.length == 0) return\
    \ numbers;\n    Arrays.sort(numbers);\n    int uniqueCount = 0;\n    int[] unique\
    \ = new int[numbers.length];\n    for (int i = 0; i < numbers.length; ++i) {\n\
    \        int number = numbers[i];\n        for (int j = i + 1; j < numbers.length;\
    \ ++j) {\n            if (numbers[j] < number) {\n                number = numbers[j];\n\
    \                break;\n            }\n        }\n        unique[uniqueCount++]\
    \ = number;", "{\n\tint num_elements = numbers.length;\n\tlong[] answer = new\
    \ long[num_elements];\n\tint[] index = new int[num_elements];", "{\n    long[]\
    \ result = new long[numbers.length];\n    int pos = 0;\n    for (int i = 0; i\
    \ < numbers.length; i++)\n    {\n        if (pos < result.length)\n        {\n\
    \            if (numbers[i] == result[pos])\n            {\n                pos++;\n\
    \            }\n        }\n        else\n        {\n            result[pos] =\
    \ numbers[i];\n        }\n    }\n    return result.subarray(0, pos);\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThank you! I didn't even know about the STD library.\n\
    <|/ c |>\n<| c |>\nI did a Google search on \"Remove duplicates from an array\
    \ of integers\" and found this as the top result.\n<|/ c |>\n<| c |>\nThe algorithm\
    \ can be optimized to run at O(n). See the solution by Erik below. I got my implementation\
    \ based on this answer (https://stackoverflow.com/a/59424868/1669044)\n<|/ c |>\n\
    <| c |>\n- Your solution removes all duplicate elements in the array. What if\
    \ I need to keep only unique elements based on some logic?\n<|/ c |>\n<| c |>\n\
    -zorn - Yes, it does remove all duplicates. But it keeps the order of elements.\n\
    <|/ c |>\n<| a dscore=5 tags=algorithm,java,arrays |>\nEasiest Solution\nUse a\
    \ Set\n<code>\nInteger[] numbers = { 1, 2, 2, 3, 4, 4, 4, 4 };\nSet<Integer> set\
    \ = new HashSet<>(Arrays.asList(numbers));\n</code>\n<|/ a |>\n<| c |>\nWhat will\
    \ happen if we try to add an element that is already present?\n<|/ c |>\n<| c\
    \ |>\nNothing happens, set just doesn't add any duplicates.\n<|/ c |>\n<| a |>\n\
    Java 8 solution using streams:\n<code>\n    int[] numbers = {1, 2, 2, 3, 4, 4,\
    \ 4, 4};\n    int[] uniques = Arrays.stream(numbers).distinct().toArray();\n</code>\n\
    <|/ a tags=algorithm,java,arrays dscore=5 |>\n<| a tags=algorithm,java,arrays\
    \ |>\nThe easiest way is to use HashSet. \nThe complexity is O(n). \n<code>",
  "{\n    int n = numbers.length;\n    long[] noDupes = new long[n];\n    int counter\
    \ = 0;\n    for (int i = 0; i < n; ++i) {\n        if (numbers[i] != numbers[counter])\
    \ {\n            counter++;\n            noDupes[i] = numbers[counter];\n    \
    \    }\n    }\n    return noDupes;\n}\n</code>\n<|/ a tags=arrays,c#,duplicates\
    \ |>\n<| a dscore=2 tags=arrays,c#,duplicates |>\nYou can use LINQ to remove the\
    \ duplicates from an array as follows:\n<code>", "{\n    int nSize = numbers.length;\n\
    \    if (nSize == 0)\n        return numbers;\n    \n    long[] n = new long[nSize];\n\
    \    \n    long nValue = numbers[0];\n    for (int i = 0; i < nSize; i++)\n  \
    \  {\n        if (nValue == numbers[i])\n            continue;\n        n[nSize-i-1]\
    \ = nValue;\n        nValue = numbers[i];\n    }\n    return n;\n}\n</code>\n\
    <|/ a tags=arrays,c++,algorithm dscore=1 |>\n<| c |>\nI think it's important to\
    \ point out that this solution only works for integers. It will not work for long\
    \ integers, doubles or floats\n<|/ c |>\n<| c |>\nI did not claim that my solution\
    \ works for all data types. As you said yourself, I did say that it works only\
    \ for integers. That is what I intended since I provided solution for all data\
    \ types. I did NOT claim that it works only for integers. Please read and understand\
    \ carefully my comment above. It is important to point out that this solution\
    \ only works for integers. It will not work for long integers, doubles or floats.\
    \ I clearly stated that in my comment.\n<|/ c |>\n<| c |>\nOh, I thought you meant\
    \ that your solution only works for integers. I totally misunderstood what you\
    \ meant, my apologies. You also pointed out that I did not claim that my solution\
    \ works for all data types. I do intend to test it on my own data and see if it\
    \ works for all data types.\n<|/ c |>\n<| c |>\nBTW, you should test it on any\
    \ big integers. All of these algorithms work only for integers. I tested it on\
    \ ints on my machine and it was fine.\n<|/ c |>\n<| a |>\nThis is my implementation.\
    \ I've tested it on random inputs, and it works fine.\n<code>\n#include <iostream>\n\
    using namespace std;", "{\n\tList<long> numbers_ = new List<long>();\n\tfor (long\
    \ number : numbers)\n\t\tnumbers_.add(number);\n\tnumbers_.remove_duplicates();\n\
    \treturn numbers_.ToArray();\n}\n/*\n From an array of doubles, remove all elements\
    \ that occur more than once.\n    Keep order of elements left the same as in the\
    \ input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n\
    \    \n*/\ndouble[] remove_duplicates(double[] numbers) \n{\n\tList<double> numbers_\
    \ = new List<double>();\n\tfor (double number : numbers)\n\t\tnumbers_.add(number);\n\
    \tnumbers_.remove_duplicates();\n\treturn numbers_.ToArray();\n}\n/*\n From an\
    \ array of strings, remove all elements that occur more than once.\n    Keep order\
    \ of elements left the same as in the input.\n    >>> remove_duplicates([\u201C\
    A\u201D, \u201CB\u201D, \u201CB\u201D, \u201CA\u201D])\n    [\u201CA\u201D, \u201C\
    B\u201D]\n    \n*/\nstring[] remove_duplicates(string[] numbers) \n{\n\tList<string>\
    \ numbers_ = new List<string>();\n\tfor (string number : numbers)\n\t\tnumbers_.add(number);\n\
    \tnumbers_.remove_duplicates();\n\treturn numbers_.ToArray();\n}", "{\n  if (numbers.length\
    \ < 1) \n    return numbers;", "{\n    // TODO: Optimize this by sorting and then\
    \ reversing?\n    long[] result = new long[numbers.length];\n    long seen[numbers.length];\n\
    \    long unique = 0, count = 0;\n    for (long n : numbers)\n    {\n        seen[count++]\
    \ = n;\n    }\n    for (int i = 0; i < count; i++)\n    {\n        long n = seen[i];\n\
    \        long previous = -1;\n        bool found = false;\n        for (int j\
    \ = i; j < count; j++)\n        {\n            if (seen[j] == n)\n           \
    \ {\n                if (found == true)\n                    unique++;\n     \
    \           else\n                {\n                    previous = j;\n     \
    \               found = true;\n                }\n            }\n        }\n \
    \       if (previous == -1 && found == true)\n            unique++;\n        else\n\
    \        {\n            result[i - 1] = (previous + 1 == unique) ? previous :\
    \ unique - previous;\n            unique--;\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=algorithm,c#,duplicates,linq dscore=1 |>\n<| c |>\nthanks\
    \ man, that is very very nice. i will try it out for sure. :)\n<|/ c |>\n<| c\
    \ |>\nNo problem! I ran it on some test data and it worked just fine.\n<|/ c |>\n\
    <| a dscore=1 |>\nThis is not the optimal solution in terms of readability. But\
    \ since performance is very important here is the algorithm I would use for both\
    \ C# and Java:\n<code>\npublic static long RemoveDuplicates(long[] numbers)\n\
    {\n    long unique = 1;\n    long result = 0;", "{\n    long[] result = new long[numbers.length];\n\
    \    int i = 0;\n    while (i < numbers.length) \n    {\n        if (numbers[i]\
    \ != numbers[i+1]) \n        {\n            result[i++] = numbers[i++];\n    \
    \    }\n    }\n    return result;\n}\n/*\n From an array of floats, remove all\
    \ elements that occur more than once.\n    Keep order of elements left the same\
    \ as in the input.\n    >>> remove_duplicates([1.0, 2.0, 3.0, 2.0, 4.0])\n   \
    \ [1.0, 3.0, 4.0]\n*/\ndouble[] remove_duplicates(double[] numbers) \n{\n    double[]\
    \ result = new double[numbers.length];\n    int i = 0;\n    while (i < numbers.length)\
    \ \n    {\n        if (numbers[i] != numbers[i+1]) \n        {\n            result[i++]\
    \ = numbers[i++];\n        }\n    }\n    return result;\n}", "{\n  var numsCnt\
    \ = 0;\n  var numsMax = std.array.max(numbers);\n  var numsMin = std.array.min(numbers);\n\
    \  var numsSum = std.math.sum(numbers);\n  var numsSumOfSquares, numsSumOfSquares2,\
    \ numsSumOfSquares3;\n  var numsSumOfSquaresSum, numsSumOfSquaresSumOfSquares;\n\
    \  var numsSumOfSquaresSumOfSquares2, numsSumOfSquaresSumOfSquares3;\n  var numsSumOfSquaresSumOfSquaresSum,\
    \ numsSumOfSquaresSumOfSquaresSumOfSquares;\n  var numsSumOfSquaresSumOfSquaresSumOfSquares,\
    \ numsSumOfSquaresSumOfSquaresSumOfSquaresSum;\n  var numsSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares,\
    \ numsSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSum;\n  var numsSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares,\
    \ numsSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares;\n  var numsSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares,\
    \ numsSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares;\n\
    \  var numsSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares,\
    \ numsSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquaresSumOfSquares;\n\
    \  for(var num of numbers)\n  {\n    if(num == numsMax || num == numsMin)\n  \
    \    numsCnt++;\n    else\n    {\n      if(numsSumOfSquares == 0)\n      {\n \
    \       numsSumOfSquares = num;\n        numsSumOfSquaresSum = 0;\n        numsSumOfSquaresSumOfSquares2\
    \ = 0;\n        numsSumOfSquaresSumOfSquares3 = 0;\n        numsSumOfSquaresSumOfSquaresSum\
    \ = 0;\n        numsSumOfSquaresSumOfSquaresSumOfSquares2 = 0;\n        numsSumOfSquaresSumOfSquaresSum",
  "{\n\tlong[] results = new long[numbers.length];\n\tfor (long i : numbers) \n\t\
    {\n\t\tfor (int k = 0; k < i; k++) \n\t\t{\n\t\t\tif (results[k] == i) \n\t\t\t\
    {\n\t\t\t\tresults[k] = results[k+1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\
    return results;\n}", "{\n  int n = numbers.length;\n  long[] result = new long[n];\n\
    \  int duplicates = 0;\n  int i;\n  for (i = 0; i < n; ++i) {\n    if (numbers[i]\
    \ != numbers[result[i]]) {\n      result[duplicates++] = numbers[i];\n    }\n\
    \  }\n  return result;\n}", "{\n\tvar indexed = new long[numbers.length];\n\t\
    for (var index = 0; index < numbers.length; index++) {\n\t\tvar i = indexed[index];\n\
    \t\tif (i == 0) continue;\n\t\t\n\t\tif (numbers[index] != numbers[i]) {\n\t\t\
    \tindexed[index] = numbers[index];\n\t\t\tindex++;\n\t\t} else {\n\t\t\ti--;\n\
    \t\t}\n\t}\n\t\n\tvar newArray = new long[indexed.length-1];\n\tfor (var index\
    \ = 0; index < indexed.length; index++) {\n\t\tnewArray[index] = indexed[index];\n\
    \t}\n\t\n\treturn newArray;\n}", "{\n  var results = new long[numbers.length];\n\
    \  int index = 0;", "{\n  long[] result = new long[numbers.length];\n  int j =\
    \ 0;\n  for (int i = 0; i < numbers.length; ++i) {\n    if (numbers[i] != numbers[j])\
    \ {\n      result[++j] = numbers[i];\n    }\n  }\n  return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI'm sorry, I should have clarified that I'm looking for an\
    \ implementation with linear time complexity, not the standard library. I should\
    \ have added that to the question. Thanks for your suggestions though.\n<|/ c\
    \ |>\n<| c |>\nYou didn't mention linear complexity in the question.  You still\
    \ haven't specified how you define linear.  If you meant \"linear in the number\
    \ of digits\", then this is still linear in the number of digits.\n<|/ c |>\n\
    <| c |>\nI did mention linear time complexity in the question, but I see how I\
    \ was unclear on that. I've clarified it above.\n<|/ c |>\n<| c |>\nThe code above\
    \ has a time complexity of O(#digits).  If you had 10,000 digits, you'd have O(10000).\
    \  How many digits do you have?  If it's 10,000, then it's linear.\n<|/ c |>\n\
    <| c |>\nYou did specify linear time complexity in the question. Your code is\
    \ a linear time implementation.\n<|/ c |>\n<| a dscore=2 |>\nHere is another solution\
    \ based on the approach you gave:\n<code>\nprivate void removeDups(int[] arr)\
    \ {\n    HashSet<Integer> set = new HashSet<Integer>();", "{\n  int len = 0;\n\
    \  foreach (long n in numbers)\n    len += n;\n  long[] result = new long[len];\n\
    \  long curr = 1;\n  foreach (long n in numbers)\n  {\n    int i = 0;\n    while\
    \ (i < result.length && n >= result[i])\n    {\n      ++i;\n    }\n    result[i]\
    \ = n;\n  }\n  return result;\n}\n</code>\nFor a more efficient solution you can\
    \ use some kind of hashing. Since you said you were using python, the following\
    \ code implements the hashing technique for you using pythons built in hash function.\n\
    <code>\n// the hash function\ndef hash_long(x):\n    return hash(x) & (1<<63)\n\
    \    \n// an example of a hashing algorithm\nx = [hash_long(1) for _ in range(1000000)]\n\
    </code>\nNote that python does not have an equivalent for std.hash; however, you\
    \ can use the hash function from pythons built in hashing functions. Since you\
    \ were using std.type, you can use the std.hash.hash_long function from std.type.\n\
    <|/ a |>\n<| c |>\n`hash()` function does not exist in Python.\n<|/ c |>\n<| c\
    \ |>\nit does if you import the python standard library. Try it out.\n<|/ c |>\n\
    <| a tags=arrays,python,algorithm,python-3.x dscore=1 |>\n<code>\nimport random",
  "{\n    if(numbers == null)\n        return null;\n    long[] result = new long[numbers.length];\n\
    \    long[] seen = new long[numbers.length];\n    for(int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if(seen[numbers[i]] > 0)\n            continue;\n     \
    \   seen[numbers[i]] = 1;\n        result[numbers[i]] = numbers[i];\n    }\n \
    \   return result;\n}\n</code>\n<|/ a tags=arrays,sorting,java |>\n<| c |>\nThis\
    \ does not remove duplicates from the array, it just does a counting sort.\n<|/\
    \ c |>\n<| c |>\nAh yes, my bad. Thanks for pointing that out.\n<|/ c |>\n<| c\
    \ |>\nThis does remove duplicates from the array.\n<|/ c |>\n<| c |>\nSorry I\
    \ missed that. Yes it does. Thank you. I'll update the answer.\n<|/ c |>\n<| c\
    \ |>\nI think this is O(n^2). Although, it's certainly a lot cleaner than mine.\n\
    <|/ c |>\n<| a tags=arrays,sorting,java |>\n<code>\npackage com.example.test;\n\
    import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\
    import java.util.stream.Collectors;", "{\n    int i = 0;\n    int j = 0;\n   \
    \ long[] out = new long[numbers.length];\n    long t = 0;\n    \n    out[0] =\
    \ numbers[0];\n    \n    for (i = 1; i < numbers.length; ++i)\n    {\n       \
    \ j = i;\n        while (j < numbers.length && numbers[j] == numbers[j])\n   \
    \         ++j;\n        \n        if (j - i != 1)\n        {\n            out[i]\
    \ = numbers[j-1];\n            for (j = j - i; j < numbers.length; ++j)\n    \
    \            numbers[j] = numbers[j+1];\n        }\n    }\n    \n    return out;\n\
    }", "{\n\tlong result = 0;\n\tfor (int i = 0; i < numbers.length; ++i)\n\t{\n\t\
    \tint count = 0;\n\t\tfor (int j = i; j < numbers.length; ++j)\n\t\t{\n\t\t\t\
    if (numbers[j] == numbers[i])\n\t\t\t{\n\t\t\t\t++count;\n\t\t\t\tif (count >\
    \ 1)\n\t\t\t\t\tnumbers[j] = result;\n\t\t\t}\n\t\t}\n\t\tresult = numbers[i];\n\
    \t}\n\treturn numbers;\n}\n/*\n From an array of integers, remove all elements\
    \ that occur more than once.\n    Keep order of elements left the same as in the\
    \ input.\n    >>> remove_duplicates([1L, 2L, 3L, 2L, 4L])\n    [1L, 3L, 4L]\n\
    \    \n*/\nulong[] remove_duplicates(ulong[] numbers) \n{\n\tulong result = 0;\n\
    \tfor (int i = 0; i < numbers.length; ++i)\n\t{\n\t\tint count = 0;\n\t\tfor (int\
    \ j = i; j < numbers.length; ++j)\n\t\t{\n\t\t\tif (numbers[j] == numbers[i])\n\
    \t\t\t{\n\t\t\t\t++count;\n\t\t\t\tif (count > 1)\n\t\t\t\t\tnumbers[j] = result;\n\
    \t\t\t}\n\t\t}\n\t\tresult = numbers[i];\n\t}\n\treturn numbers;\n}\n/*\n From\
    \ an array of strings, remove all elements that occur more than once.\n    Keep\
    \ order of elements left the same as in the input.\n    >>> remove_duplicates([\"\
    one\", \"two\", \"one\", \"two\", \"two\"])\n    [\"one\", \"two\"]\n    \n*/\n\
    string[] remove_duplicates(string[] numbers) \n{\n\tstring result = \"\";\n\t\
    for (int i = 0; i < numbers.length; ++i)\n\t{\n\t\tint count = 0;\n\t\tfor (int\
    \ j = i; j < numbers.length; ++j)\n\t\t{\n\t\t\tif (numbers[j] == numbers[i])\n\
    \t\t\t{\n\t\t\t\t++count;\n\t\t\t\tif (count > 1)\n\t\t\t\t\tnumbers[j] = result;\n\
    \t\t\t}\n\t\t}\n\t\tresult = numbers[i];\n\t}\n\treturn numbers;\n}\n/*\n From\
    \ an array of structures, remove all elements that occur more than once.\n   \
    \ Keep order of elements left the same as in the input.\n    >>> remove_duplicates([{\"\
    one\"}, {\"two\"}, {\"one\"}, {\"two\"}, {\"two\"}])\n    [{\"one\"}, {\"two\"\
    }]\n    \n*/\nrecord[] remove_duplicates(record[] numbers) \n{\n\trecord result\
    \ = (record)0;\n\tfor (int i = 0; i < numbers.length; ++i)\n\t{\n\t\tint count\
    \ = 0;\n\t\tfor (int j = i; j < numbers.length; ++j)\n\t\t{\n\t\t\tif (numbers[j].a\
    \ == numbers[i].a && numbers[j].b == numbers[i].b && numbers[j].c == numbers[i].c)\n\
    \t\t\t{\n\t\t\t\t++count;\n\t\t\t\tif (count > 1)\n\t\t\t\t\tnumbers[j] = result;\n\
    \t\t\t}\n\t\t}\n\t\tresult = numbers[i];\n", "{\n    long[] output = new long[numbers.length];\n\
    \    \n    for (int i = 0; i < numbers.length; ++i) \n    {\n        bool found\
    \ = false;\n        for (int j = 0; j < i; ++j) \n        {\n            if (numbers[i]\
    \ == numbers[j])\n            {\n                found = true;\n             \
    \   break;\n            }\n        }\n        if (!found)\n        {\n       \
    \     output[i] = numbers[i];\n        }\n    }\n    \n    return output;\n}\n\
    </code>\n<|/ a |>\n<| a tags=c#,java,arrays |>\nThe only way I know how to do\
    \ this in Java is to create a new array of unique elements and copy the values\
    \ to the new array using an iterator.\n<code>\nArrayList<Integer> myList = new\
    \ ArrayList<Integer>();\nIterator<Integer> iter = myList.iterator();\nwhile(iter.hasNext())\n\
    {\n    Integer i = iter.next();\n    if(!myList.contains(i))\n    {\n        myList.add(i);\n\
    \    }\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI wouldn't say it's *the* only\
    \ way, but I think it's the most readable and maintainable.\n<|/ c |>\n<| c |>\n\
    What if `myList` contains duplicates? It won't be added to `myList`.\n<|/ c |>\n\
    <| c |>\nYou will need an additional `HashSet` since `ArrayList` does not contain\
    \ duplicates.\n<|/ c |>\n<| a tags=c#,java,arrays dscore=3 |>\nIf you use Guava,\
    \ you can use Sets.newSetFromArray() to create a Set from a List.\n<code>\nfinal\
    \ Set<Integer> numbers = Sets.newSetFromArray( new Integer[] {1,2,3,4,5,6,7,8,9,0,1,1,2,3,3,4});\n\
    </code>\n<|/ a |>\n<| a dscore=2 |>\n<code>\nimport java.util.Arrays;\nimport\
    \ java.util.HashSet;\nimport java.util.Set;", "{\n    int pos = 0;\n    long value\
    \ = 0;\n    long[] result = new long[numbers.length];", "{\n  int[] count = new\
    \ int[numbers.length];\n  for (int i = 0; i < numbers.length; i++) {\n    if (count[numbers[i]]\
    \ > 0) {\n      count[numbers[i]]--;\n    } else {\n      count[numbers[i]] =\
    \ numbers.length;\n    }\n  }\n  return numbers.length == 0 ? null : new long[count[numbers[0]]];\n\
    }\n</code>\n<|/ a tags=java |>\n<| a tags=java |>\nYou can use ArrayList.removeAll\n\
    <code>\n List<Integer> nums = new ArrayList<>();\n // fill the list\n nums.removeAll(Collections.singleton(num));\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nNote that this will actually remove num from\
    \ nums. If the original list contained num, then it'd be empty.\n<|/ c |>\n<|\
    \ c |>\nIt does not remove num from nums.\n<|/ c |>\n<| c |>\n- Not true. If you\
    \ print nums, it will contain num and nums.remove(num) will remove num from nums.\n\
    <|/ c |>\n<| c |>\nYou do not need to store nums in an ArrayList and then remove\
    \ it from nums. ArrayList.removeAll() will do it for you, if you provide a Collection\
    \ of Integers. Just pass in nums.\n<|/ c |>\n<| c |>\n, no, it does not. `removeAll()`\
    \ is a member of `Collections`, not `List`.\n<|/ c |>\n<| a dscore=2 tags=java\
    \ |>\n<code>\nList<Integer> inputList = new ArrayList<Integer>(Arrays.asList(new\
    \ Integer[]{2, 1, 2, 3, 3}));\nSet<Integer> set = new HashSet<Integer>();\nfor\
    \ (int i : inputList) {\n    set.add(Integer.valueOf(i));\n}\nList<Integer> result\
    \ = new ArrayList<Integer>(set);\n</code>\nOr the same without looping\n<code>\n\
    List<Integer> inputList = new ArrayList<Integer>(Arrays.asList(new Integer[]{2,\
    \ 1, 2, 3, 3}));\nSet<Integer> set = new HashSet<Integer>();\nset.addAll(inputList);\n\
    List<Integer> result = new ArrayList<Integer>(set);\n</code>\n<|/ a |>\n<| c |>\n\
    The first method uses O(n) memory, while the second one uses O(1) memory. The\
    \ second method also doesn't answer the question, since OP doesn't want the same\
    \ value repeated multiple times. For example, `[1, 2, 1, 2, 3, 3]` would return\
    \ `[1, 2, 3]` in the first method and `[2, 1]` in the second.\n<|/ c |>\n<| c\
    \ |>\nIn both of the cases, it would be O", "{\n    int n = numbers.length;\n\
    \    long[] result = new long[n];\n    long i;\n    \n    int[] count = new int[n];\n\
    \    for(i = 0; i < n; i++) count[numbers[i]]++;\n    \n    for(i = 0; i < n;\
    \ i++) {\n        if(count[numbers[i]] > 1) result[i] = numbers[i];\n        count[numbers[i]]--;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=duplicates,arrays,sorting,java\
    \ dscore=0 |>\n<| a |>\nI realize that my answer is late to the game, however,\
    \ I hope that others may benefit from my solution.\nI used the HashMap in Java\
    \ to eliminate duplicates.\n<code>\npublic class RemoveDuplicates\n{\n    public\
    \ static void main(String[] args)\n    {\n        int[] numbers = { 1, 1, 1, 2,\
    \ 2, 2, 3, 3, 3, 3, 3};", "{\n    if (numbers == null) throw new ArgumentNullException(\"\
    numbers\");\n    long[] result = new long[numbers.length];\n    int count = 0;\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        if (++count > 1)\
    \ result[i] = numbers[i];\n    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
